[
    {
        "link": "https://geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc",
        "document": "In C, a variable defined in a function is stored in the stack memory. The requirement of this memory is that it needs to know the size of the data to memory at compile time (before the program runs). Also, once defined, we can neither change the size nor completely delete the memory.\n\nTo resolve this, C provides a feature called Dynamic Memory Allocation. It allows you to allocate memory at runtime, giving your program the ability to handle data of varying sizes. Dynamic resources are stored in the heap memory instead of the stack.\n\nThis feature is useful in a variety of situations. For example, changing the size of an array according to our requirement.\n\nAs we know, the size of an array in C is fixed and should be known at compile time. There can be two problems:\n\nThe size of the array is not sufficient to store all the elements. To resolve this, one might set the size to store the maximum theoretically possible elements. This creates another problem.\n\nThis size of the array is much more than what is required to store the elements. This leads to the wastage of memory.\n\nThis is where the dynamic memory allocation comes in. The size of the array can be increased if more elements are to be inserted and decreased of less elements are inserted. Moreover, there is no need to estimate the max possible size. The size can be decided at runtime according to the requirement.\n\nDynamic memory allocation is possible in C by using 4 library functions provided by <stdlib.h> library:\n\nLet’s discuss each of them one by one.\n\nThe malloc() (stands for memory allocation) function is used to allocate a single block of contiguous memory on the heap at runtime. The memory allocated by malloc() is uninitialized, meaning it contains garbage values.\n\nwhere size is the number of bytes to allocate.\n\nThis function returns a void pointer to the allocated memory that needs to be converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nAssume that we want to create an array to store 5 integers. Since the size of int is 4 bytes, we need 5 * 4 bytes = 20 bytes of memory. This can be done as shown:\n\nIn the above malloc call, we hardcoded the number of bytes we need to store 5 integers. But we know that the size of the integer in C depends on the architecture. So, it is better to use the sizeof operator to find the size of type you want to store.\n\nMoreover, if there is no memory available, the malloc will fail and return NULL. So, it is recommended to check for failure by comparing the ptr to NULL.\n\nThe calloc() (stands for contiguous allocation) function is similar to malloc(), but it initializes the allocated memory to zero. It is used when you need memory with default zero values.\n\nwhere n is the number of elements and size is the size of each element in bytes.\n\nThis function also returns a void pointer to the allocated memory that is converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nWe can take the example of malloc() and try to do it with calloc() function.\n\nThe memory allocated using functions malloc() and calloc() is not de-allocated on their own. The free() function is used to release dynamically allocated memory back to the operating system. It is essential to free memory that is no longer needed to avoid memory leaks.\n\nwhere ptr is the pointer to the allocated memory.\n\nAfter freeing a memory block, the pointer becomes invalid, and it is no longer pointing to a valid memory location.\n\nAfter calling free(), it is a good practice to set the pointer to NULL to avoid using a “dangling pointer,” which points to a memory location that has been deallocated.\n\nrealloc() function is used to resize a previously allocated memory block. It allows you to change the size of an existing memory allocation without needing to free the old memory and allocate a new block.\n\nwhere, ptr is the pointer to the previously allocated memory block and new_size is the reallocated size that the memory block should have in bytes.\n\nThis function returns a pointer to the newly allocated memory, or NULL if the reallocation fails. If it fails, the original memory block remains unchanged.\n\nSuppose we initially allocate memory for 5 integers but later need to expand the array to hold 10 integers. We can use realloc() to resize the memory block:\n\nIt is important to note that if realloc() fails and returns NULL, the original memory block is not freed, so you should not overwrite the original pointer until you’ve successfully allocated a new block. To prevent memory leaks, it’s a good practice to handle the NULL return value carefully:\n\nConsider the first scenario where we were having issues with the fixes size array. Let’s see how we can resolve both of these issues using dynamic memory allocation.\n\nIn this program, we are managing the memory allocated to the pointer ptr according to our needs by changing the size using realloc(). It can be a fun exercise to implement an array which grows according to the elements inserted in it. This kind of arrays are called dynamically growing arrays.\n\nAs useful as dynamic memory allocation is, it is also prone to errors that requires careful handling to avoid the high memory usage or even system crashes. Few of the common errors are given below:\n• Dangling Pointers : Using a pointer after freeing its memory can cause undefined behavior or crashes.\n• Fragmentation : Repeated allocations and deallocations can fragment memory, causing inefficient use of heap space.\n• Allocation Failures : If memory allocation fails, the program may crash unless the error is handled properly.\n\nThe functions malloc() and calloc() works very similar to one another. So, why there was the need for two such similar functions.\n\nIt turns out that even though they are similar, they have different use cases due to the minor difference between them regarding the memory initialization. malloc() does not initialize memory while calloc() initializes the memory with zero.\n\nCan we only create arrays dynamically?\n\nWhat happens if memory allocation fails?\n\nWhat happens when you don’t free memory after allocating?\n\nWhat is the limit of memory that we can allocate using these functions?\n\nCan we set the new size of allocated memory to 0 with realloc()?"
    },
    {
        "link": "https://isocpp.org/wiki/faq/freestore-mgmt",
        "document": "How do I deal with memory leaks?\n\nBy writing code that doesn’t have any. Clearly, if your code has operations, operations, and pointer arithmetic all over the place, you are going to mess up somewhere and get leaks, stray pointers, etc. This is true independently of how conscientious you are with your allocations: eventually the complexity of the code will overcome the time and effort you can afford.\n\nIt follows that successful techniques rely on hiding allocation and deallocation inside more manageable types: For single objects, prefer or . For multiple objects, prefer using standard containers like and as they manage memory for their elements better than you could without disproportionate effort. Consider writing this without the help of and :\n\nWhat would be your chance of getting it right the first time? And how would you know you didn’t have a leak?\n\nNote the absence of explicit memory management, macros, casts, overflow checks, explicit size limits, and pointers. By using a function object and a standard algorithm, the code could additionally have eliminated the pointer-like use of the iterator, but that seemed overkill for such a tiny program.\n\nThese techniques are not perfect and it is not always easy to use them systematically. However, they apply surprisingly widely and by reducing the number of explicit allocations and deallocations you make the remaining examples much easier to keep track of. As early as 1981, Stroustrup pointed out that by reducing the number of objects that he had to keep track of explicitly from many tens of thousands to a few dozens, he had reduced the intellectual effort needed to get the program right from a Herculean task to something manageable, or even easy.\n\nIf your application area doesn’t have libraries that make programming that minimizes explicit memory management easy, then the fastest way of getting your program complete and correct might be to first build such a library.\n\nTemplates and the standard libraries make this use of containers, resource handles, etc., much easier than it was even a few years ago. The use of exceptions makes it close to essential.\n\nIf you cannot handle allocation/deallocation implicitly as part of an object you need in your application anyway, you can use a resource handle to minimize the chance of a leak. Here is an example where you need to return an object allocated on the free store from a function. This is an opportunity to forget to delete that object. After all, we cannot tell just looking at pointer whether it needs to be deallocated and if so who is responsible for that. Using a resource handle, here the standard library , makes it clear where the responsibility lies:\n\nThink about resources in general, rather than simply about memory.\n\nIf systematic application of these techniques is not possible in your environment (you have to use code from elsewhere, part of your program was written by Neanderthals, etc.), be sure to use a memory leak detector as part of your standard development procedure, or plug in a garbage collector.\n\nCan I use just as in Java?\n\nSort of, but don’t do it blindly, if you do want it prefer to spell it as or , and there are often superior alternatives that are simpler and more robust than any of that. Consider:\n\nThe clumsy use of for is unnecessary and slow compared with the idiomatic use of a local variable ( ). You don’t need to use to create an object if you also that object in the same scope; such an object should be a local variable.\n\nShould I use or or ?\n\nYou should use as the null pointer value. The others still work for backward compatibility with older code.\n\nA problem with both and as a null pointer value is that is a special “maybe an integer value and maybe a pointer” value. Use only for integers, and that confusion disappears.\n\nDoes delete the pointer , or the pointed-to-data ?\n\nThe keyword should really be . The same abuse of English occurs when ing the memory pointed to by a pointer in C: really means .\n\nIs it safe to the same pointer twice?\n\nNo! (Assuming you didn’t get that pointer back from in between.)\n\nFor example, the following is a disaster:\n\nThat second line might do some really bad things to you. It might, depending on the phase of the moon, corrupt your heap, crash your program, make arbitrary and bizarre changes to objects that are already out there on the heap, etc. Unfortunately these symptoms can appear and disappear randomly. According to Murphy’s law, you’ll be hit the hardest at the worst possible moment (when the customer is looking, when a high-value transaction is trying to post, etc.).\n\nNote: some runtime systems will protect you from certain very simple cases of double . Depending on the details, you might be okay if you happen to be running on one of those systems and if no one ever deploys your code on another system that handles things differently and if you are deleting something that doesn’t have a destructor and if you don’t do anything significant between the two s and if no one ever changes your code to do something significant between the two s and if your thread scheduler (over which you likely have no control!) doesn’t happen to swap threads between the two s and if, and if, and if. So back to Murphy: since it can go wrong, it will, and it will go wrong at the worst possible moment.\n\nDo NOT email me saying you tested it and it doesn’t crash. Get a clue. A non-crash doesn’t prove the absence of a bug; it merely fails to prove the presence of a bug.\n\nTrust me: double- is bad, bad, bad. Just say no.\n\nCan I pointers allocated with ? Can I pointers allocated with ?\n\nNo! In brief, conceptually and allocate from different heaps, so can’t or each other’s memory. They also operate at different levels – raw memory vs. constructed objects.\n\nYou can use and in the same program. But you cannot allocate an object with and free it using . Nor can you allocate with and with or use on an array allocated by .\n\nThe C++ operators and guarantee proper construction and destruction; where constructors or destructors need to be invoked, they are. The C-style functions , , , and don’t ensure that. Furthermore, there is no guarantee that the mechanism used by and to acquire and release raw memory is compatible with and . If mixing styles works on your system, you were simply “lucky” – for now.\n\nIf you feel the need for – and many do – then consider using a standard library . For example\n\nSee also the examples and discussion in “Learning Standard C++ as a New Language”, which you can download from Stroustrup’s publications list.\n\nWhat is the difference between and ?\n\nFirst, (or ) are nearly always superior to both and and completely eliminate and .\n\nHaving said that, here’s the difference between those two:\n\nis a function that takes a number (of bytes) as its argument; it returns a pointing to unitialized storage. is an operator that takes a type and (optionally) a set of initializers for that type as its arguments; it returns a pointer to an (optionally) initialized object of its type. The difference is most obvious when you want to allocate an object of a user-defined type with non-trivial initialization semantics. Examples:\n\nNote that when you specify a initializer using the “(value)” notation, you get initialization with that value. Often, a is a better alternative to a free-store-allocated array (e.g., consider exception safety).\n\nWhenever you use you must consider initialization and conversion of the return pointer to a proper type. You will also have to consider if you got the number of bytes right for your use. There is no performance difference between and when you take initialization into account.\n\nreports memory exhaustion by returning . reports allocation and initialization errors by throwing exceptions ( ).\n\nObjects created by are destroyed by . Areas of memory allocated by are deallocated by .\n\nWhy should I use instead of trustworthy old ?\n\nFirst, (or ) are nearly always superior to both and and completely eliminate and .\n\nHaving said that, benefits of using instead of are: Constructors/destructors, type safety, overridability.\n• Type safety: returns a which isn’t type safe. returns a pointer of the right type (a ).\n• Overridability: is an that can be overridden by a class, while is not overridable on a per-class basis.\n\nCan I use on pointers allocated via ?\n\nWhen has to copy the allocation, it uses a bitwise copy operation, which will tear many C++ objects to shreds. C++ objects should be allowed to copy themselves. They use their own copy constructor or assignment operator.\n\nBesides all that, the heap that uses may not be the same as the heap that and use!\n\nWhy doesn’t C++ have an equivalent to ?\n\nIf you want to, you can of course use . However, is only guaranteed to work on arrays allocated by (and similar functions) containing objects without user-defined copy constructors. Also, please remember that contrary to naive expectations, occasionally does copy its argument array.\n\nIn C++, a better way of dealing with reallocation is to use a standard library container, such as , and let it grow naturally.\n\nDo I need to check for null after ?\n\nNo! (But if you have an ancient, stone-age compiler, you may have to force the operator to an exception if it runs out of memory.)\n\nIt turns out to be a real pain to always write explicit tests after every allocation. Code like the following is very tedious:\n\nIf your compiler doesn’t support (or if you refuse to use) exceptions, your code might be even more tedious:\n\nTake heart. In C++, if the runtime system cannot allocate bytes of memory during , a exception will be thrown. Unlike , never returns null!\n\nTherefore you should simply write:\n\nOn the second thought. Scratch that. You should simply write:\n\nThere, there… Much better now!\n\nHowever, if your compiler is ancient, it may not yet support this. Find out by checking your compiler’s documentation under “ ”. If it is ancient, you may have to force the compiler to have this behavior.\n\nHow can I convince my (older) compiler to automatically check to see if it returns null?\n\nIf you have an old compiler that doesn’t automagically perform the null test, you can force the runtime system to do the test by installing a “new handler” function. Your “new handler” function can do anything you want, such as an exception, some objects and return (in which case will retry the allocation), print a message and the program, etc.\n\nHere’s a sample “new handler” that prints a message and s an exception. The handler is installed using :\n\nAfter the line is executed, will call your if/when it runs out of memory. This means that will never return null:\n\nNote: If your compiler doesn’t support exception handling, you can, as a last resort, change the line … to:\n\nNote: If some namespace-scope / global / static object’s constructor uses , it might not use the function since that constructor often gets called before begins. Unfortunately there’s no convenient way to guarantee that the will be called before the first use of . For example, even if you put the call in the constructor of a global object, you still don’t know if the module (“compilation unit”) that contains that global object will be elaborated first or last or somewhere inbetween. Therefore you still don’t have any guarantee that your call of will happen before any other namespace-scope / global’s constructor gets invoked.\n\nDo I need to check for null before ?\n\nThe C++ language guarantees that will do nothing if is null. Since you might get the test backwards, and since most testing methodologies force you to explicitly test every branch point, you should not put in the redundant test.\n\nWhat are the two steps that happen when I say ?\n\nis a two-step process: it calls the destructor, then releases the memory. The code generated for is functionally similar to this (assuming is of type ):\n\nThe statement calls the destructor for the object pointed to by .\n\nThe statement calls the memory deallocation primitive, . This primitive is similar in spirit to . (Note, however, that these two are not interchangeable; e.g., there is no guarantee that the two memory deallocation primitives even use the same heap!)\n\nWhy doesn’t null out its operand?\n\nFirst, you should normally be using smart pointers, so you won’t care – you won’t be writing anyway.\n\nFor those rare cases where you really are doing manual memory management and so do care, consider:\n\nIf the part doesn’t touch then the second is a serious error that a C++ implementation cannot effectively protect itself against (without unusual precautions). Since deleting a null pointer is harmless by definition, a simple solution would be for to do a after it has done whatever else is required. However, C++ doesn’t guarantee that.\n\nOne reason is that the operand of need not be an lvalue. Consider:\n\nHere, the implementation of does not have a pointer to which it can null out. These examples may be rare, but they do imply that it is not possible to guarantee that “any pointer to a deleted object is null.” A simpler way of bypassing that “rule” is to have two pointers to an object:\n\nC++ explicitly allows an implementation of to null out an lvalue operand, but that idea doesn’t seem to have become popular with implementers.\n\nIf you consider zeroing out pointers important, consider using a destroy function:\n\nConsider this yet-another reason to minimize explicit use of and by relying on standard library smart pointers, containers, handles, etc.\n\nNote that passing the pointer as a reference (to allow the pointer to be nulled out) has the added benefit of preventing from being called for an rvalue:\n\nWhy isn’t the destructor called at the end of scope?\n\nThe simple answer is “of course it is!”, but have a look at the kind of example that often accompany that question:\n\nThat is, there was some (mistaken) assumption that the object created by would be destroyed at the end of a function.\n\nBasically, you should only use heap allocation if you want an object to live beyond the lifetime of the scope you create it in. Even then, you should normally use or . In those rare cases where you do want heap allocation and you opt to use , you need to use to destroy the object. For example:\n\nIf you want an object to live in a scope only, don’t use heap allocation at all but simply define a variable:\n\nThe variable is implicitly destroyed at the end of the scope.\n\nCode that creates an object using and then s it at the end of the same scope is ugly, error-prone, inefficient, and usually not exception-safe. For example:\n\nIn , does the memory “leak” if the constructor throws an exception?\n\nIf an exception occurs during the constructor of , the C++ language guarantees that the memory bytes that were allocated will automagically be released back to the heap.\n\nHere are the details: is a two-step process:\n• bytes of memory are allocated using the primitive . This primitive is similar in spirit to . (Note, however, that these two are not interchangeable; e.g., there is no guarantee that the two memory allocation primitives even use the same heap!).\n• It constructs an object in that memory by calling the constructor. The pointer returned from the first step is passed as the parameter to the constructor. This step is wrapped in a … block to handle the case when an exception is thrown during this step.\n\nThus the actual generated code is functionally similar to:\n\nThe statement marked “Placement ” calls the constructor. The pointer becomes the pointer inside the constructor, .\n\nHow do I allocate / unallocate an array of things?\n\nAny time you allocate an array of objects via (usually with the n in the expression), you must use in the statement. This syntax is necessary because there is no syntactic difference between a pointer to a thing and a pointer to an array of things (something we inherited from C).\n\nWhat if I forget the when ing an array allocated via ?\n\nAll life comes to a catastrophic end.\n\nIt is the programmer’s —not the compiler’s— responsibility to get the connection between and correct. If you get it wrong, neither a compile-time nor a run-time error message will be generated by the compiler. Heap corruption is a likely result. Or worse. Your program will probably die.\n\nCan I drop the when ing an array of some built-in type ( , , etc)?\n\nSometimes programmers think that the in the only exists so the compiler will call the appropriate destructors for all elements in the array. Because of this reasoning, they assume that an array of some built-in type such as or can be d without the . E.g., they assume the following is valid code:\n\nBut the above code is wrong, and it can cause a disaster at runtime. In particular, the code that’s called for is , but the code that’s called for is . The default behavior for the latter is to call the former, but users are allowed to replace the latter with a different behavior (in which case they would normally also replace the corresponding code in ). If they replaced the code so it wasn’t compatible with the code, and you called the wrong one (i.e., if you said rather than ), you could end up with a disaster at runtime.\n\nAfter , how does the compiler know there are objects to be destructed during ?\n\nLong answer: The run-time system stores the number of objects, , somewhere where it can be retrieved if you only know the pointer, . There are two popular techniques that do this. Both these techniques are in use by commercial-grade compilers, both have tradeoffs, and neither is perfect. These techniques are:\n• Over-allocate the array and put just to the left of the first object.\n• Use an associative array with as the key and as the value.\n\nIs it legal (and moral) for a member function to say ?\n\nAs long as you’re careful, it’s okay (not evil) for an object to commit suicide ( ).\n• You must be absolutely 100% positively sure that object was allocated via (not by , nor by placement , nor a local object on the stack, nor a namespace-scope / global, nor a member of another object; but by plain ordinary ).\n• You must be absolutely 100% positively sure that your member function will be the last member function invoked on object.\n• You must be absolutely 100% positively sure that the rest of your member function (after the line) doesn’t touch any piece of object (including calling any other member functions or touching any data members). This includes code that will run in destructors for any objects allocated on the stack that are still alive.\n• You must be absolutely 100% positively sure that no one even touches the pointer itself after the line. In other words, you must not examine it, compare it with another pointer, compare it with , print it, cast it, do anything with it.\n\nNaturally the usual caveats apply in cases where your pointer is a pointer to a base class when you don’t have a virtual destructor.\n\nHow do I allocate multidimensional arrays using ?\n\nThere are many ways to do this, depending on how flexible you want the array sizing to be. On one extreme, if you know all the dimensions at compile-time, you can allocate multidimensional arrays statically (as in C):\n\nMore commonly, the size of the matrix isn’t known until run-time but you know that it will be rectangular. In this case you need to use the heap (“freestore”), but at least you are able to allocate all the elements in one freestore chunk.\n\nFinally at the other extreme, you may not even be guaranteed that the matrix is rectangular. For example, if each row could have a different length, you’ll need to allocate each row individually. In the following function, is the number of columns in row number , where varies between and inclusive.\n\nNote the funny use of in the deletion process. This prevents wrap-around of the value when goes one step below zero.\n\nFinally, note that pointers and arrays are evil. It is normally much better to encapsulate your pointers in a class that has a safe and simple interface. The following FAQ shows how to do this.\n\nBut the previous FAQ’s code is SOOOO tricky and error prone! Isn’t there a simpler way?\n\nThe reason the code in the previous FAQ was so tricky and error prone was that it used pointers, and we know that pointers and arrays are evil. The solution is to encapsulate your pointers in a class that has a safe and simple interface. For example, we can define a class that handles a rectangular matrix so our user code will be vastly simplified when compared to the the rectangular matrix code from the previous FAQ:\n\nThe main thing to notice is the lack of clean-up code. For example, there aren’t any statements in the above code, yet there will be no memory leaks, assuming only that the destructor does its job correctly.\n\nHere’s the code that makes the above possible:\n\nNote that the above class accomplishes two things: it moves some tricky memory management code from the user code (e.g., ) to the class, and it reduces the overall bulk of program. The latter point is important. For example, assuming is even mildly reusable, moving complexity from the users [plural] of into itself [singular] is equivalent to moving complexity from the many to the few. Anyone who has seen Star Trek 2 knows that the good of the many outweighs the good of the few… or the one.\n\nBut the above class is specific to ! Isn’t there a way to make it generic?\n\nHere’s how this can be used:\n\nNow it’s easy to use for things other than . For example, the following uses a of (where is the standard string class):\n\nYou can thus get an entire family of classes from a template. For example, , , , etc.\n\nHere’s one way that the template can be implemented:\n\nWhat’s another way to build a template?\n\nUse the standard template, and make a of .\n\nThe following uses a .\n\nNote how much simpler this is than the previous: there is no explicit in the constructor, and there is no need for any of The Big Three (destructor, copy constructor or assignment operator). Simply put, your code is a lot less likely to have memory leaks if you use than if you use explicit and .\n\nNote also that doesn’t force you to allocate numerous chunks of memory. If you prefer to allocate only one chunk of memory for the entire matrix, as was done in the previous, just change the type of to and add member variables and . You’ll figure out the rest: initialize using , change to , etc.\n\nDoes C++ have arrays whose length can be specified at run-time?\n\nYes, in the sense that the standard library has a template that provides this behavior.\n\nNo, in the sense that built-in array types need to have their length specified at compile time.\n\nYes, in the sense that even built-in array types can specify the first index bounds at run-time. E.g., comparing with the previous FAQ, if you only need the first array dimension to vary then you can just ask new for an array of arrays, rather than an array of pointers to arrays:\n\nYou can’t do this if you need anything other than the first dimension of the array to change at run-time.\n\nBut please, don’t use arrays unless you have to. Arrays are evil. Use some object of some class if you can. Use arrays only when you have to.\n\nHow can I force objects of my class to always be created via rather than as local, namespace-scope, global, or ?\n\nAs usual with the Named Constructor Idiom, the constructors are all or , and there are one or more methods (the so-called “named constructors”), one per constructor. In this case the methods allocate the objects via . Since the constructors themselves are not , there is no other way to create objects of the class.\n\nNow the only way to create objects is via :\n\nMake sure your constructors are in the section if you expect to have derived classes.\n\nNote also that you can make another class a of if you want to allow a to have a member object of class , but of course this is a softening of the original goal, namely to force objects to be allocated via .\n\nHow do I do simple reference counting?\n\nIf all you want is the ability to pass around a bunch of pointers to the same object, with the feature that the object will automagically get d when the last pointer to it disappears, you can use something like the following “smart pointer” class:\n\nNaturally you can use nested classes to rename to .\n\nNote that you can soften the “never ” rule above with a little more checking in the constructor, copy constructor, assignment operator, and destructor. If you do that, you might as well put a check into the “ ” and “ ” operators (at least as an ). I would recommend against an method, since that would let people accidentally get at the .\n\nOne of the implicit constraints on is that it must only point to objects which have been allocated via . If you want to be really safe, you can enforce this constraint by making all of ’s constructors , and for each constructor have a ( ) method which allocates the object via and returns a (not a ). That way the only way anyone could create a object would be to get a (“ ” would be replaced by “ ”). Thus no one could accidentally subvert the reference counting mechanism.\n\nFor example, if had a and a , the changes to would be:\n\nThe end result is that you now have a way to use simple reference counting to provide “pointer semantics” for a given object. Users of your explicitly use objects, which act more or less like pointers. The benefit is that users can make as many copies of their “smart pointer” objects, and the pointed-to object will automagically get d when the last such object vanishes.\n\nIf you’d rather give your users “reference semantics” rather than “pointer semantics,” you can use reference counting to provide “copy on write”.\n\nHow do I provide reference counting with copy-on-write semantics?\n\nReference counting can be done with either pointer semantics or reference semantics. The previous FAQ shows how to do reference counting with pointer semantics. This FAQ shows how to do reference counting with reference semantics.\n\nThe basic idea is to allow users to think they’re copying your objects, but in reality the underlying implementation doesn’t actually do any copying unless and until some user actually tries to modify the underlying object.\n\nClass houses all the data that would normally go into the . also has an extra data member, , to manage the reference counting. Class ends up being a “smart reference” that (internally) points to a .\n\nIf it is fairly common to call ’s default constructor, you can avoid all those calls by sharing a common object for all s that are constructed via . To avoid initialization order problems, this shared object is created “on first use” inside a function. Here are the changes that would be made to the above code (note that the shared object’s destructor is never invoked; if that is a problem, either hope you don’t have any initialization order problems, or drop back to the approach described above):\n\nNote: You can also provide reference counting for a hierarchy of classes if your class would normally have been a base class.\n\nHow do I provide reference counting with copy-on-write semantics for a hierarchy of classes?\n\nThe previous FAQ presented a reference counting scheme that provided users with reference semantics, but did so for a single class rather than for a hierarchy of classes. This FAQ extends the previous technique to allow for a hierarchy of classes. The basic difference is that is now the root of a hierarchy of classes, which probably cause it to have some functions. Note that class itself will still not have any functions.\n\nThe Virtual Constructor Idiom is used to make copies of the objects. To select which derived class to create, the sample code below uses the Named Constructor Idiom, but other techniques are possible (a statement in the constructor, etc). The sample code assumes two derived classes: and . Methods in the derived classes are unaware of the reference counting.\n\nNaturally the constructors and methods for and will need to be implemented in whatever way is appropriate.\n\nCan I absolutely prevent people from subverting the reference counting mechanism, and if so, should I?\n\nNo, and (normally) no.\n\nThere are two basic approaches to subverting the reference counting mechanism:\n• The scheme could be subverted if someone got a (rather than being forced to use a ). Someone could get a if class has an that returns a : . Yes it’s bizarre and unexpected, but it could happen. This hole could be closed in two ways: overload so it returns a , or change the return type of so it returns a ( would be a class that simulates a reference; it would need to have all the methods that has, and it would need to forward all those method calls to the underlying object; there might be a performance penalty for this second choice depending on how good the compiler is at inlining methods). Another way to fix this is to eliminate — and lose the corresponding ability to get and use a . But even if you did all this, someone could still generate a by explicitly calling : .\n• The scheme could be subverted if someone had a leak and/or dangling pointer to a . Basically what we’re saying here is that is now safe, but we somehow want to prevent people from doing stupid things with objects. (And if we could solve that via objects, we’d have the same problem again with them). One hole here is if someone created a using , then allowed the to leak (worst case this is a leak, which is bad but is usually a little better than a dangling pointer). This hole could be plugged by declaring as , thus preventing someone from saying . Another hole here is if someone creates a local object, then takes the address of that and passed around the . If that lived longer than the , you could have a dangling pointer — shudder. This hole could be plugged by preventing people from taking the address of a (by overloading as ), with the corresponding loss of functionality. But even if you did all that, they could still create a which is almost as dangerous as a , simply by doing this: (or by passing the to someone else).\n\nAnd even if we closed all those holes, C++ has those wonderful pieces of syntax called pointer casts. Using a pointer cast or two, a sufficiently motivated programmer can normally create a hole that’s big enough to drive a proverbial truck through. (By the way, pointer casts are evil.)\n\nSo the lessons here seem to be: (a) you can’t prevent espionage no matter how hard you try, and (b) you can easily prevent mistakes.\n\nSo I recommend settling for the “low hanging fruit”: use the easy-to-build and easy-to-use mechanisms that prevent mistakes, and don’t bother trying to prevent espionage. You won’t succeed, and even if you do, it’ll (probably) cost you more than it’s worth.\n\nSo if we can’t use the C++ language itself to prevent espionage, are there other ways to do it? Yes. I personally use old fashioned code reviews for that. And since the espionage techniques usually involve some bizarre syntax and/or use of pointer-casts and unions, you can use a tool to point out most of the “hot spots.”\n\nCan I use a garbage collector in C++?\n\nIf you want automatic garbage collection, there are good commercial and public-domain garbage collectors for C++. For applications where garbage collection is suitable, C++ is an excellent garbage collected language with a performance that compares favorably with other garbage collected languages. See The C++ Programming Language (4th Edition) for a discussion of automatic garbage collection in C++. See also, Hans-J. Boehm’s site for C and C++ garbage collection.\n\nAlso, C++ supports programming techniques that allows memory management to be safe and implicit without a garbage collector. Garbage collection is useful for specific needs, such as inside the implementation of lock-free data structures to avoid ABA issues, but not as a general-purpose default way of handling for resource management. We are not saying that GC is not useful, just that there are better approaches in many situations.\n\nCompared with the “smart pointer” techniques, the two kinds of garbage collector techniques are:\n• usually more efficient (especially when the average object size is small or in multithreaded environments)\n• able to handle “cycles” in the data (reference counting techniques normally “leak” if the data structures can form a cycle)\n• sometimes leak other objects (since the garbage collectors are necessarily conservative, they sometimes see a random bit pattern that appears to be a pointer into an allocation, especially if the allocation is large; this can allow the allocation to leak)\n• work better with existing libraries (since smart pointers need to be used explicitly, they may be hard to integrate with existing libraries)\n\nWhat are the two kinds of garbage collectors for C++?\n\nIn general, there seem to be two flavors of garbage collectors for C++:\n• Conservative garbage collectors. These know little or nothing about the layout of the stack or of C++ objects, and simply look for bit patterns that appear to be pointers. In practice they seem to work with both C and C++ code, particularly when the average object size is small. Here are some examples, in alphabetical order:\n• Hybrid garbage collectors. These usually scan the stack conservatively, but require the programmer to supply layout information for heap objects. This requires more work on the programmer’s part, but may result in improved performance. Here are some examples, in alphabetical order:\n\nSince garbage collectors for C++ are normally conservative, they can sometimes leak if a bit pattern “looks like” it might be a pointer to an otherwise unused block. Also they sometimes get confused when pointers to a block actually point outside the block’s extent (which is illegal, but some programmers simply must push the envelope; sigh) and (rarely) when a pointer is hidden by a compiler optimization. In practice these problems are not usually serious, however providing the collector with hints about the layout of the objects can sometimes ameliorate these issues.\n\nWhere can I get more info on garbage collectors for C++?\n\nFor more information, see the Garbage Collector FAQ.\n\nWhat is an and why isn’t there an ?\n\nIt’s now spelled , which supports both single objects and arrays.\n\nis an old standard smart pointer that has been deprecated, and is only being kept in the standard for backward compatibility with older code. It should not be used in new code."
    },
    {
        "link": "https://stackoverflow.com/questions/8477110/which-c-standard-library-functions-use-malloc-under-the-hood",
        "document": "Usually, the only routines in the C99 standard that might use are the standard I/O functions (in where the file structure and the buffer used by it is often allocated as if by . Some of the locale handling may use dynamic memory. All the other routines have no need for dynamic memory allocation in general.\n\nNow, is any of that formally documented? No, I don't think it is. There is no blanket restriction 'the functions in the library shall not use '. (There are, however, restrictions on other functions - such as and and ; they may not be used by the implementation, and the implementation may not use any of the other functions that may return a pointer to a static memory location.) However, one of the reasons why the extremely useful function is not in the standard C library is (reportedly) because it does memory allocation. It also isn't completely clear whether this was a factor in the routines such as and in TR 24731-2 not making it into C1x, but it could have been a factor."
    },
    {
        "link": "https://en.cppreference.com/w/c/memory/malloc",
        "document": "If allocation succeeds, returns a pointer that is suitably aligned for any object type with fundamental alignment.\n\nIf is zero, the behavior of is implementation-defined. For example, a null pointer may be returned. Alternatively, a non-null pointer may be returned; but such a pointer should not be dereferenced, and should be passed to free to avoid memory leaks.\n\nis thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage. A previous call to free, free_sized, and free_aligned_sized(since C23) or realloc that deallocates a region of memory synchronizes-with a call to that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by . There is a single total order of all allocation and deallocation functions operating on each particular region of memory.\n\nOn success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with free() or realloc()."
    },
    {
        "link": "https://stackoverflow.com/questions/13442375/best-practice-for-allocating-memory-for-use-by-a-function-malloc-inside-or-out",
        "document": "The criteria I'd use for deciding are:\n• None If the code outside the called function can know how much memory to allocate, then it is better to have the calling code allocate the memory.\n• None If the code outside the called function cannot know how much memory to allocate, then the called function must do the memory allocation. It is likely then that there will be a second function available to release the memory returned by the first function (the 'called' function), unless it is just a single that's needed. The function documentation should make this clear.\n\nFor example, if the called function is reading a complete tree structure from a file, the function will have to allocate the memory. But, there will also be a companion function for releasing the memory (since the called code knows how to do it and the calling code shouldn't need to know).\n\nOn the other hand, if the called function is reading a simple list of integer and floating point values into a fixed size structure, it is far better to make the calling function allocate the memory. Note that I skipped 'strings'! If the strings are of a fixed size in the structure, then the calling function can do the allocation, but if the strings are of variable size, then probably the called function does the allocation.\n\nThe Standard C Library has functions like which expect the calling code to allocate the memory to be used. The calling sequence tells how much space is available. You run into problems if you didn't provide enough memory. (The problem with is that you may only get the start of a line of text, not the whole line of text.)\n\nThe POSIX 2008 Library provides which will allocate enough space for the line.\n\nThe and related functions (see TR24731-2) allocate memory as required. The function does not — it is told how much space there is available, it uses no more than that, and says how much it really needed, and it is up to you to note if you didn't provide enough space and do something about it (allocate more space and try again, or blithely ignore the truncated value and continue as if nothing went wrong)."
    },
    {
        "link": "https://geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc",
        "document": "In C, a variable defined in a function is stored in the stack memory. The requirement of this memory is that it needs to know the size of the data to memory at compile time (before the program runs). Also, once defined, we can neither change the size nor completely delete the memory.\n\nTo resolve this, C provides a feature called Dynamic Memory Allocation. It allows you to allocate memory at runtime, giving your program the ability to handle data of varying sizes. Dynamic resources are stored in the heap memory instead of the stack.\n\nThis feature is useful in a variety of situations. For example, changing the size of an array according to our requirement.\n\nAs we know, the size of an array in C is fixed and should be known at compile time. There can be two problems:\n\nThe size of the array is not sufficient to store all the elements. To resolve this, one might set the size to store the maximum theoretically possible elements. This creates another problem.\n\nThis size of the array is much more than what is required to store the elements. This leads to the wastage of memory.\n\nThis is where the dynamic memory allocation comes in. The size of the array can be increased if more elements are to be inserted and decreased of less elements are inserted. Moreover, there is no need to estimate the max possible size. The size can be decided at runtime according to the requirement.\n\nDynamic memory allocation is possible in C by using 4 library functions provided by <stdlib.h> library:\n\nLet’s discuss each of them one by one.\n\nThe malloc() (stands for memory allocation) function is used to allocate a single block of contiguous memory on the heap at runtime. The memory allocated by malloc() is uninitialized, meaning it contains garbage values.\n\nwhere size is the number of bytes to allocate.\n\nThis function returns a void pointer to the allocated memory that needs to be converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nAssume that we want to create an array to store 5 integers. Since the size of int is 4 bytes, we need 5 * 4 bytes = 20 bytes of memory. This can be done as shown:\n\nIn the above malloc call, we hardcoded the number of bytes we need to store 5 integers. But we know that the size of the integer in C depends on the architecture. So, it is better to use the sizeof operator to find the size of type you want to store.\n\nMoreover, if there is no memory available, the malloc will fail and return NULL. So, it is recommended to check for failure by comparing the ptr to NULL.\n\nThe calloc() (stands for contiguous allocation) function is similar to malloc(), but it initializes the allocated memory to zero. It is used when you need memory with default zero values.\n\nwhere n is the number of elements and size is the size of each element in bytes.\n\nThis function also returns a void pointer to the allocated memory that is converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nWe can take the example of malloc() and try to do it with calloc() function.\n\nThe memory allocated using functions malloc() and calloc() is not de-allocated on their own. The free() function is used to release dynamically allocated memory back to the operating system. It is essential to free memory that is no longer needed to avoid memory leaks.\n\nwhere ptr is the pointer to the allocated memory.\n\nAfter freeing a memory block, the pointer becomes invalid, and it is no longer pointing to a valid memory location.\n\nAfter calling free(), it is a good practice to set the pointer to NULL to avoid using a “dangling pointer,” which points to a memory location that has been deallocated.\n\nrealloc() function is used to resize a previously allocated memory block. It allows you to change the size of an existing memory allocation without needing to free the old memory and allocate a new block.\n\nwhere, ptr is the pointer to the previously allocated memory block and new_size is the reallocated size that the memory block should have in bytes.\n\nThis function returns a pointer to the newly allocated memory, or NULL if the reallocation fails. If it fails, the original memory block remains unchanged.\n\nSuppose we initially allocate memory for 5 integers but later need to expand the array to hold 10 integers. We can use realloc() to resize the memory block:\n\nIt is important to note that if realloc() fails and returns NULL, the original memory block is not freed, so you should not overwrite the original pointer until you’ve successfully allocated a new block. To prevent memory leaks, it’s a good practice to handle the NULL return value carefully:\n\nConsider the first scenario where we were having issues with the fixes size array. Let’s see how we can resolve both of these issues using dynamic memory allocation.\n\nIn this program, we are managing the memory allocated to the pointer ptr according to our needs by changing the size using realloc(). It can be a fun exercise to implement an array which grows according to the elements inserted in it. This kind of arrays are called dynamically growing arrays.\n\nAs useful as dynamic memory allocation is, it is also prone to errors that requires careful handling to avoid the high memory usage or even system crashes. Few of the common errors are given below:\n• Dangling Pointers : Using a pointer after freeing its memory can cause undefined behavior or crashes.\n• Fragmentation : Repeated allocations and deallocations can fragment memory, causing inefficient use of heap space.\n• Allocation Failures : If memory allocation fails, the program may crash unless the error is handled properly.\n\nThe functions malloc() and calloc() works very similar to one another. So, why there was the need for two such similar functions.\n\nIt turns out that even though they are similar, they have different use cases due to the minor difference between them regarding the memory initialization. malloc() does not initialize memory while calloc() initializes the memory with zero.\n\nCan we only create arrays dynamically?\n\nWhat happens if memory allocation fails?\n\nWhat happens when you don’t free memory after allocating?\n\nWhat is the limit of memory that we can allocate using these functions?\n\nCan we set the new size of allocated memory to 0 with realloc()?"
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/udn4ca/what_are_good_projects_to_get_comfortable_with",
        "document": "I’ve quite a few projects, and I’ve learned quite a bit, but none have really forced me to use pointers.\n\nI’ve implemented malloc() and free() in my OS course, but implementing library functions lack the pazazz of implementing an NES"
    },
    {
        "link": "https://embedded.com/best-practices-to-safely-navigate-pointers-in-c-c",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/722922/best-way-to-handle-memory-allocation-in-c",
        "document": "I know this is an old post but there hasn't really been much of a comprehensive answer to best practice in terms of style, which I think is what the op really wanted, so here is my take on memory allocation in C. Note I am more of a C++ person so much of my thoughts come from that attitude.\n\nIt is often handy to know whether your pointer is allocated, so always assign NULL to a pointer when you declare it. You can also create yourself a safe free function which frees the memory and then assigns NULL to it so you don't have to worry.\n\nIf you allocate memory in one C file then you should free it in the same file. This is perhaps more restrictive than needed, however if you are writing a library then you should definitely free any memory within your library that is malloc'd in your library. This is because on Windows dlls have a different heap to the exe, so mallocing memory in a dll and freeing it in the exe corrupts your heap.\n\nBy extension and for the sake of symmetry this means if you have a function which returns a pointer to allocated memory then you should have a function which frees that memory. This is why many librarys have an initialisation function which returns a pointer to some data (generally cast as a void *) then a cleanup function which will free the library's resources. If you can malloc and free within the same function then that is good as it makes it easy for you to keep track of things.\n\nDo not try to allocate all your memory at the beginning of a function and then free it at the end. This just means that if you want to return part way through the function you have to free all the memory, whereas if you malloc and free memory as you go you will have fewer pointers to free.\n\nIf you often have functions which allocate many pointers, then consider creating and array which holds pointers to all your pointers at the beginning of the function, then have a function that frees them all. This will save you the inevitable \"I'll come back and sort my memory leaks later\" syndrome if you want to return mid function.\n\nThe concept of factories is useful. A factory would be a function which mallocs the memory for a struct, assigns function pointer to the struct, initialises its variables and then returns the pointer to it. If the first of those was a destructor or an array of specific functions then you can have a generic destroy function that can call any struct's destructor, then free the struct's memory. You can also hide some of the internal details of the class by having different inward and outward facing definition of the struct. COM is built upon these principles.\n\nSo these are just the ways I look at memory in C. It isn't as elegant as in C++, but as you are relying on humans to deal with it, there are strategies like those above that can make things as simple as possible for them.\n\nNote also that there are always exceptions to every rule - these are just things that I think about when I use C. I'm sure other people have other ideas."
    },
    {
        "link": "https://perfectelearning.com/blog/efficient-memory-management-with-pointers-best-practices",
        "document": "Boost your C program's performance with efficient memory management techniques using pointers. Optimize memory allocation and deallocation for maximum speed!\n\n, efficient memory management is crucial for optimizing program performance. Memory management refers to the allocation and deallocation of memory resources during program execution. Pointers, a fundamental feature of C, play a vital role in memory management. By understanding and implementing best practices for using pointers effectively, developers can enhance the efficiency and performance of their C programs.\n\nare variables that store memory addresses rather than actual data. They allow direct access to memory locations, enabling efficient manipulation of data and dynamic memory allocation. Pointers are widely used in C programming for tasks such as array manipulation, passing data between functions, and implementing complex data structures.\n\nDynamic memory allocation enables programs to request memory at runtime rather than relying solely on static allocation. The standard library provides functions like malloc(), calloc(), and realloc() for allocating memory dynamically.\n\nThe malloc() function allocates a block of memory of a specified size and returns a pointer to the allocated memory. It is crucial to check if the allocation was successful before proceeding with its usage. After using the dynamically allocated memory, it is essential to release it using the free() function to prevent memory leaks.\n\nThe calloc() function is similar to malloc(), but it additionally initializes the allocated memory to zero. It takes two arguments: the number of elements to allocate and the size of each element.\n\nThe realloc() function is used to resize dynamically allocated memory. It takes a pointer to the previously allocated memory block and the desired new size. It can be used to increase or decrease the size of the memory block.\n\nMemory leaks occur when allocated memory is not deallocated properly, resulting in a loss of available memory over time. To avoid memory leaks, always pair each allocation with an appropriate deallocation. Carefully track the lifecycle of dynamically allocated memory and ensure that every allocation is followed by a corresponding deallocation.\n\nNull pointers are pointers that do not point to any valid memory address. It is good practice to initialize pointers to null to avoid referencing uninitialized memory. Dangling pointers occur when a pointer points to memory that has been deallocated. Avoid using dangling pointers, as they can lead to unexpected behavior and crashes. Set dangling pointers to null after freeing the memory they reference.\n\nMemory alignment refers to the placement of data objects in memory at specific boundaries. Proper memory alignment can enhance performance, especially on architectures that require aligned memory access. Consider aligning data structures and memory allocations to improve efficiency and avoid potential performance penalties.\n\nPointer arithmetic allows manipulating pointers using arithmetic operations like addition and subtraction. It is essential to handle pointer arithmetic carefully to avoid buffer overflows, invalid memory access, and other undefined behavior. Follow best practices and perform appropriate bounds checking to ensure the correctness and safety of pointer arithmetic operations.\n\nPointer safety involves practices to ensure that pointers are used correctly and safely within a program.\n\nAlways initialize pointers before using them. Uninitialized pointers can lead to undefined behavior and crashes. Set pointers to null or valid memory addresses before accessing them.\n\nPerform necessary validations before dereferencing pointers. Check if pointers are null or point to valid memory locations before accessing the data they point to. Validate pointers returned by functions or obtained from external sources.\n\nEnsure that pointers remain valid for their intended usage. Avoid using pointers to memory that has been deallocated or has gone out of scope. Be mindful of the lifetime of pointers, especially when working with complex data structures or multithreaded programs.\n\npointer-related issues can be challenging. Common problems include null pointers, dangling pointers, and incorrect memory accesses. Use debugging tools and techniques like printing pointer values, analyzing stack traces, and employing memory debugging tools to identify and resolve pointer-related issues effectively.\n\nEfficient memory management with pointers is essential for optimizing C programs. By understanding the fundamentals of pointers and implementing best practices, developers can enhance performance, reduce memory leaks, and improve overall program efficiency. Remember to initialize and validate pointers, avoid memory leaks, and consider performance optimization techniques. With efficient memory management, C programs can achieve optimal performance and responsiveness.\n\nQ1: How can I allocate memory dynamically in C?\n\nA1: In C, you can allocate memory dynamically using functions like malloc(), calloc(), and realloc(). These functions provide flexibility in requesting memory at runtime.\n\nQ2: What is a memory leak in C?\n\nA2: A memory leak occurs when allocated memory is not properly deallocated, resulting in a loss of available memory over time. It is important to free memory after its usage to avoid memory leaks.\n\nQ3: How can I avoid null pointers in C?\n\nA3: To avoid null pointers in C, it is good practice to initialize pointers to null before using them. This helps prevent referencing uninitialized memory.\n\nQ4: Why is memory alignment important in C?\n\nA4: Memory alignment is important in C for performance reasons. Proper alignment can improve memory access speed, especially on architectures that require aligned memory access.\n\nis a tech-enabled education platform that provides IT courses with 100% Internship and Placement support. Perfect eLearning provides both Online classes and Offline classes only in Faridabad.\n\nIt provides a wide range of courses in areas such as Artificial Intelligence, Cloud Computing, Perfect eLearning, with its cutting-edge technology and expert instructors from Adobe, Microsoft, PWC, Google, Amazon, Flipkart, Nestle and Infoedge is the perfect place to start your IT education.\n\nPerfect eLearning in Faridabad provides the training and support you need to succeed in today's fast-paced and constantly evolving tech industry, whether you're just starting out or looking to expand your skill set.\n\nThere's something here for everyone. provides the best online courses as well as complete internship and placement assistance.\n\nIf you are confused and need Guidance over choosing the right programming language or right career in the tech industry, you can schedule a free counselling session with Perfect eLearning experts."
    }
]