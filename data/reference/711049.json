[
    {
        "link": "https://medium.com/@rajeshvelmani/managing-object-behavior-with-the-state-design-pattern-in-java-c00072e694f9",
        "document": "In software development, the State design pattern provides a way to change the behavior of an object dynamically as its internal state changes. This pattern allows an object to alter its behavior by delegating different responsibilities to separate state objects. In this blog, we will explore the State design pattern, understand its implementation in Java, and provide a practical example to illustrate its usage.\n\nThe State design pattern falls under the behavioral design pattern category. It allows an object to change its behavior by encapsulating different states into separate classes. Each state class represents a specific behavior associated with the object’s internal state. The pattern promotes loose coupling, improves code readability, and simplifies the management of complex conditional statements.\n• Context: The context represents the object whose behavior changes based on its internal state. It maintains a reference to the current state object and delegates behavior to it.\n• State: The state interface or abstract class defines the common methods that encapsulate the behavior associated with a specific state. It typically declares methods for performing operations based on the state.\n• Concrete States: Concrete state classes implement the state interface or extend the state abstract class. Each concrete state encapsulates the behavior associated with a specific state of the context object.\n• Client: The client code interacts with the context object and triggers state transitions based on certain conditions or events.\n\nLet’s demonstrate the implementation of the State design pattern using Java code. We’ll create an example of a fan that changes its speed (state) based on user commands.\n\nThe interface defines the state interface. It declares the method to encapsulate the behavior associated with a specific state. The , , , and classes are concrete state implementations. They implement the interface and encapsulate specific behaviors associated with the fan's different states. The class represents the context. It maintains a reference to the current state object and delegates behavior to it. The method allows the client to change the fan's state, and the method triggers the state transition based on the current state.\n\nUsing the State: To use the State pattern in the fan example, clients can create an instance of the class and interact with it by calling the method.\n\nIn the above example, we create an instance of the class. We call the method multiple times, which triggers state transitions based on the current state. The fan changes its behavior accordingly, and the corresponding messages are printed to the console.\n• Clean and structured code: The State pattern allows for the encapsulation of behavior associated with different states, leading to more organized and readable code.\n• Simplified state transitions: The pattern eliminates complex conditional statements by delegating behavior to separate state objects. It simplifies the management of state transitions and promotes maintainability.\n• Easy extensibility: New states can be added easily by implementing the state interface or extending the state abstract class. This makes it simple to introduce new behaviors without modifying existing code.\n• Improved flexibility: The State pattern enables objects to change their behavior dynamically at runtime. It allows for more flexible and adaptive software design.\n\nThe State design pattern provides an elegant solution for managing the behavior of an object as its internal state changes. In Java, the State pattern can be applied in various scenarios where objects need to exhibit different behaviors based on their state. By utilizing the State pattern effectively, you can achieve code modularity, flexibility, and improved maintainability, ultimately enhancing the overall design and functionality of your applications."
    },
    {
        "link": "https://stackoverflow.com/questions/54479066/best-practices-to-model-the-change-of-states-of-an-object-in-time",
        "document": "I'm currently working on a java webapp, and I have trouble trying to model the change of states of an object that depends on a start/end date.\n\nAs i need to change states in runtime, I'm following the State Pattern for the states, but I have doubts about the proper way to check for the conditions to change states. For example, I have a simple Event class, with an abstract EventState that is empty:\n\nAnd also, many states, some of which depends on the start/endDate. Like starting an event automatically in the startDate, and finishing it in the endDate:\n\nMy current approach is a Scheduler class that checks every Event a minute, and updates the states that way.\n\nConsidering that I will have many instances of Event in my application, is there any recommendation or approach to checking for time-based conditions when using the state pattern? Or should I not be using the state pattern for those states in particular?"
    },
    {
        "link": "https://geeksforgeeks.org/handling-state-and-state-management-system-design",
        "document": "State management is a critical aspect of system design that involves managing the state or condition of a system at any given point in time. In software development, state refers to the current values of variables, data, and configurations that determine the behavior of an application or system. Effective state management is essential for ensuring that a system functions correctly, maintains data integrity, and delivers a seamless user experience.\n\nState management is crucial in system design for several reasons:\n• Consistency : Proper state management ensures that data remains consistent across different components or modules of a system, preventing discrepancies and ensuring reliability.\n• Concurrency : In multi-user or distributed systems, effective state management allows for concurrent access to shared resources without conflicts or data corruption.\n• Performance : Efficient state management strategies optimize resource utilization and minimize latency, improving overall system performance and responsiveness.\n• Scalability : Scalable state management solutions enable systems to handle increasing loads and user volumes without sacrificing performance or reliability.\n• Fault Tolerance : Robust state management mechanisms incorporate fault tolerance and resilience, allowing systems to recover gracefully from failures and maintain data integrity.\n• Maintainability : Well-organized state management facilitates system maintenance and evolution by providing clear separation of concerns and modularization of functionality.\n• Security : Secure state management practices protect sensitive data from unauthorized access or tampering, ensuring compliance with privacy and regulatory requirements.\n\nIn system design, states can be broadly categorized into several types based on its nature and scope. Here are the main types of state:\n\nLocal state refers to data that is specific to a particular component or module within a system. It is typically managed and accessed within the context of that component and may not be shared with other parts of the system.\n\nGlobal state, also known as application-wide state, encompasses data that is shared and accessible across multiple components or modules within an application. It often represents the overall state of the application and can influence the behavior of various parts of the system.\n\nClient-side state resides on the client devices, such as web browsers or mobile devices, and is managed by client-side applications. Examples include user preferences, session data, and cached resources. Client-side state is often transient and may be lost when the client application is closed or refreshed.\n\nServer-side state is stored and managed on the server-side of a distributed system. It includes data such as user accounts, session information, and application state. Server-side state is typically more persistent and can be shared across multiple clients.\n\nImmutable state refers to data that cannot be modified after it is created. Instead of modifying existing state, immutable data structures create new copies with each change, preserving the integrity of the original data. Immutable state is often used to simplify state management and improve concurrency.\n\nMutable state, in contrast to immutable state, allows for direct modification of data after it is created. While mutable state can be more flexible and efficient in some cases, it can also lead to complexity and potential issues, such as race conditions and data inconsistencies.\n\nTransient state is temporary data that exists only for the duration of a specific operation or interaction. Once the operation is completed or the interaction ends, transient state is discarded and does not persist beyond that point.\n\nState transitions play a significant role in system design and are essential for understanding how a system evolves and responds to various inputs and events. Here are some key reasons why state transitions are significant:\n• Behavior Specification: State transitions define the behavior of a system by describing how the system moves from one state to another in response to external stimuli or events. By defining these transitions, designers can specify the expected behavior of the system under different conditions.\n• System Dynamics: State transitions capture the dynamic nature of a system by modeling its evolving states and interactions over time. They provide insight into how the system's behavior changes in response to user actions, environmental changes, or internal processes.\n• Event Handling: State transitions facilitate event handling and processing within a system. They define the actions or operations triggered by specific events, allowing the system to respond appropriately and maintain consistency.\n• Concurrency Control: In multi-user or distributed systems, state transitions help manage concurrency by defining rules for accessing and modifying shared resources. By synchronizing state transitions and enforcing access controls, systems can prevent conflicts and ensure data integrity.\n• Error Handling: State transitions provide mechanisms for error handling and recovery within a system. They define how the system responds to unexpected events or errors, including rollback procedures, error logging, and recovery mechanisms.\n\nState management poses several challenges in system design, particularly in distributed, concurrent, and large-scale systems. Some of the key challenges include:\n• Concurrency Control: Managing concurrent access to shared state is a major challenge, as multiple processes or threads may attempt to read from or write to the same state simultaneously. Ensuring data consistency and preventing race conditions or deadlocks requires careful synchronization and coordination mechanisms.\n• Consistency Maintenance: Maintaining consistency across distributed replicas of state is challenging, especially in distributed systems where data can be replicated across multiple nodes. Ensuring consistency in the presence of network partitions, failures, and asynchronous updates requires sophisticated replication protocols and consensus algorithms.\n• Fault Tolerance: Ensuring fault tolerance and resilience in state management is critical for maintaining system availability and reliability. Strategies such as replication, redundancy, and data recovery mechanisms must be implemented to tolerate failures and prevent data loss or corruption.\n• Stateful Behavior: Stateful systems often exhibit complex behavior and dependencies between states, making it challenging to reason about their correctness and behavior. Managing stateful interactions, state transitions, and handling edge cases requires careful design and testing.\n• Complexity and Maintainability: Stateful systems tend to be more complex and harder to maintain compared to stateless systems. Managing stateful components, handling state transitions, and debugging state-related issues require additional effort and expertise.\n\nEffective state management is essential for building robust, scalable, and maintainable systems. Here are some key principles to consider:\n• Single Source of Truth: Maintain a single, authoritative source of state within the system to avoid inconsistencies and synchronization issues. Centralizing state management simplifies data access, updates, and ensures data consistency across components.\n• Immutability: Embrace immutability where possible to simplify state management and prevent unintended side effects. Immutable data structures ensure that state changes are explicit and predictable, reducing the risk of concurrency issues and simplifying debugging.\n• Separation of Concerns: Decouple state management from business logic and presentation concerns to improve modularity, reusability, and maintainability. Adopt architectural patterns such as Model-View-Controller (MVC) or Flux to enforce clear separation between state management and user interface components.\n• Unidirectional Data Flow: Establish a unidirectional flow of data through the system to maintain predictability and traceability of state changes. Unidirectional data flow patterns, such as Redux in web applications or Flux architecture, ensure that changes to state propagate in a controlled manner, simplifying debugging and reasoning about system behavior.\n• State Persistence: Implement mechanisms for persisting state data to durable storage to ensure data durability and resilience against system failures. Use reliable storage solutions such as databases, caches, or distributed file systems to persist critical state information.\n• Definition : Local state management involves managing state within individual components or modules of a system without sharing it with other parts of the application.\n• Usage : It is commonly used in frontend development, where each UI component maintains its own state.\n• Benefits : Local state management simplifies component isolation, reduces coupling, and improves encapsulation. It also enhances reusability and testability of components.\n• Challenges : Ensuring consistency and synchronization of local state across components can be challenging, especially in large applications with complex interactions.\n• Definition : Centralized state management involves maintaining a single, global state store that is shared across multiple components or modules of an application.\n• Usage : It is commonly used in frontend frameworks like Redux or Vuex for managing application-wide state.\n• Benefits : Centralized state management provides a single source of truth, simplifying data access, updates, and synchronization across components. It also facilitates debugging, time-travel debugging, and performance optimizations.\n• Challenges : Centralized state management can introduce complexity, especially in large applications with complex state dependencies and interactions. Careful design and architecture are required to prevent state bloat and performance issues.\n• Definition : State machines and finite state automata model systems as a set of states, transitions, and actions. State machines define the behavior of systems based on their current state and the input received.\n• Usage : They are widely used for modeling and implementing systems with well-defined states and transitions, such as user interfaces, protocol implementations, and business workflows.\n• Benefits : State machines provide a structured and formalized way to model system behavior, making it easier to understand, analyze, and implement complex logic. They also facilitate state validation, error handling, and state-dependent actions.\n• Challenges : Designing and maintaining state machines can be complex, especially for systems with many states and transitions. Careful consideration of edge cases, error handling, and state transitions is essential to ensure correctness and reliability.\n• Definition : Event sourcing involves capturing and storing changes to application state as a sequence of immutable events. CQRS separates the responsibility of handling commands (state mutations) from queries (state retrievals).\n• Usage : Event sourcing and CQRS are commonly used in distributed systems, event-driven architectures, and systems requiring auditability and traceability.\n• Benefits : Event sourcing provides a reliable and auditable way to track changes to application state, enabling event replay, auditing, and historical analysis. CQRS simplifies system design by separating concerns, improving scalability, and enabling optimization of read and write operations independently.\n• Challenges : Event sourcing and CQRS introduce complexity, especially in systems with complex business logic and transactional requirements. Implementing event sourcing requires careful consideration of event schema design, event storage, and event replay mechanisms.\n\nEach of these techniques for state management offers unique advantages and challenges, and the choice of technique depends on the specific requirements, constraints, and architecture of the system being designed.\n\nThere are several state management libraries and frameworks available across different programming languages and platforms. These tools provide developers with pre-built solutions for managing state in their applications, simplifying development and improving productivity. Here are some popular state management libraries and frameworks:\n• None Redux is a predictable state container for JavaScript applications, commonly used with React for managing application state.\n• None It provides a centralized store to hold the entire application state and offers utilities for updating and accessing state using reducers and actions.\n• None Redux is widely used in large-scale React applications for its simplicity, scalability, and performance optimizations.\n• None VueX is the official state management library for Vue.js applications, inspired by Redux.\n• None It provides a centralized store with reactive state management capabilities and integrates seamlessly with Vue.js components.\n• None VueX simplifies state management in Vue.js applications by providing a structured and organized way to handle application state.\n• None MobX is a simple and scalable state management library for JavaScript applications, compatible with React, Vue.js, and other frameworks.\n• None It allows developers to define observable state and automatically track and update state changes in response to actions.\n• None MobX offers a more flexible and reactive approach to state management compared to Redux or VueX, making it suitable for smaller applications or projects with less complex state requirements.\n• None Flux is an architectural pattern for managing data flow in React applications, popularized by Facebook.\n• None It emphasizes unidirectional data flow and provides a clear separation of concerns between views, actions, and stores.\n• None While Flux itself is not a library or framework, there are several implementations and libraries inspired by Flux, such as Redux and Alt.js, that provide concrete solutions for state management in React applications.\n• None NgRx is a state management library for Angular applications, inspired by Redux.\n• None It provides a reactive state management solution based on RxJS observables and actions, allowing developers to manage application state in a consistent and predictable manner.\n• None NgRx simplifies state management in Angular applications by providing a centralized store, reducers, and effects for handling asynchronous actions and side effects.\n• None Flask-RESTPlus is an extension for Flask that simplifies the creation of RESTful APIs in Python applications.\n• None It provides features such as automatic Swagger documentation generation, request parsing, and input validation, making it easier to build scalable and maintainable APIs with Flask.\n\nEffective state management is crucial for building robust, scalable, and maintainable software systems. Here are some best practices to follow when managing state in your applications:\n• Keep State as Local as Possible: Minimize global state and favor local component-level state where appropriate. This helps in reducing complexity, improving encapsulation, and making components more reusable.\n• Single Source of Truth: Maintain a single, centralized source of truth for your application state. This simplifies data access, updates, and synchronization across components, reducing inconsistencies and improving predictability.\n• Normalize State Shape: Normalize complex state structures to improve consistency, reduce redundancy, and facilitate easier updates and access. Use normalized data structures such as normalized tables or nested maps for managing relational or hierarchical data.\n• Separation of Concerns: Separate business logic from state management concerns. Use architectural patterns such as MVC (Model-View-Controller), Flux, or Redux to maintain a clear separation between state management, business logic, and presentation concerns.\n• Avoid Deep Nesting: Avoid deeply nested state structures, as they can lead to increased complexity and decreased performance. Flatten state where possible and use selectors or memoization techniques to efficiently access nested data.\n\nBy following these best practices, you can build applications with robust, scalable, and maintainable state management solutions that meet the needs of your users and stakeholders."
    },
    {
        "link": "https://stackoverflow.com/questions/70355629/what-is-the-best-practice-to-store-state-variables-in-java",
        "document": "Closed. This question needs to be more . This question needs to be more focused . It is not currently accepting answers. Want to improve this question? Update the question so it focuses on one problem only by editing this post. This post was edited and submitted for review 3 years ago and failed to reopen the post:\n\nI'm new to Java. Say I want to make a simple game with Swing or whatever. How and where do I store variables like the player's score or progress, for example, so that I can access it from different classes (during the game and before persistence in the database). I like how we use useContext in React. I also used global variables in PHP's sessions."
    },
    {
        "link": "https://javanexus.com/blog/managing-state-in-functional-style-java",
        "document": "When it comes to managing state in Java, the traditional approach has been to rely heavily on mutable objects and imperative programming paradigms. However, with the rise of functional programming, there has been a shift towards immutability and a more declarative style of programming.\n\nIn this article, we will explore how to manage state in a functional-style Java application, leveraging concepts such as immutability, pure functions, and the package.\n\nIn functional programming, immutability is a key concept. An immutable object is one whose state cannot be modified after it is created. This can lead to more predictable and easier-to-reason-about code, as it eliminates the risk of unexpected state changes.\n\nIn Java, we can create immutable classes by following a few simple guidelines:\n• Make the class to prevent it from being extended.\n• Make all fields and to prevent them from being modified.\n• Do not provide any mutator methods, and instead initialize the fields through the constructor.\n\nLet's take a look at an example of an immutable class:\n\nIn this example, the class is immutable, as its state (i.e., and ) cannot be modified after the object is constructed. This ensures that instances of will always maintain their initial state, making it easier to reason about their behavior.\n\nAnother important concept in functional programming is the idea of pure functions. A pure function is a function that, given the same input, will always produce the same output, and has no side effects. This means that it does not modify any state outside of its own scope.\n\nIn Java, we can strive to write pure functions by avoiding the use of mutable state and ensuring that our functions do not have any side effects. This can help make our code more predictable and easier to test and debug.\n\nLet's consider an example of a pure function in Java:\n\nThe function is a pure function because it always produces the same output for a given input, and it does not modify any state outside of its scope.\n\nIn Java, the package provides powerful abstractions for processing sequences of elements in a functional style. Streams allow us to perform stateful operations on collections of data using a declarative syntax, without explicitly mutating the original data.\n\nFor example, consider the following code snippet:\n\nIn this example, we use a stream to perform stateful operations on a list of numbers. We filter out the odd numbers, map each even number to its double, and then calculate the sum of the resulting numbers. Throughout this process, the original list remains unchanged.\n\nBy leveraging streams and stateful operations, we can write code that is more concise, expressive, and easier to reason about, while still maintaining a functional style.\n\nIn conclusion, managing state in a functional-style Java application involves embracing immutability, writing pure functions, and leveraging stateful operations using streams. By adhering to these principles, we can create code that is more predictable, easier to reason about, and less prone to bugs.\n\nFunctional-style programming offers an elegant approach to managing state, and by applying these concepts, we can take full advantage of the features Java has to offer, while writing code that is both performant and maintainable.\n\nFor further reading on Java and functional programming, I highly recommend the book \"Functional Programming in Java\" by Pierre-Yves Saumont.\n\nThank you for reading! Happy coding!"
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/17/language/switch-expressions-and-statements.html",
        "document": "Like all expressions, expressions evaluate to a single value and can be used in statements. They may contain \" \" labels that eliminate the need for statements to prevent fall through. You can use a statement to specify the value of a switch expression.\n\nFor background information about the design of expressions, see JEP 361.\n\nConsider the following statement that prints the number of letters of a day of the week: It would be better if you could \"return\" the length of the day's name instead of storing it in the variable ; you can do this with a expression. Furthermore, it would be better if you didn't need statements to prevent fall through; they are laborious to write and easy to forget. You can do this with a new kind of label. The following is a expression that uses the new kind of label to print the number of letters of a day of the week: The new kind of label has the following form: When the Java runtime matches any of the labels to the left of the arrow, it runs the code to the right of the arrow and does not fall through; it does not run any other code in the expression (or statement). If the code to the right of the arrow is an expression, then the value of that expression is the value of the expression. You can use the new kind of label in statements. The following is like the first example, except it uses \" \" labels instead of \" \" labels: A \" \" label along with its code to its right is called a switch labeled rule.\n\nYou can use \" \" labels in expressions; a \" \" label along with its code to the right is called a switch labeled statement group: The previous example uses statements. They take one argument, which is the value that the label produces in a expression. The statement makes it easier for you to differentiate between statements and expressions. A statement, but not a expression, can be the target of a statement. Conversely, a expression, but not a statement, can be the target of a statement. It's recommended that you use \" \" labels. It's easy to forget to insert or statements when using \" \" labels; if you do, you might introduce unintentional fall through in your code. For \" \" labels, to specify multiple statements or code that are not expressions or statements, enclose them in a block. Specify the value that the label produces with the statement:\n\nUnlike statements, the cases of expressions must be exhaustive, which means that for all possible values, there must be a matching switch label. Thus, expressions normally require a clause. However, for expressions that cover all known constants, the compiler inserts an implicit clause. In addition, a expression must either complete normally with a value or complete abruptly by throwing an exception. For example, the following code doesn't compile because the switch labeled rule doesn't contain a statement: The following example doesn't compile because the switch labeled statement group doesn't contain a yield statement: i = switch (day) { case MONDAY, TUESDAY, WEDNESDAY: yield 0; default: System.out.println(\"Second half of the week\"); // ERROR! Group doesn't contain a yield statement };"
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nUnlike and statements, the statement can have a number of possible execution paths. A works with the , , , and primitive data types. It also works with enumerated types (discussed in Enum Types), the class, and a few special classes that wrap certain primitive types: , , , and (discussed in Numbers and Strings).\n\nThe following code example, , declares an named whose value represents a month. The code displays the name of the month, based on the value of , using the statement.\n\nIn this case, is printed to standard output.\n\nThe body of a statement is known as a switch block. A statement in the block can be labeled with one or more or labels. The statement evaluates its expression, then executes all statements that follow the matching label.\n\nYou could also display the name of the month with statements:\n\nDeciding whether to use statements or a statement is based on readability and the expression that the statement is testing. An statement can test expressions based on ranges of values or conditions, whereas a statement tests expressions based only on a single integer, enumerated value, or object.\n\nAnother point of interest is the statement. Each statement terminates the enclosing statement. Control flow continues with the first statement following the block. The statements are necessary because without them, statements in blocks fall through: All statements after the matching label are executed in sequence, regardless of the expression of subsequent labels, until a statement is encountered. The program shows statements in a block that fall through. The program displays the month corresponding to the integer and the months that follow in the year:\n\nThis is the output from the code:\n\nTechnically, the final is not required because flow falls out of the statement. Using a is recommended so that modifying the code is easier and less error prone. The section handles all values that are not explicitly handled by one of the sections.\n\nThe following code example, , shows how a statement can have multiple labels. The code example calculates the number of days in a particular month:\n\nThis is the output from the code:\n\nIn Java SE 7 and later, you can use a object in the statement's expression. The following code example, , displays the number of the month based on the value of the named :\n\nThe output from this code is .\n\nThe in the expression is compared with the expressions associated with each label as if the method were being used. In order for the example to accept any month regardless of case, is converted to lowercase (with the method), and all the strings associated with the labels are in lowercase.\n\nNote: This example checks if the expression in the statement is . Ensure that the expression in any statement is not null to prevent a from being thrown."
    },
    {
        "link": "https://medium.com/@javatechie/the-evolution-of-switch-statement-from-java-7-to-java-17-4b5eee8d29b7",
        "document": "Switch statement in java has gone through a rapid evolution since Java 7 . So in this article we will discuss evolution or changes of switch statement from java 7 to java 17 with example .\n\nUntil Java 7 only integers could be used in switch case and this had been the standard for a long time:\n\nIn Java 8 strings & enum were introduced in case values and switch statements started to evolve\n\nJava 12 further enhanced the switch statement and introduced switch expressions as a preview feature.\n\nIt introduced a flurry of new features:\n• You can return values from a switch block and hence switch statements became switch expressions\n• You can have multiple values in a case label\n• You can return value from a switch expression through the arrow operator or through the “break” keyword\n\nThe word “break” can be used to return the result value.\n\nFurther instead of returning values using break keyword , Java 12 introduced arrow operators as a simple alternative:\n\nAlso starting Java 12 multiple case values could be provided in a single case statement , So if you observe above example since all 5 case expected here same value so instead of return one by one i can merge or combine multiple case value to single one like below\n\nWhat ever switch statement & features we discussed so far in java 12 and 13 those are preview features to access that The flag –enable-preview need to set true .\n\nBut Java 14 just made all the features permanent from being a preview feature\n\nThe flag –enable-preview need not be set starting java 14. & switch statements have evolved into switch expressions!\n\nJava 17 LTS is the latest long-term support release for the Java SE platform and it was released on\n\nIt has introduced a new feature for switch i.e called pattern matching.\n\nYou can match patterns in a case label.\n\nIn other words you can pass objects in switch condition and this object can be checked for different types in switch case labels.\n\nIn the above example I am passing an object to the switch condition. This was not possible until Java 17. And then this object can be checked for a particular data type and assigned to a variable as well.\n\nFor example consider the case :\n\ncase Integer i- > \"It is an integer\";\n\nThe passed object is checked for the type “Integer” and then assigned to the variable “i” if it is an integer. And through the arrow operator the string “It is an integer ” is returned .\n\nLet’s take this use case.\n\nInside the case label where I have checked for a “Employee” instance , I want to do an additional check.\n\nThinking traditionally , you could be doing this after the case statement.\n\nSomething like this:\n\nyield \"This is IT Employee\";\n\nBut Java 17 has introduced “Guarded Patterns” . You can do this check in the case label itself like below\n\nYou could never pass a null value to switch statements prior to Java 17 without a Null pointer exception being thrown.\n\nJava 17 allows you to handle it this way\n\nIf you have the above switch expression you will never get Null Pointer exception if the object you pass is null.\n\nThat’s all about the journey from java 7 to java 17 switch case journey . Hope you like this article . if yes do follow me on medium now :)"
    },
    {
        "link": "https://stackoverflow.com/questions/69631357/java-17-switch-case-unused-method-parameters-should-be-removed",
        "document": "I have a simple method which takes an enum and returns a String:\n\nBut Sonar gives me this Major error:Unused method parameters should be removed.\n\nas you can see the parameter type is used in the switch. For more details when I use old switch case every thing is OK.\n\nAny idea about the issue, does sonar cover new Java syntaxes?\n\nHmm, I notice that when I remove sonar pass correctly! this is weird."
    },
    {
        "link": "https://bell-sw.com/blog/a-guide-to-pattern-matching-for-switch-in-java-21",
        "document": "Pattern matching for statements and expressions was introduced in JDK 17 and refined in the following releases. This feature evolved together with record patterns included into JDK 19. Both features were finalized in Java 21, so let’s see how we can use them in development.\n\nThe article contains some theory on statements / expressions and pattern matching, so if you are already familiar with the concepts, feel free to jump to the practical section.\n\nWhat are switch statements and expressions\n\nThe statements are statements with multiple execution paths. Using instead of traditional if-else statements helps to significantly reduce boilerplate code. So, for instance, instead of this code:\n\nWe can write this:\n\nA statement consists of a body in braces ( block), which includes one or multiple labels followed by statements (code to be executed): the labels containing values to which the expression is compared, and an optional label, whose statement is executed in case the expression doesn’t match any value in the case labels.\n\nThe example above is the traditional fall-through statement with a label. Fall-through means that all statements will be executed unless there’s a clause in each. This semantics has long been an irritation point for developers as it is verbose and error-prone. So, Java 14 brought a new label that\n\n1. Means that only one statement after the label matching the expression will be executed even without the clause, and\n\n2. Allows for multiple constants per .\n\nTherefore, the code above can be simplified to:\n\nJava 14 also introduced switch expressions that assigns a value to the given variable directly. So, we can simplify our example even more:\n\nBut despite the fact that expressions became more developer-friendly, they still possessed some limitations:\n• Support for a limited number of types: primitive types (int, byte, char, short, except for long), their boxed forms (Integer, Byte, Short, Character), enums, and String;\n• Special treatment of null values: separate code block outside of a statement / expression for handling nulls is required;\n• The expression can be tested against constants in labels only for exact equality.\n\nThis is where pattern matching comes to rescue.\n\nPattern matching means testing an object against a particular structure and then extracting values from the object if it matches some structure. A pattern consists of a test applied to the target (the object that we check) and a set of pattern variables, which are extracted from the target only if the test passes successfully.\n\nPattern matching has already been used in regular expressions. But this feature was extended to the operator in JEP 394 for Java 16. Thanks to pattern matching for , instead of introducing a local variable, assigning the given expression, casting it to specific type, and only then processing the expression like this:\n\nWe can simply write this:\n\nWhere is a type pattern, which is a pattern that takes type as a test and contains one pattern variable, to which the target is assigned.\n\nIn further JDK releases, the scope of pattern matching was extended to statements / expressions to overcome their limitations and avoid boilerplate with multiple if-else statements.\n\nHow to use pattern matching for switch\n• JDK 21. You can use Liberica JDK 21 for your platform by getting it directly from the website or using your favorite package manager.\n\nThe syntax of a statement / expression doesn’t change, only now we use type patterns in case labels, plus we can use any type to test against as opposed to the traditional :\n\nWhat about the null values? How can we handle them? There’s no need to carry the logic of testing against null outside the block, we can now do that inside the block using a label:\n\nNote that if you don’t add the null case, will throw a like it always has.\n\nWhat if we need to further test the value when it matches some pattern? For instance, we want to accept only Integers of certain values. One way is to use nested if-else statements, but it leads to redundant and potentially error-prone code.\n\nLuckily, we can use guarded pattern labels that contain a type pattern and a boolean expression or guard.\n\nLet’s linger on the previous example for a while. We can add a condition that checks whether the given object is an Integer of any value rather than 1 or 2:\n\nThe code functions correctly, but what if we change the case order and put case on top?\n\nIn this case, you will get a compile-time error java: this case label is dominated by a preceding case label .\n\nIf we place before , the first pattern will dominate the second pattern , meaning that any Integer matches the more general condition, and so the won’t go any further to analyze more specific cases and execute this statement. Therefore,\n• A more general (unguarded) pattern label dominates the guarded label with the same condition;\n• A type of a pattern label dominates the subtype of a pattern label.\n\nSo, for instance, placing a parent class in a pattern over a child class like that\n\nWill also result in a compile-time error.\n\nTo conclude this section, there’s a simple rule to ordering pattern labels: move down from more specific to more general conditions. Constant labels should come first, then guarded pattern labels, then unguarded pattern labels. Subtypes should precede types.\n\nExhaustiveness of statements / expressions implies that all possible values of the selector expression must be handled in the block.\n\nLet’s take one of the snippets we created above. If we remove the case like that\n\nit will result in compile-time error java: the switch expression does not cover all possible input values .\n\nThis functionality is especially useful with enums and sealed classes. Consider the following enum class:\n\nIf we want to use a statement / expression with our enum, we can specify all possible input values without the clause, and leave exhaustiveness checks to the compiler.\n\nRemoving one of the case labels will lead to a compile-time error. There’s logic to that. Suppose we extend our enum with additional values. Without the requirement for exhaustiveness, we could get away with not adding new values to , which will result in undesired application behavior.\n\nSo, if you add new constants to your enum class without recompiling the class containing the expression, the compiler will throw an exception.\n\nThe same applies to sealed classes and interfaces that restrict what other classes or interfaces can extend or implement them. For example, we have a sealed class that lets only , , and extend it:\n\nWe now have to cover all classes permitted by in our expression.\n\nBut there’s a catch. If you remove one of the input values (here or in the enum example), and instead, add a clause like that\n\nThe code will compile and run without errors. So, the general recommendation would be to avoid using clauses in statements / expressions working with enums and sealed classes.\n\nBefore we move on to another section, I would like to highlight another possible pitfall related to enums in .\n\nIf you use a traditional statement with labels, and don’t specify all existing enum constants:\n\nThe code will also compile and run without errors. In case you use Intellij IDEA, Nicolai Parlog offered a workaround to this issue. Go to Settings -> Editor -> Inspections -> Enum ‘switch’ statement that misses case, and set the severity level to Error. Apply the changes. After that, you will see that the incomplete switch statement is highlighted by the IDE.\n\nRecord patterns combine the power of Java records (classes that act as immutable data carriers) and pattern matching.\n\nA record pattern includes a record class type and a pattern list matched against the record component values.\n\nFor instance, we have a record :\n\nThen the corresponding record pattern will be . Now, we can use this record pattern with the operator: without creating local variables and extracting the components explicitly, we can access the value components directly:\n\nIn a simple case without complex hierarchies, record patterns in statements / expressions help us to write very laconic code:\n\nIn case you have a more complex situation with hierarchy involved:\n\nYou must make sure that the statement / expression is exhaustive, i.e., all possible combinations of the component pattern types must be covered:\n\nPattern matching for switch is a useful feature that makes the code more concise, expressive, and reliable.\n\nSubscribe to our newsletter if you want to learn about other cool features in newer Java versions!"
    }
]