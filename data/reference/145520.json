[
    {
        "link": "https://freecodecamp.org/news/how-javascript-works-behind-the-scene-javascript-execution-context",
        "document": "Have you ever wondered how JavaScript works behind the scenes? It's actually quite fascinating! And that's what you'll learn about here.\n\nJavaScript is a single-threaded interpreted language. Every browser has its own JavaScript engine. Google Chrome has the V8 engine, Mozilla Firefox has SpiderMonkey, and so on. They all are used for the same goal, because the browsers cannot directly understand JavaScript code.\n\nLet's look at an example so we can learn more:\n\nIn the above code,\n• n is initialized and assigned a value of 5\n• We defined a function that accepts an argument n and returns the square of n.\n• We call the function and store the returned value in the variable.\n• We call the function and store the returned value in the variable.\n• Finally, it outputs both and\n\nBehind the scenes, JavaScript is doing so many things. Let's understand all of it.\n\nWhat is the Execution Context?\n\nWhen the JavaScript engine scans a script file, it makes an environment called the Execution Context that handles the entire transformation and execution of the code.\n\nDuring the context runtime, the parser parses the source code and allocates memory for the variables and functions. The source code is generated and gets executed.\n\nThere are two types of execution contexts: global and function. The global execution context is created when a JavaScript script first starts to run, and it represents the global scope in JavaScript. A function execution context is created whenever a function is called, representing the function's local scope.\n\nThere are two phases of JavaScript execution context:\n• Creation phase: In this phase, the JavaScript engine creates the execution context and sets up the script's environment. It determines the values of variables and functions and sets up the scope chain for the execution context.\n• Execution phase: In this phase, the JavaScript engine executes the code in the execution context. It processes any statements or expressions in the script and evaluates any function calls.\n\nEverything in JS happens inside this execution context. It is divided into two components. One is memory and the other is code. It is important to remember that these phases and components are applicable to both global and functional execution contexts.\n\nLet's take this simple example once again:\n\nAt the very beginning, the JavaScript engine executes the entire source code, creates a global execution context, and then does the following things:\n• Creates a global object that is window in the browser and global in NodeJs.\n• Sets up a memory for storing variables and functions.\n• Stores the variables with values as undefined and function references.\n\nThis is called the creation phase. Here's a diagram to help explain it:\n\nAfter this creation phase, the execution context will move to the code execution phase.\n\nNow, in this phase, it starts going through the entire code line by line from top to bottom. As soon as it encounters n = 5, it assigns the value 5 to 'n' in memory. Until now, the value of 'n' was undefined by default.\n\nThen we get to the 'square' function. As the function has been allocated in memory, it directly jumps into the line var square1 = square(n);. square() will be invoked and JavaScript once again will create a new function execution context.\n\nOnce the calculation is done, it assigns the value of square in the 'ans' variable that was undefined before. The function will return the value, and the function execution context will be destroyed.\n\nThe returned value from square() will be assigned on square1. This happens for square2 also. Once the entire code execution is done completely, the global context will look like this and it will be destroyed also.\n\nWhat is the Call Stack?\n\nTo keep the track of all the contexts, including global and functional, the JavaScript engine uses a call stack. A call stack is also known as an 'Execution Context Stack', 'Runtime Stack', or 'Machine Stack'.\n\nIt uses the LIFO principle (Last-In-First-Out). When the engine first starts executing the script, it creates a global context and pushes it on the stack. Whenever a function is invoked, similarly, the JS engine creates a function stack context for the function and pushes it to the top of the call stack and starts executing it.\n\nWhen execution of the current function is complete, then the JavaScript engine will automatically remove the context from the call stack and it goes back to its parent.\n\nLet's see the following example:\n\nIn this example, the JS engine creates a global execution context that enters the creation phase.\n\nFirst it allocates memory for , , the function, and the variable. Then it invokes , which will be pushed on the call stack.\n\nThen will call . At this point, 's context will be stored on the top of the stack. Then it will start executing and call another function . Similarly, 's context will be pushed.\n\nOnce execution of each function is done, it will be removed from the call stack. The following picture depicts the entire process of the execution:\n\nThe call stack has its own fixed size depending on the system or browser. If the number of contexts exceeds the limit, then a stack overflow error will occur. This happens with a recursive function that has no base condition.\n\nIn conclusion, JavaScript execution context is a crucial part of understanding how JavaScript works behind the scenes. It determines the environment in which code is executed and what variables and functions are available to use.\n\nThe creation phase includes creating the global and function execution contexts, creating the scope chain, and allocating memories for the variables and functions. During the execution phase, the JavaScript engine executes the code line by line. This includes evaluating and executing statements.\n\nI hope you found this tutorial helpful and informative. If you enjoyed reading it, I encourage you to share it with your friends and followers on social media.\n\nDon't forget to also follow me on Twitter for more updates on coding and tech. Thanks for reading!"
    },
    {
        "link": "https://dev.to/jahid6597/javascript-execution-context-a-deep-dive-4kno",
        "document": "Suppose you're the manager of a restaurant, and your restaurant is like a JavaScript program. Each section of the restaurant represents an execution context.\n\nThe first section of the restaurant is the dining room, which is like the global execution context in JavaScript. This is the main area where the customers come to eat and enjoy their meals. It contains everything that's required for the restaurant to run smoothly, like the tables, chairs, menus, and waitstaff. This is similar to how the global execution context contains all the variables, functions, and objects that are needed for a JavaScript program to run.\n\nNow, let's say a customer wants to order a meal. The customer is like the user input, and the act of taking their order is like creating a new execution context. The waiter takes the customer's order and moves to the kitchen area, which is like creating a new execution context in JavaScript.\n\nIn the kitchen area, the chef and kitchen staff prepare the meal based on the order taken by the waiter. This area is like a new execution context, similar to how each function call in JavaScript creates a new execution context. The kitchen has its own set of tools and ingredients, just like each execution context in JavaScript has its own set of variables and functions.\n\nOnce the meal is prepared, it's delivered to the customer in the dining room. This is like the result of a function call being returned to the global execution context. The customer receives their meal, and the restaurant continues to operate smoothly.\n\nOverall, just like how a restaurant operates with different areas serving different functions, JavaScript code operates in different execution contexts as it moves through a program.\n\nJavaScript is a high-level programming language used for web development. It is single-threaded, meaning it can only execute one command at a time, and is interpreted, meaning it is not compiled before execution.\n\nV8 is a high-performance JavaScript engine developed by Google and used in their Chrome browser, as well as other applications. It compiles JavaScript code to machine code, improving its performance.\n\nJavaScript is primarily used for client-side scripting, meaning it runs on the user's web browser, and is used to create dynamic and interactive web pages. It is often used in conjunction with HTML and CSS.\n\nJavaScript Execution Context is the environment in which JavaScript code is executed. It contains information about the variables, functions, and objects that are available to the code being executed, as well as the scope chain and the value of the 'this' keyword.\n\nAn execution context has two phases:\n\nCreation Phase:\n\n In this phase, the JavaScript engine sets up the environment for the code to be executed. During this phase, the JavaScript engine creates the following:\n• The Variable Object (VO): The VO contains all the variables and functions that are defined in the current scope. This includes function arguments, function declarations, and variable declarations. The VO is used to resolve identifiers to their values during execution.\n• The Scope Chain: The Scope Chain is a list of Variable Objects that are accessible in the current scope. Each Variable Object in the Scope Chain represents a higher level of scope.\n• The \"this\" keyword: The \"this\" keyword is set to the value of the \"this\" object.\n\nExecution Phase:\n\n In this phase, the JavaScript engine executes the code line by line. The JavaScript engine reads the code and executes it one line at a time. This phase involves the following steps:\n• Assigning Values to Variables: During the execution phase, the JavaScript engine assigns values to variables. If a variable is not initialized, it has the value of 'undefined'.\n• Executing Functions and Code Blocks: The JavaScript engine executes functions and code blocks as it encounters them in the code. If a function is called, the engine creates a new execution context for that function and adds it to the call stack.\n• Managing the Call Stack: The call stack is a data structure that keeps track of the functions that are being executed. When a function is called, its execution context is added to the top of the call stack. When the function returns, its execution context is removed from the stack.\n\nThe two main components of an execution context in JavaScript are:\n• Memory Component: This refers to the memory space that is allocated for the code and data components within the context. This includes variables, objects, arrays, and other data structures that are used or manipulated by the code. The memory component is also responsible for maintaining the scope chain, which is a list of variable objects that a function has access to, starting with its own variable object and continuing with the variable objects of its parent functions, all the way up to the global variable object.\n• Code Component: This refers to the actual code that is being executed within the context. It includes any function and variable declarations, as well as any other instructions that make up the code. During the creation phase of the execution context, the JavaScript engine sets up memory space for all variables and function declarations through a process known as hoisting.\n\nTogether, these two components enable the JavaScript engine to execute code and manage data within the program. Understanding how these components work is crucial for writing efficient and effective JavaScript code.\n\nThe JavaScript engine first runs the complete source code then does the following:\n• Create a Global Execution Context(G.E.C) and push it to the call stack.\n• Creates a global object window in the browser and global in the NodeJs.\n• Stores the variables with values as undefined and function body references.\n\nAfter this memory creation phase, the execution context will move to the code execution phase.\n\n The function is called.\n\nCreate greetings Execution Context and push it to the call stack.\n\nMemory Creation and Code Execution of greetings Execution Context. Here The function is called, so it executes and logs the string \"Welcome to the JS world!\" to the console.\n\npop greetings Execution Context from the call stack.\n\nA function is called, which takes two parameters and . Inside the function, the two parameters are added together and the is returned.\n\nCreate add Execution Context and push it to the call stack.\n\nMemory Creation and Code Execution of add Execution Context. Here returned the sum of and .\n\nvariable defined and assigned the result of calling the .\n\nA function is called, which takes two parameters and . Inside the function, a new variable is defined and assigned a value of 15. Then, the sum of , , and is returned.\n\nCreate addExtra Execution Context and push it to the call stack.\n\nMemory Creation and Code Execution of addExtra Execution Context. Here is defined and assigned a value of 15 and returned the sum of , and .\n\nvariable defined and assigned the result of calling the .\n\nThe value of logged to the console.\n\nThe value of logged to the console.\n\nJavaScript execution context is a fundamental concept that defines the environment in which JavaScript code is executed. It plays a vital role in how JavaScript functions and interacts with its surrounding environment, and understanding it is essential to write efficient and effective JavaScript code. An execution context is a data structure that contains information about the environment in which the JavaScript code is executed.\n\nEach execution context has a scope chain that determines what variables and functions the context has access to. The scope chain is determined by the lexical environment of the execution context and is used to look up variables and functions when code is executed.\n\nThe variable object is another important component of an execution context. It is a data structure that contains information about the variables, functions, and parameters defined in the execution context. The variable object is used to store and manage the variables and functions in the context and is updated dynamically as the code is executed.\n\nThe this keyword is also an important part of the execution context. The value of this is determined by the context in which a function is called. In the global execution context, this refers to the global object. In a function execution context, this refers to the object that the function is a method of, or the global object if the function is not a method of any object.\n\nHoisting is another concept that is closely related to execution context. In JavaScript, variable and function declarations are hoisted to the top of their respective execution contexts. This means that they can be used before they are declared in the code.\n\nFinally, the execution stack is a data structure that stores execution contexts in a last-in, first-out (LIFO) order. When a function is called, a new execution context is created and pushed onto the top of the stack. When a function returns, its execution context is popped off the stack.\n\nThe execution context is a fundamental concept in JavaScript that defines the environment in which code is executed. It contains information about the variables, functions, and parameters defined in that environment, as well as the scope chain and the this keyword. By understanding the execution context, developers can write more efficient and effective JavaScript code, ultimately leading to better performance and more reliable applications."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model",
        "document": "This page introduces the basic infrastructure of the JavaScript runtime environment. The model is largely theoretical and abstract, without any platform-specific or implementation-specific details. Modern JavaScript engines heavily optimize the described semantics. This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java. It makes heavy references to existing concepts in operating systems and programming languages.\n\nThe engine and the host JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment. The JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality. It takes source code, parses it, and executes it. However, in order to interact with the outside world, such as to produce any meaningful output, to interface with external resources, or to implement security- or performance-related mechanisms, we need additional environment-specific mechanisms provided by the host environment. For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment that allows JavaScript to be run on the server side. While we focus primarily on the mechanisms defined in ECMAScript in this reference, we will occasionally talk about mechanisms defined in the HTML spec, which is often mimicked by other host environments like Node.js or Deno. This way, we can give a coherent picture of the JavaScript execution model as used on the web and beyond.\n\nIn the JavaScript specification, each autonomous executor of JavaScript is called an agent, which maintains its facilities for code execution:\n• Heap (of objects): this is just a name to denote a large (mostly unstructured) region of memory. It gets populated as objects get created in the program. Note that in the case of shared memory, each agent has its own heap with its own version of a object, but the underlying memory represented by the buffer is shared.\n• Queue (of jobs): this is known in HTML (and also commonly) as the event loop which enables asynchronous programming in JavaScript while being single-threaded. It's called a queue because it's generally first-in-first-out: earlier jobs are executed before later ones.\n• Stack (of execution contexts): this is what's known as a call stack and allows transferring control flow by entering and exiting execution contexts like functions. It's called a stack because it's last-in-first-out. Every job enters by pushing a new frame onto the (empty) stack, and exits by emptying the stack. These are three distinct data structures that keep track of different data. We will introduce the queue and the stack in more detail in the following sections. To read more about how heap memory is allocated and freed, see memory management. Each agent is analogous to a thread (note that the underlying implementation may or may not be an actual operating system thread). Each agent can own multiple realms (which 1-to-1 correlate with global objects) that can synchronously access each other, and thus needs to run in a single execution thread. An agent also has a single memory model, indicating whether it's little-endian, whether it can be synchronously blocked, whether atomic operations are lock-free, etc. An agent on the web can be one of the following:\n• A Similar-origin window agent, which contains various objects which can potentially reach each other, either directly or by using . If the window is origin-keyed, then only same-origin windows can reach each other. In other words, each worker creates its own agent, while one or more windows may be within the same agent—usually a main document and its similar-origin iframes. In Node.js, a similar concept called worker threads is available. The diagram below illustrates th execution model of agents:\n\nEach agent owns one or more realms. Each piece of JavaScript code is associated with a realm when it's loaded, which remains the same even when called from another realm. A realm consists of the follow information:\n• A list of intrinsic objects like , , etc.\n• Globally declared variables, the value of , and the global object\n• A cache of template literal arrays, because evaluation of the same tagged template literal expression always causes the tag to receive the same array object On the web, the realm and the global object are 1-to-1 corresponded. The global object is either a , a , or a . So for example, every executes in a different realm, though it may be in the same agent as the parent window. Realms are usually mentioned when talking about the identities of global objects. For example, we need methods such as or , because an array constructed in another realm will have a different prototype object than the object in the current realm, so will wrongly return .\n\nOne mechanism defined in the specification is proper tail call (PTC). A function call is a tail call if the caller does nothing after the call except return the value: In this case, the call to is a tail call. If a function call is in tail position, the engine is required to discard the current execution context and replace it with the context of the tail call, instead of pushing a new frame for the call. This means that tail recursion is not subject to the stack size limits: In reality, discarding the current frame causes debugging problems, because if throws an error, is no longer on the stack and won't appear in the stack trace. Currently, only Safari (JavaScriptCore) implements PTC, and they have invented some specific infrastructure to address the debuggability issue.\n\nAn agent is a thread, which means the interpreter can only process one statement at a time. When the code is all synchronous, this is fine because we can always make progress. But if the code needs to perform asynchronous action, then we cannot progress unless that action is completed. However, it would be detrimental to user experience if that halts the whole program—the nature of JavaScript as a web scripting language requires it to be never blocking. Therefore, the code that handles the completion of that asynchronous action is defined as a callback. This callback defines a job, which gets placed into a job queue—or, in HTML terminology, an event loop—once the action is completed. Every time, the agent pulls a job from the queue and executes it. When the job is executed, it may create more jobs, which are added to the end of the queue. Jobs can also be added via the completion of asynchronous platform mechanisms, such as timers, I/O, and events. A job is considered completed when the stack is empty; then, the next job is pulled from the queue. Jobs might not be pulled with uniform priority—for example, HTML event loops split jobs into two categories: tasks and microtasks. Microtasks have higher priority and the microtask queue is drained first before the task queue is pulled. For more information, check the HTML microtask guide. If the job queue is empty, the agent waits for more jobs to be added.\n\nEach job is processed completely before any other job is processed. This offers some nice properties when reasoning about your program, including the fact that whenever a function runs, it cannot be preempted and will run entirely before any other code runs (and can modify data the function manipulates). This differs from C, for instance, where if a function runs in a thread, it may be stopped at any point by the runtime system to run some other code in another thread. For example, consider this example: In this example, we create an already-resolved promise, which means any callback attached to it will be immediately scheduled as jobs. The two callbacks seem to cause a race condition, but actually, the output is fully predictable: and will be logged in order. This is because each job runs to completion before the next one is executed, so the overall order is always and never . A downside of this model is that if a job takes too long to complete, the web application is unable to process user interactions like click or scroll. The browser mitigates this with the \"a script is taking too long to run\" dialog. A good practice to follow is to make job processing short and if possible cut down one job into several jobs.\n\nMultiple agents can communicate via memory sharing, forming an agent cluster. Agents are within the same cluster if and only if they can share memory. There is no built-in mechanism for two agent clusters to exchange any information, so they can be regarded as completely isolated execution models. When creating an agent (such as by spawning a worker), there are some criteria for whether it's in the same cluster as the current agent, or a new cluster is created. For example, the following pairs of global objects are each within the same agent cluster, and thus can share memory with each other:\n• A object and a dedicated worker that it created.\n• A worker (of any type) and a dedicated worker it created.\n• A object A and the object of a same-origin element that A created.\n• A object and a same-origin object that opened it.\n• A object and a worklet that it created. The following pairs of global objects are not within the same agent cluster, and thus cannot share memory:\n• A worker (of any type) and a shared worker it created.\n• A object A and the object of an element that A created that cannot be same origin-domain with A.\n• Any two objects with no opener or ancestor relationship. This holds even if the two objects are same origin. For the exact algorithm, check the HTML specification.\n\nAs aforementioned, agents communicate via memory sharing. On the web, memory is shared via the method. The using web workers guide provides an overview of this. Typically, data is passed by value only (via structured cloning), and therefore does not involve any concurrency complications. To share memory, one must post a object, which can be simultaneously accessed by multiple agents. Once two agents share access to the same memory via a , they can synchronize executions via the object. There are two ways to access shared memory: via normal memory access (which is not atomic) and via atomic memory access. The latter is sequentially consistent (which means there is a strict total ordering of events agreed upon by all agents in the cluster), while the former is unordered (which means no ordering exists); JavaScript does not provide operations with other ordering guarantees. The spec provides the following guidelines for programmers working with shared memory: We recommend programs be kept data race free, i.e., make it so that it is impossible for there to be concurrent non-atomic operations on the same memory location. Data race free programs have interleaving semantics where each step in the evaluation semantics of each agent are interleaved with each other. For data race free programs, it is not necessary to understand the details of the memory model. The details are unlikely to build intuition that will help one to better write ECMAScript. More generally, even if a program is not data race free it may have predictable behavior, so long as atomic operations are not involved in any data races and the operations that race all have the same access size. The simplest way to arrange for atomics not to be involved in races is to ensure that different memory cells are used by atomic and non-atomic operations and that atomic accesses of different sizes are not used to access the same cells at the same time. Effectively, the program should treat shared memory as strongly typed as much as possible. One still cannot depend on the ordering and timing of non-atomic accesses that race, but if memory is treated as strongly typed the racing accesses will not \"tear\" (bits of their values will not be mixed).\n\nWhen multiple agents cooperate, the never-blocking guarantee does not always hold. An agent can become blocked, or paused, while waiting for another agent to perform some action. This is different from waiting on a promise in the same agent, because it halts the entire agent and does not allow any other code to run in the meantime—in other words, it cannot make forward progress. To prevent deadlocks, there are some strong restrictions on when and which agents can become blocked.\n• In a set of agents that share an executing thread, one agent eventually makes forward progress.\n• An agent does not cause another agent to become blocked except via explicit APIs that provide blocking.\n• Only certain agents can be blocked. On the web, this includes dedicated workers and shared workers, but not similar-origin windows or service workers. The agent cluster ensures some level of integrity over the activeness of its agents, in the case of external pauses or terminations:\n• An agent may be paused or resumed without its knowledge or cooperation. For example, navigating away from a window may suspend code execution but preserve its state. However, an agent cluster is not allowed to be partially deactivated, to avoid an agent starving because another agent has been deactivated. For example, shared workers are never in the same agent cluster as the creator window or other dedicated workers. This is because a shared worker's lifetime is independent of documents: if a document is deactivated while its dedicated worker holds a lock, the shared worker is blocked from acquiring the lock until the dedicated worker is reactivated, if ever. Meanwhile other workers trying to access the shared worker from other windows will starve.\n• Similarly, an agent may be terminated by factors external to the cluster. For example, operating systems or users killing a browser process, or the browser force-terminating one agent because it's using too many resources. In this case, all the agents in the cluster get terminated. (The spec also allows a second strategy, which is an API that allows at least one remaining member of the cluster to identify the termination and the agent that was terminated, but this is not implemented on the web.)"
    },
    {
        "link": "https://javascripttutorial.net/javascript-execution-context",
        "document": "Summary: in this tutorial, you will learn about the JavaScript execution context to deeply understand how JavaScript code gets executed.\n\nLet’s start with the following example:\n\nIn this example:\n• First, declare the variable and initialize its value with .\n• Second, declare the function that accepts an argument and returns a value that is the result of the multiplication of the argument with .\n• Third, call the function with the argument as the value of the variable and store result in the variable .\n• Finally, output the variable to the Console.\n\nBehind the scenes, JavaScript does many things. in this tutorial, you will focus on execution contexts.\n\nWhen the JavaScript engine executes the JavaScript code, it creates execution contexts.\n\nEach execution context has two phases: the creation phase and the execution phase.\n\nWhen the JavaScript engine executes a script for the first time, it creates the global execution context. During this phase, the JavaScript engine performs the following tasks:\n• Create the global object i.e., in the web browser or in Node.js.\n• Create the object and bind it to the global object.\n• Set up a memory heap for storing variables and function references.\n• Store the function declarations in the memory heap and variables within the global execution context with the initial values as .\n\nWhen the JavaScript engine executes the code example above, it does the following in the creation phase:\n• First, store the variables and and function declaration in the global execution context.\n• Second, initialize the variables and to .\n\nAfter the creation phase, the global execution context moves to the execution phase.\n\nDuring the execution phase, the JavaScript engine executes the code line by line, assigns the values to variables, and executes the function calls.\n\nFor each function call, the JavaScript engine creates a new function execution context.\n\nThe function execution context is similar to the global execution context. But instead of creating the global object, the JavaScript engine creates the object that is a reference to all the parameters of the function:\n\nIn our example, the function execution context creates the object that references all parameters passed into the function, sets value to the global object, and initializes the parameter to .\n\nDuring the execution phase of the function execution context, the JavaScript engine assigns to the parameter and returns the result ( ) to the global execution context:\n\nTo keep track of all the execution contexts, including the global execution context and function execution contexts, the JavaScript engine uses the call stack, which you will learn in the next tutorial.\n\nIn this tutorial, you have learned about the JavaScript execution contexts, including the global execution context and function execution contexts."
    },
    {
        "link": "https://medium.com/@rabailzaheer/javascript-execution-context-behind-the-call-stack-19f253aad0a4",
        "document": "Welcome to the fascinating world of JavaScript execution context — a core concept that forms the foundation of how JavaScript code runs. In this exploration, we will unravel the mysteries of this concept, demystifying what the JavaScript execution context is and why it’s crucial for understanding the inner workings of your JavaScript code.\n\nThe JavaScript execution context is the environment in which your JavaScript code is executed. It includes all the necessary information and settings for your code to run, such as variables, functions, scope, and more. Think of it as the backstage area where your code comes to life, where every line of JavaScript is orchestrated and performed.\n\nUnderstanding execution context is like having a backstage pass to a concert — you get a glimpse of what’s happening behind the scenes. Here’s why it’s essential:\n• Variable Scope: Execution context defines where variables and functions are accessible, helping you avoid unexpected behavior or conflicts in your code.\n• Function Execution: It’s the key to understanding how functions are called and how their execution context interacts with the call stack."
    },
    {
        "link": "https://w3schools.com/js/js_scope.asp",
        "document": "Before ES6 (2015), JavaScript variables had only Global Scope and Function Scope.\n\nES6 introduced two important new JavaScript keywords: and .\n\nThese two keywords provide Block Scope in JavaScript.\n\nVariables declared inside a { } block cannot be accessed from outside the block:\n\nVariables declared with the keyword can NOT have block scope.\n\nVariables declared inside a { } block can be accessed from outside the block.\n\nVariables declared within a JavaScript function, are LOCAL to the function:\n\nSince local variables are only recognized inside their functions, variables with the same name can be used in different functions.\n\nLocal variables are created when a function starts, and deleted when the function is completed.\n\nJavaScript has function scope: Each function creates a new scope.\n\nVariables defined inside a function are not accessible (visible) from outside the function.\n\nVariables declared with , and are quite similar when declared inside a function.\n\nThey all have Function Scope:\n\nVariables declared Globally (outside any function) have Global Scope.\n\nGlobal variables can be accessed from anywhere in a JavaScript program.\n\nVariables declared with , and are quite similar when declared outside a block.\n\nThey all have Global Scope:\n\nIn JavaScript, objects and functions are also variables.\n\nIf you assign a value to a variable that has not been declared, it will automatically become a GLOBAL variable.\n\nThis code example will declare a global variable , even if the value is assigned inside a function.\n\nYou will learn more about how to use strict mode in a later chapter of this tutorial.\n\nWith JavaScript, the global scope is the JavaScript environment.\n\nIn HTML, the global scope is the window object.\n\nGlobal variables defined with the keyword belong to the window object:\n\nGlobal variables defined with the keyword do not belong to the window object:\n\nDo NOT create global variables unless you intend to. Your global variables (or functions) can overwrite window variables (or functions).\n\nAny function, including the window object, can overwrite your global variables and functions.\n\nThe lifetime of a JavaScript variable starts when it is declared.\n\nFunction (local) variables are deleted when the function is completed.\n\nIn a web browser, global variables are deleted when you close the browser window (or tab)."
    },
    {
        "link": "https://geeksforgeeks.org/explain-scope-and-scope-chain-in-javascript",
        "document": "In this article, we will try to understand what is the scope of a variable as well as its function (or method). We will see what is a Scope Chain with the help of certain coding examples.\n• None Scope in JavaScript determines the accessibility of variables and functions at various parts of one’s code or program.\n• None In other words, Scope will help us to determine a given part of a code or a program, what variables or functions one can access, and what variables or functions one cannot access.\n• None Within a scope itself, a variable a function, or a method could be accessed. Outside the specified scope of a variable or function, the data cannot be accessed.\n• None There are three types of scopes available in JavaScript: Global Scope, Local / Function Scope, Block Scope. Let us try to understand each one of them briefly in the following section.\n• None Variables or functions (or methods) that are declared under a global namespace (like area or location) are determined as Global Scope.\n• None It means that all the variables that have global scope can be easily accessed from anywhere within the code or a program.\n\nExample: In this example, we will be declaring a global variable which we will use in the later part of our code. We will call that variable in one function. We will call that function inside another function and then we will call that other function to see the result.\n• None Variables that are declared inside a function or a method have Local or Function Scope.\n• None It means those variables or functions which are declared inside the function or a method can be accessed within that function only.\n\nExample: In this example, we will declare the main function which will consist of a local/function scoped variable. We will declare a nested function that will take that variable into consideration and perform a multiply operation on it. We will call the nested function inside the main function itself and thereafter the main function outside its declaration.\n\nThen at last we will call our local/function scoped variable along with the local/function scoped function to see what output they will display upon their calling.\n• None is related to the variables or functions which are declared using does not have block scope.\n• None Block Scope tells us that variables that are declared inside a block { }, can be accessed within that block only, not outside of that block.\n\nExample: In this example, we will declare a block using curly braces “{ }”, and inside that block, we will declare a variable having a certain value in it. We will call that variable outside the blocked scope to see what output it actually displays upon calling.\n• None JavaScript engine uses scopes to find out the exact location or accessibility of variables and that particular process is known as Scope Chain.\n• None Scope Chain means that one variable has a scope (it may be global or local/function or block scope) is used by another variable or function having another scope (may be global or local/function or block scope).\n• None This complete chain formation goes on and stops when the user wishes to stop it according to the requirement.\n\nExample: In this example, we will first declare a global scope variable which we will use in the later part of the code, and then we will declare the main function inside which we will do some stuff. We will declare another local/function scoped variable inside that main function and just after that we will declare two nested functions (having local/function scope) within the main function itself.\n• None First, the nested function will print the value of the local/function scoped variable and the second nested function will display the value of the globally scoped variable.\n• None We will call the two nested functions inside the main function and then call the main function outside its declaration namespace."
    },
    {
        "link": "https://dasha.ai/en-us/blog/javascript-scope-and-scope-chain",
        "document": "If you are new to JavaScript, you might be struggling to understand these concepts. I remember how long it took me to get a firm understanding of these two tricky concepts. In this post, we will go through the scope and scope chain with some simple examples to clear out the confusion.\n\nWithout further ado, let's get started 😊\n\nHave you ever wondered why you can't access some of the variables outside a function? Or did you find it strange that you can have the same variable name outside a function and inside a function as well? The reason for this strange behavior is that every variable, function, or code block has its own scope.\n\nAccording to MDN, the scope is,\n\nWhat does this mean?\n\nScope in JavaScript refers to the accessibility or visibility of variables and expressions. That means the space where an item, such as a variable or a function, is visible and accessible in your code.\n\nFor example, once a variable is declared, it can only be accessible within the scope that it has been declared in and will not be accessible outside the scope.\n\nLet's look at a couple of examples to understand this.\n\nIn the above example, we have declared a variable userName and assigned the value of Sarah. No issue or error is coming up when we want to access this variable and print the name to the console.\n\nNow let's declare this variable inside a function and print the value to the console outside the function.\n\nIn the above example, when trying to log the variable, JavaScript throws an error, ReferenceError: userName is not defined. This is because the greeting function creates a scope for the userName variable. And the userName variable can be accessed only within this scope, inside the function.\n\nYou might think that this behavior is strange. But having a scope for variables and expressions helps us to write efficient code and avoid conflicts and errors within our code.\n\nOne of the main benefits of scope is ownership. If we can access all variables from anywhere within our program, it will lead to unintended modifications to the variable from other parts of the program. Which means anyone can change them from anywhere at any given time.\n\nWith scoping, we can only access the variables in a certain area of the code. The scope helps to avoid these modifications, which help us to write secure code.\n\nThe scope helps to avoid name collision. For example, imagine that you have to use the same variable name in a different place in your program for a different purpose, or someone else from your team has already declared a variable in the global scope, and you want to identify the boundary of this variable.\n\nHaving clear scope on where you can access a variable makes it easier to identify its boundary, avoid assigning more values to the same variable, and use the same variable name in multiple locations within the code without altering the values.\n\nIn dynamic languages like JavaScript, when we complete the usage of a variable, the data will be automatically garbage collected. If we don't have a clear scope on where we can access certain variables, the compiler will not be able to identify when to collect the garbage, except at the end.\n\nHaving a clear scope on where variables can be accessed helps the compiler to garbage collect these variables at the end of each scope.\n\nJavaScript has three different types of scope.\n\nLet's take a few examples to understand these three different scopes.\n\nVariables declared outside of functions or code blocks (curly braces { }) are considered to have a global scope. The outermost scope contains the entire code, and there is only one global scope in the program.\n\nThe variables defined in the global scope are named Global Variables and can be accessed and altered in any other scopes.\n\nCheck the below example. The function greeting can access the userName variable inside the function, and it is located in the global scope.\n\nWe have the accessibility to change the value of the variable anywhere in the code with global scope. Check the below example.\n\nIn the above example, we have reassigned the value of the variable userName inside the function. And it has modified the value of the variable inside the global scope.\n\nThis means that we can alter global variables anywhere within our code. Therefore, it is advised to only use global variables if and only if necessary as a best practice.\n\nLet's move on to the function scope.\n\nEach and every function creates its own scope. And the variables declared inside that function are only accessible inside that function and any of its nested functions. This is also called Local Scope.\n\nCheck the below examples to understand the function scope.\n\nIn the above example, we have a function to calculate the age. However, when trying to print the variables currentYear and age, JavaScript throws an error ReferenceError: currentYear is not defined. This is because the calcAge() function creates a scope for these variables, which can only be accessed within the function scope.\n\nI hope now you can understand how the function scope works. Let's move on to block scope.\n\nES6 introduced let and const variables. With that, it introduced the block scope. Block scope means that the variables defined inside a code clock {} can only be used inside it.\n\nFor example, a variable created inside an if statement or for loop can only be accessed within that code block. Same as function scope, it is not accessible outside of the block scope.\n\nWhile let and const are block scoped, the variables defined with var have their scope limited to the current function scope or the global scope. Suppose we declare a variable using var, that variable is accessible outside the block. So, the variable declared using var within a code block is not block scoped; It is function scoped.\n\nCheck the below example,\n\nIn the above example, we have declared working using var and message using const. When trying to print the variable message, JavaScript throws an error ReferenceError: message is not defined at calcAge. This is because the if block creates a scope for this variable, which is only accessible within that block scope.\n\nHowever, there is no error when trying to access working outside the code block. As explained before, this is because var is not block scoped, it's function scoped. So you can access working inside the calcAge() function since it's the current function scope. But if we try to access the working outside the calcAge() function, then JavaScript will throw an error.\n\nThe scope can be nested, which means you can create functions inside another function, block inside another function, function inside another block, or block inside a block.\n\nThe scope contained within another scope is named inner scope. And the scope that wraps another scope is named outer scope.\n\nWhen there are nested scopes, the inner scope can also access the outer scope variables. But outside of the scopes, these variables are not accessible. So outer scope does not have access to the variables of inner functions or blocks.\n\nCheck the below example to understand this behavior.\n\nIn the above example, the yearsToRetire() function and if block are nested inside the calcAge() function. To calculate the retirement, we have accessed the age variable, which is declared in the outer scope, inside the calcAge() function.\n\nAlso, we have accessed the userName variable, which is declared in the calcAge() function scope, in both yearsToRetire() function and if block. We can look outwards to access variables in the parent's scope with nested scope. It could be a variable inside an outer function, outer block, or a global variable.\n\nI hope now you have a better understanding of global, function, and block scope. However, before moving to the scope chain, there is one more scope that we should learn, which is lexical scope.\n\nLexical scoping means that organizing and accessing variables are controlled by where we write our functions and code blocks.\n\nFor example, a function that is written inside another function has access to the variables of the parent function despite where the function is invoked.\n\nSo the lexical scoping means that the scope is defined at the location where the variable or function is defined, and not where they run.\n\nLet's check the below example to understand this.\n\nLet's see what has happened here:\n• When the function is called, it creates a local variable and sets its value as .\n• In the next line, the function is called, and function is defined outside the function.\n• function logs the variable, but is not defined in the scope. So we have to go up one scope to the global scope to get the value of which is .\n• Even though we have right above where the function invokes, we have never accessed that value.\n• This is because lexical scoping requires us to go where the functions are defined, not where they run.\n\nI hope now you understand what lexical scope is. So let's move on to the scope chain.\n\nThe scope chain is how Javascript looks for variables. When looking for variables through the nested scope, the inner scope first looks at its own scope. If the variable is not assigned locally, which is inside the inner function or block scope, then JavaScript will look at the outer scope of said function or block to find the variable. If Javascript could not find the variable in any of the outer scopes on the chain, it will throw a reference error.\n\nLet's take an example and go through this process step by step. Check the below code.\n\nIn the above example,\n• We have an outer function , which is in the global scope.\n• We have an inner function, , nested inside function.\n• Also, we have an block inside the function.\n\nWith the above example, let's try to understand how the scope chain works.\n\nFirst, we have the global scope, which has only one variable, userName. There is a function declared in the global scope, which is calcAge(). But to keep things simple, let's focus on the variables. And keep in mind that function and variables work the same way in the scope chain.\n\nIf you remember, each function creates its own scope. So inside the global scope, the first function scope is created with the calcAge() function.\n\nInside the calcAge() function there are two variables declared, which are currentYear and age. Also, we have access to the global variable userName inside the calcAge() function.\n\nIf we have any need to access the variable userName inside this function, then JavaScript looks inside the calcAge() function to see whether the variable is declared inside the scope. When JavaScript can't find it there, it will reach out to the outer scope, that is the global scope.\n\nNext, inside the first scope, there is a second function, yearsToRetire(), which also creates its own scope containing the retirement variable set to 60 - age. Now we have a nested structure of scopes with one scope inside the other.\n\nWe have a string that needs access to userName variable inside this function. Since JavaScript cannot find this variable within the local scope, it will look up in the scope chain until it finds the variable and uses it.\n\nAlso, inside this yearsToRetire() function scope we also have the access to variables inside the caclAge function scope, since caclAge is the parent scope and outer scope of yearsToRetire() function.\n\nThere is an if block inside the calcAge() function, which has the two variables declared inside that. However, as I explained earlier, the variable declared with var is not block scoped. So the variable working will be a part of the calcAge() function scope. Since the working is in the calcAge() function scope, the yearsToRetire() function scope also has access to it.\n\nThe scope chain applies to block scope as well. Therefore, the if block scope gets access to all the variables from its outer scope. So the block scope can access the variable inside the calcAge() function scope and global scope.\n\nAnother important thing to remember is that the if block scope does not have access to any variables in the yearsToRetire() function scope, and vice versa. The reason for this is lexical scoping.\n\nThe way we can access variables depends on where the scope is placed or where it is written in the code. In this scenario, none of these two scopes is written inside one another. We could say that they are sibling scopes since they are both child scopes of the calcAge() function scope. So, according to the lexical scoping, they cannot access each other's variables. Scope chain only works upwards, not sideways.\n\nSo this is how the scope chain works. If one scope needs to use a certain variable but cannot find it in the scope, it will look up in the scope chain and check whether it can find a variable on one of the outer scopes. If the variable is available in the outer scope, then the child scope has the access to it. If it is not there in any outer scopes, the JavaScript will throw a reference error. So this process is called variable lookup.\n\nI hope this post helped you understand the different types of scopes in JavaScript and how the scope chain works."
    },
    {
        "link": "https://cabulous.medium.com/javascript-execution-context-scope-chain-closure-and-this-part-4-961acd9689c9",
        "document": "Many find the following concepts are the complicated part of JavaScript:\n\nThese concepts are more comfortable to understand than they look like, especially with the knowledge of the execution context.\n\nWhat are these three concepts in common? They all relate to the variable lookup, the way the JavaScript engines looks for a variable.\n\nA variable lookup could be confusing in the following example.\n\nWhen executing the function, we have three stacked execution contexts in position:\n\nNext, the console begins looking up the variable.\n\nIntuitively, we may analyze the chain lookup by following a top-to-bottom flow in the call stack. The console would log “banana” because it finds the variable in the function execution context.\n\nBy contrast, the console actually logs “apple” assigned in the global execution context.\n\nOur chain lookup missed a critical component in the execution context, the outer.\n\nThe outer defined how the JavaScript engine performs the chain lookup, also known as the scope chain.\n\nIf we look into the execution context, its outer points to the global execution context.\n\nIn this case, the JavaScript engine looks for an variable in the global execution context immediately after failing to find it in the execution context.\n\nNot really. The outer concept leads to another question.\n\nWhy the outer of execution context points to the global one instead of the ?\n\nAfter all, the function is called inside of the . Shouldn’t the scope chain follow the call stack?\n\nCounterintuitively, JavaScript’s scope chain is defined by the lexical scope and never influenced by the call stack.\n\nFrom the two-step process perspective, the scope chain is defined at the compiling step, not the execution step.\n\nTo further answer this question, we need to demystify how JavaScript designs its lexical scope.\n\nJavaScript engine has a rule: the lexical scope is defined by where the function located.\n\nLet’s take a look at the same example from a lexical scope perspective.\n\nIn this case, the and functions are declared in the global scope. Therefore, their lexical scopes are the global scope.\n\nWhen the JavaScript engine compiles the script, the outers in both function execution contests are pointed to the global execution context.\n\nTo better understand this feature, let’s take a look at another example. Instead of declaring functions in the global scope, we indent each function inside of the previous one.\n• function is defined in the global scope;\n• function is defined in the scope;\n• function is defined in the scope.\n\nBased on lexical scopes, we can reason the outer in each execution context:\n• In execution context, the outer points to execution context;\n• In execution context, the outer points to execution context;\n• In execution context, the outer points to the global execution context.\n\nAt the end of the execution, the console logs “30.”\n\nThat’s how the scope chain works in the JavaScript execution context.\n\nThe closure is more straightforward to understand than it sounds. Let’s take a look at an example.\n\nWe have the following call stack right before the is returned and assigned to the variable.\n\nAfter returning the , the function execution ends, and its execution context is removed.\n\nMeanwhile, variable and lexical environments disappear, and variables inside of them are supported to be destroyed.\n\nAt this moment, JavaScript’s lexical scope rule kicks in — an inner function can always access to variables in its outer function.\n\nHere, the inner functions are and , and the outer function is .\n\nThe function uses two variables, and , while function uses the .\n\nFollowing the rule, and variables are kept in a separate area. It is an exclusive area where can only be accessed by and function, also known as the closure.\n\nMeanwhile, the variable is destroyed because no methods hold a reference to it.\n\nNext, the execution continues and calls the function. The JavaScript engine looks through the scope chain and locates the variable in the closure. The value of the is set to “20.”\n\nIn the last line, the is called. Following the same chain lookup, the JavaScript engine finds the and variables in the closure and logs out “apple” and “20” correspondingly.\n\nBy running the example codes in your Chrome, you can see the closure in its dev tools."
    },
    {
        "link": "https://explainthis.io/en/swe/what-is-scope-and-scope-chain",
        "document": "Your support will help us to continue to provide quality content. 👉 Buy Me a Coffee\n\nScope, as the name suggests, refers to the range that a variable can be accessed. There are three types of scope in JavaScript: global scope, function scope, and block scope. According to MDN, the scope is the current execution context in which values and expressions are \"visible\" or can be referenced. In other words, if a variable or expression is not in the current scope, it cannot be accessed.\n\nJavaScript has three types of scope:\n• None Global Scope: When JavaScript code is executed, a global execution context will be created. Variables defined outside the function or block level will belong to the global scope. These variables is known as Global variable and can be used anywhere. The value of variable in the following example is a global variable in the global scope.\n• None Block Scope: Introduced in ES6, block scope is defined in a block level. It should be noted that only variables declared by and will have to block-level scope, and variables defined by will have function scope. As in the following example, in the condition, variable has a block scope but has a function scope.\n\nScope chain is a mechanism in JavaScript to resolve the value of variable names. The process of resolving a variable value is like a chain, so we call it scope chain\n\nThe scope chain starts with the innermost (or local) scope. If the variable cannot be found in the current scope, it will keep looking for the variable in the parent scope and all the way up to the global scope. If it's still not found in the global scope, an error will be thrown directly.\n\nIn a scope chain, if a variable with the same name is declared in multiple scopes, the innermost (or local) declaration takes precedence."
    }
]