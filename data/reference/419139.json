[
    {
        "link": "https://stackoverflow.com/questions/27070775/dictionary-mapping-python",
        "document": "Here's my code: Create a class, rit_object is a private class than has types for the parameters:\n\nRead through file. the output should resemble:\n\nif my total occurrences uses 'words' from my readWordFile, is my totaloccurences function working corrctly to produces the total count for each year?"
    },
    {
        "link": "https://stackoverflow.com/questions/12229064/mapping-over-values-in-a-python-dictionary",
        "document": "While my original answer missed the point (by trying to solve this problem with the solution to Accessing key in factory of defaultdict), I have reworked it to propose an actual solution to the present question.\n\nHere it is:\n\nThe idea is to subclass the original dict to give it the desired functionality: \"mapping\" a function over all the values.\n\nThe plus point is that this dictionary can be used to store the original data as if it was a , while transforming any data on request with a callback.\n\nOf course, feel free to name the class and the function the way you want (the name chosen in this answer is inspired by PHP's function).\n\nNote: Neither the - block nor the statements are mandatory for the functionality, they are there to further mimic the behavior of the PHP's ."
    },
    {
        "link": "https://github.com/IsakNyberg/7-Segment-Display-Python-Dictionary",
        "document": "A Python dictionary for a digit in a 7 segment display with a decimal point\n\nAdigit is stored as a byte in the order DP A B C D E F G where each letter represents a segment in the following way:\n\nFor those who just want to copy the text:"
    },
    {
        "link": "https://docs.python.org/3/library/collections.html",
        "document": "This module implements specialized container datatypes providing alternatives to Python’s general purpose built-in containers, , , , and .\n\nA class is provided for quickly linking a number of mappings so they can be treated as a single unit. It is often much faster than creating a new dictionary and running multiple calls. The class can be used to simulate nested scopes and is useful in templating. A groups multiple dicts or other mappings together to create a single, updateable view. If no maps are specified, a single empty dictionary is provided so that a new chain always has at least one mapping. The underlying mappings are stored in a list. That list is public and can be accessed or updated using the maps attribute. There is no other state. Lookups search the underlying mappings successively until a key is found. In contrast, writes, updates, and deletions only operate on the first mapping. A incorporates the underlying mappings by reference. So, if one of the underlying mappings gets updated, those changes will be reflected in . All of the usual dictionary methods are supported. In addition, there is a maps attribute, a method for creating new subcontexts, and a property for accessing all but the first mapping: A user updateable list of mappings. The list is ordered from first-searched to last-searched. It is the only stored state and can be modified to change which mappings are searched. The list should always contain at least one mapping. Returns a new containing a new map followed by all of the maps in the current instance. If is specified, it becomes the new map at the front of the list of mappings; if not specified, an empty dict is used, so that a call to is equivalent to: . If any keyword arguments are specified, they update passed map or new empty dict. This method is used for creating subcontexts that can be updated without altering values in any of the parent mappings. Changed in version 3.4: The optional parameter was added. Property returning a new containing all of the maps in the current instance except the first one. This is useful for skipping the first map in the search. Use cases are similar to those for the keyword used in nested scopes. The use cases also parallel those for the built-in function. A reference to is equivalent to: . Note, the iteration order of a is determined by scanning the mappings last to first: This gives the same ordering as a series of calls starting with the last mapping: Changed in version 3.9: Added support for and operators, specified in PEP 584.\n• None The MultiContext class in the Enthought CodeTools package has options to support writing to any mapping in the chain.\n• None Django’s Context class for templating is a read-only chain of mappings. It also features pushing and popping of contexts similar to the method and the property.\n• None The Nested Contexts recipe has options to control whether writes and other mutations apply only to the first mapping or to any mapping in the chain. This section shows various approaches to working with chained maps. Example of letting user specified command-line arguments take precedence over environment variables which in turn take precedence over default values: Example patterns for using the class to simulate nested contexts: # Child of c, independent from d # Get first key in the chain of contexts The class only makes updates (writes and deletions) to the first mapping in the chain while lookups will search the full chain. However, if deep writes and deletions are desired, it is easy to make a subclass that updates keys found deeper in the chain: 'Variant of ChainMap that allows direct updates to inner scopes' # update an existing key two levels down # new keys get added to the topmost dict # remove an existing key one level down\n\nA counter tool is provided to support convenient and rapid tallies. For example: # Find the ten most common words in Hamlet [('the', 1143), ('and', 966), ('to', 762), ('of', 669), ('i', 631), ('you', 554), ('a', 546), ('my', 514), ('hamlet', 471), ('in', 451)] A is a subclass for counting hashable objects. It is a collection where elements are stored as dictionary keys and their counts are stored as dictionary values. Counts are allowed to be any integer value including zero or negative counts. The class is similar to bags or multisets in other languages. Elements are counted from an iterable or initialized from another mapping (or counter): # a new counter from an iterable Counter objects have a dictionary interface except that they return a zero count for missing items instead of raising a : # count of a missing element is zero Setting a count to zero does not remove an element from a counter. Use to remove it entirely: Changed in version 3.7: As a subclass, inherited the capability to remember insertion order. Math operations on Counter objects also preserve order. Results are ordered according to when an element is first encountered in the left operand and then by the order encountered in the right operand. Counter objects support additional methods beyond those available for all dictionaries: Return an iterator over elements repeating each as many times as its count. Elements are returned in the order first encountered. If an element’s count is less than one, will ignore it. Return a list of the n most common elements and their counts from the most common to the least. If n is omitted or , returns all elements in the counter. Elements with equal counts are ordered in the order first encountered: Elements are subtracted from an iterable or from another mapping (or counter). Like but subtracts counts instead of replacing them. Both inputs and outputs may be zero or negative. Compute the sum of the counts. The usual dictionary methods are available for objects except for two which work differently for counters. This class method is not implemented for objects. Elements are counted from an iterable or added-in from another mapping (or counter). Like but adds counts instead of replacing them. Also, the iterable is expected to be a sequence of elements, not a sequence of pairs. Counters support rich comparison operators for equality, subset, and superset relationships: , , , , , . All of those tests treat missing elements as having zero counts so that returns true. Changed in version 3.10: In equality tests, missing elements are treated as having zero counts. Formerly, and were considered distinct. Several mathematical operations are provided for combining objects to produce multisets (counters that have counts greater than zero). Addition and subtraction combine counters by adding or subtracting the counts of corresponding elements. Intersection and union return the minimum and maximum of corresponding counts. Equality and inclusion compare corresponding counts. Each operation can accept inputs with signed counts, but the output will exclude results with counts of zero or less. Unary addition and subtraction are shortcuts for adding an empty counter or subtracting from an empty counter. Added in version 3.3: Added support for unary plus, unary minus, and in-place multiset operations. Counters were primarily designed to work with positive integers to represent running counts; however, care was taken to not unnecessarily preclude use cases needing other types or negative values. To help with those use cases, this section documents the minimum range and type restrictions.\n• None The class itself is a dictionary subclass with no restrictions on its keys and values. The values are intended to be numbers representing counts, but you could store anything in the value field.\n• None The method requires only that the values be orderable.\n• None For in-place operations such as , the value type need only support addition and subtraction. So fractions, floats, and decimals would work and negative values are supported. The same is also true for and which allow negative and zero values for both inputs and outputs.\n• None The multiset methods are designed only for use cases with positive values. The inputs may be negative or zero, but only outputs with positive values are created. There are no type restrictions, but the value type needs to support addition, subtraction, and comparison.\n• None The method requires integer counts. It ignores zero and negative counts.\n• None For mathematical operations on multisets and their use cases, see Knuth, Donald. The Art of Computer Programming Volume II, Section 4.6.3, Exercise 19.\n• None To enumerate all distinct multisets of a given size over a given set of elements, see :\n\nReturns a new deque object initialized left-to-right (using ) with data from iterable. If iterable is not specified, the new deque is empty. Deques are a generalization of stacks and queues (the name is pronounced “deck” and is short for “double-ended queue”). Deques support thread-safe, memory efficient appends and pops from either side of the deque with approximately the same O(1) performance in either direction. Though objects support similar operations, they are optimized for fast fixed-length operations and incur O(n) memory movement costs for and operations which change both the size and position of the underlying data representation. If maxlen is not specified or is , deques may grow to an arbitrary length. Otherwise, the deque is bounded to the specified maximum length. Once a bounded length deque is full, when new items are added, a corresponding number of items are discarded from the opposite end. Bounded length deques provide functionality similar to the filter in Unix. They are also useful for tracking transactions and other pools of data where only the most recent activity is of interest. Add x to the right side of the deque. Add x to the left side of the deque. Remove all elements from the deque leaving it with length 0. Count the number of deque elements equal to x. Extend the right side of the deque by appending elements from the iterable argument. Extend the left side of the deque by appending elements from iterable. Note, the series of left appends results in reversing the order of elements in the iterable argument. Return the position of x in the deque (at or after index start and before index stop). Returns the first match or raises if not found. Insert x into the deque at position i. If the insertion would cause a bounded deque to grow beyond maxlen, an is raised. Remove and return an element from the right side of the deque. If no elements are present, raises an . Remove and return an element from the left side of the deque. If no elements are present, raises an . Remove the first occurrence of value. If not found, raises a . Reverse the elements of the deque in-place and then return . Rotate the deque n steps to the right. If n is negative, rotate to the left. When the deque is not empty, rotating one step to the right is equivalent to , and rotating one step to the left is equivalent to . Maximum size of a deque or if unbounded. In addition to the above, deques support iteration, pickling, , , , , membership testing with the operator, and subscript references such as to access the first element. Indexed access is O(1) at both ends but slows to O(n) in the middle. For fast random access, use lists instead. # make a new deque with three items # add a new entry to the right side # add a new entry to the left side # show the representation of the deque # list the contents of the deque # list the contents of a deque in reverse # cannot pop from an empty deque : This section shows various approaches to working with deques. Bounded length deques provide functionality similar to the filter in Unix: 'Return the last n lines of a file' Another approach to using deques is to maintain a sequence of recently added elements by appending to the right and popping to the left: A round-robin scheduler can be implemented with input iterators stored in a . Values are yielded from the active iterator in position zero. If that iterator is exhausted, it can be removed with ; otherwise, it can be cycled back to the end with the method: The method provides a way to implement slicing and deletion. For example, a pure Python implementation of relies on the method to position elements to be popped: To implement slicing, use a similar approach applying to bring a target element to the left side of the deque. Remove old entries with , add new entries with , and then reverse the rotation. With minor variations on that approach, it is easy to implement Forth style stack manipulations such as , , , , , , and .\n\nReturn a new dictionary-like object. is a subclass of the built-in class. It overrides one method and adds one writable instance variable. The remaining functionality is the same as for the class and is not documented here. The first argument provides the initial value for the attribute; it defaults to . All remaining arguments are treated the same as if they were passed to the constructor, including keyword arguments. objects support the following method in addition to the standard operations: If the attribute is , this raises a exception with the key as argument. If is not , it is called without arguments to provide a default value for the given key, this value is inserted in the dictionary for the key, and returned. If calling raises an exception this exception is propagated unchanged. This method is called by the method of the class when the requested key is not found; whatever it returns or raises is then returned or raised by . Note that is not called for any operations besides . This means that will, like normal dictionaries, return as a default rather than using . This attribute is used by the method; it is initialized from the first argument to the constructor, if present, or to , if absent. Changed in version 3.9: Added merge ( ) and update ( ) operators, specified in PEP 584. Using as the , it is easy to group a sequence of key-value pairs into a dictionary of lists: When each key is encountered for the first time, it is not already in the mapping; so an entry is automatically created using the function which returns an empty . The operation then attaches the value to the new list. When keys are encountered again, the look-up proceeds normally (returning the list for that key) and the operation adds another value to the list. This technique is simpler and faster than an equivalent technique using : Setting the to makes the useful for counting (like a bag or multiset in other languages): When a letter is first encountered, it is missing from the mapping, so the function calls to supply a default count of zero. The increment operation then builds up the count for each letter. The function which always returns zero is just a special case of constant functions. A faster and more flexible way to create constant functions is to use a lambda function which can supply any constant value (not just zero): Setting the to makes the useful for building a dictionary of sets:\n\nNamed tuples assign meaning to each position in a tuple and allow for more readable, self-documenting code. They can be used wherever regular tuples are used, and they add the ability to access fields by name instead of position index. Returns a new tuple subclass named typename. The new subclass is used to create tuple-like objects that have fields accessible by attribute lookup as well as being indexable and iterable. Instances of the subclass also have a helpful docstring (with typename and field_names) and a helpful method which lists the tuple contents in a format. The field_names are a sequence of strings such as . Alternatively, field_names can be a single string with each fieldname separated by whitespace and/or commas, for example or . Any valid Python identifier may be used for a fieldname except for names starting with an underscore. Valid identifiers consist of letters, digits, and underscores but do not start with a digit or underscore and cannot be a such as class, for, return, global, pass, or raise. If rename is true, invalid fieldnames are automatically replaced with positional names. For example, is converted to , eliminating the keyword and the duplicate fieldname . defaults can be or an iterable of default values. Since fields with a default value must come after any fields without a default, the defaults are applied to the rightmost parameters. For example, if the fieldnames are and the defaults are , then will be a required argument, will default to , and will default to . If module is defined, the attribute of the named tuple is set to that value. Named tuple instances do not have per-instance dictionaries, so they are lightweight and require no more memory than regular tuples. To support pickling, the named tuple class should be assigned to a variable that matches typename. Changed in version 3.6: The verbose and rename parameters became keyword-only arguments. Changed in version 3.7: Removed the verbose parameter and the attribute. Changed in version 3.7: Added the defaults parameter and the attribute. # fields also accessible by name Named tuples are especially useful for assigning field names to result tuples returned by the or modules: In addition to the methods inherited from tuples, named tuples support three additional methods and two attributes. To prevent conflicts with field names, the method and attribute names start with an underscore. Class method that makes a new instance from an existing sequence or iterable. Return a new which maps field names to their corresponding values: Changed in version 3.1: Returns an instead of a regular . Changed in version 3.8: Returns a regular instead of an . As of Python 3.7, regular dicts are guaranteed to be ordered. If the extra features of are required, the suggested remediation is to cast the result to the desired type: . Return a new instance of the named tuple replacing specified fields with new values: Named tuples are also supported by generic function . Changed in version 3.13: Raise instead of for invalid keyword arguments. Tuple of strings listing the field names. Useful for introspection and for creating new named tuple types from existing named tuples. To retrieve a field whose name is stored in a string, use the function: To convert a dictionary to a named tuple, use the double-star-operator (as described in Unpacking Argument Lists): Since a named tuple is a regular Python class, it is easy to add or change functionality with a subclass. Here is how to add a calculated field and a fixed-width print format: The subclass shown above sets to an empty tuple. This helps keep memory requirements low by preventing the creation of instance dictionaries. Subclassing is not useful for adding new, stored fields. Instead, simply create a new named tuple type from the attribute: Docstrings can be customized by making direct assignments to the fields: 'List of authors sorted by last name'\n• None See for a way to add type hints for named tuples. It also provides an elegant notation using the keyword:\n• None See for a mutable namespace based on an underlying dictionary instead of a tuple.\n• None The module provides a decorator and functions for automatically adding generated special methods to user-defined classes.\n\nOrdered dictionaries are just like regular dictionaries but have some extra capabilities relating to ordering operations. They have become less important now that the built-in class gained the ability to remember insertion order (this new behavior became guaranteed in Python 3.7). Some differences from still remain:\n• None The regular was designed to be very good at mapping operations. Tracking insertion order was secondary.\n• None The was designed to be good at reordering operations. Space efficiency, iteration speed, and the performance of update operations were secondary.\n• None The algorithm can handle frequent reordering operations better than . As shown in the recipes below, this makes it suitable for implementing various kinds of LRU caches.\n• None The equality operation for checks for matching order. A regular can emulate the order sensitive equality test with p == q and all(k1 == k2 for k1, k2 in zip(p, q)) .\n• None The method of has a different signature. It accepts an optional argument to specify which item is popped. A regular can emulate OrderedDict’s with which is guaranteed to pop the rightmost (last) item. A regular can emulate OrderedDict’s with which will return and remove the leftmost (first) item if it exists.\n• None has a method to efficiently reposition an element to an endpoint. A regular can emulate OrderedDict’s with which will move the key and its associated value to the rightmost (last) position. A regular does not have an efficient equivalent for OrderedDict’s which moves the key and its associated value to the leftmost (first) position. Return an instance of a subclass that has methods specialized for rearranging dictionary order. The method for ordered dictionaries returns and removes a (key, value) pair. The pairs are returned in order if last is true or order if false. Move an existing key to either end of an ordered dictionary. The item is moved to the right end if last is true (the default) or to the beginning if last is false. Raises if the key does not exist: In addition to the usual mapping methods, ordered dictionaries also support reverse iteration using . Equality tests between objects are order-sensitive and are roughly equivalent to . Equality tests between objects and other objects are order-insensitive like regular dictionaries. This allows objects to be substituted anywhere a regular dictionary is used. Changed in version 3.5: The items, keys, and values views of now support reverse iteration using . Changed in version 3.6: With the acceptance of PEP 468, order is retained for keyword arguments passed to the constructor and its method. Changed in version 3.9: Added merge ( ) and update ( ) operators, specified in PEP 584. It is straightforward to create an ordered dictionary variant that remembers the order the keys were last inserted. If a new entry overwrites an existing entry, the original insertion position is changed and moved to the end: 'Store items in the order the keys were last added' An would also be useful for implementing variants of : \"LRU Cache that invalidates and refreshes old entries.\" it has been requested multiple times. To avoid flushing the LRU cache with one-time requests, we don't cache until a request has been made more than once.\n\nThis class acts as a wrapper around list objects. It is a useful base class for your own list-like classes which can inherit from them and override existing methods or add new ones. In this way, one can add new behaviors to lists. The need for this class has been partially supplanted by the ability to subclass directly from ; however, this class can be easier to work with because the underlying list is accessible as an attribute. Class that simulates a list. The instance’s contents are kept in a regular list, which is accessible via the attribute of instances. The instance’s contents are initially set to a copy of list, defaulting to the empty list . list can be any iterable, for example a real Python list or a object. In addition to supporting the methods and operations of mutable sequences, instances provide the following attribute: A real object used to store the contents of the class. Subclassing requirements: Subclasses of are expected to offer a constructor which can be called with either no arguments or one argument. List operations which return a new sequence attempt to create an instance of the actual implementation class. To do so, it assumes that the constructor can be called with a single parameter, which is a sequence object used as a data source. If a derived class does not wish to comply with this requirement, all of the special methods supported by this class will need to be overridden; please consult the sources for information about the methods which need to be provided in that case."
    },
    {
        "link": "https://raspi.tv/2015/7-segment-display-python-raspberry-pi-countdown-ticker",
        "document": "Continuing with our theme of 7-segment displays driven directly from the Raspberry Pi’s GPIO using Python, I was asked for an explanation of the code from the previous post. In order to explain something, you first have to fully understand it, so I took some time to have a good look at the ‘business end’ of Bertwert’s code and figured out exactly how it works.\n\nI’ve now put a full code walkthrough of that script in the comments section of the previous post.\n\nHaving done that, and having had a tweet from David Meiklejohn saying he’d done something similar in the past…\n\n…I had a look at David’s code, which reminded me that you can use Python list variables with RPi.GPIO to switch multiple ports at once. More on this, a bit later.\n\nSo having ‘done’ a clock last time, today, I thought we’d have some fun with a simple countdown ticker. I wanted to see how fast we could drive the display, so I’ve made it count down from 9999 to 0 and placed it on an imaginary ‘stick of dynamite’. See it in action in the video…\n\nWant To Have A Go?\n\nIf you’d like to have a go at this project, I have a limited number of kits available for £12 including global shipping. Here’s what’s in the kit. Pick yours up today and start playing with 7-segment displays on your Pi…\n\nI also wanted to have a go at creating some other characters. You’re a bit limited with what letters you can create on a 7-segment display, but it’s fun to see what can be done. Let’s have a look at how it’s done…\n\nWe need a diagram to help us here…\n\nLook at the white lettering on the right-hand side. Each of the segments has a name a-g or dp.\n\nIn our dictionary in the Python script, each entry has an 8 digit list of 1s and 0s. The first list element corresponds to a and they go in alphabetical order, ending with dp (decimal point).\n\nOur letter L has a, b & c inactive (0), d, e & f active (1), g and dp inactive (0).\n\nSo let’s suppose we wanted to create the letter P. Looking at the diagram, we can make a P if we light all of the segments except for c, d and dp. But we have to map this in the correct order for our dictionary. So here’s what we arrive at…\n\nSo you add that entry to your dictionary – it doesn’t matter where, but make sure you have a comma at the end of the line to match the correct format (the last entry has a }).\n\nAnd that’s really all there is to it. Some letters are difficult/impossible. I couldn’t do an X, so my X is the same as the standard 7seg H. All letters with diagonal lines on are tricky for this kind of 7 segment display.\n\nNow onto the code tweaks…\n\nI knew this was possible, but I’d never used it before. Using this feature of RPi.GPIO allows us to completely eliminate our loop. This makes our code shorter, simpler and easier to understand.\n\n…which means one less loop and one less level of slicing to get our heads around. In we’re finding the segment values in our dictionary for the nth of our display string .\n\nAnother way we can simplify the code is to change…\n\nWe can do all this with one line of code…\n\n…using our list variable and taking advantage of the fact that we can set an initial value for each port at the time of setup, using or .\n\nFor these two tweaks to work correctly, we have to add a ‘ ‘ to the end of each character defined in our dictionary because we defined 8 ports in our list variable (the last entry represents the decimal point).\n\nI’ve incorporated all of the above changes into the new code. I’ve also changed to to make the code easier to read and understand.\n\nLines 1-2 import the libraries we need\n\n Line 3 sets up BCM mode for RPi.GPIO\n\n Lines 6-8 create a list variable for the segment ports and initialise them all to outputs at 0\n\n Lines 11-13 create a list variable for the digit ports and initialise them all to outputs at 1 (remember setting these ports to 0 activates the digits on the 7-seg)\n\n Lines 16-32 define our dictionary of characters to display. Notice we’ve added a few new ones from last time, namely b, y, E, A, L, & X.\n\n Lines 34-39 I’ve taken the main segment/digit driving code and put it in a function. This is so that we can reuse the same code in two different loops in our main code block without repeating it.\n\n Line 35 iterates through the digits.\n\n Line 36 sets all of the segments’ GPIO ports in one line using list variable and looking up the appropriate character for the current in our dictionary \n\n Lines 37-39 activate our digit for a millisecond and then deactivate it. Then the loop can go to the next iteration\n\n Lines 40-55 contain our main program block, wrapped with a so that we can clean up our GPIO ports on exit, error, or exception.\n\n Lines 41-47 First we set our counter to 9999, then we start a loop that continues until we reach 0. Line 43 displays the current value of our counter. 44-45 check if we’ve got to 0 yet, and if we have, changes the to ” byE”. 46 calls the function we defined in 34-39 to display the current . 47 decrements the counter value by 1. Then the loop starts again.\n\n Lines 49-53 determine what happens when our countdown is completed. In 48 we set back to 1000, so that we can display ” byE” for 500 iterations. In line 50, once n goes below 500 we change the to “ALEX” (although the X is more of an H – it’s the best we can do on a 7-seg). Line 52 calls our function to display the current .\n\nWant To Have A Go?\n\nIf you’d like to have a go at this project, I have a limited number of kits available for £12 including global shipping. Here’s what’s in the kit. Pick yours up today and start playing with 7-segment displays on your Pi…"
    },
    {
        "link": "https://automatetheboringstuff.com/2e/chapter8",
        "document": "Input validation code checks that values entered by the user, such as text from the input() function, are formatted correctly. For example, if you want users to enter their ages, your code shouldn’t accept nonsensical answers such as negative numbers (which are outside the range of acceptable integers) or words (which are the wrong data type). Input validation can also prevent bugs or security vulnerabilities. If you implement a withdrawFromAccount() function that takes an argument for the amount to subtract from an account, you need to ensure the amount is a positive number. If the withdrawFromAccount() function subtracts a negative number from the account, the “withdrawal” will end up adding money!\n\nTypically, we perform input validation by repeatedly asking the user for input until they enter valid text, as in the following example:\n\nwhile True:\n\n print('Enter your age:')\n\n age = input()\n\n try:\n\n age = int(age)\n\n except:\n\n print('Please use numeric digits.')\n\n continue\n\n if age < 1:\n\n print('Please enter a positive number.')\n\n continue\n\n break\n\n\n\n print(f'Your age is {age}.')\n\nWhen you run this program, the output could look like this:\n\nEnter your age:\n\n five\n\n Please use numeric digits.\n\n Enter your age:\n\n -2\n\n Please enter a positive number.\n\n Enter your age:\n\n 30\n\n Your age is 30.\n\nWhen you run this code, you’ll be prompted for your age until you enter a valid one. This ensures that by the time the execution leaves the while loop, the age variable will contain a valid value that won’t crash the program later on.\n\nHowever, writing input validation code for every input() call in your program quickly becomes tedious. Also, you may miss certain cases and allow invalid input to pass through your checks. In this chapter, you’ll learn how to use the third-party PyInputPlus module for input validation.\n\nPyInputPlus contains functions similar to input() for several kinds of data: numbers, dates, email addresses, and more. If the user ever enters invalid input, such as a badly formatted date or a number that is outside of an intended range, PyInputPlus will reprompt them for input just like our code in the previous section did. PyInputPlus also has other useful features like a limit for the number of times it reprompts users and a timeout if users are required to respond within a time limit.\n\nPyInputPlus is not a part of the Python Standard Library, so you must install it separately using Pip. To install PyInputPlus, run pip install --user pyinputplus from the command line. Appendix A has complete instructions for installing third-party modules. To check if PyInputPlus installed correctly, import it in the interactive shell:\n\nIf no errors appear when you import the module, it has been successfully installed.\n\nPyInputPlus has several functions for different kinds of input:\n\ninputStr() Is like the built-in input() function but has the general PyInputPlus features. You can also pass a custom validation function to it\n\ninputNum() Ensures the user enters a number and returns an int or float, depending on if the number has a decimal point in it\n\ninputChoice() Ensures the user enters one of the provided choices\n\ninputMenu() Is similar to inputChoice(), but provides a menu with numbered or lettered options\n\ninputBool() Is similar to inputYesNo(), but takes a “True” or “False” response and returns a Boolean value\n\ninputFilepath() Ensures the user enters a valid file path and filename, and can optionally check that a file with that name exists\n\ninputPassword() Is like the built-in input(), but displays * characters as the user types so that passwords, or other sensitive information, aren’t displayed on the screen\n\nThese functions will automatically reprompt the user for as long as they enter invalid input:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum()\n\n five\n\n 'five' is not a number.\n\n 42\n\n >>> response\n\n 42\n\nThe as pyip code in the import statement saves us from typing pyinputplus each time we want to call a PyInputPlus function. Instead we can use the shorter pyip name. If you take a look at the example, you see that unlike input(), these functions return an int or float value: 42 and 3.14 instead of the strings '42' and '3.14'.\n\nJust as you can pass a string to input() to provide a prompt, you can pass a string to a PyInputPlus function’s prompt keyword argument to display a prompt:\n\n>>> response = input('Enter a number: ')\n\n Enter a number: 42\n\n >>> response\n\n '42'\n\n >>> import pyinputplus as pyip\n\n >>> response = pyip.inputInt(prompt='Enter a number: ')\n\n Enter a number: cat\n\n 'cat' is not an integer.\n\n Enter a number: 42\n\n >>> response\n\n 42\n\nUse Python’s help() function to find out more about each of these functions. For example, help(pyip.inputChoice) displays help information for the inputChoice() function. Complete documentation can be found at https://pyinputplus.readthedocs.io/.\n\nUnlike Python’s built-in input(), PyInputPlus functions have several additional features for input validation, as shown in the next section.\n\nThe inputNum(), inputInt(), and inputFloat() functions, which accept int and float numbers, also have min, max, greaterThan, and lessThan keyword arguments for specifying a range of valid values. For example, enter the following into the interactive shell:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum('Enter num: ', min=4)\n\n Enter num:3\n\n Input must be at minimum 4.\n\n Enter num:4\n\n >>> response\n\n 4\n\n >>> response = pyip.inputNum('Enter num: ', greaterThan=4)\n\n Enter num: 4\n\n Input must be greater than 4.\n\n Enter num: 5\n\n >>> response\n\n 5\n\n >>> response = pyip.inputNum('>', min=4, lessThan=6)\n\n Enter num: 6\n\n Input must be less than 6.\n\n Enter num: 3\n\n Input must be at minimum 4.\n\n Enter num: 4\n\n >>> response\n\n 4\n\nThese keyword arguments are optional, but if supplied, the input cannot be less than the min argument or greater than the max argument (though the input can be equal to them). Also, the input must be greater than the greaterThan and less than the lessThan arguments (that is, the input cannot be equal to them).\n\nBy default, blank input isn’t allowed unless the blank keyword argument is set to True:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum('Enter num: ')\n\n Enter num:(blank input entered here)\n\n Blank values are not allowed.\n\n Enter num: 42\n\n >>> response\n\n 42\n\n >>> response = pyip.inputNum(blank=True)\n\n (blank input entered here)\n\n >>> response\n\n ''\n\nUse blank=True if you’d like to make input optional so that the user doesn’t need to enter anything.\n\nBy default, the PyInputPlus functions will continue to ask the user for valid input forever (or for as long as the program runs). If you’d like a function to stop asking the user for input after a certain number of tries or a certain amount of time, you can use the limit and timeout keyword arguments. Pass an integer for the limit keyword argument to determine how many attempts a PyInputPlus function will make to receive valid input before giving up, and pass an integer for the timeout keyword argument to determine how many seconds the user has to enter valid input before the PyInputPlus function gives up.\n\nIf the user fails to enter valid input, these keyword arguments will cause the function to raise a RetryLimitException or TimeoutException, respectively. For example, enter the following into the interactive shell:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum(limit=2)\n\n blah\n\n 'blah' is not a number.\n\n Enter num: number\n\n 'number' is not a number.\n\n Traceback (most recent call last):\n\n --snip--\n\n pyinputplus.RetryLimitException\n\n >>> response = pyip.inputNum(timeout=10)\n\n 42 (entered after 10 seconds of waiting)\n\n Traceback (most recent call last):\n\n --snip--\n\n pyinputplus.TimeoutException\n\nWhen you use these keyword arguments and also pass a default keyword argument, the function returns the default value instead of raising an exception. Enter the following into the interactive shell:\n\n>>> response = pyip.inputNum(limit=2, default='N/A')\n\n hello\n\n 'hello' is not a number.\n\n world\n\n 'world' is not a number.\n\n >>> response\n\n 'N/A'\n\nInstead of raising RetryLimitException, the inputNum() function simply returns the string 'N/A'.\n\nYou can also use regular expressions to specify whether an input is allowed or not. The allowRegexes and blockRegexes keyword arguments take a list of regular expression strings to determine what the PyInputPlus function will accept or reject as valid input. For example, enter the following code into the interactive shell so that inputNum() will accept Roman numerals in addition to the usual numbers:\n\nOf course, this regex affects only what letters the inputNum() function will accept from the user; the function will still accept Roman numerals with invalid ordering such as 'XVX' or 'MILLI' because the r'(I|V|X|L|C|D|M)+' regular expression accepts those strings.\n\nYou can also specify a list of regular expression strings that a PyInputPlus function won’t accept by using the blockRegexes keyword argument. Enter the following into the interactive shell so that inputNum() won’t accept even numbers:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum(blockRegexes=[r'[02468]$'])\n\n 42\n\n This response is invalid.\n\n 44\n\n This response is invalid.\n\n 43\n\n >>> response\n\n 43\n\nIf you specify both an allowRegexes and blockRegexes argument, the allow list overrides the block list. For example, enter the following into the interactive shell, which allows 'caterpillar' and 'category' but blocks anything else that has the word 'cat' in it:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputStr(allowRegexes=[r'caterpillar', 'category'],\n\n blockRegexes=[r'cat'])\n\n cat\n\n This response is invalid.\n\n catastrophe\n\n This response is invalid.\n\n category\n\n >>> response\n\n 'category'\n\nThe PyInputPlus module’s functions can save you from writing tedious input validation code yourself. But there’s more to the PyInputPlus module than what has been detailed here. You can examine its full documentation online at https://pyinputplus.readthedocs.io/.\n\nYou can write a function to perform your own custom validation logic by passing the function to inputCustom(). For example, say you want the user to enter a series of digits that adds up to 10. There is no pyinputplus.inputAddsUpToTen() function, but you can create your own function that:\n• Accepts a single string argument of what the user entered\n• Raises an exception if the string fails validation\n• Returns (or has no statement) if should return the string unchanged\n• Returns a non- value if should return a different string from the one the user entered\n• Is passed as the first argument to\n\nFor example, we can create our own addsUpToTen() function, and then pass it to inputCustom(). Note that the function call looks like inputCustom(addsUpToTen) and not inputCustom(addsUpToTen()) because we are passing the addsUpToTen() function itself to inputCustom(), not calling addsUpToTen() and passing its return value.\n\n>>> import pyinputplus as pyip\n\n >>> def addsUpToTen(numbers):\n\n ... numbersList = list(numbers)\n\n ... for i, digit in enumerate(numbersList):\n\n ... numbersList[i] = int(digit)\n\n ... if sum(numbersList) != 10:\n\n ... raise Exception('The digits must add up to 10, not %s.' %\n\n (sum(numbersList)))\n\n ... return int(numbers) # Return an int form of numbers.\n\n ...\n\n >>> response = pyip.inputCustom(addsUpToTen) # No parentheses after\n\n addsUpToTen here.\n\n 123\n\n The digits must add up to 10, not 6.\n\n 1235\n\n The digits must add up to 10, not 11.\n\n 1234\n\n >>> response # inputStr() returned an int, not a string.\n\n 1234\n\n >>> response = pyip.inputCustom(addsUpToTen)\n\n hello\n\n invalid literal for int() with base 10: 'h'\n\n 55\n\n >>> response\n\nThe inputCustom() function also supports the general PyInputPlus features, such as the blank, limit, timeout, default, allowRegexes, and blockRegexes keyword arguments. Writing your own custom validation function is useful when it’s otherwise difficult or impossible to write a regular expression for valid input, as in the “adds up to 10” example.\n\nProject: How to Keep an Idiot Busy for Hours\n\nLet’s use PyInputPlus to create a simple program that does the following:\n• Ask the user if they’d like to know how to keep an idiot busy for hours.\n• If the user answers no, quit.\n• If the user answers yes, go to Step 1.\n\nOf course, we don’t know if the user will enter something besides “yes” or “no,” so we need to perform input validation. It would also be convenient for the user to be able to enter “y” or “n” instead of the full words. PyInputPlus’s inputYesNo() function will handle this for us and, no matter what case the user enters, return a lowercase 'yes' or 'no' string value.\n\nWhen you run this program, it should look like the following:\n\nWant to know how to keep an idiot busy for hours?\n\n sure\n\n 'sure' is not a valid yes/no response.\n\n Want to know how to keep an idiot busy for hours?\n\n yes\n\n Want to know how to keep an idiot busy for hours?\n\n y\n\n Want to know how to keep an idiot busy for hours?\n\n Yes\n\n Want to know how to keep an idiot busy for hours?\n\n YES\n\n Want to know how to keep an idiot busy for hours?\n\n YES!!!!!!\n\n 'YES!!!!!!' is not a valid yes/no response.\n\n Want to know how to keep an idiot busy for hours?\n\n TELL ME HOW TO KEEP AN IDIOT BUSY FOR HOURS.\n\n 'TELL ME HOW TO KEEP AN IDIOT BUSY FOR HOURS.' is not a valid yes/no response.\n\n Want to know how to keep an idiot busy for hours?\n\n no\n\n Thank you. Have a nice day.\n\nOpen a new file editor tab and save it as idiot.py. Then enter the following code:\n\nThis imports the PyInputPlus module. Since pyinputplus is a bit much to type, we’ll use the name pyip for short.\n\nwhile True:\n\n prompt = 'Want to know how to keep an idiot busy for hours?\n\n'\n\n response = pyip.inputYesNo(prompt)\n\nNext, while True: creates an infinite loop that continues to run until it encounters a break statement. In this loop, we call pyip.inputYesNo() to ensure that this function call won’t return until the user enters a valid answer.\n\nThe pyip.inputYesNo() call is guaranteed to only return either the string yes or the string no. If it returned no, then our program breaks out of the infinite loop and continues to the last line, which thanks the user:\n\nOtherwise, the loop iterates once again.\n\nYou can also make use of the inputYesNo() function in non-English languages by passing yesVal and noVal keyword arguments. For example, the Spanish version of this program would have these two lines:\n\nNow the user can enter either sí or s (in lower- or uppercase) instead of yes or y for an affirmative answer.\n\nPyInputPlus’s features can be useful for creating a timed multiplication quiz. By setting the allowRegexes, blockRegexes, timeout, and limit keyword argument to pyip.inputStr(), you can leave most of the implementation to PyInputPlus. The less code you need to write, the faster you can write your programs. Let’s create a program that poses 10 multiplication problems to the user, where the valid input is the problem’s correct answer. Open a new file editor tab and save the file as multiplicationQuiz.py.\n\nFirst, we’ll import pyinputplus, random, and time. We’ll keep track of how many questions the program asks and how many correct answers the user gives with the variables numberOfQuestions and correctAnswers. A for loop will repeatedly pose a random multiplication problem 10 times:\n\nimport pyinputplus as pyip\n\n import random, time\n\n\n\n numberOfQuestions = 10\n\n correctAnswers = 0\n\n for questionNumber in range(numberOfQuestions):\n\nInside the for loop, the program will pick two single-digit numbers to multiply. We’ll use these numbers to create a #Q: N × N = prompt for the user, where Q is the question number (1 to 10) and N are the two numbers to multiply.\n\nThe pyip.inputStr() function will handle most of the features of this quiz program. The argument we pass for allowRegexes is a list with the regex string '^%s$', where %s is replaced with the correct answer. The ^ and % characters ensure that the answer begins and ends with the correct number, though PyInputPlus trims any whitespace from the start and end of the user’s response first just in case they inadvertently pressed the spacebar before or after their answer. The argument we pass for blocklistRegexes is a list with ('.*', 'Incorrect!'). The first string in the tuple is a regex that matches every possible string. Therefore, if the user response doesn’t match the correct answer, the program will reject any other answer they provide. In that case, the 'Incorrect!' string is displayed and the user is prompted to answer again. Additionally, passing 8 for timeout and 3 for limit will ensure that the user only has 8 seconds and 3 tries to provide a correct answer:\n\ntry:\n\n # Right answers are handled by allowRegexes.\n\n # Wrong answers are handled by blockRegexes, with a custom message.\n\n pyip.inputStr(prompt, allowRegexes=['^%s$' % (num1 * num2)],\n\n blockRegexes=[('.*', 'Incorrect!')],\n\n timeout=8, limit=3)\n\nIf the user answers after the 8-second timeout has expired, even if they answer correctly, pyip.inputStr() raises a TimeoutException exception. If the user answers incorrectly more than 3 times, it raises a RetryLimitException exception. Both of these exception types are in the PyInputPlus module, so pyip. needs to prepend them:\n\nexcept pyip.TimeoutException:\n\n print('Out of time!')\n\n except pyip.RetryLimitException:\n\n print('Out of tries!')\n\nRemember that, just like how else blocks can follow an if or elif block, they can optionally follow the last except block. The code inside the following else block will run if no exception was raised in the try block. In our case, that means the code runs if the user entered the correct answer:\n\nelse:\n\n # This block runs if no exceptions were raised in the try block.\n\n print('Correct!')\n\n correctAnswers += 1\n\nNo matter which of the three messages, “Out of time!”, “Out of tries!”, or “Correct!”, displays, let’s place a 1-second pause at the end of the for loop to give the user time to read it. After the program has asked 10 questions and the for loop continues, let’s show the user how many correct answers they made:\n\ntime.sleep(1) # Brief pause to let user see the result.\n\n print('Score: %s / %s' % (correctAnswers, numberOfQuestions))\n\nPyInputPlus is flexible enough that you can use it in a wide variety of programs that take keyboard input from the user, as demonstrated by the programs in this chapter.\n\nIt’s easy to forget to write input validation code, but without it, your programs will almost certainly have bugs. The values you expect users to enter and the values they actually enter can be completely different, and your programs need to be robust enough to handle these exceptional cases. You can use regular expressions to create your own input validation code, but for common cases, it’s easier to use an existing module, such as PyInputPlus. You can import the module with import pyinputplus as pyip so that you can enter a shorter name when calling the module’s functions.\n\nPyInputPlus has functions for entering a variety of input, including strings, numbers, dates, yes/no, True/False, emails, and files. While input() always returns a string, these functions return the value in an appropriate data type. The inputChoice() function allow you to select one of several pre-selected options, while inputMenu() also adds numbers or letters for quick selection.\n\nAll of these functions have the following standard features: stripping whitespace from the sides, setting timeout and retry limits with the timeout and limit keyword arguments, and passing lists of regular expression strings to allowRegexes or blockRegexes to include or exclude particular responses. You'll no longer need to write your own tedious while loops that check for valid input and reprompt the user.\n\nIf none of the PyInputPlus module’s, functions fit your needs, but you’d still like the other features that PyInputPlus provides, you can call inputCustom() and pass your own custom validation function for PyInputPlus to use. The documentation at https://pyinputplus.readthedocs.io/en/latest/ has a complete listing of PyInputPlus’s functions and additional features. There’s far more in the PyInputPlus online documentation than what was described in this chapter. There’s no use in reinventing the wheel, and learning to use this module will save you from having to write and debug code for yourself.\n\nNow that you have expertise manipulating and validating text, it’s time to learn how to read from and write to files on your computer’s hard drive.\n\n1. Does PyInputPlus come with the Python Standard Library?\n\n2. Why is PyInputPlus commonly imported with import pyinputplus as pyip?\n\n3. What is the difference between inputInt() and inputFloat()?\n\n4. How can you ensure that the user enters a whole number between 0 and 99 using PyInputPlus?\n\n5. What is passed to the allowRegexes and blockRegexes keyword arguments?\n\n6. What does inputStr(limit=3) do if blank input is entered three times?\n\n7. What does inputStr(limit=3, default='hello') do if blank input is entered three times?\n\nFor practice, write programs to do the following tasks.\n\nWrite a program that asks users for their sandwich preferences. The program should use PyInputPlus to ensure that they enter valid input, such as:\n• Using for a bread type: wheat, white, or sourdough.\n• Using for a protein type: chicken, turkey, ham, or tofu.\n• Using to ask if they want cheese.\n• If so, using to ask for a cheese type: cheddar, Swiss, or mozzarella.\n• Using to ask if they want mayo, mustard, lettuce, or tomato.\n• Using to ask how many sandwiches they want. Make sure this number is 1 or more.\n\nCome up with prices for each of these options, and have your program display a total cost after the user enters their selection.\n\nTo see how much PyInputPlus is doing for you, try re-creating the multiplication quiz project on your own without importing it. This program will prompt the user with 10 multiplication questions, ranging from 0 × 0 to 9 × 9. You’ll need to implement the following features:\n• If the user enters the correct answer, the program displays “Correct!” for 1 second and moves on to the next question.\n• The user gets three tries to enter the correct answer before the program moves on to the next question.\n• Eight seconds after first displaying the question, the question is marked as incorrect even if the user enters the correct answer after the 8-second limit.\n\nCompare your code to the code using PyInputPlus in “Project: Multiplication Quiz” on page 196."
    },
    {
        "link": "https://p-kane.medium.com/input-validation-with-python-570953d5d297",
        "document": "Getting user inputs is one of the most crucial part of any program. What’s more important is to get the right type of input so that the program continues to run without problem.\n\nJust like any other programming language, you can easily write a block of code to validate and filter a user input to ensure the program takes the only correct type of input with Python. You can even create a loop that keeps sending a message to inform the user to input correctly before going to the next step.\n\nFor example, assuming that you need to create a program which takes an integer from the user to perform further operations, you’ll write the following block of code to transform any whole number input into an integer:\n\nTry an input any whole number with the above code and there’s no problem. The variable num stored any whole number you typed in as an integer. Great! The first layer of input validation is successfully pealed. Did I say layer? Yes. That’s because there can be many layers stacked on top of an input validation process, depending solely on what is needed for it to perform.\n\nThe code above will work fine as long as the user inptut a whole number. It breaks easily, however, when it gets something that is not a whole number such as ‘3.14’ or ‘pi’. In other words, the code above will throw an error message if the user give it anything but a whole number:\n\nWe can easily avoid the above error by using try and except as shown in the following code block to catch the error:\n\nAs we already know, without the try except block, the code will throw a ValueError error if the input is anything that can’t be converted into an integer by the int() function, so we specifically tell the try except block to catch this type of error in the code above. However, the program just ends and we need to restart the program again if we are to give it another input.\n\nA while loop can ease this pain. We can create a loop that will never stop telling the user to give the correct type of input until he/she does so:\n\nBasically, the above code tells the program to keep asking the user for a valid integer until it gets one. Once the input is correct, the loop is terminated with the break command. However, it will keep telling the user “Please input a valid integer.” until it gets one. This way, we don’t have to restart the program every time we give it a wrong input. And there’s no error message. The program keeps running (validating the input) smoothly even when we give wrong types of inputs. The second layer of the input validation process is cracked!\n\nIn general, the more specific an input, the more smoothly the program (or data processing) in the later phases will perform. Let’s say, for example, that we need to validate the input so that it’s an integer with the value ranges from 1 to 10 only, we can tweak the above code so that it will take only the said values like the following:\n\nSimply adding an if block that will tell the user to input a valid integer anytime when the value of the variable num is out of the 1–10 range does the trick of letting the program be even more specific about ingesting any input from the user based on the condition(s) in the if block.\n\nThe third layer is cracked!\n\nYou can also apply this knowledge in validating inputs of string type without having to down-cast it to any other data type as well, since the initial data type of the input() function is already string.\n\nLet’s say that, for some reason, you need a program to input a string with only 3 characters in length, you can write a block of code to validate the input according to the said condition like so:\n\nThe above code will keep asking the user for any input with specifically 3 characters in length. Anything less or more than 3-character long will be disregarded.\n\nThere you have it, some easy tricks to validate inputs and negate errors with Python.\n\nIn summary, there are basically 3 main layers for input validation:\n• Type-cast the input as needed just as the example of casting a string to an integer with the int() function.\n• Use the while loop to negate error, let the process of data validation runs smoothly until the program gets the correct type of input.\n• Create conditions so that the input is more tailored to what the user reallly needed. This layer is very important for the future data processing and operations. It minimalizes the chances of future possible errors!\n\nYou see how we can specifically handle the ValueError with the try except block. What if we don’t know what type of error will happen and we just want to handle an error? We can do so with the following code:\n\nIn the code above, we can use Exception to handle a variety of types of unexpected (or unknown) errors.\n\nI do hope you find this short article about input validation with Python useful an applicable with your works. Enjoy coding. Until next time!"
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/riija3/what_is_the_correct_way_to_validate_user_input",
        "document": "What is the optimal way in which one would validate and handle invalid input for something like the following example?\n\netc. How do you efficiently validate the input and ask again? Without countless if statements etc."
    },
    {
        "link": "https://stackoverflow.com/questions/74659981/how-we-handle-input-validation-on-python",
        "document": "I am new to python. I am wondering how we handle input validation using try catch. I have the code below, would you provide some suggestion?"
    },
    {
        "link": "https://stackoverflow.com/questions/23294658/asking-the-user-for-input-until-they-give-a-valid-response",
        "document": "How do I ask for valid input instead of crashing or accepting invalid values (e.g. -1 )?\n\nInstead of crashing, I would like the program to ask for the input again. Like this:\n\nBut it fails if the user enters invalid data:\n\nThe program works as expected as long as the the user enters meaningful data.\n\nThe simplest way to accomplish this is to put the method in a while loop. Use when you get bad input, and out of the loop when you're satisfied. When Your Input Might Raise an Exception Use and to detect when the user enters data that can't be parsed. while True: try: # Note: Python 2.x users should use raw_input, the equivalent of 3.x's input age = int(input(\"Please enter your age: \")) except ValueError: print(\"Sorry, I didn't understand that.\") #better try again... Return to the start of the loop continue else: #age was successfully parsed! #we're ready to exit the loop. break if age >= 18: print(\"You are able to vote in the United States!\") else: print(\"You are not able to vote in the United States.\") If you want to reject values that Python can successfully parse, you can add your own validation logic. while True: data = input(\"Please enter a loud message (must be all caps): \") if not data.isupper(): print(\"Sorry, your response was not loud enough.\") continue else: #we're happy with the value given. #we're ready to exit the loop. break while True: data = input(\"Pick an answer from A to D:\") if data.lower() not in ('a', 'b', 'c', 'd'): print(\"Not an appropriate choice.\") else: break Both of the above techniques can be combined into one loop. while True: try: age = int(input(\"Please enter your age: \")) except ValueError: print(\"Sorry, I didn't understand that.\") continue if age < 0: print(\"Sorry, your response must not be negative.\") continue else: #age was successfully parsed, and we're happy with its value. #we're ready to exit the loop. break if age >= 18: print(\"You are able to vote in the United States!\") else: print(\"You are not able to vote in the United States.\") Encapsulating it All in a Function If you need to ask your user for a lot of different values, it might be useful to put this code in a function, so you don't have to retype it every time. def get_non_negative_int(prompt): while True: try: value = int(input(prompt)) except ValueError: print(\"Sorry, I didn't understand that.\") continue if value < 0: print(\"Sorry, your response must not be negative.\") continue else: break return value age = get_non_negative_int(\"Please enter your age: \") kids = get_non_negative_int(\"Please enter the number of children you have: \") salary = get_non_negative_int(\"Please enter your yearly earnings, in dollars: \") Putting It All Together You can extend this idea to make a very generic input function: def sanitised_input(prompt, type_=None, min_=None, max_=None, range_=None): if min_ is not None and max_ is not None and max_ < min_: raise ValueError(\"min_ must be less than or equal to max_.\") while True: ui = input(prompt) if type_ is not None: try: ui = type_(ui) except ValueError: print(\"Input type must be {0}.\".format(type_.__name__)) continue if max_ is not None and ui > max_: print(\"Input must be less than or equal to {0}.\".format(max_)) elif min_ is not None and ui < min_: print(\"Input must be greater than or equal to {0}.\".format(min_)) elif range_ is not None and ui not in range_: if isinstance(range_, range): template = \"Input must be between {0.start} and {0.stop}.\" print(template.format(range_)) else: template = \"Input must be {0}.\" if len(range_) == 1: print(template.format(*range_)) else: expected = \" or \".join(( \", \".join(str(x) for x in range_[:-1]), str(range_[-1]) )) print(template.format(expected)) else: return ui age = sanitised_input(\"Enter your age: \", int, 1, 101) answer = sanitised_input(\"Enter your answer: \", str.lower, range_=('a', 'b', 'c', 'd')) Common Pitfalls, and Why you Should Avoid Them The Redundant Use of Redundant Statements This method works but is generally considered poor style: data = input(\"Please enter a loud message (must be all caps): \") while not data.isupper(): print(\"Sorry, your response was not loud enough.\") data = input(\"Please enter a loud message (must be all caps): \") It might look attractive initially because it's shorter than the method, but it violates the Don't Repeat Yourself principle of software development. This increases the likelihood of bugs in your system. What if you want to backport to 2.7 by changing to , but accidentally change only the first above? It's a just waiting to happen. If you've just learned about recursion, you might be tempted to use it in so you can dispose of the while loop. def get_non_negative_int(prompt): try: value = int(input(prompt)) except ValueError: print(\"Sorry, I didn't understand that.\") return get_non_negative_int(prompt) if value < 0: print(\"Sorry, your response must not be negative.\") return get_non_negative_int(prompt) else: return value This appears to work fine most of the time, but if the user enters invalid data enough times, the script will terminate with a . You may think \"no fool would make 1000 mistakes in a row\", but you're underestimating the ingenuity of fools!\n\nFunctional approach or \"look mum no loops!\": from itertools import chain, repeat prompts = chain([\"Enter a number: \"], repeat(\"Not a number! Try again: \")) replies = map(input, prompts) valid_response = next(filter(str.isdigit, replies)) print(valid_response) Enter a number: a Not a number! Try again: b Not a number! Try again: 1 1 or if you want to have a \"bad input\" message separated from an input prompt as in other answers: Enter a number: a Sorry, I didn't understand that. Enter a number: b Sorry, I didn't understand that. Enter a number: 1 1 How does it work?\n• This combination of and will create an iterator which will yield strings once, and \"Not a number! Try again: \" an infinite number of times: Enter a number: Not a number! Try again: Not a number! Try again: Not a number! Try again: # ... and so on\n• - here will apply all the strings from the previous step to the function. E.g.: Enter a number: a a Not a number! Try again: 1 1 Not a number! Try again: it doesn't care now it doesn't care now # and so on...\n• We use and to filter out those strings that contain only digits: Enter a number: a Not a number! Try again: 1 1 Not a number! Try again: 2 2 Not a number! Try again: b Not a number! Try again: # and so on... And to get only the first digits-only string we use .\n• None String methods: Of course you can use other string methods like to get only alphabetic strings, or to get only uppercase. See docs for the full list.\n• None Membership testing:\n\n There are several different ways to perform it. One of them is by using method: from itertools import chain, repeat fruits = {'apple', 'orange', 'peach'} prompts = chain([\"Enter a fruit: \"], repeat(\"I don't know this one! Try again: \")) replies = map(input, prompts) valid_response = next(filter(fruits.__contains__, replies)) print(valid_response) Enter a fruit: 1 I don't know this one! Try again: foo I don't know this one! Try again: apple apple\n• None Numbers comparison:\n\n There are useful comparison methods which we can use here. For example, for ( ): from itertools import chain, repeat prompts = chain([\"Enter a positive number:\"], repeat(\"I need a positive number! Try again:\")) replies = map(input, prompts) numeric_strings = filter(str.isnumeric, replies) numbers = map(float, numeric_strings) is_positive = (0.).__lt__ valid_response = next(filter(is_positive, numbers)) print(valid_response) Enter a positive number: a I need a positive number! Try again: -5 I need a positive number! Try again: 0 I need a positive number! Try again: 5 5.0 Or, if you don't like using dunder methods (dunder = double-underscore), you can always define your own function, or use the ones from the module.\n• None Path existance:\n\n Here one can use library and its method: from itertools import chain, repeat from pathlib import Path prompts = chain([\"Enter a path: \"], repeat(\"This path doesn't exist! Try again: \")) replies = map(input, prompts) paths = map(Path, replies) valid_response = next(filter(Path.exists, paths)) print(valid_response) Enter a path: a b c This path doesn't exist! Try again: 1 This path doesn't exist! Try again: existing_file.txt existing_file.txt If you don't want to torture a user by asking him something an infinite number of times, you can specify a limit in a call of . This can be combined with providing a default value to the function: from itertools import chain, repeat prompts = chain([\"Enter a number:\"], repeat(\"Not a number! Try again:\", 2)) replies = map(input, prompts) valid_response = next(filter(str.isdigit, replies), None) print(\"You've failed miserably!\" if valid_response is None else 'Well done!') Enter a number: a Not a number! Try again: b Not a number! Try again: c You've failed miserably! Sometimes we don't want to reject an input if the user accidentally supplied it IN CAPS or with a space in the beginning or an end of the string. To take these simple mistakes into account we can preprocess the input data by applying and methods. For example, for the case of membership testing the code will look like this: from itertools import chain, repeat fruits = {'apple', 'orange', 'peach'} prompts = chain([\"Enter a fruit: \"], repeat(\"I don't know this one! Try again: \")) replies = map(input, prompts) lowercased_replies = map(str.lower, replies) stripped_replies = map(str.strip, lowercased_replies) valid_response = next(filter(fruits.__contains__, stripped_replies)) print(valid_response) Enter a fruit: duck I don't know this one! Try again: Orange orange In the case when you have many functions to use for preprocessing, it might be easier to use a function performing a function composition. For example, using the one from here: from itertools import chain, repeat from lz.functional import compose fruits = {'apple', 'orange', 'peach'} prompts = chain([\"Enter a fruit: \"], repeat(\"I don't know this one! Try again: \")) replies = map(input, prompts) process = compose(str.strip, str.lower) # you can add more functions here processed_replies = map(process, replies) valid_response = next(filter(fruits.__contains__, processed_replies)) print(valid_response) Enter a fruit: potato I don't know this one! Try again: PEACH peach For a simple case, for example, when the program asks for age between 1 and 120, one can just add another : But in the case when there are many rules, it's better to implement a function performing a logical conjunction. In the following example I will use a ready one from here: from functools import partial from itertools import chain, repeat from lz.logical import conjoin def is_one_letter(string: str) -> bool: return len(string) == 1 rules = [str.isalpha, str.isupper, is_one_letter, 'C'.__le__, 'P'.__ge__] prompt_msg = \"Enter a letter (C-P): \" bad_input_msg = \"Wrong input.\" prompts = chain([prompt_msg], repeat('\n\n'.join([bad_input_msg, prompt_msg]))) replies = map(input, prompts) valid_response = next(filter(conjoin(*rules), replies)) print(valid_response) Unfortunately, if someone needs a custom message for each failed case, then, I'm afraid, there is no pretty functional way. Or, at least, I couldn't find one."
    }
]