[
    {
        "link": "https://doc.qt.io/qt-6/qtransform.html",
        "document": "The QTransform class specifies 2D transformations of a coordinate system. More...\n\nA transformation specifies how to translate, scale, shear, rotate or project the coordinate system, and is typically used when rendering graphics. A QTransform object can be built using the setMatrix(), scale(), rotate(), translate() and shear() functions. Alternatively, it can be built by applying basic matrix operations. The matrix can also be defined when constructed, and it can be reset to the identity matrix (the default) using the reset() function. The QTransform class supports mapping of graphic primitives: A given point, line, polygon, region, or painter path can be mapped to the coordinate system defined by this matrix using the map() function. In case of a rectangle, its coordinates can be transformed using the mapRect() function. A rectangle can also be transformed into a polygon (mapped to the coordinate system defined by this matrix), using the mapToPolygon() function. QTransform provides the isIdentity() function which returns if the matrix is the identity matrix, and the isInvertible() function which returns if the matrix is non-singular (i.e. AB = BA = I). The inverted() function returns an inverted copy of this matrix if it is invertible (otherwise it returns the identity matrix), and adjoint() returns the matrix's classical adjoint. In addition, QTransform provides the determinant() function which returns the matrix's determinant. Finally, the QTransform class supports matrix multiplication, addition and subtraction, and objects of the class can be streamed as well as compared. When rendering graphics, the matrix defines the transformations but the actual transformation is performed by the drawing routines in QPainter. By default, QPainter operates on the associated device's own coordinate system. The standard coordinate system of a QPaintDevice has its origin located at the top-left position. The x values increase to the right; y values increase downward. For a complete description, see the coordinate system documentation. QPainter has functions to translate, scale, shear and rotate the coordinate system without using a QTransform. For example: Although these functions are very convenient, it can be more efficient to build a QTransform and call QPainter::setTransform() if you want to perform more than a single transform operation. For example: A QTransform object contains a 3 x 3 matrix. The ( ) and ( ) elements specify horizontal and vertical translation. The and elements specify horizontal and vertical scaling. The and elements specify horizontal and vertical shearing. And finally, the and elements specify horizontal and vertical projection, with as an additional projection factor. QTransform transforms a point in the plane to another point using the following formulas: The point (x, y) is the original point, and (x', y') is the transformed point. (x', y') can be transformed back to (x, y) by performing the same operation on the inverted() matrix. The various matrix elements can be set when constructing the matrix, or by using the setMatrix() function later on. They can also be manipulated using the translate(), rotate(), scale() and shear() convenience functions. The currently set values can be retrieved using the m11(), m12(), m13(), m21(), m22(), m23(), m31(), m32(), m33(), dx() and dy() functions. Translation is the simplest transformation. Setting and will move the coordinate system units along the X axis and units along the Y axis. Scaling can be done by setting and . For example, setting to 2 and to 1.5 will double the height and increase the width by 50%. The identity matrix has , , and set to 1 (all others are set to 0) mapping a point to itself. Shearing is controlled by and . Setting these elements to values different from zero will twist the coordinate system. Rotation is achieved by setting both the shearing factors and the scaling factors. Perspective transformation is achieved by setting both the projection factors and the scaling factors. Here's the combined transformations example using basic matrix operations: The combined transform first scales each operand, then rotates it, and finally translates it, just as in the order in which the product of its factors is written. This means the point to which the transforms are applied is implicitly multiplied on the left with the transform to its right. The matrix notation in QTransform is the transpose of a commonly-taught convention which represents transforms and points as matrices and vectors. That convention multiplies its matrix on the left and column vector to the right. In other words, when several transforms are applied to a point, the right-most matrix acts directly on the vector first. Then the next matrix to the left acts on the result of the first operation - and so on. As a result, that convention multiplies the matrices that make up a composite transform in the reverse of the order in QTransform, as you can see in Combining Transforms. Transposing the matrices, and combining them to the right of a row vector that represents the point, lets the matrices of transforms appear, in their product, in the order in which we think of the transforms being applied to the point.\n\nSee also QPainter, Coordinate System, Affine Transformations Example, and Transformations Example.\n\nReturns if t1 and t2 are equal, allowing for a small fuzziness factor for floating-point comparisons; false otherwise. Returns the hash value for key, using seed to seed the calculation. This is the same as matrix.map(line). This is the same as matrix.map(line). This is the same as matrix.map(path). This is the same as matrix.map(point). This is the same as matrix.map(polygon). This is the same as matrix.map(polygon). This is the same as matrix.map(region). Writes the given matrix to the given stream and returns a reference to the stream. Reads the given matrix from the given stream and returns a reference to the stream."
    },
    {
        "link": "https://qthub.com/static/doc/qt5/qtgui/qimage.html",
        "document": "The QImage class provides a hardware-independent image representation that allows direct access to the pixel data, and can be used as a paint device. More...\n\nNote: All functions in this class are reentrant.\n\nThere are also functions for changing attributes of an image in-place:\n\nThe transformed() function returns a copy of the image that is transformed with the given transformation matrix and transformation mode: Internally, the transformation matrix is adjusted to compensate for unwanted translation, i.e. transformed() returns the smallest image containing all transformed points of the original image. The static trueMatrix() function returns the actual matrix used for transforming the image.\n\nThe scaledToWidth () and scaledToHeight () functions return scaled copies of the image.\n\nThe mirrored () function returns a mirror of the image in the desired direction, the scaled () returns a copy of the image scaled to a rectangle of the desired measures, and the rgbSwapped () function constructs a BGR image from a RGB image.\n\nQImage supports a number of functions for creating a new image that is a transformed version of the original: The createAlphaMask () function builds and returns a 1-bpp mask from the alpha buffer in this image, and the createHeuristicMask () function creates and returns a 1-bpp heuristic mask for this image. The latter function works by selecting a color from one of the corners, then chipping away pixels of that color starting at all the edges.\n\nAn image's format can be retrieved using the format () function. Use the convertToFormat () functions to convert an image into another format. The allGray () and isGrayscale () functions tell whether a color image can safely be converted to a grayscale image.\n\n32-bit images have no color table; instead, each pixel contains an QRgb value. There are three different types of 32-bit images storing RGB (i.e. 0xffRRGGBB), ARGB and premultiplied ARGB values respectively. In the premultiplied format the red, green, and blue channels are multiplied by the alpha component divided by 255.\n\n8-bit images are stored using 8-bit indexes into a color table, i.e. they have a single byte per pixel. The color table is a QVector < QRgb >, and the QRgb typedef is equivalent to an unsigned int containing an ARGB quadruplet on the format 0xAARRGGBB.\n\nMonochrome images are stored using 1-bit indexes into a color table with at most two colors. There are two different types of monochrome images: big endian (MSB first) or little endian (LSB first) bit order.\n\nEach pixel stored in a QImage is represented by an integer. The size of the integer varies depending on the format. QImage supports several image formats described by the Format enum.\n\nQImage also provide the scanLine () function which returns a pointer to the pixel data at the scanline with the given index, and the bits () function which returns a pointer to the first pixel data (this is equivalent to scanLine(0) ).\n\nFor images with more than 8-bit per color-channel. The methods setPixelColor () and pixelColor () can be used to set and get with QColor values.\n\nAn entry in the color table is an ARGB quadruplet encoded as an QRgb value. Use the qRgb () and qRgba () functions to make a suitable QRgb value for use with the setColor () function. For example:\n\nIn case of a 8-bit and monchrome images, the pixel value is only an index from the image's color table. So the setPixel () function can only be used to alter the color of the pixel at the given coordinates to a predefined color from the image's color table, i.e. it can only change the pixel's index value. To alter or add a color to an image's color table, use the setColor () function.\n\nIn case of a 32-bit image, the setPixel () function can be used to alter the color of the pixel at the given coordinates to any other color specified as an ARGB quadruplet. To make a suitable QRgb value, use the qRgb () (adding a default alpha component to the given RGB values, i.e. creating an opaque color) or qRgba () function. For example:\n\nThe functions used to manipulate an image's pixels depend on the image format. The reason is that monochrome and 8-bit images are index-based and use a color lookup table, while 32-bit images store ARGB values directly. For more information on image formats, see the Image Formats section.\n\nThe cacheKey () function returns a number that uniquely identifies the contents of this QImage object.\n\nThe format (), bytesPerLine (), and sizeInBytes () functions provide low-level information about the data stored in the image.\n\nSee also the Pixel Manipulation and Image Transformations sections.\n\nThe hasAlphaChannel () function tells if the image's format respects the alpha channel, or not. The allGray () and isGrayscale () functions tell whether an image's colors are all shades of gray.\n\nIn case of monochrome and 8-bit images, the colorCount () and colorTable () functions provide information about the color components used to store the image data: The colorTable () function returns the image's entire color table. To obtain a single entry, use the pixelIndex () function to retrieve the pixel index for a given pair of coordinates, then use the color () function to retrieve the color. Note that if you create an 8-bit image manually, you have to set a valid color table on the image as well.\n\nThe rect () function returns the image's enclosing rectangle. The valid () function tells if a given pair of coordinates is within this rectangle. The offset () function returns the number of pixels by which the image is intended to be offset by when positioned relative to other images, which also can be manipulated using the setOffset () function.\n\nQImage provides a collection of functions that can be used to obtain a variety of information about the image:\n\nThe complete list of supported file formats are available through the QImageReader::supportedImageFormats () and QImageWriter::supportedImageFormats () functions. New file formats can be added as plugins. By default, Qt supports the following formats:\n\nQImage provides several ways of loading an image file: The file can be loaded when constructing the QImage object, or by using the load () or loadFromData () functions later on. QImage also provides the static fromData () function, constructing a QImage from the given data. When loading an image, the file name can either refer to an actual file on disk or to one of the application's embedded resources. See The Qt Resource System overview for details on how to embed images and other resource files in the application's executable.\n\nWarning: Painting on a QImage with the format QImage::Format_Indexed8 is not supported.\n\nNote: If you would like to load QImage objects in a static build of Qt, refer to the Plugin HowTo .\n\nQImage objects can be passed around by value since the QImage class uses implicit data sharing . QImage objects can also be streamed and compared.\n\nQImage provides a collection of functions that can be used to obtain a variety of information about the image. There are also several functions that enables transformation of the image.\n\nThe QImage class supports several image formats described by the Format enum. These include monochrome, 8-bit, 32-bit and alpha-blended images which are available in all versions of Qt 4.x.\n\nBecause QImage is a QPaintDevice subclass, QPainter can be used to draw directly onto images. When using QPainter on a QImage, the painting can be performed in another thread than the current GUI thread.\n\nQt provides four classes for handling image data: QImage, QPixmap , QBitmap and QPicture . QImage is designed and optimized for I/O, and for direct pixel access and manipulation, while QPixmap is designed and optimized for showing images on screen. QBitmap is only a convenience class that inherits QPixmap , ensuring a depth of 1. Finally, the QPicture class is a paint device that records and replays QPainter commands.\n\nSee also QImageReader, QImageWriter, QPixmap, QSvgRenderer, Image Composition Example, Image Viewer Example, Scribble Example, and Pixelator Example.\n\nThis enum type is used to describe how pixel values should be inverted in the invertPixels () function.\n\nSee also format () and convertToFormat ().\n\nNote: Avoid most rendering directly to most of these formats using QPainter . Rendering is best optimized to the Format_RGB32 and Format_ARGB32_Premultiplied formats, and secondarily for rendering to the Format_RGB16 , Format_RGBX8888 , Format_RGBA8888_Premultiplied , Format_RGBX64 and Format_RGBA64_Premultiplied formats\n\nNote: Drawing into a QImage with QImage::Format_Indexed8 is not supported.\n\nThe following image formats are available in Qt. See the notes after the table.\n\nReturns a QImage in which the values of the red and blue components of all pixels have been swapped, effectively converting an RGB image to an BGR image.\n\nThe original QImage is not changed.\n\nReturns a mirror of the image, mirrored in the horizontal and/or the vertical direction depending on whether horizontal and vertical are set to true or false.\n\nNote that the original image is not changed.\n\nReturns a copy of the image in the given format.\n\nThe specified image conversion flags control how the image data is handled during the conversion process.\n\nMove-constructs a QImage instance, making it point at the same object that other was pointing to.\n\nThis function was introduced in Qt 5.2.\n\nConstructs a shallow copy of the given image.\n\nFor more information about shallow copies, see the Implicit Data Sharing documentation.\n\nConstructs an image and tries to load the image from the file with the given fileName.\n\nThe loader attempts to read the image using the specified format. If the format is not specified (which is the default), it is auto-detected based on the file's suffix and header. For details, see {QImageReader::setAutoDetectImageFormat()}{QImageReader}.\n\nIf the loading of the image failed, this object is a null image.\n\nThe file name can either refer to an actual file on disk or to one of the application's embedded resources. See the Resource System overview for details on how to embed images and other resource files in the application's executable.\n\nSee also isNull() and Reading and Writing Image Files.\n\nConstructs an image from the given xpm image.\n\nMake sure that the image is a valid XPM image. Errors are silently ignored.\n\nNote that it's possible to squeeze the XPM variable a little bit by using an unusual declaration:\n\nThe extra makes the entire definition read-only, which is slightly more efficient (e.g., when the code is in a shared library) and able to be stored in ROM with the application.\n\nConstructs an image with the given width, height and format, that uses an existing memory buffer, data. The width and height must be specified in pixels. bytesPerLine specifies the number of bytes per line (stride).\n\nThe buffer must remain valid throughout the life of the QImage and all copies that have not been modified or otherwise detached from the original buffer. The image does not delete the buffer at destruction. You can provide a function pointer cleanupFunction along with an extra pointer cleanupInfo that will be called when the last copy is destroyed.\n\nIf format is an indexed color format, the image color table is initially empty and must be sufficiently expanded with setColorCount() or setColorTable() before the image is used.\n\nUnlike the similar QImage constructor that takes a non-const data buffer, this version will never alter the contents of the buffer. For example, calling QImage::bits() will return a deep copy of the image, rather than the buffer passed to the constructor. This allows for the efficiency of constructing a QImage from raw data, without the possibility of the raw data being changed.\n\nConstructs an image with the given width, height and format, that uses an existing memory buffer, data. The width and height must be specified in pixels. bytesPerLine specifies the number of bytes per line (stride).\n\nThe buffer must remain valid throughout the life of the QImage and all copies that have not been modified or otherwise detached from the original buffer. The image does not delete the buffer at destruction. You can provide a function pointer cleanupFunction along with an extra pointer cleanupInfo that will be called when the last copy is destroyed.\n\nIf format is an indexed color format, the image color table is initially empty and must be sufficiently expanded with setColorCount() or setColorTable() before the image is used.\n\nConstructs an image with the given width, height and format, that uses an existing read-only memory buffer, data. The width and height must be specified in pixels, data must be 32-bit aligned, and each scanline of data in the image must also be 32-bit aligned.\n\nThe buffer must remain valid throughout the life of the QImage and all copies that have not been modified or otherwise detached from the original buffer. The image does not delete the buffer at destruction. You can provide a function pointer cleanupFunction along with an extra pointer cleanupInfo that will be called when the last copy is destroyed.\n\nIf format is an indexed color format, the image color table is initially empty and must be sufficiently expanded with setColorCount() or setColorTable() before the image is used.\n\nUnlike the similar QImage constructor that takes a non-const data buffer, this version will never alter the contents of the buffer. For example, calling QImage::bits() will return a deep copy of the image, rather than the buffer passed to the constructor. This allows for the efficiency of constructing a QImage from raw data, without the possibility of the raw data being changed.\n\nConstructs an image with the given width, height and format, that uses an existing memory buffer, data. The width and height must be specified in pixels, data must be 32-bit aligned, and each scanline of data in the image must also be 32-bit aligned.\n\nThe buffer must remain valid throughout the life of the QImage and all copies that have not been modified or otherwise detached from the original buffer. The image does not delete the buffer at destruction. You can provide a function pointer cleanupFunction along with an extra pointer cleanupInfo that will be called when the last copy is destroyed.\n\nIf format is an indexed color format, the image color table is initially empty and must be sufficiently expanded with setColorCount() or setColorTable() before the image is used.\n\nConstructs an image with the given width, height and format.\n\nA null image will be returned if memory cannot be allocated.\n\nWarning: This will create a QImage with uninitialized data. Call fill() to fill the image with an appropriate pixel value before drawing onto it with QPainter.\n\nConstructs an image with the given size and format.\n\nA null image is returned if memory cannot be allocated.\n\nWarning: This will create a QImage with uninitialized data. Call fill() to fill the image with an appropriate pixel value before drawing onto it with QPainter.\n\nMove-assigns other to this QImage instance.\n\nThis function was introduced in Qt 5.2.\n\nAssigns a shallow copy of the given image to this image and returns a reference to this image.\n\nFor more information about shallow copies, see the Implicit Data Sharing documentation.\n\nSee also copy() and QImage().\n\nDestroys the image and cleans up.\n\nReturns if all the colors in the image are shades of gray (i.e. their red, green and blue components are equal); otherwise false.\n\nNote that this function is slow for images without color table.\n\nApplies the color transformation transform to all pixels in the image.\n\nThis function was introduced in Qt 5.14.\n\nReturns the number of bit planes in the image.\n\nThe number of bit planes is the number of bits of color and transparency information for each pixel. This is different from (i.e. smaller than) the depth when the image format contains unused bits.\n\nThis function was introduced in Qt 4.7.\n\nSee also depth(), format(), and Image Formats.\n\nReturns a pointer to the first pixel data. This is equivalent to scanLine(0).\n\nNote that QImage uses implicit data sharing. This function performs a deep copy of the shared pixel data, thus ensuring that this QImage is the only one using the current return value.\n\nSee also scanLine(), sizeInBytes(), and constBits().\n\nThis is an overloaded function.\n\nNote that QImage uses implicit data sharing, but this function does not perform a deep copy of the shared pixel data, because the returned data is const.\n\nReturns the number of bytes per image scanline.\n\nThis is equivalent to sizeInBytes() / height() if height() is non-zero.\n\nReturns a number that identifies the contents of this QImage object. Distinct QImage objects can only have the same key if they refer to the same contents.\n\nThe key will change when the image is altered.\n\nReturns the color in the color table at index i. The first color is at index 0.\n\nThe colors in an image's color table are specified as ARGB quadruplets (QRgb). Use the qAlpha(), qRed(), qGreen(), and qBlue() functions to get the color value components.\n\nSee also setColor(), pixelIndex(), and Pixel Manipulation.\n\nReturns the size of the color table for the image.\n\nNotice that colorCount() returns 0 for 32-bpp images because these images do not use color tables, but instead encode pixel values as ARGB quadruplets.\n\nThis function was introduced in Qt 4.6.\n\nSee also setColorCount() and Image Information.\n\nReturns the color space of the image if a color space is defined.\n\nThis function was introduced in Qt 5.14.\n\nReturns a list of the colors contained in the image's color table, or an empty list if the image does not have a color table\n\nSee also setColorTable(), colorCount(), and color().\n\nReturns a pointer to the first pixel data.\n\nNote that QImage uses implicit data sharing, but this function does not perform a deep copy of the shared pixel data, because the returned data is const.\n\nThis function was introduced in Qt 4.7.\n\nSee also bits() and constScanLine().\n\nReturns a pointer to the pixel data at the scanline with index i. The first scanline is at index 0.\n\nThe scanline data is as minimum 32-bit aligned. For 64-bit formats it follows the native alignment of 64-bit integers (64-bit for most platforms, but notably 32-bit on i386).\n\nNote that QImage uses implicit data sharing, but this function does not perform a deep copy of the shared pixel data, because the returned data is const.\n\nThis function was introduced in Qt 4.7.\n\nSee also scanLine() and constBits().\n\nDetach and convert the image to the given format in place.\n\nThe specified image conversion flags control how the image data is handled during the conversion process.\n\nThis function was introduced in Qt 5.13.\n\nIf the image has no valid color space, the method does nothing.\n\nThis function was introduced in Qt 5.14.\n\nSee also convertedToColorSpace() and setColorSpace().\n\nThis is an overloaded function.\n\nReturns a copy of the image converted to the given format, using the specified colorTable.\n\nConversion from RGB formats to indexed formats is a slow operation and will use a straightforward nearest color approach, with no dithering.\n\nIf the image has no valid color space, a null QImage is returned.\n\nThis function was introduced in Qt 5.14.\n\nReturns a sub-area of the image as a new image.\n\nThe returned image is copied from the position (rectangle.x(), rectangle.y()) in this image, and will always have the size of the given rectangle.\n\nIn areas beyond this image, pixels are set to 0. For 32-bit RGB images, this means black; for 32-bit ARGB images, this means transparent black; for 8-bit images, this means the color with index 0 in the color table which can be anything; for 1-bit images, this means Qt::color0.\n\nIf the given rectangle is a null rectangle the entire image is copied.\n\nThis is an overloaded function.\n\nThe returned image is copied from the position (x, y) in this image, and will always have the given width and height. In areas beyond this image, pixels are set to 0.\n\nBuilds and returns a 1-bpp mask from the alpha buffer in this image. Returns a null image if the image's format is QImage::Format_RGB32.\n\nThe flags argument is a bitwise-OR of the Qt::ImageConversionFlags, and controls the conversion process. Passing 0 for flags sets all the default options.\n\nThe returned image has little-endian bit order (i.e. the image's format is QImage::Format_MonoLSB), which you can convert to big-endian (QImage::Format_Mono) using the convertToFormat() function.\n\nSee also createHeuristicMask() and Image Transformations.\n\nCreates and returns a 1-bpp heuristic mask for this image.\n\nThe function works by selecting a color from one of the corners, then chipping away pixels of that color starting at all the edges. The four corners vote for which color is to be masked away. In case of a draw (this generally means that this function is not applicable to the image), the result is arbitrary.\n\nThe returned image has little-endian bit order (i.e. the image's format is QImage::Format_MonoLSB), which you can convert to big-endian (QImage::Format_Mono) using the convertToFormat() function.\n\nIf clipTight is true (the default) the mask is just large enough to cover the pixels; otherwise, the mask is larger than the data pixels.\n\nNote that this function disregards the alpha buffer.\n\nSee also createAlphaMask() and Image Transformations.\n\nCreates and returns a mask for this image based on the given color value. If the mode is MaskInColor (the default value), all pixels matching color will be opaque pixels in the mask. If mode is MaskOutColor, all pixels matching the given color will be transparent.\n\nSee also createAlphaMask() and createHeuristicMask().\n\nReturns the depth of the image.\n\nThe image depth is the number of bits used to store a single pixel, also called bits per pixel (bpp).\n\nThe supported depths are 1, 8, 16, 24, 32 and 64.\n\nSee also bitPlaneCount(), convertToFormat(), Image Formats, and Image Information.\n\nReturns the device pixel ratio for the image. This is the ratio between device pixels and device independent pixels.\n\nUse this function when calculating layout geometry based on the image size: QSize layoutSize = image.size() / image.devicePixelRatio()\n\nThe default value is 1.0.\n\nSee also setDevicePixelRatio() and QImageReader.\n\nReturns the number of pixels that fit horizontally in a physical meter. Together with dotsPerMeterY(), this number defines the intended scale and aspect ratio of the image.\n\nSee also setDotsPerMeterX() and Image Information.\n\nReturns the number of pixels that fit vertically in a physical meter. Together with dotsPerMeterX(), this number defines the intended scale and aspect ratio of the image.\n\nSee also setDotsPerMeterY() and Image Information.\n\nFills the entire image with the given pixelValue.\n\nIf the depth of this image is 1, only the lowest bit is used. If you say fill(0), fill(2), etc., the image is filled with 0s. If you say fill(1), fill(3), etc., the image is filled with 1s. If the depth is 8, the lowest 8 bits are used and if the depth is 16 the lowest 16 bits are used.\n\nNote: QImage::pixel() returns the color of the pixel at the given coordinates while QColor::pixel() returns the pixel value of the underlying window system (essentially an index value), so normally you will want to use QImage::pixel() to use a color from an existing image or QColor::rgb() to use a specific color.\n\nSee also depth() and Image Transformations.\n\nThis is an overloaded function.\n\nFills the entire image with the given color.\n\nIf the depth of the image is 1, the image will be filled with 1 if color equals Qt::color1; it will otherwise be filled with 0.\n\nIf the depth of the image is 8, the image will be filled with the index corresponding the color in the color table if present; it will otherwise be filled with 0.\n\nThis function was introduced in Qt 4.8.\n\nThis is an overloaded function.\n\nFills the image with the given color, described as a standard global color.\n\nThis function was introduced in Qt 4.8.\n\nReturns the format of the image.\n\nConstructs a QImage from the first size bytes of the given binary data. The loader attempts to read the image using the specified format. If format is not specified (which is the default), the loader probes the data for a header to guess the file format.\n\nIf format is specified, it must be one of the values returned by QImageReader::supportedImageFormats().\n\nIf the loading of the image fails, the image returned will be a null image.\n\nSee also load(), save(), and Reading and Writing Image Files.\n\nThis is an overloaded function.\n\nLoads an image from the given QByteArray data.\n\nReturns if the image has a format that respects the alpha channel, otherwise returns .\n\nReturns the height of the image.\n\nInverts all pixel values in the image.\n\nThe given invert mode only have a meaning when the image's depth is 32. The default mode is InvertRgb, which leaves the alpha channel unchanged. If the mode is InvertRgba, the alpha bits are also inverted.\n\nInverting an 8-bit image means to replace all pixels using color index i with a pixel using color index 255 minus i. The same is the case for a 1-bit image. Note that the color table is not changed.\n\nIf the image has a premultiplied alpha channel, the image is first converted to an unpremultiplied image format to be inverted and then converted back.\n\nFor 32-bit images, this function is equivalent to allGray().\n\nFor color indexed images, this function returns if color(i) is QRgb(i, i, i) for all indexes of the color table; otherwise returns .\n\nSee also allGray() and Image Formats.\n\nReturns if it is a null image, otherwise returns .\n\nA null image has all parameters set to zero and no allocated data.\n\nLoads an image from the file with the given fileName. Returns if the image was successfully loaded; otherwise invalidates the image and returns .\n\nThe loader attempts to read the image using the specified format, e.g., PNG or JPG. If format is not specified (which is the default), it is auto-detected based on the file's suffix and header. For details, see QImageReader::setAutoDetectImageFormat().\n\nThe file name can either refer to an actual file on disk or to one of the application's embedded resources. See the Resource System overview for details on how to embed images and other resource files in the application's executable.\n\nSee also Reading and Writing Image Files.\n\nThis is an overloaded function.\n\nThis function reads a QImage from the given device. This can, for example, be used to load an image directly into a QByteArray.\n\nLoads an image from the first len bytes of the given binary data. Returns if the image was successfully loaded; otherwise invalidates the image and returns .\n\nThe loader attempts to read the image using the specified format, e.g., PNG or JPG. If format is not specified (which is the default), the loader probes the file for a header to guess the file format.\n\nSee also Reading and Writing Image Files.\n\nThis is an overloaded function.\n\nLoads an image from the given QByteArray data.\n\nReturns the number of pixels by which the image is intended to be offset by when positioning relative to other images.\n\nSee also setOffset() and Image Information.\n\nReturns the color of the pixel at the given position.\n\nIf the position is not valid, the results are undefined.\n\nWarning: This function is expensive when used for massive pixel manipulations. Use constBits() or constScanLine() when many pixels needs to be read.\n\nSee also setPixel(), valid(), constBits(), constScanLine(), and Pixel Manipulation.\n\nThis is an overloaded function.\n\nReturns the color of the pixel at coordinates (x, y).\n\nReturns the color of the pixel at the given position as a QColor.\n\nIf the position is not valid, an invalid QColor is returned.\n\nWarning: This function is expensive when used for massive pixel manipulations. Use constBits() or constScanLine() when many pixels needs to be read.\n\nThis function was introduced in Qt 5.6.\n\nSee also setPixelColor(), setPixel(), valid(), constBits(), constScanLine(), and Pixel Manipulation.\n\nThis is an overloaded function.\n\nReturns the color of the pixel at coordinates (x, y) as a QColor.\n\nThis function was introduced in Qt 5.6.\n\nReturns the pixel index at the given position.\n\nIf position is not valid, or if the image is not a paletted image (depth() > 8), the results are undefined.\n\nSee also valid(), depth(), and Pixel Manipulation.\n\nThis is an overloaded function.\n\nReturns the enclosing rectangle (0, 0, width(), height()) of the image.\n\nChanges the format of the image to format without changing the data. Only works between formats of the same depth.\n\nThis function can be used to change images with alpha-channels to their corresponding opaque formats if the data is known to be opaque-only, or to change the format of a given image buffer before overwriting it with new data.\n\nWarning: The function does not check if the image data is valid in the new format and will still return if the depths are compatible. Operations on an image with invalid data are undefined.\n\nWarning: If the image is not detached, this will cause the data to be copied.\n\nThis function was introduced in Qt 5.9.\n\nSee also hasAlphaChannel() and convertToFormat().\n\nSaves the image to the file with the given fileName, using the given image file format and quality factor. If format is , QImage will attempt to guess the format by looking at fileName's suffix.\n\nThe quality factor must be in the range 0 to 100 or -1. Specify 0 to obtain small compressed files, 100 for large uncompressed files, and -1 (the default) to use the default settings.\n\nReturns if the image was successfully saved; otherwise returns .\n\nSee also Reading and Writing Image Files.\n\nThis is an overloaded function.\n\nThis function writes a QImage to the given device.\n\nThis can, for example, be used to save an image directly into a QByteArray:\n\nReturns a copy of the image scaled to a rectangle defined by the given size according to the given aspectRatioMode and transformMode.\n• If aspectRatioMode is Qt::IgnoreAspectRatio, the image is scaled to size.\n• If aspectRatioMode is Qt::KeepAspectRatio, the image is scaled to a rectangle as large as possible inside size, preserving the aspect ratio.\n• If aspectRatioMode is Qt::KeepAspectRatioByExpanding, the image is scaled to a rectangle as small as possible outside size, preserving the aspect ratio.\n\nIf the given size is empty, this function returns a null image.\n\nSee also isNull() and Image Transformations.\n\nThis is an overloaded function.\n\nReturns a copy of the image scaled to a rectangle with the given width and height according to the given aspectRatioMode and transformMode.\n\nIf either the width or the height is zero or negative, this function returns a null image.\n\nReturns a scaled copy of the image. The returned image is scaled to the given height using the specified transformation mode.\n\nThis function automatically calculates the width of the image so that the ratio of the image is preserved.\n\nIf the given height is 0 or negative, a null image is returned.\n\nReturns a scaled copy of the image. The returned image is scaled to the given width using the specified transformation mode.\n\nThis function automatically calculates the height of the image so that its aspect ratio is preserved.\n\nIf the given width is 0 or negative, a null image is returned.\n\nReturns a pointer to the pixel data at the scanline with index i. The first scanline is at index 0.\n\nThe scanline data is as minimum 32-bit aligned. For 64-bit formats it follows the native alignment of 64-bit integers (64-bit for most platforms, but notably 32-bit on i386).\n\nWarning: If you are accessing 32-bpp image data, cast the returned pointer to (QRgb has a 32-bit size) and use it to read/write the pixel value. You cannot use the pointer directly, because the pixel format depends on the byte order on the underlying platform. Use qRed(), qGreen(), qBlue(), and qAlpha() to access the pixels.\n\nSee also bytesPerLine(), bits(), Pixel Manipulation, and constScanLine().\n\nThis is an overloaded function.\n\nSets the alpha channel of this image to the given alphaChannel.\n\nIf alphaChannel is an 8 bit alpha image, the alpha values are used directly. Otherwise, alphaChannel is converted to 8 bit grayscale and the intensity of the pixel values is used.\n\nIf the image already has an alpha channel, the existing alpha channel is multiplied with the new one. If the image doesn't have an alpha channel it will be converted to a format that does.\n\nThe operation is similar to painting alphaChannel as an alpha image over this image using .\n\nSee also hasAlphaChannel(), alphaChannel(), Image Transformations, and Image Formats.\n\nSets the color at the given index in the color table, to the given to colorValue. The color value is an ARGB quadruplet.\n\nIf index is outside the current size of the color table, it is expanded with setColorCount().\n\nSee also color(), colorCount(), setColorTable(), and Pixel Manipulation.\n\nResizes the color table to contain colorCount entries.\n\nIf the color table is expanded, all the extra colors will be set to transparent (i.e qRgba(0, 0, 0, 0)).\n\nWhen the image is used, the color table must be large enough to have entries for all the pixel/index values present in the image, otherwise the results are undefined.\n\nThis function was introduced in Qt 4.6.\n\nSee also colorCount(), colorTable(), setColor(), and Image Transformations.\n\nSets the image color space to colorSpace without performing any conversions on image data.\n\nThis function was introduced in Qt 5.14.\n\nSets the color table used to translate color indexes to QRgb values, to the specified colors.\n\nWhen the image is used, the color table must be large enough to have entries for all the pixel/index values present in the image, otherwise the results are undefined.\n\nSee also colorTable(), setColor(), and Image Transformations.\n\nSets the device pixel ratio for the image. This is the ratio between image pixels and device-independent pixels.\n\nThe default scaleFactor is 1.0. Setting it to something else has two effects:\n\nQPainters that are opened on the image will be scaled. For example, painting on a 200x200 image if with a ratio of 2.0 will result in effective (device-independent) painting bounds of 100x100.\n\nCode paths in Qt that calculate layout geometry based on the image size will take the ratio into account: QSize layoutSize = image.size() / image.devicePixelRatio() The net effect of this is that the image is displayed as high-DPI image rather than a large image (see Drawing High Resolution Versions of Pixmaps and Images).\n\nSets the number of pixels that fit horizontally in a physical meter, to x.\n\nTogether with dotsPerMeterY(), this number defines the intended scale and aspect ratio of the image, and determines the scale at which QPainter will draw graphics on the image. It does not change the scale or aspect ratio of the image when it is rendered on other paint devices.\n\nSee also dotsPerMeterX() and Image Information.\n\nSets the number of pixels that fit vertically in a physical meter, to y.\n\nTogether with dotsPerMeterX(), this number defines the intended scale and aspect ratio of the image, and determines the scale at which QPainter will draw graphics on the image. It does not change the scale or aspect ratio of the image when it is rendered on other paint devices.\n\nSee also dotsPerMeterY() and Image Information.\n\nSets the number of pixels by which the image is intended to be offset by when positioning relative to other images, to offset.\n\nSee also offset() and Image Information.\n\nSets the pixel index or color at the given position to index_or_rgb.\n\nIf the image's format is either monochrome or paletted, the given index_or_rgb value must be an index in the image's color table, otherwise the parameter must be a QRgb value.\n\nIf position is not a valid coordinate pair in the image, or if index_or_rgb >= colorCount() in the case of monochrome and paletted images, the result is undefined.\n\nWarning: This function is expensive due to the call of the internal function called within; if performance is a concern, we recommend the use of scanLine() or bits() to access pixel data directly.\n\nSee also pixel() and Pixel Manipulation.\n\nThis is an overloaded function.\n\nSets the pixel index or color at (x, y) to index_or_rgb.\n\nSets the color at the given position to color.\n\nIf position is not a valid coordinate pair in the image, or the image's format is either monochrome or paletted, the result is undefined.\n\nWarning: This function is expensive due to the call of the internal function called within; if performance is a concern, we recommend the use of scanLine() or bits() to access pixel data directly.\n\nThis function was introduced in Qt 5.6.\n\nSee also pixelColor(), pixel(), bits(), scanLine(), and Pixel Manipulation.\n\nThis is an overloaded function.\n\nSets the pixel color at (x, y) to color.\n\nThis function was introduced in Qt 5.6.\n\nSets the image text to the given text and associate it with the given key.\n\nIf you just want to store a single text block (i.e., a \"comment\" or just a description), you can either pass an empty key, or use a generic key like \"Description\".\n\nThe image text is embedded into the image data when you call save() or QImageWriter::write().\n\nNot all image formats support embedded text. You can find out if a specific image or format supports embedding text by using QImageWriter::supportsOption(). We give an example:\n\nYou can use QImageWriter::supportedImageFormats() to find out which image formats are available to you.\n\nSee also text() and textKeys().\n\nReturns the size of the image, i.e. its width() and height().\n\nThis function was introduced in Qt 5.10.\n\nSee also byteCount(), bytesPerLine(), bits(), and Image Information.\n\nReturns a smoothly scaled copy of the image. The returned image has a size of width w by height h pixels.\n\nSwaps image other with this image. This operation is very fast and never fails.\n\nThis function was introduced in Qt 4.8.\n\nReturns the image text associated with the given key. If the specified key is an empty string, the whole image text is returned, with each key-text pair separated by a newline.\n\nSee also setText() and textKeys().\n\nReturns the text keys for this image.\n\nYou can use these keys with text() to list the image text for a certain key.\n\nThe returned CGImageRef partakes in the QImage implicit sharing, and holds a reference to the QImage data. CGImage is immutable and will never detach the QImage. Writing to the QImage will detach as usual.\n\nThis function is fast, and does not copy or convert image data.\n\nThe following image formats are supported, and will be mapped to a corresponding native image type:\n\nOther formats are not supported; this function returns a null CGImageRef for those cases. Users of this function may then convert the QImage to a supported formate first, for example Format_ARGB32_Premultiplied.\n\nThe CGImageRef color space is set to the sRGB color space.\n\nReturns a copy of the image that is transformed using the given transformation matrix and transformation mode.\n\nThe returned image will normally have the same {Image Formats}{format} as the original image. However, a complex transformation may result in an image where not all pixels are covered by the transformed pixels of the original image. In such cases, those background pixels will be assigned a transparent color value, and the transformed image will be given a format with an alpha channel, even if the orginal image did not have that.\n\nThe transformation matrix is internally adjusted to compensate for unwanted translation; i.e. the image produced is the smallest image that contains all the transformed points of the original image. Use the trueMatrix() function to retrieve the actual matrix used for transforming an image.\n\nUnlike the other overload, this function can be used to perform perspective transformations on images.\n\nSee also trueMatrix() and Image Transformations.\n\nReturns the actual matrix used for transforming an image with the given width, height and matrix.\n\nWhen transforming an image using the transformed() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. transformed() returns the smallest image containing all transformed points of the original image. This function returns the modified matrix, which maps points correctly from the original image into the new image.\n\nUnlike the other overload, this function creates transformation matrices that can be used to perform perspective transformations on images.\n\nSee also transformed() and Image Transformations.\n\nReturns if pos is a valid coordinate pair within the image; otherwise returns .\n\nSee also rect() and QRect::contains().\n\nThis is an overloaded function.\n\nReturns if QPoint(x, y) is a valid coordinate pair within the image; otherwise returns .\n\nReturns the width of the image.\n\nReturns if this image and the given image have different contents; otherwise returns .\n\nThe comparison can be slow, unless there is some obvious difference, such as different widths, in which case the function will return quickly.\n\nReturns if this image and the given image have the same contents; otherwise returns .\n\nThe comparison can be slow, unless there is some obvious difference (e.g. different size or format), in which case the function will return quickly."
    },
    {
        "link": "https://doc.qt.io/qt-5/qimage-obsolete.html",
        "document": "The following members of class QImage are obsolete. They are provided to keep old source code working. We strongly advise against using them in new code.\n\nThis function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.\n\nReturns the alpha channel of the image as a new grayscale QImage in which each pixel's red, green, and blue values are given the alpha value of the original image. The color depth of the returned image is 8-bit.\n\nYou can see an example of use of this function in QPixmap's alphaChannel(), which works in the same way as this function on QPixmaps.\n\nMost usecases for this function can be replaced with QPainter and using composition modes.\n\nNote this returns a color-indexed image if you want the alpha channel in the alpha8 format instead use convertToFormat(Format_Alpha8) on the source image.\n\nSee also setAlphaChannel(), hasAlphaChannel(), convertToFormat(), Pixmap, and Image Transformations.\n\nThis function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.\n\nReturns the number of bytes occupied by the image data.\n\nNote this method should never be called on an image larger than 2 gigabytes. Instead use sizeInBytes().\n\nThis function was introduced in Qt 4.6.\n\nSee also sizeInBytes(), bytesPerLine(), bits(), and Image Information.\n\nThis function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.\n\nReturns the number of bytes occupied by the image data.\n\nThis function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.\n\nReturns the size of the color table for the image.\n\nSee also setNumColors() and setColorCount().\n\nThis function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.\n\nReturns a number that identifies the contents of this QImage object. Distinct QImage objects can only have the same serial number if they refer to the same contents (but they don't have to).\n\nThis function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.\n\nResizes the color table to contain n entries.\n\nSee also numColors() and setColorCount().\n\nThis function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.\n\nSets the image text to the given text and associate it with the given key. The text is recorded in the specified language, or in a default language if language is .\n\nThe language the text is recorded in is no longer relevant since the text is always set using QString and UTF-8 representation.\n\nThis function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.\n\nReturns the text recorded for the given key in the given language, or in a default language if language is .\n\nThe language the text is recorded in is no longer relevant since the text is always set using QString and UTF-8 representation.\n\nThis function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.\n\nThis is an overloaded function.\n\nReturns the text recorded for the given keywordAndLanguage.\n\nThe language the text is recorded in is no longer relevant since the text is always set using QString and UTF-8 representation.\n\nThis function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.\n\nReturns the language identifiers for which some texts are recorded. Note that if you want to iterate over the list, you should iterate over a copy.\n\nThe language the text is recorded in is no longer relevant since the text is always set using QString and UTF-8 representation.\n\nThis function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.\n\nReturns a list of QImageTextKeyLang objects that enumerate all the texts key/language pairs set for this image.\n\nThe language the text is recorded in is no longer relevant since the text is always set using QString and UTF-8 representation.\n\nThis function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.\n\nReturns a copy of the image that is transformed using the given transformation matrix and transformation mode.\n\nThe returned image will normally have the same {Image Formats}{format} as the original image. However, a complex transformation may result in an image where not all pixels are covered by the transformed pixels of the original image. In such cases, those background pixels will be assigned a transparent color value, and the transformed image will be given a format with an alpha channel, even if the orginal image did not have that.\n\nThe transformation matrix is internally adjusted to compensate for unwanted translation; i.e. the image produced is the smallest image that contains all the transformed points of the original image. Use the trueMatrix() function to retrieve the actual matrix used for transforming an image.\n\nSee also trueMatrix() and Image Transformations.\n\nThis function is obsolete. It is provided to keep old source code working. We strongly advise against using it in new code.\n\nReturns the actual matrix used for transforming an image with the given width, height and matrix.\n\nWhen transforming an image using the transformed() function, the transformation matrix is internally adjusted to compensate for unwanted translation, i.e. transformed() returns the smallest image containing all transformed points of the original image. This function returns the modified matrix, which maps points correctly from the original image into the new image.\n\nSee also transformed() and Image Transformations."
    },
    {
        "link": "https://qthub.com/static/doc/qt5/qtwidgets/qtwidgets-painting-transformations-example.html",
        "document": "The Transformations example shows how transformations influence the way that QPainter renders graphics primitives.\n\nThe application allows the user to manipulate the rendering of a shape by changing the translation, rotation and scale of QPainter's coordinate system.\n\nThe example consists of two classes and a global enum:\n• The class controls the rendering of a given shape.\n• The class is the application's main window.\n• The enum describes the various transformation operations available in the application.\n\nFirst we will take a quick look at the enum, then we will review the class to see how a shape is rendered. Finally, we will take a look at the Transformations application's features implemented in the class.\n\nNormally, the QPainter operates on the associated device's own coordinate system, but it also has good support for coordinate transformations.\n\nThe default coordinate system of a paint device has its origin at the top-left corner. The x values increase to the right and the y values increase downwards. You can scale the coordinate system by a given offset using the QPainter::scale() function, you can rotate it clockwise using the QPainter::rotate() function and you can translate it (i.e. adding a given offset to the points) using the QPainter::translate() function. You can also twist the coordinate system around the origin (called shearing) using the QPainter::shear() function.\n\nAll the tranformation operations operate on QPainter's tranformation matrix that you can retrieve using the QPainter::worldTransform() function. A matrix transforms a point in the plane to another point. For more information about the transformation matrix, see the Coordinate System and QTransform documentation.\n\nThe global enum is declared in the file and describes the various transformation operations available in the Transformations application.\n\nThe class inherits QWidget, and controls the rendering of a given shape.\n\nWe declare two public functions, and , to be able to specify the widget's shape and to transform the coordinate system the shape is rendered within.\n\nWe reimplement the QWidget's minimumSizeHint() and sizeHint() functions to give the widget a reasonable size within our application, and we reimplement the QWidget::paintEvent() event handler to draw the render area's shape applying the user's transformation choices.\n\nWe also declare several convenience functions to draw the shape, the coordinate system's outline and the coordinates, and to transform the painter according to the chosen transformations.\n\nIn addition, the widget keeps a list of the currently applied transformation operations, a reference to its shape, and a couple of convenience variables that we will use when rendering the coordinates.\n\nThe widget controls the rendering of a given shape, including the transformations of the coordinate system, by reimplementing the QWidget::paintEvent() event handler. But first we will take a quick look at the constructor and at the functions that provides access to the widget:\n\nIn the constructor we pass the parent parameter on to the base class, and customize the font that we will use to render the coordinates. The QWidget::font() function returns the font currently set for the widget. As long as no special font has been set, or after QWidget::setFont() is called, this is either a special font for the widget class, the parent's font or (if this widget is a top level widget) the default application font.\n\nAfter ensuring that the font's size is 12 points, we extract the rectangles enclosing the coordinate letters, 'x' and 'y', using the QFontMetrics class.\n\nQFontMetrics provides functions to access the individual metrics of the font, its characters, and for strings rendered in the font. The QFontMetrics::boundingRect() function returns the bounding rectangle of the given character relative to the left-most point on the base line.\n\nIn the and functions we update the widget by storing the new value or values followed by a call to the QWidget::update() slot which schedules a paint event for processing when Qt returns to the main event loop.\n\nWe reimplement the QWidget's minimumSizeHint() and sizeHint() functions to give the widget a reasonable size within our application. The default implementations of these functions returns an invalid size if there is no layout for this widget, and returns the layout's minimum size or preferred size, respectively, otherwise.\n\nThe event handler receives the widget's paint events. A paint event is a request to repaint all or part of the widget. It can happen as a result of QWidget::repaint() or QWidget::update(), or because the widget was obscured and has now been uncovered, or for many other reasons.\n\nFirst we create a QPainter for the widget. The QPainter::Antialiasing render hint indicates that the engine should antialias edges of primitives if possible. Then we erase the area that needs to be repainted using the QPainter::fillRect() function.\n\nWe also translate the coordinate system with an constant offset to ensure that the original shape is renderend with a suitable margin.\n\nBefore we start to render the shape, we call the QPainter::save() function.\n\nQPainter::save() saves the current painter state (i.e. pushes the state onto a stack) including the current coordinate system. The rationale for saving the painter state is that the following call to the function will transform the coordinate system depending on the currently chosen transformation operations, and we need a way to get back to the original state to draw the outline.\n\nAfter transforming the coordinate system, we draw the 's shape, and then we restore the painter state using the QPainter::restore() function (i.e. popping the saved state off the stack).\n\nThen we draw the square outline.\n\nSince we want the coordinates to correspond with the coordinate system the shape is rendered within, we must make another call to the function.\n\nThe order of the painting operations is essential with respect to the shared pixels. The reason why we don't render the coordinates when the coordinate system already is transformed to render the shape, but instead defer their rendering to the end, is that we want the coordinates to appear on top of the shape and its outline.\n\nThere is no need to save the QPainter state this time since drawing the coordinates is the last painting operation.\n\nThe , and are convenience functions called from the event handler. For more information about QPainter's basic drawing operations and how to display basic graphics primitives, see the Basic Drawing example.\n\nThe convenience function is also called from the event handler, and transforms the given QPainter's coordinate system according to the user's transformation choices.\n\nThe class is the Transformations application's main window.\n\nThe application displays four widgets. The left-most widget renders the shape in QPainter's default coordinate system, the others render the shape with the chosen transformation in addition to all the transformations applied to the widgets to their left.\n\nWe declare two public slots to make the application able to respond to user interaction, updating the displayed widgets according to the user's transformation choices.\n\nThe slot updates each of the widgets applying the currently chosen transformation operations, and is called whenever the user changes the selected operations. The slot updates the widgets' shapes whenever the user changes the preferred shape.\n\nWe also declare a private convenience function, , that is used when constructing the widget, and we declare pointers to the various components of the widget. We choose to keep the available shapes in a QList of QPainterPaths. In addition we declare a private enum counting the number of displayed widgets except the widget that renders the shape in QPainter's default coordinate system.\n\nIn the constructor we create and initialize the application's components:\n\nFirst we create the widget that will render the shape in the default coordinate system. We also create the associated QComboBox that allows the user to choose among four different shapes: A clock, a house, a text and a truck. The shapes themselves are created at the end of the constructor, using the convenience function.\n\nThen we create the widgets that will render their shapes with coordinate tranformations. By default the applied operation is No Transformation, i.e. the shapes are rendered within the default coordinate system. We create and initialize the associated QComboBoxes with items corresponding to the various transformation operations decribed by the global enum.\n\nWe also connect the QComboBoxes' activated() signal to the slot to update the application whenever the user changes the selected transformation operations.\n\nFinally, we set the layout for the application window using the QWidget::setLayout() function, construct the available shapes using the private convenience function, and make the application show the clock shape on startup using the public slot before we set the window title.\n\nThe function is called from the constructor and create the QPainterPath objects representing the shapes that are used in the application. For construction details, see the example file. The shapes are stored in a QList. The QList::append() function inserts the given shape at the end of the list.\n\nWe also connect the associated QComboBox's activated() signal to the slot to update the application when the user changes the preferred shape.\n\nThe public slot is called whenever the user changes the selected operations.\n\nWe retrieve the chosen transformation operation for each of the transformed widgets by querying the associated QComboBoxes. The transformed widgets are supposed to render the shape with the transformation specified by its associated combobox in addition to all the transformations applied to the widgets to its left. For that reason, for each widget we query, we append the associated operation to a QList of transformations which we apply to the widget before proceeding to the next.\n\nThe slot is called whenever the user changes the preferred shape, updating the widgets using their public function.\n\nThe Transformations example shows how transformations influence the way that QPainter renders graphics primitives. Normally, the QPainter operates on the device's own coordinate system, but it also has good support for coordinate transformations. With the Transformations application you can scale, rotate and translate QPainter's coordinate system. The order in which these tranformations are applied is essential for the result.\n\nAll the tranformation operations operate on QPainter's tranformation matrix. For more information about the transformation matrix, see the Coordinate System and QTransform documentation.\n\nThe Qt reference documentation provides several painting examples. Among these is the Affine Transformations example that shows Qt's ability to perform transformations on painting operations. The example also allows the user to experiment with the various transformation operations."
    },
    {
        "link": "https://qt.developpez.com/doc/5.15/qimage",
        "document": "Sets the color table used to translate color indexes. Only monochrome and 8-bit formats.\n\nInverts all pixel values in the image using the given InvertMode value.\n\nFills the entire image with the given pixel value.\n\nDefines the aspect ratio by setting the number of pixels that fit vertically in a physical meter.\n\nDefines the aspect ratio by setting the number of pixels that fit horizontally in a physical meter.\n\nThere are also functions for changing attributes of an image in-place:\n\nThe transformed() function returns a copy of the image that is transformed with the given transformation matrix and transformation mode: Internally, the transformation matrix is adjusted to compensate for unwanted translation, i.e. transformed() returns the smallest image containing all transformed points of the original image. The static trueMatrix() function returns the actual matrix used for transforming the image.\n\nThe scaledToWidth () and scaledToHeight () functions return scaled copies of the image.\n\nThe mirrored () function returns a mirror of the image in the desired direction, the scaled () returns a copy of the image scaled to a rectangle of the desired measures, and the rgbSwapped () function constructs a BGR image from a RGB image.\n\nQImage supports a number of functions for creating a new image that is a transformed version of the original: The createAlphaMask () function builds and returns a 1-bpp mask from the alpha buffer in this image, and the createHeuristicMask () function creates and returns a 1-bpp heuristic mask for this image. The latter function works by selecting a color from one of the corners, then chipping away pixels of that color starting at all the edges.\n\nAn image's format can be retrieved using the format () function. Use the convertToFormat () functions to convert an image into another format. The allGray () and isGrayscale () functions tell whether a color image can safely be converted to a grayscale image.\n\n32-bit images have no color table; instead, each pixel contains an QRgb value. There are three different types of 32-bit images storing RGB (i.e. 0xffRRGGBB), ARGB and premultiplied ARGB values respectively. In the premultiplied format the red, green, and blue channels are multiplied by the alpha component divided by 255.\n\n8-bit images are stored using 8-bit indexes into a color table, i.e. they have a single byte per pixel. The color table is a QVector < QRgb >, and the QRgb typedef is equivalent to an unsigned int containing an ARGB quadruplet on the format 0xAARRGGBB.\n\nMonochrome images are stored using 1-bit indexes into a color table with at most two colors. There are two different types of monochrome images: big endian (MSB first) or little endian (LSB first) bit order.\n\nEach pixel stored in a QImage is represented by an integer. The size of the integer varies depending on the format. QImage supports several image formats described by the Format enum.\n\nQImage also provide the scanLine () function which returns a pointer to the pixel data at the scanline with the given index, and the bits () function which returns a pointer to the first pixel data (this is equivalent to scanLine(0)).\n\nFor images with more than 8-bit per color-channel. The methods setPixelColor () and pixelColor () can be used to set and get with QColor values.\n\nAn entry in the color table is an ARGB quadruplet encoded as an QRgb value. Use the qRgb () and qRgba () functions to make a suitable QRgb value for use with the setColor () function. For example:\n\nIn case of a 8-bit and monchrome images, the pixel value is only an index from the image's color table. So the setPixel () function can only be used to alter the color of the pixel at the given coordinates to a predefined color from the image's color table, i.e. it can only change the pixel's index value. To alter or add a color to an image's color table, use the setColor () function.\n\nIn case of a 32-bit image, the setPixel () function can be used to alter the color of the pixel at the given coordinates to any other color specified as an ARGB quadruplet. To make a suitable QRgb value, use the qRgb () (adding a default alpha component to the given RGB values, i.e. creating an opaque color) or qRgba () function. For example:\n\nThe functions used to manipulate an image's pixels depend on the image format. The reason is that monochrome and 8-bit images are index-based and use a color lookup table, while 32-bit images store ARGB values directly. For more information on image formats, see the Image Formats section.\n\nThe cacheKey () function returns a number that uniquely identifies the contents of this QImage object.\n\nThe format (), bytesPerLine (), and sizeInBytes () functions provide low-level information about the data stored in the image.\n\nThe depth () function returns the depth of the image. The supported depths are 1 (monochrome), 8, 16, 24 and 32 bits. The bitPlaneCount () function tells how many of those bits that are used. For more information see the Image Formats section.\n\nThe text () function returns the image text associated with the given text key. An image's text keys can be retrieved using the textKeys () function. Use the setText () function to alter an image's text.\n\nThe hasAlphaChannel () function tells if the image's format respects the alpha channel, or not. The allGray () and isGrayscale () functions tell whether an image's colors are all shades of gray.\n\nIn case of monochrome and 8-bit images, the colorCount () and colorTable () functions provide information about the color components used to store the image data: The colorTable () function returns the image's entire color table. To obtain a single entry, use the pixelIndex () function to retrieve the pixel index for a given pair of coordinates, then use the color () function to retrieve the color. Note that if you create an 8-bit image manually, you have to set a valid color table on the image as well.\n\nThe color of a pixel can be retrieved by passing its coordinates to the pixel () function. The pixel () function returns the color as a QRgb value indepedent of the image's format.\n\nThe rect () function returns the image's enclosing rectangle. The valid () function tells if a given pair of coordinates is within this rectangle. The offset () function returns the number of pixels by which the image is intended to be offset by when positioned relative to other images, which also can be manipulated using the setOffset () function.\n\nThe size (), width (), height (), dotsPerMeterX (), and dotsPerMeterY () functions provide information about the image size and aspect ratio.\n\nQImage provides a collection of functions that can be used to obtain a variety of information about the image:\n\nThe complete list of supported file formats are available through the QImageReader::supportedImageFormats () and QImageWriter::supportedImageFormats () functions. New file formats can be added as plugins. By default, Qt supports the following formats:\n\nSimply call the save () function to save a QImage object.\n\nQImage provides several ways of loading an image file: The file can be loaded when constructing the QImage object, or by using the load () or loadFromData () functions later on. QImage also provides the static fromData () function, constructing a QImage from the given data. When loading an image, the file name can either refer to an actual file on disk or to one of the application's embedded resources. See The Qt Resource System overview for details on how to embed images and other resource files in the application's executable.\n\nPainting on a QImage with the format QImage::Format_Indexed8 is not supported.\n\nIf you would like to load QImage objects in a static build of Qt, refer to the Plugin HowTo .\n\nQImage objects can be passed around by value since the QImage class uses implicit data sharing . QImage objects can also be streamed and compared.\n\nQImage provides a collection of functions that can be used to obtain a variety of information about the image. There are also several functions that enables transformation of the image.\n\nThe QImage class supports several image formats described by the Format enum. These include monochrome, 8-bit, 32-bit and alpha-blended images which are available in all versions of Qt 4.x.\n\nBecause QImage is a QPaintDevice subclass, QPainter can be used to draw directly onto images. When using QPainter on a QImage , the painting can be performed in another thread than the current GUI thread.\n\nQt provides four classes for handling image data: QImage , QPixmap , QBitmap and QPicture . QImage is designed and optimized for I/O, and for direct pixel access and manipulation, while QPixmap is designed and optimized for showing images on screen. QBitmap is only a convenience class that inherits QPixmap , ensuring a depth of 1. Finally, the QPicture class is a paint device that records and replays QPainter commands.\n\nInvert only the RGB values and leave the alpha channel unchanged.\n\nThis enum type is used to describe how pixel values should be inverted in the invertPixels () function.\n\nAvoid most rendering directly to most of these formats using QPainter . Rendering is best optimized to the Format_RGB32 and Format_ARGB32_Premultiplied formats, and secondarily for rendering to the Format_RGB16, Format_RGBX8888, Format_RGBA8888_Premultiplied, Format_RGBX64 and Format_RGBA64_Premultiplied formats\n\nDrawing into a QImage with QImage::Format_Indexed8 is not supported.\n\nThe image is stored using a 24-bit BGR format. (added in Qt 5.14)\n\nThe image is stored using a premultiplied 64-bit halfword-ordered RGBA format (16-16-16-16). (added in Qt 5.12)\n\nThe image is stored using a 64-bit halfword-ordered RGBA format (16-16-16-16). (added in Qt 5.12)\n\nThe image is stored using a 64-bit halfword-ordered RGB(x) format (16-16-16-16). This is the same as the Format_RGBA64 except alpha must always be 65535. (added in Qt 5.12)\n\nThe image is stored using an 16-bit grayscale format. (added in Qt 5.13)\n\nThe image is stored using an 8-bit grayscale format. (added in Qt 5.5)\n\nThe image is stored using an 8-bit alpha only format. (added in Qt 5.5)\n\nThe image is stored using a 32-bit premultiplied ARGB format (2-10-10-10). (added in Qt 5.4)\n\nThe image is stored using a 32-bit RGB format (x-10-10-10). (added in Qt 5.4)\n\nThe image is stored using a 32-bit premultiplied ABGR format (2-10-10-10). (added in Qt 5.4)\n\nThe image is stored using a 32-bit BGR format (x-10-10-10). (added in Qt 5.4)\n\nThe image is stored using a premultiplied 32-bit byte-ordered RGBA format (8-8-8-8). (added in Qt 5.2)\n\nThe image is stored using a 32-bit byte-ordered RGBA format (8-8-8-8). Unlike ARGB32 this is a byte-ordered format, which means the 32bit encoding differs between big endian and little endian architectures, being respectively (0xRRGGBBAA) and (0xAABBGGRR). The order of the colors is the same on any architecture if read as bytes 0xRR,0xGG,0xBB,0xAA. (added in Qt 5.2)\n\nThe image is stored using a 32-bit byte-ordered RGB(x) format (8-8-8-8). This is the same as the Format_RGBA8888 except alpha must always be 255. (added in Qt 5.2)\n\nThe image is stored using a premultiplied 16-bit ARGB format (4-4-4-4).\n\nThe image is stored using a 16-bit RGB format (4-4-4). The unused bits are always zero.\n\nThe image is stored using a 24-bit RGB format (8-8-8).\n\nThe image is stored using a premultiplied 24-bit ARGB format (8-5-5-5).\n\nThe image is stored using a 16-bit RGB format (5-5-5). The unused most significant bit is always zero.\n\nThe image is stored using a premultiplied 24-bit ARGB format (6-6-6-6).\n\nThe image is stored using a 24-bit RGB format (6-6-6). The unused most significant bits is always zero.\n\nThe image is stored using a premultiplied 24-bit ARGB format (8-5-6-5).\n\nThe image is stored using a 16-bit RGB format (5-6-5).\n\nThe image is stored using a premultiplied 32-bit ARGB format (0xAARRGGBB), i.e. the red, green, and blue channels are multiplied by the alpha component divided by 255. (If RR, GG, or BB has a higher value than the alpha channel, the results are undefined.) Certain operations (such as image composition using alpha blending) are faster using premultiplied ARGB32 than with plain ARGB32.\n\nThe image is stored using a 32-bit ARGB format (0xAARRGGBB).\n\nThe image is stored using a 32-bit RGB format (0xffRRGGBB).\n\nThe image is stored using 8-bit indexes into a colormap.\n\nThe image is stored using 1-bit per pixel. Bytes are packed with the less significant bit (LSB) first.\n\nThe image is stored using 1-bit per pixel. Bytes are packed with the most significant bit (MSB) first.\n\nThe following image formats are available in Qt. See the notes after the table."
    },
    {
        "link": "https://doc.qt.io/qt-6/qtwidgets-painting-basicdrawing-example.html",
        "document": "The Basic Drawing example shows how to display basic graphics primitives in a variety of styles using the QPainter class.\n\nQPainter performs low-level painting on widgets and other paint devices. The class can draw everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps. Normally, it draws in a \"natural\" coordinate system, but it can in addition do view and world transformation.\n\nThe example provides a render area, displaying the currently active shape, and lets the user manipulate the rendered shape and its appearance using the QPainter parameters: The user can change the active shape (Shape), and modify the QPainter's pen (Pen Width, Pen Style, Pen Cap, Pen Join), brush (Brush Style) and render hints (Antialiasing). In addition the user can rotate a shape (Transformations); behind the scenes we use QPainter's ability to manipulate the coordinate system to perform the rotation.\n\nThe Basic Drawing example consists of two classes:\n• is a custom widget that renders multiple copies of the currently active shape.\n• is the application's main window displaying a widget in addition to several parameter widgets.\n\nFirst we will review the class, then we will take a look at the class.\n\nThe Window class inherits QWidget, and is the application's main window displaying a widget in addition to several parameter widgets.\n\nWe declare the various widgets, and three private slots updating the widget: The slot updates the widget when the user changes the currently active shape. We call the slot when either of the QPainter's pen parameters changes. And the slot updates the widget when the user changes the painter's brush style.\n\nIn the constructor we create and initialize the various widgets appearing in the main application window.\n\nFirst we create the widget that will render the currently active shape. Then we create the Shape combobox, and add the associated items (i.e. the different shapes a QPainter can draw).\n\nQPainter's pen is a QPen object; the QPen class defines how a painter should draw lines and outlines of shapes. A pen has several properties: Width, style, cap and join.\n\nA pen's width can be zero or greater, but the most common width is zero. Note that this doesn't mean 0 pixels, but implies that the shape is drawn as smoothly as possible although perhaps not mathematically correct.\n\nWe create a QSpinBox for the Pen Width parameter.\n\nThe pen style defines the line type. The default style is solid (Qt::SolidLine). Setting the style to none (Qt::NoPen) tells the painter to not draw lines or outlines. The pen cap defines how the end points of lines are drawn. And the pen join defines how two lines join when multiple connected lines are drawn. The cap and join only apply to lines with a width of 1 pixel or greater.\n\nWe create QComboBoxes for each of the Pen Style, Pen Cap and Pen Join parameters, and adds the associated items (i.e the values of the Qt::PenStyle, Qt::PenCapStyle and Qt::PenJoinStyle enums respectively).\n\nThe QBrush class defines the fill pattern of shapes drawn by a QPainter. The default brush style is Qt::NoBrush. This style tells the painter to not fill shapes. The standard style for filling is Qt::SolidPattern.\n\nWe create a QComboBox for the Brush Style parameter, and add the associated items (i.e. the values of the Qt::BrushStyle enum).\n\nAntialiasing is a feature that \"smoothes\" the pixels to create more even and less jagged lines, and can be applied using QPainter's render hints. QPainter::RenderHints are used to specify flags to QPainter that may or may not be respected by any given engine.\n\nWe simply create a QCheckBox for the Antialiasing option.\n\nThe Transformations option implies a manipulation of the coordinate system that will appear as if the rendered shape is rotated in three dimensions.\n\nWe use the QPainter::translate(), QPainter::rotate() and QPainter::scale() functions to implement this feature represented in the main application window by a simple QCheckBox.\n\nThen we connect the parameter widgets with their associated slots using the static QObject::connect() function, ensuring that the widget is updated whenever the user changes the shape, or any of the other parameters.\n\nFinally, we add the various widgets to a layout, and call the , , and slots to initialize the application. We also turn on antialiasing.\n\nThe slot is called whenever the user changes the currently active shape.\n\nFirst we retrieve the shape the user has chosen using the QComboBox::itemData() function. This function returns the data for the given role in the given index in the combobox. We use QComboBox::currentIndex() to retrieve the index of the shape, and the role is defined by the Qt::ItemDataRole enum; is an alias for Qt::UserRole.\n\nNote that Qt::UserRole is only the first role that can be used for application-specific purposes. If you need to store different data in the same index, you can use different roles by simply incrementing the value of Qt::UserRole, for example: 'Qt::UserRole + 1' and 'Qt::UserRole + 2'. However, it is a good programming practice to give each role their own name: 'myFirstRole = Qt::UserRole + 1' and 'mySecondRole = Qt::UserRole + 2'. Even though we only need a single role in this particular example, we add the following line of code to the beginning of the file.\n\nThe QComboBox::itemData() function returns the data as a QVariant, so we need to cast the data to . If there is no data for the given role, the function returns QVariant::Invalid.\n\nIn the end we call the slot to update the widget.\n\nWe call the slot whenever the user changes any of the pen parameters. Again we use the QComboBox::itemData() function to retrieve the parameters, and then we call the slot to update the widget.\n\nThe brushChanged() slot is called whenever the user changes the brush parameter which we retrieve using the QComboBox::itemData() function as before.\n\nIf the brush parameter is a gradient fill, special actions are required.\n\nThe QGradient class is used in combination with QBrush to specify gradient fills. Qt currently supports three types of gradient fills: linear, radial and conical. Each of these is represented by a subclass of QGradient: QLinearGradient, QRadialGradient and QConicalGradient.\n\nSo if the brush style is Qt::LinearGradientPattern, we first create a QLinearGradient object with interpolation area between the coordinates passed as arguments to the constructor. The positions are specified using logical coordinates. Then we set the gradient's colors using the QGradient::setColorAt() function. The colors is defined using stop points which are composed by a position (between 0 and 1) and a QColor. The set of stop points describes how the gradient area should be filled. A gradient can have an arbitrary number of stop points.\n\nIn the end we call slot to update the widget's brush with the QLinearGradient object.\n\nA similar pattern of actions, as the one used for QLinearGradient, is used in the cases of Qt::RadialGradientPattern and Qt::ConicalGradientPattern.\n\nThe only difference is the arguments passed to the constructor: Regarding the QRadialGradient constructor the first argument is the center, and the second the radial gradient's radius. The third argument is optional, but can be used to define the focal point of the gradient inside the circle (the default focal point is the circle center). Regarding the QConicalGradient constructor, the first argument specifies the center of the conical, and the second specifies the start angle of the interpolation.\n\nIf the brush style is Qt::TexturePattern we create a QBrush from a QPixmap. Then we call slot to update the widget with the newly created brush.\n\nOtherwise we simply create a brush with the given style and a green color, and then call slot to update the widget with the newly created brush.\n\nThe class inherits QWidget, and renders multiple copies of the currently active shape using a QPainter.\n\nFirst we define a public enum to hold the different shapes that can be rendered by the widget (i.e the shapes that can be rendered by a QPainter). Then we reimplement the constructor as well as two of QWidget's public functions: minimumSizeHint() and sizeHint().\n\nWe also reimplement the QWidget::paintEvent() function to be able to draw the currently active shape according to the specified parameters.\n\nWe declare several private slots: The slot changes the 's shape, the and slots modify the widget's pen and brush, and the and slots modify the widget's respective properties.\n\nIn the constructor we initialize some of the widget's variables.\n\nWe set its shape to be a Polygon, its antialiased property to be false and we load an image into the widget's pixmap variable. In the end we set the widget's background role, defining the brush from the widget's palette that will be used to render the background. QPalette::Base is typically white.\n\nThe inherits QWidget's sizeHint property holding the recommended size for the widget. If the value of this property is an invalid size, no size is recommended.\n\nThe default implementation of the QWidget::sizeHint() function returns an invalid size if there is no layout for the widget, and returns the layout's preferred size otherwise.\n\nOur reimplementation of the function returns a QSize with a 400 pixels width and a 200 pixels height.\n\nalso inherits QWidget's minimumSizeHint property holding the recommended minimum size for the widget. Again, if the value of this property is an invalid size, no size is recommended.\n\nThe default implementation of QWidget::minimumSizeHint() returns an invalid size if there is no layout for the widget, and returns the layout's minimum size otherwise.\n\nOur reimplementation of the function returns a QSize with a 100 pixels width and a 100 pixels height.\n\nThe public , and slots are called whenever we want to modify a widget's shape, pen or brush. We set the shape, pen or brush according to the slot parameter, and call QWidget::update() to make the changes visible in the widget.\n\nThe QWidget::update() slot does not cause an immediate repaint; instead it schedules a paint event for processing when Qt returns to the main event loop.\n\nWith the and slots we change the state of the properties according to the slot parameter, and call the QWidget::update() slot to make the changes visible in the widget.\n\nThen we reimplement the QWidget::paintEvent() function. The first thing we do is to create the graphical objects we will need to draw the various shapes.\n\nWe create a vector of four QPoints. We use this vector to render the Points, Polyline and Polygon shapes. Then we create a QRect, defining a rectangle in the plane, which we use as the bounding rectangle for all the shapes excluding the Path and the Pixmap.\n\nWe also create a QPainterPath. The QPainterPath class provides a container for painting operations, enabling graphical shapes to be constructed and reused. A painter path is an object composed of a number of graphical building blocks, such as rectangles, ellipses, lines, and curves. For more information about the QPainterPath class, see the Painter Paths example. In this example, we create a painter path composed of one straight line and a Bezier curve.\n\nIn addition we define a start angle and an arc length that we will use when drawing the Arc, Chord and Pie shapes.\n\nWe create a QPainter for the widget, and set the painters pen and brush according to the 's pen and brush. If the Antialiasing parameter option is checked, we also set the painter's render hints. QPainter::Antialiasing indicates that the engine should antialias edges of primitives if possible.\n\nFinally, we render the multiple copies of the 's shape. The number of copies is depending on the size of the widget, and we calculate their positions using two loops and the widgets height and width.\n\nFor each copy we first save the current painter state (pushes the state onto a stack). Then we translate the coordinate system, using the QPainter::translate() function, to the position determined by the variables of the loops. If we omit this translation of the coordinate system all the copies of the shape will be rendered on top of each other in the top left cormer of the widget.\n\nIf the Transformations parameter option is checked, we do an additional translation of the coordinate system before we rotate the coordinate system 60 degrees clockwise using the QPainter::rotate() function and scale it down in size using the QPainter::scale() function. In the end we translate the coordinate system back to where it was before we rotated and scaled it.\n\nNow, when rendering the shape, it will appear as if it was rotated in three dimensions.\n\nNext, we identify the 's shape, and render it using the associated QPainter drawing function:\n\nBefore we started rendering, we saved the current painter state (pushes the state onto a stack). The rationale for this is that we calculate each shape copy's position relative to the same point in the coordinate system. When translating the coordinate system, we lose the knowledge of this point unless we save the current painter state before we start the translating process.\n\nThen, when we are finished rendering a copy of the shape we can restore the original painter state, with its associated coordinate system, using the QPainter::restore() function. In this way we ensure that the next shape copy will be rendered in the correct position.\n\nWe could translate the coordinate system back using QPainter::translate() instead of saving the painter state. But since we in addition to translating the coordinate system (when the Transformation parameter option is checked) both rotate and scale the coordinate system, the easiest solution is to save the current painter state."
    },
    {
        "link": "https://stackoverflow.com/questions/3670590/painting-inside-widget-in-qt",
        "document": "I created a very simple GUI that has a push button and a \"Graphics View\" widget from Display Widgets. On pushing the button I want a line to be drawn across the \"Graphics View\" widget. I have changed the name of the \"Graphics View\" widget to gv by right-clicking the widget in design view and then selecting change objectName. I am not able to understand how should the line be drawn. I read various texts on Qt that provided information about QPainter, PaintEvent etc. But I got more confused.\n\nKindly help me with this. A small sample code shall be really helpful for me as I am new to Qt."
    },
    {
        "link": "https://forum.qt.io/topic/36694/painting-widget-with-qpainter",
        "document": "\n• I'm trying to paint a Widget in my custom Delegate, basically I just want to show a widget inside a cell of a tableView. I found multiple way to do that, but it's not working as I want. \n\n Use the .render method of QWidget to render it\n\n Problem : Nothing is painted (see \"screenshot\":https://www.dropbox.com/s/qeiisgzw7e5t1m1/solution0_render.png)\n\n @\n\n EditTargetPowerWidget *widgetTarget = new EditTargetPowerWidget();\n\n widgetTarget->targetStart->setText(\"Test\");\n\n widgetTarget->render(painter, option.rect.center(), option.rect, QWidget::DrawChildren );\n\n @ \n\n Convert the QWidget to a pixmap and then paint the pixmap with the painter\n\n problem : Color and background all messed up (see \"screenshot\":https://www.dropbox.com/s/mr92gcibngvir6x/solution2_pixmap.png) \n\n Try to replicate the Widget and draw the stuff manually using drawText\n\n Problem : Ok to display one line of data, but I don't know how to replicate my GridLayout in here. (see \"screenshot\":https://www.dropbox.com/s/3m8eh5sc174iyxd/solution3_drawText.png) int targetStepPower = interval->getPowerStepType(); qDebug() << \"TARGET STEP!\" << targetStepPower; QString str_Step = Interval::getStepTypeFromInt( targetStepPower ); double startFTP = interval->getFTP_start() * 100; double endFTP = interval->getFTP_end() * 100; int range = interval->getFTP_range(); painter->drawText(option.rect, Qt::AlignLeft | Qt::AlignVCenter, str_Step); //Draw all other data also.. with good layout?@ If someone has figured how to use the render() method of QWidget, or fix the QPixmap display problem, I think it would be a better solution than using drawText... thank you!\n• ad :\n\n make sure that your painter has not been translated and paints to the correct location on the viewport. \"option.rect.center()\" doesn't seem correct here...\n\n Please post the whole painting code of your delegate. --- SUPPORT REQUESTS VIA CHAT WILL BE IGNORED ---\n\n If you have a question please use the forum so others can benefit from the solution in the future\n• I think the solution 3 could be used with some \"tricks\", in order to have texts arranged in \"subcells\" in a \"cell\" ... what is a \"cell\"?: it is thought as successive standard(qt) table items in a row so take any successive items in a table row, in the amount of your grid layout columns and then controls the drawText as follow:\n• for drawing text in a certain column(subcell) with index.column()\n• for drawing text in certain subcell's row with new line character \"\n\n\"\n\n i.e.\n\n @ painter->drawText(option.rect.adjusted(4,4,0,0),QString(\"\n\n\")+your text@ I used this and it worked, and for changing text font or color by QSS I used dummy/hidden widgets styled externally and using their values in delegate's painter\n• For the render method of QWidget, I don't really understand the arguments that I need to pass. Usually I use painter and option.rect (where to display) in order to paint, so i'm kind of lost with those 4 parameters Here is the full paint method of my delegate:\n\n @//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n void SpinBoxDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const { if (option.state & QStyle::State_Selected) { painter->setPen(QPen( Qt::red, 5 )); painter->drawRect(option.rect); return; } painter->setPen(QPen( Qt::white, 1 )); /// Type if (index.column() == 0) { int value = index.model()->data(index, Qt::DisplayRole).toInt(); QString intervalType = Interval::getTypeFromInt(value); painter->drawText(option.rect, Qt::AlignLeft | Qt::AlignVCenter, intervalType); } /// Duration else if (index.column() == 1) { QTime time = index.model()->data(index, Qt::DisplayRole).toTime(); QString toDisplay = Util::showQTimeAsString(time); painter->drawText(option.rect, Qt::AlignLeft | Qt::AlignVCenter, toDisplay ); } /// Display Message else if (index.column() == 2) { QString msg = index.model()->data(index, Qt::DisplayRole).toString(); painter->drawText(option.rect, Qt::AlignLeft | Qt::AlignVCenter, msg); } /// Target Power else if (index.column() == 3) { //// SOLUTION 1, NOTHING IS DRAW EditTargetPowerWidget *widgetTarget = new EditTargetPowerWidget(); widgetTarget->targetStart->setText(\"Test\"); widgetTarget->render(painter, QPoint(), option.rect, QWidget::DrawChildren ); /// SOLUTION 2 - NOT GOOD LOOKING (Color messed up) // EditTargetPowerWidget *widgetTarget = new EditTargetPowerWidget(); // QPixmap pix = QPixmap::grabWidget(widgetTarget); // painter->drawPixmap(option.rect, pix); /// SOLUTION 3, DRAW IT BY HAND - WORKS BUT HARD TO REPLICATE WIDGET WITH TEXT // std::shared_ptr<Interval> interval(qvariant_cast<std::shared_ptr<Interval>>( index.model()->data(index, Qt::DisplayRole) )); // int targetStepPower = interval->getPowerStepType(); // qDebug() << \"TARGET STEP!\" << targetStepPower; // QString str_Step = Interval::getStepTypeFromInt( targetStepPower ); // double startFTP = interval->getFTP_start() * 100; // double endFTP = interval->getFTP_end() * 100; // int range = interval->getFTP_range(); // painter->drawText(option.rect, Qt::AlignLeft | Qt::AlignVCenter, str_Step); } /// Standard delegate display - Display Message else { QStyleOptionViewItem viewOption(option); viewOption.palette.setColor(QPalette::Text, QColor(Qt::white)); QStyledItemDelegate::paint(painter, viewOption, index); } I will try to fix #1 and then use #3 as last resort.\n\n Thanks!\n• And another suggestion:\n\n Don't create a new widget on every time your paint() method is called. No need to allocate new memory every time, beside you never delete this widget, thus it leaks.\n\n Rather hold a single instance in your delegate class and reuse it when needed. --- SUPPORT REQUESTS VIA CHAT WILL BE IGNORED ---\n\n If you have a question please use the forum so others can benefit from the solution in the future\n• The display is working fine now, but my delegate has a memory leak in the paint function now. I have noted that it is in the column that I used QWidget.render(). So in the code below, if I comment column 3,4 and 5, I don't have a memory leak.\n\n Sorry I know I asked a lot of question already, hopefully I can give back to Qt.. Do you think that the line\n\n \"widgetTarget->render(painter, QPoint(), QRegion(), QWidget::DrawChildren );\"\n\n could trigger an infinite loop? I'm failing to see where all that memory goes.. I should probably learn to use the debugger also -_- qDebug() << \"paintNow...\"; if (option.state & QStyle::State_Selected) { painter->setPen(QPen( Qt::red, 5 )); painter->drawRect(option.rect); return; } painter->setPen(QPen( Qt::white, 1 )); /// Type if (index.column() == 0) { int value = index.model()->data(index, Qt::DisplayRole).toInt(); QString intervalType = Interval::getTypeFromInt(value); painter->drawText(option.rect, Qt::AlignLeft | Qt::AlignVCenter, intervalType); } /// Duration else if (index.column() == 1) { QTime time = index.model()->data(index, Qt::DisplayRole).toTime(); QString toDisplay = Util::showQTimeAsString(time); painter->drawText(option.rect, Qt::AlignLeft | Qt::AlignVCenter, toDisplay ); } /// Display Message else if (index.column() == 2) { QString msg = index.model()->data(index, Qt::DisplayRole).toString(); painter->drawText(option.rect, Qt::AlignLeft | Qt::AlignVCenter, msg); } /// Target Power else if (index.column() == 3) { EditTargetPowerWidget *widgetTarget = new EditTargetPowerWidget(ptrParent, \"POWER\"); std::shared_ptr<Interval> interval(qvariant_cast<std::shared_ptr<Interval>>( index.model()->data(index, Qt::DisplayRole) )); int targetStepPower = interval->getPowerStepType(); double startFTP = interval->getFTP_start() * 100; double endFTP = interval->getFTP_end() * 100; int range = interval->getFTP_range(); widgetTarget->stepComboBox->setCurrentIndex(targetStepPower); widgetTarget->targetStartValue->setValue(startFTP); widgetTarget->targetEndValue->setValue(endFTP); widgetTarget->targetRangeValue->setValue(range); painter->save(); widgetTarget->resize( option.rect.size() ); painter->translate(option.rect.topLeft()); widgetTarget->render(painter, QPoint(), QRegion(), QWidget::DrawChildren ); painter->restore(); } /// Target Cadence else if (index.column() == 4) { EditTargetPowerWidget *widgetTarget = new EditTargetPowerWidget(ptrParent, \"CADENCE\"); std::shared_ptr<Interval> interval(qvariant_cast<std::shared_ptr<Interval>>( index.model()->data(index, Qt::DisplayRole) )); int targetStepCadence = interval->getCadenceStepType(); int startCadence = interval->getCadence_start(); int endCadence = interval->getCadence_end(); int range = interval->getCadence_range(); widgetTarget->stepComboBox->setCurrentIndex(targetStepCadence); widgetTarget->targetStartValue->setValue(startCadence); widgetTarget->targetEndValue->setValue(endCadence); widgetTarget->targetRangeValue->setValue(range); painter->save(); widgetTarget->resize( option.rect.size() ); painter->translate(option.rect.topLeft()); widgetTarget->render(painter, QPoint(), QRegion(), QWidget::DrawChildren ); painter->restore(); } /// Target Cadence else if (index.column() == 5) { EditTargetPowerWidget *widgetTarget = new EditTargetPowerWidget(ptrParent, \"HR\"); std::shared_ptr<Interval> interval(qvariant_cast<std::shared_ptr<Interval>>( index.model()->data(index, Qt::DisplayRole) )); int targetStepHR = interval->getHRStepType(); double startHR = interval->getHR_start() *100; double endHR = interval->getHR_end() *100; int range = interval->getHR_range(); widgetTarget->stepComboBox->setCurrentIndex(targetStepHR); widgetTarget->targetStartValue->setValue(startHR); widgetTarget->targetEndValue->setValue(endHR); widgetTarget->targetRangeValue->setValue(range); painter->save(); widgetTarget->resize( option.rect.size() ); painter->translate(option.rect.topLeft()); widgetTarget->render(painter, QPoint(), QRegion(), QWidget::DrawChildren ); painter->restore(); } /// Standard delegate display - Display Message else { QStyleOptionViewItem viewOption(option); viewOption.palette.setColor(QPalette::Text, QColor(Qt::white)); QStyledItemDelegate::paint(painter, viewOption, index); }\n• I modified my code to improve memory and find where is the problem. I think it is a memory leak with the createEditor() that doesn't get deleted after each use. I would like to know if there is an example of this technique\n\n \"source\":http://qt-project.org/doc/qt-5.0/qtwidgets/itemviews-spinboxdelegate.html\n\n Furthermore it is also possible to reuse (and avoid deleting) the editor widget by reimplementing the destroyEditor() function I tried but the createEditor and setEditorData are \"const\" function and I can't store any pointer there..\n\n [EDIT: I removed the const in createEditor but now the function is now longer called, I wanted to create all my editor in the Constructor and reuse the same.. this technique doesn't work -_-] I changed the way I change my model using a pointer in Qvariant rather than passing the whole object in a Qvariant, it helps but the memory used is still too high, /// Type if (index.column() == 0) { IntervalComboBox *comboBox = static_cast<IntervalComboBox*>(editor); int value = comboBox->currentIndex(); model->setData(index, value, Qt::EditRole); } /// Duration else if (index.column() == 1) { QTimeEdit *timeEdit = static_cast<QTimeEdit*>(editor); QTime time1 = timeEdit->time(); model->setData(index, time1, Qt::EditRole); } /// Display Message else if (index.column() == 2) { QLineEdit *lineEdit = static_cast<QLineEdit*>(editor); QString msg = lineEdit->text(); model->setData(index, msg, Qt::EditRole); } /// Target Power else if (index.column() == 3) { EditTargetPowerWidget *targetWidget = static_cast<EditTargetPowerWidget*>(editor); int targetStepPower = targetWidget->stepComboBox->currentIndex(); Interval::StepType stepType = static_cast<Interval::StepType>( targetStepPower ); double startFTP = targetWidget->targetStartValue->value()/100; double endFTP = targetWidget->targetEndValue->value()/100; int range = targetWidget->targetRangeValue->value(); Interval *interval = (Interval*) index.model()->data(index, Qt::DisplayRole).value<void *>(); interval->setPowerData(stepType, startFTP, endFTP, range); /// MEMORY STILL INCREASE BY 2MB EACH EDIT, pointer *targetWidget not deleted? /// Break model/view architecture here... /// model->setData(index, variant, Qt::EditRole); }"
    },
    {
        "link": "https://stackoverflow.com/questions/45903916/use-custom-qpainter-to-render-qwidget",
        "document": "What I ended up doing and is working fine:\n\nI'm using a custom top level widget without additional functionality to make mouse and keyboard handling easier.\n\n This widget doesn't have a parent and is rendered - with its children - into memory using a QImage and overlaid as an image. This way the transparency works. Important here is the WA_NoSystemBackground attribute.\n\n To make the events work, I've installed an event filter on the application and pass on the events to the widgets in my custom widgets. I'll spare you the details, I'm planning on making the code public later this year anyway and I'll add a link once that's done.\n\nHowever, two important notes when passing the events:\n\n First, to prevent an endless recursive loop because your filter will also catch the events you are sending, I've checked whether the receiving object is a widget and if it is, I simply checked if the topLevelWidget of this widget is an instance of my custom widget class and if it is, the event is ignored.\n\n Second, simply passing mouse events doesn't make mouse over work. There are separate hover events which you have to take care of yourself."
    },
    {
        "link": "https://felgo.com/doc/qt/qtwidgets-painting-basicdrawing-example",
        "document": "The Basic Drawing example shows how to display basic graphics primitives in a variety of styles using the QPainter class.\n\nQPainter performs low-level painting on widgets and other paint devices. The class can draw everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps. Normally, it draws in a \"natural\" coordinate system, but it can in addition do view and world transformation.\n\nThe example provides a render area, displaying the currently active shape, and lets the user manipulate the rendered shape and its appearance using the QPainter parameters: The user can change the active shape (Shape), and modify the QPainter's pen (Pen Width, Pen Style, Pen Cap, Pen Join), brush (Brush Style) and render hints (Antialiasing). In addition the user can rotate a shape (Transformations); behind the scenes we use QPainter's ability to manipulate the coordinate system to perform the rotation.\n\nThe Basic Drawing example consists of two classes:\n• is a custom widget that renders multiple copies of the currently active shape.\n• is the application's main window displaying a widget in addition to several parameter widgets.\n\nFirst we will review the class, then we will take a look at the class.\n\nThe Window class inherits QWidget, and is the application's main window displaying a widget in addition to several parameter widgets.\n\nWe declare the various widgets, and three private slots updating the widget: The slot updates the widget when the user changes the currently active shape. We call the slot when either of the QPainter's pen parameters changes. And the slot updates the widget when the user changes the painter's brush style.\n\nIn the constructor we create and initialize the various widgets appearing in the main application window.\n\nFirst we create the widget that will render the currently active shape. Then we create the Shape combobox, and add the associated items (i.e. the different shapes a QPainter can draw).\n\nQPainter's pen is a QPen object; the QPen class defines how a painter should draw lines and outlines of shapes. A pen has several properties: Width, style, cap and join.\n\nA pen's width can be zero or greater, but the most common width is zero. Note that this doesn't mean 0 pixels, but implies that the shape is drawn as smoothly as possible although perhaps not mathematically correct.\n\nWe create a QSpinBox for the Pen Width parameter.\n\nThe pen style defines the line type. The default style is solid (Qt::SolidLine). Setting the style to none (Qt::NoPen) tells the painter to not draw lines or outlines. The pen cap defines how the end points of lines are drawn. And the pen join defines how two lines join when multiple connected lines are drawn. The cap and join only apply to lines with a width of 1 pixel or greater.\n\nWe create QComboBoxes for each of the Pen Style, Pen Cap and Pen Join parameters, and adds the associated items (i.e the values of the Qt::PenStyle, Qt::PenCapStyle and Qt::PenJoinStyle enums respectively).\n\nThe QBrush class defines the fill pattern of shapes drawn by a QPainter. The default brush style is Qt::NoBrush. This style tells the painter to not fill shapes. The standard style for filling is Qt::SolidPattern.\n\nWe create a QComboBox for the Brush Style parameter, and add the associated items (i.e. the values of the Qt::BrushStyle enum).\n\nAntialiasing is a feature that \"smoothes\" the pixels to create more even and less jagged lines, and can be applied using QPainter's render hints. QPainter::RenderHints are used to specify flags to QPainter that may or may not be respected by any given engine.\n\nWe simply create a QCheckBox for the Antialiasing option.\n\nThe Transformations option implies a manipulation of the coordinate system that will appear as if the rendered shape is rotated in three dimensions.\n\nWe use the QPainter::translate(), QPainter::rotate() and QPainter::scale() functions to implement this feature represented in the main application window by a simple QCheckBox.\n\nThen we connect the parameter widgets with their associated slots using the static QObject::connect() function, ensuring that the widget is updated whenever the user changes the shape, or any of the other parameters.\n\nFinally, we add the various widgets to a layout, and call the , , and slots to initialize the application. We also turn on antialiasing.\n\nThe slot is called whenever the user changes the currently active shape.\n\nFirst we retrieve the shape the user has chosen using the QComboBox::itemData() function. This function returns the data for the given role in the given index in the combobox. We use QComboBox::currentIndex() to retrieve the index of the shape, and the role is defined by the Qt::ItemDataRole enum; is an alias for Qt::UserRole.\n\nNote that Qt::UserRole is only the first role that can be used for application-specific purposes. If you need to store different data in the same index, you can use different roles by simply incrementing the value of Qt::UserRole, for example: 'Qt::UserRole + 1' and 'Qt::UserRole + 2'. However, it is a good programming practice to give each role their own name: 'myFirstRole = Qt::UserRole + 1' and 'mySecondRole = Qt::UserRole + 2'. Even though we only need a single role in this particular example, we add the following line of code to the beginning of the file.\n\nThe QComboBox::itemData() function returns the data as a QVariant, so we need to cast the data to . If there is no data for the given role, the function returns QVariant::Invalid.\n\nIn the end we call the slot to update the widget.\n\nWe call the slot whenever the user changes any of the pen parameters. Again we use the QComboBox::itemData() function to retrieve the parameters, and then we call the slot to update the widget.\n\nThe brushChanged() slot is called whenever the user changes the brush parameter which we retrieve using the QComboBox::itemData() function as before.\n\nIf the brush parameter is a gradient fill, special actions are required.\n\nThe QGradient class is used in combination with QBrush to specify gradient fills. Qt currently supports three types of gradient fills: linear, radial and conical. Each of these is represented by a subclass of QGradient: QLinearGradient, QRadialGradient and QConicalGradient.\n\nSo if the brush style is Qt::LinearGradientPattern, we first create a QLinearGradient object with interpolation area between the coordinates passed as arguments to the constructor. The positions are specified using logical coordinates. Then we set the gradient's colors using the QGradient::setColorAt() function. The colors is defined using stop points which are composed by a position (between 0 and 1) and a QColor. The set of stop points describes how the gradient area should be filled. A gradient can have an arbitrary number of stop points.\n\nIn the end we call slot to update the widget's brush with the QLinearGradient object.\n\nA similar pattern of actions, as the one used for QLinearGradient, is used in the cases of Qt::RadialGradientPattern and Qt::ConicalGradientPattern.\n\nThe only difference is the arguments passed to the constructor: Regarding the QRadialGradient constructor the first argument is the center, and the second the radial gradient's radius. The third argument is optional, but can be used to define the focal point of the gradient inside the circle (the default focal point is the circle center). Regarding the QConicalGradient constructor, the first argument specifies the center of the conical, and the second specifies the start angle of the interpolation.\n\nIf the brush style is Qt::TexturePattern we create a QBrush from a QPixmap. Then we call slot to update the widget with the newly created brush.\n\nOtherwise we simply create a brush with the given style and a green color, and then call slot to update the widget with the newly created brush.\n\nThe class inherits QWidget, and renders multiple copies of the currently active shape using a QPainter.\n\nFirst we define a public enum to hold the different shapes that can be rendered by the widget (i.e the shapes that can be rendered by a QPainter). Then we reimplement the constructor as well as two of QWidget's public functions: minimumSizeHint() and sizeHint().\n\nWe also reimplement the QWidget::paintEvent() function to be able to draw the currently active shape according to the specified parameters.\n\nWe declare several private slots: The slot changes the 's shape, the and slots modify the widget's pen and brush, and the and slots modify the widget's respective properties.\n\nIn the constructor we initialize some of the widget's variables.\n\nWe set its shape to be a Polygon, its antialiased property to be false and we load an image into the widget's pixmap variable. In the end we set the widget's background role, defining the brush from the widget's palette that will be used to render the background. QPalette::Base is typically white.\n\nThe inherits QWidget's sizeHint property holding the recommended size for the widget. If the value of this property is an invalid size, no size is recommended.\n\nThe default implementation of the QWidget::sizeHint() function returns an invalid size if there is no layout for the widget, and returns the layout's preferred size otherwise.\n\nOur reimplementation of the function returns a QSize with a 400 pixels width and a 200 pixels height.\n\nalso inherits QWidget's minimumSizeHint property holding the recommended minimum size for the widget. Again, if the value of this property is an invalid size, no size is recommended.\n\nThe default implementation of QWidget::minimumSizeHint() returns an invalid size if there is no layout for the widget, and returns the layout's minimum size otherwise.\n\nOur reimplementation of the function returns a QSize with a 100 pixels width and a 100 pixels height.\n\nThe public , and slots are called whenever we want to modify a widget's shape, pen or brush. We set the shape, pen or brush according to the slot parameter, and call QWidget::update() to make the changes visible in the widget.\n\nThe QWidget::update() slot does not cause an immediate repaint; instead it schedules a paint event for processing when Qt returns to the main event loop.\n\nWith the and slots we change the state of the properties according to the slot parameter, and call the QWidget::update() slot to make the changes visible in the widget.\n\nThen we reimplement the QWidget::paintEvent() function. The first thing we do is to create the graphical objects we will need to draw the various shapes.\n\nWe create a vector of four QPoints. We use this vector to render the Points, Polyline and Polygon shapes. Then we create a QRect, defining a rectangle in the plane, which we use as the bounding rectangle for all the shapes excluding the Path and the Pixmap.\n\nWe also create a QPainterPath. The QPainterPath class provides a container for painting operations, enabling graphical shapes to be constructed and reused. A painter path is an object composed of a number of graphical building blocks, such as rectangles, ellipses, lines, and curves. For more information about the QPainterPath class, see the Painter Paths example. In this example, we create a painter path composed of one straight line and a Bezier curve.\n\nIn addition we define a start angle and an arc length that we will use when drawing the Arc, Chord and Pie shapes.\n\nWe create a QPainter for the widget, and set the painters pen and brush according to the 's pen and brush. If the Antialiasing parameter option is checked, we also set the painter's render hints. QPainter::Antialiasing indicates that the engine should antialias edges of primitives if possible.\n\nFinally, we render the multiple copies of the 's shape. The number of copies is depending on the size of the widget, and we calculate their positions using two loops and the widgets height and width.\n\nFor each copy we first save the current painter state (pushes the state onto a stack). Then we translate the coordinate system, using the QPainter::translate() function, to the position determined by the variables of the loops. If we omit this translation of the coordinate system all the copies of the shape will be rendered on top of each other in the top left cormer of the widget.\n\nIf the Transformations parameter option is checked, we do an additional translation of the coordinate system before we rotate the coordinate system 60 degrees clockwise using the QPainter::rotate() function and scale it down in size using the QPainter::scale() function. In the end we translate the coordinate system back to where it was before we rotated and scaled it.\n\nNow, when rendering the shape, it will appear as if it was rotated in three dimensions.\n\nNext, we identify the 's shape, and render it using the associated QPainter drawing function:\n\nBefore we started rendering, we saved the current painter state (pushes the state onto a stack). The rationale for this is that we calculate each shape copy's position relative to the same point in the coordinate system. When translating the coordinate system, we lose the knowledge of this point unless we save the current painter state before we start the translating process.\n\nThen, when we are finished rendering a copy of the shape we can restore the original painter state, with its associated coordinate system, using the QPainter::restore() function. In this way we ensure that the next shape copy will be rendered in the correct position.\n\nWe could translate the coordinate system back using QPainter::translate() instead of saving the painter state. But since we in addition to translating the coordinate system (when the Transformation parameter option is checked) both rotate and scale the coordinate system, the easiest solution is to save the current painter state."
    }
]