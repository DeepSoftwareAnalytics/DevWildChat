[
    {
        "link": "https://stackoverflow.com/questions/43713602/how-to-determine-pattern-of-cards-in-3-card-game-to-find-winner",
        "document": "I have created N Three card hands using random sampling from a deck of 52 cards. Now, I want to find winner among the N hands.\n\nThese are the rules to find winner.\n• Double Run (Three Cards with values in a sequence and of same suit)\n• Same(two out of three cards have same values)\n\nThe winning priority of Cards is in descending order and probability of getting these cards is in ascending order.\n\nProbability of getting trial is least and winning priority is most and so on.\n\nI have checked in sequence of trial to normal.\n\nIs this the best way ?\n\nI have two options What is the best way to find winning hand among these two ?\n• least to most probability(check from Trial to normal)\n• most to least probability(check from normal to trial)"
    },
    {
        "link": "https://medium.com/@raaflahar/python-project-card-game-war-55733cfb1ab0",
        "document": "Actually, I make simulation of this game using Python. For this project, I implemented Object Oriented Programming (OOP) to divided all of the event happened on the game. But, to be fair game, I will import Python’s library named random, to create random state to both player.\n\nThen, I divided event that will happen on the game to three classes, Card, Deck, and Player. Each of classes have logic and method that define what the program will do. For the better understanding, let’s check what I mean.\n\nThe card class is the first class I will create. This class includes the value of the cards, the suits of the cards, and the rank of the cards. So, this class will have objectives that include:\n• First, this class should be understand what suits of the Card, like Heart, Spade, Diamond, and Clover. Actually, you could skip defining this part, because “War” game didn’t count suits to play. But, let’s just make the complete definition of playing cards.\n• Second, this class should be understand rank of the card, could be Ace, King, Queen, Jack, etc.\n• Lastly, this class must be able to determine what is the integer value of the card.\n\nThis class is used to store all existing cards. All cards saved will be called up in the deck and used in the game. To do that, I have to give the value for the rank, suit, and the value of the rank in the form of an integer value.\n\nI will define those values in the form of global variables. Which means, I will place this variables before any of classes I use. This variables will very important later in the Deck section. But, from now on, let’s just create it.\n\nThe variables I need was done. Now, I will create class named “Card”. This class will know what is the rank of cards, the suits of cards, and the integer values of cards.\n\nSo, the __init__ method for Card Class is define to have object that pass into the method itself, that is suit and rank of card.\n\nThe value of the cards, define inside __init__ that gives values of the card with integer data type. Besides that, there is __str__ method, notes that __str__ values will return rank and suit of the card as string object, like code above.\n\nNext, I will create class named “Deck”. This class main function is store all of card from playing cards. The cards that stored must be exactly one card from each suits and ranks. The playing cards will be stored using append method from Python.\n\nThe other function of this class is to shuffle the actual deck. Shuffling the deck will make condition of the card in random state, so it will be more or less fair for each player. To do that, I’ll import library from Python called random and using one of function inside the library, that is shuffle().\n\nLast function of this class is to draw one card from each deck. This is the crucial function to make sure the game running properly. To execute this event, I will be using pop method from Python’s list function.\n\nSo, there will be three method inside this class and here’s code for the deck class I created:\n\nNotes that to create exactly one card each, I use double for loops to call all object from variables I created above that is suits and ranks, and I create card by calling Card class and store it into my all_cards list.\n\nThe last thing I need to do is make player class. This player class objective is to do some abstraction about the deck in your hand. Typically, if I had to draw a card, I need to draw from the top of the deck. Otherwise, if I win a card from my opponent I will add it via bottom of the deck.\n\nPython do have logic we needed to draw and add a card. We could use Python’s list to do that. So, if we indexing Python’s list we could know position of data inside of the list.\n\nThe most left data is position number 0, the counting goes on and on until the right most data is counted. But, to make it simple Python do have some sort of capability to count backwards so if I need the right most data inside the list actually I could say that the right most data is position number -1.\n\nThis concept could be applied into imagining actual deck. To make it clear, you could say that the top of the deck is the first data I could unpack, so which means that the top of the deck is data with position number 0. On the other hand, the bottom of the deck is the last data I have, so it must be position number -1 (If I counting backwardly).\n\nSo, my code for the Player should be containing about:\n• Drawing a card, from top of the deck.\n• Adding card I won, to the bottom of the deck.\n\nThe code I used should looks like below:\n\nYou may notice that I do different approach to add new cards into the deck which I do to avoid error. The reason is the object I add into the deck. If it’s multiple cards that I win in the Battle, so I could assume this object is a List object, because I shouldn’t add it one by one. Otherwise, it will make program slower. The other reason is if it’s a List object, so definitely I cannot used append, because it will make new_cards nested. So, I used extend instead."
    },
    {
        "link": "https://stackoverflow.com/questions/57842421/oop-python-card-game-class-methods",
        "document": "I have written a simple card game where upon initialising the game each player is given two cards.\n\nAt the bottom I have created a method called returnCards that puts the cards of a player back in the deck.\n\nI am new to OOP in python and am curious if it's good convention to create a standalone method like this?\n\nI feel as though this method should actually be a Player class method but I'm unsure how to write it as such. More than anything I'm trying to understand good practices when writing OOP code"
    },
    {
        "link": "https://reddit.com/r/Python/comments/77ik8r/card_game_to_predict_3_cards_for_a_player",
        "document": "Player_1 = input (\"What is your Name\") card = [] for a in range (0,3): card.append(random.randint(2, 14)) print(card) maxvalue = max(card) print(maxvalue) print (\"your max value is \", maxvalue)\n\nthis is the code that im trying to use. it works however i want to assign the values of jack, queen, king and ace to numbers 11, 12, 13 and 14 respectively. I understand that I need to add if and elif statements but have no idea where and how to add them to this code. Even when I add them, for some reason they are not recognised.\n\nThese are the statements I'm using: if card == 11: print (\"Jack\") elif card == 12: print (\"Queen\")\n\nThis is on Python 3.5"
    },
    {
        "link": "https://ziffur.com/article/code_along",
        "document": "In this article we will write a Python script to simulate a simple card game and collect some statistics about it. By doing this, we hope to provide an overview over some basic programming concepts (variables, data types, loops, and functions) and how they come together in Python to make a useful script.\n\nThe game we will be simulating is very simple. In Iceland it is known as \"Langavitleysa\", which translates to \"long nonsense\" (if you recognize the rules and know the game by another name, please shoot us an email using the address in the footer!).\n\nThe game is played by two players using a deck of 52 playing cards and proceeds in turns. Each player starts with half of the deck, face down. Each turn, both players draw the top card from their stack and present it. The player with the higher card takes both cards and places them at the bottom of their stack. This procedure is repeated until one player runs out of cards.\n\nSimple, right? There's only one special case: If both cards are of equal value (same number, suits don't matter), each player draws three more cards from the top of their stack and places them face-down on the table. Then they present the next card from the stack. Whoever draws the higher card takes all ten cards on the table and adds them to the bottom of their stack. If the cards are equal again, repeat this procedure until a winner is decided.\n\nSince we're going to be simulating a game, we will start by programming the game's logic. First, we'll create a list to hold our deck of cards.\n\nSince aces are high, we'll use the numbers 2–14 to represent the card values 2–10 followed by jack, queen, king, and ace. Since suits don't matter, we'll add each card four times to reach a total of 52.\n• First we initialize a variable named as an empty list.\n• We then create a loop through the numbers 0–12.\n• In every iteration of the loop, we add 2 to the current number and append the result to the end of the list before moving on to the next iteration. is a built-in function available to any list and adds the given item to the end of the list.\n\nWe now have a list of the numbers 2–14. In order to make a deck, we need to add these numbers 4 times to simulate the 4 suits:\n• We initialize the variable as an empty list.\n• We create a loop with 4 iterations, one for each suit (♠ ♥ ♦ ♣)\n• In each iteration, we create an inner loop to loop through all 13 cards again and append them to the deck one by one.\n\nWe now have a full deck of 52 cards. The code we used to get there works fine but it's a little more complicated than it needs to be. In order to produce the same deck of 52 cards, we could also write:\n\nHere, we use a list comprehension which is a shorthand syntax and allows us to populate a list using a for loop with very little extra code. In order to repeat the list of cards 4 times, Python allows us to \"multiply\" the list using the operator.\n\nNow that we have our deck, we'll need to shuffle the cards and then deal half to each player. Lucky for us, shuffling a list is easy using the library which should come included with your Python installation. We can include modules such as the library in our code by using the keyword:\n\nThis will randomly rearrange the order of the cards in the list we called . We can now proceed to deal the cards. Since the order is already random and each player gets half of the deck, we can simply split the list in the middle:\n\nThere's a few tricks hidden in there. Let's go through them one at a time:\n• The function takes a list and returns its length, so will return the number 52.\n• We divide the number 52 in half to get the index of the middle of the deck. An index is a term used to describe a position in a list and can be used to read the corresponding item. For example, will return the first item in .\n• We divide using the operator to make sure the result is an integer (a whole number). If the result would be a decimal, it is rounded down instead.\n• Similar to how selects the first item in a list, we can use to get a range of items. If we omit we get all items from the beginning to the index (non-inclusive). If we omit , we get everything from the index (inclusive) to the end of the list.\n\nNow we have two players, each represented by their stack of 26 cards. They can now start playing!\n\nThe game proceeds in turns, each turn having the following steps:\n• Each player draws the top card from their stack and presents it.\n• The player with the higher card takes both cards and adds them to their deck.\n• If the cards are equal, each player adds their next 3 cards to the pot and continues.\n\nLet's start with the main logic and leave out the tie for now. Remember that and are lists containing each player's card stack.\n\nSimilar to , the function is built-in and available to any list. It removes an item from a list and returns it. By default, it removes and returns the last item. By giving it the index 0 as a parameter, we can make it remove and return the first item instead. This simulates drawing a card from the stack.\n\nOnce the cards are drawn, we put them in a pot and compare them to determine which player wins the pot. We use statements to determine what happens in each case. After a winner is determined, we use the function to add each card in the pot to the end of the list, representing the bottom of that player's stack.\n\nExample: Player 1 draws an 11 (jack) while player 2 draws a 14 (ace). Player 2 wins the turn and puts both cards in the pot (11 and 14) on the bottom of their stack.\n\nThis code covers a basic round but doesn't do anything in case of a tie. In a tie, remember, each player adds the next 3 cards from the top of their stack to the pot before presenting a card again (which also joins the pot). To resolve this, we'll update our turn code like so:\n\nWe keep all the code for a standard turn but add an extra loop to cover the case of a tie. A loop is an excellent tool here for two reasons: First, in the case of one tie (or no tie), it works exactly like another statement. Second, if we encounter many ties in a row, the while loop will run as often as it needs to until the tie is resolved.\n\nInside the while loop, we do similar things to what we did before. Once a draw is encountered, we use a loop to simulate each player drawing 3 cards and adding them to the pot. Then we draw a new card for each player reassign the and variables. This allows the condition of the loop to be resolved (unless a second tie occurs, in which case the loop simply runs again).\n\nNow that we have the players set up and we've defined the logic necessary to play a turn, all we need to do is repeat turns until the game ends. To do this, we first create functions for the code we wrote above. This will make the rest of our logic much easier to build and work with:\n\nHaving created functions ( and ) for the functionality we already had, the rest of the script is easy to build. We no longer need to worry about the implementation details of the functions, all we need to know is their names, their parameters, and their return values:\n• We use the function to create a deck and deal cards to two players.\n• Using a loop, we simulate one turn at a time until the game ends due to a player running out of cards.\n• After the loop ends, we use statements to determine and announce the winner.\n\nNotice that the function returns two values, one for each player's stack of cards. We accomplish this using the syntax, which creates a tuple. Tuple is a built-in data type in Python we won't cover in detail since it's uncommon in other popular programming languages.\n\nWe can run this script from a terminal by using the command and providing the source file by name, like so:\n\nRunning the script a few times reveals two cases where it can fail:\n• The game continues forever, causing the terminal to hang and no output to be printed. We can stop the program by using to send a signal to the process.\n• While resolving a tie, one player runs out of cards. This causes the script to fail with the error message below.\n\nBoth of these errors happen because the rules of the game don't plan around them. If you play the game in real life, you probably won't run into these problems unless you play thousands of turns per second. Python has some methods built in which allow us to predict errors like these and create new logic to work around them. These methods are out of the scope of this series but we may cover them in future articles.\n\nIn this article, we combined lots of basic concepts from previous articles in the series to create a script for a real-world scenario. We learned how variables, data types, control flow, and functions come together to create complete scripts. Using these basic concepts, we can build very useful pieces of software.\n\nIf you're a total beginner, hopefully this series helps you gain some valuable insight into the world of programming. While there are many more things to learn for various software systems, understanding these basics and knowing how to apply them is the foundation to writing software in the real-world."
    },
    {
        "link": "https://geeksforgeeks.org/understanding-time-complexity-simple-examples",
        "document": "A lot of students get confused while understanding the concept of time complexity, but in this article, we will explain it with a very simple example.\n\nQ. Imagine a classroom of 100 students in which you gave your pen to one person. You have to find that pen without knowing to whom you gave it.\n\nHere are some ways to find the pen and what the O order is.\n• O(n2): You go and ask the first person in the class if he has the pen. Also, you ask this person about the other 99 people in the classroom if they have that pen and so on, \n\n This is what we call O(n\n• O(n): Going and asking each student individually is O(N).\n• O(log n): Now I divide the class into two groups, then ask: “Is it on the left side, or the right side of the classroom?” Then I take that group and divide it into two and ask again, and so on. Repeat the process till you are left with one student who has your pen. This is what you mean by O(log n).\n\nI might need to do:\n• O(n2) only one student knows on which student the pen is hidden\n• O(n) one student had the pen and only they knew it\n• O(log n) all the students knew , but would only tell me if I guessed the right side.\n\nNOTE: We are interested in the rate of growth over time with respect to the inputs taken during the program execution.\n\nIs the Time Complexity of an Algorithm/Code the same as the Running/Execution Time of Code?\n\nThe Time Complexity of an algorithm/code is not equal to the actual time required to execute a particular code, but the number of times a statement executes. We can prove this by using the time command.\n\nFor example: Write code in C/C++ or any other language to find the maximum between N numbers, where N varies from 10, 100, 1000, and 10000. For Linux based operating system (Fedora or Ubuntu), use the below commands:\n\nYou will get surprising results i.e.:\n• None For N = 10: you may get 0.5 ms time,\n• None For N = 10,000: you may get 0.2 ms time.\n• None Also, you will get different timings on different machines. Even if you will not get the same timings on the same machine for the same code, the reason behind that is the current network load.\n\nSo, we can say that the actual time required to execute code is machine-dependent (whether you are using Pentium 1 or Pentium 5) and also it considers network load if your machine is in LAN/WAN.\n\nWhat is meant by the Time Complexity of an Algorithm?\n\nNow, the question arises if time complexity is not the actual time required to execute the code, then what is it?\n\nExample 1: Consider the below simple code to print Hello World\n\nTime Complexity: In the above code “Hello World” is printed only once on the screen. \n\nSo, the time complexity is constant: O(1) i.e. every time a constant amount of time is required to execute code, no matter which operating system or which machine configurations you are using. \n\nAuxiliary Space: O(1)\n\nTime Complexity: In the above code “Hello World !!!” is printed only n times on the screen, as the value of n can change. \n\nSo, the time complexity is linear: O(n) i.e. every time, a linear amount of time is required to execute code.\n\nAuxiliary Space: O(1)\n\nHow To Find The Time Complexity Of An Algorithm?\n\nNow let us see some other examples and the process to find the time complexity of an algorithm:\n\nExample: Let us consider a model machine that has the following specifications:\n\nQ1. Find the Sum of 2 numbers on the above machine:\n\nFor any machine, the pseudocode to add two numbers will be something like this:\n• None The above code will take 2 units of time(constant):\n• None one for arithmetic operations and\n• None one for return. (as per the above conventions).\n\nQ2. Find the sum of all elements of a list/array\n\nThe pseudocode to do so can be given as:\n\n\n\nTo understand the time complexity of the above code, let’s see how much time each statement will take:\n\nTherefore the total cost to perform sum operation\n\nTherefore, the time complexity of the above code is O(n)\n\nQ3. Find the sum of all elements of a matrix\n\nFor this one, the complexity is a polynomial equation (quadratic equation for a square matrix)\n• None Since Tsum is in order of n Time Complexity = O(n2)\n\nTime Complexity: O(n*m)\n\nThe program iterates through all the elements in the 2D array using two nested loops. The outer loop iterates n times and the inner loop iterates m times for each iteration of the outer loop. Therefore, the time complexity of the program is O(n*m).\n\nAuxiliary Space: O(n*m)\n\nThe program uses a fixed amount of auxiliary space to store the 2D array and a few integer variables. The space required for the 2D array is nm integers. The program also uses a single integer variable to store the sum of the elements. Therefore, the auxiliary space complexity of the program is O(nm + 1), which simplifies to O(n*m).\n\nIn conclusion, the time complexity of the program is O(nm), and the auxiliary space complexity is also O(nm).\n\nTo compare algorithms, let us define a few objective measures:\n• Execution times: Not a good measure as execution times are specific to a particular computer.\n• The number of statements executed: Not a good measure, since the number of statements varies with the programming language as well as the style of the individual programmer.\n• Ideal solution: Let us assume that we express the running time of a given algorithm as a function of the input size n (i.e., f(n)) and compare these different functions corresponding to running times. This kind of comparison is independent of machine time, programming style, etc. \n\n Therefore, an ideal solution can be used to compare algorithms.\n• None Analysis of Algorithms | Set 2 (Worst, Average and Best Cases)"
    },
    {
        "link": "https://tau.edu.ng/assets/media/docs/algorithms-and-complexity-analysis-csc304_1716907183.pdf",
        "document": ""
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/287487/simple-and-clean-way-of-comparing-three-numbers",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://geeksforgeeks.org/complete-guide-on-complexity-analysis",
        "document": "What is the need for Complexity Analysis?\n• None Complexity Analysis determines the amount of time and space resources required to execute it.\n• None It is used for comparing different algorithms on different input sizes.\n• None Complexity helps to determine the difficulty of a problem.\n• None often measured by how much time and space (memory) it takes to solve a particular problem\n\nBig-O notation represents the upper bound of the running time of an algorithm. Therefore, it gives the worst-case complexity of an algorithm. By using big O- notation, we can asymptotically limit the expansion of a running time to a range of constant factors above and below. It is a model for quantifying algorithm performance. \n\n\n\nOmega notation represents the lower bound of the running time of an algorithm. Thus, it provides the best-case complexity of an algorithm.\n\nThe execution time serves as a lower bound on the algorithm’s time complexity. It is defined as the condition that allows an algorithm to complete statement execution in the shortest amount of time.\n\nTheta notation encloses the function from above and below. Since it represents the upper and the lower bound of the running time of an algorithm, it is used for analyzing the average-case complexity of an algorithm. The execution time serves as both a lower and upper bound on the algorithm’s time complexity. It exists as both, the most, and least boundaries for a given input value.\n\nBig-Ο is used as a tight upper bound on the growth of an algorithm’s effort (this effort is described by the function f(n)), even though, as written, it can also be a loose upper bound. “Little-ο” (ο()) notation is used to describe an upper bound that cannot be tight. \n\n\n\nLet f(n) and g(n) be functions that map positive integers to positive real numbers. We say that f(n) is ω(g(n)) (or f(n) ∈ ω(g(n))) if for any real constant c > 0, there exists an integer constant n0 ≥ 1 such that f(n) > c * g(n) ≥ 0 for every integer n ≥ n0.\n\nThe complexity of an algorithm can be measured in three ways:\n\nThe time complexity of an algorithm is defined as the amount of time taken by an algorithm to run as a function of the length of the input. Note that the time to run is a function of the length of the input and not the actual execution time of the machine on which the algorithm is running on\n\nTo estimate the time complexity, we need to consider the cost of each fundamental instruction and the number of times the instruction is executed.\n• None If we have statements with basic operations like comparisons, return statements, assignments, and reading a variable. We can assume they take constant time each O(1).\n\nThis is the result of calculating the overall time complexity.\n\nAssuming that n is the size of the input, let’s use T(n) to represent the overall time and t to represent the amount of time that a statement or collection of statements takes to execute.\n• None For any loop, we find out the runtime of the block inside them and multiply it by the number of times the program will repeat the loop.\n\nFor the above example, the loop will execute n times, and it will print “GeeksForGeeks” N number of times. so the time taken to run this program is:\n• None For 2D arrays, we would have nested loop concepts, which means a loop inside a loop.\n\nFor the above example, the cout statement will execute n*m times, and it will print “GeeksForGeeks” N*M number of times. so the time taken to run this program is:\n\nThe amount of memory required by the algorithm to solve a given problem is called the space complexity of the algorithm. Problem-solving using a computer requires memory to hold temporary data or final result while the program is in execution.\n\nThe space Complexity of an algorithm is the total space taken by the algorithm with respect to the input size. Space complexity includes both Auxiliary space and space used by input. \n\nSpace complexity is a parallel concept to time complexity. If we need to create an array of size n, this will require O(n) space. If we create a two-dimensional array of size n*n, this will require O(n2) space.\n\nHowever, just because you have n calls total doesn’t mean it takes O(n) space.\n\nLook at the below function :\n\nThe temporary space needed for the use of an algorithm is referred to as auxiliary space. Like temporary arrays, pointers, etc. \n\nIt is preferable to make use of Auxiliary Space when comparing things like sorting algorithms. \n\nfor example, sorting algorithms take O(n) space, as there is an input array to sort. but auxiliary space is O(1) in that case.\n\nHow does Complexity affect any algorithm?\n\nHow to optimize the time and space complexity of an Algorithm?\n\nOptimization means modifying the brute-force approach to a problem. It is done to derive the best possible solution to solve the problem so that it will take less time and space complexity. We can optimize a program by either limiting the search space at each step or occupying less search space from the start.\n\nWe can optimize a solution using both time and space optimization. To optimize a program,\n• reduce the time taken to run the program and increase the space occupied;\n• None we can reduce the memory usage of the program and increase its total run time, or\n• None we can reduce both time and space\n\nDifferent types of Complexity exist in the program:\n\nIf the function or method of the program takes negligible execution time. Then that will be considered as constant complexity.\n\nExample: The below program takes a constant amount of time.\n\nIt imposes a complexity of O(log(N)). It undergoes the execution of the order of log(N) steps. To perform operations on N elements, it often takes the logarithmic base as 2.\n\nExample: The below program takes logarithmic complexity.\n\n// location of x in given array arr[l..r] is present, // If the element is present at the middle // If element is smaller than mid, then // it can only be present in left subarray // Else the element can only be present // We reach here when element is not \"Element is not present in array\" // the index of x in the given array arr[l..r] if present, // If the element is present at the middle itself // If element is smaller than mid, then // it can only be present in the left subarray // Else the element can only be present // We reach here when the element is not present in the array \"Element is not present in the array\" // This code is contributed by Utkarsh Kumar # Python program for the above approach # location of x in the given array arr[l..r] if present, # If the element is present at the middle itself # If the element is smaller than mid, then # it can only be present in the left subarray # Else the element can only be present # We reach here when the element is not \"Element is not present in array\" # This code is contributed by Susobhan Akhuli // C# program for the above approach // location of x in given array arr[l..r] if present, // If the element is present at the middle // If the element is smaller than mid, then // it can only be present in the left subarray // Else the element can only be present // We reach here when the element is not \"Element is not present in array\" // This code is contributed by Susobhan Akhuli // the index of x in the given array arr[l..r] if present, // If the element is present at the middle itself // If element is smaller than mid, then // it can only be present in the left subarray // Else the element can only be present // We reach here when the element is not present in the array \"Element is not present in the array\"\n\nIt imposes a complexity of O(N). It encompasses the same number of steps as that of the total number of elements to implement an operation on N elements.\n\nExample: The below program takes Linear complexity.\n\nIt imposes a complexity of O(n2). For N input data size, it undergoes the order of N2 count of operations on N number of elements for solving a given problem.\n\nExample: The below program takes quadratic complexity.\n\nIt imposes a complexity of O(n!). For N input data size, it executes the order of N! steps on N elements to solve a given problem.\n\nExample: The below program takes factorial complexity.\n\nIt imposes a complexity of O(2N), O(N!), O(nk), …. For N elements, it will execute the order of the count of operations that is exponentially dependable on the input data size.\n\nExample: The below program takes exponential complexity.\n\nWorst Case time complexity of different data structures for different operations\n• None Top MCQs on Complexity Analysis of Algorithms with Answers\n• None Top MCQs on Complexity Analysis using Recurrence Relations with Answers\n\nComplexity analysis is a very important technique to analyze any problem. The interviewer often checks your ideas and coding skills by asking you to write a code giving restrictions on its time or space complexities. By solving more and more problems anyone can improve their logical thinking day by day. Even in coding contests optimized solutions are accepted. The naive approach can give TLE(Time limit exceed)."
    },
    {
        "link": "https://simplilearn.com/tutorials/data-structure-tutorial/algorithm-complexity-in-data-structure",
        "document": ""
    }
]