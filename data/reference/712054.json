[
    {
        "link": "https://defold.com/ref/gui",
        "document": "This is a callback-function, which is called by the engine when a gui component is finalized (destroyed). It can be used to e.g. take some last action, report the finalization to other game object instances or release user input focus (see ). There is no use in starting any animations or similar from this function since the gui component is about to be destroyed.\n\nThis starts an animation of a node property according to the specified parameters. If the node property is already being animated, that animation will be canceled and replaced by the new one. Note however that several different node properties can be animated simultaneously. Use to stop the animation before it has completed. Composite properties of type vector3, vector4 or quaternion also expose their sub-components (x, y, z and w). You can address the components individually by suffixing the name with a dot '.' and the name of the component. For instance, (the position x coordinate) or (the color alpha value). If a (Lua function) is specified, that function will be called when the animation has completed. By starting a new animation in that function, several animations can be sequenced together. See the examples below for more information.\n\nHow to start a simple color animation, where the node fades in to white during 0.5 seconds:How to start a sequenced animation where the node fades in to white during 0.5 seconds, stays visible for 2 seconds and then fades out:How to animate a node's y position using a crazy custom easing curve:\n\nIf an animation of the specified node is currently running (started by ), it will immediately be canceled.\n\nStart an animation of the position property of a node, then cancel parts of the animation:\n\nCancels any running flipbook animation on the specified node.\n\nMake a clone instance of a node. The cloned node will be identical to the original node, except the id which is generated as the string \"node\" plus a sequential unsigned integer value. This function does not clone the supplied node's children nodes. Use gui.clone_tree for that purpose.\n\nMake a clone instance of a node and all its children. Use gui.clone to clone a node excluding its children.\n\nDeletes the specified node. Any child nodes of the specified node will be recursively deleted.\n\nDelete a particular node and any child nodes it might have:\n\nInstead of using specific getters such as gui.get_position or gui.get_scale, you can use gui.get instead and supply the property as a string or a hash. While this function is similar to go.get, there are a few more restrictions when operating in the gui namespace. Most notably, only these explicitly named properties are supported:\n\nThe value returned will either be a vmath.vector4 or a single number, i.e getting the \"position\" property will return a vec4 while getting the \"position.x\" property will return a single value. You can also use this function to get material constants.\n\nReturns the adjust mode of a node. The adjust mode defines how the node will adjust itself to screen resolutions that differs from the one in the project settings.\n\nReturns the blend mode of a node. Blend mode defines how the node will be blended with the background.\n\nIf node is set as an inverted clipping node, it will clip anything inside as opposed to outside.\n\nClipping mode defines how the node will clip it's children nodes\n\nIf node is set as visible clipping node, it will be shown as well as clipping. Otherwise, it will only clip but not show visually.\n\nReturns the color of the supplied node. The components of the returned vector4 contains the color channel values:\n\nReturns the rotation of the supplied node. The rotation is expressed in degree Euler angles.\n\nThis is only useful nodes with flipbook animations. Gets the normalized cursor of the flipbook animation on a node.\n\nThis is only useful nodes with flipbook animations. Gets the playback rate of the flipbook animation on a node.\n\nThis is only useful for text nodes. The font must be mapped to the gui scene in the gui editor.\n\nThis is only useful for text nodes. The font must be mapped to the gui scene in the gui editor.\n\nGet the text metrics for a text\n\nRetrieves the id of the specified node.\n\nGets the id of a node:\n\nRetrieve the index of the specified node among its siblings. The index defines the order in which a node appear in a GUI scene. Higher index means the node is drawn on top of lower indexed nodes.\n\nCompare the index order of two sibling nodes:\n\nReturns the inner radius of a pie node. The radius is defined along the x-axis.\n\nThe layer must be mapped to the gui scene in the gui editor.\n\nReturns the leading value for a text node.\n\nReturns whether a text node is in line-break mode or not. This is only useful for text nodes.\n\nReturns the material of a node. The material must be mapped to the gui scene in the gui editor.\n\nGetting the material for a node, and assign it to another node:\n\nRetrieves the node with the specified id.\n\nGets a node by id and change its color:\n\nReturns the outline color of the supplied node. See gui.get_color for info how vectors encode color values.\n\nReturns the parent node of the specified node. If the supplied node does not have a parent, is returned.\n\nGet the paricle fx for a gui node\n\nReturns the number of generated vertices around the perimeter of a pie node.\n\nThe pivot specifies how the node is drawn and rotated from its position.\n\nReturns the position of the supplied node.\n\nReturns the rotation of the supplied node. The rotation is expressed as a quaternion\n\nReturns the scale of the supplied node.\n\nReturns the screen position of the supplied node. This function returns the calculated transformed position of the node, taking into account any parent node transforms.\n\nReturns the shadow color of the supplied node. See gui.get_color for info how vectors encode color values.\n\nReturns the size of the supplied node.\n\nReturns the size of a node. The size mode defines how the node will adjust itself in size. Automatic size mode alters the node size based on the node's content. Automatic size mode works for Box nodes and Pie nodes which will both adjust their size to match the assigned image. Particle fx and Text nodes will ignore any size mode setting.\n\nReturns the slice9 configuration values for the node.\n\nReturns the text value of a text node. This is only useful for text nodes.\n\nReturns the texture of a node. This is currently only useful for box or pie nodes. The texture must be mapped to the gui scene in the gui editor.\n\nReturns the tracking value of a text node.\n\nGet a node and all its children as a Lua table.\n\nReturns if a node is visible and if it's not. Invisible nodes are not rendered.\n\nThe x-anchor specifies how the node is moved when the game is run in a different resolution.\n\nThe y-anchor specifies how the node is moved when the game is run in a different resolution.\n\nHides the on-display touch keyboard on the device.\n\nReturns if a node is enabled and if it's not. Disabled nodes are not rendered and animations acting on them are not evaluated.\n\nAlters the ordering of the two supplied nodes by moving the first node above the second. If the second argument is the first node is moved to the top.\n\nAlters the ordering of the two supplied nodes by moving the first node below the second. If the second argument is the first node is moved to the bottom.\n\nHow to create a texture and apply it to a new box node:\n\nTests whether a coordinate is within the bounding box of a node.\n\nPlay flipbook animation on a box or pie node. The current node texture must contain the animation. Use this function to set one-frame still images on the node.\n\nSet the texture of a node to a flipbook animation from an atlas:Set the texture of a node to an image from an atlas:\n\n. Resets the input context of keyboard. This will clear marked text. Resets the node material to the material assigned in the gui scene. node to reset the material for Resetting the material for a node: Resets all nodes in the current GUI scene to their initial state. The reset only applies to static node loaded from the scene. Nodes that are created dynamically from script are not affected. Convert the screen position to the local position of supplied node node used for getting local transformation matrix Instead of using specific setteres such as gui.set_position or gui.set_scale, you can use gui.set instead and supply the property as a string or a hash. While this function is similar to go.get and go.set, there are a few more restrictions when operating in the gui namespace. Most notably, only these named properties identifiers are supported: The value to set must either be a vmath.vector4, vmath.vector3, vmath.quat or a single number and depends on the property name you want to set. I.e when setting the \"position\" property, you need to use a vmath.vector4 and when setting a single component of the property, such as \"position.x\", you need to use a single value. Note: When setting the rotation using the \"rotation\" property, you need to pass in a vmath.quat. This behaviour is different than from the gui.set_rotation function, the intention is to move new functionality closer to go namespace so that migrating between gui and go is easier. To set the rotation using degrees instead, use the \"euler\" property instead. The rotation and euler properties are linked, changing one of them will change the backing data of the other. Similar to go.set, you can also use gui.set for setting material constant values on a node. E.g if a material has specified a constant called in the .material file, you can use gui.set to set the value of that constant by calling , or if the constant is a matrix. Arrays are also supported by gui.set - to set an array constant, you need to pass in an options table with the 'index' key set. If the material has a constant array called 'tint_array' specified in the material, you can use to set the fourth array element to a different value. node to set the property for optional options table (only applicable for material constants) - index into array property (1 based) Updates the position property on an existing node: Updates the rotation property on an existing node: -- this is equivalent to: -- or using the entire vector: -- or using the set_rotation Sets various material constants for a node: -- update a constant in an array at position 4. the array is specified in the shader as: -- update a matrix constant in an array at position 4. the array is specified in the shader as: -- update a sub-element in an array constant at position 4 Sets the adjust mode on a node. The adjust mode defines how the node will adjust itself to screen resolutions that differs from the one in the project settings. node for which to set alpha Set the blend mode of a node. Blend mode defines how the node will be blended with the background. If node is set as an inverted clipping node, it will clip anything inside as opposed to outside. Clipping mode defines how the node will clip it's children nodes If node is set as an visible clipping node, it will be shown as well as clipping. Otherwise, it will only clip but not show visually. Sets the color of the supplied node. The components of the supplied vector3 or vector4 should contain the color channel values: node to set the color for Sets a node to the disabled or enabled state. Disabled nodes are not rendered and animations acting on them are not evaluated. whether the node should be enabled or not Sets the rotation of the supplied node. The rotation is expressed in degree Euler angles. node to set the rotation for node to set the fill angle for This is only useful nodes with flipbook animations. The cursor is normalized. node to set the cursor for This is only useful nodes with flipbook animations. Sets the playback rate of the flipbook animation on a node. Must be positive. node to set the cursor for This is only useful for text nodes. The font must be mapped to the gui scene in the gui editor. node for which to set the font Set the id of the specicied node to a new value. Nodes created with the gui.new_*_node() functions get an empty id. This function allows you to give dynamically created nodes an id. No checking is done on the uniqueness of supplied ids. It is up to you to make sure you use unique ids. node to set the id for Create a new node and set its id: node from which to set the inherit alpha state Sets the inner radius of a pie node. The radius is defined along the x-axis. node to set the inner radius for The layer must be mapped to the gui scene in the gui editor. node for which to set the layer Sets the leading value for a text node. This value is used to scale the line spacing of text. node for which to set the leading a scaling value for the line spacing (default=1) Sets the line-break mode on a text node. This is only useful for text nodes. Set the material on a node. The material must be mapped to the gui scene in the gui editor, and assigning a material is supported for all node types. To set the default material that is assigned to the gui scene node, use instead. Assign an existing material to a node: node for which to set the outer bounds mode the outer bounds mode of the pie node: Sets the outline color of the supplied node. See gui.set_color for info how vectors encode color values. node to set the outline color for Sets the parent node of the specified node. node for which to set its parent optional flag to make the scene position being perserved Sets the number of generated vertices around the perimeter of a pie node. The pivot specifies how the node is drawn and rotated from its position. Sets the position of the supplied node. node to set the position for Set the order number for the current GUI scene. The number dictates the sorting of the \"gui\" render predicate, in other words in which order the scene will be rendered in relation to other currently rendered GUI scenes. The number must be in the range 0 to 15. Sets the rotation of the supplied node. The rotation is expressed as a quaternion node to set the rotation for Sets the scaling of the supplied node. node to set the scale for Set the screen position to the supplied node node to set the screen position to Sets the shadow color of the supplied node. See gui.set_color for info how vectors encode color values. node to set the shadow color for Sets the size of the supplied node. You can only set size on nodes with size mode set to SIZE_MODE_MANUAL node to set the size for Sets the size mode of a node. The size mode defines how the node will adjust itself in size. Automatic size mode alters the node size based on the node's content. Automatic size mode works for Box nodes and Pie nodes which will both adjust their size to match the assigned image. Particle fx and Text nodes will ignore any size mode setting. Set the slice9 configuration values for the node. Set the text value of a text node. This is only useful for text nodes. Set the texture on a box or pie node. The texture must be mapped to the gui scene in the gui editor. The function points out which texture the node should render from. If the texture is an atlas, further information is needed to select which image/animation in the atlas to render. In such cases, use in addition to this function. To set a texture (or animation) from an atlas: Set a dynamically created texture to a node. Note that there is only one texture image in this case so is sufficient. -- Create the texture. Repeat the color string for each pixel. -- Create a box node and apply the texture to it. -- Change the data in the texture to a nice orange. -- Go on and to more stuff Sets the tracking value of a text node. This value is used to adjust the vertical spacing of characters in the text. node for which to set the tracking Set if a node should be visible or not. Only visible nodes are rendered. node to be visible or not whether the node should be visible or not The x-anchor specifies how the node is moved when the game is run in a different resolution. The y-anchor specifies how the node is moved when the game is run in a different resolution. Shows the on-display touch keyboard. The specified type of keyboard is displayed if it is available on the device. This function is only available on iOS and Android. . if the keyboard should automatically close when clicking outside This is a callback-function, which is called by the engine when a gui component is initialized. It can be used to set the initial state of the script and gui scene. reference to the script state to be used for storing data This is a callback-function, which is called by the engine when user input is sent to the instance of the gui component. It can be used to take action on the input, e.g. modify the gui according to the input. For an instance to obtain user input, it must first acquire input focus through the message . Any instance that has obtained input will be put on top of an input stack. Input is sent to all listeners on the stack until the end of stack is reached, or a listener returns to signal that it wants input to be consumed. See the documentation of acquire_input_focus for more information. The parameter is a table containing data about the input mapped to the . For mapped actions it specifies the value of the input and if it was just pressed or released. Actions are mapped to input in an input_binding-file. Mouse movement is specifically handled and uses as its . The only contains positional parameters in this case, such as x and y of the pointer. Here is a brief description of the available table fields: The amount of input given by the user. This is usually 1 for buttons and 0-1 for analogue inputs. This is not present for mouse movement. If the input was pressed this frame. This is not present for mouse movement. If the input was released this frame. This is not present for mouse movement. If the input was repeated this frame. This is similar to how a key on a keyboard is repeated when you hold it down. This is not present for mouse movement. The x value of a pointer device, if present. The y value of a pointer device, if present. The screen space x value of a pointer device, if present. The screen space y value of a pointer device, if present. The change in x value of a pointer device, if present. The change in y value of a pointer device, if present. The change in screen space x value of a pointer device, if present. The change in screen space y value of a pointer device, if present. The index of the gamepad device that provided the input. List of touch input, one element per finger, if present. See table below about touch input Touch input table: A number identifying the touch input during its duration. True if the finger was pressed this frame. True if the finger was released this frame. Number of taps, one for single, two for double-tap, etc The change in x value. The change in y value. reference to the script state to be used for storing data id of the received input action, as mapped in the input_binding-file a table containing the input data, see above for a description optional boolean to signal if the input should be consumed (not passed on to others) or not, default is false This is a callback-function, which is called by the engine whenever a message has been sent to the gui component. It can be used to take action on the message, e.g. update the gui or send a response back to the sender of the message. The parameter is a table containing the message data. If the message is sent from the engine, the documentation of the message specifies which data is supplied. See the update function for examples on how to use this callback-function. reference to the script state to be used for storing data This is a callback-function, which is called by the engine when the gui script is reloaded, e.g. from the editor. It can be used for live development, e.g. to tweak constants or set up the state properly for the script. reference to the script state to be used for storing data This is a callback-function, which is called by the engine every frame to update the state of a gui component. It can be used to perform any kind of gui related tasks, e.g. animating nodes. reference to the script state to be used for storing data the time-step of the frame update This example demonstrates how to update a text node that displays game score in a counting fashion. It is assumed that the gui component receives messages from the game when a new score is to be shown. -- fetch the score text node for later use (assumes it is called \"score\") -- keep track of the current score counted up so far -- keep track of the target score we should count up to -- how fast we will update the score, in score/second -- check if target score is more than current score -- increment current score according to the speed -- check if we went past the target score, clamp current score in that case Adjust mode is used when the screen resolution differs from the project settings. The fit mode ensures that the entire node is visible in the adjusted gui scene. Adjust mode is used when the screen resolution differs from the project settings. The stretch mode ensures that the node is displayed as is in the adjusted gui scene, which might scale it non-uniformally. Adjust mode is used when the screen resolution differs from the project settings. The zoom mode ensures that the node fills its entire area and might make the node exceed it. once forward and then backward The provided data is not in the expected format or is in some other way incorrect, for instance the image data provided to gui.new_texture(). The system is out of resources, for instance when trying to create a new texture using gui.new_texture(). The texture id already exists when trying to use gui.new_texture(). The size of the node is determined by the currently assigned texture. The size of the node is determined by the size set in the editor, the constructor or by gui.set_size() This message is broadcast to every GUI component when a layout change has been initiated on device. the id of the layout the engine is changing to the id of the layout the engine is changing from The fonts used in the gui. The type of the property is hash. Key must be specified in options table. How to set font using a script property (see resource.font) The main material (the default material assigned to a GUI) used when rendering the gui. The type of the property is hash. How to set material using a script property (see resource.material) The materials used when rendering the gui. The type of the property is hash. Key must be specified in options table. How to change a named material resource using a script property from a script -- this will update the \"my_gui_material\" entry in the GUI to use the material -- specified in the \"my_material\" script property. The textures used in the gui. The type of the property is hash. Key must be specified in options table. How to set texture using a script property (see resource.atlas)\n\nHow to play a particle fx when a gui node is created. The callback receives the gui node, the hash of the id of the emitter, and the new state of the emitter as particlefx.EMITTER_STATE_"
    },
    {
        "link": "https://defold.com/manuals/lua",
        "document": "Getting Started - Introduction - Installing Defold - Glossary - Defold for Flash users - Getting help Project Setup - Creating a project - Project settings - Sharing projects Editor - Overview - Code editor - Custom project templates - Editor scripts - Editor scripts: UI - Debugger - Keyboard shortcuts - Preferences - Refactoring - Styling Core Concepts - Building blocks - Addressing - Message passing - Application lifecycle Assets and Resources - Importing assets - Caching assets - Importing 2D graphics - Importing 3D models - Adapting to different screen sizes - Live update - Atlas - Buffer - Font - Runtime TTF Font - Resource management - Tile source - Texture filtering - Texture compression Animations - Overview - Flipbook Animation - Model animation - Property animation (tweens) - Rive animation - Spine animation Components - Overview - Collection factory - Collection proxy - Collision object - Camera - Factory - Label - Mesh - Model - Particle FX - Rive - Sound - Spine - Sprite - Tilemap GUI - GUI overview - Box nodes - Text nodes - Pie nodes - Spine nodes - ParticleFX nodes - Template nodes - Scripts - Clipping - Layouts Physics - Physics overview - Collision objects - Collision shapes - Collision groups - Collision messages - Collision events listener - Resolving collisions - Ray casts - Joints and constraints Sound - Sound - Sound Streaming - FMOD Input - Overview - Key and text input - Mouse and touch - Gamepads Game logic - Scripts - Properties - Script properties - Lua in Defold - Source code obfuscation - Modules - Debugging - Writing code Files - Working with files Network Connections - Overview - HTTP Requests - Socket connections - WebSocket connections - Online services Rendering - Render - Material - Compute - Shader - Texture filtering Workflow - Application security - Bundling an application - Caching assets - Command line tools - Hot reloading - Porting guidelines - Refactoring - The mobile dev app - Version control - Writing code - Working offline Debugging - Debugging game logic - Debugging native code - Debugging native code on Android - Debugging native code on iOS - Reading game and system logs Optimization - Optimizing an application - Optimize game size - Optimize runtime performance - Optimize battery usage - Optimize memory usage - Profiling Monetization - Ads - In-app purchases Android - Introduction - Advertising Info - AdMob ads - Android Device Performance Framework - App review and ratings - Camera - Facebook - Firebase Analytics - Firebase Remote Config - Google Play Game Services - Google Play Instant - Inter-app communication - IronSource ad mediation - Push notifications - Safe Area - Webview - The mobile dev app iOS - Introduction - Advertising Info - AdMob ads - App review and ratings - Camera - Facebook - Firebase Analytics - Firebase Remote Config - Inter-app communication - IronSource ad mediation - Push notifications - Safe Area - Webview - The mobile dev app Consoles - Nintendo Switch - PlayStation®4 - PlayStation®5 - Microsoft Xbox HTML5 - Introduction - CrazyGames - Facebook - Facebook Instant Games - Poki Desktop - Linux - macOS - Windows Engine extensions - Introduction - Defold SDK - Gradle dependencies - Cocoapod dependencies - Adding auto-complete definition - Best Practices - Debugging - Extension Manifests - App Manifests - Manifest Merging - The Lua C API (external) - Setup local build server - Available Docker images to run Extender\n\nThe Defold engine has the Lua language embedded for scripting. Lua is a lightweight dynamic language that is powerful, fast, and easy to embed. It is widely used as a videogame scripting language. Lua programs are written in a simple procedural syntax. The language is dynamically typed and is run by a bytecode interpreter. It features automatic memory management with incremental garbage collection.\n\nThis manual will give a quick introduction to the basics of Lua programming in general and what you need to consider when working with Lua in Defold. If you have some experience with Python, Perl, Ruby, Javascript, or a similar dynamic language you will get going pretty quickly. If you are new to programming you might want to start with a Lua book aimed at beginners. There are plenty to choose from.\n\nDefold uses LuaJIT, a highly optimized version of Lua suitable for use in games and other performance-critical software. It is fully upwards compatible with Lua 5.1 and supports all standard Lua library functions and the full set of Lua/C API functions.\n\nLuaJIT also adds several language extensions and some Lua 5.2 and 5.3 features.\n\nWe aim to keep Defold the same across all platforms, but we currently have a few minor discrepancies in the Lua language version between platforms:\n• iOS does not allow JIT compilation.\n• Nintendo Switch does not allow JIT compilation.\n• HTML5 uses Lua 5.1.4 instead of LuaJIT.\n\nDefold includes all of the Lua 5.1 standard libraries as well as a socket and a bit operation library:\n\nAll libraries are documented in the reference API documentation.\n• Programming in Lua (first edition) Later editions are available in print.\n• Programming in Lua - Programming in Lua is the official book about the language, providing a solid base to any programmer who wants to use Lua. Authored by Roberto Ierusalimschy, the chief architect of the language.\n• Lua programming gems - This collection of articles records some of the existing wisdom and practice on how to program well in Lua.\n• Lua 5.1 reference manual - Also available online (see above)\n\nPrograms have simple, easy-to-read syntax. Statements are written one on each line and there is no need to mark the end of a statement. You can optionally use semicolons to separate statements. Blocks of code are keyword delimited, ending with the keyword. Comments can be either written in a block or until the end of the line:\n\nLua is dynamically typed, meaning variables do not have types, but values do. Unlike in statically typed languages, you can assign any value to any variable as you like.\n\nThere are eight basic types in Lua:\n\nLua provides the usual set of flow control constructs.\n\nAll variables that you declare are by default global, meaning that they are available through all parts of the Lua runtime context. You can explicitly declare variables , meaning that the variable will only exist within the current scope.\n\nEach Lua source file defines a separate scope. Local declarations on the topmost level in a file mean the variable is local to the Lua script file. Each function creates another nested scope and each control structure block creates additional scopes. You can explicitly create a scope with the and keywords. Lua is lexically scoped, meaning that a scope has full access to local variables from the enclosing scope. Note that the local variables must be declared before their use.\n\nNote that if you declare functions in a script file (which is generally a good idea) you need to watch out how you order the code. You can use forward declarations if you have functions that mutually call each other.\n\nIf you write a function enclosed in another function, it too has full access to local variables from the enclosing function. This is a very powerful construct.\n\nLocal variables declared in a block will shadow variables from a surrounding block with the same name.\n\nFunctions execute from beginning to end and there is no way to stop them midway through. Coroutines allow you to do that, which can be very convenient in some cases. Suppose we want to create a very specific frame-by-frame animation where we move a game object from y position to some very specific y positions from frame 1 to frame 5. We could solve that with a counter in the function (see below) and a list of the positions. However, with a coroutine, we get a very clean implementation that is easy to extend and work with. All state is contained within the coroutine itself.\n\nWhen a coroutine yields it returns control back to the caller but remembers its execution point so it can continue from there later on.\n\nAll variables that you declare are by default global, meaning that they are available through all parts of the Lua runtime context. Defold has a setting shared_state setting in game.project that controls this context. If the option is set, all scripts, GUI scripts, and the render script are evaluated in the same Lua context and global variables are visible everywhere. If the option is not set, the engine executes scripts, GUI scripts, and the render script in separate contexts.\n\nDefold allows you to use the same script file in several separate game object components. Any locally declared variables are shared between components that run the same script file.\n\nIn a high-performance game that is intended to run at a smooth 60 FPS small performance mistakes can have a large impact on the experience. There are some simple general things to consider and some things that might not seem problematic.\n\nBeginning with the simple things. It is generally a good idea to write straightforward code that does not contain unnecessary loops. Sometimes you do need to iterate over lists of things, but be careful if the list of things is sufficiently large. This example runs in slightly over 1 millisecond on a pretty decent laptop, which can make all the difference if each frame is only 16 milliseconds long (at 60 FPS) and with the engine, render script, physics simulation, and so forth eating up a chunk of that.\n\nUse the value returned from (seconds since system epoch) to benchmark suspect code.\n\nLua’s garbage collection runs automatically in the background by default and reclaims memory that the Lua runtime has allocated. Collecting lots of garbage can be a time-consuming task so it is good to keep down the number of objects that need to be garbage collected:\n• Local variables are in themselves free and will not generate garbage. (i.e. )\n• Each new unique string creates a new object. Writing will create a new object and assign to it. The local itself will not generate garbage, but the string object will. Using the same string multiple times adds no additional memory cost.\n• Each time a table constructor is executed ( ) a new table is created.\n• Vararg functions ( ) create a table for the ellipsis each time the function is called (in Lua before version 5.2, or if not using LuaJIT).\n\nThere are many cases where you can avoid creating new objects and instead reuse the ones you already have. For example. The following is common at the end of each :\n\nIt’s easy to forget that each call to creates a new object. Let’s find out how much memory one uses:\n\n70 bytes has been added between the calls to , but this includes allocations for more than the object. Each printing of the result from builds a string which in itself adds 22 bytes of garbage:\n\nSo a weighs in at 70-22=48 bytes. That is not much, but if you create one each frame in a 60 FPS game it’s suddenly 2.8 kB of garbage per second. With 360 script components that each create one every frame we’re looking at 1 MB of garbage generated per second. The numbers can add up very quickly. When the Lua runtime collects garbage it may eat up many precious milliseconds—especially on mobile platforms.\n\nOne way to avoid allocations is to create a and then keep working with the same object. For instance, to reset a we can use the following construct:\n\nThe default garbage-collecting scheme may not be optimal for some time-critical applications. If you see a stutter in your game or app, you might want to tune how Lua collects garbage through the Lua function. You can, for instance, run the collector for a short time every frame with a low value. To get an idea how much memory your game or app is eating, you can print the current amount of garbage bytes with:\n\nA common implementation design consideration is how to structure code for shared behaviors. Several approaches are possible."
    },
    {
        "link": "https://forum.defold.com/t/documenting-my-code/7147",
        "document": "I was looking into LDoc or LuaDoc to document my code. I saw from some examples (I have a clickable script that is pretty awesome to set my standards) that people already use some of these standards for documentation.\n\nSince the boilerplate code for all game object scripts comes with predefined functions and a useful reference to instances thanks to self, most of my functions contain self as a parameter, and I will generally define some variables for self in the init function, i.e\n\nI’m not sure what’s the best way to document these instance variables.\n\nbtw, can I change the declaration of these functions to be local? I haven’t really tested/understood this.\n\nAlso, for lua best practices, if someone has good links, I am developing a project with a few friends and most of us are not experts in lua. I’ve been playing with defold for a couple of months now, but still I feel like a noob."
    },
    {
        "link": "https://forum.defold.com/t/how-to-gui-in-defold/73256",
        "document": ""
    },
    {
        "link": "https://forum.defold.com/t/lua-utility-functions/70526",
        "document": ""
    },
    {
        "link": "https://defold.com/manuals/font",
        "document": "Getting Started - Introduction - Installing Defold - Glossary - Defold for Flash users - Getting help Project Setup - Creating a project - Project settings - Sharing projects Editor - Overview - Code editor - Custom project templates - Editor scripts - Editor scripts: UI - Debugger - Keyboard shortcuts - Preferences - Refactoring - Styling Core Concepts - Building blocks - Addressing - Message passing - Application lifecycle Assets and Resources - Importing assets - Caching assets - Importing 2D graphics - Importing 3D models - Adapting to different screen sizes - Live update - Atlas - Buffer - Font - Runtime TTF Font - Resource management - Tile source - Texture filtering - Texture compression Animations - Overview - Flipbook Animation - Model animation - Property animation (tweens) - Rive animation - Spine animation Components - Overview - Collection factory - Collection proxy - Collision object - Camera - Factory - Label - Mesh - Model - Particle FX - Rive - Sound - Spine - Sprite - Tilemap GUI - GUI overview - Box nodes - Text nodes - Pie nodes - Spine nodes - ParticleFX nodes - Template nodes - Scripts - Clipping - Layouts Physics - Physics overview - Collision objects - Collision shapes - Collision groups - Collision messages - Collision events listener - Resolving collisions - Ray casts - Joints and constraints Sound - Sound - Sound Streaming - FMOD Input - Overview - Key and text input - Mouse and touch - Gamepads Game logic - Scripts - Properties - Script properties - Lua in Defold - Source code obfuscation - Modules - Debugging - Writing code Files - Working with files Network Connections - Overview - HTTP Requests - Socket connections - WebSocket connections - Online services Rendering - Render - Material - Compute - Shader - Texture filtering Workflow - Application security - Bundling an application - Caching assets - Command line tools - Hot reloading - Porting guidelines - Refactoring - The mobile dev app - Version control - Writing code - Working offline Debugging - Debugging game logic - Debugging native code - Debugging native code on Android - Debugging native code on iOS - Reading game and system logs Optimization - Optimizing an application - Optimize game size - Optimize runtime performance - Optimize battery usage - Optimize memory usage - Profiling Monetization - Ads - In-app purchases Android - Introduction - Advertising Info - AdMob ads - Android Device Performance Framework - App review and ratings - Camera - Facebook - Firebase Analytics - Firebase Remote Config - Google Play Game Services - Google Play Instant - Inter-app communication - IronSource ad mediation - Push notifications - Safe Area - Webview - The mobile dev app iOS - Introduction - Advertising Info - AdMob ads - App review and ratings - Camera - Facebook - Firebase Analytics - Firebase Remote Config - Inter-app communication - IronSource ad mediation - Push notifications - Safe Area - Webview - The mobile dev app Consoles - Nintendo Switch - PlayStation®4 - PlayStation®5 - Microsoft Xbox HTML5 - Introduction - CrazyGames - Facebook - Facebook Instant Games - Poki Desktop - Linux - macOS - Windows Engine extensions - Introduction - Defold SDK - Gradle dependencies - Cocoapod dependencies - Adding auto-complete definition - Best Practices - Debugging - Extension Manifests - App Manifests - Manifest Merging - The Lua C API (external) - Setup local build server - Available Docker images to run Extender\n\nFonts are used to render text on Label components and GUI text nodes. Defold supports several font file formats:\n\nFonts added to your project are automatically converted into a texture format that Defold can render. Two font rendering techniques are available, each with its own specific benefits and drawbacks:\n\nTo create a font for use in Defold, create a new Font file by selecting from the menu, then select . You can also a location in the Assets browser and select .\n\nGive the new font file a name and click . The new font file now opens in the editor.\n\nDrag the font you wish to use into the Assets browser and drop it in a good spot.\n\nSet the Font property to the font file and set the font properties as needed.\n\nDistance field fonts store the distance to the edge of the glyph in the texture instead of bitmap data. When the engine renders the font, a special shader is required to interpret the distance data and use that to draw the glyph. Distance field fonts are more resource intensive than bitmap fonts, but allow for greater sizing flexibility.\n\nMake sure to change the Material property of the font to (or any other material that can handle the distance field data) when you create the font—or the font will not use the correct shader when it is rendered to screen.\n\nIn addition to generated bitmaps Defold supports prebaked bitmap “BMFont” format fonts. These fonts consists of a PNG font sheet with all the glyphs. In addition, a file contains information on where on the sheet each glyph can be found as well as size and kerning information. (Note that Defold does not support the XML version of the format that is used by Phaser and some other tools)\n\nThese types of fonts provide no performance improvement from bitmap fonts generated from TrueType or OpenType font files, but can include arbitrary graphics, coloring and shadows right in the image.\n\nAdd the generated and files to your Defold project. These files should reside in the same folder. Create a new font file and set the font property to the file. Make sure that output_format is set to . Defold will not generate a bitmap but use the one provided in the PNG.\n\nFor the font to render correctly, don’t forget to set the material property to when you create the font.\n\nGenerally, bitmap fonts are best when the font is rendered with no scaling. They are faster to render to screen than distance field fonts.\n\nDistance field fonts respond very good to upscaling. Bitmap fonts, on the other hand, being just pixelated images will increase in size so the pixels will grow as the font is scaled, resulting in blocky artifacts. The following is a sample at font size 48 pixels, scaled up 4 times.\n\nWhen scaling down, bitmap textures can be nicely and efficiently scaled down and antialiased by the GPU. A bitmap font keeps its color better than a distance field font. Here is a zoom of the same sample font at size 48 pixels, scaled down to 1/5 of the size:\n\nDistance field fonts need to be rendered to a target size that is big enough to hold distance information that can express the curves of the font glyphs. This is the same font as above, but at 18 pixels size and scaled up 10 times. It is clear that this is too small to encode the shapes of this typeface:\n\nIf you don’t want shadow or outline support, set their respective alpha values to zero. Otherwise, shadow and outline data will still be generated, taking up unnecessary memory.\n\nA font resource in Defold will result in two things at runtime, a texture and the font data.\n• The font data consist of a list of glyph entries, each containing some basic kerning info and the bitmap data for that glyph.\n• The texture is internally called the “glyph cache texture” and it will be used when rendering text for a specific font.\n\nAt runtime, when rendering text, the engine will first loop through the glyphs to be rendered to check which glyphs are available in the texture cache. Each glyph that is missing from the glyph texture cache will trigger a texture upload from the bitmap data stored in the font data.\n\nEach glyph is placed internally in the cache according to the font baseline, which enables calculating local texture coordinates of the glyph within its corresponding cache cell in a shader. This means that you can achieve certain text effects such as gradients or texture overlays dynamically. The engine exposes metrics about the cache to the shader via a special shader constant called , which contains the following information in the vector components:\n• is the inverse of the cache width\n• is the inverse of the cache height\n• is the ratio of cache cell width to the cache width\n• is the ratio of cache cell height to the cache height\n\nFor example - to generate a gradient in a shader fragment, simply write:\n\nFor more information about shader uniforms, see the Shader manual."
    },
    {
        "link": "https://forum.defold.com/t/how-to-load-and-set-a-font-at-runtime/68490",
        "document": "Defold is a free and open game engine used for development of console, desktop, mobile and web games."
    },
    {
        "link": "https://defold.com/examples/gui/get_set_font",
        "document": "-- get the font file on the gui component which is assigned to -- get the font file currently assigned to the font with id 'default' -- toggle between the default font and the font referenced by the\n\nIf you want to play with these examples, you can get the project on Github. Do you want to see more examples? Why not write a few yourself and submit a pull request? We love contributions. GITHUB"
    },
    {
        "link": "https://defold.com/manuals/gui-text",
        "document": "Getting Started - Introduction - Installing Defold - Glossary - Defold for Flash users - Getting help Project Setup - Creating a project - Project settings - Sharing projects Editor - Overview - Code editor - Custom project templates - Editor scripts - Editor scripts: UI - Debugger - Keyboard shortcuts - Preferences - Refactoring - Styling Core Concepts - Building blocks - Addressing - Message passing - Application lifecycle Assets and Resources - Importing assets - Caching assets - Importing 2D graphics - Importing 3D models - Adapting to different screen sizes - Live update - Atlas - Buffer - Font - Runtime TTF Font - Resource management - Tile source - Texture filtering - Texture compression Animations - Overview - Flipbook Animation - Model animation - Property animation (tweens) - Rive animation - Spine animation Components - Overview - Collection factory - Collection proxy - Collision object - Camera - Factory - Label - Mesh - Model - Particle FX - Rive - Sound - Spine - Sprite - Tilemap GUI - GUI overview - Box nodes - Text nodes - Pie nodes - Spine nodes - ParticleFX nodes - Template nodes - Scripts - Clipping - Layouts Physics - Physics overview - Collision objects - Collision shapes - Collision groups - Collision messages - Collision events listener - Resolving collisions - Ray casts - Joints and constraints Sound - Sound - Sound Streaming - FMOD Input - Overview - Key and text input - Mouse and touch - Gamepads Game logic - Scripts - Properties - Script properties - Lua in Defold - Source code obfuscation - Modules - Debugging - Writing code Files - Working with files Network Connections - Overview - HTTP Requests - Socket connections - WebSocket connections - Online services Rendering - Render - Material - Compute - Shader - Texture filtering Workflow - Application security - Bundling an application - Caching assets - Command line tools - Hot reloading - Porting guidelines - Refactoring - The mobile dev app - Version control - Writing code - Working offline Debugging - Debugging game logic - Debugging native code - Debugging native code on Android - Debugging native code on iOS - Reading game and system logs Optimization - Optimizing an application - Optimize game size - Optimize runtime performance - Optimize battery usage - Optimize memory usage - Profiling Monetization - Ads - In-app purchases Android - Introduction - Advertising Info - AdMob ads - Android Device Performance Framework - App review and ratings - Camera - Facebook - Firebase Analytics - Firebase Remote Config - Google Play Game Services - Google Play Instant - Inter-app communication - IronSource ad mediation - Push notifications - Safe Area - Webview - The mobile dev app iOS - Introduction - Advertising Info - AdMob ads - App review and ratings - Camera - Facebook - Firebase Analytics - Firebase Remote Config - Inter-app communication - IronSource ad mediation - Push notifications - Safe Area - Webview - The mobile dev app Consoles - Nintendo Switch - PlayStation®4 - PlayStation®5 - Microsoft Xbox HTML5 - Introduction - CrazyGames - Facebook - Facebook Instant Games - Poki Desktop - Linux - macOS - Windows Engine extensions - Introduction - Defold SDK - Gradle dependencies - Cocoapod dependencies - Adding auto-complete definition - Best Practices - Debugging - Extension Manifests - App Manifests - Manifest Merging - The Lua C API (external) - Setup local build server - Available Docker images to run Extender\n\nDefold supports a specific type of GUI node that allows text to be rendered in a GUI scene. Any font resource added to a project can be used for text node rendering.\n\nThe fonts that you wish to use in GUI text nodes must be added to the GUI component. Either right-click the Fonts folder, use the top menu or press the corresponding keyboard shortcut.\n\nBy setting the node pivot you can change the alignment mode for the text.\n\nText nodes respond to any generic node manipulation functions for setting size, pivot, color and so forth. A few text node only functions exist:\n• To change the font of a text node, use the function.\n• To change the line break behavior of a text node, use the function.\n• To change the content of a text node, use the function."
    },
    {
        "link": "https://defold.com/manuals/gui",
        "document": "Getting Started - Introduction - Installing Defold - Glossary - Defold for Flash users - Getting help Project Setup - Creating a project - Project settings - Sharing projects Editor - Overview - Code editor - Custom project templates - Editor scripts - Editor scripts: UI - Debugger - Keyboard shortcuts - Preferences - Refactoring - Styling Core Concepts - Building blocks - Addressing - Message passing - Application lifecycle Assets and Resources - Importing assets - Caching assets - Importing 2D graphics - Importing 3D models - Adapting to different screen sizes - Live update - Atlas - Buffer - Font - Runtime TTF Font - Resource management - Tile source - Texture filtering - Texture compression Animations - Overview - Flipbook Animation - Model animation - Property animation (tweens) - Rive animation - Spine animation Components - Overview - Collection factory - Collection proxy - Collision object - Camera - Factory - Label - Mesh - Model - Particle FX - Rive - Sound - Spine - Sprite - Tilemap GUI - GUI overview - Box nodes - Text nodes - Pie nodes - Spine nodes - ParticleFX nodes - Template nodes - Scripts - Clipping - Layouts Physics - Physics overview - Collision objects - Collision shapes - Collision groups - Collision messages - Collision events listener - Resolving collisions - Ray casts - Joints and constraints Sound - Sound - Sound Streaming - FMOD Input - Overview - Key and text input - Mouse and touch - Gamepads Game logic - Scripts - Properties - Script properties - Lua in Defold - Source code obfuscation - Modules - Debugging - Writing code Files - Working with files Network Connections - Overview - HTTP Requests - Socket connections - WebSocket connections - Online services Rendering - Render - Material - Compute - Shader - Texture filtering Workflow - Application security - Bundling an application - Caching assets - Command line tools - Hot reloading - Porting guidelines - Refactoring - The mobile dev app - Version control - Writing code - Working offline Debugging - Debugging game logic - Debugging native code - Debugging native code on Android - Debugging native code on iOS - Reading game and system logs Optimization - Optimizing an application - Optimize game size - Optimize runtime performance - Optimize battery usage - Optimize memory usage - Profiling Monetization - Ads - In-app purchases Android - Introduction - Advertising Info - AdMob ads - Android Device Performance Framework - App review and ratings - Camera - Facebook - Firebase Analytics - Firebase Remote Config - Google Play Game Services - Google Play Instant - Inter-app communication - IronSource ad mediation - Push notifications - Safe Area - Webview - The mobile dev app iOS - Introduction - Advertising Info - AdMob ads - App review and ratings - Camera - Facebook - Firebase Analytics - Firebase Remote Config - Inter-app communication - IronSource ad mediation - Push notifications - Safe Area - Webview - The mobile dev app Consoles - Nintendo Switch - PlayStation®4 - PlayStation®5 - Microsoft Xbox HTML5 - Introduction - CrazyGames - Facebook - Facebook Instant Games - Poki Desktop - Linux - macOS - Windows Engine extensions - Introduction - Defold SDK - Gradle dependencies - Cocoapod dependencies - Adding auto-complete definition - Best Practices - Debugging - Extension Manifests - App Manifests - Manifest Merging - The Lua C API (external) - Setup local build server - Available Docker images to run Extender\n\nDefold provides you with a custom GUI editor and powerful scripting possibilities that are tailor made for the construction and implementation of user interfaces.\n\nA graphical user interface in Defold is a component that you build and attach to a game object and place in a collection. This component has the following properties:\n• It has simple, but powerful, layout features that allow resolution and aspect ratio independent rendering of your user interface.\n• It can have logic behavior attached to it through a GUI script.\n• It is (by default) rendered on top of other content, independent of camera view so even if you have a moving camera, your GUI elements will stay put on the screen. The rendering behavior can be changed.\n\nGUI components are rendered independently of the game view. Because of this it is not placed in a particular location in the collection editor, nor does it have a visual representation in the collection editor. However, GUI components have to reside in a game object that has a location in a collection. Changing that location has no effect on the GUI.\n\nGUI components are created from a GUI scene prototype file (also known as “prefabs” or “blueprints” in other engines). To create a new GUI component, a location in the Assets browser and select . Type a name for the new GUI file and press .\n\nDefold now automatically opens the file in the GUI scene editor.\n\nThe Outline lists all the GUI’s content: it’s list of nodes and any dependencies (see below).\n\nThe central editing area shows the GUI. The toolbar in the top right corner of the editing area contains Move, Rotate and Scale tools, as well as a layout selector.\n\nA white rectangle shows the bounds of the currently selected layout, of the default display width and height as set in the project settings.\n\nSelecting the root “Gui” node in the Outline shows the Properties for the GUI component:\n\nYou can manipulate GUI properties in runtime from a script component using and :\n\nThe resource tree in a Defold game is static so any dependencies that you need for your GUI nodes need to be added to the component. The Outline groups all dependencies by type under “folders”:\n\nTo add a new dependency, the “Gui” root in the Outline, then select from the popup context menu.\n\nYou can also on the folder icon for the type you want to add and select .\n\nA GUI component is built from a set of nodes. Nodes are simple elements. They can be translated (moved, scaled and rotated) and ordered in parent-child hierarchies either in the editor or at runtime through scripting. The following node types exist:\n\nAdd nodes by right-clicking on the Nodes folder and selecting and then , , , or .\n\nYou can also press and select the type you want to add to the GUI.\n\nEach node has an extensive set of properties that control its appearance:\n\nThe combination of Pivot, Anchors and Adjust Mode properties allows for a very flexible design of GUIs but it can be somewhat hard to understand how it all works without looking at a concrete example. Let’s take this GUI mockup created for a 640x1136 screen as an example:\n\nThe UI is created with X and Y Anchors set to None and the Adjust Mode for each node is left at the default value of Fit. The Pivot point for the top panel is North, the pivot for the bottom panel is South and the pivot point for the bars in the top panel are set to West. The rest of the nodes have pivot points set to Center. If we resize the window to make it wider this is what happens:\n\nNow, what if we want the top and bottom bars to always be as wide as the screen? We can change the Adjust Mode for the grey background panels at the top and bottom to Stretch:\n\nThis is better. The grey background panels will now always stretch to the width of the window, but the bars in the top panel as well as the two boxes at the bottom aren’t positioned properly. If we want to keep the bars at the top positioned to the left we need to change the X Anchor from None to Left:\n\nThat is exactly as we want it for the top panel. The bars in the top panel already had their Pivot points set to West which means that they will position themselves nicely with the left/west edge of the bars (Pivot) anchored to the left edge of the parent panel (X Anchor).\n\nNow, if we set the X Anchor to Left for the box on the left and the X Anchor to Right for the box on the right we get the following result:\n\nThis is not quite the expected result. The two boxes should stay as close to the left and right edges as the two bars did in the top panel. The reason for this is that the Pivot point is wrong:\n\nBoth boxes have a Pivot point set to Center. What this means is that when the screen becomes wider the center point (the pivot point) of the boxes will stay at the same relative distance from the edges. In the case of the left box it was 17% from the left edge with the original 640x1136 window:\n\nWhen the screen is resized the center point of the left box remains at the same distance of 17% from the left edge:\n\nIf we change the Pivot point from Center to West for the box on the left and to East for the box on the right and reposition the boxes we get the result we’re after even when the screen is resized:\n\nAll nodes are rendered in the order they are listed under the “Nodes” folder. The node at the top of the list is drawn first and will thus appear behind every other node. The last node in the list is drawn last, meaning it will appear in front of all other nodes. Altering the Z-value on a node does not control its draw order; however, if you set the Z-value outside of your render script’s render range the node will no longer be rendered to screen. You can override the index ordering of nodes with layers (see below).\n\nSelect a node and press to move a node up or down and change its index order.\n\nThe draw order can be changed in script:\n\nA node is made the child of another node by dragging it onto the node that you wish to be the child’s parent. A node with a parent inherits the transform (position, rotation and scale) applied to the parent and relative to the parent pivot.\n\nParents are drawn before their children. Use layers to change the draw order of parent and child nodes and to optimize the rendering of nodes (see below).\n\nLayers give fine grained control over how nodes are drawn and can be used to reduce the number of draw calls the engine must create to draw a GUI scene. When the engine is about to draw the nodes of a GUI scene, it groups the nodes into draw call batches based on the following conditions:\n• The nodes must use the same type.\n• The nodes must use the same atlas or tile source.\n• The nodes must be rendered with the same blend mode.\n• They must use same font.\n\nIf a node differs from the previous one on any of these points, it will break the batch and create another draw call. Clipping nodes always break the batch and each stencil scope also breaks the batch.\n\nThe ability to arrange nodes in hierarchies makes it easy to group nodes into manageable units. But hierarchies can effectively break batch rendering if you mix different node types:\n\nWhen the rendering pipeline walks through the list of nodes, it is forced to set up a separate batch for each separate node because the types are different. All in all these three buttons will require six draw calls.\n\nBy assigning layers to the nodes, they can be ordered differently, allowing the render pipeline to group the nodes together in fewer draw calls. Start by adding the layers you need to the scene. the “Layers” folder icon in the Outline and select . Mark the new layer and assign it a Name property in the Properties view.\n\nThen set the Layer property on each node to the corresponding layer. The layer drawing order takes precedence over the regular indexed node order, so setting the button graphics box-nodes to “graphics” and the button text nodes to “text” will result in the following draw order:\n• First all nodes in the “graphics” layer, from the top:\n• Then all nodes in the “text” layer, from the top:\n\nThe nodes can now be batched into two draw calls, instead of six. A major performance win!\n\nNote that a child node with unset layer will implicitly inherit the layer setting of its parent node. Not setting a layer on a node implicitly adds it to the “null” layer, which is drawn before any other layer."
    }
]