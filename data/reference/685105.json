[
    {
        "link": "https://micro-os-plus.github.io/develop/sutter-101",
        "document": "C++ Coding Standards: 101 Rules, Guidelines, and Best Practices\n\nThis page reproduces content from the Summary of Summaries chapter of C++ Coding Standards: 101 Rules, Guidelines, and Best Practices, by Herb Sutter and Andrei Alexandrescu, published in 2005 by Pearson Education, Inc.\n\n0. Don’t sweat the small stuff. (Or: Know what not to standardize.)\n\nSay only what needs saying: Don’t enforce personal tastes or obsolete practices.\n\nTake warnings to heart: Use your compiler’s highest warning level. Require clean (warning-free) builds. Understand all warnings. Eliminate warnings by changing your code, not by reducing the warning level.\n\nPush the (singular) button: Use a fully automatic (“one-action”) build system that builds the whole project without user intervention.\n\nThe palest of ink is better than the best memory (Chinese proverb): Use a version control system (VCS). Never keep files checked out for long periods. Check in frequently after your updated unit tests pass. Ensure that checked-in code does not break the build.\n\nRe-view code: More eyes will help make more quality. Show your code, and read others’. You’ll all learn and benefit.\n\nFocus on one thing at a time: Prefer to give each entity (variable, class, function, namespace, module, library) one well-defined responsibility. As an entity grows, its scope of responsibility naturally increases, but its responsibility should not diverge.\n\n6. Correctness, simplicity, and clarity come first\n\nKISS (Keep It Simple Software): Correct is better than fast. Simple is better than complex. Clear is better than cute. Safe is better than insecure (see Items 83 and 99).\n\n7. Know when and how to code for scalability\n\nBeware of explosive data growth: Without optimizing prematurely, keep an eye on asymptotic complexity. Algorithms that work on user data should take a predictable, and preferably no worse than linear, time with the amount of data processed. When optimization is provably necessary and important, and especially if it’s because data volumes are growing, focus on improving big-Oh complexity rather than on micro-optimizations like saving that one extra addition.\n\nSpur not a willing horse (Latin proverb): Premature optimization is as addictive as it is unproductive. The first rule of optimization is: Don’t do it. The second rule of optimization (for experts only) is: Don’t do it yet. Measure twice, optimize once.\n\nEasy on yourself, easy on the code: All other things being equal, notably code complexity and readability, certain efficient design patterns and coding idioms should just flow naturally from your fingertips and are no harder to write than the pessimized alternatives. This is not premature optimization; it is avoiding gratuitous pessimization.\n\nSharing causes contention: Avoid shared data, especially global data. Shared data increases coupling, which reduces maintainability and often performance.\n\nDon’t tell: Don’t expose internal information from an entity that provides an abstraction.\n\n12. Know when and how to code for concurrency\n\nTh rea d : If your application uses multiple threads or processes, know how to minimize sharing objects where possible (see Item 10) and share the right ones safely.\n\n13. Ensure resources are owned by objects. Use explicit RAII and smart pointers.\n\nDon’t saw by hand when you have power tools: C++’s “resource acquisition is initialization” (RAII) idiom is the power tool for correct resource handling. RAII allows the compiler to provide strong and automated guarantees that in other languages require fragile hand-coded idioms. When allocating a raw resource, immediately pass it to an owning object. Never allocate more than one resource in a single statement.\n\nDon’t put off ’til run time what you can do at build time: Prefer to write code that uses the compiler to check for invariants during compilation, instead of checking them at run time. Run-time checks are control- and data-dependent, which means you’ll seldom know whether they are exhaustive. In contrast, compile-time checking is not control- or data-dependent and typically offers higher degrees of confidence.\n\nis your friend: Immutable values are easier to understand, track, and reason about, so prefer constants over variables wherever it is sensible and make your default choice when you define a value: It’s safe, it’s checked at compile time (see Item 14), and it’s integrated with C++’s type system. Don’t cast away except to call a const-incorrect function (see Item 94).\n\nTO PUT IT BLUNTLY: Macros are the bluntest instrument of C and C++’s abstraction facilities, ravenous wolves in functions’ clothing, hard to tame, marching to their own beat all over your scopes. Avoid them.\n\nProgramming isn’t magic, so don’t incant it: Avoid spelling literal constants like or in code. They are not self-explanatory and complicate maintenance by adding a hard-to-detect form of duplication. Use symbolic names and expressions instead, such as .\n\n18. Declare variables as locally as possible\n\nAvoid scope bloat, as with requirements so too with variables: Variables introduce state, and you should have to deal with as little state as possible, with lifetimes as short as possible. This is a specific case of Item 10 that deserves its own treatment.\n\nStart with a clean slate: Uninitialized variables are a common source of bugs in C and C++ programs. Avoid such bugs by being disciplined about cleaning memory before you use it; initialize variables upon definition.\n\nShort is better than long, flat is better than deep: Excessively long functions and nested code blocks are often caused by failing to give one function one cohesive responsibility (see Item 5), and both are usually solved by better refactoring.\n\nKeep (initialization) order: Namespace-level objects in different compilation units should never depend on each other for initialization, because their initialization order is undefined. Doing otherwise causes headaches ranging from mysterious crashes when you make small changes in your project to severe nonportability even to new releases of the same compiler.\n\nDon’t be over-dependent: Don’t a definition when a forward declaration will do.\n\nDon’t be co-dependent: Cyclic dependencies occur when two modules depend directly or indirectly on one another. A module is a cohesive unit of release (see page 103); modules that are interdependent are not really individual modules, but super-glued together into what’s really a larger module, a larger unit of release. Thus, cyclic dependencies work against modularity and are a bane of large projects. Avoid them.\n\nBehave responsibly: Ensure that each header you write is compilable standalone, by having it include any headers its contents depend upon.\n\nWear head(er) protection: Prevent unintended multiple inclusions by using guards with unique names for all of your header files.\n\n25. Take parameters appropriately by value, (smart) pointer, or reference\n\nParametrize well: Distinguish among input, output, and input/output parameters, and between value and reference parameters. Take them appropriately.\n\nProgrammers hate surprises: Overload operators only for good reason, and preserve natural semantics; if that’s difficult, you might be misusing operator overloading.\n\n27. Prefer the canonical forms of arithmetic and assignment operators\n\nIf you , also : When defining binary arithmetic operators, provide their assignment versions as well, and write to minimize duplication and maximize efficiency.\n\n28. Prefer the canonical form of and . Prefer calling the prefix forms\n\nIf you , also : The increment and decrement operators are tricky because each has pre- and postfix forms, with slightly different semantics. Define and such that they mimic the behaviour of their built-in counterparts. Prefer to call the prefix versions if you don’t need the original value.\n\nDo not multiply objects beyond necessity (Occam’s Razor): Implicit type conversions provide syntactic convenience (but see Item 40). But when the work of creating temporary objects is unnecessary and optimization is appropriate (see Item 8), you can provide overloaded functions with signatures that match common argument types exactly and won’t cause conversions.\n\nWisdom means knowing when to refrain: The built-in , and (comma) enjoy special treatment from the compiler. If you overload them, they become ordinary functions with very different semantics (you will violate Items 26 and 31), and this is a sure way to introduce subtle bugs and fragilities. Don’t overload these operators naïvely.\n\n31. Don’t write code that depends on the order of evaluation of function arguments\n\nKeep (evaluation) order: The order in which arguments of a function are evaluated is unspecified, so don’t rely on a specific ordering.\n\n32. Be clear what kind of class you’re writing\n\nKnow thyself: There are different kinds of classes. Know which kind you are writing.\n\nDivide and conquer: Small classes are easier to write, get right, test, and use. They are also more likely to be usable in a variety of situations. Prefer such small classes that embody simple concepts instead of kitchen-sink classes that try to implement many and/or complex concepts (see Items 5 and 6).\n\nAvoid inheritance taxes: Inheritance is the second-tightest coupling relationship in C++, second only to friendship. Tight coupling is undesirable and should be avoided where possible. Therefore, prefer composition to inheritance unless you know that the latter truly benefits your design.\n\n35. Avoid inheriting from classes that were not designed to be base classes\n\nSome people don’t want to have kids: Classes meant to be used standalone obey a different blueprint than base classes (see Item 32). Using a standalone class as a base is a serious design error and should be avoided. To add behaviour, prefer to add non-member functions instead of member functions (see Item 44). To add state, prefer composition instead of inheritance (see Item 34). Avoid inheriting from concrete base classes.\n\nLove abstract art: Abstract interfaces help you focus on getting an abstraction right without muddling it with implementation or state management details. Prefer to design hierarchies that implement abstract interfaces that model abstract concepts.\n\n37. Public inheritance is substitutability. Inherit, not to reuse,but to be reused\n\nKnow what: Public inheritance allows a pointer or reference to the base class to actually refer to an object of some derived class, without destroying code correctness and without needing to change existing code. Know why: Don’t inherit publicly to reuse code (that exists in the base class); inherit publicly in order to be reused (by existing code that already uses base objects polymorphically).\n\nOverride responsibly: When overriding a virtual function, preserve substitutability; in particular, observe the function’s pre- and post-conditions in the base class. Don’t change default arguments of virtual functions. Prefer explicitly redeclaring overrides as virtual. Beware of hiding overloads in the base class.\n\nIn base classes with a high cost of change (particularly ones in libraries and frameworks): Prefer to make public functions nonvirtual. Prefer to make virtual functions private, or protected if derived classes need to be able to call the base versions. (Note that this advice does not apply to destructors; see Item 50.)\n\nNot all change is progress: Implicit conversions can often do more damage than good. Think twice before providing implicit conversions to and from the types you define, and prefer to rely on explicit conversions ( constructors and named conversion functions).\n\nThey’re none of your caller’s business: Keep data members private. Only in the case of simple C-style types that aggregate a bunch of values but don’t pretend to encapsulate or provide behaviour, make all data members public. Avoid mixes of public and nonpublic data, which almost always signal a muddled design.\n\nDon’t volunteer too much: Avoid returning handles to internal data managed by your class, so clients won’t uncontrollably modify state that your object thinks it owns.\n\nOvercome the language’s separation anxiety: C++ makes private members inaccessible, but not invisible. Where the benefits warrant it, consider making private members truly invisible using the Pimpl idiom to implement compiler firewalls and increase information hiding. (See Items 11 and 41.)\n\n45. Always provide and together\n\nThey’re a package deal: Every class-specific overload must be accompanied by a corresponding overload , where is a list of extra parameter types (of which the first is always ). The same goes for the array forms and .\n\n46. If you provide any class-specific , provide all of the standard forms (plain, in-place, and )\n\nDon’t hide good s: If a class defines any overload of , it should provide overloads of all three of plain, in-place, and non-throwing . If you don’t, they’ll be hidden and unavailable to users of your class.\n\n47. Define and initialize member variables in the same order\n\nAgree with your compiler: Member variables are always initialized in the order they are declared in the class definition; the order in which you write them in the constructor initialization list is ignored. Make sure the constructor code doesn’t confusingly specify a different order.\n\nSet once, use everywhere: In constructors, using initialization instead of assignment to set member variables prevents needless run-time work and takes the same amount of typing.\n\nVirtual functions only “virtually” always behave virtually: Inside constructors and destructors, they don’t. Worse, any direct or indirect call to an unimplemented pure virtual function from a constructor or destructor results in undefined behaviour. If your design wants virtual dispatch into a derived class from a base class constructor or destructor, you need other techniques such as post-constructors.\n\n50. Make base class destructors public and virtual, or protected and nonvirtual\n\nTo delete, or not to delete; that is the question: If deletion through a pointer to a base Base should be allowed, then Base’s destructor must be public and virtual. Otherwise, it should be protected and nonvirtual\n\nEverything they attempt shall succeed: Never allow an error to be reported from a destructor, a resource deallocation function (e.g., ), or a swap function. Specifically, types whose destructors may throw an exception are flatly forbidden from use with the C++ standard library.\n\nWhat you create, also clean up: If you define any of the copy constructor, copy assignment operator, or destructor, you might need to define one or both of the others.\n\nCopy consciously: Knowingly choose among using the compiler-generated copy constructor and assignment operator, writing your own versions, or explicitly disabling both if copying should not be allowed.\n\n54. Avoid slicing. Consider in stead of copying in base classes\n\nSliced bread is good; sliced objects aren’t: Object slicing is automatic, invisible, and likely to bring wonderful polymorphic designs to a screeching halt. In base classes, consider disabling the copy constructor and copy assignment operator, and instead supplying a virtual member function if clients need to make polymorphic (complete, deep) copies.\n\nYour assignment: When implementing , prefer the canonical form—nonvirtual and with a specific signature.\n\n56. Whenever it makes sense, provide a no-fail swap (and provide it correctly)\n\nis both a lightweight and a workhorse: Consider providing a function to efficiently and infallibly swap the internals of this object with another’s. Such a function can be handy for implementing a number of idioms, from smoothly moving objects around to implementing assignment easily to providing a guaranteed commit function that enables strongly error-safe calling code. (See also Item 51.)\n\n57. Keep a type and its nonmember function interface in the same namespace\n\nNonmembers are functions too: Nonmember functions that are designed to be part of the interface of a class X (notably operators and helper functions) must be defined in the same namespace as the X in order to be called correctly.\n\n58. Keep types and functions in separate namespaces unless they’re specifically intended to work together\n\nHelp prevent name lookup accidents: Isolate types from unintentional argument-dependent lookup (ADL, also known as Koenig lookup), and encourage intentional ADL, by putting them in their own namespaces (along with their directly related nonmember functions; see Item 57). Avoid putting a type into the same namespace as a templated function or operator.\n\n59. Don’t write namespace s in a header file or before an\n\nNamespace s are for your convenience, not for you to inflict on others: Never write a using declaration or a directive before an directive.\n\nCorollary: In header files, don’t write namespace-level directives or declarations; instead, explicitly namespace-qualify all names. (The second rule follows from the first, because headers can never know what other header might appear after them.)\n\n60. Avoid allocating and deallocating memory in different modules\n\nPut things back where you found them: Allocating memory in one module and deallocating it in a different module makes your program fragile by creating a subtle long-distance dependency between those modules. They must be compiled with the same compiler version and same flags (notably debug vs. ) and the same standard library implementation, and in practice the module allocating the memory had better still be loaded when the deallocation happens.\n\nRepetition causes bloat: Entities with linkage, including namespace-level variables or functions, have memory allocated for them. Defining such entities in header files results in either link-time errors or memory waste. Put all entities with linkage in implementation files.\n\n62. Don’t allow exceptions to propagate across module boundaries\n\nDon’t throw stones into your neighbour’s garden: There is no ubiquitous binary standard for C++ exception handling. Don’t allow exceptions to propagate between two pieces of code unless you control the compiler and compiler options used to build both sides; otherwise, the modules might not support compatible implementations for exception propagation. Typically, this boils down to: Don’t let exceptions propagate across module/subsystem boundaries.\n\nTake extra care when living on the edge (of a module): Don’t allow a type to appear in a module’s external interface unless you can ensure that all clients understand the type correctly. Use the highest level of abstraction that clients can understand.\n\nSo much more than a mere sum of parts: Static and dynamic polymorphism are complementary. Understand their tradeoffs, use each for what it’s best at, and mix them to get the best of both worlds.\n\nIntentional is better than accidental, and explicit is better than implicit: When writing a template, provide points of customization knowingly and correctly, and document them clearly. When using a template, know how the template intends for you to customize it for use with your type, and customize it appropriately.\n\nSpecialization is good only when it can be done correctly: When extending someone else’s function template (including ), avoid trying to write a specialization; instead, write an overload of the function template, and put it in the namespace of the type(s) the overload is designed to be used for. (See Item 57.) When you write your own function template, avoid encouraging direct specialization of the function template itself.\n\nCommit to abstractions, not to details: Use the most generic and abstract means to implement a piece of functionality.\n\nBe assertive! Use or an equivalent liberally to document assumptions internal to a module (i.e., where the caller and callee are maintained by the same person or team) that must always be true and otherwise represent programming errors (e.g., violations of a function’s postconditions detected by the caller of the function). (See also Item 70.) Ensure that assertions don’t perform side effects.\n\nConsciously specify, and conscientiously apply, what so many projects leave to ad-hoc (mis)judgment: Develop a practical, consistent, and rational error handling policy early in design, and then stick to it. Ensure that it includes:\n• Severity: How important or urgent each error is.\n• Detection: Which code is responsible for detecting the error.\n• Propagation: What mechanisms are used to report and propagate error notifications in each module.\n• Handling: What code is responsible for doing something about the error.\n• Reporting: How the error will be logged or users notified. Change error handling mechanisms only on module boundaries.\n\nA breach of contract is an error: A function is a unit of work. Thus, failures should be viewed as errors or otherwise based on their impact on functions. Within a function , a failure is an error if and only if it violates one of ’s preconditions or prevents from meeting any of its callees’ preconditions, achieving any of ’s own postconditions, or re-establishing any invariant that shares responsibility for maintaining.\n\nIn particular, here we exclude internal programming errors (i.e., where the caller and callee are the responsibility of the same person or team, such as inside a module), which are a separate category normally dealt with using assertions (see Item 68).\n\nPromise, but don’t punish: In each function, give the strongest safety guarantee that won’t penalize callers who don’t need it. Always give at least the basic guarantee.\n\nEnsure that errors always leave your program in a valid state. This is the basic guarantee. Beware of invariant-destroying errors (including but not limited to leaks), which are just plain bugs.\n\nPrefer to additionally guarantee that the final state is either the original state (if there was an error the operation was rolled back) or the intended target state (if there was no error the operation was committed). This is the strong guarantee.\n\nPrefer to additionally guarantee that the operation can never fail at all. Although this is not possible for most functions, it is required for functions like destructors and deallocation functions. This is the no-fail guarantee.\n\n72. Prefer to use exceptions to report errors\n\nWhen harmed, take exception: Prefer using exceptions over error codes to report errors. Use status codes (e.g., return codes, ) for errors when exceptions cannot be used (see Item 62), and for conditions that are not errors. Use other methods, such as graceful or ungraceful termination, when recovery is impossible or not required.\n\n73. Throw by value, catch by reference\n\nLearn to properly: Throw exceptions by value (not pointer) and catch them by reference (usually to ). This is the combination that meshes best with exception semantics. When rethrowing the same exception, prefer just ; to ;.\n\nKnow when to say when: Report errors at the point they are detected and identified as errors. Handle or translate each error at the nearest level that can do it correctly.\n\nTake exception to these specifications: Don’t write exception specifications on your functions unless you’re forced to (because other code you can’t change has already introduced them; see Exceptions).\n\n76. Use vector by default. Otherwise, choose an appropriate container\n\nUsing the “right container” is great: If you have a good reason to use a specific container type, use that container type knowing that you did the right thing.\n\nSo is using : Otherwise, write and keep going without breaking stride, also knowing you did the right thing.\n\n77. Use and instead of arrays\n\nWhy juggle Ming vases? Avoid implementing array abstractions with C-style arrays, pointer arithmetic, and memory management primitives. Using or not only makes your life easier, but also helps you write safer and more scalable software.\n\n78. Use (and ) to exchange data with non-C++ APIs\n\nisn’t lost in translation: and are your gateway to communicate with non-C++ APIs. But don’t assume iterators are pointers; to get the address of the element referred to by a , use .\n\n79. Store only values and smart pointers in containers\n\nStore objects of value in containers: Containers assume they contain value-like types, including value types (held directly), smart pointers, and iterators.\n\n80. Prefer push back to other ways of expanding a sequence\n\npush back all you can: If you don’t need to care about the insert position, prefer using push back to add an element to a sequence. Other means can be both vastly slower and less clear.\n\nDon’t use oars when the wind is fair (based on a Latin proverb): When adding elements to sequence containers, prefer to use range operations (e.g., the form of insert that takes a pair of iterators) instead of a series of calls to the single-element form of the operation. Calling the range operation is generally easier to write, easier to read, and more efficient than an explicit loop. (See also Item 84.)\n\n82. Use the accepted idioms to really shrink capacity and really erase elements\n\nUse a diet that works: To really shed excess capacity from a container, use the “swap trick.” To really erase elements from a container, use the erase-remove idiom.\n\nSafety first (see Item 6): Use a checked STL implementation, even if it’s only available for one of your compiler platforms, and even if it’s only used during pre-release testing.\n\nUse function objects judiciously: For very simple loops, handwritten loops can be the simplest and most efficient solution. But writing algorithm calls instead of handwritten loops can be more expressive and maintainable, less error-prone, and as efficient.\n\nWhen calling algorithms, consider writing your own custom function object that encapsulates the logic you need. Avoid cobbling together parameter-binders and simple function objects (e.g., , ), which usually degrade clarity. Consider trying the [Boost] Lambda library, which automates the task of writing function objects.\n\n85. Use the right STL search algorithm\n\nSearch “just enough”—the right search may be STL (slower than light), but it’ll still be pretty fast: This Item applies to searching for a particular value in a range, or for the location where it would be if it were in the range. To search an unsorted range, use / or / . To search a sorted range, use lower bound, upper bound, equal range, or (rarely) binary search. (Despite its common name, binary search is usually not the right choice.)\n\n86. Use the right STL sort algorithm\n\nSort “just enough:” Understand what each of the sorting algorithms does, and use the cheapest algorithm that does what you need.\n\nPredicate purity: A predicate is a function object that returns a yes/no answer, typically as a value. A function is pure in the mathematical sense if its result depends only on its arguments (note that this use of “pure” has nothing to do with pure virtual functions).\n\nDon’t allow predicates to hold or access state that affects the result of their , including both member and global state. Prefer to make a member function for predicates (see Item 15).\n\n88. Prefer function objects over functions as algorithm and comparer arguments\n\nObjects plug in better than functions: Prefer passing function objects, not functions, to algorithms. Comparers for associative containers must be function objects. Function objects are adaptable and, counterintuitively, they typically produce faster code than functions.\n\nBe cheap, be adaptable: Design function objects to be values that are cheap to copy. Where possible, make them adaptable by inheriting from - or .\n\nSwitch off: Avoid switching on the type of an object to customize behaviour. Use templates and virtual functions to let types (not their calling code) decide their behaviour.\n\n91. Rely on types, not on representations\n\nDon’t try to X-ray objects (see Item 96): Don’t make assumptions about how objects are exactly represented in memory. Instead, let types decide how their objects are written to and read from memory.\n\nLies have short legs (German and Romanian proverb): Don’t try to use to force the compiler to reinterpret the bits of an object of one type as being the bits of an object of a different type. That’s the opposite of maintaining type safety, and isn’t even guaranteed to do that or anything else in particular.\n\nPointers to dynamic objects don’t static cast: Safe alternatives range from using dynamic cast to refactoring to redesigning.\n\nSome fibs are punishable: Casting away const sometimes results in undefined behaviour, and it is a staple of poor programming style even when legal.\n\nAge doesn’t always imply wisdom: C-style casts have different (and often dangerous) semantics depending on context, all disguised behind a single syntax. Replacing C-style casts with C++-style casts helps guard against unexpected errors.\n\nDon’t try to X-ray objects (see Item 91): Don’t use memcpy and memcmp to copy or compare anything more structured than raw memory.\n\nA deceit is still a lie: Unions can be abused into obtaining a “cast without a cast” by writing one member and reading another. This is more insidious and even less predictable than (see Item 92).\n\nEllipses cause collapses: The ellipsis is a dangerous carryover from C. Avoid varargs, and use higher-level C++ constructs and libraries instead.\n\nDon’t use expired medicines: Both invalid objects and historical but unsafe functions wreak havoc on your program’s health.\n\nArrays are ill-adjusted: Treating arrays polymorphically is a gross type error that your compiler will probably remain silent about. Don’t fall into the trap."
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/d2ywm0/c_mortgage_calculator_nanind",
        "document": "I had to make a mortgage calculator for my C++ OOP class. Every time I run it I receive a -nan(ind) as the result for the calculation. I've seen that this means something is getting divided by zero but I can't figure what I need to change in order to get the correct calculation. Any help would be greatly appreciated. Link to code\n\nThis was the assignment.\n\nDesign a class that will determine the monthly payment on a home mortgage. The program should calculate and display the mortgage payment amount, given the amount of the mortgage, the term of the mortgage, and the interest rate of the mortgage. Calculate the monthly payment for the amount = $200,000, the term = 30 years, and the interest rate = 4.5% which you get from user. Insert comments in the program to document the program. To use pow (power function) you need to include the #include<cmath>. The class should have member functions for setting and getting the loan amount, interest rate, and number of years of the loan. It should also have member functions for returning the monthly payment amount and the total amount paid to the bank at the end of the loan period, Implement the class in complete program.\n\nInput validation: Do not accept negative numbers for any of the loan values.\n\nHere is the guide for the Mortgage Calculator program; you can use the following formula:"
    },
    {
        "link": "https://issamvb.medium.com/10-best-practices-to-design-and-implement-a-c-class-4326611827e1",
        "document": "1- Try using new C++ standards as possible\n\nBy 2011, C++ had been in use for more than 30 years. It was not easy to convince developers that the new C++ standards actually simplified many frustrating facets of C++ usage and that there was a new modern way to improve the C++ Code.\n\nLet’s take memory management as an example, which is maybe the most criticized mechanism in C++. For many years the object allocation was done by the new keyword, and the developer must never forget to invoke delete somewhere in the code. The “Modern C++” resolved this issue and promotes the use of a shared pointer.\n\nModern C++ libraries use extensively the namespaces to modularize their codebase, and they use the “Namespace-by-feature” approach. Namespace-by-feature uses namespaces to reflect the feature set. It places all items related to a single feature (and only that feature) into a single namespace. This results in namespaces with high cohesion and high modularity, and with minimal coupling between namespaces. Items that work closely together are placed next to each other.\n\nBoost is the best example of grouping by feature, it contains thousands of namespaces, each one is used to group a specific feature.\n\nData abstraction is one of the most essential and important features of object-oriented programming in C++. Abstraction means displaying only essential information and hiding the details. Data abstraction refers to providing only essential information about the data to the outside world, hiding the background details or implementation.\n\nEven if this best practice is recommended by many books, web resources, conference speakers, experts. However, in many projects, this rule is ignored and we can have many class details not hidden.\n\nTypes with many lines of code should be split into a group of smaller types.\n\nTo refactor a big Class you’ll need patience, and you might even need to recreate everything from scratch. Here is some refactoring advice:\n• The logic in the BigClass must be split into smaller classes. These smaller classes can eventually become private classes nested in the original God Class, whose instances objects become composed of instances of smaller nested classes.\n• Smaller class partitioning should be driven by the multiple responsibilities handled by the God Class. To identify these responsibilities it often helps to look for subsets of methods strongly coupled with subsets of fields.\n• If the Big Class contains way more logic than states, a good option can be to define one or several static classes that contains no static field but only pure static methods. A pure static method is a function that computes a result only from inputs parameters, it doesn’t read nor assign any static or instance field. The main advantage of pure static methods is that they are easily testable.\n• Try to maintain the interface of the Big Class at first and delegate calls to the new extracted classes. In the end, the Big Class should be a pure facade without its own logic. Then you can keep it for convenience or throw it away and start to use the new classes only.\n• Unit Tests can help: write tests for each method before extracting it to ensure you don’t break functionality.\n\n5- Few methods per class as you can\n\nTypes with more than 20 methods might be hard to understand and maintain.\n\nHaving many methods for a type might be a symptom of too many responsibilities implemented.\n\nMaybe you are facing a class that controls way too many other classes in the system and has grown beyond all logic to become The Class That Does Everything.\n\nLow coupling is desirable because a change in one area of an application will require fewer changes throughout the entire application. In the long run, this could alleviate a lot of time, effort, and cost associated with modifying and adding new features to an application.\n\nLow coupling could be achieved by using abstract classes or using generic types and methods.\n\nThe single responsibility principle states that a class should not have more than one reason to change. Such a class is said to be cohesive. A high LCOM value generally pinpoints a poorly cohesive class. There are several LCOM metrics. The LCOM takes its values in the range [0–1]. The LCOM HS (HS stands for Henderson-Sellers) takes its values in the range [0–2]. A LCOM HS value highest than 1 should be considered alarming. Here are to compute LCOM metrics:\n• M is the number of methods in class (both static and instance methods are counted, it includes also constructors, properties getters/setters, events add/remove methods).\n• F is the number of instance fields in the class.\n• MF is the number of methods of the class accessing a particular instance field.\n• Sum(MF) is the sum of MF over all instance fields of the class.\n\nThe underlying idea behind these formulas can be stated as follow: a class is utterly cohesive if all its methods use all its methods use all its instance fields, which means that sum(MF)=M*F and then LCOM = 0 and LCOMHS = 0.\n\nLCOMHS value higher than 1 should be considered alarming.\n\n8- Comment only what the code cannot say\n\nComments that parrot the code offer nothing extra to the reader. A prevalence of noisy comments and incorrect comments in a codebase encourages programmers to ignore all comments, either by skipping past them or by taking active measures to hide them.\n\n9- Don’t repeat yourself as possible\n\nIt’s known that the presence of duplicate code has negative impacts on software development and maintenance. Indeed a major drawback is when an instance of duplicate code is changed for fixing bugs or adding new features, its correspondents have to be changed simultaneously.\n\nThe most popular reason for duplicate code is the Copy/Paste operations, and in this case, the source code is exactly similar in two or more places, this practice is discouraged in many articles, books, and websites. However, sometimes it’s not easy to practice the recommendations, and the developer chose the easy solution: the Copy/Paste method.\n\nUsing the appropriate tool makes easy the detection of the duplicate code from the copy/paste operations, however, there are some cases where cloned code is not trivial to detect.\n\n10- Immutability is your friend for multithreading programming.\n\nBasically, an object is immutable if its state doesn’t change once the object has been created. Consequently, a class is immutable if its instances are immutable.\n\nThere is one important argument in favor of using immutable objects: It dramatically simplifies concurrent programming. Think about it, why does writing proper multithreaded programming is a hard task? Because it is hard to synchronize threads access to resources (objects or others OS resources). Why it is hard to synchronize these accesses? Because it is hard to guarantee that there won’t be race conditions between the multiple write accesses and read accesses done by multiple threads on multiple objects. What if there are no more write accesses? In other words, what if the state of the objects accessed by threads, doesn’t change? There is no more need for synchronization!\n\nAnother benefit about immutable classes is that they can never violate LSP (Liskov Subtitution Principle) , here’s a definition of LSP quoted from its wiki page:\n\nThe Class of the object referenced is immutable if it has no public fields, no methods that can change its internal data, and no way for methods of the derived class to change its internal data. And because the value cannot change, it’s possible to reference the same object in all cases. There’s no need to have a copy constructor or assignment operator. For this reason, it’s recommended to make the copy constructor and assignment operator private, inherit from boost::noncopyable, or use the new C++11 feature “Explicitly defaulted and deleted special member functions“.\n\nHow to enforce the check of these best practices?\n\nCppDepend provides a code query language named CQLinq to query the code base like a database. Developers, designers, and architects could define their custom queries to find easily the bug-prone situations.\n\nWith CQlinq we can combine the data from the code metrics, dependencies, API usage, and other model data to define very advanced queries that match some bug-prone situations.\n\nFor example, after the analysis of the clang source code, we can detect the big classes:"
    },
    {
        "link": "https://amazon.com/Coding-Standards-Rules-Guidelines-Practices/dp/0321113586",
        "document": "Enter the characters you see below\n\nSorry, we just need to make sure you're not a robot. For best results, please make sure your browser is accepting cookies."
    },
    {
        "link": "https://devcom.com/tech-blog/coding-standards-and-best-practices-guide-implementation-tips",
        "document": "Coding standards are something that each development team should consider. Without standardization, engineers can stitch code together in their own style. Collaboration stalls as your team wastes hours untangling each other’s logic and rewriting after each other. As a result, the delays grow, costs soar, and your technical debt increases.\n\nThis guide explains how globally accepted programming standards, rules, and guidelines can overcome these problems. We will describe the best conventions and practices that can make your development process faster and code cleaner. Finally, we’ll tell you how you can start integrating good coding standards step-by-step without overburdening your teams.\n\nCoding standards are rules, conventions, and guidelines that dictate how to produce code. They provide a consistent framework for development teams to write, format, and organize software code across projects in a way that’s high-quality, secure, maintainable, and scalable.\n\nWith the proper implementation, these standards can greatly improve larger teams’ workflow, productivity, and privacy compliance.\n\nCoding standards are essential because they simplify and organize every stage of the software development lifecycle and IT operations:\n• Software development. Coding standards in software engineering make code consistent across several development teams, making it easier to follow and debug.\n• Testing and quality assurance (QA). tandards ensure consistency in naming, formatting, and structure, helping developers write quality unit tests. This helps the testers to validate the individual units (functions, classes, modules) of the code.\n• Project management. With a standardized codebase, project managers can more accurately track key performance indicators (KPIs) across modules, sprints, and teams.\n• Knowledge sharing. A common set of coding rules and practices ensures team members are on the same page. Besides, new employees don’t have to spend too much time learning inconsistent practices.\n\nTo illustrate the importance of coding standards, let’s look at the advantages they can bring.\n\nDon’t think of coding standards as limitations. Instead, look at them as guidance that makes the development process more manageable in the long run. Coding standards within developer teams offer far-reaching benefits to your organization, such as:\n• Improved consistency. When developers adhere to a unified set of standards, the codebase becomes more consistent. This reduces the likelihood of errors introduced by conflicting practices, leading to a more reliable release.\n• Higher code quality. Coding standards often include best practices for error handling, input validation, and resource management.\n• Increased efficiency. Developers and testers can improve their productivity because they will spend less time correcting inconsistent and duplicate code.\n• Faster onboarding. New developers can become more productive if your codebase adheres to familiar standards. Similarly, if a team member leaves, the standardized code allows others to continue the work seamlessly.\n• Improved security and compliance. Secure coding practices embedded in the development can mitigate vulnerabilities and help adhere to data privacy regulations, including GDPR. Meanwhile, thorough documentation makes it easier to prepare for security and compliance audits.\n• Enhanced scalability. By following coding conventions, you can make your software more optimized and modular. It will help the product handle increased workloads and allow you to scale components independently when needed.\n• Reduced technical debt. Technical debt refers to the long-term consequences of choosing shortcuts that lead to rework later. Good coding practices make your codebase future-ready, predictable, and easier to modify, lowering maintenance costs.\n• Long-term savings. The cost savings come from improved productivity, less rework, lower maintenance costs, and fewer risks of non-compliance.\n\nNow, let’s look at the fundamental components of coding standards, which are more or less applicable to any organization.\n\nAspects are the building blocks of coding standards. Understanding them is essential for establishing an efficient pipeline that addresses all critical areas of development.\n\nNaming conventions are a foundational element of coding standards. Purposeful names make the code much easier to modify and troubleshoot, especially in large projects.\n\nThere is quite a selection of naming conventions you can choose. They include:\n• Camel case: Words are joined together without spaces, starting with a lowercase letter, and the subsequent words are capitalized (\n• Snake case: Names are all lowercase, and words are separated by underscores (\n• Kebab case: Similar to snake case, but words are separated by hyphens (\n• Pascal case: Every word starts with an uppercase letter (\n• Descriptive and purposeful names for code elements, such as variables, functions, and classes. For example, a variable is self-explanatory compared to a vague name like\n• Constants (values that don’t change during the execution of a program) are usually named in uppercase letters with underscores to distinguish them from other variables. For example, for the upper limit of allowed connections in a system.\n• Local variables are defined and used within a specific function or block in camel case.\n• Function names are usually written in camel case, starting with a lowercase letter.\n\nConsistent formatting is about making the code look organized and easier to understand. After all, you want the programmers to have an easier time understanding it.\n• Whitespace (spaces, tabs, and line breaks) can help separate different parts of code, letting you visually organize it in a consistent structure.\n• Indentation is a whitespace that visually maps the nesting and hierarchy in the code, basically helping you show the relationships between parent-child elements (in conditions, loops, classes, etc.).\n• Restricted line length to about 120 characters prevents horizontal scrolling, making the code easily viewable on different devices.\n• Code spacing goes a long way to make code human-readable, which programmers will be thankful for.\n• Smaller and reusable functions are much easier to understand and maintain than deeply nested code.\n\nThe commentary explains the purpose and reasoning behind the code segment. It’s invaluable for other developers when the context isn’t immediately apparent from the code itself.\n\nWe also recommend avoiding redundant notes that merely repeat something that’s evident from the code. As a rule, comments should be for non-obvious segments, business logic explanations, regulatory requirements, and workarounds. Alternatively, they could point to areas for improvement.\n• Place inline comments in the same line or immediately above the code it refers to.\n• Reduce redundant comments that restate something already expressed with the code.\n• Remove temporary comments used for debugging or troubleshooting once resolved.\n• Use specialized tools for external documentation , such as Javadoc for Java, Doxygen for C++, or Docstrings for Python.\n• Add headers with detailed information on how to use certain headers (module headers).\n\nYou should standardize error-handling practices for consistent responses to errors across all parts of the application. It enables your teams to deal with unexpected issues and runtime anomalies without disrupting user experience or causing system failures.\n• Use try-catch blocks to manage errors and exceptions. Try blocks are used for sections of code where errors are expected, and catch blocks contain the logic to handle it (so the system doesn’t crash).\n• Log errors with meaningful messages , such as timestamps, error types, stack traces, and other contexts. Additionally, use structured formats (like JSON) for easier parsing.\n• Configure standardized error return values for your functions, such as for success. This practice will reduce ambiguity when analyzing logs and debugging.\n• Include an auto-recovery mechanism , such as retrying operations after a short delay, to minimize the impact of transient issues (like network outages).\n\nStandardized control systems provide a structured way to manage the codebase. They allow dev teams to track code changes and work simultaneously without overwriting each other’s work.\n• Write descriptive commit messages in version control explaining the changes’ purpose and scope. You should enforce a consistent format (like a short summary followed by a detailed description if necessary).\n• Use a consistent branching strategy within a version control system. For instance, in Gitflow, the system is usually divided into Master, Developer, Feature, Release, and Hotfix branches.\n• Enforce code reviews before integrating changes into the main codebase. It’s best to focus on reviewing smaller changes frequently instead of going through massive pull requests.\n• Backup code regularly using automated tools to keep all relevant versions.\n• Measure the impact of changes by tracking metrics like the number of bugs resolved, reduction in technical debt, and time spent on reviewing the code.\n\nCompanies must incorporate secure coding guidelines to build a proactive defense against vulnerabilities and adhere to strict data privacy laws.\n• Use input validation systems to prevent malicious actors from injecting harmful commands into your system. All user-provided inputs should adhere to expected formats and boundaries.\n• Encrypt sensitive data to ensure that all credentials and personally identifiable information (passwords, payment details, health records, etc.) are accessible only to authorized users.\n• Don’t hardcode secrets , such as passwords and API keys, directly in the codebase. These variables and credentials should always be stored in secure environments.\n• Enforce the principle of least privilege , granting users the minimum level of access necessary to perform their coding tasks.\n\nFocus on writing and structuring code for efficiency and resource management to minimize latency and system overhead.\n• Use profiling to find code sections that cause the most delays. This is about focusing on parts of the code that cause the most latency and avoiding those that don’t impact performance significantly.\n• Minimize lines of code , rewriting complex segments into shorter equivalents. Examples include replacing loops with vectorized operations or using anonymous functions for simple processes instead of full functions.\n• Use efficient algorithms with lower time complexity. For example, using a hash table for lookups (instead of a list) can reduce the search times.\n• Use green coding practices that involve writing code in a way that minimizes energy consumption. It will not just enhance the performance but also improve sustainability.\n\nWith the key foundations out of the way, let’s look at the principles that work across programming languages and frameworks.\n\nUnderstanding these widely recognized standards helps developers align their code with industry expectations.\n\nThe DRY principle emphasizes reducing duplication in code. Instead of copying and pasting similar code in multiple places, developers should abstract repeated logic into reusable components like functions, classes, or modules. If multiple modules perform the same data validation, you should create a validation function that all modules use.\n\nYou can use inheritance and composition to reduce duplication. In object-oriented programming, inheritance allows a class to inherit properties from a parent class. Composition involves building classes that contain instances of other classes.\n\nSystems work best when they are kept simple rather than made complex. In other words, it’s about avoiding unnecessary complexity and over-engineering.\n\nResist the temptation to add unnecessary layers of abstraction. Opt for the simplest algorithms that accomplish the task. It’s also about decomposing complex problems into smaller sub-problems that can be solved with simple code.\n\nYAGNI (You Aren’t Gonna Need It)\n\nThe YAGNI principle advises developers to implement features only when they are needed, not based on speculation about future requirements. Develop features in response to concrete requirements or user stories. Do not include code for scenarios that have an extremely low chance of occurring.\n\nThe SOLID principles are a set of five coding standards intended to make object-oriented software more understandable and maintainable:\n• The Single Responsibility Principle (SRP) means that a class, module, or function should have only one reason to change. If a function handles multiple concerns, changes in one concern may affect others that you don’t intend to change.\n• The Open-Closed Principle (OCP) states that software entities should be open for extension but closed for modification. Instead of modifying existing code to add new features, create new classes, modules, or functions that extend the existing ones.\n• Liskov Substitution Principle (LSP) means objects of a superclass can be replaced with objects of their subclasses without breaking the application. This promotes reliable inheritance hierarchies and helps apply the same code in different subclasses.\n• Interface Segregation Principle (ISP) prevents overblown interfaces. The idea behind the ISP code guidelines is that multiple specific interfaces are better than one general-purpose interface with numerous unwanted features.\n• Dependency Inversion Principle (DIP) means making high-level and low-level modules depend on abstractions instead of depending directly on each other. These coding practices make the code more modular and extensible.\n\nCertain industries have regulatory requirements that include standard coding practices. The same goes for safety-critical sectors that require you to use closed standards (developed by specific organizations) instead of freely available open standards.\n\nFor example, developing software for the transportation industry might require you to follow ISO 26262 (a functional safety standard in the automotive industry). Or, your team might follow HL7 standards to ensure interoperability of electronic health records.\n\nNot every coding standard is universal—they are often tailored to a specific programming language, industry, or project.\n\nDifferent languages have their unique standards. We won’t name them all, but let’s concentrate on the essential coding best practices for the most popular languages and frameworks.\n\nThis only covers the essentials. If you need the most comprehensive set of standards for each programming language, read the official documentation.\n\nIn some cases, you may face resistance to change from your team. Some of them may cling to old habits or won’t understand why you want to make code human-readable and visually appealing. Besides, adherence to strict code quality standards can be burdensome under deadlines, too.\n\nHowever, these practices can help you implement standard coding practices with minimal resistance.\n• Involve the team in defining standards. Engage your team from the bottom up, encouraging them to share their suggestions.\n• Start small. Begin with key guidelines and rules and gradually expand as the team becomes more comfortable.\n• Adapt and customize. Make sure the standards are practical and acceptable. Adapt standards to fit the context of your projects.\n• Document standards clearly. Create a well-defined document with your guiding principles, conventions, and rules. Use code snippets to illustrate both compliant and non-compliant code.\n• Provide training and onboarding. Conduct training sessions and pair less experienced developers with seniors who can help them adjust to new practices.\n• Recognize and reward compliance. Consider implementing rewards or recognition programs to motivate employees to adopt the new rules.\n\nThe key lies in communication, collaboration, and support for your team. However, if you lack internal knowledge, you can partner with a technical vendor to help you implement code standards.\n\nSome tools are very useful for identifying bugs, style violations, and security issues or automating other tasks that can save developers time. They can be divided into linters (for spotting logical problems in the code), formatters (to enforce style across projects), static code analyzers (to gauge performance metrics for the codebase), and IDEs (integrated development environments that streamline editing, compiling, debugging and other tasks).\n\nHere are some of the tools we want to highlight:\n• ESLint for JavaScript can identify stylistic issues and potential bugs. It offers customizable rules, autofix capabilities and has a broad integration ecosystem.\n• SpotBugs can reveal tricky bugs, performance issues and concurrency problems in Java code.\n• gofmt helps make code easier to read, review and maintain in Go projects.\n• Prettier formats code according to defined rules in multiple programming languages and editors.\n• JetBrains Rider IDE inspects code for inconsistencies, provides quick-fix resolutions, allows sharing of custom code configurations and syncs formatting and syntax rules.\n• IntelliJ IDEA can help define style rules across databases, check for violations and fix issues in real time.\n• Visual Studio IDE offers built-in code-style settings and analyzers, cleanup and refactoring operations, and integrates with various formatting tools.\n\nInvesting in coding standards can position your company for long-term success, innovation, and competitiveness. However, it requires certain knowledge and commitment from all levels of the organization.\n\nOften, you need to rework large chunks of your codebase. After all, you can’t have uniformity if only some of your systems adhere to coding standards and best practices.\n\nAt DevCom, we specialize in helping companies implement effective coding standards and best practices. Our code audit services include codebase reviews, architecture evaluations, UI design assessments, and security tests. We will analyze your entire codebase, deliver a comprehensive report, and, if you’re willing, update your system to the highest standards.\n\nContact us today to learn how we can elevate your software development life cycle and quality."
    },
    {
        "link": "https://stackoverflow.com/questions/35376513/compound-interest-rate-formula",
        "document": "This is so frustrating. I can't find this answer anywhere and I can't figure it out myself. This is for an assignment in a college class. We're supposed to have a result of:\n\nHow can I calculate this using c++?"
    },
    {
        "link": "https://stackoverflow.com/questions/75490717/how-to-calculate-compound-interest-in-c",
        "document": "(and ) takes 2 input arguments, but you are passing in only 1 value - the result of this calculation:\n\nBecause of your use of the comma operator, returns , thus the above is effectively just this simpler calculation:\n\nThat is the sole value you are passing to . But that is not what it wants.\n\nThe formula does not translate into this code, as you have written it:\n\nIt actually translates into code more like this instead:\n\nDepending on how you read the formula. However, those solutions are all wrong, because the formulas you have shown are written incorrectly to begin with! So, you are translating them into C++ code incorrectly."
    },
    {
        "link": "https://geeksforgeeks.org/cpp-program-to-find-compound-interest",
        "document": "What is ‘Compound interest’? \n\nCompound interest is the addition of interest to the principal sum of a loan or deposit, or in other words, interest on interest. It is the result of reinvesting interest, rather than paying it out, so that interest in the next period is then earned on the principal sum plus previously-accumulated interest. Compound interest is standard in finance and economics.\n\nCompound interest may be contrasted with simple interest, where interest is not added to the principal, so there is no compounding.\n\nCompound Interest formula:\n\nFormula to calculate compound interest annually is given by: \n\n\n\nWhere, \n\nP is principal amount \n\nR is the rate and \n\nT is the time span\n\nInput principal amount. Store it in some variable say principal. \n\n Input time in some variable say time. \n\n Input rate in some variable say rate. \n\n \n\n \n\n \n\n Finally, print the resultant value of CI.\n\nTime complexity: O(n), as pow() function take O(N) time.\n\nAuxiliary space: O(1)."
    },
    {
        "link": "https://cplusplus.com/forum/beginner/111554",
        "document": "#include <iostream>\n\n #include <cmath>\n\n \n\n using namespace std;\n\n \n\n int main()\n\n {\n\n \n\n double result = 0.0, rate = 0, dollars;\n\n int months = 12, result;\n\n result = dollars * pow( ( 1 + rate / months ) , ( months * dollars ) );\n\n \n\n cout << \"Enter monthly deposit:\" <<endl;\n\n cin >> dollars;\n\n \n\n cout << \"Enter the interest rate (in percent):\" <<endl;\n\n cin >> rate;\n\n \n\n cout << \"Enter the time (months):\" <<endl;\n\n cin >> months;\n\n \n\n while (dollars < lastNumber)\n\n {\n\n \n\n \n\n }\n\n \n\n cout << \"The new balance is: \" << sum + lastNumber<< endl;\n\n \n\n return 0;\n\n }\n\n \n\n For this I had to use a template (sum.cpp) which can be found here for the reference (under labs and assigns #1)\n\n http://people.stfx.ca/mvanbomm/cseng/ Hello. I have to write a program for compound monthly interest with a starting monthly deposit, an annual interest rate, and a new balance. My problem is that I cant seem to get the right output. I tried some recommendations but nothings working. I am a complete noob at this. Any and all help would be appreciated.#include #include using namespace std;int main()double result = 0.0, rate = 0, dollars;int months = 12, result;result = dollars * pow( ( 1 + rate / months ) , ( months * dollars ) );cout << \"Enter monthly deposit:\" < > dollars;cout << \"Enter the interest rate (in percent):\" < > rate;cout << \"Enter the time (months):\" < > months;while (dollars < lastNumber)cout << \"The new balance is: \" << sum + lastNumber<< endl;return 0;For this I had to use a template (sum.cpp) which can be found here for the reference (under labs and assigns #1)\n\n\n\n You're trying assign a value to result but haven't assigned yet any value to it's operands in the right side. You should put this statements somewhere after you already stored the value on it's operands, the ( rate, months, dollars ... )\n\n \n\n main () //assign the value to result ( result = dollars * pow( ( 1 + rate / months ) , ( months * dollars ) ); ) 0; \n\n \n\n And one thing: why is there a comma in that assignment statement\n\n You're trying assign a value to result but haven't assigned yet any value to it's operands in the right side. You should put this statements somewhere after you already stored the value on it's operands, the ( rate, months, dollars ... )And one thing: why is there a comma in that assignment statement\n\nYou don't have to rude about it... Seriously. I'm frustrated as it is.\n\n \n\n If more details is what you need then fine.\n\n \n\n result = dollars * pow( ( 1 + rate / months ) , ( months * dollars ) );\n\n this line right here will not go through for it says it has a previous declaration.\n\n \n\n When I type in values in the output the result is always 5 or 16. It will only calculate (I think) the first month. \n\n \n\n\n\nThank you for all your help. It was much appreciated. The program still isn't quite there yet, but its close. Thank you for all your help. I do appreciate it.\n\n \n\n especially @ nevermore28 :)\n\n \n\n Cheers\n\nlol, i've just realize that pow is a function that takes arguments... and so the COMMA in there is just RIGHT, sorry for wrong info :////\n\nIf you are supposed to use sum.cpp and the instructions on the course page, I would use (principle * rate / 1200) in the while loop. It is not correct to use the pow function. The term (principle * rate / 1200) assumes you use 10 instead of 0.1 as a 10% rate. Furthermore it converts the annual interest rate to the monthly rate. \n\n \n\n #include <iostream>\n\n using namespace std;\n\n \n\n int main()\n\n {\n\n double deposit;\n\n double rate;\n\n unsigned short years;\n\n double sum;\n\n \n\n // description and input\n\n cout << \"This program determines how much money\n\n\"\n\n << \"a person would have saved if they deposit\n\n\"\n\n << \"a given amount of money each month for a\n\n\"\n\n << \"given number of years into a savings account\n\n\"\n\n << \"which earns interest at a given annual rate.\n\n\n\n\";\n\n cout << \"Please start by entering the monthly deposit: \";\n\n cin >> deposit;\n\n cout << \"\n\nEnter the annual interest rate: \";\n\n cin >> rate;\n\n cout << \"\n\nEnter the number of years: \";\n\n cin >> years;\n\n \n\n // calculate future value\n\n unsigned short counter = 1;\n\n sum = 0;\n\n while (counter <= years * 12)\n\n {\n\n sum = sum + sum * (rate / 1200) + deposit;\n\n counter = counter + 1;\n\n }\n\n \n\n cout << \"\n\nMoney saved is \" << sum << endl;\n\n return 0;\n\n }"
    },
    {
        "link": "https://geeksforgeeks.org/program-find-compound-interest",
        "document": "What is ‘Compound interest’ ? \n\nCompound interest is the addition of interest to the principal sum of a loan or deposit, or in other words, interest on interest. It is the result of reinvesting interest, rather than paying it out, so that interest in the next period is then earned on the principal sum plus previously-accumulated interest. Compound interest is standard in finance and economics.\n\nCompound interest may be contrasted with simple interest, where interest is not added to the principal, so there is no compounding.\n\nCompound Interest formula: \n\n\n\nFormula: to calculate compound interest annually is given by: \n\nAmount= P(1 + R/100)t\n\nCompound Interest = Amount – P\n\nWhere, \n\nP is the principal amount \n\nR is the rate and \n\nT is the time span\n\nInput principal amount. Store it in some variable say principal\n\nInput time in some variable say time.\n\nInput rate in some variable say rate.\n\nCalculate Amount using the formula, \n\nAmount = principal* (1 + rate / 100) time).\n\nCalculate Compound Interest using Formula.\n\nFinally, print the resultant value of CI.\n\nTime complexity: O(1), as there is no loop used so constant time\n\nAuxiliary Space: O(1)"
    }
]