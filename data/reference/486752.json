[
    {
        "link": "https://vuejs.org/guide/essentials/watchers.html",
        "document": "Computed properties allow us to declaratively compute derived values. However, there are cases where we need to perform \"side effects\" in reaction to state changes - for example, mutating the DOM, or changing another piece of state based on the result of an async operation.\n\nWith the Options API, we can use the option to trigger a function whenever a reactive property changes: // whenever question changes, this function will run 'Error! Could not reach the API. ' The option also supports a dot-delimited path as the key: // Note: only simple paths. Expressions are not supported.\n\nWith Composition API, we can use the function to trigger a callback whenever a piece of reactive state changes: 'Error! Could not reach the API. ' 's first argument can be different types of reactive \"sources\": it can be a ref (including computed refs), a reactive object, a getter function, or an array of multiple sources: Do note that you can't watch a property of a reactive object like this: // this won't work because we are passing a number to watch()\n\nWhen you call directly on a reactive object, it will implicitly create a deep watcher - the callback will be triggered on all nested mutations: // Note: `newValue` will be equal to `oldValue` here // because they both point to the same object! This should be differentiated with a getter that returns a reactive object - in the latter case, the callback will only fire if the getter returns a different object: // fires only when state.someObject is replaced You can, however, force the second case into a deep watcher by explicitly using the option: // Note: `newValue` will be equal to `oldValue` here // *unless* state.someObject has been replaced\n\nIn Vue 3.5+, the option can also be a number indicating the max traversal depth - i.e. how many levels should Vue traverse an object's nested properties.\n\nis lazy by default: the callback won't be called until the watched source has changed. But in some cases we may want the same callback logic to be run eagerly - for example, we may want to fetch some initial data, and then re-fetch the data whenever relevant state changes.\n\nWatcher's callback will execute whenever the watched source changes. If you want the callback to trigger only once when the source changes, use the option.\n\nIt is common for the watcher callback to use exactly the same reactive state as the source. For example, consider the following code, which uses a watcher to load a remote resource whenever the ref changes: In particular, notice how the watcher uses twice, once as the source and then again inside the callback. This can be simplified with . allows us to track the callback's reactive dependencies automatically. The watcher above can be rewritten as: Here, the callback will run immediately, there's no need to specify . During its execution, it will automatically track as a dependency (similar to computed properties). Whenever changes, the callback will be run again. With , we no longer need to pass explicitly as the source value. You can check out this example of and reactive data-fetching in action. For examples like these, with only one dependency, the benefit of is relatively small. But for watchers that have multiple dependencies, using removes the burden of having to maintain the list of dependencies manually. In addition, if you need to watch several properties in a nested data structure, may prove more efficient than a deep watcher, as it will only track the properties that are used in the callback, rather than recursively tracking all of them. only tracks dependencies during its synchronous execution. When using it with an async callback, only properties accessed before the first tick will be tracked. and both allow us to reactively perform side effects. Their main difference is the way they track their reactive dependencies:\n• None only tracks the explicitly watched source. It won't track anything accessed inside the callback. In addition, the callback only triggers when the source has actually changed. separates dependency tracking from the side effect, giving us more precise control over when the callback should fire.\n• None , on the other hand, combines dependency tracking and side effect into one phase. It automatically tracks every reactive property accessed during its synchronous execution. This is more convenient and typically results in terser code, but makes its reactive dependencies less explicit.\n\nSometimes we may perform side effects, e.g. asynchronous requests, in a watcher:\n\nBut what if changes before the request completes? When the previous request completes, it will still fire the callback with an ID value that is already stale. Ideally, we want to be able to cancel the stale request when changes to a new value.\n\nWe can use the API to register a cleanup function that will be called when the watcher is invalidated and is about to re-run:\n\nNote that is only supported in Vue 3.5+ and must be called during the synchronous execution of a effect function or callback function: you cannot call it after an statement in an async function.\n\nAlternatively, an function is also passed to watcher callbacks as the 3rd argument, and to the effect function as the first argument:\n\nThis works in versions before 3.5. In addition, passed via function argument is bound to the watcher instance so it is not subject to the synchronously constraint of .\n\nWhen you mutate reactive state, it may trigger both Vue component updates and watcher callbacks created by you.\n\nSimilar to component updates, user-created watcher callbacks are batched to avoid duplicate invocations. For example, we probably don't want a watcher to fire a thousand times if we synchronously push a thousand items into an array being watched.\n\nBy default, a watcher's callback is called after parent component updates (if any), and before the owner component's DOM updates. This means if you attempt to access the owner component's own DOM inside a watcher callback, the DOM will be in a pre-update state.\n\nIf you want to access the owner component's DOM in a watcher callback after Vue has updated it, you need to specify the option:\n\nIt's also possible to create a watcher that fires synchronously, before any Vue-managed updates:\n\nWatchers declared synchronously inside or are bound to the owner component instance, and will be automatically stopped when the owner component is unmounted. In most cases, you don't need to worry about stopping the watcher yourself. The key here is that the watcher must be created synchronously: if the watcher is created in an async callback, it won't be bound to the owner component and must be stopped manually to avoid memory leaks. Here's an example: // this one will be automatically stopped To manually stop a watcher, use the returned handle function. This works for both and : // ...later, when no longer needed Note that there should be very few cases where you need to create watchers asynchronously, and synchronous creation should be preferred whenever possible. If you need to wait for some async data, you can make your watch logic conditional instead: // do something when data is loaded"
    },
    {
        "link": "https://stackoverflow.com/questions/59125857/how-to-watch-props-change-with-vue-composition-api-vue-3",
        "document": "While Vue Composition API RFC Reference site has many advanced use scenarios with the module, there are no examples of how to watch component props.\n\nNeither is it mentioned in Vue Composition API RFC's main page or vuejs/composition-api in Github.\n\nI've created a Codesandbox to elaborate on this issue.\n\nAlthough my question and code example were initially with JavaScript, I'm using TypeScript. Tony Tom's first answer although working, led to a type error. Which was solved by Michal Levý's answer. So I've tagged this question with afterward.\n\nHere is my polished yet barebones version of the reactive wirings for this custom select component, on top of from (otherwise agnostic-implementation but this underlying component does emit @input and @change events both, based on whether the change was made programmatically or by user interaction)."
    },
    {
        "link": "https://netlify.com/blog/2021/01/29/deep-dive-into-the-vue-composition-apis-watch-method",
        "document": "The watch API is part of the larger Vue Composition APIs. It takes a data source and a callback function that executes when the provided data changes.\n\nIn my experience, I’ve found that whenever I need to track reactive data and perform some operation when the data changes, computed properties were all I needed.\n\nHowever, like the Options API, the Vue Composition API also shipped with watch, that offers developers another way of watching and reacting to data changes. I have found that there’s some nuance around it and I wanted to deep dive into it in this post and shine more light on the different ways you can use it.\n\nThis is largely because it behaves differently depending on the type of data you’re watching, and it can get confusing if you’re not already familiar with it. In this post, we’ll look at how to use it when dealing with and states as well as with arrays and objects.\n\nA general rule of thumb when working with the watch API is to know that it takes two arguments. The first is the data source you want to watch and the second is a callback function that applies side effects to that data.\n\nThe watch API allows us to watch a single ref or to collectively watch multiples refs. Let’s demonstrate how to watch a single ref with simple data types (strings, numbers booleans)\n\nWhen watching a single ref, we simply pass it as the first argument to the watch API. Here’s a quick example:\n\nThis is fairly straightforward. We are watching to ensure that when its value changes, we perform any operation we want in the callback. In this case, we just log the current and old values to the console. The same applies to all other ’s of simple data types like booleans and numbers.\n\nHowever that’s not the case when watching a of more complex data type like arrays and objects.\n\nLet’s see how to do that with an array:\n\nTwo things to notice here:\n• We used a function to return the array we want to watch (not passed in directly like we did in the last example)\n• We returned a copy of the values of the array i.e (not the existing array itself).\n\nThis is significantly different from what we saw earlier with simple data types. But this is just an array, what if it was an object, would it be any different? Let’s find out:\n\nThe difference here is that with objects, we pass the data directly into the watch API, no need to return it with a function or make a copy like we did with the array.\n\nOne more thing you’ll notice is that for both cases (array and object), the value of and is in fact the same thing. Why? here’s why and how to fix it.\n\nWhat if we had nested objects or arrays, how do we use the watch API to monitor changes in nested arrays/objects?. Let’s start with a nested array example:\n\nWe are watching , which is the parent of the nested array. Ideally, when the value of changes, the watch API should execute and log the different values to the console. However, that won’t happen becuase:\n\nAs a result, we can use lodash to “deeply” watch the array (this time with access to the nested array):\n\nWith this, the values of both our arrays will be tracked just fine. The good thing with this approach is that we did’t have to copy the array’s values anymore, we can simply pass it into and it handles the rest for us. This also applies to nested objects:\n\nIf we had more than one item that we wanted to watch at once, we can pass them all into the watch API with an array. For instance, if we had and , we could watch for changes in their values at once like so:\n\nThe way the watch API handles values is somewhat different from how it handles . Everything we’ve done so far has been with values, let’s try redoing them, but this time with . This way, we’ll cover both values and you will be equipped to use the watch API either way.\n\nOnce again we start off with an array. Here’s how to watch a reactive array and react to changes in its value:\n\nUsing the watch API with a array is no different from how we used it with a . In both cases, we deep cloned the array with lodash and return it as the first argument to the watch API. The only difference here is that we did not append to read the value of the array.\n\nTo cut to the chase quickly, using lodash like we did in the last example ensures that we track every aspect of the data we want to watch. As a result, if we have deeply nested arrays, it will track the values as well:\n\nThis is almost exactly the same with the example, with the exception of the appends.\n\nWhen dealing with objects, I personally tend to go with by default. However the implementation is also not very different from how you would approach a :\n\nYou can watch an object or an array by deep cloning it using lodash. I have made this approach my default since in most cases, I want to track both the previous and current values of the data I’m watching. If you’re okay tracking just the current values, you don’t need to use lodash here.\n\nThe watch API can also take a third argument , which when set to true, will extend its functionality to keep an eye on deeply nested values:\n\nHowever, because it doesn’t track both previous and current values of , lodash is still my preferred option for using the watch API with reactive nested arrays and objects:\n\nWhen watching a specific property in a reactive object, the first argument you pass to will be an anonymous function that returns the specific property you want to watch.\n\nIt is worthy to note that there’s a significant difference in how we watch an entire reactive object and how we watch a specific property in a reactive object as I just demonstrated above. If it’s not clear, feel free to text me on Twitter and I’ll be happy to provide some more clarity.\n\nIt would be incomplete to finish this post without telling you a little bit about . Unlike the watch API, it takes only one argument, which is a callback function that runs immediately and re-runs when any of its dependencies change. Maybe in a future post, we can look at in more detail but in the meantime, you can learn more about it here.\n\nHope this helps you understand how to use the watch API in more detail. If you prefer to learn with videos, I made a not so comprehensive tutorial on YouTube as well.\n• Launching with the Composition API — Free Video Course"
    },
    {
        "link": "https://stackoverflow.com/questions/70713083/using-watch-function-w-prop-in-vue3-composition-api",
        "document": "I have a component that renders a table of Inventoried computer equipment. Here is the relevant code for initial render:\n\nThe initial render is fine. Now I have a watcher on the prop so when someone submits a new item for the inventory I push that data onto the corresponding object array (ie, a laptop would be pushed onto the oEquiptByType[props.propFormData.Equipment] via oEquiptByType[props.propFormData.Equipment].push(props.propFormData);\n\nThis works fine for the first item I add to backend as you can see here with original and then adding first item :\n\nand after first item added (a laptop)\n\nNotice the oEquiptByType[props.propFormData.Equipment] has the new item added. Great. But now when I add a second item (a MacBook) is added this is resulting state:\n\nNotice the Macbook array has been updated but also the Laptop array's last item has been overwritten with the Mac book entry??? And this behavior continues for any additional items added from a user. I have read docs over and do not see anything that would explain this behavior. I'm hoping maybe someone with more than my limited experience with Vue can help me out. Any additional info needed please let me know. Thanks...\n\nUpdate two: here is lineage of prop.FormData-\n\nwe start in form-modal and emit the form data like:\n\nthen catch the data in the parent App.vue:\n\nand then as posted previous in display-scrap.vue the prop propFormData is defined and watched for in the watch function. hope that helps.."
    },
    {
        "link": "https://bacancytechnology.com/qanda/vue/watch-props-change-with-vue-composition-api-vue-3",
        "document": "In Vue 3 and the Composition API, you can watch for changes in props by using the watch function provided by Vue. This allows you to react to changes in props similar to how you might use watch in the Options API.\n\nHere’s an example demonstrating how to watch for prop changes using the Composition API in Vue 3:"
    },
    {
        "link": "https://vuejs.org/api/composition-api-setup.html",
        "document": "The hook serves as the entry point for Composition API usage in components in the following cases:\n• Integrating with Composition-API-based code in an Options API component.\n\nWe can declare reactive state using Reactivity APIs and expose them to the template by returning an object from . The properties on the returned object will also be made available on the component instance (if other options are used):\n\nrefs returned from are automatically shallow unwrapped when accessed in the template so you do not need to use when accessing them. They are also unwrapped in the same way when accessed on .\n\nitself does not have access to the component instance - will have a value of inside . You can access Composition-API-exposed values from Options API, but not the other way around.\n\nshould return an object synchronously. The only case when can be used is when the component is a descendant of a Suspense component.\n\nThe first argument in the function is the argument. Just as you would expect in a standard component, inside of a function are reactive and will be updated when new props are passed in.\n\nNote that if you destructure the object, the destructured variables will lose reactivity. It is therefore recommended to always access props in the form of .\n\nIf you really need to destructure the props, or need to pass a prop into an external function while retaining reactivity, you can do so with the toRefs() and toRef() utility APIs:\n\nThe second argument passed to the function is a Setup Context object. The context object exposes other values that may be useful inside :\n\nThe context object is not reactive and can be safely destructured:\n\nand are stateful objects that are always updated when the component itself is updated. This means you should avoid destructuring them and always reference properties as or . Also note that, unlike , the properties of and are not reactive. If you intend to apply side effects based on changes to or , you should do so inside an lifecycle hook.\n\nis a function that can be used to explicitly limit the properties exposed when the component instance is accessed by a parent component via template refs:\n\ncan also return a render function which can directly make use of the reactive state declared in the same scope:\n\nReturning a render function prevents us from returning anything else. Internally that shouldn't be a problem, but it can be problematic if we want to expose methods of this component to the parent component via template refs.\n\nWe can solve this problem by calling :\n\nThe method would then be available in the parent component via a template ref."
    },
    {
        "link": "https://tatvasoft.com/outsourcing/2024/11/vue-composition-api.html",
        "document": "VueJS, being a robust JavaScript framework, is a popular choice for building modern web applications. Composition API is one glaring reason behind it. Top VueJS development companies use this feature to create large and complex applications. You can easily maintain and scale a complex codebase with it.\n\nThis article serves as a guide to understanding the Vue composition API along with its features and benefits. It also demonstrates how to install and use composition API in Vue.\n\n1. What is the Vue Composition API?\n\nFirst introduced as a built-in feature of Vue 3, Composition API allows developers to write Vue components using imported functions. In Vue v2, this task was accomplished by declaring options. But now, you can use the composition APIs in old versions through the @vue/composition-api plugin.\n\nComposition APIs offer a robust and flexible approach to organizing the code and reusing it across multiple components. The set of imported functions they provide helps you compose logic in a functional style. It’s way better than the traditional use of options-based syntax because composition API makes it easy to handle complex and large-scale apps and makes its code more readable.\n\nThis section discusses the primary features that make composition APIs a valuable tool in app development.\n\nReactivity is useful for automating the tracking and updating of data dependencies in a user interface (UI). The Composition API implements reactivity using reactive and ref() functions().\n\nThe Vue developers created a reactive reference for value using the ref functions to facilitate effective tracking of changes and ensure UI reactivity. The ref() and reactive() functions help directly create reactive state, computed properties, and watchers directly. In short, you can build a responsive and flexible Vue 3 application using the reactivity API.\n\nThese functions promote component-based development as they break down the complex parts of the code into small and manageable units within the same component. They isolate specific areas of concern within a component to handle its logic well. This leads to better code organization and reusability. Data manipulation, computed properties, and custom logic are well-known examples of composition functions.\n\nYou need a specific point in a component lifecycle to implement custom logic. Vue provides different options in the form of lifecycle hooks, such as created and mounted. Vue developers use these hooks to perform specific actions, like creating, mounting, or updating a component.\n\nUsing composition APIs in VueJS development offers several benefits. Here are a few of its advantages:\n\nThe Vue composition API offers a better approach to organizing your code. The setup function allows you to group related code based on functionality rather than type. With that, maintenance, navigation, and scaling of a codebase becomes easy, especially if it is a complex application.\n\nBreaking down complex functionality into small, maintainable units makes it easier to share them across different projects. With Composition API, you can extract reusable logic and import it into the functions that you want to use in any Vue component. This approach not only encourages logic reusability but also reduces code redundancy.\n\nFront-end developers prefer TypeScript for its better IDE support, which helps in writing robust code. It was challenging to adopt TypeScript with Options API in Vue. But with the advent of composition APIs, Vue developers can enjoy a complete type inference with less need for manual hints.\n\nAll the functions and variables in Composition API are type-friendly. This offers better type-checking and auto-completion, resulting in enhanced productivity and a better development experience.\n\nComposition in Vue allows developers to build flexible user interfaces. This enables them to experiment with different combinations of components to create dynamic and complex UIs. It is important to mention that the goal remains the same; to design an aesthetically pleasing and user-friendly interface. The Composition API helps you be creative about it.\n\nYour Vue code runs faster, thanks to the composition API. This approach reduces the amount of code that needs to be loaded and executed by breaking down complex functionalities into smaller components. As a result, loading times decrease, leading to improved performance.\n\nThe render functions and scoped slots in Vue composition API help speed up rendering and eliminate unnecessary DOM updates, leading to an improved user experience.\n\nWhen Composition API breaks down complicated functions into small, independent components, testing becomes much easier. You can directly test these functions in an isolated environment without mounting a Vue component. This approach improves the speed and efficiency of your tests.\n\nThe Vue Composition API is used in the above code for the following:\n\nReactive State Creation: A reactive variable named wicket is created using the ref function. Because it is initialized at 0, the wicket acts as a reactive reference. So, if any changes are made to the wicket’s value, they will be reflected in the DOM automatically.\n\nFunction Definition: In the setup function, a defined function named addWicket increases the wicket’s value if called.\n\nReturning Reactive Data and Methods: You can access the method addWicket and a reactive variable wicket directly from the template. Because the setup function returns the object consisting of them both.\n\nTemplate Binding: The interpolation ({{ wicket }}) bounds the reactive variable wicket to the displayed content in a template. Meanwhile, the @click directive links the event of a button click with the addWicket function.\n\nWith the composition APIs, you can easily define the functions and reactive state in the setup function. This streamlines the logic organization and state management processes which help you write a clean and easy-to-maintain code.\n\nComposition API is a built-in feature in Vue 3, so, you don’t need to install it for Vue 3 projects. But it doesn’t come by default in Vue 2. In that case, install Composition API through NPM.\n\nNext, import composition API in your main.js file.\n\n6. Using the Composition API in a Vue.js Component\n\nImporting the ref() and reactive() functions from the Vue package and then defining a setup function allows you to use the composition API in a Vue component. The setup function acts as a lifecycle hook that helps you set up the reactive data and functions. It must be executed before creating the component.\n\nThe utilization of Vuex4 with TypeScript and the composition API offers benefits such as type inferences, static type checking, and IDE auto-completion. But to enjoy these benefits, you first have to install the required dependencies and make other necessary configurations to use TypeScript.\n\nFirst, wrap the object of your component with defineComponent.\n\nNow, you can use types in your set up:\n\nThe variables are inferred as types in the above code. The following APIs are also typed to reduce the chances of passing off wrong data. IntelliSense in TypeScript is a big help in such cases especially if you are using VS Code.\n\nWhile the options API is helpful for object-oriented programming, the Composition API is changing how we organize code. It allows for logic reuse and supports component-based development. Its benefits include better app performance and better code readability. Moreover, it’s an ideal fit for complex and long-term projects.\n\nWhat is the difference between Vue option API and composition API?\n\nOptions API depends on a single object that contains various options, whereas the composition API relies on composable functions. Hence, the Composition API is an ideal choice for complex components or applications, whereas the Options API is a right fit for simple components or applications.\n\nWhat is the method composition API in Vue?\n\nComposition API is a robust and flexible way to write components in Vue. It simplifies complex functionalities and promotes logic reusability.\n\nCan I use composition API in Vue2?\n\nYes, you can use the composition API in Vue2 by installing the @vue/composition-api as a plugin via Vue. use()."
    },
    {
        "link": "https://vuejs.org/guide/extras/composition-api-faq",
        "document": "Composition API is a set of APIs that allows us to author Vue components using imported functions instead of declaring options. It is an umbrella term that covers the following APIs:\n• None Reactivity API, e.g. and , that allows us to directly create reactive state, computed state, and watchers.\n• None Lifecycle Hooks, e.g. and , that allow us to programmatically hook into the component lifecycle.\n• None Dependency Injection, i.e. and , that allow us to leverage Vue's dependency injection system while using Reactivity APIs.\n\nComposition API is a built-in feature of Vue 3 and Vue 2.7. For older Vue 2 versions, use the officially maintained plugin. In Vue 3, it is also primarily used together with the syntax in Single-File Components. Here's a basic example of a component using Composition API:\n\nDespite an API style based on function composition, Composition API is NOT functional programming. Composition API is based on Vue's mutable, fine-grained reactivity paradigm, whereas functional programming emphasizes immutability.\n\nIf you are interested in learning how to use Vue with Composition API, you can set the site-wide API preference to Composition API using the toggle at the top of the left sidebar, and then go through the guide from the beginning.\n\nThe primary advantage of Composition API is that it enables clean, efficient logic reuse in the form of Composable functions. It solves all the drawbacks of mixins, the primary logic reuse mechanism for Options API.\n\nComposition API's logic reuse capability has given rise to impressive community projects such as VueUse, an ever-growing collection of composable utilities. It also serves as a clean mechanism for easily integrating stateful third-party services or libraries into Vue's reactivity system, for example immutable data, state machines, and RxJS.\n\nMany users love that we write organized code by default with Options API: everything has its place based on the option it falls under. However, Options API poses serious limitations when a single component's logic grows beyond a certain complexity threshold. This limitation is particularly prominent in components that need to deal with multiple logical concerns, which we have witnessed first hand in many production Vue 2 apps.\n\nTake the folder explorer component from Vue CLI's GUI as an example: this component is responsible for the following logical concerns:\n\nThe original version of the component was written in Options API. If we give each line of code a color based on the logical concern it is dealing with, this is how it looks:\n\nNotice how code dealing with the same logical concern is forced to be split under different options, located in different parts of the file. In a component that is several hundred lines long, understanding and navigating a single logical concern requires constantly scrolling up and down the file, making it much more difficult than it should be. In addition, if we ever intend to extract a logical concern into a reusable utility, it takes quite a bit of work to find and extract the right pieces of code from different parts of the file.\n\nHere's the same component, before and after the refactor into Composition API:\n\nNotice how the code related to the same logical concern can now be grouped together: we no longer need to jump between different options blocks while working on a specific logical concern. Moreover, we can now move a group of code into an external file with minimal effort, since we no longer need to shuffle the code around in order to extract them. This reduced friction for refactoring is key to the long-term maintainability in large codebases.\n\nIn recent years, more and more frontend developers are adopting TypeScript as it helps us write more robust code, make changes with more confidence, and provides a great development experience with IDE support. However, the Options API, originally conceived in 2013, was designed without type inference in mind. We had to implement some absurdly complex type gymnastics to make type inference work with the Options API. Even with all this effort, type inference for Options API can still break down for mixins and dependency injection.\n\nThis had led many developers who wanted to use Vue with TS to lean towards Class API powered by . However, a class-based API heavily relies on ES decorators, a language feature that was only a stage 2 proposal when Vue 3 was being developed in 2019. We felt it was too risky to base an official API on an unstable proposal. Since then, the decorators proposal has gone through yet another complete overhaul, and finally reached stage 3 in 2022. In addition, class-based API suffers from logic reuse and organization limitations similar to Options API.\n\nIn comparison, Composition API utilizes mostly plain variables and functions, which are naturally type friendly. Code written in Composition API can enjoy full type inference with little need for manual type hints. Most of the time, Composition API code will look largely identical in TypeScript and plain JavaScript. This also makes it possible for plain JavaScript users to benefit from partial type inference.\n\nCode written in Composition API and is also more efficient and minification-friendly than Options API equivalent. This is because the template in a component is compiled as a function inlined in the same scope of the code. Unlike property access from , the compiled template code can directly access variables declared inside , without an instance proxy in between. This also leads to better minification because all the variable names can be safely shortened.\n\nSome users moving from Options API found their Composition API code less organized, and concluded that Composition API is \"worse\" in terms of code organization. We recommend users with such opinions to look at that problem from a different perspective.\n\nIt is true that Composition API no longer provides the \"guard rails\" that guide you to put your code into respective buckets. In return, you get to author component code like how you would write normal JavaScript. This means you can and should apply any code organization best practices to your Composition API code as you would when writing normal JavaScript. If you can write well-organized JavaScript, you should also be able to write well-organized Composition API code.\n\nOptions API does allow you to \"think less\" when writing component code, which is why many users love it. However, in reducing the mental overhead, it also locks you into the prescribed code organization pattern with no escape hatch, which can make it difficult to refactor or improve code quality in larger scale projects. In this regard, Composition API provides better long term scalability.\n\nDoes Composition API cover all use cases? ​\n\nYes in terms of stateful logic. When using Composition API, there are only a few options that may still be needed: , , , and .\n\nIf you intend to exclusively use Composition API (along with the options listed above), you can shave a few kbs off your production bundle via a compile-time flag that drops Options API related code from Vue. Note this also affects Vue components in your dependencies.\n\nCan I use both APIs in the same component? ​\n\nYes. You can use Composition API via the option in an Options API component.\n\nHowever, we only recommend doing so if you have an existing Options API codebase that needs to integrate with new features / external libraries written with Composition API.\n\nNo, we do not have any plan to do so. Options API is an integral part of Vue and the reason many developers love it. We also realize that many of the benefits of Composition API only manifest in larger-scale projects, and Options API remains a solid choice for many low-to-medium-complexity scenarios.\n\nWe no longer recommend using Class API with Vue 3, given that Composition API provides great TypeScript integration with additional logic reuse and code organization benefits.\n\nComposition API provides the same level of logic composition capabilities as React Hooks, but with some important differences.\n\nReact Hooks are invoked repeatedly every time a component updates. This creates a number of caveats that can confuse even seasoned React developers. It also leads to performance optimization issues that can severely affect development experience. Here are some examples:\n• None Hooks are call-order sensitive and cannot be conditional.\n• None Variables declared in a React component can be captured by a hook closure and become \"stale\" if the developer fails to pass in the correct dependencies array. This leads to React developers relying on ESLint rules to ensure correct dependencies are passed. However, the rule is often not smart enough and over-compensates for correctness, which leads to unnecessary invalidation and headaches when edge cases are encountered.\n• None Expensive computations require the use of , which again requires manually passing in the correct dependencies array.\n• None Event handlers passed to child components cause unnecessary child updates by default, and require explicit as an optimization. This is almost always needed, and again requires a correct dependencies array. Neglecting this leads to over-rendering apps by default and can cause performance issues without realizing it.\n• None The stale closure problem, combined with Concurrent features, makes it difficult to reason about when a piece of hooks code is run, and makes working with mutable state that should persist across renders (via ) cumbersome.\n• None Invokes or code only once. This makes the code align better with the intuitions of idiomatic JavaScript usage as there are no stale closures to worry about. Composition API calls are also not sensitive to call order and can be conditional.\n• None Vue's runtime reactivity system automatically collects reactive dependencies used in computed properties and watchers, so there's no need to manually declare dependencies.\n• None No need to manually cache callback functions to avoid unnecessary child updates. In general, Vue's fine-grained reactivity system ensures child components only update when they need to. Manual child-update optimizations are rarely a concern for Vue developers.\n\nWe acknowledge the creativity of React Hooks, and it is a major source of inspiration for Composition API. However, the issues mentioned above do exist in its design and we noticed Vue's reactivity model happens to provide a way around them."
    },
    {
        "link": "https://tatvasoft.com/outsourcing/2022/09/vue-3-installation-guide.html",
        "document": "Vue.js is an open-source front-end framework for creating single-page apps and user interfaces that is rapidly rising in popularity. Vue.js has grown in prominence and gained new subscribers since its first release, because of its development-friendly language, ease of use, and well-known documentation. The new Vue version, Vue 3, was launched in September 2020. It’s more compact, easier to maintain, and when used with Vue best practices it comes with more useful functions. Its new release consists of many thoughtful breaking changes—let’s discuss them.\n\nHere are some steps to install vue3\n\nDownload Node.js and NPM (Node Package Manager) on your PC as the main action.\n\nYou may determine whether they are already downloaded by navigating to the Terminal/Command prompt window on your system and executing a few instructions.\n\nTo determine the model of Node.js version,\n\nIf it is currently downloaded, ensure that it is version 10 or higher.\n\nTo confirm the npm, execute the below code in the terminal.\n\nIf they are not downloaded, you will see a warning like “command not found” when performing node and npm versions test commands. Therefore, you will be required to install these.\n\nNavigate to the Node.js portal in the internet browser; you will find two variants; It is recommended choosing LTS, the better reliable version, that is usually preferred for most visitors.\n\nClicking the LTS button initiates the Node.js package file installing on the PC.\n\nTo download the file, double-click the file to open the installation window. Installing Node.js is the same as installing any other software.\n\nAlong with node.js, you may also download npm since they do not need to be installed individually.\n\nThen click Agree and Install, that will request the administrator passcode. After entering the passcode, it will take a bit of time to finish the setup.\n\nLaunch Terminal and execute the following command:\n\nA few moments will be required to finish the installation.\n\nIf it states that users do not get authorization, rerun the command with the sudo prefix, which will prompt you to provide your administrator passcodes, and you will be good to go.\n\nTo build a vue 3 application, a vue cli version of 4.5 or higher is required.\n\nIf you’ve previously downloaded vue cli, you may use the below command to determine its version.\n\nIf you have a release that is less than 4.5, you may update it by using the command here.\n\nThe following task is to establish a Vue 3 project.\n\nTo accomplish so, use the terminal and type the following into the input field to access the computer:\n\nYou are then questioned which edition of vue you wish to be using; you may select vue 3 by using the up and down arrow keys on your computer and pressing the enter button.\n\nThis will initiate the creation of our Vue 3 project with the title of the project as the file or folder title.\n\nThe creation of the vue 3 project and installation of its standard dependencies will require a couple moments.\n\nOn the desktop, you may locate the file with the program’s name after it’s completed.\n\nThe final step is to execute the vue 3 project in a web browser.\n\nYour terminal window may provide me with two instructions to execute the project.\n\nThe initial step is to navigate to the program file:\n\nTo execute the application, use the command below.\n\nRather than utilizing the Terminal window, you may execute the project with the help of the Visual Studio Code editor.\n\nGo to the Applications folder → Visual Studio Code\n\nAfter that, open the file and navigate the created program file.\n\nAs you are aware, the Terminal window is associated with Visual Studio, hence you may access it by selecting Terminal from the editor’s toolbar and afterwards New Terminal, which opens a new window. .\n\nIf the terminal is already in the project, then you will not need to execute the initial command.\n\nYou only need to do the npm run server command.\n\nThis command will launch the server on your PC and provide the localhost URL.\n\nAfter doing so, you may receive two URLs: one is localhost and another is the Network URL, which is useful when you wish to view the program on several devices, like when testing the user interface of the program on a mobile phone.\n\nCopy the Network URL, open the new window on the browser, then paste it into the address bar.\n\nAt this point, your Vue 3 application is setup and operating smoothly.\n\nHere are some of the new features in Vue 3\n\nComposition API was first released as a plugin a few months ago, however in Vue 3, we no longer need to deploy it as a plugin. It’s now included in the latest version of the Vue package and may be used right away without any further configuration.\n\nImplementing the Composition API has two major advantages:\n• The code may be shared and reused\n\nOptions API will be supported in Vue 3, therefore if you don’t require composition API, you can always utilize the standard Vue 2 techniques.\n\nIf you’re unfamiliar with the Composition API, this is how you can build code to create a component:\n\nWe can see that utilizing Composition API helps developers to better organize the code by grouping similar features’ code (state, procedures, calculated variables, viewers, and so on), which was not feasible with the Options API.\n\nIn the Composition API instance above, the code for counting and the code for altering a message are clearly divided. As the element develops in size, code organization becomes more critical. Without investing too much time evaluating all of the program code, any software employee may quickly grasp the code.\n\nProgrammers used to be able to exchange code using Mixins. However, keeping track of data and procedures across components was difficult, and Mixins had the ability to overwrite present condition or procedures in our elements if we weren’t diligent.\n\nTransferring code is significantly easier when you use the Composition API. As seen below, we may factor out the script for a certain functionality and reuse it in several places:\n\nSuspense is a unique component that, unless a criterion is fulfilled, presents a default content instead of your component.\n\nYou probably recall all the components in vue 2 you’ve built with v-if=”!isLoading” on the root element and a v-else on the secondary one to present data after it is loaded , including an API call or other concurrent query.\n\nThis is the purpose of suspense. The sample syntax in the template below is much better than the v-if one.\n\nThe mechanism used to determine if your component should be loaded or not. It is included with the Composition API and the below-mentioned setup function. Suspense takes over when the setup function is defined as async, and the fallback is presented after you return from setup.\n\nA snippet example has been given below that may interrupt the fallback:\n\nThis feature minimizes the boilerplate code necessary to perform external calls quite dramatically — and cleanly.\n\nMany firms utilize v-model for two-way binding in Vue.js, and the most popular method to use it is with form elements. You can only use one v-model in a single component in Vue 2, but in Vue 3 one can use multiple v-models. Let’s see how it looks for both below:\n\nPortal is a feature that allows the display of a portion of code from one component into another component in a separate DOM tree. In Vue 2, there was a third-party plugin named portal-vue that did this.\n\nPortal will be incorporated into Vue 3 and is very simple to utilize. Vue 3 will contain a custom tag called <Teleport> that will allow any code encased within it to be transported to any location.\n\nLet’s look at an example:\n\nAny code included in <Portal></Portal> will be shown at the specified target location.\n\nVue 3 is now entirely written in TypeScript. TypeScript is a superset of JavaScript. Vue type descriptions enhance TypeScript compatibility because they are automatically created, tested and kept up-to-date. It’s worth noting that TypeScript will still be completely optional in Vue projects. That’s fantastic!\n\nThe Vue Core Team also highlighted that after incorporating TypeScript into the Vue core, the system architecture has been greatly reduced and is a lot easier to manage.\n\nFragments could be referred to as “Multiple Root Nodes,” as well and is one of the React features. In Vue 2, every component is restricted to a single root element. Fragments resolve this issue by enabling the use of many root nodes inside each of them. The notion of multiple root nodes is as simple as it feels. The sole exception is that if you wish to use property inheritance, you must indicate which root components will receive any attributes supplied to the parent component:\n\nAs you may notice in the above code snippet, Vue 3 allows you to use many root nodes immediately without any further work.\n\nYou’ll find something unusual when you access main.js in the project. To load plugins and additional libraries, developers no longer need to utilize the Global Vue instance unlike previous versions.\n\nHowever, have a look at the createApp method:\n\nThe benefit of this functionality is that it shields the Vue app from third-party libraries/plugins that may override or modify the global instance – most commonly via Mixins.\n\nNow, instead of installing those plugins on the global material, you may use the createApp function to install them on a specific instance and it will work properly.\n\nIf you’re starting a new project, you could still use Vue 2 with a Composition API plugin and then transition to Vue 3 later because there won’t be any major updates other from the loss of filters.\n\nVue 3 will have a slew of new and exciting features. The unified composition will have a huge influence on future app development by offering a simple method to organize and exchange code, as well as excellent TypeScript support.\n\nThe effectiveness will be perfectly alright, and the package capacity will be lowered even further in the next release. Suspense, v-models, and other features will make programming easier than earlier."
    },
    {
        "link": "https://stackoverflow.com/questions/74382628/how-to-use-vue-3-package-with-script-setup-composition-api",
        "document": "When I come across most packages they are written in Options API. What's the best way to determine how to write it with + Composition API?\n\nBut I get an error:"
    }
]