[
    {
        "link": "https://osu.ppy.sh/community/forums/topics/586892",
        "document": "1. Unify GetBeatmapset and GetBeatmap:2. Deserialize directly to object, it requires way less code and makes it easier to read and maintain.(from my private API lib) - https://puu.sh/vxUbh.png - left side example, right is random usage3. Avoid using dynamic when it comes to objects. 'dynamic' is not a type, nor an object. It was primarily introduced as a way to allow C# to interop with languages such as Python, which is not statically typed. If you are using it out of this context you are probably forgoing functionality.4. If you are building library, imo good habit is making XML documentation comments. Helps end-dev who use it to not look into documentation for \"what is what\"./// - shortcut to shippet in visual studioGood luck!This can be solid, if i find time I may commit something myself to this."
    },
    {
        "link": "https://osu.ppy.sh/community/forums/topics/424167",
        "document": "As I'm developing a small music game, I thought about osu file compatibility for it, turned out that was exactly out of the box reading a .osu file. Yes, is not hard, but either easy. As I see a lot of devs here use C#/VB, I decided to give my library open source. Actually is an early development stage (only mania 4K specific maps can be parsed), but I'm working to support all the gamemodes and keycounts.Fast loading of osu files (20-25ms).Returns a C# object for beatmap, timing points, hit objects, easy to read and manage.Full .Net framework compatibility (it will work in C#, VB and all other .Net languages).Open Source, released under GNU GPL V3.You can find source and releases here I'm open to feature requests, code improving suggestions and so on...Sorry for bad english."
    },
    {
        "link": "https://github.com/ppy/osu-framework",
        "document": "If you are interested in creating a project using the framework, please start from the getting started wiki resources (or jump straight over to the project templates). You can either start off from an empty project, or take a peek at a working sample game. Either way, full project structure, cross-platform support, and a testing setup are included!\n\nThe rest of the information on this page is related to working on the framework, not using it!\n\nThis framework is intended to take steps beyond what you would normally expect from a game framework. This means things like basic UI elements, text rendering, advanced input handling (textboxes) and performance overlays are provided out-of-the-box. Any of the osu! code that is deemed useful to other game projects will live in this framework project.\n• Anywhere we implement graphical components, they will be displayed with a generic design and will be derivable for further customisation.\n• Common elements used by games (texture caching, font loading) will be automatically initialised at runtime.\n• Allow for isolated development of components via a solid testing environment ( and ). Check the wiki for more information on how these can be used to streamline development.\n• When running on linux, please have a system-wide ffmpeg installation available to support video decoding.\n• When running on Windows 7 or 8.1, additional prerequisites* may be required to correctly run .NET 8 applications if your operating system is not up-to-date with the latest service packs.\n• When working with the codebase, we recommend using an IDE with intellisense and syntax highlighting, such as Visual Studio 2019+, Jetbrains Rider, or Visual Studio Code with the EditorConfig and C# plugin installed.\n\nBuild configurations for the recommended IDEs (listed above) are included. You should use the provided Build/Run functionality of your IDE to get things going. When testing or building new components, it's highly encouraged you use the project/configuration. More information on this provided below.\n• Visual Studio / Rider users should load the project via one of the platform-specific .slnf files, rather than the main .sln. This will allow access to template run configurations.\n\nCode analysis can be run with or .\n\nContributions can be made via pull requests to this repository.\n\nIf you're unsure of what you can help with, check out the list of open issues (especially those with the \"good first issue\" label).\n\nBefore starting, please make sure you are familiar with the development and testing procedure we have set up. New component development, and where possible, bug fixing and debugging existing components should always be done under VisualTests.\n\nNote that while we already have certain standards in place, nothing is set in stone. If you have an issue with the way code is structured; with any libraries we are using; with any processes involved with contributing, please bring it up. We welcome all feedback so we can make contributing to this project as pain-free as possible.\n\nWe love to reward quality contributions. If you have made a large contribution, or are a regular contributor, you are welcome to submit an expense via opencollective. If you have any questions, feel free to reach out to peppy before doing so.\n\nThis framework is licensed under the MIT licence. Please see the licence file for more information. tl;dr you can do whatever you want as long as you include the original copyright and license notice in any copy of the software/source.\n\nThe BASS audio library (a dependency of this framework) is a commercial product. While it is free for non-commercial use, please ensure to obtain a valid licence if you plan on distributing any application using it commercially.\n\nosu! – rhythm is just a click away!\n\nIWBTM - A platform game with level editor based off of \"I Wanna...\" games\n\nfluXis - A community-driven rhythm game with a focus on creativity and expression"
    },
    {
        "link": "https://osu.edu/newmedia/tlds.php",
        "document": "\n• How Can I use the osu.edu domain?\n• How can my department receive an ohio-state.edu domain?\n• What other domains will Ohio State host?\n• Can areas on campus host their own domains?\n• How is Windows Active Directory being used on campus?\n\nAs a service to the University, the Office of Information Technology provides Domain Name Service (DNS) hosting. All groups that use University IP space for must follow the Sonnet Network Policy, including the section concerning the registering of all devices attached to the network. (All domain requests should be sent to the Web Policy Committee, if you have questions check the Hostmaster FAQ.)\n\nHow Can I use the osu.edu domain?\n\nThe osu.edu name space has been opened up to departments on campus, on a case-by-case basis. Due to the limited use of the osu.edu domain, below are the guidelines of how it can be used:\n• To provide everyone with an equal opportunity to request names and to provide a central reviewing body the Web Policy Committee has been tasked with the reviewing and approval of all names used in the osu.edu name space. All requests need to be submitted by using the online form located on their website.\n• It is intended for short URL's to web sites however to keep a \"clean\" and standard length of names all names are limited to name.osu.edu, to aid users that by default type www.name.osu.edu entries a www.name.osu.edu record will be created to direct the user to the name.osu.edu site.\n• Any requested osu.edu names are maintained as an alias (CNAME record) to a server located in the departments' ohio-state domain, and are required to be directed to a server on the University network.\n\nHow can my department receive an ohio-state.edu domain?\n\nIf a department is interested in requesting a new domain name in the ohio-state.edu name space they should fill out the Subdomain Request formand include a brief letter that includes the intended use and number of hosts for the new domain.\n\nWhat other domains will Ohio State host?\n\nFor groups around campus that the standard ohio-state and osu.edu domains do not reflect a joint project with external organizations and or Universities they are involved in the Web Policy Committee will review and if approved, provide hosting services for other Top Level Domains (TLD's). These domains should, however reflect in their name an association with the University, where possible.\n\nThe one TLD's Ohio State will not provide hosting for is .com. (.Com's are intended to be used by commercial organizations, according to RFC1591.) Since Ohio State is a non-profit, state funded institution .com names do not represent the mission of the University and are not allowed on the network.\n\nAny group that requests a domain must show how the traditional ohio-state domain does not work for their situation, i.e. a joint project that wants to provide equal exposure to all parties involved. The requesting group also must show how the project supports the mission of the University.\n\nFor a domain to be approved, using one of the TLD's, the parties involved must include the following:\n\nA letter on departmental letterhead signed by the parental unit chair/dean/director addressing the following:\n• A description of the purpose/function/nature of the organization that includes the participants involved (including physical locations for both the on and off campus parts of the organization) and the role the University plays in the organization.\n• If the University already provides hosting for other domains for the people involved how is the new request different.\n• That it is not a private, business or some other commercial venture.\n• Agreeing to a periodic review and renewal process of approved domains to insure that the content matches the original signed agreement and that no commercial activity is taking place.\n• Stating that they understand it is the organization's responsibility to incur any additional costs in the registration process, including but not limited to transferring or renewing the domain name with the appropriate domain registrar.\n\nA second technical letter from the Department Network Administrator is also needed that addresses the following:\n• Who the billing contact is in the organization.\n• 2. Agreeing to coordinate the creation of the domain with Ohio State, at Network Solutions, with the following conditions:\n• Ohio State will maintain the domains' primary and secondary name servers.\n• The \"Registrant\", \"Administrative\" and \"Billing\" contacts will be listed as someone in the organization.\n• The \"Technical\" contact information will be the registered NIC handle for the University, ZE146-ORG.\n• Providing the IP /s that will be used with the new domain.\n• Agreeing that Ohio State will only support published domain names, and will not provide DNS for other domains that are variations of the published name. IE: Publishing something.org and asking for something.net to point the same place.\n\nBoth of these documents should be sent to the following: \n\nOhio State Hostmaster \n\n320 West 8th Ave \n\nColumbus, Ohio 43201-2331 \n\n614-292-9525 fax\n\nCan areas on campus host their own domains?\n\nSince Ohio State is responsible for the operation of the campus backbone, all domains using University resources are required to reside on the Ohio State name servers.\n\nAny domains found that were created without consulting Ohio State will be reviewed, and if they meet both the requirements for hosting and residing on the University network, it will be added to the Ohio State name servers. If a domain is discovered on the University network does not meet the requirements set forth by Ohio State, it will be removed from University IP space.\n\nThis also includes, previously approved domains that did not continue the stated purpose/function/or nature of the domain.\n\nHow is Windows Active Directory being used on campus?\n\nOhio State is currently supports the records required by Microsoft active directory, however due to the security issues that accompany a fully deployed active directory dynamic updates are not allowed to Ohio State's name servers.\n\nThe Active Directory configuration page explains DNS options for departments. To use the available features of the directory structure Microsoft requires extra records in DNS. It is important, and somewhat time sensitive, for these records to be passed onto the university Hostmaster, by the Department Network Administrator (DNA) on file, in a timely manner otherwise unexplained/unexpected complications in the directory structure may occur.\n\nFor more information concerning the implementations of Active Directory here at OSU we have asked the NT/2000 administrators to use the osu.windows.misc newsgroup to provide their experiences with deployments and to help others thinking of installing Windows."
    },
    {
        "link": "https://osu.ppy.sh/community/forums/topics/1318171",
        "document": "So I get that Osu! was made with C# and I've examined the code for Osu! laser and all, but was it first created with Windows Forms or it was all made from scratch?\n\n\n\nLemme try and explain myself well. So with C#, you can hard code the design and everything, and there is also windows forms, where you use premade designs, drag and drop these designs and code the functions of these designs.\n\n\n\nSo my question is, was this what was used or everything about Osu! is hard coded? I tried finding the post that discusses this but I couldn't find one.\n\n\n\nHope someone can help. Thx in advance for any replies. \n\n\n\nP.S: I'm creating a game for my class project and wanna know some tiny details before I dwell deeper."
    },
    {
        "link": "https://stackoverflow.com/questions/18099477/asp-net-c-sharp-using-dataset-to-read-one-row",
        "document": "I'm developing a classic WEBForms application in C# and when I have to authenticate the user, I read from SQL database the user data using a query like that:\n\nI want to use this sql query in my method that returns a Object that I defined in my class. I'm thinking to use a to fill user data executing the query.\n\n Is it the correct approach or is it too expensive and useless to use to read one row from a query?\n\nCan you advice me?"
    },
    {
        "link": "https://stackoverflow.com/questions/17281412/fastest-way-to-update-populate-1-000-000-records-into-a-database-using-net",
        "document": "I am using this code to insert 1 million records into an empty table in the database. Ok so without much code I will start from the point I have already interacted with data, and read the schema into a :\n\nAnd now that we have lets create a new to be a clone of the source database table:\n\nThis code is populating 1 million records to an embedded SQL database (localDb) in 5200ms. The rest of the code is just implementing the bulkCopy but I will post it anyway.\n\nTrying it via a connection to SQL server was around 7000ms(at best) & ~7700ms average. Also via a random kv nosql database took around 40 sec (really I did not even keep records of it as it passed over the x2 of sql variants). So... is there a faster way than what I was testing in my code?\n\ni am using win7 x64 8gb ram and most important i should think (as i5 3ghz) is not so great by now the x3 500Gb Wd on Raid-0 does the job even better but i am just saying if you will check on your pc though just compare it to any other method in your configuration"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/records",
        "document": "Records are types that use value-based equality. You can define records as reference types or value types. Two variables of a record type are equal if the record type definitions are identical, and if for every field, the values in both records are equal. Two variables of a class type are equal if the objects referred to are the same class type and the variables refer to the same object. Value-based equality implies other capabilities you probably want in record types. The compiler generates many of those members when you declare a instead of a . The compiler generates those same methods for types.\n\nIn this tutorial, you learn how to:\n\nYou define a record by declaring a type with the keyword, modifying a or declaration. Optionally, you can omit the keyword to create a . A record follows value-based equality semantics. To enforce value semantics, the compiler generates several methods for your record type (both for types and types):\n• A virtual method whose parameter is the record type.\n\nRecords also provide an override of Object.ToString(). The compiler synthesizes methods for displaying records using Object.ToString(). You explore those members as you write the code for this tutorial. Records support expressions to enable nondestructive mutation of records.\n\nYou can also declare positional records using a more concise syntax. The compiler synthesizes more methods for you when you declare positional records:\n• A primary constructor whose parameters match the positional parameters on the record declaration.\n• Public properties for each parameter of a primary constructor. These properties are init-only for types and types. For types, they're read-write.\n• A method to extract properties from the record.\n\nData and statistics are among the scenarios where you want to use records. For this tutorial, you build an application that computes degree days for different uses. Degree days are a measure of heat (or lack of heat) over a period of days, weeks, or months. Degree days track and predict energy usage. More hotter days mean more air conditioning, and more colder days mean more furnace usage. Degree days help manage plant populations and correlate to plant growth as the seasons change. Degree days help track animal migrations for species that travel to match climate.\n\nThe formula is based on the mean temperature on a given day and a baseline temperature. To compute degree days over time, you'll need the high and low temperature each day for a period of time. Let's start by creating a new application. Make a new console application. Create a new record type in a new file named \"DailyTemperature.cs\":\n\nThe preceding code defines a positional record. The record is a , because you don't intend to inherit from it, and it should be immutable. The and properties are init only properties, meaning they can be set in the constructor or using a property initializer. If you wanted the positional parameters to be read-write, you declare a instead of a . The type also has a primary constructor that has two parameters that match the two properties. You use the primary constructor to initialize a record. The following code creates and initializes several records. The first uses named parameters to clarify the and . The remaining initializers use positional parameters to initialize the and :\n\nYou can add your own properties or methods to records, including positional records. You need to compute the mean temperature for each day. You can add that property to the record:\n\nLet's make sure you can use this data. Add the following code to your method:\n\nRun your application, and you see output that looks similar to the following display (several rows removed for space):\n\nThe preceding code shows the output from the override of synthesized by the compiler. If you prefer different text, you can write your own version of that prevents the compiler from synthesizing a version for you.\n\nTo compute degree days, you take the difference from a baseline temperature and the mean temperature on a given day. To measure heat over time, you discard any days where the mean temperature is below the baseline. To measure cold over time, you discard any days where the mean temperature is above the baseline. For example, the U.S. uses 65 F as the base for both heating and cooling degree days. That's the temperature where no heating or cooling is needed. If a day has a mean temperature of 70 F, that day is five cooling degree days and zero heating degree days. Conversely, if the mean temperature is 55 F, that day is 10 heating degree days and 0 cooling degree days.\n\nYou can express these formulas as a small hierarchy of record types: an abstract degree day type and two concrete types for heating degree days and cooling degree days. These types can also be positional records. They take a baseline temperature and a sequence of daily temperature records as arguments to the primary constructor:\n\nThe abstract record is the shared base class for both the and records. The primary constructor declarations on the derived records show how to manage base record initialization. Your derived record declares parameters for all the parameters in the base record primary constructor. The base record declares and initializes those properties. The derived record doesn't hide them, but only creates and initializes properties for parameters that aren't declared in its base record. In this example, the derived records don't add new primary constructor parameters. Test your code by adding the following code to your method:\n\nYou get output like the following display:\n\nYour code calculates the correct number of heating and cooling degree days over that period of time. But this example shows why you might want to replace some of the synthesized methods for records. You can declare your own version of any of the compiler-synthesized methods in a record type except the clone method. The clone method has a compiler-generated name and you can't provide a different implementation. These synthesized methods include a copy constructor, the members of the System.IEquatable<T> interface, equality and inequality tests, and GetHashCode(). For this purpose, you synthesize . You could also declare your own , but provides a better option for inheritance scenarios. To provide your own version of a synthesized method, the signature must match the synthesized method.\n\nThe element in the console output isn't useful. It displays the type, but nothing else. You can change this behavior by providing your own implementation of the synthesized method. The signature depends on modifiers applied to the declaration:\n• If a record type is , or a , the signature is\n• If a record type isn't and derives from (that is, it doesn't declare a base record), the signature is\n• If a record type isn't and derives from another record, the signature is\n\nThese rules are easiest to comprehend through understanding the purpose of . adds information about each property in a record type to a string. The contract requires base records to add their members to the display and assumes derived members add their members. Each record type synthesizes a override that looks similar to the following example for :\n\nYou declare a method in the record that doesn't print the type of the collection:\n\nThe signature declares a method to match the compiler's version. Don't worry if you get the accessors wrong; the language enforces the correct signature. If you forget the correct modifiers for any synthesized method, the compiler issues warnings or errors that help you get the right signature.\n\nYou can declare the method as in a record type. That prevents derived records from providing a new implementation. Derived records will still contain the override. You would seal if you didn't want it to display the runtime type of the record. In the preceding example, you'd lose the information on where the record was measuring heating or cooling degree days.\n\nThe synthesized members in a positional record class don't modify the state of the record. The goal is that you can more easily create immutable records. Remember that you declare a to create an immutable record struct. Look again at the preceding declarations for and . The members added perform computations on the values for the record, but don't mutate state. Positional records make it easier for you to create immutable reference types.\n\nCreating immutable reference types means you want to use nondestructive mutation. You create new record instances that are similar to existing record instances using expressions. These expressions are a copy construction with extra assignments that modify the copy. The result is a new record instance where each property was copied from the existing record and optionally modified. The original record is unchanged.\n\nLet's add a couple features to your program that demonstrate expressions. First, let's create a new record to compute growing degree days using the same data. Growing degree days typically uses 41 F as the baseline and measures temperatures above the baseline. To use the same data, you can create a new record that is similar to the , but with a different base temperature:\n\nYou can compare the number of degrees computed to the numbers generated with a higher baseline temperature. Remember that records are reference types and these copies are shallow copies. The array for the data isn't copied, but both records refer to the same data. That fact is an advantage in one other scenario. For growing degree days, it's useful to keep track of the total for the previous five days. You can create new records with different source data using expressions. The following code builds a collection of these accumulations, then displays the values:\n\nYou can also use expressions to create copies of records. Don't specify any properties between the braces for the expression. That means create a copy, and don't change any properties:\n\nRun the finished application to see the results.\n\nThis tutorial showed several aspects of records. Records provide concise syntax for types where the fundamental use is storing data. For object-oriented classes, the fundamental use is defining responsibilities. This tutorial focused on positional records, where you can use a concise syntax to declare the properties for a record. The compiler synthesizes several members of the record for copying and comparing records. You can add any other members you need for your record types. You can create immutable record types knowing that none of the compiler-generated members would mutate state. And expressions make it easy to support nondestructive mutation.\n\nRecords add another way to define types. You use definitions to create object-oriented hierarchies that focus on the responsibilities and behavior of objects. You create types for data structures that store data and are small enough to copy efficiently. You create types when you want value-based equality and comparison, don't want to copy values, and want to use reference variables. You create types when you want the features of records for a type that is small enough to copy efficiently.\n\nYou can learn more about records in the C# language reference article for the record type and the proposed record type specification and record struct specification."
    },
    {
        "link": "https://medium.com/@iammanolov98/understanding-records-in-net-software-interview-junior-to-senior-c182932d5b5f",
        "document": "Welcome, engineers! Today, we will explore a theory question for a Mid level software engineering position.\n\nAs a mid level software engineer, you are likely always on the lookout for ways to improve the maintainability, readability, and efficiency of your code. One feature introduced in C# 9.0 that can greatly assist in achieving these goals is the “record” type. In this article, we will delve into the concept of records in C# .NET, understand their purpose, and explore scenarios where they can be incredibly beneficial.\n\nWell, you know what is coming next. A full blown technical article with code examples to accompany the theory, so place your booty in a comfortable position and Let’s Get Right Into It!\n\nWhat is a Record in C# .NET ❓\n\nLet’s start with the basics. What exactly do we mean by this keyword?\n\nA record is a new reference type introduced in C# 9.0, specifically designed for scenarios where you need to create immutable objects with value semantics. It combines the best aspects of classes and structs while adding a few additional features that make it particularly suited for modeling data."
    },
    {
        "link": "https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-8",
        "document": "I look forward to summer every year. Sun, beach, warm nights, and putting the finishing touches on the next version of .NET. It’s also the time I get to continue a tradition I started for myself back in 2017 of writing about the performance improvements that have gone into the latest .NET incarnation. A year ago that was Performance Improvements in .NET 7, which followed similar posts for .NET 6, .NET 5, .NET Core 3.0, .NET Core 2.1, and .NET Core 2.0.\n\nSince .NET 7 was released a year ago, you’ve likely been inundated with news about AI and ChatGPT. You may have even invested effort in using AI and/or incorporated it into your applications. And I got to wondering: could AI write this blog post for me? So I issued the following request to Bing Chat:\n\nFair enough (especially since, after writing this post and measuring the token count, it’s north of 300,000). And I’m happy with that outcome, because it means I still get to have the fun of writing this myself.\n\nThroughout the past year, as I was reviewing PRs in various .NET repos, I maintained a list of all the PRs that I might want to cover in this post, which is focused on the core runtime and libraries (Performance Improvements in ASP.NET Core 8 provides an in-depth focus on ASP.NET). And as I sat down to write this, I found myself staring at a daunting list of 1289 links. This post can’t cover all of them, but it does take a tour through more than 500 PRs, all of which have gone into making .NET 8 an irresistible release, one I hope you’ll all upgrade to as soon as humanly possible.\n\nThroughout this post, I include microbenchmarks to highlight various aspects of the improvements being discussed. Most of those benchmarks are implemented using BenchmarkDotNet v0.13.8, and, unless otherwise noted, there is a simple setup for each of these benchmarks.\n\nTo follow along, first make sure you have .NET 7 and .NET 8 installed. For this post, I’ve used the .NET 8 Release Candidate (8.0.0-rc.1.23419.4).\n\nWith those prerequisites taken care of, create a new C# project in a new directory:\n\nThat directory will contain two files: (the project file with information about how the application should be built) and (the code for the application). Replace the entire contents of with this:\n\nThe preceding project file tells the build system we want:\n• to build a runnable application (as opposed to a library),\n• to be able to run on both .NET 8 and .NET 7 (so that BenchmarkDotNet can run multiple processes, one with .NET 7 and one with .NET 8, in order to be able to compare the results),\n• to be able to use all of the latest features from the C# language even though C# 12 hasn’t officially shipped yet,\n• to be able to use the keyword in the code,\n• and to configure the garbage collector (GC) into its “server” configuration, which impacts the tradeoffs it makes between memory consumption and throughput (this isn’t strictly necessary, I’m just in the habit of using it, and it’s the default for ASP.NET apps.)\n\nThe at the end pulls in BenchmarkDotNet from NuGet so that we’re able to use the library in . (A handful of benchmarks require additional packages be added; I’ve noted those where applicable.)\n\nFor each benchmark, I’ve then included the full source; just copy and paste that code into , replacing its entire contents. In each test, you’ll notice several attributes may be applied to the class. The attribute indicates I want it to track managed allocation, the attribute indicates I want it to report on the actual assembly code generated for the test (and by default one level deep of functions invoked by the test), and the attribute simply suppresses some columns of data BenchmarkDotNet might otherwise emit by default but are unnecessary for our purposes here.\n\nRunning the benchmarks is then straightforward. Each shown test also includes a comment at the beginning for the command to run the benchmark. Typically, it’s something like this:\n• builds the benchmarks in a Release build. This is important for performance testing, as most optimizations are disabled in Debug builds, in both the C# compiler and the JIT compiler.\n• targets .NET 7 for the host project. In general with BenchmarkDotNet, you want to target the lowest-common denominator of all runtimes you’ll be executing against, so as to ensure that all of the APIs being used are available everywhere they’re needed.\n• runs all of the benchmarks in the whole program. The argument can be refined to scope down to just a subset of benchmarks desired, but says “run ’em all.”\n• runs the tests on both .NET 7 and .NET 8.\n\nThroughout the post, I’ve shown many benchmarks and the results I received from running them. All of the code works well on all supported operating systems and architectures. Unless otherwise stated, the results shown for benchmarks are from running them on Linux (Ubuntu 22.04) on an x64 processor (the one bulk exception to this is when I’ve used to show assembly code, in which case I’ve run them on Windows 11 due to a sporadic issue on Unix with on .NET 7 not always producing the requested assembly). My standard caveat: these are microbenchmarks, often measuring operations that take very short periods of time, but where improvements to those times add up to be impactful when executed over and over and over. Different hardware, different operating systems, what else is running on your machine, your current mood, and what you ate for breakfast can all affect the numbers involved. In short, don’t expect the numbers you see to match exactly the numbers I report here, though I have chosen examples where the magnitude of differences cited is expected to be fully repeatable.\n\nWith all that out of the way, let’s dive in…\n\nCode generation permeates every single line of code we write, and it’s critical to the end-to-end performance of applications that the compiler doing that code generation achieves high code quality. In .NET, that’s the job of the Just-In-Time (JIT) compiler, which is used both “just in time” as an application executes as well as in Ahead-Of-Time (AOT) scenarios as the workhorse to perform the codegen at build-time. Every release of .NET has seen significant improvements in the JIT, and .NET 8 is no exception. In fact, I dare say the improvements in .NET 8 in the JIT are an incredible leap beyond what was achieved in the past, in large part due to dynamic PGO…\n\nTo understand dynamic PGO, we first need to understand “tiering.” For many years, a .NET method was only ever compiled once: on first invocation of the method, the JIT would kick in to generate code for that method, and then that invocation and every subsequent one would use that generated code. It was a simple time, but also one frought with conflict… in particular, a conflict between how much the JIT should invest in code quality for the method and how much benefit would be gained from that enhanced code quality. Optimization is one of the most expensive things a compiler does; a compiler can spend an untold amount of time searching for additional ways to shave off an instruction here or improve the instruction sequence there. But none of us has an infinite amount of time to wait for the compiler to finish, especially in a “just in time” scenario where the compilation is happening as the application is running. As such, in a world where a method is compiled once for that process, the JIT has to either pessimize code quality or pessimize how long it takes to run, which means a tradeoff between steady-state throughput and startup time.\n\nAs it turns out, however, the vast majority of methods invoked in an application are only ever invoked once or a small number of times. Spending a lot of time optimizing such methods would actually be a deoptimization, as likely it would take much more time to optimize them than those optimizations would gain. So, .NET Core 3.0 introduced a new feature of the JIT known as “tiered compilation.” With tiering, a method could end up being compiled multiple times. On first invocation, the method would be compiled in “tier 0,” in which the JIT prioritizes speed of compilation over code quality; in fact, the mode the JIT uses is often referred to as “min opts,” or minimal optimization, because it does as little optimization as it can muster (it still maintains a few optimizations, primarily the ones that result in less code to be compiled such that the JIT actually runs faster). In addition to minimizing optimizations, however, it also employs call counting “stubs”; when you invoke the method, the call goes through a little piece of code (the stub) that counts how many times the method was invoked, and once that count crosses a predetermined threshold (e.g. 30 calls), the method gets queued for re-compilation, this time at “tier 1,” in which the JIT throws every optimization it’s capable of at the method. Only a small subset of methods make it to tier 1, and those that do are the ones worthy of additional investment in code quality. Interestingly, there are things the JIT can learn about the method from tier 0 that can lead to even better tier 1 code quality than if the method had been compiled to tier 1 directly. For example, the JIT knows that a method “tiering up” from tier 0 to tier 1 has already been executed, and if it’s already been executed, then any fields it accesses are now already initialized, which means the JIT can look at the values of those fields and base the tier 1 code gen on what’s actually in the field (e.g. if it’s a , the JIT can now treat the value of that field as if it were ). If the method were instead compiled directly to tier 1, the JIT might not be able to make the same optimizations. Thus, with tiering, we can “have our cake and eat it, too.” We get both good startup and good throughput. Mostly…\n\nOne wrinkle to this scheme, however, is the presence of longer-running methods. Methods might be important because they’re invoked many times, but they might also be important because they’re invoked only a few times but end up running forever, in particular due to looping. As such, tiering was disabled by default for methods containing backward branches, such that those methods would go straight to tier 1. To address that, .NET 7 introduced On-Stack Replacement (OSR). With OSR, the code generated for loops also included a counting mechanism, and after a loop iterated to a certain threshold, the JIT would compile a new optimized version of the method and jump from the minimally-optimized code to continue execution in the optimized variant. Pretty slick, and with that, in .NET 7 tiering was also enabled for methods with loops.\n\nBut why is OSR important? If there are only a few such long-running methods, what’s the big deal if they just go straight to tier 1? Surely startup isn’t significantly negatively impacted? First, it can be: if you’re trying to trim milliseconds off startup time, every method counts. But second, as noted before, there are throughput benefits to going through tier 0, in that there are things the JIT can learn about a method from tier 0 which can then improve its tier 1 compilation. And the list of things the JIT can learn gets a whole lot bigger with dynamic PGO.\n\nProfile-Guided Optimization (PGO) has been around for decades, for many languages and environments, including in .NET world. The typical flow is you build your application with some additional instrumentation, you then run your application on key scenarios, you gather up the results of that instrumentation, and then you rebuild your application, feeding that instrumentation data into the optimizer, allowing it to use the knowledge about how the code executed to impact how it’s optimized. This approach is often referred to as “static PGO.” “Dynamic PGO” is similar, except there’s no effort required around how the application is built, scenarios it’s run on, or any of that. With tiering, the JIT is already generating a tier 0 version of the code and then a tier 1 version of the code… why not sprinkle some instrumentation into the tier 0 code as well? Then the JIT can use the results of that instrumentation to better optimize tier 1. It’s the same basic “build, run and collect, re-build” flow as with static PGO, but now on a per-method basis, entirely within the execution of the application, and handled automatically for you by the JIT, with zero additional dev effort required and zero additional investment needed in build automation or infrastructure.\n\nDynamic PGO first previewed in .NET 6, off by default. It was improved in .NET 7, but remained off by default. Now, in .NET 8, I’m thrilled to say it’s not only been significantly improved, it’s now on by default. This one-character PR to enable it might be the most valuable PR in all of .NET 8: dotnet/runtime#86225.\n\nThere have been a multitude of PRs to make all of this work better in .NET 8, both on tiering in general and then on dynamic PGO in particular. One of the more interesting changes is dotnet/runtime#70941, which added more tiers, though we still refer to the unoptimized as “tier 0” and the optimized as “tier 1.” This was done primarily for two reasons. First, instrumentation isn’t free; if the goal of tier 0 is to make compilation as cheap as possible, then we want to avoid adding yet more code to be compiled. So, the PR adds a new tier to address that. Most code first gets compiled to an unoptimized and uninstrumented tier (though methods with loops currently skip this tier). Then after a certain number of invocations, it gets recompiled unoptimized but instrumented. And then after a certain number of invocations, it gets compiled as optimized using the resulting instrumentation data. Second, / (R2R) images were previously unable to participate in dynamic PGO. This was a big problem for taking full advantage of all that dynamic PGO offers, in particular because there’s a significant amount of code that every .NET application uses that’s already R2R’d: the core libraries. is an AOT technology that enables most of the code generation work to be done at build-time, with just some minimal fix-ups applied when that precompiled code is prepared for execution. That code is optimized and not instrumented, or else the instrumentation would slow it down. So, this PR also adds a new tier for R2R. After an R2R method has been invoked some number of times, it’s recompiled, again with optimizations but this time also with instrumentation, and then when that’s been invoked sufficiently, it’s promoted again, this time to an optimized implementation utilizing the instrumentation data gathered in the previous tier.\n\nThere have also been multiple changes focused on doing more optimization in tier 0. As noted previously, the JIT wants to be able to compile tier 0 as quickly as possible, however some optimizations in code quality actually help it to do that. For example, dotnet/runtime#82412 teaches it to do some amount of constant folding (evaluating constant expressions at compile time rather than at execution time), as that can enable it to generate much less code. Much of the time the JIT spends compiling in tier 0 is for interactions with the Virtual Machine (VM) layer of the .NET runtime, such as resolving types, and so if it can significantly trim away branches that won’t ever be used, it can actually speed up tier 0 compilation while also getting better code quality. We can see this with a simple repro app like the following:\n\nI can set the environment variable to ; that will result in the JIT printing out to the console the code it emits for this method. On .NET 7, when I run this ( ), I get the following tier 0 code:\n\nThe important thing to note here is that all of the code associated with the had to be emitted, including the JIT needing to resolve the method tokens involved (which is how it knew to print “System.Console:WriteLine”), even though that branch will provably never be taken (it’s only taken when and the JIT can see that is a ). Now in .NET 8, it applies the previously-reserved-for-tier-1 constant folding optimizations that recognize the value is not an and generates tier 0 code accordingly ( ):\n\ndotnet/runtime#77357 and dotnet/runtime#83002 also enable some JIT intrinsics to be employed in tier 0 (a JIT intrinsic is a method the JIT has some special knowledge of, either knowing about its behavior so it can optimize around it accordingly, or in many cases actually supplying its own implementation to replace the one in the method’s body). This is in part for the same reason; many intrinsics can result in better dead code elimination (e.g. ). But more so, without recognizing intrinsics as being special, we might end up generating code for an intrinsic method that we would never otherwise need to generate code for, even in tier 1. dotnet/runtime#88989 also eliminates some forms of boxing in tier 0.\n\nCollecting all of this instrumentation in tier 0 instrumented code brings with it some of its own challenges. The JIT is augmenting a bunch of methods to track a lot of additional data; where and how does it track it? And how does it do so safely and correctly when multiple threads are potentially accessing all of this at the same time? For example, one of the things the JIT tracks in an instrumented method is which branches are followed and how frequently; that requires it to count each time code traverses that branch. You can imagine that happens, well, a lot. How can it do the counting in a thread-safe yet efficient way?\n\nThe answer previously was, it didn’t. It used racy, non-synchronized updates to a shared value, e.g. . This means that some updates might get lost in the presence of multithreaded access, but as the answer here only needs to be approximate, that was deemed ok. As it turns out, however, in some cases it was resulting in a lot of lost counts, which in turn caused the JIT to optimize for the wrong things. Another approach tried for comparison purposes in dotnet/runtime#82775 was to use interlocked operations (e.g. if this were C#, ); that results in perfect accuracy, but that explicit synchronization represents a huge potential bottleneck when heavily contended. dotnet/runtime#84427 provides the approach that’s now enabled by default in .NET 8. It’s an implementation of a scalable approximate counter that employs some amount of pseudo-randomness to decide how often to synchronize and by how much to increment the shared count. There’s a great description of all of this in the dotnet/runtime repo; here is a C# implementation of the counting logic based on that discussion:\n\nFor current count values less than 8192, it ends up just doing the equivalent of an . However, as the count increases to beyond that threshold, it starts only doing the add randomly half the time, and when it does, it adds 2. Then randomly a quarter of the time it adds 4. Then an eighth of the time it adds 8. And so on. In this way, as more and more increments are performed, it requires writing to the shared counter less and less frequently.\n\nWe can test this out with a little app like the following (if you want to try running it, just copy the above into the program as well):\n\nWhen I run that, I get results like this:\n\nI find these results fascinating. The interlocked approach gets the exact right count, but it’s super slow, ~20x slower than the other approaches. The fastest is the racy additions one, but its count is also wildly inaccurate: it was off by a factor of 8x! The scalable counters solution was only a hair slower than the racy solution, but its count was only off the expected value by 0.5%. This scalable approach then enables the JIT to track what it needs with the efficiency and approximate accuracy it needs. Other PRs like dotnet/runtime#82014, dotnet/runtime#81731, and dotnet/runtime#81932 also went into improving the JIT’s efficiency around tracking this information.\n\nAs it turns out, this isn’t the only use of randomness in dynamic PGO. Another is used as part of determining which types are the most common targets of virtual and interface method calls. At a given call site, the JIT wants to know which type is most commonly used and by what percentage; if there’s a clear winner, it can then generate a fast path specific to that type. As in the previous example, tracking a count for every possible type that might come through is expensive. Instead, it uses an algorithm known as “reservoir sampling”. Let’s say I have a containing ~60% s, ~30% s, and ~10% s, and I want to know which is the most common. With reservoir sampling, I might do so like this:\n\nWhen I run this, I get results like the following:\n\nNote that in the above example, I actually had all the data in advance; in contrast, the JIT likely has multiple threads all running instrumented code and overwriting elements in the reservoir. I also happened to choose the same size reservoir the JIT is using as of dotnet/runtime#87332, which highlights how that value was chosen for its use case and why it needed to be tweaked.\n\nOn all five runs above, it correctly found there to be more s than s and more s than s, and it was often reasonably close to the actual percentages. But, importantly, randomness is involved here, and every run produced slightly different results. I mention this because that means the JIT compiler now incorporates randomness, which means that the produced dynamic PGO instrumentation data is very likely to be slightly different from run to run. However, even without explicit use of randomness, there’s already non-determinism in such code, and in general there’s enough data produced that the overall behavior is quite stable and repeatable.\n\nInterestingly, the JIT’s PGO-based optimizations aren’t just based on the data gathered during instrumented tier 0 execution. With dotnet/runtime#82926 (and a handful of follow-on PRs like dotnet/runtime#83068, dotnet/runtime#83567, dotnet/runtime#84312, and dotnet/runtime#84741), the JIT will now create a synthetic profile based on statically analyzing the code and estimating a profile, such as with various approaches to static branch prediction. The JIT can then blend this data together with the instrumentation data, helping to fill in data where there are gaps (think “Jurassic Park” and using modern reptile DNA to plug the gaps in the recovered dinosaur DNA).\n\nBeyond the mechanisms used to enable tiering and dynamic PGO getting better (and, did I mention, being on by default?!) in .NET 8, the optimizations it performs also get better. One of the main optimizations dynamic PGO feeds is the ability to devirtualize virtual and interface calls per call site. As noted, the JIT tracks what concrete types are used, and then can generate a fast path for the most common type; this is known as guarded devirtualization (GDV). Consider this benchmark:\n\nThe method is doing:\n\nWithout PGO, that’s just a normal interface dispatch. With PGO, however, the JIT will end up seeing that the actual type of is most commonly , and it will end up generating tier 1 code closer to if my benchmark was instead:\n\nIt can then in turn see that the method is really simple, and so not only is the call devirtualized, it’s also inlined, such that the code effectively becomes:\n\nWe can confirm this by running the above benchmark. The resulting numbers certainly show something going on:\n\nWe see it’s both faster (which we expected) and more code (which we also expected). Now for the assembly. On .NET 7, we get this:\n\nWe can see it’s performing the interface call (the three s followed by the ) and then multiplying the result by ( ). Now on .NET 8, we get this:\n\nWe still see the , but it’s buried in a cold section at the end. Instead, we see the type of the object being compared against , and if it matches (the followed by the ), we store into ; is the hex representation of , so this is the entirety of the inlined body of the devirtualized call. .NET 8 is also capable of doing multiple GDVs, meaning it can generate fast paths for more than 1 type, thanks in large part to dotnet/runtime#86551 and dotnet/runtime#86809. However, this is off by default and for now needs to be opted-into with a configuration setting (setting the environment variable to the desired maximum number of types for which to test). We can see the impact of that with this benchmark (note that because I’ve explicitly specified the configs to use in the code itself, I’ve omitted the argument in the command):\n\nAnd in the assembly code with the environment variable set, we can indeed see it doing multiple checks for three types before falling back to the general interface dispatch:\n\ndotnet/runtime#75140 provides another really nice optimization, still related to GDV, but now for delegates and in relation to loop cloning. Take the following benchmark:\n\nDynamic PGO is capable of doing GDV with delegates just as it is with virtual and interface methods. The JIT’s profiling of this method will highlight that the function being invoked is always the same lambda, and as we saw, that can then be transformed into a method something like the following pseudo-code:\n\nIt’s not very visible that inside our loop we’re performing the same check over and over and over. We’re also branching based on it. One common compiler optimization is “hoisting,” where a computation that’s “loop invariant” (meaning it doesn’t change per iteration) can be pulled out of the loop to be above it, e.g.\n\nbut even with that, we still have the branch on each iteration. Wouldn’t it be nice if we could hoist that as well? What if we could “clone” the loop, duplicating it once for when the method is the known target and once for when it’s not. That’s “loop cloning,” an optimization the JIT is already capable of for other reasons, and now in .NET 8 the JIT is capable of that with this exact scenario, too. The code it’ll produce ends up then being very similar to this:\n\nLooking at the generated assembly on .NET 8 confirms this:\n\nFocus just on the block: you can see it ends with a to loop back around to if (which is storing ) is less than 0x2710, or 10,000 decimal, aka our loop’s upper bound. Note that there are just a few instructions in the middle, nothing at all resembling a … this is the optimized cloned loop, where our lambda has been inlined. There’s another loop that alternates between , , and , and that one does have a … that’s the fallback loop. And if we run the benchmark, we see a huge resulting improvement:\n\nAs long as we’re discussing hoisting, it’s worth noting other improvements have also contributed. In particular, dotnet/runtime#81635 enables the JIT to hoist more code used in generic method dispatch. We can see that in action with a benchmark like this:\n\nBefore moving on, one word of warning about dynamic PGO: it’s good at what it does, really good. Why is that a “warning?” Dynamic PGO is very good about seeing what your code is doing and optimizing for it, which is awesome when you’re talking about your production applications. But there’s a particular kind of coding where you might not want that to happen, or at least you need to be acutely aware of it happening, and you’re currently looking at it: benchmarks. Microbenchmarks are all about isolating a particular piece of functionality and running that over and over and over and over in order to get good measurements about its overhead. With dynamic PGO, however, the JIT will then optimize for the exact thing you’re testing. If the thing you’re testing is exactly how the code will execute in production, then awesome. But if your test isn’t fully representative, you can get a skewed understanding of the costs involved, which can lead to making less-than-ideal assumptions and decisions.\n\nFor example, consider this benchmark:\n\nThis runs a benchmark with two different “Probability” values. Regardless of that value, the code that’s executed for the benchmark does exactly the same thing and should result in exactly the same assembly code (other than one path checking for the value and the other for ). In a world without PGO, there should be close to zero difference in performance between the runs, and if we set the environment variable to (to disable PGO), that’s exactly what we see, but with PGO, we observe a larger difference:\n\nWhen all of the calls use (because we set the probability to 1, all of the random values are less than that, and we always take the first branch), we see throughput ends up being 25% faster than when half of the calls use and half use . If your benchmark was only trying to measure the overhead of using , you might not realize that the resulting code was being optimized for calling with the same delegate every time, in which case you get different results than if is called with multiple delegates and all with reasonably equal chances of being used. (As an aside, the nice overall improvement between dynamic PGO being disabled and enabled comes in part from the use of , which internally makes a virtual call that can help elide.)\n\nThroughout the rest of this post, I’ve kept this in mind and tried hard to show benchmarks where the resulting wins are due primarily to the cited improvements in the relevant code; where dynamic PGO plays a larger role in the improvements, I’ve called that out, often showing the results with and without dynamic PGO. There are many more benchmarks I could have shown but have avoided where it would look like a particular method had massive improvements, yet in reality it’d all be due to dynamic PGO being its awesome self rather than some explicit change made to the method’s C# code.\n\nOne final note about dynamic PGO: it’s awesome, but it doesn’t obviate the need for thoughtful coding. If you know and can use something’s concrete type rather than an abstraction, from a performance perspective it’s better to do so rather than hoping the JIT will be able to see through it and devirtualize. To help with this, a new analyzer, CA1859, was added to the .NET SDK in dotnet/roslyn-analyzers#6370. The analyzer looks for places where interfaces or base classes could be replaced by derived types in order to avoid interface and virtual dispatch. dotnet/runtime#80335 and dotnet/runtime#80848 rolled this out across dotnet/runtime. As you can see from the first PR in particular, there were hundreds of places identified that with just an edit of one character (e.g. replacing with ), we could possibly reduce overheads.\n\nAnother huge area of investment in code generation in .NET 8 is around vectorization. This is a continuation of a theme that’s been going for multiple .NET releases. Almost a decade ago, .NET gained the type. .NET Core 3.0 and .NET 5 added thousands of intrinsic methods for directly targeting specific hardware instructions. .NET 7 provided hundreds of cross-platform operations for and to enable SIMD algorithms on fixed-width vectors. And now in .NET 8, .NET gains support for AVX512, both with new hardware intrinsics directly exposing AVX512 instructions and with the new and types.\n\nThere were a plethora of changes that went into improving existing SIMD support, such as dotnet/runtime#76221 that improves the handling of when it’s not hardware accelerated by lowering it as two operations. Or like dotnet/runtime#87283, which removed the generic constraint on the in all of the vector types in order to make them easier to use in a larger set of contexts. But the bulk of the work in this area in this release is focused on AVX512.\n\nWikipedia has a good overview of AVX512, which provides instructions for processing 512-bits at a time. In addition to providing wider versions of the 256-bit instructions seen in previous instruction sets, it also adds a variety of new operations, almost all of which are exposed via one of the new types in , like , , , , and . dotnet/runtime#83040 kicked things off by stubbing out the various files, followed by dozens of PRs that filled in the functionality, for example dotnet/runtime#84909 that added the 512-bit variants of the SSE through SSE4.2 intrinsics that already exist; like dotnet/runtime#75934 from @DeepakRajendrakumaran and dotnet/runtime#77419 from @DeepakRajendrakumaran that added support for the EVEX encoding used by AVX512 instructions; like dotnet/runtime#74113 from @DeepakRajendrakumaran that added the logic for detecting AVX512 support; like dotnet/runtime#80960 from @DeepakRajendrakumaran and dotnet/runtime#79544 from @anthonycanino that enlightened the register allocator and emitter about AVX512’s additional registers; and like dotnet/runtime#87946 from @Ruihan-Yin and dotnet/runtime#84937 from @jkrishnavs that plumbed through knowledge of various intrinsics.\n\nLet’s take it for a spin. The machine on which I’m writing this doesn’t have AVX512 support, but my Dev Box does, so I’m using that for AVX512 comparisons (using WSL with Ubuntu). In last year’s Performance Improvements in .NET 7, we wrote a method that used if there was sufficient data available and it was accelerated, or else if there was sufficient data available and it was accelerated, or else a scalar fallback. Tweaking that to also “light up” with AVX512 took me literally less than 30 seconds: copy/paste the code block for and then search and replace in that copy from “Vector256” to “Vector512″… boom, done. Here it is in a benchmark, using environment variables to disable the JIT’s ability to use the various instruction sets so that we can try out this method with each acceleration path:\n\nNumerous PRs elsewhere in the JIT then take advantage of AVX512 support when it’s available. For example, separate from AVX512, dotnet/runtime#83945 and dotnet/runtime#84530 taught the JIT how to unroll operations, such that the JIT can emit optimized, vectorized replacements when it can see a constant length for at least one of the inputs. “Unrolling” means that rather than emitting a loop for N iterations, each of which does the loop body once, a loop is emitted for N / M iterations, where every iteration does the loop body M times (and if N == M, there is no loop at all). So for a benchmark like this:\n\nwe now get results like this:\n\nFor .NET 7, we see assembly code like this (note the instruction to the underlying helper):\n\nAnd now for .NET 8, we get assembly code like this:\n\nNow there’s no , with the entire implementation provided by the JIT; we can see it making liberal use of the 128-bit SIMD registers. However, those PRs only enabled the JIT to handle up to 64 bytes being compared (unrolling results in larger code, so at some length it no longer makes sense to unroll). With AVX512 support in the JIT, dotnet/runtime#84854 then extends that up to 128 bytes. This is easily visible in a benchmark like this, which is similar to the previous example, but with larger data:\n\nOn my Dev Box with AVX512 support, for .NET 8 we get:\n\nNow instead of the 128-bit registers, we see use of the 512-bit registers from AVX512.\n\nThe JIT in .NET 8 also now unrolls s ( , , etc.) for small-enough constant lengths, thanks to dotnet/runtime#83638 and dotnet/runtime#83740. And then with dotnet/runtime#84348 that unrolling takes advantage of AVX512 if it’s available. dotnet/runtime#85501 extends this to , too.\n\ndotnet/runtime#84885 extended the unrolling and vectorization done as part of / and to utilize AVX512 when available, as well.\n\nIt’s so fast in .NET 8 because, whereas with .NET 7 it ends up calling through to the underlying helper:\n\nin .NET 8, the JIT generates code for the operation directly, taking advantage of AVX512’s greater width and thus able to process a larger input without significantly increasing code size:\n\nEven super simple operations get in on the action. Here we just have a cast from a to a :\n\nThanks to dotnet/runtime#84384 from @khushal1996, the code for that shrinks from this:\n\nusing the AVX instruction, to this:\n\nAs yet another example, with dotnet/runtime#87641 we see the JIT using AVX512 to accelerate various APIs:\n\nBranching is integral to all meaningful code; while some algorithms are written in a branch-free manner, branch-free algorithms typically are challenging to get right and complicated to read, and typically are isolated to only small regions of code. For everything else, branching is the name of the game. Loops, if/else blocks, ternaries… it’s hard to imagine any real code without them. Yet they can also represent one of the more significant costs in an application. Modern hardware gets big speed boosts from pipelining, for example from being able to start reading and decoding the next instruction while the previous ones are still processing. That, of course, relies on the hardware knowing what the next instruction is. If there’s no branching, that’s easy, it’s whatever instruction comes next in the sequence. For when there is branching, CPUs have built-in support in the form of branch predictors, used to determine what the next instruction most likely will be, and they’re often right… but when they’re wrong, the cost incurred from that incorrect branch prediction can be huge. Compilers thus strive to minimize branching.\n\nOne way the impact of branches is reduced is by removing them completely. Redundant branch optimizers look for places where the compiler can prove that all paths leading to that branch will lead to the same outcome, such that the compiler can remove the branch and everything in the path not taken. Consider the following example:\n\nRunning that on .NET 7, we can glimpse into the impact of failed branch prediction. When we always take the branch the same way, the throughput is 2.5x what it was when it was impossible for the branch predictor to determine where we were going next:\n\nWe can also use this example for a .NET 8 improvement. That guarded call has its own branch to ensure that is within the bounds of the span; we can see that very clearly by looking at the disassembly generated on .NET 7:\n\nIn particular, look at :\n\nAt this point, either or (0x14) has been loaded into , and it’s being compared against , which was loaded from the span’s earlier ( ). There’s a very obvious redundant branch here, as the code does , and then if it doesn’t jump as part of the , it does the exact same comparison again; the first is the one we wrote in , the second is the one from itself, which got inlined.\n\nOn .NET 8, thanks to dotnet/runtime#72979 and dotnet/runtime#75804, that branch (and many others of a similar ilk) is optimized away. We can run the exact same benchmark, this time on .NET 8, and if we look at the assembly at the corresponding code block (which isn’t numbered exactly the same because of other changes):\n\nwe can see that, indeed, the redundant branch has been eliminated.\n\nAnother way the overhead associated with branches (and branch misprediction) is removed is by avoiding them altogether. Sometimes simple bit manipulation tricks can be employed to avoid branches. dotnet/runtime#62689 from @pedrobsaila, for example, finds expressions like for signed integers and , and rewrites them to the equivalent of .\n\nHere instead of code like we’d get on .NET 7, which involves a branch for the :\n\nnow on .NET 8, the result is branchless:\n\nSuch bit tricks, however, only get you so far. To go further, both x86/64 and Arm provide conditional move instructions, like on x86/64 and on Arm, that encapsulate the condition into the single instruction. For example, “conditionally selects” the value from one of two register arguments based on whether the condition is true or false and writes that value into the destination register. The instruction pipeline stays filled then because the instruction after the is always the next instruction; there’s no control flow that would result in a different instruction coming next.\n\nThe JIT in .NET 8 is now capable of emitting conditional instructions, on both x86/64 and Arm. With PRs like dotnet/runtime#73472 from @a74nh and dotnet/runtime#77728 from @a74nh, the JIT gains an additional “if conversion” optimization phase, where various conditional patterns are recognized and morphed into conditional nodes in the JIT’s internal representation; these can then later be emitted as conditional instructions, as was done by dotnet/runtime#78879, dotnet/runtime#81267, dotnet/runtime#82235, dotnet/runtime#82766, and dotnet/runtime#83089. Other PRs, like dotnet/runtime#84926 from @SwapnilGaikwad and dotnet/runtime#82031 from @SwapnilGaikwad optimized which exact instructions would be employed, in these cases using the Arm and instructions.\n\nWe can see all this in a simple benchmark:\n• In .NET 7, the cost with a probability of 0.5 is 3x that of when it had a probability of 1.0, due to the branch predictor not being able to successfully predict which way the actual branch would go.\n• In .NET 8, it doesn’t matter whether the probability is 0.5 or 1: the cost is the same (and cheaper than on .NET 7).\n\nWe can also look at the generated assembly to see the difference. In particular, on .NET 8, we see this for the generated assembly:\n\nThat sequence in there is the comparison between the randomly-generated floating-point value and the probability threshold followed by the conditional move (“conditionally move if below or equal”).\n\nThere are many methods that implicitly benefit from these transformations. Take even a simple method, like , whose code I’ve copied here:\n\nThat pattern should look familiar. Here’s the assembly we get on .NET 7:\n\nThe two arguments come in via the and registers. They’re compared, and if the first argument is greater than or equal to the second, it jumps down to the bottom where the first argument is moved into as the return value; if it wasn’t, then the second value is moved into . And on .NET 8:\n\nAgain the two arguments come in via the and registers, and they’re compared. The second argument is then moved into as the return value. If the comparison showed that the first argument was greater than the second, it’s then moved into (overwriting the second argument that was just moved there). Fun.\n\nNote if you ever find yourself wanting to do a deeper-dive into this area, BenchmarkDotNet has some excellent additional tools at your disposal. On Windows, it enables you to collect hardware counters, which expose a wealth of information about how things actually executed on the hardware, whether it be number of instructions retired, cache misses, or branch mispredictions. To use it, add another package reference to your .csproj:\n\nand add an additional attribute to your tests class:\n\nThen make sure you’re running the benchmarks from an elevated / admin terminal. When I do that, now I see this:\n\nWe can see it confirms what we already knew: on .NET 7 with a 0.5 probability, it ends up mispredicting a branch.\n\nThe C# compiler (aka “Roslyn”) also gets in on the branch-elimination game in .NET 8, for a very specific kind of branch. In .NET, while we think of as only being a two-value type ( and ), is actually one byte. That means a can technically have 256 different values, where 0 is considered and [1,255] are all considered . Thankfully, unless a developer is poking around the edges of interop or otherwise using code to purposefully manipulate these other values, developers can remain blissfully unaware of the actual numeric value here, for two reasons. First, C# doesn’t consider to be a numerical type, and thus you can’t perform arithmetic on it or cast it to a type like . Second, all of the s produced by the runtime and C# are normalized to actually be 0 or 1 in value, e.g. a IL instruction is documented as “If value1 is greater than value2, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.” There is a class of algorithms, however, where being able to rely on such 0 and 1 values is handy, and we were just talking about them: branch-free algorithms.\n\nLet’s say we didn’t have the JIT’s new-found ability to use conditional moves and we wanted to write our own method for integers:\n\nIf we could rely on always being 0 or 1 (we can’t), and if we could do arithmetic on a (we can’t), then we could use the behavior of multiplication to implement our function. Anything multiplied by 0 is 0, and anything multiplied by 1 is itself, so we could write our like this:\n\nThen if is 1, would be and would be 0, such that the whole expression would evaluate to . And, conversely, if is 0, would be 0 and would be , such that the whole expression would evaluate to . As noted, though, we can’t write the above, but we could write this:\n\nThat provides the exact semantics we want… but we’ve introduced two branches into our supposedly branch-free algorithm. This is the IL produced for that in .NET 7:\n\nNote all those and instructions in there. Are they necessary, though? Earlier I noted that the runtime will only produce s with a value of 0 or 1. And thanks to dotnet/roslyn#67191, the C# compiler now recognizes that and optimizes the pattern to be branchless. Our same function now in .NET 8 compiles to this:\n\nZero branch instructions. Of course, you wouldn’t actually want to write this function like this anymore; just because it’s branch-free doesn’t mean it’s the most efficient. On .NET 8, here’s the assembly code produced by the JIT for the above:\n\nwhereas if you just wrote it as:\n\nEven so, this C# compiler optimization is useful for other branch-free algorithms. Let’s say I wanted to write a method that would compare two s, returning -1 if the first is less than the second, 0 if they’re equal, and 1 if the first is greater than the second. I could write that like this:\n\nSimple, but every invocation will incur at least one branch, if not two. With the optimization, we can instead write it like this:\n\nThis is now branch-free, with the C# compiler producing:\n\nand, from that, the JIT producing:\n\nDoes that mean that everyone should now be running to rewrite their algorithms in a branch-free manner? Most definitely not. It’s another tool in your tool belt, and in some cases it’s quite beneficial, especially when it can provide more consistent throughput results due to doing the same work regardless of outcome. It’s not always a win, however, and in general it’s best not to try to outsmart the compiler. Take the example we just looked at. There’s a function with that exact implementation in the core libraries: . And if you look at its implementation in .NET 8, you’ll find that it’s still using the branch-based implementation. Why? Because it often yields better results, in particular in the common case where the operation gets inlined and the JIT is able to combine the branches in the method with ones based on processing the result of . Most uses of involve additional branching based on its result, such as in a quick sort partitioning step that’s deciding whether to move elements. So let’s take an example where code makes a decision based on the result of such a comparison:\n\nNote that both implementations now have just one branch (a in the “branching” case and a in the “branchless” case), and the “branching” implementation results in less assembly code.\n\nArrays, strings, and spans are all bounds checked by the runtime. That means that indexing into one of these data structures incurs validation to ensure that the index is within the bounds of the data structure. For example, the method here:\n\nresults in this code being generated for the method:\n\nHere, the is passed in , the is in , and the code is comparing the value of the index against the value stored at an 8-byte offset from the beginning of the array: that’s where the array’s length is stored. The instruction (jump if above or equal) is an unsigned comparison, such that if , it’ll jump to , where we see a call to a helper function that will throw an . All of that is the “bounds check.” The actual access into the array is the two and instructions, where the is moved into , and then the value located at (the address of the array) + (the index) + 0x10 (the offset of the start of the data in the array) is moved into the return register.\n\nIt’s the runtime’s responsibility to ensure that all accesses are guaranteed in bounds. It can do so with a bounds check. But it can also do so by proving that the index is always in range, in which case it can elide adding a bounds check that would only add overhead and provide zero benefit. Every .NET release, the JIT improves its ability to recognize patterns that don’t need a bounds check added because there’s no way the access could be out of range. And .NET 8 is no exception, with it learning several new and valuable tricks.\n\nOne such trick comes from dotnet/runtime#84231, where it learns how to avoid bounds checks in a pattern that’s very prevalent in collections, in particular in hash tables. In a hash table, you generally compute a hash code for a key and then use that key to index into an array (often referred to as “buckets”). As the hash code might be any and the buckets array is invariably going to be much smaller than the full range of a 32-bit integer, all of the hash codes need to be mapped down to an element in the array, and a good way to do that is by mod’ing the hash code by the array’s length, e.g.\n\nNote the , the tell-tale sign of a bounds check. Now in .NET 8, the JIT recognizes that it’s impossible for a value ‘d by an array’s length to be out of bounds of that array; either the array’s is greater than 0, in which case the result of the will always be and , or the is 0, and will throw an exception. As such, it can elide the bounds check:\n\nNow consider this:\n\nOur function is checking to see whether the supplied string begins and ends with a quote. It needs to be at least two characters long, and the first and last characters need to be quotes ( is shorthand for and expanded by the C# compiler into the equivalent of ). Here’s the .NET 7 assembly:\n\nNote that our function is indexing into the string twice, and the assembly does have a at the end of the method, but there’s only one referring to the location of that . That’s because the JIT already knows to avoid the bounds check on the access: it sees that it’s already been verified that the string’s , so it’s safe to index without a bounds check into any index . But, we do still have the bounds check for the . Now in .NET 8, we get this:\n\nNote the distinct lack of the ; no more bounds checks. Not only did the JIT recognize that is safe because , thanks to dotnet/runtime#84213 it also recognized that since , is and , which means it’s in-bounds and thus no range check is needed.\n\nAnother important operation employed by compilers is constant folding (and the closely related constant propagation). Constant folding is just a fancy name for a compiler evaluating expressions at compile-time, e.g. if you have , rather than emitting a multiplication instruction, it can just do the multiplication at compile-time and substitute . Constant propagation is then the act of taking that new constant and using it anywhere this expression’s result feeds, e.g. if you have:\n\na compiler can instead pretend it was:\n\nI bring this up here, after we just talked about bounds-check elimination, because there are scenarios where constant folding and bounds check elimination go hand-in-hand. If we can determine a data structure’s length at compile-time, and we can determine an index at a compile-time, then also at compile-time we can determine whether the index is in bounds and avoid the bounds check. We can also take it further: if we can determine not only the data structure’s length but also its contents, then we can do the indexing at compile-time and substitute the value from the data structure.\n\nConsider this example, which is similar in nature to the kind of code types often have in their or implementations:\n\nWe have a method for formatting the value according to the specified . The call site is explicit about the format to use, as many such call sites are, explicitly passing here. The implementation is then special-casing formats that are one-character long and match in an ignore-case manner against one of three known formats (it’s using an ASCII trick based on the values of the lowercase letters being one bit different from their uppercase counterparts, such that ‘ing an uppercase ASCII letter with lowercases it). If we look at the assembly generated for this method in .NET 7, we get this:\n\nWe can see the code here from but this is the code for , so the callee was successfully inlined. We also don’t see any code for the (the first is part of the ), nor do we see any signs of a bounds check (there’s no ). We do, however, see it loading the first character from :\n\nand then using the equivalent of a cascading / . Now let’s look at .NET 8:\n\nWhoa. It not only saw that ‘s was 1 and not only was able to avoid the bounds check, it actually read the first character, lowercased it, and matched it against all the branches, such that the entire operation was constant folded and propagated away, leaving just a call to . That’s primarily thanks to dotnet/runtime#78593.\n\nThere are a multitude of other such improvements, such as dotnet/runtime#77593 which enables it to constant fold the length of a or stored in a field. Consider:\n\nOn .NET 7, I get the following assembly:\n\nThis is effectively a 1:1 translation of the C#, with not much interesting happening: it loads the string from , and compares its to 1; if it doesn’t match, it returns 0 (false), otherwise it compares the value in the first element of the array against 0xA (line feed) and returns whether they match. Now, .NET 8:\n\nThat’s more interesting. I ran this code on Windows, where is . The JIT has constant folded the entire operation, seeing that the length is not 1, such that the whole operation boils down to just returning false.\n\nOr consider dotnet/runtime#78783 and dotnet/runtime#80661 which teach the JIT how to actually peer into the contents of an “RVA static.” These are “Relative Virtual Address” static fields, which is a fancy way of saying they live in the assembly’s data section. The C# compiler has optimizations that put constant data into such fields; for example, when you write:\n\nthe C# compiler will actually emil IL like this:\n\nWith these PRs, when indexing into such RVA statics, the JIT is now able to actually read the data at the relevant location, constant folding the operation to the value at that location. So, take the following benchmark:\n\nThe method is implemented via a lookup into such an RVA static, using the passed in as an index into it. If the index ends up being a , now on .NET 8 the whole operation can be constant folded away. .NET 7:\n\nYou get the idea. Of course, a developer hopefully wouldn’t explicitly write , but such code can result none-the-less, especially via inlining.\n\nThere are a multitude of these kinds of improvements in .NET 8. dotnet/runtime#77102 made it so that a value type’s primitive fields can be constant folded as if they were themselves fields, and dotnet/runtime#80431 extended that to strings. dotnet/runtime#85804 taught the JIT how to handle (which is used in methods like ), while dotnet/runtime#87101 taught it to handle (such that if the JIT knows the exact type of an instance , it can replace the invocation with the known answer). However, one of my favorite examples, purely because of just how magical it seems, comes from a series of PRs, including dotnet/runtime#80622, dotnet/runtime#78961, dotnet/runtime#80888, and dotnet/runtime#81005. Together, they enable this:\n\nThe JIT was able to successfully inline and constant fold the entire operation down to a single constant. That in that instruction is the value for the field that backs . Sure enough, if you run:\n\nEarlier we saw an example of the codegen when loading a constant string. As a reminder, this code:\n\nresults in this assembly on .NET 7:\n\nThere are two instructions here. The first is loading the location where the address to the string object is stored, and the second is reading the address stored at that location (this requires two s because on x64 there’s no addressing mode that supports moving the value stored at an absolute address larger than 32-bits). Even though we’re dealing with a string literal here, such that the data for the string is constant, that constant data still ends up being copied into a heap-allocated object. That object is interned, such that there’s only one of them in the process, but it’s still a heap object, and that means it’s still subject to being moved around by the GC. That means the JIT can’t just bake in the address of the object, since the address can change, hence why it needs to read the address each time, in order to know where it currently is. Or, does it?\n\nWhat if we could ensure that the object for this literal is created some place where it would never move, for example on the Pinned Object Heap (POH)? Then the JIT could avoid the indirection and instead just hardcode the address of the , knowing that it would never move. Of course, the POH guarantees objects on it will never move, but it doesn’t guarantee addresses to them will always be valid; after all, it doesn’t root the objects, so objects on the POH are still collectible by the GC, and if they were collected, their addresses would be pointing at garbage or other data that ended up reusing the space.\n\nTo address that, .NET 8 introduces a new mechanism used by the JIT for these kinds of situations: the Non-GC Heap (an evolution of the older “Frozen Segments” concept used by Native AOT). The JIT can ensure relevant objects are allocated on the Non-GC Heap, which is, as the name suggests, not managed by the GC and is intended to store objects where the JIT can prove the object has no references the GC needs to be aware of and will be rooted for the lifetime of the process, which in turn implies it can’t be part of an unloadable context.\n\nThe JIT can then avoid indirections in code generated to access that object, instead just hardcoding the object’s address. That’s exactly what it does now for string literals, as of dotnet/runtime#49576. Now in .NET 8, that same method above results in this assembly:\n\ndotnet/runtime#75573 makes a similar play, but with the objects produced by (subject to various constraints, like the not coming from an unloadable assembly, in which case permanently rooting the object would prevent unloading). Again, we can see this with a simple benchmark:\n\nwhere we get the following difference between .NET 7 and .NET 8:\n\nThe same capability can be extended to other kinds of objects, as it is in dotnet/runtime#85559 (which is based on work from dotnet/runtime#76112), making cheaper by allocating the empty arrays on the Non-GC Heap.\n\nAnd as of dotnet/runtime#77737, it also applies to the heap object associated with value type fields, at least those that don’t contain any GC references. Wait, heap object for value type fields? Surely, Stephen, you got that wrong, value types aren’t allocated on the heap when stored in fields. Well, actually they are when they’re stored in fields; the runtime creates a heap-allocated box associated with that field to store the value (but the same box is reused for all writes to that field). And that means for a benchmark like this:\n\nwe see the following assembly code for reading that on .NET 7:\n\nThat code is loading the address of the field, reading from it the address of the box object, and then reading from that box object the value that’s stored inside of it. But, now on .NET 8 we get the assembly you’ve now come to expect:\n\nThe box gets allocated on the Non-GC heap, which means the JIT can bake in the address of the object, and we get to save a .\n\nBeyond fewer indirections to access these Non-GC Heap objects, there are other benefits. For example, a “generational GC” like the one used in .NET divides the heap into multiple “generations,” where generation 0 (“gen0”) is for recently created objects and generation 2 (“gen2”) is for objects that have been around for a while. When the GC performs a collection, it needs to determine which objects are still alive (still referenced) and which ones can be collected, and to do that it has to trace through all references to find out what objects are still reachable. However, the generational model is beneficial because it can enable the GC to scour through much less of the heap than it might otherwise need to. If it can tell, for example, that there aren’t any references from gen2 back to gen0, then when doing a gen0 collection, it can avoid enumerating gen2 objects entirely. But to be able to know about such references, the GC needs to know any time a reference is written to a shared location. We can see that in this benchmark:\n\nwhere the code generated for that method on both .NET 7 and .NET 8 is:\n\nThat is a JIT helper function that contains what’s known as a “GC write barrier,” a little piece of code that runs to let the GC track that a reference is being written that it might need to know about, e.g. because the object being assigned might be gen0 and the destination might be gen2. We see the same thing on .NET 7 for a tweak to the benchmark like this:\n\nNow we’re storing a string literal into the destination, and on .NET 7 we see assembly similarly calling :\n\nBut, now on .NET 8 we see this:\n\nNo write barrier. That’s thanks to dotnet/runtime#76135, which recognizes that these Non-GC Heap objects don’t need to be tracked, since they’ll never be collected anyway. There are multiple other PRs that improve how constant folding works with these Non-GC Heap objects, too, like dotnet/runtime#85127, dotnet/runtime#85888, and dotnet/runtime#86318.\n\nThe JIT frequently needs to generate code that zeroes out memory. Unless you’ve used , for example, any stack space allocated with needs to be zeroed, and it’s the JIT’s responsibility to generate the code that does so. Consider this benchmark:\n\nHere’s what the .NET 7 assembly looks like for both and :\n\nWe can see in the middle there that the JIT has written a zeroing loop, zeroing 16 bytes at a time by pushing two 8-byte s onto the stack on each iteration:\n\nNow in .NET 8 with dotnet/runtime#83255, the JIT unrolls and vectorizes that zeroing, and after a certain threshold (which as of dotnet/runtime#83274 has also been updated and made consistent with what other native compilers do), it switches over to using an optimized routine rather than emitting a large amount of code to achieve the same thing. Here’s what we now get on .NET 8 for (on my machine… I call that out because the limits are based on what instruction sets are available):\n\nNotice there’s no zeroing loop, and instead we see a bunch of 256-bit move instructions to copy the zeroed out register to the next portion of the stack. And then for we see:\n\nAgain, no zeroing loop, and instead we see , relying on the optimized underlying to efficiently handle the zeroing. The effects of this are visible in throughput numbers as well:\n\ndotnet/runtime#83488 improved this further by using a standard trick frequently employed when vectorizing algorithms. Let’s say you want to zero out 120 bytes and you have at your disposal an instruction for zeroing out 32 bytes at a time. We can issue three such instructions to zero out 96 bytes, but we’re then left with 24 bytes that still need to be zeroed. What do we do? We can’t write another 32 bytes from where we left off, as we might then be overwriting 8 bytes we shouldn’t be touching. We could use scalar zeroing and issue three instructions each for 8 bytes, but could we do it in just a single instruction? Yes! Since the writes are idempotent, we can just zero out the last 32 bytes of the 120 bytes, even though that means we’ll be re-zeroing 8 bytes we already zeroed. You can see this same approach utilized in many of the vectorized operations throughout the core libraries, and as of this PR, the JIT employs it when zeroing as well.\n\ndotnet/runtime#85389 takes this further and uses AVX512 to improve bulk operations like this zeroing. So, running the same benchmark on my Dev Box with AVX512, I see this assembly generated for :\n\nNote that now, rather than eight instructions with , we see four instructions with , as each move instruction is able to zero out twice as much, with each instruction handling 64 bytes at a time.\n\nValue types (structs) have been used increasingly as part of high-performance code. Yet while they have obvious advantages (they don’t require heap allocation and thus reduce pressure on the GC), they also have disadvantages (more data being copied around) and have historically not been as optimized as someone relying on them heavily for performance might like. It’s been a key focus area of improvement for the JIT in the last several releases of .NET, and that continues into .NET 8.\n\nOne specific area of improvement here is around “promotion.” In this context, promotion is the idea of splitting a struct apart into its constituent fields, effectively treating each field as its own local. This can lead to a number of valuable optimizations, including being able to enregister portions of a struct. As of .NET 7, the JIT does support struct promotion, but with limitations, including only supporting structs with at most four fields and not supporting nested structs (other than for primitive types).\n\nA lot of work in .NET 8 went into removing those restrictions. dotnet/runtime#83388 improves upon the existing promotion support with an additional optimization pass the JIT refers to as “physical promotion;” it does away with both of those cited limitations, however as of this PR the feature was still disabled by default. Other PRs like dotnet/runtime#85105 and dotnet/runtime#86043 improved it further, and dotnet/runtime#88090 enabled the optimizations by default. The net result is visible in a benchmark like the following:\n\nHere we have a struct modeling some data that might be extracted from a file on Linux. The benchmark makes a local copy of the struct and returns a sum of the user and kernel times. In .NET 7, the assembly looks like this:\n\nThe two really interesting instructions here are these:\n\nThe struct is 80 bytes in size, and this pair of instructions is repeatedly ( ) copying 8-bytes ( ) 10 times ( that’s been populated with 0xA) from the source location in (which was initialized with , aka the location of the field) to the destination location in (a stack location at ). In other words, this is making a full copy of the whole struct, even though we only need two fields from it. Now in .NET 8, we get this:\n\nAhhh, so much nicer. Now it’s avoided the whole copy, and is simply moving the relevant values into registers and adding them together.\n\nhas a struct that’s returned from , such that when you the list directly (rather than as an ), the C# compiler binds to this struct enumerator via the enumerator pattern. This example runs afoul of the previous limitations in two ways. That has a field for the current , so if is a non-primitive value type, it violates the “no nested structs” limitation. And that has four fields, so if that has multiple fields, it pushes it beyond the four-field limit. Now in .NET 8, the JIT is able to see through the struct to its fields, and optimize the enumeration of the list to a much more efficient result.\n\nNote the significant improvement in both throughput and code size from .NET 7 to .NET 8 even without PGO. However, the gap here between .NET 8 without PGO and with PGO is also interesting, albeit for other reasons. We see an almost halving of execution time with PGO applied, but only four bytes of difference in assembly code size. Those four bytes stem from a single instruction that PGO was able to help remove, which we can see easily by pasting the two snippets into a diffing tool: ~12us down to ~6us is a lot for a difference of a single … why such an outsized impact? This ends up being a really good example of what I mentioned at the beginning of this article: beware microbenchmarks, as they can differ from machine to machine. Or in this case, in particular from processor to processor. The machine on which I’m writing this and on which I’ve run the majority of the benchmarks in this post is a several year old desktop with an Intel Coffee Lake processor. When I run the same benchmark on my Dev Box, which has an Intel Xeon Platinum 8370C, I see this:\n\nSame code size, still a large improvement due to physical promotion, but now only a small ~15% rather than ~2x improvement from PGO. As it turns out, Coffee Lake is one of the processors affected by the Jump Conditional Code (JCC) Erratum issued in 2019 (“erratum” here is a fancy way of saying “bug”, or alternatively, “documentation about a bug”). The problem involved jump instructions on a 32-byte boundary, and the hardware caching information about those instructions. The issue was then subsequently fixed via a microcode update that disabled the relevant caching, but that then created a possible performance issue, as whether a jump is on a 32-byte boundary impacts whether it’s cached and therefore the resulting performance gains that cache was introduced to provide. If I set the environment variable to (to get the JIT to output the disassembly directly, rather than relying on BenchmarkDotNet to fish it out), and set the environment variable to (to get the JIT to include alignment boundary information in that output), I see this:\n\nSure enough, we see that this jump instruction is falling on a 32-byte boundary. When PGO kicks in and removes the earlier , that changes the alignment such that the jump is no longer on a 32-byte boundary:\n\nThis is all to say, again, there are many things that can impact microbenchmarks, and it’s valuable to understand the source of a difference rather than just taking it at face value.\n\nOk, where were we? Oh yeah, structs. Another improvement related to structs comes in dotnet/runtime#79346, which adds an additional “liveness” optimization pass earlier than the others it already has (liveness is just an indication of whether a variable might still be needed because its value might be used again in the future). This then allows the JIT to remove some struct copies it wasn’t previously able to, in particular in situations where the last time the struct is used is in passing it to another method. However, this additional liveness pass has other benefits as well, in particular with relation to “forward substitution.” Forward substitution is an optimization that can be thought of as the opposite of “common subexpression elimination” (CSE). With CSE, the compiler replaces an expression with something containing the result already computed for that expression, so for example if you had:\n\na compiler might use CSE to rewrite that as:\n\nForward substitution could be used to undo that, distributing the expression feeding into back to where is used, such that we end up back with:\n\nWhy would a compiler want to do that? It can make certain subsequent optimizations easier for it to see. For example, consider this benchmark:\n\nOn .NET 7, that results in this assembly:\n\nThe generated code here is performing each multiplication individually. But when we view:\n\nand knowing that the initial result stored into is temporary (thank you, liveness), forward substitution can turn that into:\n\nat which point constant folding can kick in. Now on .NET 8 we get:\n\nAnother change related to liveness is dotnet/runtime#77990 from @SingleAccretion. This adds another pass over one of the JIT’s internal representations, eliminating writes it finds to be useless.\n\nVarious improvements have gone into improving the performance of casting in .NET 8.\n\ndotnet/runtime#75816 improved the performance of using when is sealed. There’s a helper the JIT uses to determine whether an object is of a specified array type, but when the is sealed, the JIT can instead emit it without the helper, generating code as if it were written like . This is another example where dynamic PGO has a measurable impact, so the benchmark highlights the improvements with and without it.\n\nMoving on, consider this benchmark:\n\nhere is just reading and returning the 0th element from the array. here is returning a to the 0th element from the array. Here’s the assembly we get in .NET 7:\n\nIn , we’re immediately using the array element, so the C# compiler can emit a IL instruction, but in , the reference to the array element is being returned, so the C# compiler emits a (load element address) instruction. In the general case, requires a type check, because of covariance; you could have a , in which case if you handed out a pointing into that array and someone wrote a via that , type safety would be violated (since you’d be storing an into a even though and aren’t related). As such, the .NET 7 assembly for this code includes a call to , which is the helper function the JIT uses to perform that type check. But the array element type here is , which is sealed, which means we can’t get into that problematic situation: there’s no type you can store into a variable other than . Thus, this helper call is superfluous, and with dotnet/runtime#85256, the JIT can now avoid using it. On .NET 8, then, we get this for :\n\nAnd then dotnet/runtime#86728 reduces the costs associated with a generic cast. Previously the JIT would always use a method to perform the cast, but with this change, it inlines a fast success path.\n\nA “peephole optimization” is one in which a small sequence of instructions is replaced by a different sequence that is expected to perform better. This could include getting rid of instructions deemed unnecessary or replacing two instructions with one instruction that can accomplish the same task. Every release of .NET features a multitude of new peephole optimizations, often inspired by real-world examples where some overhead could be trimmed by slightly increasing code quality, and .NET 8 is no exception. Here are just some of these optimizations in .NET 8:\n• dotnet/runtime#73120 from @dubiousconst282 and dotnet/runtime#74806 from @En3Tho improved the handling of the common bit-test patterns like .\n• dotnet/runtime#77874 gets rid of some unnecessary casts in a method like .\n• dotnet/runtime#76981 improves the performance of multiplying by a number that’s one away from a power of two, by replacing an instruction with a three-instruction / / sequence, and dotnet/runtime#77137 improves other multiplications by a constant via replacing a / sequence with a single .\n• dotnet/runtime#78786 from @pedrobsaila fuses together separate conditions like into the equivalent of .\n• dotnet/runtime#79630 avoids an unnecessary in a method like .\n• dotnet/runtime#77540 from @AndyJGraham, dotnet/runtime#84399, and dotnet/runtime#85032 optimize pairs of load and store instructions and replace them with a single or instruction on Arm.\n• dotnet/runtime#84350 similarly optimizes pairs of instructions to be instructions.\n• dotnet/runtime#83458 from @SwapnilGaikwad optimizes some redundant memory loads on Arm by replacing some instructions with instructions.\n• dotnet/runtime#83176 optimizes an expression from emitting a / sequence on Arm to instead emitting an instruction.\n• dotnet/runtime#82924 removes a redundant overflow check on Arm for some division operations.\n• dotnet/runtime#84605 combines an / sequence on Arm into a single .\n• dotnet/runtime#84667 combines and sequences into use of on Arm.\n\n(I’ve touched here on some of the improvements specific to Arm. For a more in-depth look, see Arm64 Performance Improvements in .NET 8).\n\nNative AOT shipped in .NET 7. It enables .NET programs to be compiled at build time into a self-contained executable or library composed entirely of native code: no JIT is required at execution time to compile anything, and in fact there’s no JIT included with the compiled program. The result is an application that can have a very small on-disk footprint, a small memory footprint, and very fast startup time. In .NET 7, the primary supported workloads were console applications. Now in .NET 8, a lot of work has gone into making ASP.NET applications shine when compiled with Native AOT, as well as driving down overall costs, regardless of app model.\n\nA significant focus in .NET 8 was on reducing the size of built applications, and the net effect of this is quite easy to see. Let’s start by creating a new Native AOT console app:\n\nThat creates a new directory and adds to it a new “Hello, world” app that targets .NET 7. Edit the generated nativeaotexample.csproj in two ways:\n• Change the to instead be , so that we can easily build for either .NET 7 or .NET 8.\n• Add to the , so that when we , it uses Native AOT.\n\nNow, publish the app for .NET 7. I’m currently targeting Linux for x64, so I’m using , but you can follow along on Windows with a Windows identifier, like :\n\nThat should successfully build the app, producing a standalone executable, and we can / the output directory to see the produced binary size (here I’ve used ):\n\nSo, on .NET 7 on Linux, this “Hello, world” application, including all necessary library support, the GC, everything, is ~13Mb. Now, we can do the same for .NET 8:\n\nand again see the generated output size:\n\nNow on .NET 8, that ~13MB has dropped to ~1.5M! We can get it smaller, too, using various supported configuration flags. First, we can set a size vs speed option introduced in dotnet/runtime#85133, adding to the .csproj. Then if I don’t need globalization-specific code and data and am ok utilizing an invariant mode, I can add . Maybe I don’t care about having good stack traces if an exception occurs? dotnet/runtime#88235 added the option. Add all of those and republish:\n\nA good chunk of those improvements came from a relentless effort that involved hacking away at the size, 10Kb here, 20Kb there. Some examples that drove down these sizes:\n• There are a variety of data structures the Native AOT compiler needs to create that then need to be used by the runtime when the app executes. dotnet/runtime#77884 added support for these data structures, including ones containing pointers, to be stored into the application and then rehydrated at execution time. Even before being extended in a variety of ways by subsequent PRs, this shaved hundreds of kilobytes off the app size, on both Windows and Linux (but more so on Linux).\n• Every type with a static field containing references has a data structure associated with it containing a few pointers. dotnet/runtime#78794 made those pointers relative, saving ~0.5% of the HelloWorld app size (at least on Linux, a bit less on Windows). dotnet/runtime#78801 did the same for another set of pointers, saving another ~1%.\n• dotnet/runtime#79594 removed some over-aggressive tracking of types and methods that needed data stored about them for reflection. This saved another ~32Kb on HelloWorld.\n• In some cases, generic type dictionaries were being created even if they were never used and thus empty. dotnet/runtime#82591 got rid of these, saving another ~1.5% on a simple ASP.NET minimal APIs app. dotnet/runtime#83367 saved another ~20Kb by ridding itself of other empty type dictionaries.\n• Members declared on a generic type have their code copied and specialized for each value type that’s substituted for the generic type parameter. However, if with some tweaks those members can be made non-generic and moved out of the type, such as into a non-generic base type, that duplication can be avoided. dotnet/runtime#82923 did so for array enumerators, moving down the and non-generic interface implementations.\n• has an implementation of an empty array enumerator that can be used when enumerating a that’s empty, and that singleton may be used in non-array enumerables, e.g. enumerating an empty could produce that array enumerator singleton. That enumerator, however, has a reference to a , and in the Native AOT world, using the enumerator then means code needs to be produced for the various members of . If, however, the enumerator in question is for a that’s unlikely to be used elsewhere (e.g. ), dotnet/runtime#82899 supplies a specialized enumerator singleton that doesn’t reference , avoiding forcing that code to be created and kept (for example, code for a ‘s ).\n• No one ever calls the / methods on the structs produced by the C# compiler for async methods; they’re a hidden implementation detail, but even so, such virtual methods are in general kept rooted in a Native AOT app (and whereas CoreCLR can use reflection to provide the implementation of these methods for value types, Native AOT needs customized code emitted for each). dotnet/runtime#83369 special-cased these to avoid them being kept, shaving another ~1% off a minimal APIs app.\n• dotnet/runtime#83937 reduced the size of static constructor contexts, data structures used to pass information about a type’s static between portions of the system.\n• dotnet/runtime#84463 made a few tweaks that ended up avoiding creating s for / and that reduced reliance on some array methods, shaving another ~3% off HelloWorld.\n• dotnet/runtime#84156 manually split a method into two portions such that some lesser-used code isn’t always brought in when using the more commonly-used code; this saved another several hundred kilobytes.\n• dotnet/runtime#84224 improved handling of the common pattern that’s often used to do generic specialization (e.g. such as in code like ), doing it in a way that makes it easier to get rid of side effects from branches that are trimmed away.\n• The GC includes a vectorized sort implementation called . When building with a configuration optimized for size, dotnet/runtime#85036 enabled removing that throughput optimization, saving several hundred kilobytes.\n• is a very handy type, but it brings a lot of code with it, as it implements multiple interfaces which then end up rooting functionality on the generic type parameters. dotnet/runtime#87120 removed a use of from , saving ~200Kb.\n• On Linux specifically, a large improvement came from dotnet/runtime#85139. Debug symbols were previously being stored in the published executable; with this change, symbols are stripped from the executable and are instead stored in a separate file built next to it. Someone who wants to revert to keeping the symbols in the executable can add to in their project.\n\nYou get the idea. The improvements go beyond nipping and tucking here and there within the Native AOT compiler, though. Individual libraries also contributed. For example:\n• supports automatic decompression of response streams, for both and , and that in turn means that any use implicitly brings with it most of . However, by default that decompression isn’t enabled, and you need to opt-in to it by explicitly setting the property on the or in use. So, dotnet/runtime#78198 employs a trick where rather than ‘s main code paths relying directly on the internal that does this work, it instead relies on a delegate. The field storing that delegate starts out as null, and then as part of the setter, that field is set to a delegate that will do the decompression work. That means that if the trimmer doesn’t see any code accessing the setter such that the setter can be trimmed away, then all of the and its reliance on and can also be trimmed away. Since it’s a little confusing to read, here’s a representation of it: private DecompressionMethods _automaticDecompression; private Func<Stream, Stream>? _getStream; public DecompressionMethods AutomaticDecompression { get => _automaticDecompression; set { _automaticDecompression = value; _getStream ??= CreateDecompressionStream; } } public Stream GetStreamAsync() { Stream response = ...; return _getStream is not null ? _getStream(response) : response; } private static Stream CreateDecompressionStream(Stream stream) => UseGZip ? new GZipStream(stream, CompressionMode.Decompress) : UseZLib ? new ZLibStream(stream, CompressionMode.Decompress) : UseBrotli ? new BrotliStream(stream, CompressionMode.Decompress) : stream; } The method here is the one that references all of the compression-related code, and the only code path that touches it is in the setter. Therefore, if nothing in the app accesses the setter, the setter can be trimmed, which means the method can also be trimmed, which means if nothing else in the app is using these compression streams, they can also be trimmed.\n• dotnet/runtime#80884 is another example, saving ~90Kb of size when is used by just being a bit more intentional about what types are being used in its implementation (e.g. using a instead of a to store a bitmap).\n• Or particularly interesting, dotnet/runtime#84169, which adds a new feature switch to . Various APIs in use , which can trigger use of , which in turn references the networking stack; an app that’s using XML but not otherwise using networking can end up inadvertently bringing in upwards of 3MB of networking code, just by using an API like . Such an app can use the MSBuild property added in dotnet/sdk#34412 to enable all of those code paths in XML to be trimmed away.\n• in tries to optimize throughput by spending some time upfront to build a factory that’s then very efficient at creating things. Its main strategy for doing so involved using as a simpler API for using reflection emit, building up custom IL for the exact thing being constructed. When you have a JIT, that can work very well. But when dynamic code isn’t supported, can’t use reflection emit and instead falls back to using an interpreter. That makes such an “optimization” in actually a deoptimization, plus it brings with it the size impact of . dotnet/runtime#81262 adds a reflection-based alternative for when , resulting in faster code and allowing the usage to be trimmed away.\n\nOf course, while size was a large focus for .NET 8, there are a multitude of other ways in which performance with Native AOT has improved. For example, dotnet/runtime#79709 and dotnet/runtime#80969 avoid helper calls as part of reading static fields. BenchmarkDotNet works with Native AOT as well, so we can run the following benchmark to compare; instead of using , we just use (BenchmarkDotNet also currently doesn’t support the with Native AOT):\n\ndotnet/runtime#83054 is another good example. It improves upon support in Native AOT by ensuring that the comparer can be stored in a to enable better constant folding in consumers.\n\nAs another example, dotnet/runtime#83911 avoids some overhead related to static class initialization. As we discussed in the JIT section, the JIT is able to rely on tiering to know that a static field accessed by a method must have already been initialized if the method is being promoted from tier 0 to tier 1, but tiering doesn’t exist in the Native AOT world, so this PR adds a fast-path check to help avoid most of the costs.\n\nOther fundamental support has also improved. dotnet/runtime#79519, for example, changes how locks are implemented for Native AOT, employing a hybrid approach that starts with a lightweight spinlock and upgrades to using the type (which is currently internal to Native AOT but likely to ship publicly in .NET 9).\n\nThe VM is, loosely speaking, the part of the runtime that’s not the JIT or the GC. It’s what handles things like assembly and type loading. While there were a multitude of improvements throughout, I’ll call out three notable improvements.\n\nFirst, dotnet/runtime#79021 optimized the operation of mapping an instruction pointer to a (a data structure that represents a method, with various pieces of information about it, like its signature), which happens in particular any time stack walking is performed (e.g. exception handling, , etc.) and as part of some delegate creations. The change not only makes this conversion faster but also mostly lock-free, which means on a benchmark like the following, there’s a significant improvement for sequential use but an even larger one for multi-threaded use:\n\nSecond, dotnet/runtime#83632 improves the performance of the . This allocator is responsible for allocation related to all executable memory in the runtime, e.g. the JIT uses it to get memory into which to write the generated code that will then need to be executed. When memory is mapped, it has permissions associated with it for what can be done with that memory, e.g. can it be read and written, can it be executed, etc. The allocator maintains a cache, and this PR improved the performance of the allocator by reducing the number of cache misses incurred and reducing the cost of those cache misses when they do occur.\n\nThird, dotnet/runtime#85743 makes a variety of changes focused on significantly reducing startup time. This includes reducing the amount of time spent on validation of types in R2R images, making lookups for generic parameters and nested types in R2R images much faster due to dedicated metadata in the R2R image, converting an lookup into an lookup by storing an additional index in a method description, and ensuring that vtable chunks are always shared.\n\nAt the beginning of this post, I suggested that be added to the csproj used for running the benchmarks in this post. That setting configures the GC to run in “server” mode, as opposed to “workstation” mode. The workstation mode was designed for use with client applications and is less resource intensive, preferring to use less memory but at the possible expense of throughput and scalability if the system is placed under heavier load. In contrast, the server mode was designed for larger-scale services. It is much more resource hungry, with a dedicated heap by default per logical core in the machine, and a dedicated thread per heap for servicing that heap, but it is also significantly more scalable. This tradeoff often leads to complication, as while applications might demand the scalability of the server GC, they may also want memory consumption closer to that of workstation, at least at times when demand is lower and the service needn’t have so many heaps.\n\nIn .NET 8, the server GC now has support for a dynamic heap count, thanks to dotnet/runtime#86245, dotnet/runtime#87618, and dotnet/runtime#87619, which add a feature dubbed “Dynamic Adaptation To Application Sizes”, or DATAS. It’s off-by-default in .NET 8 in general (though on-by-default when publishing for Native AOT), but it can be enabled trivially, either by setting the environment variable to , or via the MSBuild property. The employed algorithm is able to increase and decrease the heap count over time, trying to maximize its view of throughput, and maintaining a balance between that and overall memory footprint.\n\nHere’s a simple example. I create a console app with in the .csproj and the following code in Program.cs, which just spawns a bunch of threads that continually allocate, and then repeatedly prints out the working set:\n\nWhen I run that, I consistently see output like:\n\nWhen I then add to the .csproj, the working set drops significantly:\n\nFor a more detailed examination of the feature and plans for it, see Dynamically Adapting To Application Sizes.\n\nThus far I’ve referred to “the runtime”, “the JIT”, “the GC”, and so on. That’s all in the context of the “CoreCLR” runtime, which is the primary runtime used for console applications, ASP.NET applications, services, desktop applications, and the like. For mobile and browser .NET applications, however, the primary runtime used is the “Mono” runtime. And it also has seen some huge improvements in .NET 8, improvements that accrue to scenarios like Blazor WebAssembly apps.\n\nJust as how with CoreCLR there’s both the ability to JIT and AOT, there are multiple ways in which code can be shipped for Mono. Mono includes an AOT compiler; for WASM in particular, the AOT compiler enables all of the IL to be compiled to WASM, which is then shipped down to the browser. As with CoreCLR, however, AOT is opt-in. The default experience for WASM is to use an interpreter: the IL is shipped down to the browser, and the interpreter (which itself is compiled to WASM) then interprets the IL. Of course, interpretation has performance implications, and so .NET 7 augmented the interpreter with a tiering scheme similar in concept to the tiering employed by the CoreCLR JIT. The interpreter has its own representation of the code to be interpreted, and the first few times a method is invoked, it just interprets that byte code with little effort put into optimizing it. Then after enough invocations, the interpreter will take some time to optimize that internal representation so as to speed up subsequent interpretations. Even with that, however, it’s still interpreting: it’s still an interpreter implemented in WASM reading instructions for what to do and doing them. One of the most notable improvements to Mono in .NET 8 expands on this tiering by introducing a partial JIT into the interpreter. dotnet/runtime#76477 provided the initial code for this “jiterpreter,” as some folks refer to it. As part of the interpreter, this JIT is able to participate in the same data structures used by the interpreter and process the same byte code, and works by replacing sequences of that byte code with on-the-fly generated WASM. That could be a whole method, it could just be a hot loop within a method, or it could be just a few instructions. This provides significant flexibility, including a very progressive on-ramp where optimizations can be added incrementally, shifting more and more logic from interpretation to jitted WASM. Dozens of PRs went into making the jiterpreter a reality for .NET 8, such as dotnet/runtime#82773 that added basic SIMD support, dotnet/runtime#82756 that added basic loop support, and dotnet/runtime#83247 that added a control-flow optimization pass.\n\nLet’s see this in action. I created a new .NET 7 Blazor WebAssembly project, added a NuGet reference to the project, and replaced the contents of with the following:\n\nThen I did the exact same thing, but for .NET 8, built both in Release, and ran them both. When the resulting page opened for each, I clicked the “Click me” button (a few times, but it didn’t change the results).\n\nThe timing measurements for how long the operation took in .NET 7 compared to .NET 8 speak for themselves.\n\nBeyond the jiterpreter, the interpreter itself saw a multitude of improvements, for example:\n• dotnet/runtime#79165 added special handling of the IL instruction for when the value type doesn’t contain any references, and thus doesn’t need to interact with the GC.\n• dotnet/runtime#80046 special-cased a compare followed by / , creating a single interpreter opcode for the very common pattern.\n• dotnet/runtime#79392 added an intrinsic to the interpreter for string creation.\n• dotnet/runtime#78840 added a cache to the Mono runtime (including for but not limited to the interpreter) for various pieces of information about types, like , , and .\n• dotnet/runtime#81782 added intrinsics for some of the most common operations on , and dotnet/runtime#86859 augmented this to use those same opcodes for .\n• dotnet/runtime#83498 special-cased division by powers of 2 to instead employ shifts.\n• dotnet/runtime#83490 tweaked the inlining size limit to ensure that key methods could be inlined, like ‘s indexer.\n• dotnet/runtime#85528 added devirtualization support in situations where enough type information is available to enable doing so.\n\nI’ve already alluded several times to vectorization in Mono, but in its own right this has been a big area of focus for Mono in .NET 8, across all backends. As of dotnet/runtime#86546, which completed adding support for Mono’s AMD64 JIT backend, is now supported across all Mono backends. Mono’s WASM backends not only support , .NET 8 includes the new type, which is specific to WASM and exposes hundreds of overloads that map down to WASM SIMD operations. The basis for this type was introduced in dotnet/runtime#73289, where the initial SIMD support was added as internal. dotnet/runtime#76539 continued the effort by adding more functionality and also making the type public, as it now is in .NET 8. Over a dozen PRs continued to build it out, such as dotnet/runtime#80145 that added intrinsics, dotnet/runtime#87052 and dotnet/runtime#87828 that added load and store intrinsics, dotnet/runtime#85705 that added floating-point support, and dotnet/runtime#88595, which overhauled the surface area based on learnings since its initial design.\n\nAnother effort in .NET 8, related to app size, has been around reducing reliance on ICU’s data files (ICU is the globalization library employed by .NET and many other systems). Instead, the goal is to rely on the target platform’s native APIs wherever possible (for WASM, APIs provided by the browser). This effort is referred to as “hybrid globalization,” because the dependence on ICU’s data files still remains, it’s just lessened, and it comes with behavioral changes, so it’s opt-in for situations where someone really wants the smaller size and is willing to deal with the behavioral accommodations. A multitude of PRs have also gone into making this a reality for .NET 8, such as dotnet/runtime#81470, dotnet/runtime#84019, and dotnet/runtime#84249. To enable the feature, you can add to your .csproj, and for more information, there’s a good design document that goes into much more depth.\n\nRecent releases of .NET saw huge improvements to the area of threading, parallelism, concurrency, and asynchrony, such as a complete rewrite of the (in .NET 6 and .NET 7), a complete rewrite of the async method infrastructure (in .NET Core 2.1), a complete rewrite of (in .NET Core 2.0), and so on. This release doesn’t include such massive overhauls, but it does include some thoughtful and impactful improvements.\n\nThe .NET runtime makes it easy to associate data with a thread, often referred to as thread-local storage (TLS). The most common way to achieve this is by annotating a static field with the attribute (another for more advanced uses is via the type), which causes the runtime to replicate the storage for that field to be per thread rather than global for the process.\n\nHistorically, accessing such a field has required a non-inlined JIT helper call (e.g. ), but now with dotnet/runtime#82973 and dotnet/runtime#85619, the common and fast path from that helper can be inlined into the caller. We can see this with a simple benchmark that just increments an stored in a .\n\nwas similarly optimized for Native AOT, via both dotnet/runtime#84566 and dotnet/runtime#87148:\n\nLet’s try an experiment. Create a new console app, and add to the .csproj. Then make the entirety of the program this:\n\nThe idea is to see the stack trace of a work item running on a thread. Now run it, and you should see something like this:\n\nThe important piece here is the bottom line: we see we’re being called from the , which is the managed thread pool implementation that’s been used across operating systems since .NET 6. Now, instead of running directly, let’s publish for Native AOT and run the resulting app (for the specific thing we’re looking for, this part should be done on Windows).\n\nNow, we see this:\n\nAgain, note the last line: “WindowsThreadPool.” Applications published with Native AOT on Windows have historically used a implementation that wraps the Windows thread pool. The work item queues and dispatching code is all the same as with the portable pool, but the thread management itself is delegated to the Windows pool. Now in .NET 8 with dotnet/runtime#85373, projects on Windows have the option of using either pool; Native AOT apps can opt to instead use the portable pool, and other apps can opt to instead use the Windows pool. Opting in or out is easy: in a in the .csproj, add to opt-out in a Native AOT app, and conversely use in other apps to opt-in. When using this MSBuild switch, in a Native AOT app, whichever pool isn’t being used can automatically be trimmed away. For experimentation, the environment variable can also be set to or to explicitly opt out or in, respectively.\n\nThere’s currently no hard-and-fast rule about why one pool might be better; the option has been added to allow developers to experiment. We’ve seen with the Windows pool that I/O doesn’t scale as well on larger machines as it does with the portable pool. However, if the Windows thread pool is already being used heavily elsewhere in the application, consolidating into the same pool can reduce oversubscription. Further, if thread pool threads get blocked very frequently, the Windows thread pool has more information about that blocking and can potentially handle those scenarios more efficiently. We can see this with a simple example. Compile this code:\n\nThis is a dastardly repro that creates a bunch of work items, all of which block until all of the work items have been processed: basically it takes every thread the thread pool gives it and never gives it back (until the program exits). When I run this on my machine where is 12, I get output like this:\n\nThe portable pool quickly injects threads, but after that it proceeds to only inject an additional thread once or twice a second. Now, set to and try again:\n\nZoom. The Windows pool is much more aggressive about injecting threads here. Whether that’s good or bad can depend on your scenario. If you’ve found yourself setting a really high minimum thread pool thread count for your application, you might want to give this option a go.\n\nEven with all the improvements to async/await in previous releases, this release sees async methods get cheaper still, both when they complete synchronously and when they complete asynchronously.\n\nWhen an async / -returning method completes synchronously, it tries to give back a cached task object rather than creating one a new and incurring the allocation. In the case of , that’s easy, it can simply use . In the case of , it uses a cache that stores cached tasks for some values. When is , for example, it can successfully cache a for both and , such that it’ll always successfully avoid the allocation. For , it caches a few tasks for common values (e.g. through ). For reference types, it caches a task for . And for the primitive integer types ( , , , , , , , , , , and ), it caches a task for 0. It used to be that all of this logic was dedicated to async methods, but in .NET 6 that logic moved into , such that all use of now benefits from this caching. In .NET 8, thanks to dotnet/runtime#76349 and dotnet/runtime#87541, the caching is improved further. In particular, the optimization of caching a task for for the primitive types is extended to be the caching of a task for for any value type that is 1, 2, 4, 8, or 16 bytes. In such cases, we can do an unsafe cast to one of these primitives, and then use that primitive’s equality to compare against . If that comparison is true, it means the value is entirely zeroed, which means we can use a cached task for created from , as that is also entirely zeroed. What if that type has a custom equality comparer? That actually doesn’t matter, since the original value and the one stored in the cached task have identical bit patterns, which means they’re indistinguishable. The net effect of this is we can cache tasks for other commonly used types.\n\nThose changes helped some async methods to become leaner when they complete synchronously. Other changes have helped practically all async methods to become leaner when they complete asynchronously. When an async method suspends for the first time, assuming it’s returning / / / and the default async method builders are in use (i.e. they haven’t been overridden using on the method in question), a single allocation occurs: the task object to be returned. That task object is actually a type derived from (in the implementation today the internal type is called ) and that has on it a strongly-typed field for the state machine struct generated by the C# compiler. In fact, as of .NET 7, it has three additional fields beyond what’s on the base :\n• One to hold the state machine struct generated by the C# compiler.\n• One to cache an delegate that points to .\n• One to store an to flow to the next invocation.\n\nIf we can trim down the fields required, we can make every async method less expensive by allocating smaller instead of larger objects. That’s exactly what dotnet/runtime#83696 and dotnet/runtime#83737 accomplish, together shaving 16 bytes (in a 64-bit process) off the size of every such async method task. How?\n\nThe C# language allows anything to be awaitable as long as it follows the right pattern, exposing a method that returns a type with the right shape. That pattern includes a set of “OnCompleted” methods that take an delegate, enabling the async method builder to provide a continuation to the awaiter, such that when the awaited operation completes, it can invoke the to resume the method’s processing. As such, the type has on it a field used to cache an delegate that’s lazily created to point to its method; that is created during the first suspending await where it’s needed and can then be used for all subsequent awaits, such that the is allocated at most once for the lifetime of an async method, regardless of how many times the invocation suspends. (The delegate is only needed, however, if the state machine awaits something that’s not a known awaiter; the runtime has fast paths that avoid requiring that when awaiting all of the built-in awaiters). Interestingly, though, itself has a field for storing a delegate, and that field is only used when the is created to invoke a delegate (e.g. , , etc.). Since most tasks allocated today come from async methods, that means that the majority of tasks have all had a wasted field. It turns out we can just use that base field on the for this cached as well, making the field relevant to almost all tasks, and allowing us to remove the extra field on the state machine box.\n\nThere’s another existing field on the base that also goes unused in async methods: the state object field. When you use a method like or to create a , you can provide an that’s then passed to the ‘s delegate. In an async method, though, the field just sits there, unused, lonely, forgotten, forelorn. Instead of having a separate field for the , then, we can just store the in this existing state field (being careful not to allow it to be exposed via the ‘s property that normally exposes the object state).\n\nWe can see the effect of getting rid of those two fields with a simple benchmark like this:\n\nNote the 16-byte decrease just as we predicted.\n\nAsync method overheads are reduced in other ways, too. dotnet/runtime#82181, for example, shrinks the size of the type that’s used as the workhorse for custom / implementations; it takes advantage of the 99.9% case to use a single field for something that previously required two fields. But my favorite addition in this regard is dotnet/runtime#22144, which adds new overloads. Yes, I know is a sore subject with some, but these new overloads a) address a really useful scenario that many folks end up writing their own custom awaiters for, b) do it in a way that’s cheaper than custom solutions can provide, and c) actually help with the naming, as it fulfills the original purpose of that led us to name it that in the first place. When was originally devised, we debated many names, and we settled on “ConfigureAwait” because that’s what it was doing: it was allowing you to provide arguments that configured how the await behaved. Of course, for the last decade, the only configuration you’ve been able to do is pass a single to indicate whether to capture the current context / scheduler or not, and that in part has led folks to bemoan the naming as overly verbose for something that’s a single . Now in .NET 8, there are new overloads of that take a enum:\n\nyou know; that’s the same as today. is something that comes up now and again in various capacities, but essentially you’re awaiting something and rather than continuing synchronously if the thing you’re awaiting has already completed by the time you await it, you effectively want the system to pretend it’s not completed even if it is. Then rather than continuing synchronously, the continuation will always end up running asynchronously from the caller. This can be helpful as an optimization in a variety of ways. Consider this code that was in ‘s HTTP/2 implementation in .NET 7:\n\nWith in .NET 8, the code is now:\n\nRather than have a separate , we’ve just piggy-backed on the for the task returned from (which we know will quickly return the task to us), ensuring that the work that comes after it doesn’t run synchronously as part of the call to . Or imagine you had code that was doing:\n\nThis is using to queue an async method’s invocation. That async method results in a Task being allocated, plus the results in a being allocated, plus a work item needs to be queued to the , so at least three allocations. Now, this same functionality can be written as:\n\nand rather than three allocations, we end up with just one: for the async . That’s because with all the optimizations introduced in previous releases, the state machine box object is also what will be queued to the thread pool.\n\nArguably the most valuable addition to this support, though, is . It does what it sounds like: when you a task that completes in failure or cancellation, such that normally the would propagate the exception, it won’t. So, for example, in where we previously had this code:\n\nnow we have this code:\n\nor in where we had this code:\n\nnow we just have this:\n\nIt is useful to note the cast that’s in there. returns a , but that is being cast to the base because is incompatible with . That’s because, without an exception propagating, the await will complete successfully and return a , which may be invalid if the task actually faulted. So if you have a that you want to await with , cast to the base and await it, and then you can inspect the immediately after the await completes. (If you do end up using with a , the analyzer introduced in dotnet/roslyn-analyzers#6669 will alert you to it.)\n\nThe above example with is using the new to replace a previous optimization added in .NET 8, as well. dotnet/runtime#83294 added to that an implementation of the internal interface, which is the special sauce that enables the async method builders to backchannel with a known awaiter to avoid the delegate allocation. Now that the behaviors this was providing are built-in, it’s no longer needed, and the built-in implementation enjoys the same privileges via . The net result of these changes for is that it now not only has simpler code, but faster code, too. Here’s a benchmark showing the decrease in execution time and allocation associated with calls that need to wait with a and/or timeout:\n\nThere have been other improvements on other operations on as well. dotnet/runtime#81065 removes a defensive allocation from . It was previously doing a defensive copy such that it could then validate on the copy whether any of the elements were (a copy because another thread could erroneously and concurrently null out elements); that’s a large cost to pay for argument validation in the face of multi-threaded misuse. Instead, the method will still validate whether is in the input, and if a slips through because the input collection was erroneously mutated concurrently with the synchronous call to , it’ll just ignore the at that point. In making these changes, the PR also special-cased a input to avoid making a copy, as is also one of the main types we see fed into (e.g. someone builds up a list of tasks and then waits for all of them).\n\nThe generic was also improved as part of dotnet/runtime#88154, which removes a allocation from an extra continuation that was an implementation detail. This is one of my favorite kinds of PRs: it not only improved performance, it also resulted in cleaner code, and less code.\n\nOne last example related to tasks, though this one is a bit different, as it’s specifically about improving test performance (and test reliability). Imagine you have a method like this:\n\nThe purpose of this method is to wait for 30 seconds and then log a completion message as well as how much time the method observed to pass. This is obviously a simplification of the kind of functionality you’d find in real applications, but you can extrapolate from it to code you’ve likely written. How do you test this? Maybe you’ve written a test like this:\n\nThis is validating both that the method included a value of at least 30 seconds in its log and also that at least 30 seconds passed. What’s the problem? From a performance perspective, the problem is this test had to wait 30 seconds! That’s a ton of overhead for something which would otherwise complete close to instantaneously. Now imagine the delay was longer, like 10 minutes, or that we had a bunch of tests that all needed to do the same thing. It becomes untenable to test well and thoroughly.\n\nTo address these kinds of situations, many developers have introduced their own abstractions for the flow of time. Now in .NET 8, that’s no longer needed. As of dotnet/runtime#83604, the core libraries include . This abstract base class abstracts over the flow of time, with members for getting the current UTC time, getting the current local time, getting the current time zone, getting a high-frequency timestamp, and creating a timer (which in turn returns the new that supports changing the timer’s tick interval). Then core library members like and ‘s constructor have new overloads that accept a , and use it for time-related functionality rather than being hardcoded to , , or . With that, we can rewrite our previous method:\n\nIt’s been augmented to accept a parameter, though in a system that uses a dependency injection (DI) mechanism, it would likely just fetch a singleton from DI. Then instead of using or , it uses the corresponding members on the , and instead of using the overload that just takes a duration, it uses the overload that also takes a . When used in production, this can be passed , which is implemented based on the system clock (exactly what you would get without providing a at all), but in a test, it can be passed a custom instance, one that manually controls the observed flow of time. Exactly such a custom exists in the Microsoft.Extensions.TimeProvider.Testing NuGet package: . Here’s an example of using it with our method:\n\nWhen I run this, it outputs the following:\n\nIn other words, after manually advancing time by 29 seconds, the operation still hadn’t completed. Then we manually advanced time by one more second, and the operation completed. It reported that 30 seconds passed, but in reality, the whole operation took only 0.01 seconds of actual wall clock time.\n\nWith that, let’s move up the stack to …\n\n.NET 6 introduced new async methods onto in the form of . After its introduction, we started getting requests for an equivalent for loops, so now in .NET 8, with dotnet/runtime#84804, the class gains a set of methods. These were previously achievable by passing in an created from a method like , e.g.\n\nbut you can now achieve the same more simply and cheaply with:\n\nIt ends up being cheaper because you don’t need to allocate the enumerable/enumerator, and the synchronization involved in multiple workers trying to peel off the next iteration can be done in a much less expensive manner, a single rather than using an asynchronous lock like .\n\nThe allocation column here is particularly stark, and also a tad misleading. Why is so much worse here allocation-wise? It’s because of the synchronization mechanism. There’s zero work being performed here by the delegate in the test, so all of the time is spent hammering on the source. In the case of , that’s a single instruction to get the next value. In the case of , it’s a , and under a lot of contention, many of those calls are going to complete asynchronously, resulting in allocation. In a real workload, where the body delegate is doing real work, synchronously or asynchronously, the impact of that synchronization is much, much less dramatic. Here I’ve changed the calls to just be a simple for 1ms (and also significantly lowered the iteration count):\n\nand the two methods are the effectively same:\n\nInterestingly, this method is also one of the first public methods in the core libraries to be based on the generic math interfaces introduced in .NET 7:\n\nWhen initially designing the method, we copied the synchronous counterpart, which has overloads specific to and overloads specific to . Now that we have , however, we realized we could not only reduce the number of overloads and not only reduce the number of implementations, by using we could also open the same method up to other types folks want to use, such as or or ; they all “just work,” which is pretty cool. (The new , added in .NET 8 in dotnet/runtime#75517 by @huoyaoyuan, is another new public type relying on these interfaces.) Once we did that, in dotnet/runtime#84853 we used a similar technique to deduplicate the implementations, such that both and share the same generic implementations internally.\n\nIn .NET 6, gained a method, as we dipped our toes into the waters of providing “throw helpers.” The intent of the method is to concisely express the constraint being verified, letting the system throw a consistent exception for failure to meet the constraint while also optimizing the success and 99.999% case where no exception need be thrown. The method is structured in such a way that the fast path performing the check gets inlined, with as little work as possible on that path, and then everything else is relegated to a method that performs the actual throwing (the JIT won’t inline that throwing method, as it’ll look at its implementation and see that the method always throws).\n\nIn .NET 7, gained another overload, this time for pointers, and two new methods were introduced: for s and .\n\nNow in .NET 8, a slew of new such helpers have been added. Thanks to dotnet/runtime#86007, gains to complement :\n\nand thanks to dotnet/runtime#78222 from @hrrrrustic and dotnet/runtime#83853, gains 9 new methods:\n\nThose PRs used these new methods in a few places, but then dotnet/runtime#79460, dotnet/runtime#80355, dotnet/runtime#82357, dotnet/runtime#82533, and dotnet/runtime#85858 rolled out their use more broadly throughout the core libraries. To get a sense for the usefulness of these methods, here are the number of times each of these methods is being called from within the for the core libraries in dotnet/runtime as of the time I’m writing this paragraph:\n\nThese new methods also do more work in the throwing portion (e.g. formatting the exception message with the invalid arguments), which helps to better exemplify the benfits of moving all of that work out into a separate method. For example, here is the copied straight from :\n\nand here is a benchmark showing what consumption would look like if the expression were directly part of :\n\nThe most relevant highlight from the generated assembly is from the case:\n\nBecause there’s more cruft inside the method, the system decides not to inline it, and so we end up with two method invocations that occur even when the value is within range (the first is a , the second here is a , since there was no follow-up work in this method that would require control flow returning).\n\nTo make it easier to roll out usage of these helpers, dotnet/roslyn-analyzers#6293 added new analyzers to look for argument validation that can be replaced by one of the throw helper methods on , , , or . dotnet/runtime#80149 enables the analyzers for dotnet/runtime and fixes up many call sites.\n\nThere have been a variety of improvements here and there in the reflection stack in .NET 8, mostly around reducing allocation or caching information so that subsequent access is faster. For example, dotnet/runtime#87902 tweaks some code in to avoid allocating an array in order to set a property on an attribute.\n\nOther changes like dotnet/runtime#76574 from @teo-tsirpanis, dotnet/runtime#81059 from @teo-tsirpanis, and dotnet/runtime#86657 from @teo-tsirpanis also removed allocations in the reflection stack, in particular by more liberal use of spans. And dotnet/runtime#78288 from @lateapexearlyspeed improves the handling of generics information on a , leading to a boost for various generics-related members, in particular for for which the result is now cached on the object.\n\nHowever, the largest impact on performance in reflection in .NET 8 comes from dotnet/runtime#88415. This is a continuation of work done in .NET 7 to improve the performance of . When you know at compile-time the signature of the target method you want to invoke via reflection, you can achieve the best performance by using to get and cache a delegate for the method in question, and then performing all invocations via that delegate. However, if you don’t know the signature at compile-time, you need to rely on more dynamic means, like , which historically has been much more costly. Some enterprising developers turned to reflection emit to avoid that overhead by emitting custom invocation stubs at run-time, and that’s one of the optimization approaches taken under the covers in .NET 7 as well. Now in .NET 8, the code generated for many of these cases has improved; previously the emitter was always generating code that could accommodate / arguments, but many methods don’t have such arguments, and the generated code can be more efficient when it needn’t factor those in.\n\nHowever, there’s overhead involved here on each call and that’s repeated on each call. If we could extract that upfront work, do it once, and cache it, we can achieve much better performance. That’s exactly what the new and types implemented in dotnet/runtime#88415 provide. These don’t incorporate all of the obscure corner-cases that handles (like specially recognizing and handling ), but for everything else, it provides a great solution for optimizing the repeated invocation of methods whose signatures are unknown at build time.\n\nAs of dotnet/runtime#90119, these types are then used by the method in to further improve DI service construction performance. dotnet/runtime#91881 improves it further by adding a an additional caching layer that further avoids reflection on each construction.\n\nIt’s hard to believe that after two decades we’re still finding opportunity to improve the core primitive types in .NET, yet here we are. Some of this comes from new scenarios that drive optimization into different places; some of it comes from new opportunity based on new support that enables different approaches to the same problem; some of it comes from new research highlighting new ways to approach a problem; and some of it simply comes from many new eyes looking at a well-worn space (yay open source!) Regardless of the reason, there’s a lot to be excited about here in .NET 8.\n\nLet’s start with . has obviously been around since the earliest days of .NET and is used heavily. Although ‘s functionality and implementation have evolved, and although it’s received new APIs, at its core, how the data is stored has fundamentally remained the same for many years. In the .NET Framework implementation, there’s an internal class that stores a and a , and in .NET 7, there’s an that serves the same purpose. That contains the names of all of the enum’s values, and the stores their numeric counterparts. It’s a to accommodate all possible underlying types an can be, including those supported by C# ( , , , , , , , ) and those additionally supported by the runtime ( , , , , ) even though effectively no one uses those (partial support used to be on this list as well, but was deleted in .NET 8 in dotnet/runtime#79962 by @pedrobsaila).\n\nAs an aside, as part of all of this work, we examined the breadth of appropriately-licensed NuGet packages, looking for what the most common underlying types were in their use of . Out of ~163 million s found, here’s the breakdown of their underlying types. The result is likely not surprising, given the default underlying type for , but it’s still interesting:\n\nThere are several issues with the cited design for how stores its data. Every operation translates between these values and the actual type being used by the particular , plus the array is often twice as large as it needs to be ( is the default underlying type for an enum and, as seen in the above graph, by far the most commonly used). The approach also leads to significant assembly code bloat when dealing with all the new generic methods that have been added to in recent years. s are structs, and when a struct is used as a generic type argument, the JIT specializes the code for that value type (whereas for reference types it emits a single shared implementation used by all of them). That specialization is great for throughput, but it means that you get a copy of the code for every value type it’s used with; if you have a lot of code (e.g. formatting) and a lot of possible types being substituted (e.g. every declared type), that’s a lot of possible increase in code size.\n\nTo address all of this, to modernize the implementation, and to make various operations faster, dotnet/runtime#78580 rewrites . Rather than having a non-generic that stores a array of all values, it introduces a generic that stores a . Then based on the enum’s type, every generic and non-generic method looks up the underlying and invokes a generic method with that but not with a generic type parameter for the type, e.g. and both look up the for and invoke the internal . In this way, the implementation stores a strongly-typed value rather than storing the worst case , and all of the implementations across generic and non-generic entrypoints are shared while not having full generic specialization for every : worst case, we end up with one generic specialization per underlying type, of which only the previously cited 8 are expressible in C#. The generic entrypoints are able to do the mapping very efficiently, thanks to dotnet/runtime#71685 from @MichalPetryka which makes a JIT intrinsic (such that it effectively becomes a const), and the non-generic entrypoints use switches on / as was already being done in a variety of methods.\n\nOther improvements were made to as well. dotnet/runtime#76162 improves the performance of various methods like and in cases where all of the ‘s defined values are sequential starting from 0. In that common case, the internal function that looks up the value in the can do so with a simple array access, rather than needing to search for the target.\n\nThe net result of all of these changes are some very nice performance improvements:\n\nThese changes, however, also made s play much more nicely with string interpolation. First, now sports a new static method, which enables formatting an ‘s string representation directly into a :\n\nSecond, now implements , such that any code written to use a value’s method now lights up with s, too. However, even though enums are value types, they’re special and weird in that they derive from the reference type , and that means calling instance methods like or end up boxing the enum value.\n\nSo, third, the various interpolated string handlers in were updated to special-case , which as noted is now effectively free thanks to JIT optimizations, using directly in order to avoid the boxing. We can see the impact this has by running the following benchmark:\n\nSuch formatting improvements weren’t just reserved for s. The performance of number formatting also sees a nice set of improvements in .NET 8. Daniel Lemire has a nice blog post from 2021 discussing various approaches to counting the number of digits in an integer. Digit counting is relevant to number formatting as we need to know how many characters the number will be, either to allocate a string of the right length to format into or to ensure that a destination buffer is of a sufficient length. dotnet/runtime#76519 implements this inside of .NET’s number formatting, providing a branch-free, table-based lookup solution for computing the number of digits in a formatted value.\n\ndotnet/runtime#76726 improves performance further by using a trick other formatting libraries use. One of the more expensive parts of formatting a decimal is in dividing by 10 to pull off each digit; if we can reduce the number of divisions, we can reduce the overall expense of the formatting operation. The trick here is, rather than dividing by 10 for each digit in the number, we instead divide by 100 for each pair of digits in the number, and then have a precomputed lookup table for the -based representation of all values 0 to 99. This lets us cut the number of divisions in half.\n\ndotnet/runtime#79061 also expands on a previous optimization already present in .NET. The formatting code contained a table of precomputed strings for single digit numbers, so if you asked for the equivalent of , the implementation wouldn’t need to allocate a new string, it would just fetch from the table and return it. This PR expands that cache from single digit numbers to being all numbers 0 through 299 (it also makes the cache lazy, such that we don’t need to pay for the strings for values that are never used). The choice of 299 is somewhat arbitrary and could be raised in the future if the need presents itself, but in examining data from various services, this addresses a significant chunk of the allocations that come from number formatting. Coincidentally or not, it also includes all success status codes from the HTTP protocol.\n\nNumbers in .NET 8 also gain the ability to format as binary (via dotnet/runtime#84889, and parse from binary (via dotnet/runtime#84998), via the new “b” specifier. For example, this:\n\nThat implementation is then used to reimplement the existing method, such that it’s also now optimized:\n\nIn a significant addition to the primitive types (numerical and beyond), .NET 8 also sees the introduction of the new interface. was introduced in .NET 6, and with it methods on many types that enable those types to directly format into a :\n\nNow in .NET 8, we also have the interface:\n\nthat enables types to directly format into a . These are by design almost identical, the key difference being whether the implementation of these interfaces writes out UTF16 s or UTF8 s. With dotnet/runtime#84587 and dotnet/runtime#84841, all of the numerical primitives in both implement the new interface and expose a public method. So, for example, exposes these:\n\nThey have the exact same functionality, support the exact same format strings, the same general performance characteristics, and so on, and simply differ in whether writing out UTF16 or UTF8. How can I be so sure they’re so similar? Because, drumroll, they share the same implementation. Thanks to generics, the two methods above delegate to the exact same helper:\n\njust with one with as and the other as . So, when we run a benchmark like this:\n\nwe get practically identical results like this:\n\nAnd now that the primitive types themselves are able to format with full fidelity as UTF8, the class largely becomes legacy. In fact, the previously mentioned PR also rips out ‘s implementation and just reparents it on top of the same formatting logic from the primitive types. All of the previously cited performance improvements to number formatting then not only accrue to and for UTF16, and not only to for UTF8, but then also to (plus, removing duplicated code and reducing maintenance burden makes me giddy).\n\nNot only is UTF8 formatting directly supported by all these types, so, too, is parsing. dotnet/runtime#86875 added the new interface and implemented it on the primitive numeric types. Just as with its formatting counterpart, this provides identical behavior to , just for UTF8 instead of UTF16. And just as with its formatting counterpart, all of the parsing logic is shared in generic routines between the two modes. In fact, not only does this share logic between UTF16 and UTF8 parsing, it follows closely on the heals of dotnet/runtime#84582, which uses the same generic tricks to deduplicate the parsing logic across all the primitive types, such that the same generic routines end up being used for all the types and both UTF8 and UTF16. That PR removed almost 2,000 lines of code from :\n\nParsing and formatting are improved on other types, as well. Take and . dotnet/runtime#84963 improved a variety of aspects of formatting:\n• The formatting logic has general support used as a fallback and that supports any custom format, but then there are dedicated routines used for the most popular formats, allowing them to be optimized and tuned. Dedicated routines already existed for the very popular “r” (RFC1123 pattern) and “o” (round-trip date/time pattern) formats; this PR adds dedicated routines for the default format (“G”) when used with the invariant culture, the “s” format (sortable date/time pattern), and “u” format (universal sortable date/time pattern), all of which are used frequently in a variety of domains.\n• For the “U” format (universal full date/time pattern), the implementation would end up always allocating new and instances, resulting in a significant amount of allocation even though it was only needed in a rare fallback case. This fixed it to only allocate when truly required.\n• When there’s no dedicated formatting routine, formatting is done into an internal called that starts with a provided span buffer (typically seeded from a ) and then grows with memory as needed. After the formatting has completed, that builder is either copied into a destination span or a new string, depending on the method that triggered the formatting. However, we can avoid that copy for a destination span if we just seed the builder with the destination span. Then if the builder still contains the initial span when formatting has completed (having not grown out of it), we know all the data fit, and we can skip the copy, as all the data is already there.\n\nHere’s some of the example impact:\n\nParsing has also improved meaningfully. For example, dotnet/runtime#82877 improves the handling of “ddd” (abbreviated name of the day of the week), “dddd” (full name of the day of the week), “MMM” (abbreviated name of the month), and “MMMM” (full name of the month) in a custom format string; these show up in a variety of commonly used format strings, such as in the expanded definition of the RFC1123 format: . When the general parsing routine encounters these in a format string, it needs to consult the supplied / for that culture’s associated month and day names, e.g. , and then needs to do a linguistic ignore-case comparison for each name against the input text; that’s not particularly cheap. However, if we’re given an invariant culture, we can do the comparison much, much faster. Take “MMM” for abbreviated month name, for example. We can read the next three characters ( ), ensure they’re all ASCII ( ), and then combine them all into a single , employing the same ASCII casing trick discussed earlier ( ). We can do the same thing, precomputed, for each month name, which for the invariant culture we know in advance, and the entire lookup becomes a single numerical :\n\nA variety of other PRs contributed as well. The decreased allocation in the previous benchmark is thanks to dotnet/runtime#82861, which removed a string allocation that might occur when the format string contained quotes; the PR simply replaced the string allocation with use of spans. dotnet/runtime#82925 further reduced the cost of parsing with the “r” and “o” formats by removing some work that ended up being unnecessary, removing a virtual dispatch, and general streamlining of the code paths. And dotnet/runtime#84964 removed some allocations that occured in when parsing with some cultures, in particular those that employ genitive month names. If the parser needed to retrieve the or arrays, it would do so via the public properties for these on ; however, out of concern that code could mutate those arrays, these public properties hand back copies. That means that the parser was allocating a copy every time it accessed one of these. The parser can instead access the underlying original array, and pinky swear not to change it.\n\nand also implement , thanks to dotnet/runtime#84469, and as with the numerical types, the implementations are all shared between UTF16 and UTF8; thus all of the optimizations previously mentioned accrue to both. And again, ‘s support for formatting is just reparented on top of this same shared logic.\n\nSince we’re talking about , a brief foray into . gets a object for the specified identifier. One of the improvements introduced in .NET 6 is that supports both the Windows time zone set as well as the IANA time zone set, regardless of whether running on Windows or Linux or macOS. However, the was only being cached when its ID matched that for the current OS, and as such calls that resolved to the other set weren’t being fulfilled by the cache and were falling back to re-reading from the OS. dotnet/runtime#85615 ensures a cache can be used in both cases. It also allows returning the immutable objects directly, rather than cloning them on every access. dotnet/runtime#88368 also improves , in particular on Linux and macOS, by lazily loading several of the properties. dotnet/runtime#89985 then improves on that with a new overload of that allows the caller to skip the sort the implementation would otherwise perform on the result.\n\nFormatting and parsing improvements go beyond the numerical and date types. also gets in on the game. Thanks to dotnet/runtime#84553, implements , and as with all the other cases, it shares the exact same routines between UTF16 and UTF8 support. Then dotnet/runtime#81650, dotnet/runtime#81666, and dotnet/runtime#87126 from @SwapnilGaikwad vectorize that formatting support.\n\nBefore moving on from primitives and numerics, let’s take a quick look at , which has methods for producing pseudo-random numerical values.\n\ndotnet/runtime#79790 from @mla-alm provides an implementation in based on @lemire‘s unbiased range functions. When a method like is invoked, it needs to provide a value in the range . In order to provide an unbiased answer, the .NET 7 implementation generates a 32-bit value, narrows down the range to the smallest power of 2 that contains the max (by taking the log2 of the max and shifting to throw away bits), and then checks whether the result is less than the max: if it is, it returns the result as the answer. But if it’s not, it rejects the value (a process referred to as “rejection sampling”) and loops around to start the whole process over. While the cost to produce each sample in the current approach isn’t terrible, the nature of the approach makes it reasonably likely the sample will need to be rejected, which means looping and retries. With the new approach, it effectively implements modulo reduction (e.g. ), except replacing the expensive modulo operation with a cheaper multiplication and shift; then a rejection sampling loop is still employed, but the bias it corrects for happens much more rarely and thus the more expensive path happens much more rarely. The net result is a nice boost on average to the throughput of ‘s methods ( can also get a boost from dynamic PGO, as the internal abstraction uses can be devirtualized, so I’ve shown here the impact with and without PGO enabled.)\n\ndotnet/runtime#87219 from @MichalPetryka then further improves this for values. The core part of the algorithm involves multiplying the random value by the max value and then taking the low part of the product:\n\nThis can be made more efficient by not using ‘s multiplication implementation and instead using ,\n\nwhich is implemented to use the or intrinsics when one is available.\n\nFinally, I’ll mention dotnet/runtime#81627. is both a commonly-used type in its own right and also an abstraction; many of the APIs on are virtual, such that a derived type can be implemented to completely swap out the algorithm employed. So, for example, if you wanted to implement a that derived from and completely replaced the base algorithm by overriding every virtual method, you could do so, pass your instance around as , and everyone’s happy… unless you’re creating your derived type frequently and care about allocation. actually includes multiple pseudo-random generators. .NET 6 imbued it with an implementation of the / algorithms, which are used when you just do . However, if you instead instantiate a derived type, the implementation falls back to the same algorithm (a variant of Knuth’s subtractive random number generator algorithm) it’s used since the dawn of , as it doesn’t know what the derived type will be doing nor what dependencies it may have taken on the nature of the algorithm employed. That algorithm carries with it a 56-element , which means that derived classes end up instantiating and initializing that array even if they never use it. With this PR, the creation of that array is made lazy, such that it’s only initialized if and when it’s used. With that, a derived implementation that wants to avoid that cost can.\n\n.NET 8 sees a tremendous amount of improvement in the realm of data processing, in particular in the efficient manipulation of strings, arrays, and spans. Since we’ve just been talking about UTF8 and , let’s start there.\n\nAs noted, is now implemented on a bunch of types. I noted all the numerical primitives, , and , and with dotnet/runtime#84556 the type also implements it, as do and the new types, thanks to dotnet/runtime#84487. However, .NET 8 doesn’t just provide implementations of this interface on all of these types, it also consumes the interface in a key place.\n\nIf you’ll recall, string interpolation in C# 10 and .NET 6 was completely overhauled. This included not only making string interpolation much more efficient, but also in providing a pattern that a type could implement to allow for the string interpolation syntax to be used efficiently to do things other than create a new string. For example, a new extension method for was added that makes it possible to format an interpolated string directly into a destination buffer:\n\nThe above gets translated (“lowered”) by the compiler into the equivalent of the following:\n\nThe implementation of that generic call examines the and tries to do the most optimal thing. In this case, it’ll see that implements , and it’ll end up using its to format directly into the destination span.\n\nThat’s for UTF16. Now with , we have the opportunity to do the same thing but for UTF8. And that’s exactly what dotnet/runtime#83852 does. It introduces the new method, which behaves exactly like the aforementioned , except writing as UTF8 into a destination instead of as UTF16 into a destination . The implementation also special-cases , using its to write directly into the destination buffer.\n\nWith that, we can write the equivalent to the method we wrote earlier:\n\nand that gets lowered as you’d now expect:\n\nSo, identical, other than the parts you expect to change. But that’s also a problem in some ways. Take a look at that call. In the UTF16 case where we’re dealing with a destination , the implementation of simply needs to copy that string into the destination; not only that, but the JIT will inline the call, see that a string literal is being copied, and will unroll the copy, making it super efficient. But in the UTF8 case, we can’t just copy the UTF16 string s into the destination UTF8 buffer; we need to UTF8 encode the string. And while we can certainly do that (dotnet/runtime#84609 and dotnet/runtime#85120 make that trivial with the addition of a new method), it’s frustratingly inefficient to need to spend cycles repeatedly at run-time doing work that could be done at compile time. After all, we’re dealing with a string literal known at JIT time; it’d be really, really nice if the JIT could do the UTF8 encoding and then do an unrolled copy just as it’s already doing in the UTF16 case. And with dotnet/runtime#85328 and dotnet/runtime#89376, that’s exactly what happens, such that performance is effectively the same between them.\n\nUTF8 is the predominent encoding for text on the internet and for the movement of text between endpoints. However, much of this data is actually the ASCII subset, the 128 values in the range . When you know the data you’re working with is ASCII, you can achieve even better performance by using routines optimized for the subset. The new class in .NET 8, introduced in dotnet/runtime#75012 and dotnet/runtime#84886, and then further optimized in dotnet/runtime#85926 from @gfoidl, dotnet/runtime#85266 from @Daniel-Svensson, dotnet/runtime#84881, and dotnet/runtime#87141, provides this:\n\nNote that it provides overloads that operate on UTF16 ( ) and UTF8 ( ), and in many cases, intermixes them, such that you can, for example, compare a UTF8 with a UTF16 , or transcode a UTF16 to a UTF8 (which, when working with ASCII, is purely a narrowing operation, getting rid of the leading 0 in each ). For example, the PR that added these methods also used them in a variety of places (something I advocate for strongly, in order to ensure what has been designed is actually meeting the need, or ensure that other core library code is benefiting from the new APIs, which in turn makes those APIs more valuable, as their benefits accrue to more indirect consumers), including in multiple places in . Previously, had its own helpers for this purpose, an example of which I’ve copied here into this benchmark:\n\nMany of these new APIs also got the treatment, such that they light up when AVX512 is supported by the current machine, thanks to dotnet/runtime#88532 from @anthonycanino and dotnet/runtime#88650 from @khushal1996.\n\nAn even further constrained subset of text is Base64-encoded data. This is used when arbitrary bytes need to be transferred as text, and results in text that uses only 64 characters (lowercase ASCII letters, uppercase ASCII letters, ASCII digits, ‘+’, and ‘/’). .NET has long had methods on for encoding and decoding Base64 with UTF16 ( ), and it got an additional set of span-based methods in .NET Core 2.1 with the introduction of . At that point, the class was also introduced, with dedicated surface area for encoding and decoding with UTF8 ( ). That’s now improved further in .NET 8.\n\ndotnet/runtime#85938 from @heathbm and dotnet/runtime#86396 make two contributions here. First, they bring the behavior of the methods for UTF8 in line with its counterparts on the class, in particular around handling of whitespace. As it’s very common for there to be newlines in Base64-encoded data, the class’ methods for decoding permitted whitespace; in contrast, the class’ methods for decoding would fail if whitespace was encountered. These decoding methods now permit exactly the same whitespace that does. And that’s important in part because of the second contribution from these PRs, which is a new set of static methods. As with and , these methods simply state whether the supplied UTF8 or UTF16 input represents a valid input, such that the decoding methods on both and could successfully decode it. And as with all such processing we see introduced into .NET, we’ve strived to make the new functionality as efficient as possible so that it can be used to maximal benefit elsewhere. For example, dotnet/runtime#86221 from @WeihanLi updated the new to use it, and dotnet/runtime#86002 updated to use it. Here we can see a benchmark comparing the old non-vectorized with the new version using the vectorized :\n\nAnother relevant subset of ASCII is hexadecimal, and improvements have been made in .NET 8 around conversions between bytes and their representation in hex. In particular, dotnet/runtime#82521 vectorized the method using an algorithm outlined by Langdale and Mula. On even a moderate length input, this has a very measurable impact on throughput:\n\nOf course, the improvements in .NET 8 go well beyond just the manipulation of certain known sets of characters; there is a wealth of other improvements to explore. Let’s start with , which was introduced in dotnet/runtime#80753.\n\nSince the beginning of .NET, and friends have provided APIs for handling composite format strings, strings with text interspersed with format item placeholders, e.g. . These strings can then be passed to various APIs, like , which are provided with both the composite format string and the arguments that should be substituted in for the placeholders, e.g. will return a string like (the in the placeholder indicates the 0-based number of the argument to substitute, and the is the format that should be used, in this case the standard short time pattern). Such a method invocation needs to parse the composite format string each time it’s called, even though for a given call site the composite format string typically doesn’t change from invocation to invocation. These APIs are also generally non-generic, which means if an argument is a value type (as is in my example), it’ll incur a boxing allocation. To simplify the syntax around these operations, C# 6 gained support for string interpolation, such that instead of writing , you could instead write , and it was then up to the compiler to achieve the same behavior as if had been used (which the compiler typically achieved simply by lowering the interpolation into a call to ).\n\nIn .NET 6 and C# 10, string interpolation was significantly improved, both in terms of the scenarios supported and in terms of its efficiency. One key aspect of the efficiency is it enabled the parsing to be performed once (at compile-time). It also enabled avoiding all of the allocation associated with providing arguments. These improvements contributed to all use of string interpolation and a significant portion of the use of in real-world applications and services. However, the compiler support works by being able to see the string at compile time. What if the format string isn’t known until run-time, such as if it’s pulled from a resource file or some other source of configuration? At that point, remains the answer.\n\nNow in .NET 8, there’s a new answer available: . Just as an interpolated string allows the compiler to do the heavy lifting once in order to optimize repeated use, allows that reusable work to be done once in order to optimize repeated use. As it does the parsing at run-time, it’s able to tackle the remaining cases that string interpolation can’t reach. To create an instance, one simply calls its method, which takes a composite format string, parses it, and returns a instance:\n\nThen, existing methods like now have new overloads, exactly the same as the existing ones, but instead of taking a , they take a . The same formatting as was done earlier can then instead be done like this:\n\nThis overload (and other new overloads of methods like and ) accepts generic arguments, avoiding the boxing.\n\nIf you know the composite format string at compile time, interpolated strings are the answer. Otherwise, can give you throughput in the same ballpark at the expense of some startup costs. Formatting with a is actually implemented with the same interpolated string handlers that are used for string interpolation, e.g. ends up calling into methods on to do the actual formatting work.\n\nThere’s also a new analyzer to help with this. CA1863 “Use ‘CompositeFormat'” was introduced in dotnet/roslyn-analyzers#6675 to identify and calls that could possibly benefit from switching to use a argument instead.\n\nMoving on from formatting, let’s turn our attention to all the other kinds of operations one frequently wants to perform on sequences of data, whether that be arrays, strings, or the unifying force of spans. A home for many routines for manipulating all of these, via spans, is the type, which has received a multitude of new APIs in .NET 8.\n\nOne very common operation is to count how many of something there are. For example, in support of multiline comments, needs to count how many line feed characters there are in a given piece of JSON. This is, of course, trivial to write as a loop, whether character-by-character or using and slicing. Now in .NET 8, you can also just call the extension method, thanks to dotnet/runtime#80662 from @bollhals and dotnet/runtime#82687 from @gfoidl. Here we’re counting the number of line feed characters in “The Adventures of Sherlock Holmes” from Project Gutenberg:\n\nThe core of the implementation here that enables to be so fast, in particular when searching for a single value, is based on just two key primitives: and . Here’s the loop that forms the bulk of the implementation (the implementation has similar loops for and as well):\n\nThis is creating a vector where every element of the vector is the target (in this case, ). Then, as long as there’s at least one vector’s worth of data remaining, it loads the next vector ( ) and compares that with the target vector ( ). That produces a new where each element is all ones when the values are equal and all zeros when they’re not. We then extract out the most significant bit of each element ( ), so getting a bit with the value where the values were equal, otherwise . And then we use on the resulting to get the “population count,” i.e. the number of bits that are , and we add that to our running tally. In this way, the inner loop of the count operation remains branch-free, and the implementation can churn through the data very quickly. You can find several examples of using in dotnet/runtime#81325, which used it in several places in the core libraries.\n\nA similar new method is , which comes in .NET 8 in two shapes. dotnet/runtime#76337 from @gfoidl added an in-place variant:\n\nAs an example of where this comes in handy, has some code paths that need to normalize directory separators to be , such that any characters need to be replaced. This previously used an loop as was shown in the previous benchmark, and now it can just use . Here’s a comparison (which, purely for benchmarking purposes, is normalizing back and forth so that each time the benchmark runs it finds things in the original state):\n\nThe new does better than both the manual loop and the loop. As with , has a fairly simple and tight inner loop; again, here’s the variant of that loop:\n\nThis is loading the next vector’s worth of data ( ) and comparing that with a vector filled with the , which produces a new vector with s for equality and for inequality. It then calls the super handy . This is a branchless SIMD condition operation: it produces a new vector that has an element from one vector if mask’s bits were s and from another vector if the mask’s bits were s (think a ternary operator). That resulting vector is then saved out as the result. In this manner, it’s overwriting the whole span, in some cases just writing back the value that was previously there, and in cases where the original value was the target , writing out the instead. This loop body is branch-free and doesn’t change in cost based on how many elements need to be replaced. In an extreme case where there’s nothing to be replaced, an -based loop could end up being a tad bit faster, since the body of ‘s inner loop has even fewer instructions, but such an loop pays a relatively high cost for every replacement that needs to be done.\n\nalso had such an -based implementation for its and methods, and they’re now based on , so the improvements accrue there as well.\n\nInterestingly, whereas was using and switched to use , wasn’t using at all, a gap that’s been fixed in dotnet/runtime#81098. when dealing with strings is more complicated in because of its segmented nature. isn’t just backed by an array: it’s actually a linked list of segments, each of which stores an array. With the -based , it can simply operate on each segment individually, but for the -based , it needs to deal with the possibility that the value being searched for crosses a segment boundary. was thus walking each segment character-by-character, doing an equality check at each position. Now with this PR, it’s using and only falling back to a character-by-character check when close enough to a segment boundary that it might be crossed.\n\nAs long as we’re on the subject of , it saw some other nice improvements in .NET 8. dotnet/runtime#85894 from @yesmey tweaked both and the JIT to enable the JIT to unroll the memory copies that occur as part of appending a constant string.\n\nAnd dotnet/runtime#86287 from @yesmey changed to use instead of manually looping, taking advantage of the optimized implementation, even for reasonably small counts.\n\nBack to , another new helpful method is (and ). This is a span-based counterpart to for some uses of . I say “some” because there are effectively two main patterns for using : when you expect a certain number of parts, and when there are an unknown number of parts. For example, if you want to parse a version string as would be used by , there are at most four parts (“major.minor.build.revision”). But if you want to split, say, the contents of a file into all of the lines in the file (delimited by a ), that’s an unknown (and potentially quite large) number of parts. The new method is focused on the situations where there’s a known (and reasonably small) maximum number of parts expected. In such a case, it can be significantly more efficient than , especially from an allocation perspective.\n\nhas overloads that accept an , and behaves identically to these overloads; however, rather than giving it an , you give it a whose length is the same value you would have used for . For example, let’s say you want to split a key/value pair separated by an . If this were , you could write that as:\n\nOf course, if the input was actually erroneous for what you were expecting and there were 100 equal signs, you’d end up creating an array of 101 strings. So instead, you might write that as:\n\nWait, “3”? Aren’t there only two parts, and if so, why not pass “2”? Because of the behavior of what happens with the last part. The last part contains the remainder of the string after the separator before it, so for example the call:\n\nIf you want to know whether there were more than two parts, you need to request at least one more, and then if that last one was produced, you know the input was erroneous. For example, this:\n\nWe can do the same thing with the new overload, except a) the caller provides the destination span to write the results into, and b) the results are stored as a rather than as a . That means that the whole operation is allocation-free. And thanks to the indexer on that lets you pass in a and slice the span, you can easily use the written ranges to access the relevant portions of the input.\n\nHere’s an example from dotnet/runtime#80211, which used to reduce the cost of :\n\nMore examples of and being used are in dotnet/runtime#80471 and dotnet/runtime#82007. Both of those remove allocations from various types that were previously using .\n\nalso includes a new set of methods for ranges, thanks to dotnet/runtime#76803:\n\nWant to find the index of the next ASCII digit? No problem:\n\nWant to determine whether some input contains any non-ASCII or control characters? You got it:\n\nFor example, dotnet/runtime#78658 uses to quickly determine whether portions of a might contain a bidirectional control character, searching for anything in the range , and then only examining further if anything in that range is found. And dotnet/runtime#79357 uses to determine whether to use or . It was previously implemented with a simple loop, and it’s now implemented with an even simpler call to :\n\nMore of a productivity thing than performance (at least today), but .NET 8 also includes new methods (dotnet/runtime#87621) that allow writing these kind of calls that are then compared against 0 in a slightly cleaner fashion, e.g. the previous example could have been simplified slightly to:\n\nOne of the things I love about these kinds of helpers is that code can simplify down to use them, and then as the helpers improve, so too does the code that relies on them. And in .NET 8, there’s a lot of “the helpers improve.”\n\ndotnet/runtime#86655 from @DeepakRajendrakumaran added support for to most of these span-based helpers in . That means that when running on hardware which supports AVX512, many of these operations simply get faster. This benchmark uses environment variables to explicitly disable support for the various instruction sets, such that we can compare performance of a given operation when nothing is vectorized, when is used and hardware accelerated, when is used and hardware accelerated, and when is used and hardware accelerated. I’ve run this on my Dev Box that does support AVX512:\n\nSo, not quite a halving going from 128-bit to 256-bit or another halving going from 256-bit to 512-bit, but pretty close.\n\ndotnet/runtime#77947 vectorized for large enough inputs (the same underlying implementation is used for both and ). In a loop, it loads the next two vectors. It then checks to see whether anything in those vectors is non-ASCII; it can do so efficiently by OR’ing them together ( ) and then seeing whether the high bit of any of the elements is set… if none are, then all the elements in both of the input vectors are ASCII ( ). If it finds anything non-ASCII, it just continues on with the old mode of comparison. But as long as everything is ASCII, then it can proceed to do the comparison in a vectorized manner. For each vector, it uses some bit hackery to create a lowercased version of the vector, and then compares the lowercased versions for equality.\n\ndotnet/runtime#78262 uses the same tricks to vectorize and :\n\ndotnet/runtime#75640 improves the internal method that’s used by the vast majority of . If you look in the source for , you’ll find a fairly common pattern: special-case , , , and with a vectorized implementation, and then fall back to a general non-vectorized implementation for everything else. Except it’s not exactly “special-case , , , and “, but rather “special-case bitwise-equatable types that are the same size as , , , or .” If something is “bitwise equatable,” that means we don’t need to worry about any implementation it might provide or any override it might have, and we can instead simply rely on the value’s bits being the same or different from another value to identify whether the values are the same or different. And if such bitwise equality semantics apply for a type, then the intrinsics that determine equality for , , , and can be used for any type that’s 1, 2, 4, or 8 bytes, respectively. In .NET 7, would be true only for a finite and hardcoded list in the runtime: , , , , , , , , , , , , , and s. Now in .NET 8, that list is extended to a dynamically discoverable set where the runtime can easily see that the type itself doesn’t provide any equality implementation.\n\nNote this not only means the result gets vectorized, it also ends up avoiding excessive boxing (hence all that allocation), as it’s no longer calling on each value type instance.\n\ndotnet/runtime#85437 improved the vectorization of . Imagine we’re searching some text for the word “elementary.” In .NET 7, it would end up doing an in order to find the first possible place “elementary” could match, and would then do the equivalent of a . If the fails, then it loops around to search for the next possible starting location. This is ok if the the characters being searched for are rare, but in this example, is the most common letter in the English alphabet, and so an is frequently stopping, breaking out of the vectorized inner loop, in order to do the full comparison. In contrast to this, in .NET 7 was improved using the algorithm outlined by Mula; the idea there is that rather than just searching for one character (e.g. the first), you have a vector for another character as well (e.g. the last), you offset them appropriately, and you AND their comparison results together as part of the inner loop. Even if is very common, and then a nine characters later is much, much less common, and thus it can stay in its tight inner loop for longer. Now in .NET 8, we apply the same trick to when we can find two ASCII characters in the input, e.g. it’ll simultaneously search for or followed by a or ‘ nine characters later.\n\nEven just a simple is also significantly improved in .NET 8. Here I’m searching “The Adventures of Sherlock Holmes” for an , which I happen to know doesn’t appear, such that the entire search will be spent in ‘s tight inner loop.\n\nThat improvement is thanks to dotnet/runtime#78861. The goal of SIMD and vectorization is to do more with the same; rather than processing one thing at a time, process 2 or 4 or 8 or 16 or 32 or 64 things at a time. For s, which are 16 bits in size, in a 128-bit vector you can process 8 of them at a time; double that for 256-bit, and double it again for 512-bit. But it’s not just about the size of the vector; you can also find creative ways to use a vector to process more than you otherwise could. For example, in a 128-bit vector, you can process 8 s at a time… but you can process 16 s at a time. What if you could process the s instead as s? You could of course reinterpret the 8 s as 16 s, but for most algorithms you’d end up with the wrong answer (since each of the would be treated independently). What if instead you could condense two vectors’ worth of s down to a single vector of , and then do the subsequent processing on that single vector of ? Then as long as you were doing a few instructions-worth of processing on the vector and the cost of that condensing was cheap enough, you could approach doubling your algorithm’s performance. And that’s exactly what this PR does, at least for very common needles, and on hardware that supports SSE2. SSE2 has dedicated instructions for taking two vectors and narrowing them down to a single vector, e.g. take a and a , and combine them into a by taking the low from each in the input. However, these particular instructions don’t simply ignore the other in each completely; instead, they “saturate.” That means if casting the value to a would overflow, it produces 255, and if it would underflow, it produces 0. That means we can take two vectors of 16-bit values, pack them into a single vector of 8-bit values, and then as long as the thing we’re searching for is in the range [1, 254], we can be sure that equality checks against the vector will be accurate (comparisons against 0 or 255 might lead to false positives). Note that while Arm does have support for similar “narrowing with saturation,” the cost of those particular instructions was measured to be high enough that it wasn’t feasible to use them here (they are used elsewhere). This improvement applies to several other -based methods as well, including and .\n\nOne last -centric improvement to highlight. The and types don’t implement , but the method does exist to enable getting an enumerable from them. It’s buried away in primarily so as to guide developers not to iterate through the directly, but to instead iterate through its , e.g.\n\nThe driving force behind this is that the property has some overhead, as a can be backed by multiple different object types (namely a , a if it’s a , or a ), and needs to fetch a for the right one. Even so, from time to time you do actually need an from a , and provides that. In such situations, it’s actually beneficial from a performance perspective that one doesn’t just pass the as an , since doing so would box the value, and then enumerating that enumerable would require a second allocation for the . In contrast, can return an instance that is both the and the . In fact, that’s what it’s done since it was added, with the entirety of the implementation being:\n\nThe C# compiler generates an for such an iterator that does in fact also implement and return itself from to avoid an extra allocation, so that’s good. As noted, though, has some overhead, and this is accessing once per element… not ideal. dotnet/runtime#89274 addresses this in multiple ways. First, itself can check the type of the underlying object behind the , and for a or a can return a different iterator that just directly indexes into the array or string rather than going through on every access. Moreover, can check to see whether the bounds represented by the are for the full length of the array or string… if they are, then can just return the original object, without any additional allocation. The net result is a much more efficient enumeration scheme for anything other than a , which is much more rare (but also not negatively impacted by the improvements for the other types).\n\nAs should be obvious from the length of this document, there are a sheer ton of performance-focused improvements in .NET 8. As I previously noted, I think the most valuable addition in .NET 8 is enabling dynamic PGO by default. After that, I think the next most exciting addition is the new type. It is simply awesome, in my humble opinion.\n\nFunctionally, doesn’t do anything you couldn’t already do. For example, let’s say you wanted to search for the next ASCII letter or digit in text. You can already do that via :\n\nAnd that works, but it hasn’t been particularly fast. In .NET 7, is optimized for searching for up to 5 target characters, e.g. it could efficiently vectorize a search for English vowels ( ). But with a target set of 62 characters like in the previous example, it would no longer vectorize, and instead of trying to see how many characters it could process per instruction, switches to trying to see how few instructions it can employ per character (meaning we’re no longer talking about fractions of an instruction per character in the haystack and now talking about multiple instructions per character in the haystack). It does this via a Bloom filter, referred to in the implementation as a “probabilistic map.” The idea is to maintain a bitmap of 256 bits. For every needle character, it sets 2 bits in that bitmap. Then when searching the haystack, for each character it looks to see whether both bits are set in the bitmap; if at least one isn’t set, then this character can’t be in the needle and the search can continue, but if both bits are in the bitmap, then it’s likely but not confirmed that the haystack character is in the needle, and the needle is then searched for the character to see whether we’ve found a match.\n\nThere are actually known algorithms for doing these searches more efficiently. For example, the “Universal” algorithm described by Mula is a great choice when searching for an arbitrary set of ASCII characters, enabling us to efficiently vectorize a search for a needle composed of any subset of ASCII. Doing so requires some amount of computation to analyze the needle and build up the relevant bitmaps and vectors that are required for performing the search, just as we have to do so for the Bloom filter (albeit generating different artifacts). dotnet/runtime#76740 implements these techniques in . Rather than always building up a probabilistic map, it first examines the needle to see if all of the values are ASCII, and if they are, then it switches over to this optimized ASCII-based search; if they’re not, it falls back to the same probabilistic map approach used previously. The PR also recognizes that it’s only worth attempting either optimization under the right conditions; if the haystack is really short, for example, we’re better off just doing the naive search, where for every character in the haystack we search through the needle to see if the is a target.\n\nEven with those improvements, this work of building up these vectors is quite repetitive, and it’s not free. If you have such an in a loop, you’re paying to build up those vectors over and over and over again. There’s also additional work we could do to further examine the data to choose an even more optimal approach, but every additional check performed comes at the cost of more overhead for the call. This is where comes in. The idea behind is to perform all this work once and then cache it. Almost invariably, the pattern for using a is to create one, store it in a field, and then use that for all searching operations for that target set. And there are now overloads of methods like that take a or , for example, instead of a or , respectively. Thus, my previous ASCII letter or digit example would instead look like this:\n\ndotnet/runtime#78093 provided the initial implementation of (it was originally named , but we renamed it subsequently to the more general so that we can use it now and in the future with other methods, like or ). If you peruse the implementation, you’ll see that the factory methods don’t just return a concrete type; rather, provides an internal abstraction that’s then implemented by more than fifteen derived implementations, each specialized for a different scenario. You can see this fairly easily in code by running the following program:\n\nand you’ll see output like the following:\n\nhighlighting that each of these different inputs ends up getting mapped to a different -derived type.\n\nAfter that initial PR, has been successively improved and refined. dotnet/runtime#78863, for example, added AVX2 support, such that with 256-bit vectors being employed (when available) instead of 128-bit vectors, some benchmarks close to doubled in throughput, and dotnet/runtime#83122 enabled WASM support. dotnet/runtime#78996 added a method to be used when implementing scalar fallback paths. And dotnet/runtime#86046 reduced the overhead of calling with a simply by tweaking how the relevant bitmaps and vectors are internally passed around. But two of my favorite tweaks are dotnet/runtime#82866 and dotnet/runtime#84184, which improve overheads when ‘\\0’ (null) is one of the characters in the needle. Why would this matter? Surely searching for ‘\\0’ can’t be so common? Interestingly, in a variety of scenarios it can be. Imagine you have an algorithm that’s really good at searching for any subset of ASCII, but you want to use it to search for either a specific subset of ASCII or something non-ASCII. If you just search for the subset, you won’t learn about non-ASCII hits. And if you search for everything other than the subset, you’ll learn about non-ASCII hits but also all the wrong ASCII characters. Instead what you want to do is invert the ASCII subset, e.g. if your target characters are ‘A’ through ‘Z’ and ‘a’ through ‘z’, you instead create the subset including ‘\\u0000’ through ‘\\u0040’, ‘\\u005B’ through ‘\\u0060’, and ‘\\u007B’ through ‘\\u007F’. Then, rather than doing an with that inverted subset, you instead do with that inverted subset; this is a true case of “two wrongs make a right,” as we’ll end up with our desired behavior of searching for the original subset of ASCII letter plus anything non-ASCII. And as you’ll note, ‘\\0’ is in our inverted subset, making the performance when ‘\\0’ is in there more important than it otherwise would be.\n\nInterestingly, the probabilistic map code path in .NET 8 actually also enjoys some amount of vectorization, even without , thanks to dotnet/runtime#80963 (it was also further improved in dotnet/runtime#85189 that used better instructions on Arm, and in dotnet/runtime#85203 that avoided some wasted work). That means that whether or not is used, searches involving probabilistic map get much faster than in .NET 7. For example, here’s a benchmark that again searches “The Adventures of Sherlock Holmes” and counts the number of line endings in it, using the same needle that uses:\n\ncan then be used to improve upon that. It does so not only by caching the probabilistic map that each call to above needs to recompute, but also by recognizing that when a needle contains ASCII, that’s a good indication (heuristically) that ASCII haystacks will be prominent. As such, dotnet/runtime#89155 adds a fast path that performs a search for either any of the ASCII needle values or any non-ASCII value, and if it finds a non-ASCII value, then it falls back to performing the vectorized probabilistic map search.\n\ndotnet/runtime#89224 further augments that heuristic by guarding that ASCII fast path behind a quick check to see if the very next character is non-ASCII, skipping the ASCII-based search if it is and thereby avoiding the overhead when dealing with an all non-ASCII input. For example, here’s the result of running the previous benchmark, with the exact same code, except changing the URL to be , which is an almost entirely Greek document containing Aristotle’s “The Constitution of the Athenians”:\n\nWith all of that goodness imbued in , it’s now being used extensively throughout dotnet/runtime. For example, previously had its own dedicated implementation of a function that it used to search for any character with an ordinal value less than 32, or a quote, or a backslash. That implementation in .NET 7 was ~200 lines of complicated -based code. Now in .NET 8 thanks to dotnet/runtime#82789, it’s simply this:\n\nSuch use was rolled out in a bunch of PRs, for example dotnet/runtime#78664 that used in , dotnet/runtime#81976 in , dotnet/runtime#78676 in , dotnet/runtime#78667 in , dotnet/runtime#79025 in and , dotnet/runtime#79974 in , dotnet/runtime#81486 in , and dotnet/runtime#78896 in . dotnet/runtime#78666 and dotnet/runtime#79024 in are particularly nice, including optimizing the commonly-used helper with ; this shows up as a sizable improvement, especially when there’s nothing to escape.\n\nAll in all, just in dotnet/runtime, is now used in more than 40 places, and that’s not including all the uses that get generated as part of (more on that in a bit). This is helped along by dotnet/roslyn-analyzers#6898, which adds a new analyzer that will flag opportunities for and update the code to use it:\n\nThroughout this discussion, I’ve mentioned several times, using it as an example of the kind of thing that wants to efficiently search for multiple characters. After dotnet/runtime#78678 and dotnet/runtime#81630, it now also uses , plus has been enhanced with other optimizations. Given the discussion of , it’ll be obvious how it’s employed here, at least the basics of it. Previously, relied on an internal helper which did this:\n\nNow, it does:\n\nwhere that is just:\n\nStraightforward. However, it takes things a bit further. Note that there are 6 characters in that list, some of which are ASCII, some of which aren’t. Knowing the algorithms currently employs, we know that this will knock it off the path of just doing an ASCII search, and it’ll instead use the algorithm that does a search for one of the 3 ASCII characters plus anything non-ASCII, and if it finds anything non-ASCII, will then fallback to doing the probabilistic map search. If we could remove just one of those characters, we’d be back into the range of just being able to use the implementation that can work with any 5 characters. On non-Windows systems, we’re in luck. by default replaces a line ending with ; on Windows, that’s , but on Linux and macOS, that’s . If the replacement text is (which can also be opted-into on Windows by using the overload), then searching for only to replace it with is a nop, which means we can remove from the search list when the replacement text is , bringing us down to only 5 target characters, and giving us a little edge. And while that’s a nice little gain, the bigger gain is that we won’t end up breaking out of the vectorized loop as frequently, or at all if all of the line endings are the replacement text. Further, the .NET 7 implementation was always creating a new string to return, but we can avoid allocating it if we didn’t actually replace anything with anything new. The net result of all of this are huge improvements to , some due to and some beyond.\n\nThe changes also accrue to the span-based non-allocating :\n\nHaving just examined , it’s a good time to talk about , as the former now plays an integral role in the latter. was significantly improved in .NET 5, and then again was overhauled for .NET 7, which saw the introduction of the regex source generator. Now in .NET 8, continues to receive significant investment, in particular this release in taking advantage of much of the work already discussed that was introduced lower in the stack to enable more efficient searching.\n\nAs a reminder, there are effectively three different “engines” within , meaning effectively three different components for actually processing a regex. The simplest engine is the “interpreter”; the constructor translates the regular expression into a series of regex opcodes which the RegexInterpreter then evaluates against the incoming text. This is done in a “scan” loop, which (simplified) looks like this:\n\ntries to move through as much of the input text as possible until it finds a position in the input that could feasibly start a match, and then evaluates the pattern at that position against the input. That evaluation in the interpreter involves a loop like this, processing the opcodes that were produced from the pattern:\n\nThen there’s the non-backtracking engine, which is what you get when you select the option introduced in .NET 7. This engine shares the same implementation as the interpreter, such that all of the optimizations involved in skipping through as much text as possible (ideally via vectorized operations) accrue to both the interpreter and the non-backtracking engine. However, that’s where the similarities end. Rather than processing regex opcodes, the non-backtracking engine works by converting the regular expression pattern into a lazily-constructed deterministic finite automata (DFA) or non-deterministic finite automata (NFA), which it then uses to evaluate the input text. The key benefit of the non-backtracking engine is that it provides linear-time execution guarantees in the length of the input. For a lot more detail, please read Regular Expression Improvements in .NET 7.\n\nThe third engine actually comes in two forms: and the regex source generator (introduced in .NET 7). Except for a few corner-cases, these are effectively the same as each other in terms of how they work. They both generate custom code specific to the input pattern provided, with the former generating IL at run-time and the latter generating C# (which is then compiled to IL by the C# compiler) at build-time. The structure of the resulting code, and 99% of the optimizations applied, are identical between them; in fact, in .NET 7, the was completely rewritten to be a block-by-block translation of the C# code the regex source generator emits. For both, the actual emitted code is fully customized to the exact pattern supplied, with both trying to generate code that processes the regex as efficiently as possible, and with the source generator trying to do so by generating code that is as close as possible to what an expert .NET developer might write. That’s in large part because the source it generates is visible, even in Visual Studio live as you edit your pattern:\n\nI mention all of this because there is ample opportunity throughout , both in the used by the interpreter and non-backtracking engines and throughout the code generated by and the regex source generator, to use APIs introduced to make searching faster. I’m looking at you, and friends.\n\nAs noted earlier, new variants have been introduced in .NET 8 for searching for ranges, and as of dotnet/runtime#76859, will now take full advantage of them in generated code. For example, consider , which might be used to search for a zip code in the United States. The regex source generator in .NET 7 would emit code for that contained this:\n\nNow in .NET 8, that same attribute instead generates this:\n\nThat .NET 7 implementation is examining one character at a time, whereas the .NET 8 code is vectorizing the search via , examining multiple characters at a time. This can lead to significant speedups.\n\nThe generated code can use these APIs in other places as well, even as part of validating the match itself. Let’s say your pattern was instead , which is going to look for and capture a sequence of at least three word characters that is then followed by an ASCII digit. This is a standard greedy loop, so it’s going to consume as many word characters as it can (which includes ASCII digits), and will then backtrack, giving back some of the word characters consumed, until it can find a digit. Previously, that was implemented just by giving back a single character, seeing if it was a digit, giving back a single character, seeing if it was a digit, and so on. Now? The source generator emits code that includes this:\n\nIn other words, it’s using to optimize that backwards search for the next viable backtracking location.\n\nAnother significant improvement that builds on improvements lower in the stack is dotnet/runtime#85438. As was previously covered, the vectorization of has been improved in .NET 8. Previously, wasn’t utilizing this API, as it was often able to do better with its own custom-generated code. But now that the API has been optimized, this PR changes to use it, making the generated code both simpler and faster. Here I’m searching case-insensitively for the whole word “year”:\n\nIn addition to learning how to use the existing and the new and , in .NET 8 also learns how to use the new . This is a big boost for , as it now means that it can vectorize searches for many more sets than it previously could. For example, let’s say you wanted to search for all hex numbers. You might use a pattern like . If you plug that into the regex source generator in .NET 7, you’ll get a emitted that contains code like this:\n\nNow in .NET 8, thanks in large part to dotnet/runtime#78927, you’ll instead get code like this:\n\nWhat is that ? It’s a emitted into the file’s class:\n\nThe source generator explicitly recognized this set and so created a nice name for it, but that’s purely about readability; it can still use even if it doesn’t recognize the set as something that’s well-known and easily nameable. For example, if I instead augment the set to be all valid hex digits and an underscore, I then instead get this:\n\nWhen initially added to , was only used when the input set was all ASCII. But as improved over the development of .NET 8, so too did ‘s use of it. With dotnet/runtime#89205, now relies on ‘s ability to efficiently search for both ASCII and non-ASCII, and will similarly emit a if it’s able to efficiently enumerate the contents of a set and that set contains a reasonably small number of characters (today, that means no more than 128). Interestingly, ‘s optimization to first do a search for the ASCII subset of a target and then fallback to a vectorized probabilistic map search was first prototyped in (dotnet/runtime#89140), after which we decided to push the optimization downwards into so that could generate simpler code and so that other non- consumers would benefit.\n\nThat still, however, leaves the cases where we can’t efficiently enumerate the set in order to determine every character it includes, nor would we want to pass a gigantic number of characters off to . Consider the set , i.e. “word characters.” Of the 65,536 values, 50,409 match the set . It would be inefficient to enumerate all of those characters in order to try to create a for them, and doesn’t try. Instead, as of dotnet/runtime#83992, employs a similar approach as noted above, but with a scalar fallback. For example, for the pattern , it emits the following helper into :\n\nThe fact that it named the helper “IndexOfAnyWordChar” is, again, separate from the fact that it was able to generate this helper; it simply recognizes the set here as part of determining a name and was able to come up with a nicer one, but if it didn’t recognize it, the body of the method would be the same and the name would just be less readable, as it would come up with something fairly gibberish but unique.\n\nAs an interesting aside, I noted that the source generator and are effectively the same, just with one generating C# and one generating IL. That’s 99% correct. There is one interesting difference around their use of , though, one which makes the source generator a bit more efficient in how it’s able to utilize the type. Any time the source generator needs a instance for a new combination of characters, it can just emit another field for that instance, and because it’s , the JIT’s optimizations around devirtualization and inlining can kick in, with calls to use this seeing the actual type of the instance and optimizing based on that. Yay. is a different story. emits IL for a given , and it does so using ; this provides the lightest-weight solution to reflection emit, also allowing the generated methods to be garbage collected when they’re no longer referenced. s, however, are just that, methods. There’s no support for creating additional static fields on demand, without growing up into the much more expensive -based solution. How then can create and store an arbitrary number of instances, and how can it do so in a way that similarly enables devirtualization? It employs a few tricks. First, a field was added to the internal type that stores the delegate to the generated method: As an array, this enables any number of to be stored; the emitted IL can access the field, grab the array, and index into it to grab the relevant instance. Just doing that, of course, would not allow for devirtualization, and even dynamic PGO doesn’t help here because currently s don’t participate in tiering; compilation goes straight to tier 1, so there’d be no opportunity for instrumentation to see the actual -derived type employed. Thankfully, there are available solutions. The JIT can learn about the type of an instance from the type of a local in which it’s stored, so one solution is to create a local of the concrete and sealed derived type (we’re writing IL at this point, so we can do things like that without actually having access to the type in question), read the from the array, store it into the local, and then use the local for the subsequent access. And, in fact, we did that for a while during the .NET 8 development process. However, that does require a local, and requires an extra read/write of that local. Instead, a tweak in dotnet/runtime#85954 allows the JIT to use the in to learn about the actual type of , and so can just use to inform the JIT as to the actual type of the instance such that it’s then devirtualized. The code uses then to emit the IL to load a is this:\n\nWe can see all of this in action with a benchmark like this:\n\nHere we’re searching the same Sherlock Holmes text for the names of some of the most common characters in the detective stories. The regex pattern analyzer will try to find something for which it can vectorize a search, and it will look at all of the characters that can validly exist at each position in a match, e.g. all matches begin with ‘H’, ‘W’, ‘L’, ‘M’, ‘A’, or ‘G’. And since the shortest match is five letters (“Adler”), it’ll end up looking at the first five positions, coming up with these sets:\n\nAll of those sets have more than five characters in them, though, an important delineation as in .NET 7 that is the largest number of characters for which will vectorize a search. Thus, in .NET 7, ends up emitting code that walks the input checking character by character (though it does match the set using a fast branch-free bitmap mechanism):\n\nNow in .NET 8, with we can efficiently search for any of these sets, and the implementation ends up picking the one it thinks is statistically least likely to match:\n\nwhere that is defined as:\n\nThis leads the overall searching process to be much more efficient.\n\nOther PRs like dotnet/runtime#84370, dotnet/runtime#89099, and dotnet/runtime#77925 have also contributed to how and friends are used, tweaking the various heuristics involved. But there have been improvements to as well outside of this realm. dotnet/runtime#84003, for example, streamlines the matching performance of when matching against non-ASCII characters by using a bit-twiddling trick. And dotnet/runtime#84843 changes the underlying type of an internal enum from to , and in doing so ends up shrinking the size of the object containing a value of this enum by 8 bytes (in a 64-bit process). More impactful is dotnet/runtime#85564, which makes a measurable improvement for . was maintaining a list of segments to be composed back into the final string; some segments would come from the original , while some would be the replacement . As it turns out, though, the string reference contained in that is unnecessary. We can instead just maintain a list of , where every time we add a segment we add to the list the and the , and with the nature of replace, we can simply rely on the fact that we’ll need to insert the replacement text between every pair of values.\n\nOne last improvement in to highlight isn’t actually due to anything in , but actually in a primitive uses on every operation: . Consider this benchmark:\n\nThis is purely measuring the overhead of calling into a instance; the matching routine will complete immediately as the pattern matches any input. Since we’re only talking about tens of nanoseconds, your numbers may vary here, but I routinely get results like this:\n\nThat several nanosecond improvement is primarily due to dotnet/runtime#79181, which made and for reference types into intrinsics, special-casing when the JIT can see that the new value to be written is . These APIs need to employ a GC write barrier as part of writing the object reference into the shared location, for the same reasons previously discussed earlier in this post, but when writing , no such barrier is required. This benefits , which uses as part of renting a to use to actually process the match. Each instance caches a runner object, and every operation tries to rent and return it… that renting is done with :\n\nMany object pool implementations employ a similar use of and will similarly benefit.\n\nThe library was introduced in .NET 6 to provide non-cryptographic hash algorithm implementations; initially, it shipped with four types: , , , and . In .NET 8, it gets significant investment, in adding new optimized algorithms, in improving the performance of existing implementations, and in adding new surface area across all of the algorithms.\n\nThe xxHash family of hash algorithms has become quite popular of late due to its high performance on both large and small inputs and its overall level of quality (e.g. how few collisions are produced, how well inputs are dispersed, etc.) previously included implementations of the older XXH32 and XXH64 algorithms (as and , respectively). Now in .NET 8, thanks to dotnet/runtime#76641, it includes the XXH3 algorithm (as ), and thanks to dotnet/runtime#77944 from @xoofx, it includes the XXH128 algorithm (as ). The algorithm was also further optimized in dotnet/runtime#77756 from @xoofx by amortizing the costs of some loads and stores, and in dotnet/runtime#77881 from @xoofx, which improved throughput on Arm by making better use of the hardware intrinsics.\n\nTo see overall performance of these hash functions, here’s a microbenchmark comparing the throughput of the cryptographic SHA256 with each of these non-cryptographic hash functions. I’ve also included an implementation of FNV-1a, which is the hash algorithm that may be used by the C# compiler for statements (when it needs to over a string, for example, and it can’t come up with a better scheme, it hashes the input, and then does a binary search through the pregenerated hashes for each of the cases), as well as an implementation based on (noting that is different from the rest of these, in that it’s focused on enabling the hashing of arbitrary .NET types, and includes per-process randomization, whereas a goal of these other hash functions is to be 100% deterministic across process boundaries).\n\nA key reason and do so much better than and is that their design is focused on being vectorizable. As such, the .NET implementations employ the support in to take full advantage of the underlying hardware. This data also hints at why the C# compiler uses FNV-1a: it’s really simple and also really low overhead for small inputs, which are the most common form of input used in statements, but it would be a poor choice if you expected primarily longer inputs.\n\nYou’ll note that in the previous example, and both end up in the same ballpark as in terms of throughput (XXH3 generally ranks better than CRC32/64 in terms of quality). CRC32 in that comparison benefits significantly from dotnet/runtime#83321 from @brantburnett, dotnet/runtime#86539 from @brantburnett, and dotnet/runtime#85221 from @brantburnett. These vectorize the and implementations, based on a decade-old paper from Intel titled “Fast CRC Computation for Generic Polynomials Using PCLMULQDQ Instruction.” The cited instruction is part of SSE2, however the PR is also able to vectorize on Arm by taking advantage of Arm’s instruction. The net result is huge gains over .NET 7, in particular for larger inputs being hashed.\n\nAnother change also further improves performance of some of these algorithms, but with a primary purpose of actually making them easier to use in a variety of scenarios. The original design of was focused on creating non-cryptographic alternatives to the existing cryptographic algorithms folks were using, and thus the APIs are all focused on writing out the resulting digests, which are opaque bytes, e.g. CRC32 produces a 4-byte hash. However, especially for these non-cryptographic algorithms, many developers are more familiar with getting back a numerical result, e.g. CRC32 produces an . Same data, just a different representation. Interestingly, as well, some of these algorithms operate in terms of such integers, so getting back bytes actually requires a separate step, both ensuring some kind of storage location is available in which to write the resulting bytes and then extracting the result to that location. To address all of this, dotnet/runtime#78075 adds to all of the types in new utility methods for producing such numbers. For example, has two new methods added to it:\n\nIf you just want the -based CRC32 hash for some input bytes, you can simply call this one-shot static method . Or if you’re building up the hash incrementally, having created an instance of the type and having appended data to it, you can get the current hash via . This also shaves off a few instructions for an algorithm like which actually needs to do more work to produce the result as bytes, only to then need to get those bytes back as a :\n\nAlso on the hashing front, dotnet/runtime#61558 from @deeprobin adds new methods that allow for iterative crc32c hash computation. A nice aspect of crc32c is that multiple platforms provide instructions for this operation, including SSE 4.2 and Arm, and the .NET method will employ whatever hardware support is available, by delegating into the relevant hardware intrinsics in , e.g.\n\nWe can see the impact those intrinsics have by comparing a manual implementation of the crc32c algorithm against the now built-in implementation:\n\nSeveral releases ago, the C# compiler added a valuable optimization that’s now heavily employed throughout the core libraries, and that newer C# constructs (like ) rely on heavily. It’s quite common to want to store and access sequences or tables of data in code. For example, let’s say I want to quickly look up how many days there are in a month in the Gregorian calendar, based on that month’s 0-based index. I can use a lookup table like this (ignoring leap years for explanatory purposes):\n\nOf course, now I’m allocating a , so I should move that out to a field. Even then, though, that array has to be allocated, and the data loaded into it, incurring some startup overhead the first time it’s used. Instead, I can write it as:\n\nWhile this looks like it’s allocating, it’s actually not. The C# compiler recognizes that all of the data being used to initialize the is constant and that the array is being stored directly into a , which doesn’t provide any means for extracting the array back out. As such, the compiler instead lowers this into code that effectively does this (we can’t exactly express in C# the IL that gets generated, so this is pseudo-code):\n\nIt blits the data for the array into the assembly, and then constructing the span isn’t via an array allocation, but rather just wrapping the span around a pointer directly into the assembly’s data. This not only avoids the startup overhead and the extra object on the heap, it also better enables various JIT optimizations, especially when the JIT is able to see what offset is being accessed. If I run this benchmark:\n\nIn other words, for the array, it’s reading the address of the array and is then reading the element at offset 0x10, or decimal 16, which is where the array’s data begins. For the span, it’s simply loading the value 0x1F, or decimal 31, as it’s directly reading the data from the assembly data. (This isn’t a case of a missing optimization in the JIT for the array example… arrays are mutable, so the JIT can’t constant fold based on the current value stored in the array, since technically it could change.)\n\nHowever, this compiler optimization only applied to , , and . Any other primitive, and the compiler would simply do exactly what you asked it to do: allocate the array. Far from ideal. The reason for the limitation was endianness. The compiler needs to generate binaries that work on both little-endian and big-endian systems; for single-byte types, there’s no endianness concern (since endianness is about the ordering of the bytes, and if there’s only one byte, there’s only one ordering), but for multi-byte types, the generated code could no longer just point directly into the data, as on some systems the data’s bytes would be reversed.\n\n.NET 7 added a new API to help with this, . Rather than just emitting , the idea was that the compiler would emit a call to , passing in a reference to the field containing the data. The JIT and VM would then collude to ensure the data was loaded correctly and efficiently; on a little-endian system, the code would be emitted as if the call weren’t there (replaced by the equivalent of wrapping a span around the pointer and length), and on a big-endian system, the data would be loaded, reversed, and cached into an array, and the code gen would then be creating a span wrapping that array. Unfortunately, although the API shipped in .NET 7, the compiler support for it didn’t, and because no one was then actually using it, there were a variety of issues in the toolchain that went unnoticed.\n\nThankfully, all of these issues are now addressed in .NET 8 and the C# compiler (and also backported to .NET 7). dotnet/roslyn#61414 added support to the C# compiler for also supporting , , , , , , , , , and s based on these. On target frameworks where is available (.NET 7+), the compiler generates code that uses it. On frameworks where the function isn’t available, the compiler falls back to emitting a array to cache the data and wrapping a span around that. This was an important consideration for libraries that build for multiple target frameworks, so that when building “downlevel”, the implementation doesn’t fall off the proverbial performance cliff due to relying on this optimization (this optimization is a bit of an oddity, as you actually need to write your code in a way that, without the optimization, ends up performing worse than what you would have otherwise had). With the compiler implementation in place, and fixes to the Mono runtime in dotnet/runtime#82093 and dotnet/runtime#81695, and with fixes to the trimmer (which needs to preserve the alignment of the data that’s emitted by the compiler) in dotnet/cecil#60, the rest of the runtime was then able to consume the feature, which it did in dotnet/runtime#79461. So now, for example, can use this to store not only how many days there are in a (non-leap) year, but also store how many days there are before a given month, something that wasn’t previously possible efficiently in this form due to there being values larger than can be stored in a .\n\ndotnet/roslyn#69820 (which hasn’t yet merged but should soon) then rounds things out by ensuring that the pattern of initializing a to a new T[] { const of T, const of T, ... /* all const values */ } will always avoid the array allocation, regardless of the type of being used. The need only be expressible as a constant in C#. That means this optimization now also applies to , , , and . For these, the compiler will fallback to using a cached array singleton. With that, this code:\n\nnow compiles down to something like this (again, this is pseudo-code, since we can’t exactly represent in C# what’s emitted in IL):\n\nAnother closely-related C# compiler improvement comes in dotnet/runtime#66251 from @alrz. The previously mentioned optimization around single-byte types also applies to initialization. If I write:\n\nthe C# compiler emits code similar to if I’d written the following:\n\nIf, however, I switch from the multi-byte to the single-byte :\n\nthen I get something closer to this:\n\nUnlike the the case, however, which optimized not only for , , and but also for s with and as an underlying type, the optimization didn’t. Thanks to this PR, it now does.\n\nThere’s another semi-related new feature spanning C# 12 and .NET 8: . has long provided a way to use stack space as a buffer, rather than needing to allocate memory on the heap; however, for most of .NET’s history, this was “unsafe,” in that it produced a pointer:\n\nC# 7.2 introduced the immensely useful improvement to stack allocate directly into a span, at which point it becomes “safe,” not requiring being in an context and with all access to the span bounds checked appropriately, as with any other span:\n\nThe C# compiler will lower that to something along the lines of:\n\nHowever, this is still limited to the kinds of things that can be ‘d, namely types (types which don’t contain any managed references), and it’s limited in where it can be used. That’s not only because can’t be used in places like and blocks, but also because there are places where you want to be able to have such buffers that aren’t limited to the stack: inside of other types. C# has long supported the notion of “fixed-size buffers,” e.g.\n\nbut these require being in an context since they present to a consumer as a pointer (in the above example, the type of is a ) and they’re not bounds-checked, and they’re limited in the element type supported (it can only be , , , , , , , , , , , or ).\n\n.NET 8 and C# 12 provide an answer for this: . This new attribute can be placed onto a containing a single field, like this:\n\nThe runtime then expands that struct to be logically the same as if you wrote:\n\nensuring that all of the storage is appropriately contiguous and aligned. Why is that important? Because C# 12 then makes it easy to get a span from one of these instances, e.g.\n\nThis is all “safe,” and the type of the field can be anything that’s valid as a generic type argument. That means pretty much anything other than s, s, and pointers. This is a constraint imposed by the C# language, since with such a field type you wouldn’t be able to construct a , but the warning can be suppressed, as the runtime itself does support anything as the field type. The compiler-generated code for getting a span is equivalent to if you wrote:\n\nwhich is obviously complicated and not something you’d want to be writing frequently. In fact, the compiler doesn’t want to emit that frequently, either, so it puts it into a helper in the assembly that it can reuse.\n\nThe -attributed type is also a normal like any other, and can be used anywhere any other can be used; that it’s using is effectively an implementation detail. So, for example, you can embed it into another type, and the following code will print out “0” through “7” as you’d expect:\n\ndotnet/runtime#82744 provided the CoreCLR runtime support for , dotnet/runtime#83776 and dotnet/runtime#84097 provided the Mono runtime support, and dotnet/roslyn#68783 merged the C# compiler support.\n\nThis feature isn’t just about you using it directly, either. The compiler itself also uses as an implementation detail behind other new and planned features… we’ll talk more about that when discussing collections.\n\nLastly, even though the runtime and core libraries have made great strides in improving the performance of existing functionality and adding new performance-focused support, sometimes the best fix is actually in the consuming code. That’s where analyzers come in. Several new analyzers have been added in .NET 8 to help find particular classes of string-related performance issues.\n\nCA1858, added in dotnet/roslyn-analyzers#6295 from @Youssef1313, looks for calls to where the result is then being checked for equality with 0. This is functionally the same as a call to , but is much more expensive as it could end up examining the entire source string rather than just the starting position (dotnet/runtime#79896 fixes a few such uses in dotnet/runtime).\n\nCA1865, CA1866, and CA1867 are all related to each other. Added in dotnet/roslyn-analyzers#6799 from @mrahhal, these look for calls to methods like , searching for calls passing in a single-character argument, e.g. , and recommending the argument be converted into a . Which diagnostic ID the analyzer raises depends on whether the transformation is 100% equivalent behavior or whether a change in behavior could potentially result, e.g. switching from a linguistic comparison to an ordinal comparison.\n\nCA1862, added in dotnet/roslyn-analyzers#6662, looks for places where code is performing a case-insensitive comparison (which is fine) but doing so by first lower/uppercasing an input string and then comparing that (which is far from fine). It’s much more efficient to just use a . dotnet/runtime#89539 fixes a few such cases.\n\nAnd CA1861, added in dotnet/roslyn-analyzers#5383 from @steveberdy, looks for opportunities to lift and cache arrays being passed as arguments. dotnet/runtime#86229 addresses the issues found by the analyzer in dotnet/runtime.\n\nCollections are the bread and butter of practically every application and service. Have more than one of something? You need a collection to manage them. And since they’re so commonly needed and used, every release of .NET invests meaningfully in improving their performance and driving down their overheads.\n\nSome of the changes made in .NET 8 are largely collection-agnostic and affect a large number of collections. For example, dotnet/runtime#82499 special-cases “empty” on a bunch of the built-in collection types to return an empty singleton enumerator, thus avoiding allocating a largely useless object. This is wide-reaching, affecting , , , , , , , , , and . Interestingly, was already on this plan (as were a few other collections, like ); if you called on any of length 0, you already got back a singleton enumerator hardcoded to return from its . That same enumerator singleton is what’s now returned from the implementations of all of those cited collection types when they’re empty at the moment is called.\n\nEnumerator allocations are avoided in other contexts, as well. dotnet/runtime#78613 from @madelson avoids an unnecessary enumerator allocation in and , rearranging some code in order to use ‘s struct-based enumerator rather than relying on it being boxed as an . This both saves an allocation and avoids unnecessary interface dispatch.\n\nThere are other places where “empty” has been special-cased. dotnet/runtime#76097 and dotnet/runtime#76764 added an singleton to , , and , and then used that singleton in a bunch of places, multiple of which accrue further to many other places that consume them. For example, now checks whether the array being wrapped is empty, and if it is, returns rather than allocating a new to wrap the empty array (it also makes a similar update to as was discussed with the previous PRs). ‘s and will now return the same singleton if the count is known to be 0. And so on. These kinds of changes reduce the overall “peanut butter” layer of allocation across uses of collections.\n\nOf course, there are many much more targeted and impactful improvements for specific collection types, too.\n\nThe most widely used collection in .NET, other than , is . While that claim feels accurate, I also like to be data-driven, so as one measure, looking at the same NuGet packages we looked at earlier for enums, here’s a graph showing the number of references to the various concrete collection types:\n\nGiven its ubiquity, sees a variety of improvements in .NET 8. dotnet/runtime#76043 improves the performance of its method, in particular when dealing with non- inputs. When adding an , reads the collection’s , ensures the list’s array is large enough to store all the incoming data, and then copies it as efficiently as the source collection can muster by invoking the collection’s method to propagate the data directly into the ‘s backing store. But if the input enumerable isn’t an , has little choice but to enumerate the collection and add each item one at a time. Prior to this release, simply delegated to , which meant that when discovered the source wasn’t an , it would fall back to calling with each item from the enumerable. That method is too large to be inlined by default, plus involves additional checks that aren’t necessary for the usage (e.g. it needs to validate that the supplied position is within the range of the list, but for adding, we’re always just implicitly adding at the end, with a position implicitly known to be valid). This PR rewrote to not just delegate to , at which point when it falls back to enumerating the non- enumerable, it calls the optimized , which is inlineable, and which doesn’t have any extraneous checks.\n\nFor this test, I’ve configured it to run with and without PGO on .NET 8, because this particular test benefits significantly from PGO, and I want to tease those improvements apart from those that come from the cited improvements to . Why does PGO help here? Because the method will see that the type of the enumerable is always the compiler-generated iterator for and will thus generate code specific to that type, enabling the calls that would otherwise involve interface dispatch to instead be devirtualized.\n\nhas improved in other ways, too. One of the long-requested features for , ever since spans were introduced in .NET Core 2.1, was better integration between and . dotnet/runtime#76274 provides that, adding support to both and for data stored in a , and also support for copying all of the data in a to a via a method. It was of course previously possible to achieve this, but doing so required handling one element at a time, which when compared to vectorized copy implementations is significantly slower.\n\nYou may note that these new , , and methods were added as extension methods rather than as instance methods on . That was done for a few reasons, but the primary motivating factor was avoiding ambiguity. Consider this example:\n\nThis will fail to compile with:\n\nbecause an array both implements and has an implicit conversion to , and as such the compiler doesn’t know which to use. It’s likely this ambiguity will be resolved in a future version of the language, but for now we resolved it ourselves by making the span-based overload an extension method:\n\nThe other significant addition for comes in dotnet/runtime#82146 from @MichalPetryka. In .NET 5, the method was added; it returns a for the in-use area of a ‘s backing store. For example, if you write:\n\nthat will provide you with a with length 3, since the list’s is 3. This is very useful for a variety of scenarios, in particular for consuming a ‘s data via span-based APIs. It doesn’t, however, enable scenarios that want to efficiently write to a , in particular where it would require increasing a ‘s count. Let’s say, for example, you wanted to create a new that contained 100 ‘a’ values. You might think you could write:\n\nbut that won’t impact the contents of the created list at all, because the span’s will match the of the list: 0. What we need to be able to do is change the count of the list, effectively telling it “pretend like 100 values were just added to you, even though they weren’t.” This PR adds the new method, which does just that. We can now write the previous example like:\n\nand we will successfully find ourselves with a list containing 100 ‘a’ elements.\n\nThat new method is not only exposed publicly, it’s also used as an implementation detail now in LINQ (Language-Integrated Query), thanks to dotnet/runtime#85288. ‘s method now benefits from this in a variety of places. For example, calling will behave very much like the previous example (albeit with an extra enumerable allocation for the ), creating a new list, using to set its count to 100, getting the backing span, and calling to populate it. The impact of directly writing to the span rather than going through for each item is visible in the following examples:\n\nIn the case of and , the benefit is almost entirely due to writing directly into the span for each element vs the overhead of . In the case of , because the call has direct access to the span, it’s able to use the vectorized method (as it was previously doing just for ), achieving an even larger speedup.\n\nYou’ll note that I didn’t include a test for above. That’s because it was improved in other ways, and I didn’t want to conflate them in the measurements. In particular, dotnet/runtime#87992 from @neon-sunset vectorized the internal method that’s used by the specialization of both and on the iterator returned from . That means that rather than writing one at a time, on a system that supports 128-bit vectors (which is pretty much all hardware you might use today) it’ll instead write four s at a time, and on a system that supports 256-bit vectors, it’ll write eight s at a time. Thus, benefits both from writing directly into the span and from the now vectorized implementation, which means it ends up with similar speedups as above. We can also tease apart these improvements by changing what instruction sets are seen as available.\n\nThese optimized span-based implementations now also accrue to other usage beyond and . If you look at the and implementations in .NET Framework, you’ll see that they’re just normal C# iterators, e.g.\n\nbut years ago, these methods were changed in .NET Core to return a custom iterator (just a normal class implementing where we provide the full implementation rather than the compiler doing so). Once we have a dedicated type, we can add additional interfaces to it, and dotnet/runtime#88249 does exactly that, making these internal , , and several other types implement . That then means that any code which queries an for whether it implements , such as to use its and methods, will light up when passed one of these instances as well. And the same implementation that’s used internally to implement and is then used as well with . That means if you write code like:\n\nand that came from one of these enlightened types, it’ll now benefit from the exact same use of vectorization previously discussed, as the will ensure its array is appropriately sized to handle the incoming data and will then hand its array off to the iterator’s method to write into directly.\n\nVectorization with LINQ was also improved in other ways. In .NET 7, and were taught how to vectorize the handling of some inputs (when the enumerable was actually an array or list of or values), and in .NET 8 dotnet/runtime#76144 expanded that to cover , , , , , , , and as well (it also switched the implementation from using to using both and , so that shorter inputs could still benefit from some level of vectorization).\n\nhas now also been vectorized, for and , thanks to dotnet/runtime#84519 from @brantburnett. in LINQ performs arithmetic, and normal operations are , which makes the vectorization of this method a bit more challenging. To achieve it, it takes advantage of a neat little bit hack trick for determining whether an addition of two signed twos-complement numbers underflow or overflow. The same logic applies for both and here, so we’ll focus just on . It’s impossible for the addition of a negative to overflow when added to a positive , so the only way two summed values can underflow or overflow is if they have the same sign. Further, if any wrapping occurs, it can’t wrap back to the same sign; if you add two positives numbers together and it overflows, the result will be negative, and if you add two negative numbers together and it underflows, the result will be positive. Thus, a function like this can tell us whether the sum wrapped:\n\nWe’re ‘ing the result with each of the inputs, and ‘ing those together. That will produce a number who’s top-most bit is 1 if there was overflow/underflow, and otherwise 0, so we can then mask off all the other bits and compare to 0 to determine whether wrapping occurred. This is useful for vectorization, because we can easily do the same thing with vectors, summing the two vectors and reporting on whether any of the elemental sums overflowed:\n\nWith that, can be vectorized. For sure, it’s not as efficient as if we didn’t need to care about the ; after all, for every addition operation, there’s at least an extra set of instructions for the two s and the ‘ing of them (we can amortize the bit check across several operations by doing some loop unrolling). With 256-bit vectors, an ideal speedup for such a sum operation over values would be 8x, since we can process eight 32-bit values at a time in a 256-bit vector. We’re then doing fairly well that we get a 4x speedup in that situation:\n\nLINQ has improved in .NET 8 beyond just vectorization; other operators have seen other kinds of optimization. Take / , for example. These LINQ operators implement a “stable sort”; that means that while sorting the data, if two items compare equally, they’ll end up in the final result in the same order they were in the original (an “unstable sort” doesn’t care about the ordering of two values that compare equally). The core sorting routine shared by spans, arrays, and lists in .NET (e.g. ) provides an unstable sort, so to use that implementation and provide stable ordering guarantees, LINQ has to layer the stability on top, which it does by factoring into the comparison operation between keys the original location of the key in the input (e.g. if two values otherwise compare equally, then it proceeds to compare their original locations). That, however, means it needs to remember their original locations, which means it needs to allocate a separate for positions. Interestingly, though, sometimes you can’t tell the difference between whether a sort is stable or unstable. dotnet/runtime#76733 takes advantage of the fact that for primitive types like , two values that compare equally with the default comparer are indistinguishable, in which case it’s fine to use an unstable sort because the only values that can compare equally have identical bits and thus trying to maintain an order between them doesn’t matter. It thus enables avoiding all of the overhead associated with maintaining a stable sort.\n\ndotnet/runtime#76418 also improves sorting in LINQ, this time for / , and in particular when the type of the key used (the type returned by the delegate provided to ) is a value type and the default comparer is used. This change employs the same approach that some of the .NET collections like already do, which is to take advantage of the fact that value types when used as generics get a custom copy of the code dedicated to that type (“generic specialization”), and that will get devirtualized and possibly inlined. As such, it adds a dedicated path for when the key is a value type, and that enables the comparison operation (which is invoked times) to be sped up.\n\nOf course, sometimes the most efficient use of LINQ is simply not using it. It’s an amazing productivity tool, and it goes to great lengths to be efficient, but sometimes there are better answers that are just as simple. CA1860, added in dotnet/roslyn-analyzers#6236 from @CollinAlpert, flags one such case. It looks for use of on collections that directly expose a , , or property that could be used instead. While does use in an attempt to check the collection’s number of items without allocating or using an enumerator, even if it’s successful in doing so it incurs the overhead of the interface check and dispatch. It’s faster to just use the properties directly. dotnet/runtime#81583 fixed several cases of this.\n\nIn addition to making existing methods faster, LINQ has also gained some new methods in .NET 8. dotnet/runtime#85811 from @lateapexearlyspeed added new overloads of . Unlike the existing overloads that are extensions on any arbitrary and accept delegates for extracting from each a and/or , these new overloads are extensions on and . This is primarily an addition for convenience, as it means that such an enumerable that previously used code like:\n\ncan instead be simplified to just be:\n\nBeyond being simpler, this has the nice benefit of also being cheaper, as it means the method doesn’t need to invoke two delegates per item. It also means that this new method is a simple passthrough to ‘s constructor, which has its own optimizations that take advantage of knowing about internals, e.g. it can more efficiently copy the source data if it’s a .\n\nIt also benefits from the ‘s constructor being optimized in additional ways. As noted, its constructor accepting an already special-cased when the enumerable is actually a . With dotnet/runtime#86254, it now also special-cases when the enumerable is a or a . When such a source is found, a span is extracted from it (a simple cast for an array, or via for a ), and then that span (rather than the original ) is what’s enumerated. That saves an enumerator allocation and several interface dispatches per item for these reasonably common cases.\n\nThe most common operation performed on a dictionary is looking up a key, whether to see if it exists, to add a value, or to get the current value. Previous .NET releases have seen significant improvements in this lookup time, but even better than optimizing a lookup is not needing to do one at all. One common place we’ve seen unnecessary lookups is with guard clauses that end up being unnecessary, for example code that does:\n\nThis incurs two lookups, one as part of , and then if the key wasn’t in the dictionary, another as part of the call. Code can instead achieve the same operation with:\n\nwhich incurs only one lookup. CA1864, added in dotnet/roslyn-analyzers#6199 from @CollinAlpert, looks for such places where an call is guarded by a call. dotnet/runtime#88700 fixed a few occurrences of this in dotnet/runtime.\n\nSimilarly, dotnet/roslyn-analyzers#6767 from @mpidash added CA1868, which looks for or calls on s where the call is guarded by a , and recommends removing the call. dotnet/runtime#89652 from @mpidash fixes occurrences of this in dotnet/runtime.\n\nOther related analyzers previously released have also been improved. dotnet/roslyn-analyzers#6387 improved CA1854 to find more opportunities for using , with dotnet/runtime#85613 and dotnet/runtime#80996 using the analyzer to find and fix more occurrences.\n\nOther dictionaries have also improved in .NET 8. in particular got a nice boost from dotnet/runtime#81557, for all key types but especially for the very common case where is and the equality comparer is either the default comparer (whether that be , , or , all of which behave identically) or . In .NET Core, hash codes are randomized, meaning there’s a random seed value unique to any given process that’s incorporated into string hash codes. So if, for example, I run the following program:\n\nI get the following output, showing that the hash code for a given string is stable across multiple calls:\n\nbut when I run the program again, I get a different stable value:\n\nThis randomization is done to help mitigate a class of denial-of-service (DoS) attacks involving dictionaries, where an attacker might be able to trigger the worst-case algorithmic complexity of a dictionary by forcing lots of collisions amongst the keys. However, the randomization also incurs some amount of overhead. It’s enough overhead so that actually special-cases keys with a default or comparer to skip the randomization until a sufficient number of collisions has been detected. Now in .NET 8, employs the same trick. When it starts life, a instance using a default or comparer performs hashing using a non-randomized comparer. Then as it’s adding an item and traversing its internal data structure, it keeps track of how many keys it has to examine that had the same hash code. If that count surpasses a threshold, it then switches back to using a randomized comparer, rehashing the whole dictionary in order to mitigate possible attacks.\n\nThe above benchmark also benefited from dotnet/runtime#77005, which tweaked another long-standing optimization in the type. maintains a object for every key/value pair it stores. As multiple threads might be reading from the dictionary concurrent with updates happening, the dictionary needs to be really careful about how it mutates data stored in the collection. If an update is performed that needs to update a in an existing node (e.g. ), the dictionary needs to be very careful to avoid torn reads, such that one thread could be reading the value while another thread is writing the value, leading to the reader seeing part of the old value and part of the new value. It does this by only reusing that same for an update if it can write the atomically. It can write it atomically if the is a reference type, in which case it’s simply writing a pointer-sized reference, or if the is a primitive value that’s defined by the platform to always be written atomically when written with appropriate alignment, e.g. , or when in a 64-bit process. To make this check efficient, computes once whether a given is writable atomically, storing it into a field, such that in tier 1 compilation, the JIT can treat the value as a . However, this trick doesn’t always work. The field was on itself, and if one of those generic type parameters ended up being a reference type (e.g. ), accessing the field would require a generic lookup (the JIT isn’t currently able to see that the value stored in the field is only dependent on the and not on the ). To fix this, the field was moved to a separate type where is the only generic parameter, and a check for (which is itself a JIT intrinsic that manifests as a ) is done separately.\n\n‘s was also improved this release, via dotnet/runtime#82004. Mutation of a requires taking a lock. However, in the case of , we only actually need the lock if it’s possible the item being removed is contained. If the number of items protected by the given lock is 0, we know will be a nop. Thus, this PR added a fast path to that read the count for that lock and immediately bailed if it was 0.\n\nAnother dictionary that’s been improved in .NET 8 is . As background if you haven’t used this type before, is a very specialized dictionary based on ; think of it as every key being a weak reference (so if the GC runs, the key in the dictionary won’t be counted as a strong root that would keep the object alive), and that if the key is collected, the whole entry is removed from the table. It’s particularly useful in situations where additional data needs to be associated with an object but where for whatever reason you’re unable to modify that object to have a reference to the additional data. dotnet/runtime#80059 improves the performance of lookups on a , in particular for objects that aren’t in the collection, and even more specifically for an object that’s never been in any dictionary. Since is about object references, unlike other dictionaries in .NET, it doesn’t use the default to determine whether an object is in the collection; it just uses object reference equality. And that means to get a hash code for an object, it uses the same functionality that the base does. It can’t just call , as the method could have been overridden, so instead it directly calls to the same public that uses:\n\nThis PR tweaks what does here. It introduces a new internal that will avoid creating and storing a hash code for the object if the object doesn’t already have one. It then uses that method from as part of (and , and other related APIs). If returns a value indicating the object doesn’t yet have one, then the operation can early-exit, because for the object to have been stored into the collection, it must have had a hash code generated for it.\n\nSo, improvements to , , … are those the “end all be all” of hash table world? Don’t be silly…\n\nThere are many specialized libraries available on NuGet, providing all manner of data structures with this or that optimization or targeted at this or that scenario. Our goal with the core .NET libraries has never been to provide all possible data structures (it’s actually been a goal not to), but rather to provide the most commonly needed data structures focused on the most commonly needed scenarios, and rely on the ecosystem to provide alternatives where something else is deemed valuable. As a result, we don’t add new collection types all that frequently; we continually optimize the ones that are there and we routinely augment them with additional functionality, but we rarely introduce brand new collection types. In fact, in the last several years, the only new general-purpose collection type introduced into the core libraries was class, which was added in .NET 6. However, enough of a need has presented itself that .NET 8 sees the introduction of not one but two new collection types: and .\n\nBeyond causing “Let It Go” to be stuck in your head for the rest of the day (“you’re welcome”), what benefit do these new types provide, especially when we already have and ? There are enough similarities between the existing immutable collections and the new frozen collections that the latter are actually included in the library, which means they’re also available as part of the NuGet package. But there are also enough differences to warrant us adding them. In particular, this is an example of where scenario and intended use make a big impact on whether a particular data structure makes sense for your needs.\n\nArguably, the existing collections were misnamed. Yes, they’re “immutable,” meaning that once you’ve constructed an instance of one of the collection types, you can’t change its contents. However, that could have easily been achieved simply by wrapping an immutable facade around one of the existing mutable ones, e.g. an immutable dictionary type that just copied the data into a mutable and exposed only reading operations:\n\nYet, if you look at the implementation of , you’ll see a ton of code involved in making the type tick. Why? Because it and its friends are optimized for something very different. In academic nomenclature, the immutable collections are actually “persistent” collections. A persistent data structure is one that provides mutating operations on the collection (e.g. Add, Remove, etc.) but where those operations don’t actually change the existing instance, instead resulting in a new instance being created that contains that modification. So, for example, ironically exposes an method, but this method doesn’t actually modify the collection instance on which it’s called; instead, it creates and returns a brand new instance, containing all of the key/value pairs from the original instance as well as the new key/value pair being added. Now, you could imagine that being done simply by copying all of the data to a new and adding in the new value, e.g.\n\nbut while functional, that’s terribly inefficient from a memory consumption perspective, as every addition results in a brand new copy of all of the data being made, just to store that one additional pair in the new instance. It’s also terribly inefficient from an algorithmic complexity perspective, as adding N values would end up being an algorithm (each new item would result in copying all previous items). As such, is optimized to share as much as possible between instances. Its implementation uses an AVL tree, a self-balancing binary search tree. Adding into such a tree not only requires time (whereas the full copy shown in above is ), it also enables reusing entire portions of a tree between instances of dictionaries. If adding a key/value pair doesn’t require mutating a particular subtree, then both the new and old dictionary instances can point to that same subtree, thereby avoiding significant memory increase. You can see this from a benchmark like the following:\n\nwhich when run on .NET 8 yields the following results for me:\n\nThat highlights that the tree-based nature of makes it significantly more efficient (~120x better in both throughput and allocation in this run) for this example of performing lots of additions, when compared with using for the same purpose a treated as being immutable. And that’s why these immutable collections came into being in the first place. The C# compiler uses lots and lots of dictionaries and sets and the like, and it employs a lot of concurrency. It needs to enable one thread to “tear off” an immutable view of a collection even while other threads are updating the collection, and for such purposes it uses .\n\nHowever, just because the above numbers look amazing doesn’t mean is always the right tool for the immutable job… it actually rarely is. Why? Because the exact thing that made it so fast and memory efficient for the above benchmark is also its downfall on one of the most common tasks needed for an “immutable” dictionary: reading. With its tree-based data structure, not only are adds , but lookups are also , which for a large dictionary can be extremely inefficient when compared to the access times of a type like . We can see this as well with a simple benchmark. Let’s say we’ve built up our 10,000-element dictionary as in the previous example, and now we want to query it:\n\nUh oh. Our in this example is ~12x as expensive for lookups and ~20x as expensive for enumeration as . If your process will be spending most of its time performing reads on the dictionary rather than creating it and/or performing mutation, that’s a lot of cycles being left on the table.\n\nAnd that’s where frozen collections come in. The collections in are immutable, just as are those in , but they’re optimized for a different scenario. Whereas the purpose of a type like is to enable efficient mutation (into a new instance), the purpose of is to represent data that never changes, and thus it doesn’t expose any operations that suggest mutation, only operations for reading. Maybe you’re loading some configuration data into a dictionary once when your process starts (and then re-loading it only rarely when the configuration changes) and then querying that data over and over and over again. Maybe you’re creating a mapping from HTTP status codes to delegates representing how those status codes should be handled. Maybe you’re caching schema information about a set of dynamically-discovered types and then using the resulting parsed information every time you encounter those types later on. Whatever the scenario, you’re creating an immutable collection that you want to be optimized for reads, and you’re willing to spend some more cycles creating the collection (because you do it only once, or only once in a while) in order to make reads as fast as possible. That’s exactly what and provide.\n\nLet’s update our previous example to now also include :\n\nNow we’re talkin’. Whereas for this lookup test was ~9x faster than , was 50% faster than even .\n\nHow does that improvement happen? Just as doesn’t just wrap a , doesn’t just wrap one, either. It has a customized implementation focused on making read operations as fast as possible, both for lookups and for enumerations. In fact, it doesn’t have just one implementation; it has many implementations.\n\nTo start to see that, let’s change the example. In the United States, the Social Security Administration tracks the popularity of baby names. In 2022, the most popular baby names for girls were Olivia, Emma, Charlotte, Amelia, Sophia, Isabella, Ava, Mia, Evelyn, and Luna. Here’s a benchmark that checks to see whether a name is one of those:\n\nSignificantly faster. Internally, can pick an implementation based on the data supplied, both the type of the data and the exact values being used. In this case, if we print out the type of , we see:\n\nThat’s an implementation detail, but what we’re seeing here is that the , even though it’s strongly-typed as , is actually a derived type named . has analyzed the data supplied to it and chosen a strategy that it thinks will yield the best overall throughput. Part of that is just seeing that the type of the data is , in which case all the -based strategies are able to quickly discard queries that can’t possibly match. In this example, the set will have tracked that the longest string in the collection is “Charlotte” at only nine characters long; as such, when it’s asked whether the set contains “Alexandria”, it can immediately answer “no,” because it does a quick length check and sees that “Alexandria” at 10 characters can’t possibly be contained.\n\nLet’s take another example. Internal to the C# compiler, it has the notion of “special types,” and it has a dictionary that maps from a string-based type name to an used to identify that special-type. As a simplified representation of this, I’ve just extracted those strings to create a set:\n\nHere the item we’re searching for is in the collection, so it’s not getting its performance boost from a fast path to fail out of the search. The concrete type of in this case sheds some light on it:\n\nOne of the biggest costs involved in looking up something in a hash table is often the cost of producing the hash in the first place. For a type like , it’s trivial, as it’s literally just its value. But for a type like , the hash is produced by looking at the string’s contents and factoring each character into the resulting value. The more characters need to be considered, the more it costs. In this case, the type has identified that in order to differentiate all of the items in the collection, only a subset of them needs to be hashed, such that it only needs to examine a subset of the incoming string to determine what a possible match might be in the collection.\n\nA bunch of PRs went into making happen in .NET 8. It started as an internal project used by several services at Microsoft, and was then cleaned up and added as part of dotnet/runtime#77799. That provided the core types and initial strategy implementations, with dotnet/runtime#79794 following it to provide additional strategies (although we subsequently backed out a few due to lack of motivating scenarios for what their optimizations were targeting).\n\ndotnet/runtime#81021 then removed some virtual dispatch from the string-based implementations. As noted in the previous example, one approach the strategies take is to try to hash less, so there’s a phase of analysis where the implementation looks at the various substrings in each of the items and determines whether there’s an offset and length for substring that across all of the items provides an ideal differentiation. For example, consider the strings “12a34”, “12b34”, “12c34”; the analyzer would determine that there’s no need to hash the whole string, it need only consider the character at index 2, as that’s enough to uniquely hash the relevant strings. This was initially achieved by using a custom comparer type, but that then meant that virtual dispatch was needed in order to invoke the hashing routine. Instead, this PR created more concrete derived types from / , such that the choice of hashing logic was dictated by the choice of concrete collection type to instantiate, saving on the per-operation dispatch.\n\nIn any good story, there’s a twist, and we encountered a twist with these frozen collection types as well. I’ve already described the scenarios that drove the creation of these types: create once, use a lot. And as such, a lot of attention was paid to overheads involved in reading from the collection, but initially very little time was paid to optimizing construction time. In fact, improving construction time was initially a non-goal, with a willingness to spend as much time as was needed to eke out more throughput for reading. This makes sense if you’re focusing on long-lived services, where you’re happy to spend extra seconds once an hour or day or week to optimize something that will then be used many thousands of times per second. However, the equation changes a bit when types like this are exposed in the core libraries, such that the expected number of developers using them, the use cases they have for them, and the variations of data thrown at them grows by orders of magnitude. We started hearing from developers that they were excited to use / not just because of performance but also because they were truly immutable, both in implementation and in surface area (e.g. no method to confuse things), and that they’d be interested in employing them in object models, UIs, and so on. At that point, you’re no longer in the world of “we can take as much time for construction as we want,” and instead need to be concerned about construction taking inordinate amounts of time and resources.\n\nAs a stop-gap measure, dotnet/runtime#81194 changed the existing / methods to not do any analysis of the incoming data, and instead have both construction time and read throughput in line with that of / . It then added new overloads with a argument, to enable developers to opt-in to those longer construction times in exchange for better read throughput. This wasn’t an ideal solution, as it meant that it took more discovery and more code for a developer to achieve the primary purpose of these types, but it also helped developers avoid pits of failure by using what looked like a harmless method but could result in significant increases in processing time (one degenerate example I created resulted in running literally for minutes).\n\nWe then set about to improve the overall performance of the collections, with a bunch of PRs geared towards driving down the costs:\n• dotnet/runtime#81389 removed various allocations and a dependency from some of the optimizations on the generic math interfaces from .NET 7, such that the optimizations would apply downlevel as well, simplifying the code.\n• dotnet/runtime#81603 moved some code around to reduce how much code was in a generic context. With Native AOT, with type parameters involving value types, every unique set of type parameters used with these collections results in a unique copy of the code being made, and with all of the various strategies around just in case they’re necessary to optimize a given set, there’s potentially a lot of code that gets duplicated. This change was able to shave ~10Kb off each generic instantiation.\n• dotnet/runtime#86293 made a large number of tweaks, including limiting the maximum length substring that would be evaluated as part of determining the optimal hashing length to employ. This significantly reduced the worst-case running time when supplying problematic inputs.\n• dotnet/runtime#84301 added similar early-exit optimizations as were seen earlier with string, but for a host of other types, including all the primitives, , , and such. For these types, when no comparer is provided, we can sort the inputs, quickly check whether a supplied input is greater than anything known to be in the collection, and when dealing with a small number of elements such that we don’t hash at all and instead just do a linear search, we can stop searching once we’ve reached an item in the collection that’s larger than the one being tested (e.g. if the first item in the sorted list is larger than the one being tested, nothing will match). It’s interesting why we don’t just do this for an ; we did, initially, actually, but removed it because of several prominent implementations that didn’t work for this purpose. , for example, implements , but the , , etc. types the wraps may not, and the frozen collections didn’t have a good way to determine the viability of an implementation. Instead, this PR added the optimization back with an allow list, such that all the relevant known good types that could be referenced were special-cased.\n• dotnet/runtime#87510 was the first in a series of PRs to focus significantly on driving down the cost of construction. Its main contribution in this regard was in how collisions are handled. One of the main optimizations employed in the general case by / is to try to drive down the number of collisions in the hash table, since the more collisions there are, the more work will need to be performed during lookups. It does this by populating the table and tracking the number of collisions, and then if there were too many, increasing the size of the table and trying again, repeatedly, until the table has grown large enough that collisions are no longer an issue. This process would hash everything, and then check to make sure it was as good as was desired. This PR changed that to instead bail the moment we knew there were enough collisions that we’d need to retry, rather than waiting until having processed everything.\n• dotnet/runtime#87630, dotnet/runtime#87688, and dotnet/runtime#88093 in particular improve collections keyed by s, by avoiding unnecessary work. For example, as part of determining the ideal table size (to minimize collisions), the implementation generates a set of all unique hash codes, eliminating duplicate hash codes because they’d always collide regardless of the size of the table. But with s, we can skip this step, because s are their own hash codes, and so a set of unique s is guaranteed to be a set of unique hash codes as well. This was then extended to also apply for , / , / , and / (in 32-bit processes), as they all similarly use their own value as the hash code.\n• dotnet/runtime#87876 and dotnet/runtime#87989 improve the “LengthBucket” strategy referenced in the earlier examples. This implementation buckets strings by their length and then does a lookup just within the strings of that length; if there are only a few strings per length, this can make searching very efficient. The initial implementation used an array of arrays, and this PR flattens that into a single array. This makes construction time much faster for this strategy, as there’s significantly less allocation involved.\n• dotnet/runtime#87960 is based on an observation that we would invariably need to resize at least once in order to obtain the desired minimal collision rate, so it simply starts at a higher initial count than was previously being used.\n\nWith all of those optimizations in place, construction time has now improved to the point where it’s no longer a threat, and dotnet/runtime#87988 effectively reverted dotnet/runtime#81194, getting rid of the -based overloads, such that everything is now optimized for reading.\n\nAs an aside, it’s worth noting that for keys in particular, the C# compiler has now also gotten in on the game of better optimizing based on the known characteristics of the data, such that if you know all of your keys at compile-time, and you just need an ordinal, case-sensitive lookup, you might be best off simply writing a statement or expression. This is all thanks to dotnet/roslyn#66081. Let’s take the name popularity example from earlier, and express it as a statement:\n\nPreviously compiling this would result in the C# compiler providing a lowered equivalent to this:\n\nIf you stare at that for a moment, you’ll see the compiler has implemented a binary search tree. It hashes the name, and then having hashed all of the cases at build time, it does a binary search on the hash codes to find the the right case. Now with the recent improvements, it instead generates an equivalent of this:\n\nNow what’s it doing? First, it’s bucketed the strings by their length; any string that comes in that’s not 3, 4, 6, 8, or 9 characters long will be immediately rejected. For 8 and 9 characters, there’s only one possible answer it could be for each, so it simply checks against that string. For the others, it’s recognized that each name in that length begins with a different letter, and switches over that. In this particular example, the first character in each bucket is a perfect differentiator, but if it wasn’t, the compiler will also consider other indices to see if any of those might be better differentiators. This is implementing the same basic strategy as the we saw earlier.\n\nI was careful in my choice above to use a . If I’d instead written the possibly more natural expression:\n\nthen up until recently the compiler wouldn’t even have output the binary search, and would have instead just generated a cascading / as if I’d written:\n\nWith dotnet/roslyn#65874 from @alrz, however, the -based version is now lowered the same as the -based version.\n\nBack to frozen collections. As noted, types are in the library, and they’re not the only improvements to that library. A variety of new APIs have been added to help enable more productive and efficient use of the existing immutable collections…\n\nFor years, developers have found the need to bypass an ‘s immutability. For example, the previously-discussed exposes an for its keys and an for its values. It does this by creating a , which it uses for a variety of purposes while building up the collection, and then it wants to wrap that as an to be exposed for consumption. But with the public APIs available on / , there’s no way to transfer ownership like that; all the APIs that accept an input or allocate a new array and copy all of the data into it, so that the implementation can be sure no one else is still holding onto a reference to the array being wrapped (if someone was, they could use that mutable reference to mutate the contents of the immutable array, and guarding against that is one of the key differentiators between a read-only collection and an immutable collection). Enabling such wrapping of the original array is thus an “unsafe” operation, albeit one that’s valuable to enable for developers willing to accept the responsibility. Previously, developers could achieve this by employing a hack that works but only because of implementation detail: using to cast between the types. When a value type’s first field is a reference type, a reference to the beginning of the struct is also a reference to the reference type, since they’re both at the exact same memory location. Thus, because contains just a single field (for the it wraps), a method like the following will successfully wrap an around a :\n\nThat, however, is both uintuitive and depends on having the array at a 0-offset from the start of the struct, making it a brittle solution. To provide something robust, dotnet/runtime#85526 added the new class, and on it two new methods: and . These methods support casting back and forth between a and an , without allocation. They’re defined in on a class, as that’s one of the ways we have to both hide more dangerous functionality and declare that something is inherently “unsafe” in some capacity.\n\nThere are also new overloads exposed for constructing immutable collections with less allocation. All of the immutable collections have a corresponding static class that provides a method, e.g. has the corresponding static class which provides a method. Now in .NET 8 as of dotnet/runtime#87945, these methods all have a new overload that takes a , e.g. . This means an immutable collection can be created without incurring the allocation required to either go through the associated builder (which is a reference type) or to allocate an array of the exact right size.\n\ndotnet/runtime#81527 from @lateapexearlyspeed added two new methods to , and , which do exactly what their names suggest: returns whether all of the bits in the array are set, and returns whether any of the bits in the array are set. While useful, what I really like about these additions is that they make good use of the method introduced in .NET 8. ‘s storage is an , where each element in the array represents 32 bits (for the purposes of this discussion, I’m ignoring the corner-case it needs to deal with of the last element’s bits not all being used because the count of the collection isn’t a multiple of 32). Determining whether any bits are set is then simply a matter of doing . Similarly, determining whether all bits are set is simply a matter of doing . The bit pattern for is all 1s, so will return true if and only if it finds any integer that doesn’t have all of its bits set; thus if the call doesn’t find any, all bits are set. The net result is gets to maintain simple code that’s also vectorized and optimized, thanks to delegating to these shared helpers. You can see examples of these methods being used in dotnet/runtime#82057, which replaced bespoke implementations of the same functionality with the new built-in helpers.\n\nWith dotnet/roslyn#68831 and then a myriad of subsequent PRs, C# 12 introduces a new terse syntax for constructing collections: “collection expressions.” Let’s say I want to construct a , for example, with the elements 1, 2, and 3. I could do it like so:\n\nor utilizing collection initializers that were added in C# 3:\n\nNow in C# 12, I can write that as:\n\nI can also use “spreads,” where enumerables can be used in the syntax and have all of their contents splat into the collection. For example, instead of:\n\nIf it were just a simpler syntax for collections, it wouldn’t be worth discussing in this particular post. What makes it relevant from a performance perspective, however, is that the C# compiler is free to optimize this however it sees fit, and it goes to great lengths to write the best code it can for the given circumstance; some optimizations are already in the compiler, more will be in place by the time .NET 8 and C# 12 are released, and even more will come later, with the language specified in such a way that gives the compiler the freedom to innovate here. Let’s take a few examples…\n\nthe compiler won’t just translate that into:\n\nAfter all, we have a perfectly good singleton for this in the way of , something the compiler already emits use of for things like , and it can emit the same thing here:\n\nOk, what about the optimizations we previously saw around the compiler lowering the creation of an array involving only constants and storing that directly into a ? Yup, that applies here, too. So, instead of writing:\n\nand the exact same code results.\n\nWhat about ? Earlier in the discussion of collections we saw that now sports an , and the compiler is free to use that. For example, if you write this:\n\nthe compiler could emit the equivalent of this:\n\nOne of my favorite optimizations it achieves, though, is with spans and the use of the attribute we already saw. If you write:\n\nthe compiler can lower that to code along the lines of this:\n\nIn short, this collection expression syntax becomes the way to utilize in the vast majority of situations, allowing the compiler to create a shared definition for you.\n\nThat optimization also feeds into another, which is both an optimization and a functional improvement over what’s in C# 11. Let’s say you have this code… what do you expect it to print?\n\nUnless you’re steeped in and how collection initializers work, you likely didn’t predict the (unfortunate) answer:\n\nis a struct, so this will end up using its default initialization, which contains a array. But even if that was made to work, the C# compiler will have lowered the code I wrote to the equivalent of this:\n\nwhich is “wrong” in multiple ways. doesn’t actually mutate the original collection, but instead returns a new instance that contains the additional element, so when we enumerate , we wouldn’t see any of the additions. Plus, we’re doing all this work and allocation to create the results of , only to drop those results on the floor.\n\nCollection expressions fix this. Now you can write this:\n\nWhy? Because dotnet/runtime#88470 added a new attribute that’s recognized by the C# compiler. That attribute is placed on a type and points to a factory method for creating that type, accepting a and returning the instance constructed from that data. That PR also tagged with this attribute:\n\nsuch that when the compiler sees an being constructed from a collection expression, it runs to use . Not only that, it’s able to use the -based optimization we just talked about for creating that input. As such, the code the compiler generates for this example as of today is equivalent to this:\n\n, , , , and are all similarly attributed such that they all work with collection expressions as well.\n\nOf course, the compiler could actually do a bit better for . As was previously noted, the compiler is free to optimize these how it sees fit, and we already mentioned the new method. As I write this, the compiler doesn’t currently employ that method, but in the future the compiler can special-case , such that it could then generate code equivalent to the following:\n\nsaving on both stack space as well as an extra copy of the data. This is just one of the additional optimizations possible.\n\nIn short, collection expressions are intended to be a great way to express the collection you want built, and the compiler will ensure it’s done efficiently.\n\n.NET 6 overhauled how file I/O is implemented in .NET, rewriting , introducing the class, and a multitude of other changes. .NET 8 continues to improve performance with file I/O further.\n\nOne of the more interesting ways performance of a system can be improved is cancellation. After all, the fastest work is work you don’t have to do at all, and cancellation is about stopping doing unneeded work. The original patterns for asynchrony in .NET were based on a non-cancelable model (see How Async/Await Really Works in C# for an in-depth history and discussion), and over time as all of that support has shifted to the -based model based on , more and more implementations have become fully cancelable as well. As of .NET 7, the vast majority of code paths that accepted a actually respected it, more than just doing an up-front check to see whether cancellation was already requested but then not paying attention to it during the operation. Most of the holdouts have been very corner-case, but there’s one notable exception: s created without .\n\ninherited the bifurcated model of asynchrony from Windows, where at the time you open a file handle you need to specify whether it’s being opened for synchronous or asynchronous (“overlapped”) access. A file handle opened for overlapped access requires that all operations be asynchronous, and vice versa if it’s opened for non-overlapped access requires that all operations be synchronous. That causes some friction with , which exposes both synchronous (e.g. ) and asynchronous (e.g. ) methods, as it means that one set of those needs to emulate the behavior. If the is opened for asynchronous access, then needs to do the operation asynchronously and block waiting for it complete (a pattern we less-than-affectionately refer to as “sync-over-async”), and if the is opened for synchronous access, then needs to queue a work item that will do the operation synchronously (“async-over-sync”). Even though that method accepts a , the actual synchronous that ends up being invoked as part of a work item hasn’t been cancelable. Now in .NET 8, thanks to dotnet/runtime#87103, it is, at least on Windows.\n\nIn .NET 7, was fixed for this same case, relying on an internal helper that would use the Win32 to interrupt pending I/O, while also using appropriate synchronization to ensure that only the intended associated work was interrupted and not work that happened to be running on the same worker thread before or after (Linux already fully supported cancellation as of .NET 5). This PR adapted that same helper to then be usable as well inside of on Windows, in order to gain the same benefits. The same PR also further improved the implementation of that helper to reduce allocation and to further streamline the processing, such that the existing support in gets leaner as well.\n\nInteracting with paths via and has also improved in various ways. dotnet/runtime#74855 improved on Windows both functionally and for performance; in many situations in the past, we’ve made the behavior of .NET on Unix match the behavior of .NET on Windows, but this PR interestingly goes in the other direction. On Unix, uses the libc function, which accepts a template that must end in “XXXXXX” (6 s), and it populates those s with random values, using the resulting name for a new file that gets created. On Windows, was using the Win32 function, which uses a similar pattern but with only 4 s. With the characters Windows will fill in, that enables only 65,536 possible names, and as the temp directory fills up, it becomes more and more likely there will be conflicts, leading to longer and longer times for creating a temp file (it also means that on Windows has been limited to creating 65,536 simultaneously-existing files). This PR changes the format on Windows to match that used on Unix, and avoids the use of , instead doing the random name assignment and retries-on-conflict itself. The net result is more consistency across OSes, a much larger number of temporary files possible (a billion instead of tens of thousands), as well as a better-performing method:\n\nis another on the list of methods that improves, thanks to making use of methods. Here, dotnet/runtime#75318 uses (on Unix, where the only directory separator is ) or (on Windows, where both and can be a directory separator) to search for the beginning of the file name.\n\nRelated to and , various methods on also return paths. had been using to get the system path, but this was leading to noticeable overhead when starting up an ASP.NET application. dotnet/runtime#83564 changed this to use directly, which on Windows takes advantage of the much more efficient path (and resulting in simpler code), but then dotnet/runtime#83593 also fixed on Windows to use , such that its performance accrues to the higher-level uses as well.\n\ndotnet/runtime#73983 improves and , making the property lazy. Previously when constructing the info object if only the full name existed (and not the name of just the directory or file itself), the constructor would promptly create the string, even if the info object is never used (as is often the case when it’s returned from a method like ). Now, that string is lazily created on first use of the property.\n\nhas gotten a whole lot faster on macOS, thanks to dotnet/runtime#79243 from @hamarb123. now employs the OS’s function (if available) to perform the copy, and if both the source and destination are on the same volume, creates a copy-on-write clone of the file in the destination; this makes the copy at the OS level much faster, incurring the majority cost of actually duplicating the data only occurring if one of the files is subsequently written to.\n\nSome more specialized changes have been incorporated as well. is a core abstraction for writing text to an arbitrary destination, but sometimes you want that destination to be nowhere, a la on Linux. For this, provides the property, which returns a instance that nops on all of its members. Or, at least that’s the visible behavior. In practice, only a subset of its members were actually overridden, which meant that although nothing would end up being output, some work might still be incurred and then the fruits of that labor thrown away. dotnet/runtime#83293 ensures that all of the writing methods are overridden in order to do away with all of that wasted work.\n\nFurther, one of the places ends up being used is in , where allows you to replace with your own writer, at which point all of the writing methods on output to that instead. In order to provide thread-safety of writes, synchronizes access to the underlying writer, but if the writer is doing nops anyway, there’s no need for that synchronization. dotnet/runtime#83296 does away with it in that case, such that if you want to temporarily silence , you can simply set its output to go to , and the overhead of operations on will be minimized.\n\nNetworking is the heart and soul of most modern services and applications, which makes it all the more important that .NET’s networking stack shine.\n\nLet’s start at the bottom of the networking stack, looking at some primitives. Most of these improvements are around formatting, parsing, and manipulation as bytes. Take dotnet/runtime#75872, for example, which improved the performance of various such operations on . stores a that’s used as the address when it’s representing an IPv4 address, and it stores a that’s used when it’s representing an IPv6 address. A is two bytes, so a is 16 bytes, or 128 bits. “128 bits” is a very convenient number when performing certain operations, as such a value can be manipulated as a (accelerating computation on systems that accelerate it, which is most). This PR takes advantage of that to optimize common operations with an . The constructor, for example, is handed a for an IPv6 address, which it needs to read into its ; previously that was done with a loop over the input, but now it’s handled with a single vector: load the single vector, possibly reverse the endianness (which can be done in just three instructions: OR together the vector shifted left by one byte and shifted right by one byte), and store it.\n\nnow also implements and , thanks to dotnet/runtime#82913 and dotnet/runtime#84487. That means, for example, that using an as part of string interpolation no longer needs to allocate an intermediate string. As part of this, some changes were made to formatting to streamline it. It’s a bit harder to measure these changes, though, because caches a string it creates, such that subsequent calls just return the previous string created. To work around that, we can use private reflection to null out the field (never do this in a real code; private reflection against the core libraries is very much unsupported).\n\nUnfortunately, such use of reflection has a non-trivial amount of overhead associated with it, which then decreases the perceived benefit from the improvement. Instead, we can use reflection emit either directly or via to emit a custom helper that makes it less expensive to null out that private field.\n\nBut .NET 8 actually includes a feature that streamlines this; the feature’s primary purpose is in support of scenarios like source generators with Native AOT, but it’s useful for this kind of benchmarking, too. The new attribute (introduced in and supported by dotnet/runtime#86932, dotnet/runtime#88626, and dotnet/runtime#88925) lets you define an method that bypasses visibility. In this case, I’ve used it to get a to the private field, at which point I can just assign through the .\n\nis another networking primitive that saw multiple improvements. dotnet/runtime#80469 removed a variety of allocations, primarily around substrings that were instead replaced by spans. dotnet/runtime#90087 replaced unsafe code as part of scheme parsing with safe span-based code, making it both safer and faster. But dotnet/runtime#88012 is more interesting, as it made implement . That means that when, for example, a is used as an argument to an interpolated string, the can now format itself directly to the underlying buffer rather than needing to allocate a temporary string that’s then added in. This can be particularly useful for reducing the costs of logging and other forms of telemetry. It’s a little difficult to isolate just the formatting aspect of a for benchmarking purposes, as caches information gathered in the process, but even with constructing a new one each time you can see gains:\n\nOther networking primitives improved in other ways. dotnet/runtime#82095 reduced the overhead of the methods of several networking types, like . was previously allocating and is now allocation-free. Same for .\n\nAnd improved in dotnet/runtime#78240. This is a quintessential example of code doing its own manual looping looking for something (in this case, the four characters that require encoding) when it could have instead just used a well-placed .\n\nMoving up the stack to , there are some nice improvements in .NET 8 here as well.\n\ndotnet/runtime#86524 and dotnet/runtime#89808 are for Windows only because the problem they address doesn’t manifest on other operatings systems, due to how asynchronous operations are implemented on the various platforms.\n\nOn Unix operatings systems, the typical approach to asynchrony is to put the socket into non-blocking mode. Issuing an operation like ( ) when there’s nothing to receive then fails immediately with an value of or , informing the caller that no data was available to receive yet and it’s not going to wait for said data because it’s been told not to. At that point, the caller can choose how it wants to wait for data to become available. does what many other systems do, which is to use (on Linux) or (on macOS). These mechanisms allow for a single thread to wait efficiently for any number of registered file descriptors to signal that something has changed. As such, has one or more dedicated threads that sit in a wait loop, waiting on the / to signal that there’s something to do, and when there is, queueing off the associated work, and then looping around to wait for the next notification. In the case of a , that queued work will end up reissuing the , which will now succeed as data will be available. The interesting thing here is that during that interim period while waiting for data to become available, there was no pending call from .NET to or anything else that would require a managed buffer (e.g. an array) be available. That’s not the case on Windows…\n\nOn Windows, the OS provides dedicated asynchronous APIs (“overlapped I/O”), with being a thin wrapper around the Win32 function. accepts a pointer to the buffer to write into and a pointer to a callback that will be invoked when the operation has completed. That means that while waiting for data to be available, actually needs a pointer to the buffer it’ll write the data into (unless 0 bytes have been requested, which we’ll talk more about in a bit). In .NET world, buffers are typically on the managed heap, which means they can be moved around by the GC, and thus in order to pass a pointer to such a buffer down to , that buffer needs to be “pinned,” telling the GC “do not move this.” For synchronous operations, such pinning is best accomplished with the C# keyword; for asynchronous operations, or something that wraps it (like and ) are the answers. So, on Windows, uses a for any buffers it supplies to the OS to span an asynchronous operation’s lifetime.\n\nFor the last 20 years, though, it’s been overaggressive in doing so. There’s a buffer passed to various Win32 methods, including ( ), to represent the target IP address. Even though these are asynchronous operations, it turns out that data is only required as part of the synchronous part of the call to these APIs; only a operation (which is typically only used with connectionless protocols, and in particular UDP) that receives not only payload data but also the sender’s address actually needs the address buffer pinned over the lifetime of the operation. was pinning the buffer using a , and in fact doing so for the lifetime of the , even though a wasn’t actually needed at all for these calls, and a would suffice around just the Win32 call itself. The first PR fixed that, the net effect of which is that a that was previously pinning a buffer for the lifetime of every on Windows then only did so for s issuing calls. The second PR then fixed , using a native buffer instead of a managed one that would need to be permanently pinned. The primary benefit of these changes is that it helps to avoid a lot of fragmentation that can result at scale in the managed heap. We can see this most easily by looking at the runtime’s tracing, which I consume in this example via an :\n\nWhen I run this on .NET 7 on Windows, I get this:\n\nWhen I run this on .NET 8, I get this:\n\nI mentioned UDP above, with . We’ve invested a lot over the last several years in making the networking stack in .NET very efficient… for TCP. While most of the improvements there accrue to UDP as well, UDP has additional costs that hadn’t been addressed and that made it suboptimal from a performance perspective. The primary issues there are now addressed in .NET 8, thanks to dotnet/runtime#88970 and dotnet/runtime#90086. The key problem here with the UDP-related APIs, namely and , is that the API is based on but the core implementation is based on . Every call to , for example, would accept the provided and then call to produce a , which internally has its own ; that contains the address actually passed down to the underlying OS APIs. The inverse happens on the side: the received data includes an address that would be deserialized into an which is then returned to the consumer. You can see these allocations show up by profiling a simple repro:\n\nThe .NET allocation profiler in Visual Studio shows this:\n\nSo for each send/receive pair, we see three es which in turn leads to three s, and an which in turn leads to an . These costs are very difficult to address efficiently purely in implementation, as they’re directly related to what’s surfaced in the corresponding APIs. Even so, with the exact same code, it does improve a bit in .NET 8:\n\nSo with zero code changes, we’ve managed to eliminate one of the allocations and its associated , and to shrink the size of the remaining instances (in part due to dotnet/runtime#78860). But, we can do much better…\n\n.NET 8 introduces a new set of overloads. In .NET 7, we had these:\n\nand now in .NET 8 we also have these:\n• The new APIs no longer work in terms of . They now operate on directly. That means the implementation no longer needs to call to produce a and can just use the provided one directly.\n• There’s no more argument in the synchronous and no more in the asynchronous . Both of these existed in order to pass back an that represented the address of the received data’s sender. , however, is just a strongly-typed wrapper around a buffer, which means these methods can just mutate that provided instance, avoiding needing to instantiate anything to represent the received address.\n\nLet’s change our code sample to use these new APIs:\n\nWhen I profile that, and again look for objects created at least once per iteration, I now see this:\n\nThat’s not a mistake; I didn’t accidentally crop the screenshot incorrectly. It’s empty because there are no allocations per iteration; the whole program incurs only three allocations as part of the up-front setup. We can see that more clearly with a standard BenchmarkDotNet repro:\n\nMoving up the stack further, has received some love in this release. While in previous releases work was done to reduce allocation, .NET 8 sees it reduced further:\n• dotnet/runtime#74619 avoids some allocations related to ALPN. Application-Layer Protocol Negotation is a mechanism that allows higher-level protocols to piggyback on the roundtrips already being performed as part of a TLS handshake. It’s used by an HTTP client and server to negotiate which HTTP version to use (e.g. HTTP/2 or HTTP/1.1). Previously, the implementation would end up allocating a for use with this HTTP version selection, but now with this PR, the implementation precomputes s for the most common protocol selections, avoiding the need to re-allocate those s on each new connection.\n• dotnet/runtime#81096 removes a delegate allocation by moving some code around between the main implementation and the Platform Abstraction Layer (PAL) that’s used to handle OS-specific code (everything in the layer is compiled into regardless of OS, and then depending on the target OS, a different version of the class is compiled in).\n• dotnet/runtime#84690 from @am11 avoids a gigantic that was being created to enable querying for information about a particular cipher suite for use with TLS. Instead of a dictionary mapping a enum to a struct (which contained details like an enum value, a enum value, an , etc.), a statement is used, mapping that same enum to an that’s packed with all the same information. This not only avoids the run-time costs associated with allocating that dictionary and populating it, it also shaves almost 20Kb off a published Native AOT binary, due to all of the code that was necessary to populate the dictionary. dotnet/runtime#84921 from @am11 uses a similar for well-known OIDs.\n• dotnet/runtime#86163 changed an internal class into a struct, passing it around by instead.\n• dotnet/runtime#74695 avoids some allocation in interop as part of certificate handling on Linux. s are a valuable reliability feature in .NET: they wrap a native handle / file descriptor, providing the finalizer that ensures the resource isn’t leaked, but also providing ref counting to ensure that the resource isn’t closed while it’s still being used, leading to use-after-free and handle recycling bugs. They’re particularly helpful when a handle or file descriptor needs to be passed around and shared between multiple components, often as part of some larger object model (e.g. a wraps a ). However, in some cases they’re unnecessary overhead. If you have a pattern like: such that the resource is provably used and freed correctly, you can avoid the and instead just use the resource directly: thereby saving on the allocation of a finalizable object (which is more expensive than a normal allocation as synchronization is required to add that object to a finalization queue in the GC) as well as on ref-counting overhead associated with using a in interop.\n\nThis benchmark repeatedly creates new s and performs handshakes:\n\nIt shows an ~13% reduction in overall allocation as part of the lifecycle:\n\nMy favorite improvement in .NET 8, though, is dotnet/runtime#87563, which teaches to do “zero-byte reads” in order to minimize buffer use and pinning. This has been a long time coming, and is the result of multiple users of reporting significant heap fragmentation.\n\nWhen a read is issued to , it in turn needs to issue a read on the underlying ; the data it reads has a header, which gets peeled off, and then the remaining data is decrypted and stored into the user’s buffer. Since there’s manipulation of the data read from the underlying , including not giving all of it to the user, doesn’t just pass the user’s buffer to the underlying , but instead passes its own buffer down. That means it needs a buffer to pass. With performance improvements in recent .NET releases, rents said buffer on demand from the and returns it as soon as that temporary buffer has been drained of all the data read into it. There are two issues with this, though. On Windows, a buffer is being provided to , which needs to pin the buffer in order to give a pointer to that buffer to the Win32 overlapped I/O operation; that pinning means the GC can’t move the buffer on the heap, which can mean gaps end up being left on the heap that aren’t usable (aka “fragmentation”), and that in turn can lead to sporadic out-of-memory conditions. As noted earlier, the implementation on Linux and macOS doesn’t need to do such pinning, however there’s still a problem here. Imagine you have a thousand open connections, or a million open connections, all of which are sitting in a read waiting for data; even if there’s no pinning, if each of those connections has an that’s rented a buffer of any meaningful size, that’s a whole lot of wasted memory just sitting there.\n\nAn answer to this that .NET has been making more and more use of over the last few years is “zero-byte reads.” If you need to read 100 bytes, rather than handing down your 100-byte buffer, at which point it needs to be pinned, you instead issue a read for 0 bytes, handing down an empty buffer, at which point nothing needs to be pinned. When there’s data available, that zero-byte read completes (without consuming anything), and then you issue the actual read for the 100 bytes, which is much more likely to be synchronously satisfiable at that point. As of .NET 6, is already capable of passing along zero-byte reads, e.g. if you do and it doesn’t have any data buffered already, it’ll in turn issue a zero-byte read on the underlying . However, today itself doesn’t create zero-byte reads, e.g. if you do and it doesn’t have enough data buffered, it in turn will issue a non-zero-byte read, and we’re back to pinning per operation at the layer, plus needing a buffer to pass down, which means renting one.\n\ndotnet/runtime#87563 teaches how to create zero-byte reads. Now when you do and the doesn’t have enough data buffered, rather than immediately renting a buffer and passing that down, it instead issues a zero-byte read on the underlying . Only once that operation completes does it then proceed to actually rent a buffer and issue another read, this time with the rented buffer. The primary downside to this is a bit more overhead, in that it can lead to an extra syscall; however, our measurements show that overhead to largely be in the noise, with very meaningful upside in reduced fragmentation, working set reduction, and stability.\n\nThe reduction on Windows is visible with this app, a variation of one showed earlier:\n\nwhereas on .NET 8, I now get:\n\nThe primary consumer of in .NET itself is the HTTP stack, so let’s move up the stack now to , which has seen important gains of its own in .NET 8. As with , there were a bunch of improvements here that all joined to make for a measurable end-to-end improvement (many of the opportunities here were found as part of improving YARP):\n• dotnet/runtime#74393 streamlined how HTTP/1.1 response headers are parsed, including making better use of to speed up searching for various delimiters demarcating portions of the response.\n• dotnet/runtime#79525 and dotnet/runtime#79524 restructured buffer management for reading and writing on HTTP/1.1 connections.\n• dotnet/runtime#81251 reduced the size of by 8 bytes and by 16 bytes (on 64-bit). had a field that was replaced by using a bit from an existing field that wasn’t using all of its bits; as the rest of the message’s fields fit neatly into a multiple of 8 bytes, that extra , even though only a byte in size, required the object to grow by 8 bytes. For , it already had an optimization where some uncommonly used headers were pushed off into a contingently-allocated array; there were additional rarely used fields that made more sense to be contingent.\n• dotnet/runtime#83640 shrunk the size of various strongly typed types. For example, has three public properties , , and , all of which are aka . Each of these properties was backed by a field. Because of packing and alignment, ends up consuming 16 bytes, 8 bytes for the and then 8 bytes for the indicating whether the nullable has a value ( is stored as a single byte, but because of alignment and packing, it’s rounded up to 8). Instead of storing these as , they can just be , using whether they contain a negative value to indicate whether they were initialized, reducing the size of the object from 72 bytes down to 48 bytes. Similar improvements were made to six other such types.\n• dotnet/runtime#81253 tweaked how “Transfer-Encoding: chunked” is stored internally, special-casing it to avoid several allocations.\n• When is in use in order to enable the correlation of tracing information across end-to-end usage, every HTTP request ends up creating a new , which incurs not only the for that ID, but also in the making of it temporary and a temporary array. dotnet/runtime#86685 removes both of those intermediate allocations by making better use of spans.\n• dotnet/runtime#79484 is specific to HTTP/2 and applies to it similar changes to what was discussed for : it now rents buffers from the on demand, returning those buffers when idle, and it issues zero-byte reads to the underlying transport . The net result of these changes is it can reduce the memory usage of an idle HTTP/2 connection by up to 80Kb.\n\nWe can use the following simple GET-request benchmark to how some of these changes accrue to reduced overheads with :\n\nalso sees improvements in .NET 8. With dotnet/runtime#87329, (the implementation that’s used by and that’s returned from ) gets in on the zero-byte reads game. In .NET 7, you could perform a zero-byte on , but doing so would still issue a to the underlying stream with the receive header buffer. That in turn could cause the underlying to rent and/or pin a buffer. By special-casing zero-byte reads now in .NET 8, can take advantage of any special-casing in the base stream, and hopefully make it so that when the actual read is performed, the data necessary to satisfy it synchronously is already available.\n\nAnd with dotnet/runtime#75025, allocation with is reduced. This is a nice example of really needing to pay attention to defaults. has an optimization where it maintains a shared singleton that it reuses between instances. However, it can only reuse them when the settings of the match the settings of that shared singleton; by default is set, and that’s enough to knock it off the path that lets it use the shared handler. This PR adds a second shared singleton for when is set, such that requests using the default proxy can now use a shared handler rather than creating one a new.\n\nA significant focus for in .NET 8 was on improving support for trimming and source-generated implementations, as its usage ends up on critical code paths in a multitude of services and applications, including those that are a primary focus area for Native AOT. Thus, a lot of work went into adding features to the source generator that might otherwise prevent a developer from prefering to use it. dotnet/runtime#79828, for example, added support for and properties in C#, dotnet/runtime#83631 added support for “unspeakable” types (such as the compiler-generated types used to implement iterator methods), and dotnet/runtime#84768 added better support for boxed values. dotnet/runtime#79397 also added support for weakly-typed but trimmer-safe / methods, taking , that make it possible for ASP.NET and other such consumers to cache JSON contract metadata appropriately. All of these improvements are functionally valuable on their own, but also accrue to the overall goals of reducing deployed binary size, improving startup time, and generally being able to be successful with Native AOT and gaining the benefits it brings.\n\nEven with that focus, however, there were still some nice throughput-focused improvements that made their way into .NET 8. In particular, a key improvement in .NET 8 is that the is now able to utilize generated “fast-path” methods even when streaming.\n\nOne of the main things the JSON source generator does is generate at build-time all of the things would otherwise need reflection to access at run-time, e.g. discovering the shape of a type, all of its members, their names, attributes that control their serialization, and so on. With just that, however, the serializer would still be using generic routines to perform operations like serialization, just doing so without needing to use reflection. Instead, the source generator can emit a customized serialization routine specific to the data in question, in order to optimize writing it out. For example, given the following types:\n\nthe source generator will include the following serialization routines in the generated code:\n\nThe serializer can then just invoke these routines to write the data directly to the .\n\nHowever, in the past these routines weren’t used when serializing with one of the streaming routines (e.g. all of the methods), in part because of the complexity of refactoring the implementation to accommodate them, but in larger part out of concern that an individual instance being serialized might need to write more data than should be buffered; these fast paths are synchronous-only today, and so can’t perform asynchronous flushes efficiently. This is particularly unfortunate because these streaming overloads are the primary ones used by ASP.NET, which means ASP.NET wasn’t benefiting from these fast paths. Thanks to dotnet/runtime#78646, in .NET 8 they now do benefit. The PR does the necessary refactoring internally and also puts in place various heuristics to minimize chances of over-buffering. The net result is these existing optimizations now kick in for a much broader array of use cases, including the primary ones higher in the stack, and the wins are significant.\n\nThe fast-path routines are better leveraged in additional scenarios now, as well. Another case where they weren’t used, even when not streaming, was when combining multiple source-generated contexts: if you have your -derived type for your own types to be serialized, and someone passes to you another -derived type for a type they’re giving you to serialize, you need to combine those contexts together into something you can give to . In doing so, however, the fast paths could get lost. dotnet/runtime#80741 adds additional APIs and support to enable the fast paths to still be used.\n\nBeyond , there have been several other performance improvements. In dotnet/runtime#88194, for example, ‘s implementation is streamlined, including avoiding allocating a delegate while setting values into the node, and in dotnet/runtime#85886, is improved via a one-line change that stops unnecessarily calling in order to pass it to a method that accepts a : can and should be used instead, saving on a potentially large array allocation and copy.\n\nLastly on the JSON front, there’s the new CA1869 analyzer added in dotnet/roslyn-analyzers#6850.\n\nThe type looks like something that should be relatively cheap to allocate, just a small options type you could allocate on each call to or with little ramification:\n\nThat’s not the case, however. may need to use reflection to analyze the type being serialized or deserialized in order to learn about its shape and then potentially even use reflection emit to generate custom processing code for using that type. The instance is then used not only as a simple bag for options information, but also as a place to store all of that state the serializer built up, enabling it to be shared from call to call. Prior to .NET 7, this meant that passing a new instance to each call resulted in a massive performance cliff. In .NET 7, the caching scheme was improved to combat the problems here, but even with those mitigations, there’s still significant overhead to using a new instance each time. Instead, a instance should be cached and reused.\n\nCryptography in .NET 8 sees a smattering of improvements, a few large ones and a bunch of smaller ones that contribute to removing some overhead across the system.\n\nOne of the larger improvements, specific to Windows because it’s about switching what functionality is employed from the underlying OS, comes from dotnet/runtime#76277. Windows CNG (“Next Generation”) provides two libraries: and . The former provides support for “ephemeral” operations, ones where the cryptographic key is in-memory only and generated on the fly as part of an operation. The latter supports both ephemeral and persisted-key operations, and as a result much of the .NET support has been based on since it’s more universal. This, however, can add unnecessary expense, as all of the operations are handled out-of-process by the service, and thus require remote procedure calls, which add overhead. This PR switches ephemeral operations over to using instead of , and the results are noteworthy (in the future, we expect other algorithms to also switch).\n\nFor cases where implementations are still using , there are however ways we can still avoid of some of the remote procedure calls. dotnet/runtime#89599 does so by caching some information (in particular the key size) that doesn’t change but that still otherwise results in these remote procedure calls.\n\nThe library provides the support used for encoding various data structures used in cryptographic protocols. For example, is used as part of to create the that’s handed off to the ‘s constructor. As part of this, it relies heavily on OIDs (object identifiers) used to uniquely identify things like specific cryptographic algorithms. dotnet/runtime#75485 imbues and with knowledge of the most-commonly used OIDs, making reading and writing with them significantly faster.\n\nInterestingly, this PR does most of its work in two large switch statements. The first is a nice example of using C# list patterns to over a span of bytes and efficiently match to a case. The second is a great example of the C# compiler optimization mentioned earlier around es and length bucketing. The internal function this adds to do the lookup is based on a giant switch with ~100 cases. The C# compiler ends up generating a over the length of the supplied OID string, and then in each length bucket, it either does a sequential scan through the small number of keys in that bucket, or it does a secondary switch over the character at a specific offset into the input, due to all of the keys having a discriminating character at that position.\n\nAnother interesting change comes in , which is the cryptographically-secure RNG in (as opposed to the non-cryptographically secure ). provides a bytes method, which is the same as but which promises not to yield any 0 values. It does so by using , finding any produced 0s, removing them, and then calling again to replace all of the 0 values (if that call happens to produce any 0s, then the process repeats). The previous implementation of was nicely using the vectorized to search for a 0. Once it found one, however, it would shift down one at a time the rest of the bytes until the next zero. Since we expect 0s to be rare (on average, they should only occur once ever 256 generated bytes), it’s much more efficient to search for the next 0 using a vectorized operation, and then shift everything down using a vectorized memory move operation. And that’s exactly what dotnet/runtime#81340 does.\n\nFinally, a variety of changes went in to reduce allocation:\n• now also has a constructor that lets a caller presize its internal buffer, thanks to dotnet/runtime#73535. That new constructor is then used in dotnet/runtime#81626 to improve throughput on other operations.\n• dotnet/runtime#75138 removes a allocation as part of reading certificates on Linux. Stack allocation and spans are used along with instead of that produces a .\n• ‘s don’t change. The property hands back a array, and out of precaution the property needs to return a new array on each access, however the actual instances are immutable. dotnet/runtime#76156 caches these instances.\n\nLogging, along with telemetry, is the lifeblood of any service. The more logging one incorporates, the more information is available to diagnose issues. But of course the more logging one incorporates, the more resources are possibly spent on logging, and thus it’s desirable for logging-related code to be as efficient as possible.\n\nOne issue that’s plagued some applications is in ‘s method. Some libraries are passed an , call once, and then store and use that logger for all subsequent interactions; in such cases, the overhead of isn’t critical. However, other code paths, including some from ASP.NET, end up needing to “create” a logger on demand each time it needs to log. That puts significant stress on , incurring its overhead as part of every logging operation. To reduce these overheads, has long maintained a cache of all logger instances it’s created: pass in the same , get back the same instance (hence why I put “create” in quotes a few sentences back). However, that cache is also protected by a lock. That not only means every call is incurring the overhead of acquiring and releasing a lock, but if that lock is contended (meaning others are trying to access it at the same time), that contention can dramatically increase the costs associated with the cache. This is the perfect use case for a , which is optimized with lock-free support for reads, and that’s exactly how dotnet/runtime#87904 improves performance here. We still want to perform some work atomically when there’s a cache miss, so the change uses “double-checked locking”: it performs a read on the dictionary, and only if the lookup fails does it then fall back to taking the lock, after which it checks the dictionary again, and only if that second read fails does it proceed to create the new logger and store it. The primary benefit of here is it enables us to have that up-front read, which might execute concurrently with another thread mutating the dictionary; that’s not safe with but is with . This measurably lowers the cost of even uncontended access, but dramatically reduces the overhead when there’s significant contention.\n\nAlso related to , there’s a extension method and a extension method, both of which infer the category to use from specified type, using its pretty-printed name. Previously that pretty-printing involved always allocating both a to build up the name and the resulting . However, those are only necessary for more complex types, e.g. generic types, array types, and generic type parameters. For the common case, dotnet/runtime#79325 from @benaadams avoids those overheads, which were incurred even when the request for the logger could be satisfied from the cache, because the name was necessary to even perform the cache lookup.\n\nThere are also changes in .NET 8 to reduce overheads when logging actually does occur, and one such change makes use of a new .NET 8 feature we’ve already talked about: . isn’t currently used in many places throughout the core libraries, as most of the formatting they do is either with strings known at build time (in which case they use interpolated strings) or are on exceptional code paths (in which case we generally don’t want to regress working set or startup in order to optimize error conditions). However, there is one key place is now used: in . This method is similar in concept to : rather than having to redo work every time you want to log something, instead spend some more resources to frontload and cache that work, in order to optimize subsequent usage… that’s what does, just for logging. returns a strongly-typed delegate that can then be used any time logging should be performed. As of the same PR that introduced , now also constructs a under the covers, and uses that instance to perform any formatting work necessary based on the log message pattern provided (previously it would just call as part of every log operation that needed it).\n\nis used as part of the logging source generator, so the benefits there implicitly accrue not only to direct usage of but also to any use of the generator. We can see that in this benchmark here:\n\nNote the method, which is declared as a method with the attribute applied to it. The generator will see that and inject into my application the following implementation (the only changes I’ve made to this copied code are removing the fully-qualified names, for readability), which as is visible here uses :\n\nWhen running the benchmark, then, we can see the improvements that use end up translating nicely:\n\nOther changes have also gone into reducing overheads in logging. Here’s the same benchmark as before, but I’ve tweaked two things:\n• I’ve added so that allocation is more visible.\n• I’ve explicitly controlled which NuGet package version is used for which run.\n\nThe package carries with it multiple “assets”; the v7.0.0 package, even though it’s “7.0.0,” carries with it a build for net7.0, for net6.0, for netstandard2.0, etc. Similarly, the v8.0.0 package, even though it’s “8.0.0,” carries with it a build for net8.0, for net7.0, and so on. Each of those is created from compiling the source for that Target Framework Moniker (TFM). Changes that are specific to a particular TFM, such as the change to use , are only compiled into that build, but other improvements that aren’t specific to a particular TFM end up in all of them. As such, to be able to see improvements that have gone into the general code in the last year, we need to actually compare the two different NuGet packages, and can’t just compare the net8.0 vs net7.0 assets in the same package version.\n\nNotice that throughput has increased and allocation has dropped. That’s primarily due to dotnet/runtime#88560, which avoids boxing value type arguments as they’re being passed through the formatting logic.\n\ndotnet/runtime#89160 is another interesting example, not because it’s a significant savings (it ends up saving an allocation per HTTP request made using an created from an ), but because of why the allocation is there in the first place. Consider this C# class:\n\nWe’ve got a method that contains a local function that “closes over” ‘s argument. How does find its way into that ? Let’s look at a decompiled version of the IL the compiler generates:\n\nSo, the compiler has emitted the as a static method, and it’s passed the state it needs by reference, with all of the state in a separate type (which the compiler refers to as a “display class”). Note that a) the instance of this type is constructed in in order to store the argument, and that all references to , whether in or in , are to the shared on the display class, and b) that “class” is actually declared as a . That means we’re not going to incur any allocation as part of that data sharing. But now, let’s add a single keyword to our repro: add to (I’ve elided some irrelevant code here for clarity):\n\nThe code for looks almost the same, but there’s a key difference: instead of , it has . That’s because the display class now actually is a rather than being a , and that’s because the state can no longer live on the stack; it’s being passed to an asynchronous method, which may need to continue to use it even after the stack has unwound. And that means it becomes more important avoiding these kinds of implicit closures when dealing with local functions that are asynchronous.\n\nIn this particular case, (and ) had a method that looked like this:\n\nBased on the previous discussion, you likely see the problem here: is being implicitly closed over by the local function, resulting in this allocating a display class to pass that state in. The cited PR changed the code to instead be:\n\nand, voila, the allocation is gone.\n\nis another logging mechanism in .NET that’s lower-level and which is used by the core libraries for their logging needs. The runtime itself publishes its events for things like the GC and the JIT via an , something I relied on earlier in this post when tracking how many s were created (search above for ). When eventing is enabled for a particular source, that publishes a manifest describing the possible events and the shape of the data associated with each. While in the future, we aim to use a source generator to create that manifest at build time, today it’s all generated at run-time, using reflection to analyze the events defined on the -derived type and to dynamically build up the description. That unfortunately has some cost, which can measurably impact startup. Thankfully, one of the main contributors here is the manifest for that runtime source, , as it’s ever present, but it’s not actually necessary, since tools that consume this information already know about the well-documented schema. As such, dotnet/runtime#78213 stopped emitting the manifest for such that it doesn’t send a large amount of data across to the consumer that will subsequently ignore it. That prevented it from being sent, but it was still being created. dotnet/runtime#86850 from @n77y addressed a large chunk of that by reducing the costs of that generation. The effect of this is obvious if we do a .NET allocation profile of a simple nop console application.\n\nOn .NET 7, we observe this: And on .NET 8, that reduces to this: (In the future, hopefully this whole thing will go away due to precomputing the manifest.)\n\nalso relies heavily on interop, and as part of that it’s historically used delegate marshaling as part of implementing callbacks from native code. dotnet/runtime#79970 switches it over to using function pointers, which is not only more efficient, it eliminates this as one of the last uses of delegate marshaling in the core libraries. That means for Native AOT, all of the code associated with supporting delegate marshaling can typically now be trimmed away, reducing application size further.\n\nConfiguration support is critical for many services and applications, such that information necessary to the execution of the code can be extracted from the code, whether that be into a JSON file, environment variables, Azure Key Vault, wherever. This information then needs to be loaded into the application in a convenient manner, typically at startup but also potentially any time the configuration is seen to change. It’s thus not a typical candidate for throughput-focused optimization, but it is still valuable to drive associated costs down, especially to help with startup performance.\n\nWith , configuration is handled primarily with a , an , and a “binder.” Using a , you add in the various sources of your configuration information (e.g. , , etc.), and then you publish that as an instance. In typical use, you then extract from that the data you want by “binding” it to an object, meaning a method populates the provided object with data from the configuration based on the shape of the object. Let’s measure the cost of that specifically:\n\nMuch of that cost in .NET 7 comes from what I alluded to earlier when I said “based on the shape of the object.” That call is using this extension method defined in the type:\n\nHow does it know what data to extract from the configuration and where on the to store it? Reflection, of course. That means that every call is using reflection to walk the supplied ‘s type information, and is using reflection to store the configuration data onto the instance. That’s not cheap.\n\nWhat changes then in .NET 8? The mention of “EnableConfigurationBindingGenerator” in the benchmark code above probably gives it away, but the answer is there’s a new source generator for configuration in .NET 8. This source generator was initially introduced in dotnet/runtime#82179 and was then improved upon in a multitude of PRs like dotnet/runtime#84154, dotnet/runtime#86076, dotnet/runtime#86285, and dotnet/runtime#86365. The crux of the idea behind the configuration source generator is to emit a replacement for that method, one that knows exactly what type is being populated and can do all the examination of its shape at build-time rather than at run-time via reflection.\n\n“Replacement.” For anyone familiar with C# source generators, this might be setting off alarm bells in your head. Source generators plug into the compiler and are handed all the data the compiler has about the code being compiled; the source generator is then able to augment that data, generating additional code into separate files that the compiler then also compiles into the same assembly. Source generators are able to add code but they can’t rewrite the code. This is why you see source generators like the source generator or the source generator or the source generator relying on partial methods: the developer writes the partial method declaration for the method they then consume in their code, and then separately the generator emits a partial method definition to supply the implementation for that method. How then is this new configuration generator able to replace a call to an existing method? I’m glad you asked! It takes advantage of a new preview feature of the C# compiler, added primarily in dotnet/roslyn#68564: interceptors.\n\nConsider this program, defined in a file (and where the associated .csproj contains to enable the preview feature):\n\nThis is a “hello world” application, except not quite the one-liner you’re used to. There’s a call to , but there’s also a method decorated with . That method has the same signature as the being used, and the attribute is pointing to the method call in ‘s line 5 column 9. When the compiler sees this, it will change that call from to instead be , allowing this other method in the same compilation unit to intercept the original call. This interceptor needn’t be in the same file, so a source generator can analyze the code handed to it, find a call it wants to intercept, and augment the compilation unit with such an interceptor.\n\nThat’s exactly what the configuration source generator does. In this benchmark, for example, the core of what the source generator emits is here (I’ve elided stuff that’s not relevant to this discussion):\n\nWe can see the generated method is strongly typed for my type, and the generated method it invokes extracts the value from the and stores it directly into the property. No reflection anywhere in sight.\n\nThis is obviously great for throughput, but that actually wasn’t the primary goal for this particular source generator. Rather, it was in support of Native AOT and trimming. Without direct use of various portions of the object model for the bound object, the trimmer could see portions of it as being unused and trim them away (such as setters for properties that are only read by the application), at which point that data would not be available (because the deserializer would see the properties as being get-only). By having everything strongly typed in the generated source, that issue goes away. And as a bonus, if there isn’t other use of the reflection stack keeping it rooted, the trimmer can get rid of that, too.\n\nisn’t the only method that’s replaceable. provides other methods consumers can use, like , which just retrieves the value associated with a specific key, and the configuration source generator can emit replacements for those as well. dotnet/runtime#87935 modified to employ the config generator for this purpose, as it uses in its method:\n\nAnd if we look at what’s in the compiled binary (via ILSpy), we see this:\n\nSo, the code looks the same, but the actual target of the is the intercepting method emitted by the source generator. When that change merged, it knocked ~640Kb off the size of the ASP.NET app being used as an exemplar to track Native AOT app size!\n\nOnce data has been loaded from the configuration system into some kind of model, often the next step is to validate that the supplied data meets requirements. Whether a data model is populated once from configuration or per request for user input, a typical approach for achieving such validation is via the namespace. This namespace supplies attributes that can be applied to members of a type to indicate constraints the data must satisfy, such as to indicate the data must be supplied or to indicate a minimum length for a string, and .NET 8 adds additional attributes via dotnet/runtime#82311, for example . On top of this, provides an implementation of the interface (an implementation of which is typically retrieved via DI) for validating models based on data annotations, and as you can probably guess, it does so via reflection. As is a trend you’re probably picking up on, for many such areas involving reflection, .NET has been moving to add source generators that can do at build-time what would have otherwise been done at run-time; that’s the case here as well. As of dotnet/runtime#87587, the package in .NET 8 now includes a source generator that creates an implementation of for a specific type.\n\nFor example, consider this benchmark:\n\nNote the at the end. It’s applied to a class that implements , which tells the source generator to emit the implementation for this interface in order to validate . It ends up emitting code like this (which I’ve simplified a tad, e.g. removing fully-qualified namespaces, for the purposes of this post):\n\neliminating the need to use reflection to discover the relevant properties and their attribution. The benchmark results highlight the benefits:\n\nIn every .NET release, there are a multitude of welcome PRs that make small improvements. These changes on their own typically don’t “move the needle,” don’t on their own make very measurable end-to-end changes. However, an allocation removed here, an unnecessary bounds check removed there, it all adds up. Constantly working to remove this “peanut butter,” as we often refer to it (a thin smearing of overhead across everything), helps improve the performance of the platform in the aggregate.\n\nHere are some examples from the last year:\n• dotnet/runtime#77832. The type provides a convenient method that gives you all the stream’s data as a new . But while convenient, it’s a potentially large allocation and copy. The lesser known and methods give one access to the ‘s buffer directly, without incurring an allocation or copy. This PR replaced use of in and in that were better served by . Not only did it remove unnecessary allocation, as a bonus it also resulted in less code.\n• dotnet/runtime#80523 and dotnet/runtime#80389 removed string allocations from the library. was making two calls to to remove and characters, but it was then looping over every character in the input… rather than creating new strings without those characters, the loop can simply skip over them. Similarly, contained 6 calls, all of which could be replaced with simple slices.\n• dotnet/runtime#82041, dotnet/runtime#87479, and dotnet/runtime#80386 changed several hundred lines across dotnet/runtime to avoid various array and allocation. In some cases it used , in others , in others simply deleting arrays that were never used, in others using and slicing.\n• dotnet/runtime#82411 from @xtqqczze and dotnet/runtime#82456 from @xtqqczze do a similar optimization to one discussed previously in the context of . Here, they’re removing allocations in places where a simple / with the raw for the handle suffices.\n• dotnet/runtime#82096 and dotnet/runtime#83138 decreased some costs by using newer constructs: string interpolation instead of concatenation so as to avoid some intermediary string allocations, and instead of to avoid the transcoding overhead.\n• dotnet/runtime#75850 removed some allocations as part of initializing a . The dictionary in gets populated with a fixed set of predetermined items, and as such it’s provided with a capacity so as to presize its internal arrays to avoid intermediate allocations as part of growing. However, the provided capacity was smaller than the number of items actually being added. This PR simply fixed the number, and voila, less allocation.\n• dotnet/runtime#81036 from @xtqqczze and dotnet/runtime#81039 from @xtqqczze helped eliminate some bounds checking in various components across the core libraries. Today the JIT compiler recognizes the pattern , understanding that the can’t ever be negative nor greater than the ‘s length, and thus eliminates the bounds check it would have otherwise emitted on . However, the compiler doesn’t currently recognize the same thing for . These PRs primarily replaced s with s in order to help in some such cases (it also makes the code more idiomatic, and so was welcomed even in cases where it wasn’t actually helping with bounds checks).\n• dotnet/runtime#89030 fixed a case where a was being used as a set. Changing it to instead be saves on the internal storage for the values that end up being identical to the keys.\n• dotnet/runtime#78741 replaces a bunch of with and with pointer manipulation. Most of these are with managed s, such that it used to not be possible to do. However, as of C# 11, more of these operations are possible, with conditions that were previously always errors now being downgraded to warnings (which can then be suppressed) in an context. Such replacements generally won’t improve throughput, but they do make the binaries a bit smaller and require less work for the JIT, which can in turn help with startup time. dotnet/runtime#78914 takes advantage of this as well, this time to be able to pass a span as input to a call.\n• dotnet/runtime#78737 from @Poppyto and dotnet/runtime#79345 from @Poppyto remove some allocations from by replacing some code that was using to build up a result and then it at the end to get back a . In the majority case, we know the exact required size ahead of time, and can avoid the extra allocations and copy by just using an array from the get-go.\n• dotnet/runtime#82598 from @huoyaoyuan also tweaked , taking advantage of a Win32 function that was added after the original code was written, in order to reduce the number of system calls required to delete a subtree.\n• Multiple changes went into and to streamline away peanut butter related to strings and arrays. dotnet/runtime#75452 from @TrayanZapryanov replaces multiple calls with span trimming and slicing, taking advantage of the C# language’s recently added support for using over . dotnet/runtime#75946 removes some use of (these days, there’s almost always a better alternative than ), while dotnet/runtime#82006 replaces some with spans and . dotnet/runtime#85534 removed an unnecessary dictionary lookup, replacing a use of followed by the indexer with just . dotnet/runtime#84888 from @mla-alm removed some synchronous I/O from the asynchronous code paths in . dotnet/runtime#74955 from @TrayanZapryanov deleted the internal helper that was comparing the two inputs character by character with just using and . dotnet/runtime#75812 from @jlennox replaced some manual UTF8 encoding with . dotnet/runtime#76436 from @TrayanZapryanov removed intermediate allocation when writing primitive types as part of XML serialization. And dotnet/runtime#73336 from @Daniel-Svensson and dotnet/runtime#71478 from @Daniel-Svensson improved by using for UTF8 encoding and by doing more efficient writing using spans.\n• dotnet/runtime#87905 makes a tiny tweak to the , but one that can lead to very measurable gains. The instance returned from currently is a multi-layered cache. The first layer is in thread-local storage. If renting can’t be satisfied by that layer, it falls through to the next layer, where there’s a “partition” per array size per core (by default). Each partition is an array of arrays. By default, this could store 8 arrays. Now with this PR, it can store 32 arrays, decreasing the chances that code will need to spend additional cycles searching other partitions. With dotnet/runtime#86109, that 32 value can also be changed, by setting the environment variable to the desired maximum capacity. The environment variable can also be used to control how many partitions are employed.\n\nWhew! That was… a lot! So, what’s next?\n\nThe .NET 8 Release Candidate is now available, and I encourage you to download it and take it for a spin. As you can likely sense from my enthusiasm throughout this post, I’m thrilled about the potential .NET 8 has to improve your system’s performance just by upgrading, and I’m thrilled about new features .NET 8 offers to help you tweak your code to be even more efficient. We’re eager to hear from you about your experiences in doing so, and if you find something that can be improved even further, we’d love for you to make it better by contributing to the various .NET repos, whether it be issues with your thoughts or PRs with your coded improvements. Your efforts will benefit not only you but every other .NET developer around the world!\n\nThanks for reading, and happy coding!"
    }
]