[
    {
        "link": "https://digitalocean.com/community/tutorials/spring-aop-example-tutorial-aspect-advice-pointcut-joinpoint-annotations",
        "document": "Spring Framework is developed on two core concepts - Dependency Injection and Aspect Oriented Programming ( Spring AOP).\n\nWe have already seen how Spring Dependency Injection works, today we will look into the core concepts of Aspect-Oriented Programming and how we can implement it using Spring Framework.\n\nMost of the enterprise applications have some common crosscutting concerns that are applicable to different types of Objects and modules. Some of the common crosscutting concerns are logging, transaction management, data validation, etc. In Object Oriented Programming, modularity of application is achieved by Classes whereas in Aspect Oriented Programming application modularity is achieved by Aspects and they are configured to cut across different classes. Spring AOP takes out the direct dependency of crosscutting tasks from classes that we can’t achieve through normal object oriented programming model. For example, we can have a separate class for logging but again the functional classes will have to call these methods to achieve logging across the application.\n\nBefore we dive into the implementation of Spring AOP implementation, we should understand the core concepts of AOP.\n• Aspect: An aspect is a class that implements enterprise application concerns that cut across multiple classes, such as transaction management. Aspects can be a normal class configured through Spring XML configuration or we can use Spring AspectJ integration to define a class as Aspect using annotation.\n• Join Point: A join point is a specific point in the application such as method execution, exception handling, changing object variable values, etc. In Spring AOP a join point is always the execution of a method.\n• Advice: Advices are actions taken for a particular join point. In terms of programming, they are methods that get executed when a certain join point with matching pointcut is reached in the application. You can think of Advices as Struts2 interceptors or Servlet Filters.\n• Pointcut: Pointcut is expressions that are matched with join points to determine whether advice needs to be executed or not. Pointcut uses different kinds of expressions that are matched with the join points and Spring framework uses the AspectJ pointcut expression language.\n• Target Object: They are the object on which advices are applied. Spring AOP is implemented using runtime proxies so this object is always a proxied object. What is means is that a subclass is created at runtime where the target method is overridden and advice are included based on their configuration.\n• AOP proxy: Spring AOP implementation uses JDK dynamic proxy to create the Proxy classes with target classes and advice invocations, these are called AOP proxy classes. We can also use CGLIB proxy by adding it as the dependency in the Spring AOP project.\n• Weaving: It is the process of linking aspects with other objects to create the advised proxy objects. This can be done at compile time, load time or at runtime. Spring AOP performs weaving at the runtime.\n\nBased on the execution strategy of advice, they are of the following types.\n• Before Advice: These advices runs before the execution of join point methods. We can use annotation to mark an advice type as Before advice.\n• After (finally) Advice: An advice that gets executed after the join point method finishes executing, whether normally or by throwing an exception. We can create after advice using annotation.\n• After Returning Advice: Sometimes we want advice methods to execute only if the join point method executes normally. We can use annotation to mark a method as after returning advice.\n• After Throwing Advice: This advice gets executed only when join point method throws exception, we can use it to rollback the transaction declaratively. We use annotation for this type of advice.\n• Around Advice: This is the most important and powerful advice. This advice surrounds the join point method and we can also choose whether to execute the join point method or not. We can write advice code that gets executed before and after the execution of the join point method. It is the responsibility of around advice to invoke the join point method and return values if the method is returning something. We use annotation to create around advice methods.\n\nThe points mentioned above may sound confusing but when we will look at the implementation of Spring AOP, things will be more clear. Let’s start creating a simple Spring project with AOP implementations. Spring provides support for using AspectJ annotations to create aspects and we will be using that for simplicity. All the above AOP annotations are defined in package. Spring Tool Suite provides useful information about the aspects, so I would suggest you use it. If you are not familiar with STS, I would recommend you to have a look at Spring MVC Tutorial where I have explained how to use it.\n\nCreate a new Simple Spring Maven project so that all the Spring Core libraries are included in the pom.xml files and we don’t need to include them explicitly. Our final project will look like the below image, we will look into the Spring core components and Aspect implementations in detail.\n\nSpring framework provides AOP support by default but since we are using AspectJ annotations for configuring aspects and advice, we would need to include them in the pom.xml file.\n\nNotice that I have added and dependencies (version 1.7.4) in the project. Also I have updated the Spring framework version to be the latest one as of date i.e 4.0.2.RELEASE.\n\nLet’s create a simple java bean that we will use for our example with some additional methods. Employee.java code:\n\nDid you noticed that setName() method is annotated with annotation. It is a custom java annotation defined by us in the project. We will look into it’s usage later on.\n\nLet’s create a service class to work with the Employee bean. EmployeeService.java code:\n\nI could have used Spring annotations to configure it as a Spring Component, but we will use XML based configuration in this project. EmployeeService class is very standard and just provides us an access point for Employee beans.\n\nIf you are using STS, you have the option to create “Spring Bean Configuration File” and chose AOP schema namespace but if you are using some other IDE, you can simply add it in the spring bean configuration file. My project bean configuration file looks like below. spring.xml:\n\nFor using Spring AOP in Spring beans, we need to do the following:\n• Add aop:aspectj-autoproxy element to enable Spring AspectJ support with auto proxy at runtime\n\nYou can see that I have a lot of aspects defined in the spring bean configuration file, it’s time to look into them one by one.\n\nImportant points in above aspect class are:\n• Aspect classes are required to have annotation.\n• @Before annotation is used to create Before advice\n• The string parameter passed in the annotation is the Pointcut expression\n• getNameAdvice() advice will execute for any Spring Bean method with signature . This is a very important point to remember, if we will create Employee bean using new operator the advices will not be applied. Only when we will use ApplicationContext to get the bean, advices will be applied.\n• We can use asterisk (*) as wild card in Pointcut expressions, getAllAdvice() will be applied for all the classes in package whose name starts with and doesn’t take any arguments.\n\nWe will look at the advice in action in a test class after we have looked into all the different types of advices.\n\nSometimes we have to use same Pointcut expression at multiple places, we can create an empty method with annotation and then use it as an expression in the advices. EmployeeAspectPointcut.java code:\n\nAbove example is very clear, rather than expression we are using method name in the advice annotation argument.\n\nWe can use JoinPoint as a parameter in the advice methods and using it get the method signature or the target object. We can use expression in the pointcut to be applied to any method that matches the argument pattern. If we use this, then we need to use the same name in the advice method from where the argument type is determined. We can use Generic objects also in the advice arguments. EmployeeAspectJoinPoint.java code:\n\nLet’s look at a simple aspect class with an example of After, After Throwing and After Returning advice. EmployeeAfterAspect.java code:\n\nWe can use in pointcut expression to apply the advice to all the methods in the class. We can use @AfterReturning advice to get the object returned by the advised method. We have throwException() method in the Employee bean to showcase the use of After Throwing advice.\n\nAs explained earlier, we can use Around aspect to cut the method execution before and after. We can use it to control whether the advised method will execute or not. We can also inspect the returned value and change it. This is the most powerful advice and needs to be applied properly. EmployeeAroundAspect.java code:\n\nAround advice are always required to have ProceedingJoinPoint as an argument and we should use it’s proceed() method to invoke the target object advised method. If advised method is returning something, it’s advice responsibility to return it to the caller program. For void methods, advice method can return null. Since around advice cut around the advised method, we can control the input and output of the method as well as it’s execution behavior.\n\nIf you look at all the above advice pointcut expressions, there are chances that they get applied to some other beans where it’s not intended. For example, someone can define a new spring bean with getName() method and the advice will start getting applied to that even though it was not intended. That’s why we should keep the scope of pointcut expression as narrow as possible. An alternative approach is to create a custom annotation and annotate the methods where we want the advice to be applied. This is the purpose of having Employee setName() method annotated with @Loggable annotation. Spring Framework @Transactional annotation is a great example of this approach for Spring Transaction Management. Loggable.java code:\n\nThe myAdvice() method will advice only setName() method. This is a very safe approach and whenever we want to apply the advice on any method, all we need is to annotate it with Loggable annotation.\n\nI always prefer annotation but we also have the option to configure aspects in the spring configuration file. For example, let’s say we have a class as below. EmployeeXMLConfigAspect.java code:\n\nWe can configure it by including the following configuration in the Spring Bean config file.\n\nAOP xml config elements purpose is clear from their name, so I won’t go into much detail about it.\n\nLet’s have a simple Spring program and see how all these aspects cut through the bean methods. SpringMain.java code:\n\nNow when we execute the above program, we get the following output.\n\nYou can see that advices are getting executed one by one based on their pointcut configurations. You should configure them one by one to avoid confusion. That’s all for Spring AOP Example Tutorial, I hope you learned the basics of AOP with Spring and can learn more from examples. Download the sample project from below link and play around with it."
    },
    {
        "link": "https://docs.spring.io/spring-framework/docs/4.3.15.RELEASE/spring-framework-reference/html/aop.html",
        "document": "Aspect-Oriented Programming (AOP) complements Object-Oriented Programming (OOP) by providing another way of thinking about program structure. The key unit of modularity in OOP is the class, whereas in AOP the unit of modularity is the aspect. Aspects enable the modularization of concerns such as transaction management that cut across multiple types and objects. (Such concerns are often termed crosscutting concerns in AOP literature.) One of the key components of Spring is the AOP framework. While the Spring IoC container does not depend on AOP, meaning you do not need to use AOP if you don’t want to, AOP complements Spring IoC to provide a very capable middleware solution. Spring 2.0 introduces a simpler and more powerful way of writing custom aspects using either a schema-based approach or the @AspectJ annotation style. Both of these styles offer fully typed advice and use of the AspectJ pointcut language, while still using Spring AOP for weaving. The Spring 2.0 schema- and @AspectJ-based AOP support is discussed in this chapter. Spring 2.0 AOP remains fully backwards compatible with Spring 1.2 AOP, and the lower-level AOP support offered by the Spring 1.2 APIs is discussed in the following chapter. AOP is used in the Spring Framework to…​\n• …​ provide declarative enterprise services, especially as a replacement for EJB declarative services. The most important such service is .\n• …​ allow users to implement custom aspects, complementing their use of OOP with AOP. If you are interested only in generic declarative services or other pre-packaged declarative middleware services such as pooling, you do not need to work directly with Spring AOP, and can skip most of this chapter. Let us begin by defining some central AOP concepts and terminology. These terms are not Spring-specific…​ unfortunately, AOP terminology is not particularly intuitive; however, it would be even more confusing if Spring used its own terminology.\n• : a modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting concern in enterprise Java applications. In Spring AOP, aspects are implemented using regular classes (the schema-based approach) or regular classes annotated with the annotation (the style).\n• : a point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point represents a method execution.\n• : action taken by an aspect at a particular join point. Different types of advice include \"around,\" \"before\" and \"after\" advice. (Advice types are discussed below.) Many AOP frameworks, including Spring, model an advice as an , maintaining a chain of interceptors the join point.\n• : a predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.\n• : declaring additional methods or fields on behalf of a type. Spring AOP allows you to introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)\n• : object being advised by one or more aspects. Also referred to as the object. Since Spring AOP is implemented using runtime proxies, this object will always be a object.\n• : an object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy will be a JDK dynamic proxy or a CGLIB proxy.\n• : linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.\n• : Advice that executes before a join point, but which does not have the ability to prevent execution flow proceeding to the join point (unless it throws an exception).\n• : Advice to be executed after a join point completes normally: for example, if a method returns without throwing an exception.\n• : Advice to be executed if a method exits by throwing an exception.\n• : Advice to be executed regardless of the means by which a join point exits (normal or exceptional return).\n• : Advice that surrounds a join point such as a method invocation. This is the most powerful kind of advice. Around advice can perform custom behavior before and after the method invocation. It is also responsible for choosing whether to proceed to the join point or to shortcut the advised method execution by returning its own return value or throwing an exception. Around advice is the most general kind of advice. Since Spring AOP, like AspectJ, provides a full range of advice types, we recommend that you use the least powerful advice type that can implement the required behavior. For example, if you need only to update a cache with the return value of a method, you are better off implementing an after returning advice than an around advice, although an around advice can accomplish the same thing. Using the most specific advice type provides a simpler programming model with less potential for errors. For example, you do not need to invoke the method on the used for around advice, and hence cannot fail to invoke it. In Spring 2.0, all advice parameters are statically typed, so that you work with advice parameters of the appropriate type (the type of the return value from a method execution for example) rather than arrays. The concept of join points, matched by pointcuts, is the key to AOP which distinguishes it from older technologies offering only interception. Pointcuts enable advice to be targeted independently of the Object-Oriented hierarchy. For example, an around advice providing declarative transaction management can be applied to a set of methods spanning multiple objects (such as all business operations in the service layer). Spring AOP is implemented in pure Java. There is no need for a special compilation process. Spring AOP does not need to control the class loader hierarchy, and is thus suitable for use in a Servlet container or application server. Spring AOP currently supports only method execution join points (advising the execution of methods on Spring beans). Field interception is not implemented, although support for field interception could be added without breaking the core Spring AOP APIs. If you need to advise field access and update join points, consider a language such as AspectJ. Spring AOP’s approach to AOP differs from that of most other AOP frameworks. The aim is not to provide the most complete AOP implementation (although Spring AOP is quite capable); it is rather to provide a close integration between AOP implementation and Spring IoC to help solve common problems in enterprise applications. Thus, for example, the Spring Framework’s AOP functionality is normally used in conjunction with the Spring IoC container. Aspects are configured using normal bean definition syntax (although this allows powerful \"autoproxying\" capabilities): this is a crucial difference from other AOP implementations. There are some things you cannot do easily or efficiently with Spring AOP, such as advise very fine-grained objects (such as domain objects typically): AspectJ is the best choice in such cases. However, our experience is that Spring AOP provides an excellent solution to most problems in enterprise Java applications that are amenable to AOP. Spring AOP will never strive to compete with AspectJ to provide a comprehensive AOP solution. We believe that both proxy-based frameworks like Spring AOP and full-blown frameworks such as AspectJ are valuable, and that they are complementary, rather than in competition. Spring seamlessly integrates Spring AOP and IoC with AspectJ, to enable all uses of AOP to be catered for within a consistent Spring-based application architecture. This integration does not affect the Spring AOP API or the AOP Alliance API: Spring AOP remains backward-compatible. See the following chapter for a discussion of the Spring AOP APIs. One of the central tenets of the Spring Framework is that of non-invasiveness; this is the idea that you should not be forced to introduce framework-specific classes and interfaces into your business/domain model. However, in some places the Spring Framework does give you the option to introduce Spring Framework-specific dependencies into your codebase: the rationale in giving you such options is because in certain scenarios it might be just plain easier to read or code some specific piece of functionality in such a way. The Spring Framework (almost) always offers you the choice though: you have the freedom to make an informed decision as to which option best suits your particular use case or scenario. One such choice that is relevant to this chapter is that of which AOP framework (and which AOP style) to choose. You have the choice of AspectJ and/or Spring AOP, and you also have the choice of either the @AspectJ annotation-style approach or the Spring XML configuration-style approach. The fact that this chapter chooses to introduce the @AspectJ-style approach first should not be taken as an indication that the Spring team favors the @AspectJ annotation-style approach over the Spring XML configuration-style. See Section 11.4, “Choosing which AOP declaration style to use” for a more complete discussion of the whys and wherefores of each style. Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied. Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than interfaces. CGLIB is used by default if a business object does not implement an interface. As it is good practice to program to interfaces rather than classes; business classes normally will implement one or more business interfaces. It is possible to force the use of CGLIB, in those (hopefully rare) cases where you need to advise a method that is not declared on an interface, or where you need to pass a proxied object to a method as a concrete type. It is important to grasp the fact that Spring AOP is proxy-based. See Section 11.6.1, “Understanding AOP proxies” for a thorough examination of exactly what this implementation detail actually means.\n\n@AspectJ refers to a style of declaring aspects as regular Java classes annotated with annotations. The @AspectJ style was introduced by the AspectJ project as part of the AspectJ 5 release. Spring interprets the same annotations as AspectJ 5, using a library supplied by AspectJ for pointcut parsing and matching. The AOP runtime is still pure Spring AOP though, and there is no dependency on the AspectJ compiler or weaver. Using the AspectJ compiler and weaver enables use of the full AspectJ language, and is discussed in Section 11.8, “Using AspectJ with Spring applications”. To use @AspectJ aspects in a Spring configuration you need to enable Spring support for configuring Spring AOP based on @AspectJ aspects, and autoproxying beans based on whether or not they are advised by those aspects. By autoproxying we mean that if Spring determines that a bean is advised by one or more aspects, it will automatically generate a proxy for that bean to intercept method invocations and ensure that advice is executed as needed. The @AspectJ support can be enabled with XML or Java style configuration. In either case you will also need to ensure that AspectJ’s library is on the classpath of your application (version 1.6.8 or later). This library is available in the directory of an AspectJ distribution or via the Maven Central repository. To enable @AspectJ support with Java add the annotation: To enable @AspectJ support with XML based configuration use the element: This assumes that you are using schema support as described in Chapter 41, XML Schema-based configuration. See Section 41.2.7, “the aop schema” for how to import the tags in the namespace. With the @AspectJ support enabled, any bean defined in your application context with a class that is an @AspectJ aspect (has the annotation) will be automatically detected by Spring and used to configure Spring AOP. The following example shows the minimal definition required for a not-very-useful aspect: A regular bean definition in the application context, pointing to a bean class that has the annotation: And the class definition, annotated with annotation; Aspects (classes annotated with ) may have methods and fields just like any other class. They may also contain pointcut, advice, and introduction (inter-type) declarations. You may register aspect classes as regular beans in your Spring XML configuration, or autodetect them through classpath scanning - just like any other Spring-managed bean. However, note that the @Aspect annotation is not sufficient for autodetection in the classpath: For that purpose, you need to add a separate @Component annotation (or alternatively a custom stereotype annotation that qualifies, as per the rules of Spring’s component scanner). In Spring AOP, it is not possible to have aspects themselves be the target of advice from other aspects. The @Aspect annotation on a class marks it as an aspect, and hence excludes it from auto-proxying. Recall that pointcuts determine join points of interest, and thus enable us to control when advice executes. Spring AOP only supports method execution join points for Spring beans, so you can think of a pointcut as matching the execution of methods on Spring beans. A pointcut declaration has two parts: a signature comprising a name and any parameters, and a pointcut expression that determines exactly which method executions we are interested in. In the @AspectJ annotation-style of AOP, a pointcut signature is provided by a regular method definition, and the pointcut expression is indicated using the annotation (the method serving as the pointcut signature must have a return type). An example will help make this distinction between a pointcut signature and a pointcut expression clear. The following example defines a pointcut named that will match the execution of any method named : The pointcut expression that forms the value of the annotation is a regular AspectJ 5 pointcut expression. For a full discussion of AspectJ’s pointcut language, see the AspectJ Programming Guide (and for extensions, the AspectJ 5 Developers Notebook) or one of the books on AspectJ such as \"Eclipse AspectJ\" by Colyer et. al. or \"AspectJ in Action\" by Ramnivas Laddad. Spring AOP supports the following AspectJ pointcut designators (PCD) for use in pointcut expressions: The full AspectJ pointcut language supports additional pointcut designators that are not supported in Spring. These are: call, get, set, preinitialization, staticinitialization, initialization, handler, adviceexecution, withincode, cflow, cflowbelow, if, @this , and . Use of these pointcut designators in pointcut expressions interpreted by Spring AOP will result in an being thrown. The set of pointcut designators supported by Spring AOP may be extended in future releases to support more of the AspectJ pointcut designators.\n• - for matching method execution join points, this is the primary pointcut designator you will use when working with Spring AOP\n• - limits matching to join points within certain types (simply the execution of a method declared within a matching type when using Spring AOP)\n• - limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type\n• - limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type\n• - limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types\n• - limits matching to join points (the execution of methods when using Spring AOP) where the class of the executing object has an annotation of the given type\n• - limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given type(s)\n• - limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP)\n• - limits matching to join points where the subject of the join point (method being executed in Spring AOP) has the given annotation Because Spring AOP limits matching to only method execution join points, the discussion of the pointcut designators above gives a narrower definition than you will find in the AspectJ programming guide. In addition, AspectJ itself has type-based semantics and at an execution join point both and refer to the same object - the object executing the method. Spring AOP is a proxy-based system and differentiates between the proxy object itself (bound to ) and the target object behind the proxy (bound to ). Due to the proxy-based nature of Spring’s AOP framework, calls within the target object are by definition not intercepted. For JDK proxies, only public interface method calls on the proxy can be intercepted. With CGLIB, public and protected method calls on the proxy will be intercepted, and even package-visible methods if necessary. However, common interactions through proxies should always be designed through public signatures. Note that pointcut definitions are generally matched against any intercepted method. If a pointcut is strictly meant to be public-only, even in a CGLIB proxy scenario with potential non-public interactions through proxies, it needs to be defined accordingly. If your interception needs include method calls or even constructors within the target class, consider the use of Spring-driven native AspectJ weaving instead of Spring’s proxy-based AOP framework. This constitutes a different mode of AOP usage with different characteristics, so be sure to make yourself familiar with weaving first before making a decision. Spring AOP also supports an additional PCD named . This PCD allows you to limit the matching of join points to a particular named Spring bean, or to a set of named Spring beans (when using wildcards). The PCD has the following form: The token can be the name of any Spring bean: limited wildcard support using the character is provided, so if you establish some naming conventions for your Spring beans you can quite easily write a PCD expression to pick them out. As is the case with other pointcut designators, the PCD can be &&'ed, ||'ed, and ! (negated) too. Please note that the PCD is only supported in Spring AOP - and not in native AspectJ weaving. It is a Spring-specific extension to the standard PCDs that AspectJ defines and therefore not available for aspects declared in the model. The PCD operates at the instance level (building on the Spring bean name concept) rather than at the type level only (which is what weaving-based AOP is limited to). Instance-based pointcut designators are a special capability of Spring’s proxy-based AOP framework and its close integration with the Spring bean factory, where it is natural and straightforward to identify specific beans by name. Pointcut expressions can be combined using '&&', '||' and '!'. It is also possible to refer to pointcut expressions by name. The following example shows three pointcut expressions: (which matches if a method execution join point represents the execution of any public method); (which matches if a method execution is in the trading module), and (which matches if a method execution represents any public method in the trading module). It is a best practice to build more complex pointcut expressions out of smaller named components as shown above. When referring to pointcuts by name, normal Java visibility rules apply (you can see private pointcuts in the same type, protected pointcuts in the hierarchy, public pointcuts anywhere and so on). Visibility does not affect pointcut matching. When working with enterprise applications, you often want to refer to modules of the application and particular sets of operations from within several aspects. We recommend defining a \"SystemArchitecture\" aspect that captures common pointcut expressions for this purpose. A typical such aspect would look as follows: com.xyz.someapp; org.aspectj.lang.annotation.Aspect; org.aspectj.lang.annotation.Pointcut; SystemArchitecture { /** * A join point is in the web layer if the method is defined * in a type in the com.xyz.someapp.web package or any sub-package * under that. */ inWebLayer() {} /** * A join point is in the service layer if the method is defined * in a type in the com.xyz.someapp.service package or any sub-package * under that. */ inServiceLayer() {} /** * A join point is in the data access layer if the method is defined * in a type in the com.xyz.someapp.dao package or any sub-package * under that. */ inDataAccessLayer() {} /** * A business service is the execution of any method defined on a service * interface. This definition assumes that interfaces are placed in the * \"service\" package, and that implementation types are in sub-packages. * * If you group service interfaces by functional area (for example, * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then * the pointcut expression \"execution(* com.xyz.someapp..service.*.*(..))\" * could be used instead. * * Alternatively, you can write the expression using the 'bean' * PCD, like so \"bean(*Service)\". (This assumes that you have * named your Spring service beans in a consistent fashion.) */ businessService() {} /** * A data access operation is the execution of any method defined on a * dao interface. This definition assumes that interfaces are placed in the * \"dao\" package, and that implementation types are in sub-packages. */ dataAccessOperation() {} } The pointcuts defined in such an aspect can be referred to anywhere that you need a pointcut expression. For example, to make the service layer transactional, you could write: The and elements are discussed in Section 11.3, “Schema-based AOP support”. The transaction elements are discussed in Chapter 17, Transaction Management. Spring AOP users are likely to use the pointcut designator the most often. The format of an execution expression is: All parts except the returning type pattern (ret-type-pattern in the snippet above), name pattern, and parameters pattern are optional. The returning type pattern determines what the return type of the method must be in order for a join point to be matched. Most frequently you will use as the returning type pattern, which matches any return type. A fully-qualified type name will match only when the method returns the given type. The name pattern matches the method name. You can use the wildcard as all or part of a name pattern. If specifying a declaring type pattern then include a trailing to join it to the name pattern component. The parameters pattern is slightly more complex: matches a method that takes no parameters, whereas matches any number of parameters (zero or more). The pattern matches a method taking one parameter of any type, matches a method taking two parameters, the first can be of any type, the second must be a String. Consult the Language Semantics section of the AspectJ Programming Guide for more information. Some examples of common pointcut expressions are given below.\n• the execution of any public method:\n• the execution of any method with a name beginning with \"set\":\n• the execution of any method defined by the interface:\n• the execution of any method defined in the service package:\n• the execution of any method defined in the service package or a sub-package:\n• any join point (method execution only in Spring AOP) within the service package:\n• any join point (method execution only in Spring AOP) within the service package or a sub-package:\n• any join point (method execution only in Spring AOP) where the proxy implements the interface: 'this' is more commonly used in a binding form :- see the following section on advice for how to make the proxy object available in the advice body.\n• any join point (method execution only in Spring AOP) where the target object implements the interface: 'target' is more commonly used in a binding form :- see the following section on advice for how to make the target object available in the advice body.\n• any join point (method execution only in Spring AOP) which takes a single parameter, and where the argument passed at runtime is : 'args' is more commonly used in a binding form :- see the following section on advice for how to make the method arguments available in the advice body. Note that the pointcut given in this example is different to : the args version matches if the argument passed at runtime is Serializable, the execution version matches if the method signature declares a single parameter of type .\n• any join point (method execution only in Spring AOP) where the target object has an annotation: '@target' can also be used in a binding form :- see the following section on advice for how to make the annotation object available in the advice body.\n• any join point (method execution only in Spring AOP) where the declared type of the target object has an annotation: '@within' can also be used in a binding form :- see the following section on advice for how to make the annotation object available in the advice body.\n• any join point (method execution only in Spring AOP) where the executing method has an annotation: '@annotation' can also be used in a binding form :- see the following section on advice for how to make the annotation object available in the advice body.\n• any join point (method execution only in Spring AOP) which takes a single parameter, and where the runtime type of the argument passed has the annotation: '@args' can also be used in a binding form :- see the following section on advice for how to make the annotation object(s) available in the advice body.\n• any join point (method execution only in Spring AOP) on a Spring bean named :\n• any join point (method execution only in Spring AOP) on Spring beans having names that match the wildcard expression : During compilation, AspectJ processes pointcuts in order to try and optimize matching performance. Examining code and determining if each join point matches (statically or dynamically) a given pointcut is a costly process. (A dynamic match means the match cannot be fully determined from static analysis and a test will be placed in the code to determine if there is an actual match when the code is running). On first encountering a pointcut declaration, AspectJ will rewrite it into an optimal form for the matching process. What does this mean? Basically pointcuts are rewritten in DNF (Disjunctive Normal Form) and the components of the pointcut are sorted such that those components that are cheaper to evaluate are checked first. This means you do not have to worry about understanding the performance of various pointcut designators and may supply them in any order in a pointcut declaration. However, AspectJ can only work with what it is told, and for optimal performance of matching you should think about what they are trying to achieve and narrow the search space for matches as much as possible in the definition. The existing designators naturally fall into one of three groups: kinded, scoping and context:\n• Kinded designators are those which select a particular kind of join point. For example: execution, get, set, call, handler\n• Scoping designators are those which select a group of join points of interest (of probably many kinds). For example: within, withincode\n• Contextual designators are those that match (and optionally bind) based on context. For example: this, target, @annotation A well written pointcut should try and include at least the first two types (kinded and scoping), whilst the contextual designators may be included if wishing to match based on join point context, or bind that context for use in the advice. Supplying either just a kinded designator or just a contextual designator will work but could affect weaving performance (time and memory used) due to all the extra processing and analysis. Scoping designators are very fast to match and their usage means AspectJ can very quickly dismiss groups of join points that should not be further processed - that is why a good pointcut should always include one if possible. Advice is associated with a pointcut expression, and runs before, after, or around method executions matched by the pointcut. The pointcut expression may be either a simple reference to a named pointcut, or a pointcut expression declared in place. Before advice is declared in an aspect using the annotation: If using an in-place pointcut expression we could rewrite the above example as: After returning advice runs when a matched method execution returns normally. It is declared using the annotation: Note: it is of course possible to have multiple advice declarations, and other members as well, all inside the same aspect. We’re just showing a single advice declaration in these examples to focus on the issue under discussion at the time. Sometimes you need access in the advice body to the actual value that was returned. You can use the form of that binds the return value for this: The name used in the attribute must correspond to the name of a parameter in the advice method. When a method execution returns, the return value will be passed to the advice method as the corresponding argument value. A clause also restricts matching to only those method executions that return a value of the specified type ( in this case, which will match any return value). Please note that it is not possible to return a totally different reference when using after-returning advice. After throwing advice runs when a matched method execution exits by throwing an exception. It is declared using the annotation: Often you want the advice to run only when exceptions of a given type are thrown, and you also often need access to the thrown exception in the advice body. Use the attribute to both restrict matching (if desired, use as the exception type otherwise) and bind the thrown exception to an advice parameter. The name used in the attribute must correspond to the name of a parameter in the advice method. When a method execution exits by throwing an exception, the exception will be passed to the advice method as the corresponding argument value. A clause also restricts matching to only those method executions that throw an exception of the specified type ( in this case). After (finally) advice runs however a matched method execution exits. It is declared using the annotation. After advice must be prepared to handle both normal and exception return conditions. It is typically used for releasing resources, etc. The final kind of advice is around advice. Around advice runs \"around\" a matched method execution. It has the opportunity to do work both before and after the method executes, and to determine when, how, and even if, the method actually gets to execute at all. Around advice is often used if you need to share state before and after a method execution in a thread-safe manner (starting and stopping a timer for example). Always use the least powerful form of advice that meets your requirements (i.e. don’t use around advice if simple before advice would do). Around advice is declared using the annotation. The first parameter of the advice method must be of type . Within the body of the advice, calling on the causes the underlying method to execute. The method may also be called passing in an - the values in the array will be used as the arguments to the method execution when it proceeds. The behavior of proceed when called with an Object[] is a little different than the behavior of proceed for around advice compiled by the AspectJ compiler. For around advice written using the traditional AspectJ language, the number of arguments passed to proceed must match the number of arguments passed to the around advice (not the number of arguments taken by the underlying join point), and the value passed to proceed in a given argument position supplants the original value at the join point for the entity the value was bound to (Don’t worry if this doesn’t make sense right now!). The approach taken by Spring is simpler and a better match to its proxy-based, execution only semantics. You only need to be aware of this difference if you are compiling @AspectJ aspects written for Spring and using proceed with arguments with the AspectJ compiler and weaver. There is a way to write such aspects that is 100% compatible across both Spring AOP and AspectJ, and this is discussed in the following section on advice parameters. The value returned by the around advice will be the return value seen by the caller of the method. A simple caching aspect for example could return a value from a cache if it has one, and invoke proceed() if it does not. Note that proceed may be invoked once, many times, or not at all within the body of the around advice, all of these are quite legal. Spring offers fully typed advice - meaning that you declare the parameters you need in the advice signature (as we saw for the returning and throwing examples above) rather than work with arrays all the time. We’ll see how to make argument and other contextual values available to the advice body in a moment. First let’s take a look at how to write generic advice that can find out about the method the advice is currently advising. Any advice method may declare as its first parameter, a parameter of type (please note that around advice is required to declare a first parameter of type , which is a subclass of . The interface provides a number of useful methods such as (returns the method arguments), (returns the proxy object), (returns the target object), (returns a description of the method that is being advised) and (prints a useful description of the method being advised). Please do consult the javadocs for full details. We’ve already seen how to bind the returned value or exception value (using after returning and after throwing advice). To make argument values available to the advice body, you can use the binding form of . If a parameter name is used in place of a type name in an args expression, then the value of the corresponding argument will be passed as the parameter value when the advice is invoked. An example should make this clearer. Suppose you want to advise the execution of dao operations that take an Account object as the first parameter, and you need access to the account in the advice body. You could write the following: The part of the pointcut expression serves two purposes: firstly, it restricts matching to only those method executions where the method takes at least one parameter, and the argument passed to that parameter is an instance of ; secondly, it makes the actual object available to the advice via the parameter. Another way of writing this is to declare a pointcut that \"provides\" the object value when it matches a join point, and then just refer to the named pointcut from the advice. This would look as follows: The interested reader is once more referred to the AspectJ programming guide for more details. The proxy object ( ), target object ( ), and annotations ( ) can all be bound in a similar fashion. The following example shows how you could match the execution of methods annotated with an annotation, and extract the audit code. First the definition of the annotation: And then the advice that matches the execution of methods: Spring AOP can handle generics used in class declarations and method parameters. Suppose you have a generic type like this: You can restrict interception of method types to certain parameter types by simply typing the advice parameter to the parameter type you want to intercept the method for: That this works is pretty obvious as we already discussed above. However, it’s worth pointing out that this won’t work for generic collections. So you cannot define a pointcut like this: To make this work we would have to inspect every element of the collection, which is not reasonable as we also cannot decide how to treat values in general. To achieve something similar to this you have to type the parameter to and manually check the type of the elements. The parameter binding in advice invocations relies on matching names used in pointcut expressions to declared parameter names in (advice and pointcut) method signatures. Parameter names are not available through Java reflection, so Spring AOP uses the following strategies to determine parameter names:\n• If the parameter names have been specified by the user explicitly, then the specified parameter names are used: both the advice and the pointcut annotations have an optional \"argNames\" attribute which can be used to specify the argument names of the annotated method - these argument names available at runtime. For example: If the first parameter is of the , , or type, you may leave out the name of the parameter from the value of the \"argNames\" attribute. For example, if you modify the preceding advice to receive the join point object, the \"argNames\" attribute need not include it: The special treatment given to the first parameter of the , , and types is particularly convenient for advice that do not collect any other join point context. In such situations, you may simply omit the \"argNames\" attribute. For example, the following advice need not declare the \"argNames\" attribute:\n• Using the attribute is a little clumsy, so if the attribute has not been specified, then Spring AOP will look at the debug information for the class and try to determine the parameter names from the local variable table. This information will be present as long as the classes have been compiled with debug information ( at a minimum). The consequences of compiling with this flag on are: (1) your code will be slightly easier to understand (reverse engineer), (2) the class file sizes will be very slightly bigger (typically inconsequential), (3) the optimization to remove unused local variables will not be applied by your compiler. In other words, you should encounter no difficulties building with this flag on. If an @AspectJ aspect has been compiled by the AspectJ compiler (ajc) even without the debug information then there is no need to add the argNames attribute as the compiler will retain the needed information.\n• If the code has been compiled without the necessary debug information, then Spring AOP will attempt to deduce the pairing of binding variables to parameters (for example, if only one variable is bound in the pointcut expression, and the advice method only takes one parameter, the pairing is obvious!). If the binding of variables is ambiguous given the available information, then an will be thrown.\n• If all of the above strategies fail then an will be thrown. We remarked earlier that we would describe how to write a proceed call with arguments that works consistently across Spring AOP and AspectJ. The solution is simply to ensure that the advice signature binds each of the method parameters in order. For example: In many cases you will be doing this binding anyway (as in the example above). What happens when multiple pieces of advice all want to run at the same join point? Spring AOP follows the same precedence rules as AspectJ to determine the order of advice execution. The highest precedence advice runs first \"on the way in\" (so given two pieces of before advice, the one with highest precedence runs first). \"On the way out\" from a join point, the highest precedence advice runs last (so given two pieces of after advice, the one with the highest precedence will run second). When two pieces of advice defined in different aspects both need to run at the same join point, unless you specify otherwise the order of execution is undefined. You can control the order of execution by specifying precedence. This is done in the normal Spring way by either implementing the interface in the aspect class or annotating it with the annotation. Given two aspects, the aspect returning the lower value from (or the annotation value) has the higher precedence. When two pieces of advice defined in the same aspect both need to run at the same join point, the ordering is undefined (since there is no way to retrieve the declaration order via reflection for javac-compiled classes). Consider collapsing such advice methods into one advice method per join point in each aspect class, or refactor the pieces of advice into separate aspect classes - which can be ordered at the aspect level. Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare that advised objects implement a given interface, and to provide an implementation of that interface on behalf of those objects. An introduction is made using the annotation. This annotation is used to declare that matching types have a new parent (hence the name). For example, given an interface , and an implementation of that interface , the following aspect declares that all implementors of service interfaces also implement the interface. (In order to expose statistics via JMX for example.) The interface to be implemented is determined by the type of the annotated field. The attribute of the annotation is an AspectJ type pattern :- any bean of a matching type will implement the UsageTracked interface. Note that in the before advice of the above example, service beans can be directly used as implementations of the interface. If accessing a bean programmatically you would write the following: By default there will be a single instance of each aspect within the application context. AspectJ calls this the singleton instantiation model. It is possible to define aspects with alternate lifecycles :- Spring supports AspectJ’s and instantiation models ( and are not currently supported). A \"perthis\" aspect is declared by specifying a clause in the annotation. Let’s look at an example, and then we’ll explain how it works. The effect of the clause is that one aspect instance will be created for each unique service object executing a business service (each unique object bound to 'this' at join points matched by the pointcut expression). The aspect instance is created the first time that a method is invoked on the service object. The aspect goes out of scope when the service object goes out of scope. Before the aspect instance is created, none of the advice within it executes. As soon as the aspect instance has been created, the advice declared within it will execute at matched join points, but only when the service object is the one this aspect is associated with. See the AspectJ programming guide for more information on per-clauses. The instantiation model works in exactly the same way as perthis, but creates one aspect instance for each unique target object at matched join points. Now that you have seen how all the constituent parts work, let’s put them together to do something useful! The execution of business services can sometimes fail due to concurrency issues (for example, deadlock loser). If the operation is retried, it is quite likely to succeed next time round. For business services where it is appropriate to retry in such conditions (idempotent operations that don’t need to go back to the user for conflict resolution), we’d like to transparently retry the operation to avoid the client seeing a . This is a requirement that clearly cuts across multiple services in the service layer, and hence is ideal for implementing via an aspect. Because we want to retry the operation, we will need to use around advice so that we can call proceed multiple times. Here’s how the basic aspect implementation looks: Note that the aspect implements the interface so we can set the precedence of the aspect higher than the transaction advice (we want a fresh transaction each time we retry). The and properties will both be configured by Spring. The main action happens in the around advice. Notice that for the moment we’re applying the retry logic to all . We try to proceed, and if we fail with an we simply try again unless we have exhausted all of our retry attempts. The corresponding Spring configuration is: To refine the aspect so that it only retries idempotent operations, we might define an annotation: and use the annotation to annotate the implementation of service operations. The change to the aspect to only retry idempotent operations simply involves refining the pointcut expression so that only operations match:\n\nIf you prefer an XML-based format, then Spring also offers support for defining aspects using the new \"aop\" namespace tags. The exact same pointcut expressions and advice kinds are supported as when using the @AspectJ style, hence in this section we will focus on the new syntax and refer the reader to the discussion in the previous section (Section 11.2, “@AspectJ support”) for an understanding of writing pointcut expressions and the binding of advice parameters. To use the aop namespace tags described in this section, you need to import the schema as described in Chapter 41, XML Schema-based configuration. See Section 41.2.7, “the aop schema” for how to import the tags in the namespace. Within your Spring configurations, all aspect and advisor elements must be placed within an element (you can have more than one element in an application context configuration). An element can contain pointcut, advisor, and aspect elements (note these must be declared in that order). The style of configuration makes heavy use of Spring’s auto-proxying mechanism. This can cause issues (such as advice not being woven) if you are already using explicit auto-proxying via the use of or suchlike. The recommended usage pattern is to use either just the style, or just the style. Using the schema support, an aspect is simply a regular Java object defined as a bean in your Spring application context. The state and behavior is captured in the fields and methods of the object, and the pointcut and advice information is captured in the XML. An aspect is declared using the <aop:aspect> element, and the backing bean is referenced using the attribute: The bean backing the aspect (\" `aBean`\" in this case) can of course be configured and dependency injected just like any other Spring bean. A named pointcut can be declared inside an <aop:config> element, enabling the pointcut definition to be shared across several aspects and advisors. A pointcut representing the execution of any business service in the service layer could be defined as follows: Note that the pointcut expression itself is using the same AspectJ pointcut expression language as described in Section 11.2, “@AspectJ support”. If you are using the schema based declaration style, you can refer to named pointcuts defined in types (@Aspects) within the pointcut expression. Another way of defining the above pointcut would be: Assuming you have a aspect as described in the section called “Sharing common pointcut definitions”. Declaring a pointcut inside an aspect is very similar to declaring a top-level pointcut: Much the same way in an @AspectJ aspect, pointcuts declared using the schema based definition style may collect join point context. For example, the following pointcut collects the 'this' object as the join point context and passes it to advice: The advice must be declared to receive the collected join point context by including parameters of the matching names: When combining pointcut sub-expressions, '&&' is awkward within an XML document, and so the keywords 'and', 'or' and 'not' can be used in place of '&&', '||' and '!' respectively. For example, the previous pointcut may be better written as: Note that pointcuts defined in this way are referred to by their XML id and cannot be used as named pointcuts to form composite pointcuts. The named pointcut support in the schema based definition style is thus more limited than that offered by the @AspectJ style. The same five advice kinds are supported as for the @AspectJ style, and they have exactly the same semantics. Before advice runs before a matched method execution. It is declared inside an using the <aop:before> element. Here is the id of a pointcut defined at the top ( ) level. To define the pointcut inline instead, replace the attribute with a attribute: As we noted in the discussion of the @AspectJ style, using named pointcuts can significantly improve the readability of your code. The method attribute identifies a method ( ) that provides the body of the advice. This method must be defined for the bean referenced by the aspect element containing the advice. Before a data access operation is executed (a method execution join point matched by the pointcut expression), the \"doAccessCheck\" method on the aspect bean will be invoked. After returning advice runs when a matched method execution completes normally. It is declared inside an in the same way as before advice. For example: Just as in the @AspectJ style, it is possible to get hold of the return value within the advice body. Use the returning attribute to specify the name of the parameter to which the return value should be passed: The doAccessCheck method must declare a parameter named . The type of this parameter constrains matching in the same way as described for @AfterReturning. For example, the method signature may be declared as: After throwing advice executes when a matched method execution exits by throwing an exception. It is declared inside an using the after-throwing element: Just as in the @AspectJ style, it is possible to get hold of the thrown exception within the advice body. Use the throwing attribute to specify the name of the parameter to which the exception should be passed: The doRecoveryActions method must declare a parameter named . The type of this parameter constrains matching in the same way as described for @AfterThrowing. For example, the method signature may be declared as: After (finally) advice runs however a matched method execution exits. It is declared using the element: The final kind of advice is around advice. Around advice runs \"around\" a matched method execution. It has the opportunity to do work both before and after the method executes, and to determine when, how, and even if, the method actually gets to execute at all. Around advice is often used if you need to share state before and after a method execution in a thread-safe manner (starting and stopping a timer for example). Always use the least powerful form of advice that meets your requirements; don’t use around advice if simple before advice would do. Around advice is declared using the element. The first parameter of the advice method must be of type . Within the body of the advice, calling on the causes the underlying method to execute. The method may also be calling passing in an - the values in the array will be used as the arguments to the method execution when it proceeds. See the section called “Around advice” for notes on calling proceed with an . The implementation of the advice would be exactly the same as in the @AspectJ example (minus the annotation of course): The schema based declaration style supports fully typed advice in the same way as described for the @AspectJ support - by matching pointcut parameters by name against advice method parameters. See the section called “Advice parameters” for details. If you wish to explicitly specify argument names for the advice methods (not relying on the detection strategies previously described) then this is done using the attribute of the advice element, which is treated in the same manner to the \"argNames\" attribute in an advice annotation as described in the section called “Determining argument names”. For example: Find below a slightly more involved example of the XSD-based approach that illustrates some around advice used in conjunction with a number of strongly typed parameters. Next up is the aspect. Notice the fact that the method accepts a number of strongly-typed parameters, the first of which happens to be the join point used to proceed with the method call: the presence of this parameter is an indication that the is to be used as advice: Finally, here is the XML configuration that is required to effect the execution of the above advice for a particular join point: If we had the following driver script, we would get output something like this on standard output: StopWatch 'Profiling for 'Pengo' and '12'': running time (millis) = 0 ----------------------------------------- ms % Task name ----------------------------------------- 00000 ? execution(getFoo) When multiple advice needs to execute at the same join point (executing method) the ordering rules are as described in the section called “Advice ordering”. The precedence between aspects is determined by either adding the annotation to the bean backing the aspect or by having the bean implement the interface. Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare that advised objects implement a given interface, and to provide an implementation of that interface on behalf of those objects. An introduction is made using the element inside an This element is used to declare that matching types have a new parent (hence the name). For example, given an interface , and an implementation of that interface , the following aspect declares that all implementors of service interfaces also implement the interface. (In order to expose statistics via JMX for example.) The class backing the bean would contain the method: The interface to be implemented is determined by attribute. The value of the attribute is an AspectJ type pattern :- any bean of a matching type will implement the interface. Note that in the before advice of the above example, service beans can be directly used as implementations of the interface. If accessing a bean programmatically you would write the following: The only supported instantiation model for schema-defined aspects is the singleton model. Other instantiation models may be supported in future releases. The concept of \"advisors\" is brought forward from the AOP support defined in Spring 1.2 and does not have a direct equivalent in AspectJ. An advisor is like a small self-contained aspect that has a single piece of advice. The advice itself is represented by a bean, and must implement one of the advice interfaces described in Section 12.3.2, “Advice types in Spring”. Advisors can take advantage of AspectJ pointcut expressions though. Spring supports the advisor concept with the element. You will most commonly see it used in conjunction with transactional advice, which also has its own namespace support in Spring. Here’s how it looks: As well as the attribute used in the above example, you can also use the attribute to define a pointcut expression inline. To define the precedence of an advisor so that the advice can participate in ordering, use the attribute to define the value of the advisor. Let’s see how the concurrent locking failure retry example from Section 11.2.7, “Example” looks when rewritten using the schema support. The execution of business services can sometimes fail due to concurrency issues (for example, deadlock loser). If the operation is retried, it is quite likely it will succeed next time round. For business services where it is appropriate to retry in such conditions (idempotent operations that don’t need to go back to the user for conflict resolution), we’d like to transparently retry the operation to avoid the client seeing a . This is a requirement that clearly cuts across multiple services in the service layer, and hence is ideal for implementing via an aspect. Because we want to retry the operation, we’ll need to use around advice so that we can call proceed multiple times. Here’s how the basic aspect implementation looks (it’s just a regular Java class using the schema support): Note that the aspect implements the interface so we can set the precedence of the aspect higher than the transaction advice (we want a fresh transaction each time we retry). The and properties will both be configured by Spring. The main action happens in the around advice method. We try to proceed, and if we fail with a we simply try again unless we have exhausted all of our retry attempts. This class is identical to the one used in the @AspectJ example, but with the annotations removed. The corresponding Spring configuration is: Notice that for the time being we assume that all business services are idempotent. If this is not the case we can refine the aspect so that it only retries genuinely idempotent operations, by introducing an annotation: and using the annotation to annotate the implementation of service operations. The change to the aspect to retry only idempotent operations simply involves refining the pointcut expression so that only operations match:\n\nSpring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given target object. (JDK dynamic proxies are preferred whenever you have a choice). If the target object to be proxied implements at least one interface then a JDK dynamic proxy will be used. All of the interfaces implemented by the target type will be proxied. If the target object does not implement any interfaces then a CGLIB proxy will be created. If you want to force the use of CGLIB proxying (for example, to proxy every method defined for the target object, not just those implemented by its interfaces) you can do so. However, there are some issues to consider:\n• methods cannot be advised, as they cannot be overridden.\n• As of Spring 3.2, it is no longer necessary to add CGLIB to your project classpath, as CGLIB classes are repackaged under org.springframework and included directly in the spring-core JAR. This means that CGLIB-based proxy support 'just works' in the same way that JDK dynamic proxies always have.\n• As of Spring 4.0, the constructor of your proxied object will NOT be called twice anymore since the CGLIB proxy instance will be created via Objenesis. Only if your JVM does not allow for constructor bypassing, you might see double invocations and corresponding debug log entries from Spring’s AOP support. To force the use of CGLIB proxies set the value of the attribute of the element to true: To force CGLIB proxying when using the @AspectJ autoproxy support, set the attribute of the element to : Multiple sections are collapsed into a single unified auto-proxy creator at runtime, which applies the strongest proxy settings that any of the sections (typically from different XML bean definition files) specified. This also applies to the and elements. To be clear: using on , or elements will force the use of CGLIB proxies for all three of them. Spring AOP is proxy-based. It is vitally important that you grasp the semantics of what that last statement actually means before you write your own aspects or use any of the Spring AOP-based aspects supplied with the Spring Framework. Consider first the scenario where you have a plain-vanilla, un-proxied, nothing-special-about-it, straight object reference, as illustrated by the following code snippet. If you invoke a method on an object reference, the method is invoked directly on that object reference, as can be seen below. Things change slightly when the reference that client code has is a proxy. Consider the following diagram and code snippet. The key thing to understand here is that the client code inside the of the class has a reference to the proxy. This means that method calls on that object reference will be calls on the proxy, and as such the proxy will be able to delegate to all of the interceptors (advice) that are relevant to that particular method call. However, once the call has finally reached the target object, the reference in this case, any method calls that it may make on itself, such as or , are going to be invoked against the this reference, and not the proxy. This has important implications. It means that self-invocation is not going to result in the advice associated with a method invocation getting a chance to execute. Okay, so what is to be done about this? The best approach (the term best is used loosely here) is to refactor your code such that the self-invocation does not happen. For sure, this does entail some work on your part, but it is the best, least-invasive approach. The next approach is absolutely horrendous, and I am almost reticent to point it out precisely because it is so horrendous. You can (choke!) totally tie the logic within your class to Spring AOP by doing this: This totally couples your code to Spring AOP, and it makes the class itself aware of the fact that it is being used in an AOP context, which flies in the face of AOP. It also requires some additional configuration when the proxy is being created: Finally, it must be noted that AspectJ does not have this self-invocation issue because it is not a proxy-based AOP framework.\n\nEverything we’ve covered so far in this chapter is pure Spring AOP. In this section, we’re going to look at how you can use the AspectJ compiler/weaver instead of, or in addition to, Spring AOP if your needs go beyond the facilities offered by Spring AOP alone. Spring ships with a small AspectJ aspect library, which is available standalone in your distribution as ; you’ll need to add this to your classpath in order to use the aspects in it. Section 11.8.1, “Using AspectJ to dependency inject domain objects with Spring” and Section 11.8.2, “Other Spring aspects for AspectJ” discuss the content of this library and how you can use it. Section 11.8.3, “Configuring AspectJ aspects using Spring IoC” discusses how to dependency inject AspectJ aspects that are woven using the AspectJ compiler. Finally, Section 11.8.4, “Load-time weaving with AspectJ in the Spring Framework” provides an introduction to load-time weaving for Spring applications using AspectJ. 11.8.1 Using AspectJ to dependency inject domain objects with Spring The Spring container instantiates and configures beans defined in your application context. It is also possible to ask a bean factory to configure a pre-existing object given the name of a bean definition containing the configuration to be applied. The contains an annotation-driven aspect that exploits this capability to allow dependency injection of any object. The support is intended to be used for objects created outside of the control of any container. Domain objects often fall into this category because they are often created programmatically using the operator, or by an ORM tool as a result of a database query. The annotation marks a class as eligible for Spring-driven configuration. In the simplest case it can be used just as a marker annotation: When used as a marker interface in this way, Spring will configure new instances of the annotated type ( in this case) using a bean definition (typically prototype-scoped) with the same name as the fully-qualified type name ( ). Since the default name for a bean is the fully-qualified name of its type, a convenient way to declare the prototype definition is simply to omit the attribute: If you want to explicitly specify the name of the prototype bean definition to use, you can do so directly in the annotation: Spring will now look for a bean definition named \"account\" and use that as the definition to configure new instances. You can also use autowiring to avoid having to specify a dedicated bean definition at all. To have Spring apply autowiring use the property of the annotation: specify either or for autowiring by type or by name respectively. As an alternative, as of Spring 2.5 it is preferable to specify explicit, annotation-driven dependency injection for your beans by using or at the field or method level (see Section 7.9, “Annotation-based container configuration” for further details). Finally you can enable Spring dependency checking for the object references in the newly created and configured object by using the attribute (for example: ). If this attribute is set to true, then Spring will validate after configuration that all properties (which are not primitives or collections) have been set. Using the annotation on its own does nothing of course. It is the in that acts on the presence of the annotation. In essence the aspect says \"after returning from the initialization of a new object of a type annotated with , configure the newly created object using Spring in accordance with the properties of the annotation\". In this context, initialization refers to newly instantiated objects (e.g., objects instantiated with the operator) as well as to objects that are undergoing deserialization (e.g., via readResolve()). One of the key phrases in the above paragraph is 'in essence'. For most cases, the exact semantics of 'after returning from the initialization of a new object' will be fine…​ in this context, 'after initialization' means that the dependencies will be injected after the object has been constructed - this means that the dependencies will not be available for use in the constructor bodies of the class. If you want the dependencies to be injected before the constructor bodies execute, and thus be available for use in the body of the constructors, then you need to define this on the declaration like so: You can find out more information about the language semantics of the various pointcut types in AspectJ in this appendix of the AspectJ Programming Guide. For this to work the annotated types must be woven with the AspectJ weaver - you can either use a build-time Ant or Maven task to do this (see for example the AspectJ Development Environment Guide) or load-time weaving (see Section 11.8.4, “Load-time weaving with AspectJ in the Spring Framework”). The itself needs configuring by Spring (in order to obtain a reference to the bean factory that is to be used to configure new objects). If you are using Java based configuration simply add to any class. If you prefer XML based configuration, the Spring namespace defines a convenient element: Instances of objects created before the aspect has been configured will result in a message being issued to the debug log and no configuration of the object taking place. An example might be a bean in the Spring configuration that creates domain objects when it is initialized by Spring. In this case you can use the \"depends-on\" bean attribute to manually specify that the bean depends on the configuration aspect. Do not activate processing through the bean configurer aspect unless you really mean to rely on its semantics at runtime. In particular, make sure that you do not use on bean classes which are registered as regular Spring beans with the container: You would get double initialization otherwise, once through the container and once through the aspect. One of the goals of the support is to enable independent unit testing of domain objects without the difficulties associated with hard-coded lookups. If types have not been woven by AspectJ then the annotation has no affect during unit testing, and you can simply set mock or stub property references in the object under test and proceed as normal. If types have been woven by AspectJ then you can still unit test outside of the container as normal, but you will see a warning message each time that you construct an object indicating that it has not been configured by Spring. The used to implement the support is an AspectJ singleton aspect. The scope of a singleton aspect is the same as the scope of members, that is to say there is one aspect instance per classloader that defines the type. This means that if you define multiple application contexts within the same classloader hierarchy you need to consider where to define the bean and where to place on the classpath. Consider a typical Spring web-app configuration with a shared parent application context defining common business services and everything needed to support them, and one child application context per servlet containing definitions particular to that servlet. All of these contexts will co-exist within the same classloader hierarchy, and so the can only hold a reference to one of them. In this case we recommend defining the bean in the shared (parent) application context: this defines the services that you are likely to want to inject into domain objects. A consequence is that you cannot configure domain objects with references to beans defined in the child (servlet-specific) contexts using the @Configurable mechanism (probably not something you want to do anyway!). When deploying multiple web-apps within the same container, ensure that each web-application loads the types in using its own classloader (for example, by placing in ). If is only added to the container wide classpath (and hence loaded by the shared parent classloader), all web applications will share the same aspect instance which is probably not what you want. In addition to the aspect, contains an AspectJ aspect that can be used to drive Spring’s transaction management for types and methods annotated with the annotation. This is primarily intended for users who want to use the Spring Framework’s transaction support outside of the Spring container. The aspect that interprets annotations is the . When using this aspect, you must annotate the implementation class (and/or methods within that class), not the interface (if any) that the class implements. AspectJ follows Java’s rule that annotations on interfaces are not inherited. A annotation on a class specifies the default transaction semantics for the execution of any public operation in the class. A annotation on a method within the class overrides the default transaction semantics given by the class annotation (if present). Methods of any visibility may be annotated, including private methods. Annotating non-public methods directly is the only way to get transaction demarcation for the execution of such methods. Since Spring Framework 4.2, provides a similar aspect that offers the exact same features for the standard annotation. Check for more details. For AspectJ programmers that want to use the Spring configuration and transaction management support but don’t want to (or cannot) use annotations, also contains aspects you can extend to provide your own pointcut definitions. See the sources for the and aspects for more information. As an example, the following excerpt shows how you could write an aspect to configure all instances of objects defined in the domain model using prototype bean definitions that match the fully-qualified class names: When using AspectJ aspects with Spring applications, it is natural to both want and expect to be able to configure such aspects using Spring. The AspectJ runtime itself is responsible for aspect creation, and the means of configuring the AspectJ created aspects via Spring depends on the AspectJ instantiation model (the clause) used by the aspect. The majority of AspectJ aspects are singleton aspects. Configuration of these aspects is very easy: simply create a bean definition referencing the aspect type as normal, and include the bean attribute . This ensures that Spring obtains the aspect instance by asking AspectJ for it rather than trying to create an instance itself. For example: Non-singleton aspects are harder to configure: however it is possible to do so by creating prototype bean definitions and using the support from to configure the aspect instances once they have bean created by the AspectJ runtime. If you have some @AspectJ aspects that you want to weave with AspectJ (for example, using load-time weaving for domain model types) and other @AspectJ aspects that you want to use with Spring AOP, and these aspects are all configured using Spring, then you will need to tell the Spring AOP @AspectJ autoproxying support which exact subset of the @AspectJ aspects defined in the configuration should be used for autoproxying. You can do this by using one or more elements inside the declaration. Each element specifies a name pattern, and only beans with names matched by at least one of the patterns will be used for Spring AOP autoproxy configuration: Do not be misled by the name of the element: using it will result in the creation of Spring AOP proxies. The @AspectJ style of aspect declaration is just being used here, but the AspectJ runtime is not involved. 11.8.4 Load-time weaving with AspectJ in the Spring Framework Load-time weaving (LTW) refers to the process of weaving AspectJ aspects into an application’s class files as they are being loaded into the Java virtual machine (JVM). The focus of this section is on configuring and using LTW in the specific context of the Spring Framework: this section is not an introduction to LTW though. For full details on the specifics of LTW and configuring LTW with just AspectJ (with Spring not being involved at all), see the LTW section of the AspectJ Development Environment Guide. The value-add that the Spring Framework brings to AspectJ LTW is in enabling much finer-grained control over the weaving process. 'Vanilla' AspectJ LTW is effected using a Java (5+) agent, which is switched on by specifying a VM argument when starting up a JVM. It is thus a JVM-wide setting, which may be fine in some situations, but often is a little too coarse. Spring-enabled LTW enables you to switch on LTW on a per-ClassLoader basis, which obviously is more fine-grained and which can make more sense in a 'single-JVM-multiple-application' environment (such as is found in a typical application server environment). Further, in certain environments, this support enables load-time weaving without making any modifications to the application server’s launch script that will be needed to add or (as we describe later in this section) (previously named ). Developers simply modify one or more files that form the application context to enable load-time weaving instead of relying on administrators who typically are in charge of the deployment configuration such as the launch script. Now that the sales pitch is over, let us first walk through a quick example of AspectJ LTW using Spring, followed by detailed specifics about elements introduced in the following example. For a complete example, please see the Petclinic sample application. Let us assume that you are an application developer who has been tasked with diagnosing the cause of some performance problems in a system. Rather than break out a profiling tool, what we are going to do is switch on a simple profiling aspect that will enable us to very quickly get some performance metrics, so that we can then apply a finer-grained profiling tool to that specific area immediately afterwards. The example presented here uses XML style configuration, it is also possible to configure and use @AspectJ with Java Configuration. Specifically the annotation can be used as an alternative to (see below for details). Here is the profiling aspect. Nothing too fancy, just a quick-and-dirty time-based profiler, using the @AspectJ-style of aspect declaration. We will also need to create an file, to inform the AspectJ weaver that we want to weave our into our classes. This file convention, namely the presence of a file (or files) on the Java classpath called is standard AspectJ. Now to the Spring-specific portion of the configuration. We need to configure a (all explained later, just take it on trust for now). This load-time weaver is the essential component responsible for weaving the aspect configuration in one or more files into the classes in your application. The good thing is that it does not require a lot of configuration, as can be seen below (there are some more options that you can specify, but these are detailed later). Now that all the required artifacts are in place - the aspect, the file, and the Spring configuration -, let us create a simple driver class with a method to demonstrate the LTW in action. There is one last thing to do. The introduction to this section did say that one could switch on LTW selectively on a per- basis with Spring, and this is true. However, just for this example, we are going to use a Java agent (supplied with Spring) to switch on the LTW. This is the command line we will use to run the above class: The is a flag for specifying and enabling agents to instrument programs running on the JVM. The Spring Framework ships with such an agent, the , which is packaged in the that was supplied as the value of the argument in the above example. The output from the execution of the program will look something like that below. (I have introduced a statement into the implementation so that the profiler actually captures something other than 0 milliseconds - the milliseconds is not an overhead introduced by the AOP :) ) Since this LTW is effected using full-blown AspectJ, we are not just limited to advising Spring beans; the following slight variation on the program will yield the same result. Notice how in the above program we are simply bootstrapping the Spring container, and then creating a new instance of the totally outside the context of Spring…​ the profiling advice still gets woven in. The example admittedly is simplistic…​ however the basics of the LTW support in Spring have all been introduced in the above example, and the rest of this section will explain the 'why' behind each bit of configuration and usage in detail. The used in this example may be basic, but it is quite useful. It is a nice example of a development-time aspect that developers can use during development (of course), and then quite easily exclude from builds of the application being deployed into UAT or production. The aspects that you use in LTW have to be AspectJ aspects. They can be written in either the AspectJ language itself or you can write your aspects in the @AspectJ-style. It means that your aspects are then both valid AspectJ and Spring AOP aspects. Furthermore, the compiled aspect classes need to be available on the classpath. The AspectJ LTW infrastructure is configured using one or more files, that are on the Java classpath (either directly, or more typically in jar files). The structure and contents of this file is detailed in the main AspectJ reference documentation, and the interested reader is referred to that resource. (I appreciate that this section is brief, but the file is 100% AspectJ - there is no Spring-specific information or semantics that apply to it, and so there is no extra value that I can contribute either as a result), so rather than rehash the quite satisfactory section that the AspectJ developers wrote, I am just directing you there.) At a minimum you will need the following libraries to use the Spring Framework’s support for AspectJ LTW: If you are using the Spring-provided agent to enable instrumentation, you will also need: The key component in Spring’s LTW support is the interface (in the package), and the numerous implementations of it that ship with the Spring distribution. A is responsible for adding one or more to a at runtime, which opens the door to all manner of interesting applications, one of which happens to be the LTW of aspects. If you are unfamiliar with the idea of runtime class file transformation, you are encouraged to read the javadoc API documentation for the package before continuing. This is not a huge chore because there is - rather annoyingly - precious little documentation there…​ the key interfaces and classes will at least be laid out in front of you for reference as you read through this section. Configuring a for a particular can be as easy as adding one line. (Please note that you almost certainly will need to be using an as your Spring container - typically a will not be enough because the LTW support makes use of .) To enable the Spring Framework’s LTW support, you need to configure a , which typically is done using the annotation. Alternatively, if you prefer XML based configuration, use the element. Note that the element is defined in the namespace. The above configuration will define and register a number of LTW-specific infrastructure beans for you automatically, such as a and an . The default is the class, which attempts to decorate an automatically detected : the exact type of that will be 'automatically detected' is dependent upon your runtime environment (summarized in the following table). Running in Red Hat’s JBoss AS or WildFly Fallback, expecting the underlying ClassLoader to follow common conventions (e.g. applicable to and Resin) \n\n Note that these are just the that are autodetected when using the : it is of course possible to specify exactly which implementation that you wish to use. To specify a specific with Java configuration implement the interface and override the method: If you are using XML based configuration you can specify the fully-qualified classname as the value of the attribute on the element: The that is defined and registered by the configuration can be later retrieved from the Spring container using the well-known name . Remember that the exists just as a mechanism for Spring’s LTW infrastructure to add one or more . The actual that does the LTW is the (from the package) class. See the class-level javadocs of the class for further details, because the specifics of how the weaving is actually effected is beyond the scope of this section. There is one final attribute of the configuration left to discuss: the attribute (or if you are using XML). This is a simple attribute that controls whether LTW is enabled or not; it is as simple as that. It accepts one of three possible values, summarized below, with the default value being if the attribute is not present. AspectJ weaving is on, and aspects will be woven at load-time as appropriate. LTW is off…​ no aspect will be woven at load-time. If the Spring LTW infrastructure can find at least one file, then AspectJ weaving is on, else it is off. This is the default value. \n\n This last section contains any additional settings and configuration that you will need when using Spring’s LTW support in environments such as application servers and web containers. Historically, Apache Tomcat's default class loader did not support class transformation which is why Spring provides an enhanced implementation that addresses this need. Named , the loader works on Tomcat 6.0 and above. Do not define anymore on Tomcat 8.0 and higher. Instead, let Spring automatically use Tomcat’s new native facility through the strategy. If you still need to use , it can be registered individually for each web application as follows:\n• Copy into /lib, where represents the root of the Tomcat installation)\n• Instruct Tomcat to use the custom class loader (instead of the default) by editing the web application context file:\n• per-web application configuration which can be deployed either on the server-side at or embedded inside the web-app archive at For efficiency, the embedded per-web-app configuration style is recommended because it will impact only applications that use the custom class loader and does not require any changes to the server configuration. See the Tomcat 6.0.x documentation for more details about available context locations. Alternatively, consider the use of the Spring-provided generic VM agent, to be specified in Tomcat’s launch script (see above). This will make instrumentation available to all deployed web applications, no matter what ClassLoader they happen to run on. Recent versions of WebLogic Server (version 10 and above), IBM WebSphere Application Server (version 7 and above), Resin (3.1 and above) and JBoss (6.x or above) provide a ClassLoader that is capable of local instrumentation. Spring’s native LTW leverages such ClassLoaders to enable AspectJ weaving. You can enable LTW by simply activating load-time weaving as described earlier. Specifically, you do not need to modify the launch script to add . Note that GlassFish instrumentation-capable ClassLoader is available only in its EAR environment. For GlassFish web applications, follow the Tomcat setup instructions as outlined above. Note that on JBoss 6.x, the app server scanning needs to be disabled to prevent it from loading the classes before the application actually starts. A quick workaround is to add to your artifact a file named with the following content: When class instrumentation is required in environments that do not support or are not supported by the existing implementations, a JDK agent can be the only solution. For such cases, Spring provides , which requires a Spring-specific (but very general) VM agent, (previously named ). To use it, you must start the virtual machine with the Spring agent, by supplying the following JVM options: Note that this requires modification of the VM launch script which may prevent you from using this in application server environments (depending on your operation policies). Additionally, the JDK agent will instrument the entire VM which can prove expensive. For performance reasons, it is recommended to use this configuration only if your target environment (such as Jetty) does not have (or does not support) a dedicated LTW."
    },
    {
        "link": "https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html",
        "document": "Aspect-Oriented Programming (AOP) complements Object-Oriented Programming (OOP) by providing another way of thinking about program structure. The key unit of modularity in OOP is the class, whereas in AOP the unit of modularity is the aspect. Aspects enable the modularization of concerns such as transaction management that cut across multiple types and objects. (Such concerns are often termed crosscutting concerns in AOP literature.) One of the key components of Spring is the AOP framework. While the Spring IoC container does not depend on AOP, meaning you do not need to use AOP if you don't want to, AOP complements Spring IoC to provide a very capable middleware solution. Spring 2.0 introduces a simpler and more powerful way of writing custom aspects using either a schema-based approach or the @AspectJ annotation style. Both of these styles offer fully typed advice and use of the AspectJ pointcut language, while still using Spring AOP for weaving. The Spring 2.0 schema- and @AspectJ-based AOP support is discussed in this chapter. Spring 2.0 AOP remains fully backwards compatible with Spring 1.2 AOP, and the lower-level AOP support offered by the Spring 1.2 APIs is discussed in the following chapter. AOP is used in the Spring Framework to...\n• ... provide declarative enterprise services, especially as a replacement for EJB declarative services. The most important such service is declarative transaction management.\n• ... allow users to implement custom aspects, complementing their use of OOP with AOP. If you are interested only in generic declarative services or other pre-packaged declarative middleware services such as pooling, you do not need to work directly with Spring AOP, and can skip most of this chapter. Let us begin by defining some central AOP concepts and terminology. These terms are not Spring-specific... unfortunately, AOP terminology is not particularly intuitive; however, it would be even more confusing if Spring used its own terminology.\n• Aspect: a modularization of a concern that cuts across multiple classes. Transaction management is a good example of a crosscutting concern in enterprise Java applications. In Spring AOP, aspects are implemented using regular classes (the schema-based approach) or regular classes annotated with the annotation (the style).\n• Join point: a point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.\n• Advice: action taken by an aspect at a particular join point. Different types of advice include \"around,\" \"before\" and \"after\" advice. (Advice types are discussed below.) Many AOP frameworks, including Spring, model an advice as an interceptor, maintaining a chain of interceptors around the join point.\n• Pointcut: a predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name). The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default.\n• Introduction: declaring additional methods or fields on behalf of a type. Spring AOP allows you to introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.)\n• Target object: object being advised by one or more aspects. Also referred to as the advised object. Since Spring AOP is implemented using runtime proxies, this object will always be a proxied object.\n• AOP proxy: an object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy will be a JDK dynamic proxy or a CGLIB proxy.\n• Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.\n• Before advice: Advice that executes before a join point, but which does not have the ability to prevent execution flow proceeding to the join point (unless it throws an exception).\n• After returning advice: Advice to be executed after a join point completes normally: for example, if a method returns without throwing an exception.\n• After throwing advice: Advice to be executed if a method exits by throwing an exception.\n• After (finally) advice: Advice to be executed regardless of the means by which a join point exits (normal or exceptional return).\n• Around advice: Advice that surrounds a join point such as a method invocation. This is the most powerful kind of advice. Around advice can perform custom behavior before and after the method invocation. It is also responsible for choosing whether to proceed to the join point or to shortcut the advised method execution by returning its own return value or throwing an exception. Around advice is the most general kind of advice. Since Spring AOP, like AspectJ, provides a full range of advice types, we recommend that you use the least powerful advice type that can implement the required behavior. For example, if you need only to update a cache with the return value of a method, you are better off implementing an after returning advice than an around advice, although an around advice can accomplish the same thing. Using the most specific advice type provides a simpler programming model with less potential for errors. For example, you do not need to invoke the method on the used for around advice, and hence cannot fail to invoke it. In Spring 2.0, all advice parameters are statically typed, so that you work with advice parameters of the appropriate type (the type of the return value from a method execution for example) rather than arrays. The concept of join points, matched by pointcuts, is the key to AOP which distinguishes it from older technologies offering only interception. Pointcuts enable advice to be targeted independently of the Object-Oriented hierarchy. For example, an around advice providing declarative transaction management can be applied to a set of methods spanning multiple objects (such as all business operations in the service layer). Spring AOP is implemented in pure Java. There is no need for a special compilation process. Spring AOP does not need to control the class loader hierarchy, and is thus suitable for use in a Servlet container or application server. Spring AOP currently supports only method execution join points (advising the execution of methods on Spring beans). Field interception is not implemented, although support for field interception could be added without breaking the core Spring AOP APIs. If you need to advise field access and update join points, consider a language such as AspectJ. Spring AOP's approach to AOP differs from that of most other AOP frameworks. The aim is not to provide the most complete AOP implementation (although Spring AOP is quite capable); it is rather to provide a close integration between AOP implementation and Spring IoC to help solve common problems in enterprise applications. Thus, for example, the Spring Framework's AOP functionality is normally used in conjunction with the Spring IoC container. Aspects are configured using normal bean definition syntax (although this allows powerful \"autoproxying\" capabilities): this is a crucial difference from other AOP implementations. There are some things you cannot do easily or efficiently with Spring AOP, such as advise very fine-grained objects (such as domain objects typically): AspectJ is the best choice in such cases. However, our experience is that Spring AOP provides an excellent solution to most problems in enterprise Java applications that are amenable to AOP. Spring AOP will never strive to compete with AspectJ to provide a comprehensive AOP solution. We believe that both proxy-based frameworks like Spring AOP and full-blown frameworks such as AspectJ are valuable, and that they are complementary, rather than in competition. Spring 2.0 seamlessly integrates Spring AOP and IoC with AspectJ, to enable all uses of AOP to be catered for within a consistent Spring-based application architecture. This integration does not affect the Spring AOP API or the AOP Alliance API: Spring AOP remains backward-compatible. See the following chapter for a discussion of the Spring AOP APIs. One of the central tenets of the Spring Framework is that of non-invasiveness; this is the idea that you should not be forced to introduce framework-specific classes and interfaces into your business/domain model. However, in some places the Spring Framework does give you the option to introduce Spring Framework-specific dependencies into your codebase: the rationale in giving you such options is because in certain scenarios it might be just plain easier to read or code some specific piece of functionality in such a way. The Spring Framework (almost) always offers you the choice though: you have the freedom to make an informed decision as to which option best suits your particular use case or scenario. One such choice that is relevant to this chapter is that of which AOP framework (and which AOP style) to choose. You have the choice of AspectJ and/or Spring AOP, and you also have the choice of either the @AspectJ annotation-style approach or the Spring XML configuration-style approach. The fact that this chapter chooses to introduce the @AspectJ-style approach first should not be taken as an indication that the Spring team favors the @AspectJ annotation-style approach over the Spring XML configuration-style. See Section 9.4, “Choosing which AOP declaration style to use” for a more complete discussion of the whys and wherefores of each style. Spring AOP defaults to using standard J2SE dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied. Spring AOP can also use CGLIB proxies. This is necessary to proxy classes, rather than interfaces. CGLIB is used by default if a business object does not implement an interface. As it is good practice to program to interfaces rather than classes, business classes normally will implement one or more business interfaces. It is possible to force the use of CGLIB, in those (hopefully rare) cases where you need to advise a method that is not declared on an interface, or where you need to pass a proxied object to a method as a concrete type. It is important to grasp the fact that Spring AOP is proxy-based. See Section 9.6.1, “Understanding AOP proxies” for a thorough examination of exactly what this implementation detail actually means.\n\n@AspectJ refers to a style of declaring aspects as regular Java classes annotated with Java 5 annotations. The @AspectJ style was introduced by the AspectJ project as part of the AspectJ 5 release. Spring 2.0 interprets the same annotations as AspectJ 5, using a library supplied by AspectJ for pointcut parsing and matching. The AOP runtime is still pure Spring AOP though, and there is no dependency on the AspectJ compiler or weaver. Using the AspectJ compiler and weaver enables use of the full AspectJ language, and is discussed in Section 9.8, “Using AspectJ with Spring applications”. To use @AspectJ aspects in a Spring configuration you need to enable Spring support for configuring Spring AOP based on @AspectJ aspects, and autoproxying beans based on whether or not they are advised by those aspects. By autoproxying we mean that if Spring determines that a bean is advised by one or more aspects, it will automatically generate a proxy for that bean to intercept method invocations and ensure that advice is executed as needed. The @AspectJ support can be enabled with XML or Java style configuration. In either case you will also need to ensure that AspectJ's library is on the classpath of your application (version 1.6.8 or later). This library is available in the directory of an AspectJ distribution or via the Maven Central repository. To enable @AspectJ support with Java add the annotation: To enable @AspectJ support with XML based configuration use the element: This assumes that you are using schema support as described in Appendix E, XML Schema-based configuration. See Section E.2.7, “The schema” for how to import the tags in the aop namespace. If you are using the DTD, it is still possible to enable @AspectJ support by adding the following definition to your application context: With the @AspectJ support enabled, any bean defined in your application context with a class that is an @AspectJ aspect (has the annotation) will be automatically detected by Spring and used to configure Spring AOP. The following example shows the minimal definition required for a not-very-useful aspect: A regular bean definition in the application context, pointing to a bean class that has the annotation: = = <!-- configure properties of aspect here as normal --> And the class definition, annotated with annotation; Aspects (classes annotated with ) may have methods and fields just like any other class. They may also contain pointcut, advice, and introduction (inter-type) declarations. You may register aspect classes as regular beans in your Spring XML configuration, or autodetect them through classpath scanning - just like any other Spring-managed bean. However, note that the @Aspect annotation is not sufficient for autodetection in the classpath: For that purpose, you need to add a separate @Component annotation (or alternatively a custom stereotype annotation that qualifies, as per the rules of Spring's component scanner). In Spring AOP, it is not possible to have aspects themselves be the target of advice from other aspects. The @Aspect annotation on a class marks it as an aspect, and hence excludes it from auto-proxying. Recall that pointcuts determine join points of interest, and thus enable us to control when advice executes. Spring AOP only supports method execution join points for Spring beans, so you can think of a pointcut as matching the execution of methods on Spring beans. A pointcut declaration has two parts: a signature comprising a name and any parameters, and a pointcut expression that determines exactly which method executions we are interested in. In the @AspectJ annotation-style of AOP, a pointcut signature is provided by a regular method definition, and the pointcut expression is indicated using the annotation (the method serving as the pointcut signature must have a return type). An example will help make this distinction between a pointcut signature and a pointcut expression clear. The following example defines a pointcut named that will match the execution of any method named : The pointcut expression that forms the value of the annotation is a regular AspectJ 5 pointcut expression. For a full discussion of AspectJ's pointcut language, see the AspectJ Programming Guide (and for Java 5 based extensions, the AspectJ 5 Developers Notebook) or one of the books on AspectJ such as “Eclipse AspectJ” by Colyer et. al. or “AspectJ in Action” by Ramnivas Laddad. Spring AOP supports the following AspectJ pointcut designators (PCD) for use in pointcut expressions: The full AspectJ pointcut language supports additional pointcut designators that are not supported in Spring. These are: call, get, set, preinitialization, staticinitialization, initialization, handler, adviceexecution, withincode, cflow, cflowbelow, if, @this , and . Use of these pointcut designators in pointcut expressions interpreted by Spring AOP will result in an being thrown. The set of pointcut designators supported by Spring AOP may be extended in future releases to support more of the AspectJ pointcut designators.\n• execution - for matching method execution join points, this is the primary pointcut designator you will use when working with Spring AOP\n• within - limits matching to join points within certain types (simply the execution of a method declared within a matching type when using Spring AOP)\n• this - limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type\n• target - limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type\n• args - limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types\n• - limits matching to join points (the execution of methods when using Spring AOP) where the class of the executing object has an annotation of the given type\n• - limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given type(s)\n• - limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP)\n• @annotation - limits matching to join points where the subject of the join point (method being executed in Spring AOP) has the given annotation Because Spring AOP limits matching to only method execution join points, the discussion of the pointcut designators above gives a narrower definition than you will find in the AspectJ programming guide. In addition, AspectJ itself has type-based semantics and at an execution join point both ' ' and ' ' refer to the same object - the object executing the method. Spring AOP is a proxy-based system and differentiates between the proxy object itself (bound to ' ') and the target object behind the proxy (bound to ' '). Due to the proxy-based nature of Spring's AOP framework, protected methods are by definition not intercepted, neither for JDK proxies (where this isn't applicable) nor for CGLIB proxies (where this is technically possible but not recommendable for AOP purposes). As a consequence, any given pointcut will be matched against public methods only! If your interception needs include protected/private methods or even constructors, consider the use of Spring-driven native AspectJ weaving instead of Spring's proxy-based AOP framework. This constitutes a different mode of AOP usage with different characteristics, so be sure to make yourself familiar with weaving first before making a decision. Spring AOP also supports an additional PCD named ' '. This PCD allows you to limit the matching of join points to a particular named Spring bean, or to a set of named Spring beans (when using wildcards). The ' ' PCD has the following form: The ' ' token can be the name of any Spring bean: limited wildcard support using the ' ' character is provided, so if you establish some naming conventions for your Spring beans you can quite easily write a ' ' PCD expression to pick them out. As is the case with other pointcut designators, the ' ' PCD can be &&'ed, ||'ed, and ! (negated) too. Please note that the ' ' PCD is only supported in Spring AOP - and not in native AspectJ weaving. It is a Spring-specific extension to the standard PCDs that AspectJ defines. The ' ' PCD operates at the instance level (building on the Spring bean name concept) rather than at the type level only (which is what weaving-based AOP is limited to). Instance-based pointcut designators are a special capability of Spring's proxy-based AOP framework and its close integration with the Spring bean factory, where it is natural and straightforward to identify specific beans by name. Pointcut expressions can be combined using '&&', '||' and '!'. It is also possible to refer to pointcut expressions by name. The following example shows three pointcut expressions: (which matches if a method execution join point represents the execution of any public method); (which matches if a method execution is in the trading module), and (which matches if a method execution represents any public method in the trading module). It is a best practice to build more complex pointcut expressions out of smaller named components as shown above. When referring to pointcuts by name, normal Java visibility rules apply (you can see private pointcuts in the same type, protected pointcuts in the hierarchy, public pointcuts anywhere and so on). Visibility does not affect pointcut matching. When working with enterprise applications, you often want to refer to modules of the application and particular sets of operations from within several aspects. We recommend defining a \"SystemArchitecture\" aspect that captures common pointcut expressions for this purpose. A typical such aspect would look as follows: com.xyz.someapp; org.aspectj.lang.annotation.Aspect; org.aspectj.lang.annotation.Pointcut; SystemArchitecture { /** * A join point is in the web layer if the method is defined * in a type in the com.xyz.someapp.web package or any sub-package * under that. */ inWebLayer() {} /** * A join point is in the service layer if the method is defined * in a type in the com.xyz.someapp.service package or any sub-package * under that. */ inServiceLayer() {} /** * A join point is in the data access layer if the method is defined * in a type in the com.xyz.someapp.dao package or any sub-package * under that. */ inDataAccessLayer() {} /** * A business service is the execution of any method defined on a service * interface. This definition assumes that interfaces are placed in the * \"service\" package, and that implementation types are in sub-packages. * * If you group service interfaces by functional area (for example, * in packages com.xyz.someapp.abc.service and com.xyz.def.service) then * the pointcut expression \"execution(* com.xyz.someapp..service.*.*(..))\" * could be used instead. * * Alternatively, you can write the expression using the 'bean' * PCD, like so \"bean(*Service)\". (This assumes that you have * named your Spring service beans in a consistent fashion.) */ businessService() {} /** * A data access operation is the execution of any method defined on a * dao interface. This definition assumes that interfaces are placed in the * \"dao\" package, and that implementation types are in sub-packages. */ dataAccessOperation() {} } The pointcuts defined in such an aspect can be referred to anywhere that you need a pointcut expression. For example, to make the service layer transactional, you could write: The and elements are discussed in Section 9.3, “Schema-based AOP support”. The transaction elements are discussed in Chapter 12, Transaction Management. Spring AOP users are likely to use the pointcut designator the most often. The format of an execution expression is: All parts except the returning type pattern (ret-type-pattern in the snippet above), name pattern, and parameters pattern are optional. The returning type pattern determines what the return type of the method must be in order for a join point to be matched. Most frequently you will use as the returning type pattern, which matches any return type. A fully-qualified type name will match only when the method returns the given type. The name pattern matches the method name. You can use the wildcard as all or part of a name pattern. The parameters pattern is slightly more complex: matches a method that takes no parameters, whereas matches any number of parameters (zero or more). The pattern matches a method taking one parameter of any type, matches a method taking two parameters, the first can be of any type, the second must be a String. Consult the Language Semantics section of the AspectJ Programming Guide for more information. Some examples of common pointcut expressions are given below.\n• the execution of any public method:\n• the execution of any method with a name beginning with \"set\":\n• the execution of any method defined by the interface:\n• the execution of any method defined in the service package:\n• the execution of any method defined in the service package or a sub-package:\n• any join point (method execution only in Spring AOP) within the service package:\n• any join point (method execution only in Spring AOP) within the service package or a sub-package:\n• any join point (method execution only in Spring AOP) where the proxy implements the interface: 'this' is more commonly used in a binding form :- see the following section on advice for how to make the proxy object available in the advice body.\n• any join point (method execution only in Spring AOP) where the target object implements the interface: 'target' is more commonly used in a binding form :- see the following section on advice for how to make the target object available in the advice body.\n• any join point (method execution only in Spring AOP) which takes a single parameter, and where the argument passed at runtime is : 'args' is more commonly used in a binding form :- see the following section on advice for how to make the method arguments available in the advice body. Note that the pointcut given in this example is different to : the args version matches if the argument passed at runtime is Serializable, the execution version matches if the method signature declares a single parameter of type .\n• any join point (method execution only in Spring AOP) where the target object has an annotation: '@target' can also be used in a binding form :- see the following section on advice for how to make the annotation object available in the advice body.\n• any join point (method execution only in Spring AOP) where the declared type of the target object has an annotation: '@within' can also be used in a binding form :- see the following section on advice for how to make the annotation object available in the advice body.\n• any join point (method execution only in Spring AOP) where the executing method has an annotation: '@annotation' can also be used in a binding form :- see the following section on advice for how to make the annotation object available in the advice body.\n• any join point (method execution only in Spring AOP) which takes a single parameter, and where the runtime type of the argument passed has the annotation: '@args' can also be used in a binding form :- see the following section on advice for how to make the annotation object(s) available in the advice body.\n• any join point (method execution only in Spring AOP) on a Spring bean named ' ':\n• any join point (method execution only in Spring AOP) on Spring beans having names that match the wildcard expression ' ': During compilation, AspectJ processes pointcuts in order to try and optimize matching performance. Examining code and determining if each join point matches (statically or dynamically) a given pointcut is a costly process. (A dynamic match means the match cannot be fully determined from static analysis and a test will be placed in the code to determine if there is an actual match when the code is running). On first encountering a pointcut declaration, AspectJ will rewrite it into an optimal form for the matching process. What does this mean? Basically pointcuts are rewritten in DNF (Disjunctive Normal Form) and the components of the pointcut are sorted such that those components that are cheaper to evaluate are checked first. This means you do not have to worry about understanding the performance of various pointcut designators and may supply them in any order in a pointcut declaration. However, AspectJ can only work with what it is told, and for optimal performance of matching you should think about what they are trying to achieve and narrow the search space for matches as much as possible in the definition. The existing designators naturally fall into one of three groups: kinded, scoping and context:\n• None Kinded designators are those which select a particular kind of join point. For example: execution, get, set, call, handler\n• None Scoping designators are those which select a group of join points of interest (of probably many kinds). For example: within, withincode\n• None Contextual designators are those that match (and optionally bind) based on context. For example: this, target, @annotation A well written pointcut should try and include at least the first two types (kinded and scoping), whilst the contextual designators may be included if wishing to match based on join point context, or bind that context for use in the advice. Supplying either just a kinded designator or just a contextual designator will work but could affect weaving performance (time and memory used) due to all the extra processing and analysis. Scoping designators are very fast to match and their usage means AspectJ can very quickly dismiss groups of join points that should not be further processed - that is why a good pointcut should always include one if possible. Advice is associated with a pointcut expression, and runs before, after, or around method executions matched by the pointcut. The pointcut expression may be either a simple reference to a named pointcut, or a pointcut expression declared in place. Before advice is declared in an aspect using the annotation: If using an in-place pointcut expression we could rewrite the above example as: After returning advice runs when a matched method execution returns normally. It is declared using the annotation: Note: it is of course possible to have multiple advice declarations, and other members as well, all inside the same aspect. We're just showing a single advice declaration in these examples to focus on the issue under discussion at the time. Sometimes you need access in the advice body to the actual value that was returned. You can use the form of that binds the return value for this: The name used in the attribute must correspond to the name of a parameter in the advice method. When a method execution returns, the return value will be passed to the advice method as the corresponding argument value. A clause also restricts matching to only those method executions that return a value of the specified type ( in this case, which will match any return value). Please note that it is not possible to return a totally different reference when using after-returning advice. After throwing advice runs when a matched method execution exits by throwing an exception. It is declared using the annotation: Often you want the advice to run only when exceptions of a given type are thrown, and you also often need access to the thrown exception in the advice body. Use the attribute to both restrict matching (if desired, use as the exception type otherwise) and bind the thrown exception to an advice parameter. The name used in the attribute must correspond to the name of a parameter in the advice method. When a method execution exits by throwing an exception, the exception will be passed to the advice method as the corresponding argument value. A clause also restricts matching to only those method executions that throw an exception of the specified type ( in this case). After (finally) advice runs however a matched method execution exits. It is declared using the annotation. After advice must be prepared to handle both normal and exception return conditions. It is typically used for releasing resources, etc. The final kind of advice is around advice. Around advice runs \"around\" a matched method execution. It has the opportunity to do work both before and after the method executes, and to determine when, how, and even if, the method actually gets to execute at all. Around advice is often used if you need to share state before and after a method execution in a thread-safe manner (starting and stopping a timer for example). Always use the least powerful form of advice that meets your requirements (i.e. don't use around advice if simple before advice would do). Around advice is declared using the annotation. The first parameter of the advice method must be of type . Within the body of the advice, calling on the causes the underlying method to execute. The method may also be called passing in an - the values in the array will be used as the arguments to the method execution when it proceeds. The behavior of proceed when called with an Object[] is a little different than the behavior of proceed for around advice compiled by the AspectJ compiler. For around advice written using the traditional AspectJ language, the number of arguments passed to proceed must match the number of arguments passed to the around advice (not the number of arguments taken by the underlying join point), and the value passed to proceed in a given argument position supplants the original value at the join point for the entity the value was bound to (Don't worry if this doesn't make sense right now!). The approach taken by Spring is simpler and a better match to its proxy-based, execution only semantics. You only need to be aware of this difference if you are compiling @AspectJ aspects written for Spring and using proceed with arguments with the AspectJ compiler and weaver. There is a way to write such aspects that is 100% compatible across both Spring AOP and AspectJ, and this is discussed in the following section on advice parameters. The value returned by the around advice will be the return value seen by the caller of the method. A simple caching aspect for example could return a value from a cache if it has one, and invoke proceed() if it does not. Note that proceed may be invoked once, many times, or not at all within the body of the around advice, all of these are quite legal. Spring 2.0 offers fully typed advice - meaning that you declare the parameters you need in the advice signature (as we saw for the returning and throwing examples above) rather than work with arrays all the time. We'll see how to make argument and other contextual values available to the advice body in a moment. First let's take a look at how to write generic advice that can find out about the method the advice is currently advising. Any advice method may declare as its first parameter, a parameter of type (please note that around advice is required to declare a first parameter of type , which is a subclass of . The interface provides a number of useful methods such as (returns the method arguments), (returns the proxy object), (returns the target object), (returns a description of the method that is being advised) and (prints a useful description of the method being advised). Please do consult the Javadocs for full details. We've already seen how to bind the returned value or exception value (using after returning and after throwing advice). To make argument values available to the advice body, you can use the binding form of . If a parameter name is used in place of a type name in an args expression, then the value of the corresponding argument will be passed as the parameter value when the advice is invoked. An example should make this clearer. Suppose you want to advise the execution of dao operations that take an Account object as the first parameter, and you need access to the account in the advice body. You could write the following: The part of the pointcut expression serves two purposes: firstly, it restricts matching to only those method executions where the method takes at least one parameter, and the argument passed to that parameter is an instance of ; secondly, it makes the actual object available to the advice via the parameter. Another way of writing this is to declare a pointcut that \"provides\" the object value when it matches a join point, and then just refer to the named pointcut from the advice. This would look as follows: The interested reader is once more referred to the AspectJ programming guide for more details. The proxy object ( ), target object ( ), and annotations ( ) can all be bound in a similar fashion. The following example shows how you could match the execution of methods annotated with an annotation, and extract the audit code. First the definition of the annotation: And then the advice that matches the execution of methods: Spring AOP can handle generics used in class declarations and method parameters. Suppose you have a generic type like this: You can restrict interception of method types to certain parameter types by simply typing the advice parameter to the parameter type you want to intercept the method for: That this works is pretty obvious as we already discussed above. However, it's worth pointing out that this won't work for generic collections. So you cannot define a pointcut like this: To make this work we would have to inspect every element of the collection, which is not reasonable as we also cannot decide how to treat values in general. To achieve something similar to this you have to type the parameter to and manually check the type of the elements. The parameter binding in advice invocations relies on matching names used in pointcut expressions to declared parameter names in (advice and pointcut) method signatures. Parameter names are not available through Java reflection, so Spring AOP uses the following strategies to determine parameter names:\n• If the parameter names have been specified by the user explicitly, then the specified parameter names are used: both the advice and the pointcut annotations have an optional \"argNames\" attribute which can be used to specify the argument names of the annotated method - these argument names are available at runtime. For example: If the first parameter is of the , , or type, you may leave out the name of the parameter from the value of the \"argNames\" attribute. For example, if you modify the preceding advice to receive the join point object, the \"argNames\" attribute need not include it: The special treatment given to the first parameter of the , , and types is particularly convenient for advice that do not collect any other join point context. In such situations, you may simply omit the \"argNames\" attribute. For example, the following advice need not declare the \"argNames\" attribute:\n• Using the attribute is a little clumsy, so if the attribute has not been specified, then Spring AOP will look at the debug information for the class and try to determine the parameter names from the local variable table. This information will be present as long as the classes have been compiled with debug information ( at a minimum). The consequences of compiling with this flag on are: (1) your code will be slightly easier to understand (reverse engineer), (2) the class file sizes will be very slightly bigger (typically inconsequential), (3) the optimization to remove unused local variables will not be applied by your compiler. In other words, you should encounter no difficulties building with this flag on. If an @AspectJ aspect has been compiled by the AspectJ compiler (ajc) even without the debug information then there is no need to add the argNames attribute as the compiler will retain the needed information.\n• If the code has been compiled without the necessary debug information, then Spring AOP will attempt to deduce the pairing of binding variables to parameters (for example, if only one variable is bound in the pointcut expression, and the advice method only takes one parameter, the pairing is obvious!). If the binding of variables is ambiguous given the available information, then an will be thrown.\n• If all of the above strategies fail then an will be thrown. We remarked earlier that we would describe how to write a proceed call with arguments that works consistently across Spring AOP and AspectJ. The solution is simply to ensure that the advice signature binds each of the method parameters in order. For example: In many cases you will be doing this binding anyway (as in the example above). What happens when multiple pieces of advice all want to run at the same join point? Spring AOP follows the same precedence rules as AspectJ to determine the order of advice execution. The highest precedence advice runs first \"on the way in\" (so given two pieces of before advice, the one with highest precedence runs first). \"On the way out\" from a join point, the highest precedence advice runs last (so given two pieces of after advice, the one with the highest precedence will run second). When two pieces of advice defined in different aspects both need to run at the same join point, unless you specify otherwise the order of execution is undefined. You can control the order of execution by specifying precedence. This is done in the normal Spring way by either implementing the interface in the aspect class or annotating it with the annotation. Given two aspects, the aspect returning the lower value from (or the annotation value) has the higher precedence. When two pieces of advice defined in the same aspect both need to run at the same join point, the ordering is undefined (since there is no way to retrieve the declaration order via reflection for javac-compiled classes). Consider collapsing such advice methods into one advice method per join point in each aspect class, or refactor the pieces of advice into separate aspect classes - which can be ordered at the aspect level. Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare that advised objects implement a given interface, and to provide an implementation of that interface on behalf of those objects. An introduction is made using the annotation. This annotation is used to declare that matching types have a new parent (hence the name). For example, given an interface , and an implementation of that interface , the following aspect declares that all implementors of service interfaces also implement the interface. (In order to expose statistics via JMX for example.) The interface to be implemented is determined by the type of the annotated field. The attribute of the annotation is an AspectJ type pattern :- any bean of a matching type will implement the UsageTracked interface. Note that in the before advice of the above example, service beans can be directly used as implementations of the interface. If accessing a bean programmatically you would write the following: By default there will be a single instance of each aspect within the application context. AspectJ calls this the singleton instantiation model. It is possible to define aspects with alternate lifecycles :- Spring supports AspectJ's and instantiation models ( and are not currently supported). A \"perthis\" aspect is declared by specifying a clause in the annotation. Let's look at an example, and then we'll explain how it works. The effect of the clause is that one aspect instance will be created for each unique service object executing a business service (each unique object bound to 'this' at join points matched by the pointcut expression). The aspect instance is created the first time that a method is invoked on the service object. The aspect goes out of scope when the service object goes out of scope. Before the aspect instance is created, none of the advice within it executes. As soon as the aspect instance has been created, the advice declared within it will execute at matched join points, but only when the service object is the one this aspect is associated with. See the AspectJ programming guide for more information on per-clauses. The instantiation model works in exactly the same way as perthis, but creates one aspect instance for each unique target object at matched join points. Now that you have seen how all the constituent parts work, let's put them together to do something useful! The execution of business services can sometimes fail due to concurrency issues (for example, deadlock loser). If the operation is retried, it is quite likely to succeed next time round. For business services where it is appropriate to retry in such conditions (idempotent operations that don't need to go back to the user for conflict resolution), we'd like to transparently retry the operation to avoid the client seeing a . This is a requirement that clearly cuts across multiple services in the service layer, and hence is ideal for implementing via an aspect. Because we want to retry the operation, we will need to use around advice so that we can call proceed multiple times. Here's how the basic aspect implementation looks: Note that the aspect implements the interface so we can set the precedence of the aspect higher than the transaction advice (we want a fresh transaction each time we retry). The and properties will both be configured by Spring. The main action happens in the around advice. Notice that for the moment we're applying the retry logic to all . We try to proceed, and if we fail with an we simply try again unless we have exhausted all of our retry attempts. The corresponding Spring configuration is: To refine the aspect so that it only retries idempotent operations, we might define an annotation: and use the annotation to annotate the implementation of service operations. The change to the aspect to only retry idempotent operations simply involves refining the pointcut expression so that only operations match:\n\nIf you are unable to use Java 5, or simply prefer an XML-based format, then Spring 2.0 also offers support for defining aspects using the new \"aop\" namespace tags. The exact same pointcut expressions and advice kinds are supported as when using the @AspectJ style, hence in this section we will focus on the new syntax and refer the reader to the discussion in the previous section (Section 9.2, “@AspectJ support”) for an understanding of writing pointcut expressions and the binding of advice parameters. To use the aop namespace tags described in this section, you need to import the spring-aop schema as described in Appendix E, XML Schema-based configuration. See Section E.2.7, “The schema” for how to import the tags in the aop namespace. Within your Spring configurations, all aspect and advisor elements must be placed within an element (you can have more than one element in an application context configuration). An element can contain pointcut, advisor, and aspect elements (note these must be declared in that order). The style of configuration makes heavy use of Spring's auto-proxying mechanism. This can cause issues (such as advice not being woven) if you are already using explicit auto-proxying via the use of or suchlike. The recommended usage pattern is to use either just the style, or just the style. Using the schema support, an aspect is simply a regular Java object defined as a bean in your Spring application context. The state and behavior is captured in the fields and methods of the object, and the pointcut and advice information is captured in the XML. An aspect is declared using the <aop:aspect> element, and the backing bean is referenced using the attribute: The bean backing the aspect (\" \" in this case) can of course be configured and dependency injected just like any other Spring bean. A named pointcut can be declared inside an <aop:config> element, enabling the pointcut definition to be shared across several aspects and advisors. A pointcut representing the execution of any business service in the service layer could be defined as follows: Note that the pointcut expression itself is using the same AspectJ pointcut expression language as described in Section 9.2, “@AspectJ support”. If you are using the schema based declaration style with Java 5, you can refer to named pointcuts defined in types (@Aspects) within the pointcut expression, but this feature is not available on JDK 1.4 and below (it relies on the Java 5 specific AspectJ reflection APIs). On JDK 1.5 therefore, another way of defining the above pointcut would be: Assuming you have a aspect as described in the section called “Sharing common pointcut definitions”. Declaring a pointcut inside an aspect is very similar to declaring a top-level pointcut: Much the same way in an @AspectJ aspect, pointcuts declared using the schema based definition style may collect join point context. For example, the following pointcut collects the 'this' object as the join point context and passes it to advice: The advice must be declared to receive the collected join point context by including parameters of the matching names: When combining pointcut sub-expressions, '&&' is awkward within an XML document, and so the keywords 'and', 'or' and 'not' can be used in place of '&&', '||' and '!' respectively. For example, the previous pointcut may be better written as: Note that pointcuts defined in this way are referred to by their XML id and cannot be used as named pointcuts to form composite pointcuts. The named pointcut support in the schema based definition style is thus more limited than that offered by the @AspectJ style. The same five advice kinds are supported as for the @AspectJ style, and they have exactly the same semantics. Before advice runs before a matched method execution. It is declared inside an using the <aop:before> element. Here is the id of a pointcut defined at the top ( ) level. To define the pointcut inline instead, replace the attribute with a attribute: As we noted in the discussion of the @AspectJ style, using named pointcuts can significantly improve the readability of your code. The method attribute identifies a method ( ) that provides the body of the advice. This method must be defined for the bean referenced by the aspect element containing the advice. Before a data access operation is executed (a method execution join point matched by the pointcut expression), the \"doAccessCheck\" method on the aspect bean will be invoked. After returning advice runs when a matched method execution completes normally. It is declared inside an in the same way as before advice. For example: Just as in the @AspectJ style, it is possible to get hold of the return value within the advice body. Use the returning attribute to specify the name of the parameter to which the return value should be passed: The doAccessCheck method must declare a parameter named . The type of this parameter constrains matching in the same way as described for @AfterReturning. For example, the method signature may be declared as: After throwing advice executes when a matched method execution exits by throwing an exception. It is declared inside an using the after-throwing element: Just as in the @AspectJ style, it is possible to get hold of the thrown exception within the advice body. Use the throwing attribute to specify the name of the parameter to which the exception should be passed: The doRecoveryActions method must declare a parameter named . The type of this parameter constrains matching in the same way as described for @AfterThrowing. For example, the method signature may be declared as: After (finally) advice runs however a matched method execution exits. It is declared using the element: The final kind of advice is around advice. Around advice runs \"around\" a matched method execution. It has the opportunity to do work both before and after the method executes, and to determine when, how, and even if, the method actually gets to execute at all. Around advice is often used if you need to share state before and after a method execution in a thread-safe manner (starting and stopping a timer for example). Always use the least powerful form of advice that meets your requirements; don't use around advice if simple before advice would do. Around advice is declared using the element. The first parameter of the advice method must be of type . Within the body of the advice, calling on the causes the underlying method to execute. The method may also be calling passing in an - the values in the array will be used as the arguments to the method execution when it proceeds. See the section called “Around advice” for notes on calling proceed with an . The implementation of the advice would be exactly the same as in the @AspectJ example (minus the annotation of course): The schema based declaration style supports fully typed advice in the same way as described for the @AspectJ support - by matching pointcut parameters by name against advice method parameters. See the section called “Advice parameters” for details. If you wish to explicitly specify argument names for the advice methods (not relying on the detection strategies previously described) then this is done using the attribute of the advice element, which is treated in the same manner to the \"argNames\" attribute in an advice annotation as described in the section called “Determining argument names”. For example: Find below a slightly more involved example of the XSD-based approach that illustrates some around advice used in conjunction with a number of strongly typed parameters. Next up is the aspect. Notice the fact that the method accepts a number of strongly-typed parameters, the first of which happens to be the join point used to proceed with the method call: the presence of this parameter is an indication that the is to be used as advice: Finally, here is the XML configuration that is required to effect the execution of the above advice for a particular join point: = = = = <!-- this is the object that will be proxied by Spring's AOP infrastructure --> = = <!-- this is the actual advice itself --> = = = = = = = If we had the following driver script, we would get output something like this on standard output: StopWatch 'Profiling for 'Pengo' and '12'': running time (millis) = 0 ----------------------------------------- ms % Task name ----------------------------------------- 00000 ? execution(getFoo) When multiple advice needs to execute at the same join point (executing method) the ordering rules are as described in the section called “Advice ordering”. The precedence between aspects is determined by either adding the annotation to the bean backing the aspect or by having the bean implement the interface. Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare that advised objects implement a given interface, and to provide an implementation of that interface on behalf of those objects. An introduction is made using the element inside an This element is used to declare that matching types have a new parent (hence the name). For example, given an interface , and an implementation of that interface , the following aspect declares that all implementors of service interfaces also implement the interface. (In order to expose statistics via JMX for example.) The class backing the bean would contain the method: The interface to be implemented is determined by attribute. The value of the attribute is an AspectJ type pattern :- any bean of a matching type will implement the interface. Note that in the before advice of the above example, service beans can be directly used as implementations of the interface. If accessing a bean programmatically you would write the following: The only supported instantiation model for schema-defined aspects is the singleton model. Other instantiation models may be supported in future releases. The concept of \"advisors\" is brought forward from the AOP support defined in Spring 1.2 and does not have a direct equivalent in AspectJ. An advisor is like a small self-contained aspect that has a single piece of advice. The advice itself is represented by a bean, and must implement one of the advice interfaces described in Section 10.3.2, “Advice types in Spring”. Advisors can take advantage of AspectJ pointcut expressions though. Spring 2.0 supports the advisor concept with the element. You will most commonly see it used in conjunction with transactional advice, which also has its own namespace support in Spring 2.0. Here's how it looks: As well as the attribute used in the above example, you can also use the attribute to define a pointcut expression inline. To define the precedence of an advisor so that the advice can participate in ordering, use the attribute to define the value of the advisor. Let's see how the concurrent locking failure retry example from Section 9.2.7, “Example” looks when rewritten using the schema support. The execution of business services can sometimes fail due to concurrency issues (for example, deadlock loser). If the operation is retried, it is quite likely it will succeed next time round. For business services where it is appropriate to retry in such conditions (idempotent operations that don't need to go back to the user for conflict resolution), we'd like to transparently retry the operation to avoid the client seeing a . This is a requirement that clearly cuts across multiple services in the service layer, and hence is ideal for implementing via an aspect. Because we want to retry the operation, we'll need to use around advice so that we can call proceed multiple times. Here's how the basic aspect implementation looks (it's just a regular Java class using the schema support): Note that the aspect implements the interface so we can set the precedence of the aspect higher than the transaction advice (we want a fresh transaction each time we retry). The and properties will both be configured by Spring. The main action happens in the around advice method. We try to proceed, and if we fail with a we simply try again unless we have exhausted all of our retry attempts. This class is identical to the one used in the @AspectJ example, but with the annotations removed. The corresponding Spring configuration is: Notice that for the time being we assume that all business services are idempotent. If this is not the case we can refine the aspect so that it only retries genuinely idempotent operations, by introducing an annotation: and using the annotation to annotate the implementation of service operations. The change to the aspect to retry only idempotent operations simply involves refining the pointcut expression so that only operations match:\n\nSpring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given target object. (JDK dynamic proxies are preferred whenever you have a choice). If the target object to be proxied implements at least one interface then a JDK dynamic proxy will be used. All of the interfaces implemented by the target type will be proxied. If the target object does not implement any interfaces then a CGLIB proxy will be created. If you want to force the use of CGLIB proxying (for example, to proxy every method defined for the target object, not just those implemented by its interfaces) you can do so. However, there are some issues to consider:\n• methods cannot be advised, as they cannot be overridden.\n• As of Spring 3.2, it is no longer necessary to add CGLIB to your project classpath, as CGLIB classes are repackaged under org.springframework and included directly in the spring-core JAR. This means that CGLIB-based proxy support 'just works' in the same way that JDK dynamic proxies always have.\n• The constructor of your proxied object will be called twice. This is a natural consequence of the CGLIB proxy model whereby a subclass is generated for each proxied object. For each proxied instance, two objects are created: the actual proxied object and an instance of the subclass that implements the advice. This behavior is not exhibited when using JDK proxies. Usually, calling the constructor of the proxied type twice, is not an issue, as there are usually only assignments taking place and no real logic is implemented in the constructor. To force the use of CGLIB proxies set the value of the attribute of the element to true: To force CGLIB proxying when using the @AspectJ autoproxy support, set the attribute of the element to : Multiple sections are collapsed into a single unified auto-proxy creator at runtime, which applies the strongest proxy settings that any of the sections (typically from different XML bean definition files) specified. This also applies to the and elements. To be clear: using ' ' on , or elements will force the use of CGLIB proxies for all three of them. Spring AOP is proxy-based. It is vitally important that you grasp the semantics of what that last statement actually means before you write your own aspects or use any of the Spring AOP-based aspects supplied with the Spring Framework. Consider first the scenario where you have a plain-vanilla, un-proxied, nothing-special-about-it, straight object reference, as illustrated by the following code snippet. SimplePojo Pojo { foo() { // this next method invocation is a direct call on the 'this' reference .bar(); } bar() { } } If you invoke a method on an object reference, the method is invoked directly on that object reference, as can be seen below. Main { main(String[] args) { Pojo pojo = SimplePojo(); // this is a direct method call on the 'pojo' reference pojo.foo(); } } Things change slightly when the reference that client code has is a proxy. Consider the following diagram and code snippet. Main { main(String[] args) { ProxyFactory factory = ProxyFactory( SimplePojo()); factory.addInterface(Pojo. ); factory.addAdvice( RetryAdvice()); Pojo pojo = (Pojo) factory.getProxy(); // this is a method call on the proxy! pojo.foo(); } } The key thing to understand here is that the client code inside the of the class has a reference to the proxy. This means that method calls on that object reference will be calls on the proxy, and as such the proxy will be able to delegate to all of the interceptors (advice) that are relevant to that particular method call. However, once the call has finally reached the target object, the reference in this case, any method calls that it may make on itself, such as or , are going to be invoked against the reference, and not the proxy. This has important implications. It means that self-invocation is not going to result in the advice associated with a method invocation getting a chance to execute. Okay, so what is to be done about this? The best approach (the term best is used loosely here) is to refactor your code such that the self-invocation does not happen. For sure, this does entail some work on your part, but it is the best, least-invasive approach. The next approach is absolutely horrendous, and I am almost reticent to point it out precisely because it is so horrendous. You can (choke!) totally tie the logic within your class to Spring AOP by doing this: This totally couples your code to Spring AOP, and it makes the class itself aware of the fact that it is being used in an AOP context, which flies in the face of AOP. It also requires some additional configuration when the proxy is being created: Main { main(String[] args) { ProxyFactory factory = ProxyFactory( SimplePojo()); factory.adddInterface(Pojo. ); factory.addAdvice( RetryAdvice()); Pojo pojo = (Pojo) factory.getProxy(); // this is a method call on the proxy! pojo.foo(); } } Finally, it must be noted that AspectJ does not have this self-invocation issue because it is not a proxy-based AOP framework.\n\nEverything we've covered so far in this chapter is pure Spring AOP. In this section, we're going to look at how you can use the AspectJ compiler/weaver instead of, or in addition to, Spring AOP if your needs go beyond the facilities offered by Spring AOP alone. Spring ships with a small AspectJ aspect library, which is available standalone in your distribution as ; you'll need to add this to your classpath in order to use the aspects in it. Section 9.8.1, “Using AspectJ to dependency inject domain objects with Spring” and Section 9.8.2, “Other Spring aspects for AspectJ” discuss the content of this library and how you can use it. Section 9.8.3, “Configuring AspectJ aspects using Spring IoC” discusses how to dependency inject AspectJ aspects that are woven using the AspectJ compiler. Finally, Section 9.8.4, “Load-time weaving with AspectJ in the Spring Framework” provides an introduction to load-time weaving for Spring applications using AspectJ. 9.8.1 Using AspectJ to dependency inject domain objects with Spring The Spring container instantiates and configures beans defined in your application context. It is also possible to ask a bean factory to configure a pre-existing object given the name of a bean definition containing the configuration to be applied. The contains an annotation-driven aspect that exploits this capability to allow dependency injection of any object. The support is intended to be used for objects created outside of the control of any container. Domain objects often fall into this category because they are often created programmatically using the operator, or by an ORM tool as a result of a database query. The annotation marks a class as eligible for Spring-driven configuration. In the simplest case it can be used just as a marker annotation: When used as a marker interface in this way, Spring will configure new instances of the annotated type ( in this case) using a bean definition (typically prototype-scoped) with the same name as the fully-qualified type name ( ). Since the default name for a bean is the fully-qualified name of its type, a convenient way to declare the prototype definition is simply to omit the attribute: If you want to explicitly specify the name of the prototype bean definition to use, you can do so directly in the annotation: Spring will now look for a bean definition named \" \" and use that as the definition to configure new instances. You can also use autowiring to avoid having to specify a dedicated bean definition at all. To have Spring apply autowiring use the ' ' property of the annotation: specify either or for autowiring by type or by name respectively. As an alternative, as of Spring 2.5 it is preferable to specify explicit, annotation-driven dependency injection for your beans by using or at the field or method level (see Section 5.9, “Annotation-based container configuration” for further details). Finally you can enable Spring dependency checking for the object references in the newly created and configured object by using the attribute (for example: ). If this attribute is set to true, then Spring will validate after configuration that all properties (which are not primitives or collections) have been set. Using the annotation on its own does nothing of course. It is the in that acts on the presence of the annotation. In essence the aspect says \"after returning from the initialization of a new object of a type annotated with , configure the newly created object using Spring in accordance with the properties of the annotation\". In this context, initialization refers to newly instantiated objects (e.g., objects instantiated with the ' ' operator) as well as to objects that are undergoing deserialization (e.g., via readResolve()). One of the key phrases in the above paragraph is 'in essence'. For most cases, the exact semantics of 'after returning from the initialization of a new object' will be fine... in this context, 'after initialization' means that the dependencies will be injected after the object has been constructed - this means that the dependencies will not be available for use in the constructor bodies of the class. If you want the dependencies to be injected before the constructor bodies execute, and thus be available for use in the body of the constructors, then you need to define this on the declaration like so: You can find out more information about the language semantics of the various pointcut types in AspectJ in this appendix of the AspectJ Programming Guide. For this to work the annotated types must be woven with the AspectJ weaver - you can either use a build-time Ant or Maven task to do this (see for example the AspectJ Development Environment Guide) or load-time weaving (see Section 9.8.4, “Load-time weaving with AspectJ in the Spring Framework”). The itself needs configuring by Spring (in order to obtain a reference to the bean factory that is to be used to configure new objects). If you are using Java based configuration simply add to any class. If you prefer XML based configuration, the Spring namespace defines a convenient element: If you are using the DTD instead of schema, the equivalent definition is: Instances of objects created before the aspect has been configured will result in a message being issued to the debug log and no configuration of the object taking place. An example might be a bean in the Spring configuration that creates domain objects when it is initialized by Spring. In this case you can use the \"depends-on\" bean attribute to manually specify that the bean depends on the configuration aspect. Do not activate processing through the bean configurer aspect unless you really mean to rely on its semantics at runtime. In particular, make sure that you do not use on bean classes which are registered as regular Spring beans with the container: You would get double initialization otherwise, once through the container and once through the aspect. One of the goals of the support is to enable independent unit testing of domain objects without the difficulties associated with hard-coded lookups. If types have not been woven by AspectJ then the annotation has no affect during unit testing, and you can simply set mock or stub property references in the object under test and proceed as normal. If types have been woven by AspectJ then you can still unit test outside of the container as normal, but you will see a warning message each time that you construct an object indicating that it has not been configured by Spring. The used to implement the support is an AspectJ singleton aspect. The scope of a singleton aspect is the same as the scope of members, that is to say there is one aspect instance per classloader that defines the type. This means that if you define multiple application contexts within the same classloader hierarchy you need to consider where to define the bean and where to place on the classpath. Consider a typical Spring web-app configuration with a shared parent application context defining common business services and everything needed to support them, and one child application context per servlet containing definitions particular to that servlet. All of these contexts will co-exist within the same classloader hierarchy, and so the can only hold a reference to one of them. In this case we recommend defining the bean in the shared (parent) application context: this defines the services that you are likely to want to inject into domain objects. A consequence is that you cannot configure domain objects with references to beans defined in the child (servlet-specific) contexts using the @Configurable mechanism (probably not something you want to do anyway!). When deploying multiple web-apps within the same container, ensure that each web-application loads the types in using its own classloader (for example, by placing in ). If is only added to the container wide classpath (and hence loaded by the shared parent classloader), all web applications will share the same aspect instance which is probably not what you want. In addition to the aspect, contains an AspectJ aspect that can be used to drive Spring's transaction management for types and methods annotated with the annotation. This is primarily intended for users who want to use the Spring Framework's transaction support outside of the Spring container. The aspect that interprets annotations is the . When using this aspect, you must annotate the implementation class (and/or methods within that class), not the interface (if any) that the class implements. AspectJ follows Java's rule that annotations on interfaces are not inherited. A annotation on a class specifies the default transaction semantics for the execution of any public operation in the class. A annotation on a method within the class overrides the default transaction semantics given by the class annotation (if present). Methods with , , and default visibility may all be annotated. Annotating and default visibility methods directly is the only way to get transaction demarcation for the execution of such methods. For AspectJ programmers that want to use the Spring configuration and transaction management support but don't want to (or cannot) use annotations, also contains aspects you can extend to provide your own pointcut definitions. See the sources for the and aspects for more information. As an example, the following excerpt shows how you could write an aspect to configure all instances of objects defined in the domain model using prototype bean definitions that match the fully-qualified class names: aspect DomainObjectConfiguration AbstractBeanConfigurerAspect { DomainObjectConfiguration() { setBeanWiringInfoResolver( ClassNameBeanWiringInfoResolver()); } // the creation of a new bean (any object in the domain model) pointcut beanCreation(Object beanInstance) : initialization( (..)) && SystemArchitecture.inDomainModel() && (beanInstance); } When using AspectJ aspects with Spring applications, it is natural to both want and expect to be able to configure such aspects using Spring. The AspectJ runtime itself is responsible for aspect creation, and the means of configuring the AspectJ created aspects via Spring depends on the AspectJ instantiation model (the ' ' clause) used by the aspect. The majority of AspectJ aspects are singleton aspects. Configuration of these aspects is very easy: simply create a bean definition referencing the aspect type as normal, and include the bean attribute . This ensures that Spring obtains the aspect instance by asking AspectJ for it rather than trying to create an instance itself. For example: Non-singleton aspects are harder to configure: however it is possible to do so by creating prototype bean definitions and using the support from to configure the aspect instances once they have bean created by the AspectJ runtime. If you have some @AspectJ aspects that you want to weave with AspectJ (for example, using load-time weaving for domain model types) and other @AspectJ aspects that you want to use with Spring AOP, and these aspects are all configured using Spring, then you will need to tell the Spring AOP @AspectJ autoproxying support which exact subset of the @AspectJ aspects defined in the configuration should be used for autoproxying. You can do this by using one or more elements inside the declaration. Each element specifies a name pattern, and only beans with names matched by at least one of the patterns will be used for Spring AOP autoproxy configuration: Do not be misled by the name of the element: using it will result in the creation of Spring AOP proxies. The @AspectJ style of aspect declaration is just being used here, but the AspectJ runtime is not involved. 9.8.4 Load-time weaving with AspectJ in the Spring Framework Load-time weaving (LTW) refers to the process of weaving AspectJ aspects into an application's class files as they are being loaded into the Java virtual machine (JVM). The focus of this section is on configuring and using LTW in the specific context of the Spring Framework: this section is not an introduction to LTW though. For full details on the specifics of LTW and configuring LTW with just AspectJ (with Spring not being involved at all), see the LTW section of the AspectJ Development Environment Guide. The value-add that the Spring Framework brings to AspectJ LTW is in enabling much finer-grained control over the weaving process. 'Vanilla' AspectJ LTW is effected using a Java (5+) agent, which is switched on by specifying a VM argument when starting up a JVM. It is thus a JVM-wide setting, which may be fine in some situations, but often is a little too coarse. Spring-enabled LTW enables you to switch on LTW on a per- basis, which obviously is more fine-grained and which can make more sense in a 'single-JVM-multiple-application' environment (such as is found in a typical application server environment). Further, in certain environments, this support enables load-time weaving without making any modifications to the application server's launch script that will be needed to add or (as we describe later in this section) (previously named ). Developers simply modify one or more files that form the application context to enable load-time weaving instead of relying on administrators who typically are in charge of the deployment configuration such as the launch script. Now that the sales pitch is over, let us first walk through a quick example of AspectJ LTW using Spring, followed by detailed specifics about elements introduced in the following example. For a complete example, please see the Petclinic sample application. Let us assume that you are an application developer who has been tasked with diagnosing the cause of some performance problems in a system. Rather than break out a profiling tool, what we are going to do is switch on a simple profiling aspect that will enable us to very quickly get some performance metrics, so that we can then apply a finer-grained profiling tool to that specific area immediately afterwards. The example presented here uses XML style configuration, it is also possible to configure and use @AspectJ with Java Configuration. Specifically the annotation can be used as an alternative to (see below for details). Here is the profiling aspect. Nothing too fancy, just a quick-and-dirty time-based profiler, using the @AspectJ-style of aspect declaration. We will also need to create an ' ' file, to inform the AspectJ weaver that we want to weave our into our classes. This file convention, namely the presence of a file (or files) on the Java classpath called ' ' is standard AspectJ. <!DOCTYPE aspectj PUBLIC \"-//AspectJ//DTD//EN\" \"http://www.eclipse.org/aspectj/dtd/aspectj.dtd\"> <!-- only weave classes in our application-specific packages --> = <!-- weave in just this aspect --> = Now to the Spring-specific portion of the configuration. We need to configure a (all explained later, just take it on trust for now). This load-time weaver is the essential component responsible for weaving the aspect configuration in one or more ' ' files into the classes in your application. The good thing is that it does not require a lot of configuration, as can be seen below (there are some more options that you can specify, but these are detailed later). = = = = <!-- a service object; we will be profiling its methods --> = = <!-- this switches on the load-time weaving --> Now that all the required artifacts are in place - the aspect, the ' ' file, and the Spring configuration -, let us create a simple driver class with a method to demonstrate the LTW in action. foo; org.springframework.context.support.ClassPathXmlApplicationContext; Main { main(String[] args) { ApplicationContext ctx = ClassPathXmlApplicationContext( , Main. ); EntitlementCalculationService entitlementCalculationService = (EntitlementCalculationService) ctx.getBean( ); // the profiling aspect is 'woven' around this method execution entitlementCalculationService.calculateEntitlement(); } } There is one last thing to do. The introduction to this section did say that one could switch on LTW selectively on a per- basis with Spring, and this is true. However, just for this example, we are going to use a Java agent (supplied with Spring) to switch on the LTW. This is the command line we will use to run the above class: The ' ' is a Java 5+ flag for specifying and enabling agents to instrument programs running on the JVM. The Spring Framework ships with such an agent, the , which is packaged in the that was supplied as the value of the argument in the above example. The output from the execution of the program will look something like that below. (I have introduced a statement into the implementation so that the profiler actually captures something other than 0 milliseconds - the milliseconds is not an overhead introduced by the AOP :) ) Since this LTW is effected using full-blown AspectJ, we are not just limited to advising Spring beans; the following slight variation on the program will yield the same result. foo; org.springframework.context.support.ClassPathXmlApplicationContext; Main { main(String[] args) { ClassPathXmlApplicationContext( , Main. ); EntitlementCalculationService entitlementCalculationService = StubEntitlementCalculationService(); // the profiling aspect will be 'woven' around this method execution entitlementCalculationService.calculateEntitlement(); } } Notice how in the above program we are simply bootstrapping the Spring container, and then creating a new instance of the totally outside the context of Spring... the profiling advice still gets woven in. The example admittedly is simplistic... however the basics of the LTW support in Spring have all been introduced in the above example, and the rest of this section will explain the 'why' behind each bit of configuration and usage in detail. The used in this example may be basic, but it is quite useful. It is a nice example of a development-time aspect that developers can use during development (of course), and then quite easily exclude from builds of the application being deployed into UAT or production. The aspects that you use in LTW have to be AspectJ aspects. They can be written in either the AspectJ language itself or you can write your aspects in the @AspectJ-style. The latter option is of course only an option if you are using Java 5+, but it does mean that your aspects are then both valid AspectJ and Spring AOP aspects. Furthermore, the compiled aspect classes need to be available on the classpath. The AspectJ LTW infrastructure is configured using one or more ' ' files, that are on the Java classpath (either directly, or more typically in jar files). The structure and contents of this file is detailed in the main AspectJ reference documentation, and the interested reader is referred to that resource. (I appreciate that this section is brief, but the ' ' file is 100% AspectJ - there is no Spring-specific information or semantics that apply to it, and so there is no extra value that I can contribute either as a result), so rather than rehash the quite satisfactory section that the AspectJ developers wrote, I am just directing you there.) At a minimum you will need the following libraries to use the Spring Framework's support for AspectJ LTW: If you are using the Spring-provided agent to enable instrumentation, you will also need: The key component in Spring's LTW support is the interface (in the package), and the numerous implementations of it that ship with the Spring distribution. A is responsible for adding one or more to a at runtime, which opens the door to all manner of interesting applications, one of which happens to be the LTW of aspects. If you are unfamiliar with the idea of runtime class file transformation, you are encouraged to read the Javadoc API documentation for the package before continuing. This is not a huge chore because there is - rather annoyingly - precious little documentation there... the key interfaces and classes will at least be laid out in front of you for reference as you read through this section. Configuring a for a particular can be as easy as adding one line. (Please note that you almost certainly will need to be using an as your Spring container - typically a will not be enough because the LTW support makes use of .) To enable the Spring Framework's LTW support, you need to configure a , which typically is done using the annotation. Alternatively, if you prefer XML based configuration, use the element. Note that the element is defined in the ' ' namespace. The above configuration will define and register a number of LTW-specific infrastructure beans for you automatically, such as a and an . The default is the class, which attempts to decorate an automatically detected : the exact type of that will be 'automatically detected' is dependent upon your runtime environment (summarized in the following table). Fallback, expecting the underlying ClassLoader to follow common conventions (e.g. applicable to and Resin) \n\n Note that these are just the that are autodetected when using the : it is of course possible to specify exactly which implementation that you wish to use. To specify a specific with Java configuration implement the interface and override the method: If you are using XML based configuration you can specify the fully-qualified classname as the value of the ' ' attribute on the element: The that is defined and registered by the configuration can be later retrieved from the Spring container using the well-known name ' '. Remember that the exists just as a mechanism for Spring's LTW infrastructure to add one or more . The actual that does the LTW is the (from the package) class. See the class-level Javadoc for the class for further details, because the specifics of how the weaving is actually effected is beyond the scope of this section. There is one final attribute of the configuration left to discuss: the ' ' attribute (or ' ' if you are using XML). This is a simple attribute that controls whether LTW is enabled or not, it is as simple as that. It accepts one of three possible values, summarized below, with the default value if the attribute is not present being ' ' AspectJ weaving is on, and aspects will be woven at load-time as appropriate. LTW is off... no aspect will be woven at load-time. If the Spring LTW infrastructure can find at least one ' ' file, then AspectJ weaving is on, else it is off. This is the default value. \n\n This last section contains any additional settings and configuration that you will need when using Spring's LTW support in environments such as application servers and web containers. Apache Tomcat's default class loader does not support class transformation which is why Spring provides an enhanced implementation that addresses this need. Named , the loader works on Tomcat 5.0 and above and can be registered individually for each web application as follows:\n• \n• Copy into $CATALINA_HOME/lib, where $CATALINA_HOME represents the root of the Tomcat installation)\n• Instruct Tomcat to use the custom class loader (instead of the default) by editing the web application context file:\n• None per-web application configuration which can be deployed either on the server-side at $CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml or embedded inside the web-app archive at META-INF/context.xml For efficiency, the embedded per-web-app configuration style is recommended because it will impact only applications that use the custom class loader and does not require any changes to the server configuration. See the Tomcat 6.0.x documentation for more details about available context locations.\n• \n• Copy into $CATALINA_HOME/server/lib, where $CATALINA_HOME represents the root of the Tomcat installation.\n• Instruct Tomcat to use the custom class loader instead of the default one by editing the web application context file:\n• None per-web application configuration which can be deployed either on the server-side at $CATALINA_HOME/conf/[enginename]/[hostname]/[webapp]-context.xml or embedded inside the web-app archive at META-INF/context.xml For efficiency, the embedded web-app configuration style is recommended recommended because it will impact only applications that use the class loader. See the Tomcat 5.x documentation for more details about available context locations. Tomcat versions prior to 5.5.20 contained a bug in the XML configuration parsing that prevented usage of the tag inside server.xml configuration, regardless of whether a class loader is specified or whether it is the official or a custom one. See Tomcat's bugzilla for more details. In Tomcat 5.5.x, versions 5.5.20 or later, you should set useSystemClassLoaderAsParent to to fix this problem: This setting is not needed on Tomcat 6 or higher. Alternatively, consider the use of the Spring-provided generic VM agent, to be specified in Tomcat's launch script (see above). This will make instrumentation available to all deployed web applications, no matter what ClassLoader they happen to run on. Recent versions of BEA WebLogic (version 10 and above), IBM WebSphere Application Server (version 7 and above), Oracle Containers for Java EE (OC4J 10.1.3.1 and above), Resin (3.1 and above) and JBoss (5.x or above) provide a ClassLoader that is capable of local instrumentation. Spring's native LTW leverages such ClassLoaders to enable AspectJ weaving. You can enable LTW by simply activating load-time weaving as described earlier. Specifically, you do not need to modify the launch script to add . Note that GlassFish instrumentation-capable ClassLoader is available only in its EAR environment. For GlassFish web applications, follow the Tomcat setup instructions as outlined above. Note that on JBoss 6.x, the app server scanning needs to be disabled to prevent it from loading the classes before the application actually starts. A quick workaround is to add to your artifact a file named with the following content: When class instrumentation is required in environments that do not support or are not supported by the existing implementations, a JDK agent can be the only solution. For such cases, Spring provides , which requires a Spring-specific (but very general) VM agent, (previously named ). To use it, you must start the virtual machine with the Spring agent, by supplying the following JVM options: Note that this requires modification of the VM launch script which may prevent you from using this in application server environments (depending on your operation policies). Additionally, the JDK agent will instrument the entire VM which can prove expensive. For performance reasons, it is recommended to use this configuration only if your target environment (such as Jetty) does not have (or does not support) a dedicated LTW."
    },
    {
        "link": "https://baeldung.com/spring-aop-annotation",
        "document": "In this article, we’ll implement a custom AOP annotation using the AOP support in Spring.\n\nFirst, we’ll give a high-level overview of AOP, explaining what it is and its advantages. Following this, we’ll implement our annotation step by step, gradually building up a more in-depth understanding of AOP concepts as we go.\n\nThe outcome will be a better understanding of AOP and the ability to create our custom Spring annotations in the future.\n\n2. What Is an AOP Annotation?\n\nTo quickly summarize, AOP stands for aspect orientated programming. Essentially, it is a way for adding behavior to existing code without modifying that code.\n\nFor a detailed introduction to AOP, there are articles on AOP pointcuts and advice. This article assumes we have a basic knowledge already.\n\nThe type of AOP that we will be implementing in this article is annotation driven. We may be familiar with this already if we’ve used the Spring @Transactional annotation:\n\nThe key here is non-invasiveness. By using annotation meta-data, our core business logic isn’t polluted with our transaction code. This makes it easier to reason about, refactor, and to test in isolation.\n\nSometimes, people developing Spring applications can see this as ‘Spring Magic’, without thinking in much detail about how it’s working. In reality, what’s happening isn’t particularly complicated. However, once we’ve completed the steps in this article, we will be able to create our own custom annotation in order to understand and leverage AOP.\n\nFor this example, we’ll be using Spring Boot, as its convention over configuration approach lets us get up and running as quickly as possible:\n\nNote that we’ve included the AOP starter, which pulls in the libraries we need to start implementing aspects.\n\nThe annotation we are going to create is one which will be used to log the amount of time it takes a method to execute. Let’s create our annotation:\n\nAlthough a relatively simple implementation, it’s worth noting what the two meta-annotations are used for.\n\nThe @Target annotation tells us where our annotation will be applicable. Here we are using ElementType.Method, which means it will only work on methods. If we tried to use the annotation anywhere else, then our code would fail to compile. This behavior makes sense, as our annotation will be used for logging method execution time.\n\nAnd @Retention just states whether the annotation will be available to the JVM at runtime or not. By default it is not, so Spring AOP would not be able to see the annotation. This is why it’s been reconfigured.\n\nNow we have our annotation, let’s create our aspect. This is just the module that will encapsulate our cross-cutting concern, which is our case is method execution time logging. All it is is a class, annotated with @Aspect:\n\nWe’ve also included the @Component annotation, as our class also needs to be a Spring bean to be detected. Essentially, this is the class where we will implement the logic that we want our custom annotation to inject.\n\nNow, let’s create our pointcut and advice. This will be an annotated method that lives in our aspect:\n\nTechnically this doesn’t change the behavior of anything yet, but there’s still quite a lot going on that needs analysis.\n\nFirst, we have annotated our method with @Around. This is our advice, and around advice means we are adding extra code both before and after method execution. There are other types of advice, such as before and after but they will be left out of scope for this article.\n\nNext, our @Around annotation has a point cut argument. Our pointcut just says, ‘Apply this advice any method which is annotated with @LogExecutionTime.’ There are lots of other types of pointcuts, but they will again be left out if scope.\n\nThe method logExecutionTime() itself is our advice. There is a single argument, ProceedingJoinPoint. In our case, this will be an executing method which has been annotated with @LogExecutionTime.\n\nFinally, when our annotated method ends up being called, what will happen is our advice will be called first. Then it’s up to our advice to decide what to do next. In our case, our advice is doing nothing other than calling proceed(), which is the just calling the original annotated method.\n\nNow we have our skeleton in place, all we need to do is add some extra logic to our advice. This will be what logs the execution time in addition to calling the original method. Let’s add this extra behavior to our advice:\n\nAgain, we’ve not done anything that’s particularly complicated here. We’ve just recorded the current time, executed the method, then printed the amount of time it took to the console. We’re also logging the method signature, which is provided to use the joinpoint instance. We would also be able to gain access to other bits of information if we wanted to, such as method arguments.\n\nNow, let’s try annotating a method with @LogExecutionTime, and then executing it to see what happens. Note that this must be a Spring Bean to work correctly:\n\nAfter execution, we should see the following logged to the console:\n\nIn this article, we’ve leveraged Spring Boot AOP to create our custom annotation, which we can apply to Spring beans to inject extra behavior to them at runtime."
    },
    {
        "link": "https://stackoverflow.com/questions/4829088/java-aspect-oriented-programming-with-annotations",
        "document": "How could one correctly use annotations to implement aspects, advice, join points, pointcuts and this so-called aspect weaver?\n\nIn a post entitled \"AOP Fundamentals\", I asked for a King's English explanation of what AOP is, and what it does. I received some very helpful answers and links to articles that helped fill me in on all the theory. But now AOP's got my full attention, and all these articles and chapter excerpts are fantastic, but in every single case they consist of lofty theory, vague UML models, and order of abstraction that are way too high-up for my liking. Here is my understanding of AOP theory:\n• Cross-cutting concerns such as Logging, Authenticating, Synchronizing, Validating, Exception Handling, etc. become highly-coupled in non-AOP systems as they are used universally by almost every component/module in the codebase.\n• AOP defines aspects (classes/methods) that abstract these cross-cutting concerns with the use of join points, advice, and pointcuts.\n• Advice - The actual code (method of an aspect, perhaps?) implementing the cross-cutting concern (i.e. doing the actual logging, validating, authenticating, etc.)\n• Join Point - An event that is triggered in non-AOP code that causes a particular aspect's advice to be executed (\"woven\" into the non-AOP code)\n• All aspects are modularized (LoggingAspect, AuthenticationAspect, ValidationAspect, etc.) into components and registered with an AspectWeaver. When non-AOP/POJO code comes across a join point, AspectWeaver \"weaves\" (integrates) the mapped advice around the non-AOP code:\n\nThe $64,000 Question: Is my understanding of Java-based AOP on target, or way off, and why? How could one correctly use annotations to implement aspects, advice, join points, pointcuts and this so-called aspect weaver?"
    },
    {
        "link": "https://medium.com/@2015-2-60-004/spring-aop-interceptors-beyond-http-requests-mastering-method-call-interception-e89a71d7530c",
        "document": "Spring AOP is for intercepting any method call within your application…..\n\nLet’s start by creating a component class for our SpringBoot application,\n\nWe may also need to add an extra dependency for the older version of the SpringBoot application.\n\nNow to understand how to work with AOP, first, we need to know the Core concepts of Spring AOP,\n\nJoinPoint: A JoinPoint represents a specific point during the execution of your program where advice (additional code) can be applied. JoinPoints are used in combination with Pointcuts and Advice in Spring AOP. This point could be the execution of a method, the handling of an exception, the setting or getting of an attribute, or even the execution of a constructor. It is basically a precise point in the program flow where additional behavior provided by an aspect(Advice) can be appended.\n\nA JoinPoint in Spring AOP typically contains the following information:\n• Signature: Provides information about the method being executed, including its name and parameters.\n• Target Object: The actual object (instance) on which the method is being executed.\n• Arguments: The arguments passed to the method.\n• Source Location: Information about the source location where the JoinPoint is being executed (e.g., class name, method name).\n\nPointcut: Pointcut is a very powerful mechanism of the Spring AOP, wherein you can specify, specific JoinPoints on which an Advice should be executed. Pointcut expressions enable you to select methods based on criteria, like method names, annotations, or different packages and classes. Pointcuts are a kind of criteria that is expressed with the help of AspectJ, and AspectJ happens to be a language for AOP. These expressions can be very expressive, enabling you to target the methods by name, return type, parameter types, annotations and so on.\n\nLet’s look at some examples to understand how Pointcuts are defined and used.\n• Example-1: This Pointcut targets all methods in the “com.example.service” package.\n• Example-2: This Pointcut targets all methods name starts with “find*” (e.g., findById, findAll).\n• Example-4: This Pointcut targets all methods in the “UserService” class.\n• Example-5: You can also combine Pointcuts using logical operators (&&, ||, !). For example, to create a Pointcut that matches all methods in the “service” package that are also annotated with “@Transactional” annotation.\n\nAdvice: Advice represents the action taken by an aspect at a particular JoinPoint. In other words, Advice is the actual code that is executed when a Pointcut is matched. By using different types of Advice (Before, AfterReturning, AfterThrowing, After, Around), one can perform actions at various stages of method execution. Each type of Advice is suited for different scenarios, providing flexibility in how and when one applies cross-cutting concerns in the application.\n\nThere are several types of Advice:\n• Before: Executed before the JoinPoint.\n• AfterReturning: Executed after the JoinPoint completes normally.\n• AfterThrowing: Executed if the JoinPoint throws an exception.\n• After: Executed after the JoinPoint completes, regardless of the outcome.\n• Around: Surrounds the JoinPoint, allowing you to perform custom behavior before and after method execution.\n\nNow let’s look at some examples…..\n• Example-1: Applying “Before” Advice using ‘@Befor’ annotation at logBeforeServiceMethods method. This method or advice will run before any methods within any class in the ‘com.example.service’ package and its sub-packages.\n\nparameter JoinPoint provides information about the intercepted method call.\n• Example-2: Applying “AfterReturning” Advice using ‘@AfterReturning’ annotation at logAfterFindMethods method. This method or advice will run after any method completes execution normally and whose name starts with the find keyword.\n\n‘Object result’ captures the return value of the intercepted method.\n• Example-3: Applying “AfterThrowing” Advice using ‘@AfterThrowing’ annotation at logAfterThrowingTransactionalMethods method. This method or advice will run if any method throws an exception having the Transactional annotation.\n\n‘Throwable error’ captures the exception thrown by the intercepted method.\n• Example-4: Applying “After” Advice using ‘@After’ annotation at logAfterUserServiceMethods method. Regardless of the outcome, this method or advice will run after all methods in the UserService class.\n• Example-5: ‘@Around(“serviceAndTransactionalMethods()”)’: This indicates that the logAroundServiceAndTransactionalMethods method should be executed around any method defined by the serviceAndTransactionalMethods Pointcut."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/spring-aop-example-tutorial-aspect-advice-pointcut-joinpoint-annotations",
        "document": "Spring Framework is developed on two core concepts - Dependency Injection and Aspect Oriented Programming ( Spring AOP).\n\nWe have already seen how Spring Dependency Injection works, today we will look into the core concepts of Aspect-Oriented Programming and how we can implement it using Spring Framework.\n\nMost of the enterprise applications have some common crosscutting concerns that are applicable to different types of Objects and modules. Some of the common crosscutting concerns are logging, transaction management, data validation, etc. In Object Oriented Programming, modularity of application is achieved by Classes whereas in Aspect Oriented Programming application modularity is achieved by Aspects and they are configured to cut across different classes. Spring AOP takes out the direct dependency of crosscutting tasks from classes that we can’t achieve through normal object oriented programming model. For example, we can have a separate class for logging but again the functional classes will have to call these methods to achieve logging across the application.\n\nBefore we dive into the implementation of Spring AOP implementation, we should understand the core concepts of AOP.\n• Aspect: An aspect is a class that implements enterprise application concerns that cut across multiple classes, such as transaction management. Aspects can be a normal class configured through Spring XML configuration or we can use Spring AspectJ integration to define a class as Aspect using annotation.\n• Join Point: A join point is a specific point in the application such as method execution, exception handling, changing object variable values, etc. In Spring AOP a join point is always the execution of a method.\n• Advice: Advices are actions taken for a particular join point. In terms of programming, they are methods that get executed when a certain join point with matching pointcut is reached in the application. You can think of Advices as Struts2 interceptors or Servlet Filters.\n• Pointcut: Pointcut is expressions that are matched with join points to determine whether advice needs to be executed or not. Pointcut uses different kinds of expressions that are matched with the join points and Spring framework uses the AspectJ pointcut expression language.\n• Target Object: They are the object on which advices are applied. Spring AOP is implemented using runtime proxies so this object is always a proxied object. What is means is that a subclass is created at runtime where the target method is overridden and advice are included based on their configuration.\n• AOP proxy: Spring AOP implementation uses JDK dynamic proxy to create the Proxy classes with target classes and advice invocations, these are called AOP proxy classes. We can also use CGLIB proxy by adding it as the dependency in the Spring AOP project.\n• Weaving: It is the process of linking aspects with other objects to create the advised proxy objects. This can be done at compile time, load time or at runtime. Spring AOP performs weaving at the runtime.\n\nBased on the execution strategy of advice, they are of the following types.\n• Before Advice: These advices runs before the execution of join point methods. We can use annotation to mark an advice type as Before advice.\n• After (finally) Advice: An advice that gets executed after the join point method finishes executing, whether normally or by throwing an exception. We can create after advice using annotation.\n• After Returning Advice: Sometimes we want advice methods to execute only if the join point method executes normally. We can use annotation to mark a method as after returning advice.\n• After Throwing Advice: This advice gets executed only when join point method throws exception, we can use it to rollback the transaction declaratively. We use annotation for this type of advice.\n• Around Advice: This is the most important and powerful advice. This advice surrounds the join point method and we can also choose whether to execute the join point method or not. We can write advice code that gets executed before and after the execution of the join point method. It is the responsibility of around advice to invoke the join point method and return values if the method is returning something. We use annotation to create around advice methods.\n\nThe points mentioned above may sound confusing but when we will look at the implementation of Spring AOP, things will be more clear. Let’s start creating a simple Spring project with AOP implementations. Spring provides support for using AspectJ annotations to create aspects and we will be using that for simplicity. All the above AOP annotations are defined in package. Spring Tool Suite provides useful information about the aspects, so I would suggest you use it. If you are not familiar with STS, I would recommend you to have a look at Spring MVC Tutorial where I have explained how to use it.\n\nCreate a new Simple Spring Maven project so that all the Spring Core libraries are included in the pom.xml files and we don’t need to include them explicitly. Our final project will look like the below image, we will look into the Spring core components and Aspect implementations in detail.\n\nSpring framework provides AOP support by default but since we are using AspectJ annotations for configuring aspects and advice, we would need to include them in the pom.xml file.\n\nNotice that I have added and dependencies (version 1.7.4) in the project. Also I have updated the Spring framework version to be the latest one as of date i.e 4.0.2.RELEASE.\n\nLet’s create a simple java bean that we will use for our example with some additional methods. Employee.java code:\n\nDid you noticed that setName() method is annotated with annotation. It is a custom java annotation defined by us in the project. We will look into it’s usage later on.\n\nLet’s create a service class to work with the Employee bean. EmployeeService.java code:\n\nI could have used Spring annotations to configure it as a Spring Component, but we will use XML based configuration in this project. EmployeeService class is very standard and just provides us an access point for Employee beans.\n\nIf you are using STS, you have the option to create “Spring Bean Configuration File” and chose AOP schema namespace but if you are using some other IDE, you can simply add it in the spring bean configuration file. My project bean configuration file looks like below. spring.xml:\n\nFor using Spring AOP in Spring beans, we need to do the following:\n• Add aop:aspectj-autoproxy element to enable Spring AspectJ support with auto proxy at runtime\n\nYou can see that I have a lot of aspects defined in the spring bean configuration file, it’s time to look into them one by one.\n\nImportant points in above aspect class are:\n• Aspect classes are required to have annotation.\n• @Before annotation is used to create Before advice\n• The string parameter passed in the annotation is the Pointcut expression\n• getNameAdvice() advice will execute for any Spring Bean method with signature . This is a very important point to remember, if we will create Employee bean using new operator the advices will not be applied. Only when we will use ApplicationContext to get the bean, advices will be applied.\n• We can use asterisk (*) as wild card in Pointcut expressions, getAllAdvice() will be applied for all the classes in package whose name starts with and doesn’t take any arguments.\n\nWe will look at the advice in action in a test class after we have looked into all the different types of advices.\n\nSometimes we have to use same Pointcut expression at multiple places, we can create an empty method with annotation and then use it as an expression in the advices. EmployeeAspectPointcut.java code:\n\nAbove example is very clear, rather than expression we are using method name in the advice annotation argument.\n\nWe can use JoinPoint as a parameter in the advice methods and using it get the method signature or the target object. We can use expression in the pointcut to be applied to any method that matches the argument pattern. If we use this, then we need to use the same name in the advice method from where the argument type is determined. We can use Generic objects also in the advice arguments. EmployeeAspectJoinPoint.java code:\n\nLet’s look at a simple aspect class with an example of After, After Throwing and After Returning advice. EmployeeAfterAspect.java code:\n\nWe can use in pointcut expression to apply the advice to all the methods in the class. We can use @AfterReturning advice to get the object returned by the advised method. We have throwException() method in the Employee bean to showcase the use of After Throwing advice.\n\nAs explained earlier, we can use Around aspect to cut the method execution before and after. We can use it to control whether the advised method will execute or not. We can also inspect the returned value and change it. This is the most powerful advice and needs to be applied properly. EmployeeAroundAspect.java code:\n\nAround advice are always required to have ProceedingJoinPoint as an argument and we should use it’s proceed() method to invoke the target object advised method. If advised method is returning something, it’s advice responsibility to return it to the caller program. For void methods, advice method can return null. Since around advice cut around the advised method, we can control the input and output of the method as well as it’s execution behavior.\n\nIf you look at all the above advice pointcut expressions, there are chances that they get applied to some other beans where it’s not intended. For example, someone can define a new spring bean with getName() method and the advice will start getting applied to that even though it was not intended. That’s why we should keep the scope of pointcut expression as narrow as possible. An alternative approach is to create a custom annotation and annotate the methods where we want the advice to be applied. This is the purpose of having Employee setName() method annotated with @Loggable annotation. Spring Framework @Transactional annotation is a great example of this approach for Spring Transaction Management. Loggable.java code:\n\nThe myAdvice() method will advice only setName() method. This is a very safe approach and whenever we want to apply the advice on any method, all we need is to annotate it with Loggable annotation.\n\nI always prefer annotation but we also have the option to configure aspects in the spring configuration file. For example, let’s say we have a class as below. EmployeeXMLConfigAspect.java code:\n\nWe can configure it by including the following configuration in the Spring Bean config file.\n\nAOP xml config elements purpose is clear from their name, so I won’t go into much detail about it.\n\nLet’s have a simple Spring program and see how all these aspects cut through the bean methods. SpringMain.java code:\n\nNow when we execute the above program, we get the following output.\n\nYou can see that advices are getting executed one by one based on their pointcut configurations. You should configure them one by one to avoid confusion. That’s all for Spring AOP Example Tutorial, I hope you learned the basics of AOP with Spring and can learn more from examples. Download the sample project from below link and play around with it."
    },
    {
        "link": "https://docs.spring.io/spring-framework/docs/1.2.x/reference/aop.html",
        "document": "Aspect-Oriented Programming (AOP) complements OOP by providing another way of thinking about program structure. While OO decomposes applications into a hierarchy of objects, AOP decomposes programs into aspects or concerns. This enables modularization of concerns such as transaction management that would otherwise cut across multiple objects. (Such concerns are often termed crosscutting concerns.) One of the key components of Spring is the AOP framework. While the Spring IoC containers (BeanFactory and ApplicationContext) do not depend on AOP, meaning you don't need to use AOP if you don't want to, AOP complements Spring IoC to provide a very capable middleware solution.\n• None To provide declarative enterprise services, especially as a replacement for EJB declarative services. The most important such service is declarative transaction management, which builds on Spring's transaction abstraction.\n• None To allow users to implement custom aspects, complementing their use of OOP with AOP. Thus you can view Spring AOP as either an enabling technology that allows Spring to provide declarative transaction management without EJB; or use the full power of the Spring AOP framework to implement custom aspects. If you are interested only in generic declarative services or other pre-packaged declarative middleware services such as pooling, you don't need to work directly with Spring AOP, and can skip most of this chapter. Let us begin by defining some central AOP concepts. These terms are not Spring-specific. Unfortunately, AOP terminology is not particularly intuitive. However, it would be even more confusing if Spring used its own terminology.\n• None Aspect: A modularization of a concern for which the implementation might otherwise cut across multiple objects. Transaction management is a good example of a crosscutting concern in J2EE applications. Aspects are implemented using Spring as Advisors or interceptors.\n• None Joinpoint: Point during the execution of a program, such as a method invocation or a particular exception being thrown. In Spring AOP, a joinpoint is always method invocation. Spring does not use the term joinpoint prominently; joinpoint information is accessible through methods on the argument passed to interceptors, and is evaluated by implementations of the interface.\n• None Advice: Action taken by the AOP framework at a particular joinpoint. Different types of advice include \"around,\" \"before\" and \"throws\" advice. Advice types are discussed below. Many AOP frameworks, including Spring, model an advice as an interceptor, maintaining a chain of interceptors \"around\" the joinpoint.\n• None Pointcut: A set of joinpoints specifying when an advice should fire. An AOP framework must allow developers to specify pointcuts: for example, using regular expressions.\n• None Introduction: Adding methods or fields to an advised class. Spring allows you to introduce new interfaces to any advised object. For example, you could use an introduction to make any object implement an interface, to simplify caching.\n• None Target object: Object containing the joinpoint. Also referred to as advised or proxied object.\n• None AOP proxy: Object created by the AOP framework, including advice. In Spring, an AOP proxy will be a JDK dynamic proxy or a CGLIB proxy.\n• None Weaving: Assembling aspects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), or at runtime. Spring, like other pure Java AOP frameworks, performs weaving at runtime.\n• None Around advice: Advice that surrounds a joinpoint such as a method invocation. This is the most powerful kind of advice. Around advices will perform custom behavior before and after the method invocation. They are responsible for choosing whether to proceed to the joinpoint or to shortcut executing by returning their own return value or throwing an exception.\n• None Before advice: Advice that executes before a joinpoint, but which does not have the ability to prevent execution flow proceeding to the joinpoint (unless it throws an exception).\n• None Throws advice: Advice to be executed if a method throws an exception. Spring provides strongly typed throws advice, so you can write code that catches the exception (and subclasses) you're interested in, without needing to cast from Throwable or Exception.\n• None After returning advice: Advice to be executed after a joinpoint completes normally: for example, if a method returns without throwing an exception. Around advice is the most general kind of advice. Most interception-based AOP frameworks, such as Nanning Aspects, provide only around advice. As Spring, like AspectJ, provides a full range of advice types, we recommend that you use the least powerful advice type that can implement the required behavior. For example, if you need only to update a cache with the return value of a method, you are better off implementing an after returning advice than an around advice, although an around advice can accomplish the same thing. Using the most specific advice type provides a simpler programming model with less potential for errors. For example, you don't need to invoke the method on the MethodInvocation used for around advice, and hence can't fail to invoke it. The pointcut concept is the key to AOP, distinguishing AOP from older technologies offering interception. Pointcuts enable advice to be targeted independently of the OO hierarchy. For example, an around advice providing declarative transaction management can be applied to a set of methods spanning multiple objects. Thus pointcuts provide the structural element of AOP. Spring AOP is implemented in pure Java. There is no need for a special compilation process. Spring AOP does not need to control the class loader hierarchy, and is thus suitable for use in a J2EE web container or application server. Spring currently supports interception of method invocations. Field interception is not implemented, although support for field interception could be added without breaking the core Spring AOP APIs. Field interception arguably violates OO encapsulation. We don't believe it is wise in application development. If you require field interception, consider using AspectJ. Spring provides classes to represent pointcuts and different advice types. Spring uses the term advisor for an object representing an aspect, including both an advice and a pointcut targeting it to specific joinpoints. Different advice types are (from the AOP Alliance interception API); and the advice interfaces defined in the package. All advices must implement the tag interface. Advices supported out the box are ; ; ; and . We'll discuss advice types in detail below. Spring implements the AOP Alliance interception interfaces (http://www.sourceforge.net/projects/aopalliance). Around advice must implement the AOP Alliance interface. Implementations of this interface can run in Spring or any other AOP Alliance compliant implementation. Currently JAC implements the AOP Alliance interfaces, and Nanning and Dynaop are likely to in early 2004. Spring's approach to AOP differs from that of most other AOP frameworks. The aim is not to provide the most complete AOP implementation (although Spring AOP is quite capable); it is rather to provide a close integration between AOP implementation and Spring IoC to help solve common problems in enterprise applications. Thus, for example, Spring's AOP functionality is normally used in conjunction with a Spring IoC container. AOP advice is specified using normal bean definition syntax (although this allows powerful \"autoproxying\" capabilities); advice and pointcuts are themselves managed by Spring IoC: a crucial difference from other AOP implementations. There are some things you can't do easily or efficiently with Spring AOP, such as advise very fine-grained objects. AspectJ is probably the best choice in such cases. However, our experience is that Spring AOP provides an excellent solution to most problems in J2EE applications that are amenable to AOP. Spring AOP will never strive to compete with AspectJ or AspectWerkz to provide a comprehensive AOP solution. We believe that both proxy-based frameworks like Spring and full-blown frameworks such as AspectJ are valuable, and that they are complementary, rather than in competition. Thus a major priority for Spring 1.1 will be seamlessly integrating Spring AOP and IoC with AspectJ, to enable all uses of AOP to be catered for within a consistent Spring-based application architecture. This integration will not affect the Spring AOP API or the AOP Alliance API; Spring AOP will remain backward-compatible. Spring defaults to using J2SE dynamic proxies for AOP proxies. This enables any interface or set of interfaces to be proxied. Spring can also use CGLIB proxies. This is necessary to proxy classes, rather than interfaces. CGLIB is used by default if a business object doesn't implement an interface. As it's good practice to program to interfaces rather than classes, business objects normally will implement one or more business interfaces. It is possible to force the use of CGLIB: we'll discuss this below, and explain why you'd want to do this. Beyond Spring 1.0, Spring may offer additional types of AOP proxy, including wholly generated classes. This won't affect the programming model.\n\nLet's look at how Spring handles the crucial pointcut concept. Spring's pointcut model enables pointcut reuse independent of advice types. It's possible to target different advice using the same pointcut. The interface is the central interface, used to target advices to particular classes and methods. The complete interface is shown below: Splitting the interface into two parts allows reuse of class and method matching parts, and fine-grained composition operations (such as performing a \"union\" with another method matcher). The interface is used to restrict the pointcut to a given set of target classes. If the method always returns true, all target classes will be matched: The interface is normally more important. The complete interface is shown below: The method is used to test whether this pointcut will ever match a given method on a target class. This evaluation can be performed when an AOP proxy is created, to avoid the need for a test on every method invocation. If the 2-argument matches method returns true for a given method, and the method for the MethodMatcher returns true, the 3-argument matches method will be invoked on every method invocation. This enables a pointcut to look at the arguments passed to the method invocation immediately before the target advice is to execute. Most MethodMatchers are static, meaning that their method returns false. In this case, the 3-argument matches method will never be invoked. If possible, try to make pointcuts static, allowing the AOP framework to cache the results of pointcut evaluation when an AOP proxy is created. Union means the methods that either pointcut matches. Intersection means the methods that both pointcuts match. Union is usually more useful. Pointcuts can be composed using the static methods in the org.springframework.aop.support.Pointcuts class, or using the ComposablePointcut class in the same package. Spring provides several convenient pointcut implementations. Some can be used out of the box; others are intended to be subclassed in application-specific pointcuts. Static pointcuts are based on method and target class, and cannot take into account the method's arguments. Static pointcuts are sufficient--and best--for most usages. It's possible for Spring to evaluate a static pointcut only once, when a method is first invoked: after that, there is no need to evaluate the pointcut again with each method invocation. Let's consider some static pointcut implementations included with Spring. One obvious way to specific static pointcuts is regular expressions. Several AOP frameworks besides Spring make this possible. is a generic regular expression pointcut, using Perl 5 regular expression syntax. the class depends on Jakarta ORO for regular expression matching. Spring also provides the class that uses the regular expression support in JDK 1.4+. Using the class, you can provide a list of pattern Strings. If any of these is a match, the pointcut will evaluate to true. (So the result is effectively the union of these pointcuts.) The usage is shown below: Spring provides a convenience class, , that allows us to reference an Advice also (Remember that an Advice can be an interceptor, before advice, throws advice etc.). Behind the scenes, Spring will use the on J2SE 1.4 or above, and will fall back to on older VMs. The use of can be forced by setting the property to true. Using simplifies wiring, as the one bean serves as both pointcut and advisor, as shown below: RegexpMethodPointcutAdvisor can be used with any Advice type. An important type of static pointcut is a metadata-driven pointcut. This uses the values of metadata attributes: typically, source-level metadata. Dynamic pointcuts are costlier to evaluate than static pointcuts. They take into account method arguments, as well as static information. This means that they must be evaluated with every method invocation; the result cannot be cached, as arguments will vary. The main example is the pointcut. Spring control flow pointcuts are conceptually similar to AspectJ cflow pointcuts, although less powerful. (There is currently no way to specify that a pointcut executes below another pointcut.) A control flow pointcut matches the current call stack. For example, it might fire if the joinpoint was invoked by a method in the package, or by the class. Control flow pointcuts are specified using the class. Control flow pointcuts are significantly more expensive to evaluate at runtime than even other dynamic pointcuts. In Java 1.4, the cost is about 5 times that of other dynamic pointcuts; in Java 1.3 more than 10. Spring provides useful pointcut superclasses to help you to implement your own pointcuts. Because static pointcuts are most useful, you'll probably subclass StaticMethodMatcherPointcut, as shown below. This requires implemented just one abstract method (although it's possible to override other methods to customize behavior): There are also superclasses for dynamic pointcuts. You can use custom pointcuts with any advice type in Spring 1.0 RC2 and above. Because pointcuts in Spring are Java classes, rather than language features (as in AspectJ) it's possible to declare custom pointcuts, whether static or dynamic. However, there is no support out of the box for the sophisticated pointcut expressions that can be coded in AspectJ syntax. However, custom pointcuts in Spring can be arbitrarily complex. Later versions of Spring may offer support for \"semantic pointcuts\" as offered by JAC: for example, \"all methods that change instance variables in the target object.\"\n\nLet's now look at how Spring AOP handles advice. Spring advices can be shared across all advised objects, or unique to each advised object. This corresponds to per-class or per-instance advice. Per-class advice is used most often. It is appropriate for generic advice such as transaction advisors. These do not depend on the state of the proxied object or add new state; they merely act on the method and arguments. Per-instance advice is appropriate for introductions, to support mixins. In this case, the advice adds state to the proxied object. It's possible to use a mix of shared and per-instance advice in the same AOP proxy. Spring provides several advice types out of the box, and is extensible to support arbitrary advice types. Let us look at the basic concepts and standard advice types. The most fundamental advice type in Spring is interception around advice. Spring is compliant with the AOP Alliance interface for around advice using method interception. MethodInterceptors implementing around advice should implement the following interface: The MethodInvocation argument to the invoke() method exposes the method being invoked; the target joinpoint; the AOP proxy; and the arguments to the method. The invoke() method should return the invocation's result: the return value of the joinpoint. A simple MethodInterceptor implementation looks as follows: Note the call to the MethodInvocation's proceed() method. This proceeds down the interceptor chain towards the joinpoint. Most interceptors will invoke this method, and return its return value. However, a MethodInterceptor, like any around advice, can return a different value or throw an exception rather than invoke the proceed method. However, you don't want to do this without good reason! MethodInterceptors offer interoperability with other AOP Alliance-compliant AOP implementations. The other advice types discussed in the remainder of this section implement common AOP concepts, but in a Spring-specific way. While there is an advantage in using the most specific advice type, stick with MethodInterceptor around advice if you are likely to want to run the aspect in another AOP framework. Note that pointcuts are not currently interoperable between frameworks, and the AOP Alliance does not currently define pointcut interfaces. A simpler advice type is a before advice. This does not need a object, since it will only be called before entering the method. The main advantage of a before advice is that there is no need to invoke the method, and therefore no possibility of inadvertently failing to proceed down the interceptor chain. The interface is shown below. (Spring's API design would allow for field before advice, although the usual objects apply to field interception and it's unlikely that Spring will ever implement it). Note the the return type is . Before advice can insert custom behavior before the joinpoint executes, but cannot change the return value. If a before advice throws an exception, this will abort further execution of the interceptor chain. The exception will propagate back up the interceptor chain. If it is unchecked, or on the signature of the invoked method, it will be passed directly to the client; otherwise it will be wrapped in an unchecked exception by the AOP proxy. An example of a before advice in Spring, which counts all method invocations: Before advice can be used with any pointcut. Throws advice is invoked after the return of the joinpoint if the joinpoint threw an exception. Spring offers typed throws advice. Note that this means that the interface does not contain any methods: it is a tag interface identifying that the given object implements one or more typed throws advice methods. These should be of form Only the last argument is required. Thus there from one to four arguments, depending on whether the advice method is interested in the method and arguments. The following are examples of throws advices. This advice will be invoked if a is thrown (including subclasses): public class RemoteThrowsAdvice implements ThrowsAdvice { public void afterThrowing(RemoteException ex) throws Throwable { // Do something with remote exception } } The following advice is invoked if a ServletException is thrown. Unlike the above advice, it declares 4 arguments, so that it has access to the invoked method, method arguments and target object: public class ServletThrowsAdviceWithArguments implements ThrowsAdvice { public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) { // Do something will all arguments } } The final example illustrates how these two methods could be used in a single class, which handles both and . Any number of throws advice methods can be combined in a single class. public static class CombinedThrowsAdvice implements ThrowsAdvice { public void afterThrowing(RemoteException ex) throws Throwable { // Do something with remote exception } public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) { // Do something will all arguments } } Throws advice can be used with any pointcut. An after returning advice in Spring must implement the org.springframework.aop.AfterReturningAdvice interface, shown below: An after returning advice has access to the return value (which it cannot modify), invoked method, methods arguments and target. The following after returning advice counts all successful method invocations that have not thrown exceptions: This advice doesn't change the execution path. If it throws an exception, this will be thrown up the interceptor chain instead of the return value. After returning advice can be used with any pointcut. Introduction requires an , and an , implementing the following interface: The method inherited from the AOP Alliance interface must implement the introduction: that is, if the invoked method is on an introduced interface, the introduction interceptor is responsible for handling the method call--it cannot invoke . Introduction advice cannot be used with any pointcut, as it applies only at class, rather than method, level. You can only use introduction advice with the , which has the following methods: There is no , and hence no , associated with introduction advice. Only class filtering is logical. The method returns the interfaces introduced by this advisor. The method is used internally to see whether or not the introduced interfaces can be implemented by the configured . Themethod is used internally to see whether or not the introduced interfaces can be implemented by the configured Let's look at a simple example from the Spring test suite. Let's suppose we want to introduce the following interface to one or more objects: This illustrates a mixin. We want to be able to cast advised objects to Lockable, whatever their type, and call lock and unlock methods. If we call the lock() method, we want all setter methods to throw a . Thus we can add an aspect that provides the ability to make objects immutable, without them having any knowledge of it: a good example of AOP. Firstly, we'll need an that does the heavy lifting. In this case, we extend the convenience class. We could implement IntroductionInterceptor directly, but using is best for most cases. The is designed to delegate an introduction to an actual implementation of the introduced interface(s), concealing the use of interception to do so. The delegate can be set to any object using a constructor argument; the default delegate (when the no-arg constructor is used) is this. Thus in the example below, the delegate is the subclass of . Given a delegate (by default itself) a instance looks for all interfaces implemented by the delegate (other than IntroductionInterceptor), and will support introductions against any of them. It's possible for subclasses such as to call the method to suppress interfaces that should not be exposed. However, no matter how many interfaces an is prepared to support, the used will control which interfaces are actually exposed. An introduced interface will conceal any implementation of the same interface by the target. Thus LockMixin subclasses and implements Lockable itself. The superclass automatically picks up that Lockable can be supported for introduction, so we don't need to specify that. We could introduce any number of interfaces in this way. Note the use of the instance variable. This effectively adds additional state to that held in the target object. Often it isn't necessary to override the method: the implementation--which calls the delegate method if the method is introduced, otherwise proceeds towards the joinpoint--is usually sufficient. In the present case, we need to add a check: no setter method can be invoked if in locked mode. The introduction advisor required is simple. All it needs to do is hold a distinct instance, and specify the introduced interfaces--in this case, just . A more complex example might take a reference to the introduction interceptor (which would be defined as a prototype): in this case, there's no configuration relevant for a , so we simply create it using . We can apply this advisor very simply: it requires no configuration. (However, it is necessary: It's impossible to use an without an IntroductionAdvisor.) As usual with introductions, the advisor must be per-instance, as it is stateful. We need a different instance of , and hence , for each advised object. The advisor comprises part of the advised object's state. We can apply this advisor programmatically, using the method, or (the recommended way) in XML configuration, like any other advisor. All proxy creation choices discussed below, including \"auto proxy creators,\" correctly handle introductions and stateful mixins.\n\n6.5. Using the ProxyFactoryBean to create AOP proxies If you're using the Spring IoC container (an ApplicationContext or BeanFactory) for your business objects--and you should be!--you will want to use one of Spring's AOP FactoryBeans. (Remember that a factory bean introduces a layer of indirection, enabling it to create objects of a different type). The basic way to create an AOP proxy in Spring is to use the org.springframework.aop.framework.ProxyFactoryBean. This gives complete control over the pointcuts and advice that will apply, and their ordering. However, there are simpler options that are preferable if you don't need such control. The , like other Spring implementations, introduces a level of indirection. If you define a with name , what objects referencing see is not the instance itself, but an object created by the implementation of the method. This method will create an AOP proxy wrapping a target object. One of the most important benefits of using a or other IoC-aware class to create AOP proxies, is that it means that advices and pointcuts can also be managed by IoC. This is a powerful feature, enabling certain approaches that are hard to achieve with other AOP frameworks. For example, an advice may itself reference application objects (besides the target, which should be available in any AOP framework), benefiting from all the pluggability provided by Dependency Injection. Like most FactoryBean implementations provided with Spring, is itself a JavaBean. Its properties are used to:\n• None Specify the target you want to proxy\n• None Specify whether to use CGLIB Some key properties are inherited from : the superclass for all AOP proxy factories. These include:\n• None : true if we should proxy the target class, rather than its interfaces. If this is true we need to use CGLIB.\n• None : whether to apply aggressive optimization to created proxies. Don't use this setting unless you understand how the relevant AOP proxy handles optimization. This is currently used only for CGLIB proxies; it has no effect with JDK dynamic proxies (the default).\n• None : whether advice changes should be disallowed once the proxy factory has been configured. Default is false.\n• None : whether the current proxy should be exposed in a ThreadLocal so that it can be accessed by the target. (It's available via the MethodInvocation without the need for a ThreadLocal.) If a target needs to obtain the proxy and exposeProxy is true, the target can use the method.\n• None : the implementation of AopProxyFactory to use. Offers a way of customizing whether to use dynamic proxies, CGLIB or any other proxy strategy. The default implementation will choose dynamic proxies or CGLIB appropriately. There should be no need to use this property; it's intended to allow the addition of new proxy types in Spring 1.1.\n• None : array of String interface names. If this isn't supplied, a CGLIB proxy for the target class will be used\n• None : String array of Advisor, interceptor or other advice names to apply. Ordering is significant. First come, first serve that is. The first interceptor in the list will be the first to be able to intercept the invocation (of course if it concerns a regular or . The names are bean names in the current factory, including bean names from ancestor factories. You can't mention bean references here since doing so would result in the ProxyFactoryBean ignoring the singleton setting of the advise. You can append an interceptor name with an asterisk (*). This will result in the application of all advisor beans with names starting with the part before the asterisk to be applied. An example of using this feature can be found below.\n• None singleton: whether or not the factory should return a single object, no matter how often the method is called. Several implementations offer such a method. Default value is true. If you want to use stateful advice--for example, for stateful mixins--use prototype advices along with a singleton value of false. Let's look at a simple example of ProxyFactoryBean in action. This example involves:\n• None A target bean that will be proxied. This is the \"personTarget\" bean definition in the example below.\n• None An Advisor and an Interceptor used to provide advice.\n• None An AOP proxy bean definition specifying the target object (the personTarget bean) and the interfaces to proxy, along with the advices to apply. Note that the property takes a list of String: the bean names of the interceptor or advisors in the current factory. Advisors, interceptors, before, after returning and throws advice objects can be used. The ordering of advisors is significant. You might be wondering why the list doesn't hold bean references. The reason for this is that if the ProxyFactoryBean's singleton property is set to false, it must be able to return independent proxy instances. If any of the advisors is itself a prototype, an independent instance would need to be returned, so it's necessary to be able to obtain an instance of the prototype from the factory; holding a reference isn't sufficient. The \"person\" bean definition above can be used in place of a Person implementation, as follows: Other beans in the same IoC context can express a strongly typed dependency on it, as with an ordinary Java object: The class in this example would expose a property of type Person. As far as it's concerned, the AOP proxy can be used transparently in place of a \"real\" person implementation. However, its class would be a dynamic proxy class. It would be possible to cast it to the interface (discussed below). It's possible to conceal the distinction between target and proxy using an anonymous inner bean, as follows. Only the definition is different; the advice is included only for completeness: <bean id=\"myAdvisor\" class=\"com.mycompany.MyAdvisor\"> <property name=\"someProperty\"><value>Custom string property value</value></property> </bean> <bean id=\"debugInterceptor\" class=\"org.springframework.aop.interceptor.DebugInterceptor\"/> <bean id=\"person\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"> <property name=\"proxyInterfaces\"><value>com.mycompany.Person</value></property> <!-- Use inner bean, not local reference to target --> <property name=\"target\"> <bean class=\"com.mycompany.PersonImpl\"> <property name=\"name\"><value>Tony</value></property> <property name=\"age\"><value>51</value></property> </bean> </property> <property name=\"interceptorNames\"> <list> <value>myAdvisor</value> <value>debugInterceptor</value> </list> </property> </bean> This has the advantage that there's only one object of type : useful if we want to prevent users of the application context obtaining a reference to the un-advised object, or need to avoid any ambiguity with Spring IoC autowiring. There's also arguably an advantage in that the ProxyFactoryBean definition is self-contained. However, there are times when being able to obtain the un-advised target from the factory might actually be an advantage: for example, in certain test scenarios. What if you need to proxy a class, rather than one or more interfaces? Imagine that in our example above, there was no interface: we needed to advise a class called that didn't implement any business interface. In this case, you can configure Spring to use CGLIB proxying, rather than dynamic proxies. Simply set the property on the ProxyFactoryBean above to true. While it's best to program to interfaces, rather than classes, the ability to advise classes that don't implement interfaces can be useful when working with legacy code. (In general, Spring isn't prescriptive. While it makes it easy to apply good practices, it avoids forcing a particular approach.) If you want to you can force the use of CGLIB in any case, even if you do have interfaces. CGLIB proxying works by generating a subclass of the target class at runtime. Spring configures this generated subclass to delegate method calls to the original target: the subclass is used to implement the Decorator pattern, weaving in the advice. CGLIB proxying should generally be transparent to users. However, there are some issues to consider:\n• None methods can't be advised, as they can't be overridden.\n• None You'll need the CGLIB 2 binaries on your classpath; dynamic proxies are available with the JDK There's little performance difference between CGLIB proxying and dynamic proxies. As of Spring 1.0, dynamic proxies are slightly faster. However, this may change in the future. Performance should not be a decisive consideration in this case. By appending an asterisk to an interceptor name, all advisors with bean names matching the part before the asterisk, will be added to the advisor chain. This can come in handy if you need to add a standard set of 'global' advisors:\n\nOften we don't need the full power of the , because we're only interested in one aspect: For example, transaction management. There are a number of convenience factories we can use to create AOP proxies when we want to focus on a specific aspect. These are discussed in other chapters, so we'll just provide a quick survey of some of them here. The JPetStore sample application shipped with Spring shows the use of the TransactionProxyFactoryBean. The is a subclass of , so basic configuration is shared with . (See list of properties above.) The following example from the JPetStore illustrates how this works. As with a , there is a target bean definition. Dependencies should be expressed on the proxied factory bean definition (\"petStore\" here), rather than the target POJO (\"petStoreTarget\"). The requires a target, and information about \"transaction attributes,\" specifying which methods should be transactional and the required propagation and other settings: As with the , we might choose to use an inner bean to set the value of property, instead of a reference to a top-level target bean. The automatically creates a transaction advisor, including a pointcut based on the transaction attributes, so only transactional methods are advised. The allows the specification of \"pre\" and \"post\" advice, using the preInterceptors and postInterceptors properties. These take Object arrays of interceptors, other advice or Advisors to place in the interception chain before or after the transaction interceptor. These can be populated using a <list> element in XML bean definitions, as follows: These properties could be added to the \"petStore\" bean definition above. A common usage is to combine transactionality with declarative security: a similar approach to that offered by EJB. Because of the use of actual instance references, rather than bean names as in , pre and post interceptors can be used only for shared-instance advice. Thus they are not useful for stateful advice: for example, in mixins. This is consistent with the TransactionProxyFactoryBean's purpose. It provides a simple way of doing common transaction setup. If you need more complex, customized, AOP, consider using the generic , or an auto proxy creator (see below). Especially if we view Spring AOP as, in many cases, a replacement for EJB, we find that most advice is fairly generic and uses a shared-instance model. Declarative transaction management and security checks are classic examples. The depends on a implementation via its JavaBean property. This allows for pluggable transaction implementation, based on JTA, JDBC or other strategies. This relates to the Spring transaction abstraction, rather than AOP. We'll discuss the transaction infrastructure in the next chapter. If you're interested only in declarative transaction management, the TransactionProxyFactoryBean is a good solution, and simpler than using a ProxyFactoryBean. Other dedicated proxies create proxies for EJBs, enabling the EJB \"business methods\" interface to be used directly by calling code. Calling code does not need to perform JNDI lookups or use EJB create methods: A significant improvement in readability and architectural flexibility. See the chapter on Spring EJB services in this manual for further information.\n\nHowever you create AOP proxies, you can manipulate them using the interface. Any AOP proxy can be cast to this interface, whatever other interfaces it implements. This interface includes the following methods: The method will return an Advisor for every advisor, interceptor or other advice type that has been added to the factory. If you added an Advisor, the returned advisor at this index will be the object that you added. If you added an interceptor or other advice type, Spring will have wrapped this in an advisor with a pointcut that always returns true. Thus if you added a , the advisor returned for this index will be an returning your and a pointcut that matches all classes and methods. The methods can be used to add any Advisor. Usually the advisor holding pointcut and advice will be the generic , which can be used with any advice or pointcut (but not for introduction). By default, it's possible to add or remove advisors or interceptors even once a proxy has been created. The only restriction is that it's impossible to add or remove an introduction advisor, as existing proxies from the factory will not show the interface change. (You can obtain a new proxy from the factory to avoid this problem.) A simple example of casting an AOP proxy to the interface and examining and manipulating its advice: Advised advised = (Advised) myObject; Advisor[] advisors = advised.getAdvisors(); int oldAdvisorCount = advisors.length; System.out.println(oldAdvisorCount + \" advisors\"); // Add an advice like an interceptor without a pointcut // Will match all proxied methods // Can use for interceptors, before, after returning or throws advice advised.addAdvice(new DebugInterceptor()); // Add selective advice using a pointcut advised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice)); assertEquals(\"Added two advisors\", oldAdvisorCount + 2, advised.getAdvisors().length); It's questionable whether it's advisable (no pun intended) to modify advice on a business object in production, although there are no doubt legitimate usage cases. However, it can be very useful in development: for example, in tests. I have sometimes found it very useful to be able to add test code in the form of an interceptor or other advice, getting inside a method invocation I want to test. (For example, the advice can get inside a transaction created for that method: for example, to run SQL to check that a database was correctly updated, before marking the transaction for roll back.) Depending on how you created the proxy, you can usually set a flag, in which case the method will return true, and any attempts to modify advice through addition or removal will result in an . The ability to freeze the state of an advised object is useful in some cases: For example, to prevent calling code removing a security interceptor. It may also be used in Spring 1.1 to allow aggressive optimization if runtime advice modification is known not to be required.\n\nSo far we've considered explicit creation of AOP proxies using a or similar factory bean. Spring also allows us to use \"autoproxy\" bean definitions, which can automatically proxy selected bean definitions. This is built on Spring \"bean post processor\" infrastructure, which enables modification of any bean definition as the container loads. In this model, you set up some special bean definitions in your XML bean definition file configuring the auto proxy infrastructure. This allows you just to declare the targets eligible for autoproxying: you don't need to use . There are two ways to do this:\n• None Using an autoproxy creator that refers to specific beans in the current context\n• None A special case of autoproxy creation that deserves to be considered separately; autoproxy creation driven by source-level metadata attributes The package provides the following standard autoproxy creators. The BeanNameAutoProxyCreator automatically creates AOP proxies for beans with names matching literal values or wildcards. As with , there is an interceptorNames property rather than a list of interceptor, to allow correct behavior for prototype advisors. Named \"interceptors\" can be advisors or any advice type. As with auto proxying in general, the main point of using is to apply the same configuration consistently to multiple objects, and with minimal volume of configuration. It is a popular choice for applying declarative transactions to multiple objects. Bean definitions whose names match, such as \"jdkMyBean\" and \"onlyJdk\" in the above example, are plain old bean definitions with the target class. An AOP proxy will be created automatically by the . The same advice will be applied to all matching beans. Note that if advisors are used (rather than the interceptor in the above example), the pointcuts may apply differently to different beans. A more general and extremely powerful auto proxy creator is . This will automagically apply eligible advisors in the current context, without the need to include specific bean names in the autoproxy advisor's bean definition. It offers the same merit of consistent configuration and avoidance of duplication as .\n• None Specifying any number of Advisors in the same or related contexts. Note that these must be Advisors, not just interceptors or other advices. This is necessary because there must be a pointcut to evaluate, to check the eligibility of each advice to candidate bean definitions. The will automatically evaluate the pointcut contained in each advisor, to see what (if any) advice it should apply to each business object (such as \"businessObject1\" and \"businessObject2\" in the example). This means that any number of advisors can be applied automatically to each business object. If no pointcut in any of the advisors matches any method in a business object, the object will not be proxied. As bean definitions are added for new business objects, they will automatically be proxied if necessary. Autoproxying in general has the advantage of making it impossible for callers or dependencies to obtain an un-advised object. Calling getBean(\"businessObject1\") on this ApplicationContext will return an AOP proxy, not the target business object. (The \"inner bean\" idiom shown earlier also offers this benefit.) The is very useful if you want to apply the same advice consistently to many business objects. Once the infrastructure definitions are in place, you can simply add new business objects without including specific proxy configuration. You can also drop in additional aspects very easily--for example, tracing or performance monitoring aspects--with minimal change to configuration. The DefaultAdvisorAutoProxyCreator offers support for filtering (using a naming convention so that only certain advisors are evaluated, allowing use of multiple, differently configured, AdvisorAutoProxyCreators in the same factory) and ordering. Advisors can implement the interface to ensure correct ordering if this is an issue. The TransactionAttributeSourceAdvisor used in the above example has a configurable order value; default is unordered. This is the superclass of DefaultAdvisorAutoProxyCreator. You can create your own autoproxy creators by subclassing this class, in the unlikely event that advisor definitions offer insufficient customization to the behavior of the framework . A particularly important type of autoproxying is driven by metadata. This produces a similar programming model to .NET . Instead of using XML deployment descriptors as in EJB, configuration for transaction management and other enterprise services is held in source-level attributes. In this case, you use the , in combination with Advisors that understand metadata attributes. The metadata specifics are held in the pointcut part of the candidate advisors, rather than in the autoproxy creation class itself. This is really a special case of the , but deserves consideration on its own. (The metadata-aware code is in the pointcuts contained in the advisors, not the AOP framework itself.) The directory of the JPetStore sample application shows the use of attribute-driven autoproxying. In this case, there's no need to use the . Simply defining transactional attributes on business objects is sufficient, because of the use of metadata-aware pointcuts. The bean definitions include the following code, in . Note that this is generic, and can be used outside the JPetStore: The bean definition (the name is not significant, hence it can even be omitted) will pick up all eligible pointcuts in the current application context. In this case, the \"transactionAdvisor\" bean definition, of type , will apply to classes or methods carrying a transaction attribute. The TransactionAttributeSourceAdvisor depends on a TransactionInterceptor, via constructor dependency. The example resolves this via autowiring. The depends on an implementation of the interface. In this fragment, the \"attributes\" bean satisfies this, using the Jakarta Commons Attributes API to obtain attribute information. (The application code must have been compiled using the Commons Attributes compilation task.) The directory of the JPetStore sample application contains an analogous example for auto-proxying driven by JDK 1.5+ annotations. The following configuration enables automatic detection of Spring's annotation, leading to implicit proxies for beans containing that annotation: The defined here depends on a definition, which is not included in this generic file (although it could be) because it will be specific to the application's transaction requirements (typically JTA, as in this example, or Hibernate, JDO or JDBC): If you require only declarative transaction management, using these generic XML definitions will result in Spring automatically proxying all classes or methods with transaction attributes. You won't need to work directly with AOP, and the programming model is similar to that of .NET ServicedComponents. This mechanism is extensible. It's possible to do autoproxying based on custom attributes. You need to:\n• None Specify an Advisor with the necessary advice, including a pointcut that is triggered by the presence of the custom attribute on a class or method. You may be able to use an existing advice, merely implementing a static pointcut that picks up the custom attribute. It's possible for such advisors to be unique to each advised class (for example, mixins): they simply need to be defined as prototype, rather than singleton, bean definitions. For example, the introduction interceptor from the Spring test suite, shown above, could be used in conjunction with an attribute-driven pointcut to target a mixin, as shown here. We use the generic , configured using JavaBean properties: If the attribute aware pointcut matches any methods in the or other bean definitions, the mixin will be applied. Note that both and definitions are prototypes. The pointcut can be a singleton definition, as it doesn't hold state for individual advised objects.\n\nSpring offers the concept of a TargetSource, expressed in the interface. This interface is responsible for returning the \"target object\" implementing the joinpoint. The implementation is asked for a target instance each time the AOP proxy handles a method invocation. Developers using Spring AOP don't normally need to work directly with TargetSources, but this provides a powerful means of supporting pooling, hot swappable and other sophisticated targets. For example, a pooling TargetSource can return a different target instance for each invocation, using a pool to manage instances. If you do not specify a TargetSource, a default implementation is used that wraps a local object. The same target is returned for each invocation (as you would expect). Let's look at the standard target sources provided with Spring, and how you can use them. When using a custom target source, your target will usually need to be a prototype rather than a singleton bean definition. This allows Spring to create a new target instance when required. The exists to allow the target of an AOP proxy to be switched while allowing callers to keep their references to it. Changing the target source's target takes effect immediately. The is threadsafe. You can change the target via the method on HotSwappableTargetSource as follows: The XML definitions required look as follows: The above call changes the target of the swappable bean. Clients who hold a reference to that bean will be unaware of the change, but will immediately start hitting the new target. Although this example doesn't add any advice--and it's not necessary to add advice to use a --of course any can be used in conjunction with arbitrary advice. Using a pooling target source provides a similar programming model to stateless session EJBs, in which a pool of identical instances is maintained, with method invocations going to free objects in the pool. A crucial difference between Spring pooling and SLSB pooling is that Spring pooling can be applied to any POJO. As with Spring in general, this service can be applied in a non-invasive way. Spring provides out-of-the-box support for Jakarta Commons Pool 1.1, which provides a fairly efficient pooling implementation. You'll need the commons-pool Jar on your application's classpath to use this feature. It's also possible to subclass to support any other pooling API. Note that the target object--\"businessObjectTarget\" in the example--must be a prototype. This allows the implementation to create new instances of the target to grow the pool as necessary. See the Javadoc for and the concrete subclass you wish to use for information about it's properties: maxSize is the most basic, and always guaranteed to be present. In this case, \"myInterceptor\" is the name of an interceptor that would need to be defined in the same IoC context. However, it isn't necessary to specify interceptors to use pooling. If you want only pooling, and no other advice, don't set the interceptorNames property at all. It's possible to configure Spring so as to be able to cast any pooled object to the interface, which exposes information about the configuration and current size of the pool through an introduction. You'll need to define an advisor like this: This advisor is obtained by calling a convenience method on the class, hence the use of MethodInvokingFactoryBean. This advisor's name (\"poolConfigAdvisor\" here) must be in the list of interceptors names in the ProxyFactoryBean exposing the pooled object. The cast will look as follows: Pooling stateless service objects is not usually necessary. We don't believe it should be the default choice, as most stateless objects are naturally thread safe, and instance pooling is problematic if resources are cached. Simpler pooling is available using autoproxying. It's possible to set the TargetSources used by any autoproxy creator. Setting up a \"prototype\" target source is similar to a pooling TargetSource. In this case, a new instance of the target will be created on every method invocation. Although the cost of creating a new object isn't high in a modern JVM, the cost of wiring up the new object (satisfying its IoC dependencies) may be more expensive. Thus you shouldn't use this approach without very good reason. To do this, you could modify the definition shown above as follows. (I've also changed the name, for clarity.) There's only one property: the name of the target bean. Inheritance is used in the TargetSource implementations to ensure consistent naming. As with the pooling target source, the target bean must be a prototype bean definition. ThreadLocal target sources are useful if you need an object to be created for each incoming request (per thread that is). The concept of a provide a JDK-wide facility to transparently store resource alongside a thread. Setting up a ThreadLocalTargetSource is pretty much the same as was explained for the other target sources: ThreadLocals come with serious issues (potentially resulting in memory leaks) when incorrectly using them in a multi-threaded and multi-classloader environments. One should always consider wrapping a threadlocal in some other class and never directly use the ThreadLocal itself (except of course in the wrapper class). Also, one should always remember to correctly set and unset (where the latter simply involved a call to ThreadLocal.set(null)) the resource local to the thread. Unsetting should be done in any case since not unsetting it might result in problematic behavior. Spring's ThreadLocal support is doing this for you and should always be considered in favor of using ThreadLocals without other proper handling code."
    },
    {
        "link": "https://medium.com/@youngjae991/mastering-aop-in-spring-boot-understanding-and-utilizing-pointcuts-28053b87d20f",
        "document": "In the previous stories, we explored the Proxy Pattern, JDK Dynamic Proxy, CGLIB Proxy, and the execution order of multiple advices in Spring Boot. Now, let’s delve into the world of pointcuts in AOP. Pointcuts are essential for defining where advices should be applied. This story will focus on the most commonly used pointcut expressions, their practical applications, and potential pitfalls to avoid in real-world scenarios.\n\nA pointcut is a predicate that matches join points. In Spring AOP, pointcuts determine which method executions are intercepted by advices. Pointcuts are defined using expressions that match specific join points based on method signatures, annotations, and other criteria.\n• within: Matches join points within certain types.\n• this: Matches join points where the bean reference is an instance of the given type.\n• target: Matches join points where the target object is an instance of the given type.\n• args: Matches join points where the arguments are instances of the given types.\n• @target: Matches join points where the target object has the given annotation.\n• @within: Matches join points within types that have the given annotation.\n• @annotation: Matches join points where the subject method has the given annotation.\n• @args: Matches join points where the arguments are annotated with the given annotation.\n\nCommonly Used Pointcut Expressions and Their Applications\n\nThe pointcut expression is the most commonly used in Spring AOP. It matches method executions and allows for fine-grained control over which methods are intercepted.\n\nUse to apply cross-cutting concerns to specific layers or methods based on method signatures. This is particularly useful for logging, transaction management, and security checks.\n\nThe pointcut expression matches join points within certain types, typically used to capture all methods within a particular class or package.\n\nUse when you want to apply advices to all methods within a particular class or package, providing a broader scope than .\n\nThe and pointcut expressions match join points based on the type of the proxy ( ) or the target object ( ).\n• Match methods where the proxy is an instance of a given type:\n• Match methods where the target object is an instance of a given type:\n\nUse and to apply advices based on the specific type of the proxy or target object. This can be useful for applying different behaviors based on the type hierarchy.\n\nThe pointcut expression matches join points where the arguments are instances of given types.\n\nUse to apply advices to methods based on the types of their arguments. This is useful for parameter-specific logic, such as validation or transformation.\n\nThe pointcut expression matches join points where the subject method has the given annotation.\n\nUse to apply advices based on method annotations. This is particularly useful for implementing custom behaviors for annotated methods, such as logging or security checks.\n\nPointcut expressions can be combined using logical operators to create complex matching criteria.\n• Combine pointcuts to match methods with specific annotations and argument types:\n\nWhen multiple pointcuts match the same join point, it’s important to manage the order of execution using the annotation to avoid unexpected behaviors. This can occur when different pointcut expressions are used, but they effectively target the same join point.\n\nLet’s consider an example where different pointcut expressions ( and ) match the same join point.\n\nIn this example:\n• The uses the pointcut to match the method.\n• The uses the pointcut to match the same method because it is annotated with .\n\nWithout the annotation, the execution order of these advices would be unpredictable, potentially leading to unexpected behavior.\n\nWhen you access the endpoint, the output will be:\n\nThis demonstrates the importance of managing the order of execution when pointcuts overlap.\n\nPointcuts, especially complex ones, can introduce performance overhead. It’s important to balance the granularity of pointcuts with the performance requirements of your application.\n\nComplex pointcut expressions can be difficult to debug and maintain. Keep pointcut definitions as simple and clear as possible, and use well-documented annotations to improve readability.\n\nLet’s create a comprehensive example to illustrate the usage of various pointcut expressions in a Spring Boot application.\n\nApplication Startup: Spring Boot starts the application, scans for components, and identifies , , and as beans.\n\nProxy Determination: Spring Boot detects the annotations on and and creates proxies for .\n• If implements the interface, Spring Boot uses JDK Dynamic Proxy.\n• If does not implement any interface, Spring Boot uses CGLIB to create a subclass proxy.\n\nMethod Invocation: When the endpoint is accessed, Spring Boot retrieves the bean from the application context. If has been proxied, the proxy intercepts the call to .\n• Before Advice: runs first, followed by .\n• Method Execution: The actual method on the target bean is called.\n• After Advice: runs first, followed by .\n• Return Value Handling: The proxy handles the return value, applying any advice.\n• Exception Handling: If an exception is thrown, the proxy applies any advice.\n\nWhen you access the endpoint, the output will be:\n\nThis demonstrates the usage of various pointcuts and their execution order.\n\nUnderstanding and effectively using pointcuts in Spring Boot’s AOP framework is essential for managing cross-cutting concerns. By mastering common pointcut expressions and their applications, you can ensure that your aspects are applied correctly and efficiently. Additionally, managing overlapping pointcuts using the annotation is crucial to avoid unexpected behaviors and ensure the correct execution order of advices.\n\nWith this comprehensive understanding, you can now effectively utilize pointcuts in your Spring Boot applications, ensuring clean, maintainable, and well-organized code."
    },
    {
        "link": "https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop-api.html",
        "document": ""
    }
]