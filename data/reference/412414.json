[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all",
        "document": "The static method takes an iterable of promises as input and returns a single . This returned promise fulfills when all of the input's promises fulfill (including when an empty iterable is passed), with an array of the fulfillment values. It rejects when any of the input's promises rejects, with this first rejection reason.\n\nThe method is one of the promise concurrency methods. It can be useful for aggregating the results of multiple promises. It is typically used when there are multiple related asynchronous tasks that the overall code relies on to work successfully — all of whom we want to fulfill before the code execution continues. will reject immediately upon any of the input promises rejecting. In comparison, the promise returned by will wait for all input promises to complete, regardless of whether or not one rejects. Use if you need the final result of every promise in the input iterable.\n\nwaits for all fulfillments (or the first rejection). If the contains non-promise values, they will be ignored, but still counted in the returned promise array value (if the promise is fulfilled): // All values are non-promises, so the returned promise gets fulfilled const p = Promise.all([1, 2, 3]); // The only input promise is already fulfilled, // so the returned promise gets fulfilled const p2 = Promise.all([1, 2, 3, Promise.resolve(444)]); // One (and the only) input promise is rejected, // so the returned promise gets rejected const p3 = Promise.all([1, 2, 3, Promise.reject(555)]); // Using setTimeout, we can execute code after the queue is empty setTimeout(() => { console.log(p); console.log(p2); console.log(p3); }); // Logs: // Promise { <state>: \"fulfilled\", <value>: Array[3] } // Promise { <state>: \"fulfilled\", <value>: Array[4] } // Promise { <state>: \"rejected\", <reason>: 555 }\n\nThis following example demonstrates the asynchronicity of when a non-empty is passed: // Passing an array of promises that are already resolved, // to trigger Promise.all as soon as possible const resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)]; const p = Promise.all(resolvedPromisesArray); // Immediately logging the value of p console.log(p); // Using setTimeout, we can execute code after the queue is empty setTimeout(() => { console.log(\"the queue is now empty\"); console.log(p); }); // Logs, in order: // Promise { <state>: \"pending\" } // the queue is now empty // Promise { <state>: \"fulfilled\", <value>: Array[2] } The same thing happens if rejects: const mixedPromisesArray = [Promise.resolve(33), Promise.reject(44)]; const p = Promise.all(mixedPromisesArray); console.log(p); setTimeout(() => { console.log(\"the queue is now empty\"); console.log(p); }); // Logs: // Promise { <state>: \"pending\" } // the queue is now empty // Promise { <state>: \"rejected\", <reason>: 44 } resolves synchronously if and only if the passed is empty: const p = Promise.all([]); // Will be immediately resolved const p2 = Promise.all([1337, \"hi\"]); // Non-promise values are ignored, but the evaluation is done asynchronously console.log(p); console.log(p2); setTimeout(() => { console.log(\"the queue is now empty\"); console.log(p2); }); // Logs: // Promise { <state>: \"fulfilled\", <value>: Array[0] } // Promise { <state>: \"pending\" } // the queue is now empty // Promise { <state>: \"fulfilled\", <value>: Array[2] }\n\nWithin async functions, it's very common to \"over-await\" your code. For example, given the following functions: function promptForDishChoice() { return new Promise((resolve, reject) => { const dialog = document.createElement(\"dialog\"); dialog.innerHTML = ` <form method=\"dialog\"> <p>What would you like to eat?</p> <select> <option value=\"pizza\">Pizza</option> <option value=\"pasta\">Pasta</option> <option value=\"salad\">Salad</option> </select> <menu> <li><button value=\"cancel\">Cancel</button></li> <li><button type=\"submit\" value=\"ok\">OK</button></li> </menu> </form> `; dialog.addEventListener(\"close\", () => { if (dialog.returnValue === \"ok\") { resolve(dialog.querySelector(\"select\").value); } else { reject(new Error(\"User cancelled dialog\")); } }); document.body.appendChild(dialog); dialog.showModal(); }); } async function fetchPrices() { const response = await fetch(\"/prices\"); return await response.json(); } You may write a function like this: However, note that the execution of and don't depend on the result of each other. While the user is choosing their dish, it's fine for the prices to be fetched in the background, but in the code above, the operator causes the async function to pause until the choice is made, and then again until the prices are fetched. We can use to run them concurrently, so that the user doesn't have to wait for the prices to be fetched before the result is given: is the best choice of concurrency method here, because error handling is intuitive — if any of the promises reject, the result is no longer available, so the whole expression throws. accepts an iterable of promises, so if you are using it to run several async functions concurrently, you need to call the async functions and use the returned promises. Directly passing the functions to does not work, since they are not promises. async function getPrice() { const [choice, prices] = await Promise.all([ promptForDishChoice, fetchPrices, ]); // `choice` and `prices` are still the original async functions; // Promise.all() does nothing to non-promises }"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled",
        "document": "Already fulfilled , if the iterable passed is empty.\n\nAsynchronously fulfilled, when all promises in the given have settled (either fulfilled or rejected). The fulfillment value is an array of objects, each describing the outcome of one promise in the , in the order of the promises passed, regardless of completion order. Each outcome object has the following properties:\n\nA string, either or , indicating the eventual state of the promise. Only present if is . The value that the promise was fulfilled with. Only present if is . The reason that the promise was rejected with.\n\nIf the passed is non-empty but contains no pending promises, the returned promise is still asynchronously (instead of synchronously) fulfilled."
    },
    {
        "link": "https://geeksforgeeks.org/javascript-promise-all-method",
        "document": "The Promise.all() method in JavaScript is used for handling multiple asynchronous operations simultaneously. It takes an array (or any iterable) of promises and returns a single promise that resolves when all the input promises resolve or reject if any one of the promises fails. This makes it ideal for scenarios where you need to wait for multiple asynchronous tasks to complete before proceeding.\n• iterable: An array or other iterable object containing promises or other values. Non-promise values are treated as resolved promises.\n\nReturn values: It follows some rules to return a single promise:\n• None If passed argument is empty, it returns a Promise that is already resolved\n• None If the passed iterable contains no promises, it returns a Promise that is resolved asynchronously\n• None For all other cases, it returns a pending Promise.\n• None If the iterable is empty, it returns a promise that is resolved immediately.\n• None If all promises in the iterable are fulfilled, Promise.all() resolves to an array of the fulfilled values, maintaining the order of the promises in the input array.\n• None If any promise in the iterable is rejected, Promise.all() immediately rejects with that reason, ignoring the rest of the promises, even if they were resolved.\n\nThe below examples illustrate the JavaScript Promise.all() method:\n\nExample 1: Waiting for All Promises to Resolve\n\nIn this example the Promise.all waits for all promises (p1, p2, p3) to resolve. It then returns an array of resolved values [50, 200, ‘geek’], logging them once all promises are fulfilled.\n\nIn this example the Promise.all waits for all promises (tOut(1000) and tOut(2000)) to resolve. It returns an array of results once both promises are fulfilled, logging [ ‘Completed in 1000’, ‘Completed in 2000’ ].\n\nHere, Promise.all() method is the order of the maintained promises. The first promise in the array will get resolved to the first element of the output array, the second promise will be a second element in the output array, and so on.\n\nExample 3: Array of Promises with Varying Timeouts\n\nIn this example the reates an array of promises with varying timeouts, stores them in promises, and uses Promise.all to resolve them.\n\nIn this example, If one of the promises fails, then all the rest of the promises fail and the result will be displayed in the console in the form of an Error. Then Promise.all() method gets rejected.\n\nExample 5: Using Timers with Different Promises\n\nIn this example, we will use some timer function (particularly the setTimeout function) having different timers in it and those will be written inside different promises and further those promises will be passed inside Promise.all() methods in order to obtain the result.\n\nThe browsers supported by JavaScript Promise.all() methods are listed below:\n\nDoes Promise.all() maintain the order of promises?\n\nHow does Promise.all() differ from Promise.allSettled()?\n\nWhat is the return value of Promise.all()?\n\nCan you use Promise.all() with async/await?"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises",
        "document": "A is an object representing the eventual completion or failure of an asynchronous operation. Since most people are consumers of already-created promises, this guide will explain consumption of returned promises before explaining how to create them. Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function. Imagine a function, , which asynchronously generates a sound file given a configuration record and two callback functions: one called if the audio file is successfully created, and the other called if an error occurs. Here's some code that uses : If were rewritten to return a promise, you would attach your callbacks to it instead: This convention has several advantages. We will explore each one.\n\nA common need is to execute two or more asynchronous operations back to back, where each subsequent operation starts when the previous operation succeeds, with the result from the previous step. In the old days, doing several asynchronous operations in a row would lead to the classic callback hell: With promises, we accomplish this by creating a promise chain. The API design of promises makes this great, because callbacks are attached to the returned promise object, instead of being passed into a function. Here's the magic: the function returns a new promise, different from the original: This second promise ( ) represents the completion not just of , but also of the or you passed in — which can be other asynchronous functions returning a promise. When that's the case, any callbacks added to get queued behind the promise returned by either or . Note: If you want a working example to play with, you can use the following template to create any function returning a promise: function doSomething() { return new Promise((resolve) => { setTimeout(() => { // Other things to do before completion of the promise console.log(\"Did something\"); // The fulfillment value of the promise resolve(\"https://example.com/\"); }, 200); }); } The implementation is discussed in the Creating a Promise around an old callback API section below. With this pattern, you can create longer chains of processing, where each promise represents the completion of one asynchronous step in the chain. In addition, the arguments to are optional, and is short for — so if your error handling code is the same for all steps, you can attach it to the end of the chain: You might see this expressed with arrow functions instead: Note: Arrow function expressions can have an implicit return; so, is short for . and can return any value — if they return promises, that promise is first waited until it settles, and the next callback receives the fulfillment value, not the promise itself. It is important to always return promises from callbacks, even if the promise always resolves to . If the previous handler started a promise but did not return it, there's no way to track its settlement anymore, and the promise is said to be \"floating\". doSomething() .then((url) => { // Missing `return` keyword in front of fetch(url). fetch(url); }) .then((result) => { // result is undefined, because nothing is returned from the previous // handler. There's no way to know the return value of the fetch() // call anymore, or whether it succeeded at all. }); By returning the result of the call (which is a promise), we can both track its completion and receive its value when it completes. Floating promises could be worse if you have race conditions — if the promise from the last handler is not returned, the next handler will be called early, and any value it reads may be incomplete. const listOfIngredients = []; doSomething() .then((url) => { // Missing `return` keyword in front of fetch(url). fetch(url) .then((res) => res.json()) .then((data) => { listOfIngredients.push(data); }); }) .then(() => { console.log(listOfIngredients); // listOfIngredients will always be [], because the fetch request hasn't completed yet. }); Therefore, as a rule of thumb, whenever your operation encounters a promise, return it and defer its handling to the next handler. const listOfIngredients = []; doSomething() .then((url) => { // `return` keyword now included in front of fetch call. return fetch(url) .then((res) => res.json()) .then((data) => { listOfIngredients.push(data); }); }) .then(() => { console.log(listOfIngredients); // listOfIngredients will now contain data from fetch call. }); Even better, you can flatten the nested chain into a single chain, which is simpler and makes error handling easier. The details are discussed in the Nesting section below. Using / can help you write code that's more intuitive and resembles synchronous code. Below is the same example using / : Note how the code looks exactly like synchronous code, except for the keywords in front of promises. One of the only tradeoffs is that it may be easy to forget the keyword, which can only be fixed when there's a type mismatch (e.g. trying to use a promise as a value). / builds on promises — for example, is the same function as before, so there's minimal refactoring needed to change from promises to / . You can read more about the / syntax in the async functions and references. Note: / has the same concurrency semantics as normal promise chains. within one async function does not stop the entire program, only the parts that depend on its value, so other async jobs can still run while the is pending.\n\nIn the examples above involving , the first one has one promise chain nested in the return value of another handler, while the second one uses an entirely flat chain. Simple promise chains are best kept flat without nesting, as nesting can be a result of careless composition. Nesting is a control structure to limit the scope of statements. Specifically, a nested only catches failures in its scope and below, not errors higher up in the chain outside the nested scope. When used correctly, this gives greater precision in error recovery: Note that the optional steps here are nested — with the nesting caused not by the indentation, but by the placement of the outer and parentheses around the steps. The inner error-silencing handler only catches failures from and , after which the code resumes with . Importantly, if fails, its error is caught by the final (outer) only, and does not get swallowed by the inner handler. In / , this code looks like: async function main() { try { const result = await doSomethingCritical(); try { const optionalResult = await doSomethingOptional(result); await doSomethingExtraNice(optionalResult); } catch (e) { // Ignore failures in optional steps and proceed. } await moreCriticalStuff(); } catch (e) { console.error(`Critical failure: ${e.message}`); } } Note: If you don't have sophisticated error handling, you very likely don't need nested handlers. Instead, use a flat chain and put the error handling logic at the end.\n\nIf a promise rejection event is not handled by any handler, it bubbles to the top of the call stack, and the host needs to surface it. On the web, whenever a promise is rejected, one of two events is sent to the global scope (generally, this is either the or, if being used in a web worker, it's the or other worker-based interface). The two events are: Sent when a promise is rejected but there is no rejection handler available. Sent when a handler is attached to a rejected promise that has already caused an event. In both cases, the event (of type ) has as members a property indicating the promise that was rejected, and a property that provides the reason given for the promise to be rejected. These make it possible to offer fallback error handling for promises, as well as to help debug issues with your promise management. These handlers are global per context, so all errors will go to the same event handlers, regardless of source. In Node.js, handling promise rejection is slightly different. You capture unhandled rejections by adding a handler for the Node.js event (notice the difference in capitalization of the name), like this: process.on(\"unhandledRejection\", (reason, promise) => { // Add code here to examine the \"promise\" and \"reason\" values }); For Node.js, to prevent the error from being logged to the console (the default action that would otherwise occur), adding that listener is all that's necessary; there's no need for an equivalent of the browser runtime's method. However, if you add that listener but don't also have code within it to handle rejected promises, they will just be dropped on the floor and silently ignored. So ideally, you should add code within that listener to examine each rejected promise and make sure it was not caused by an actual code bug.\n\nThere are four composition tools for running asynchronous operations concurrently: , , , and . We can start operations at the same time and wait for them all to finish like this: If one of the promises in the array rejects, immediately rejects the returned promise and aborts the other operations. This may cause unexpected state or behavior. is another composition tool that ensures all operations are complete before resolving. These methods all run promises concurrently — a sequence of promises are started simultaneously and do not wait for each other. Sequential composition is possible using some clever JavaScript: In this example, we reduce an array of asynchronous functions down to a promise chain. The code above is equivalent to: This can be made into a reusable compose function, which is common in functional programming: The function accepts any number of functions as arguments and returns a new function that accepts an initial value to be passed through the composition pipeline: Sequential composition can also be done more succinctly with async/await: let result; for (const f of [func1, func2, func3]) { result = await f(result); } /* use last result (i.e. result3) */ However, before you compose promises sequentially, consider if it's really necessary — it's always better to run promises concurrently so that they don't unnecessarily block each other unless one promise's execution depends on another's result.\n\nIn the callback-based API, when and how the callback gets called depends on the API implementor. For example, the callback may be called synchronously or asynchronously: The above design is strongly discouraged because it leads to the so-called \"state of Zalgo\". In the context of designing asynchronous APIs, this means a callback is called synchronously in some cases but asynchronously in other cases, creating ambiguity for the caller. For further background, see the article Designing APIs for Asynchrony, where the term was first formally presented. This API design makes side effects hard to analyze: let value = 1; doSomething(() => { value = 2; }); console.log(value); // 1 or 2? On the other hand, promises are a form of inversion of control — the API implementor does not control when the callback gets called. Instead, the job of maintaining the callback queue and deciding when to call the callbacks is delegated to the promise implementation, and both the API user and API developer automatically gets strong semantic guarantees, including:\n• Callbacks added with will never be invoked before the completion of the current run of the JavaScript event loop.\n• These callbacks will be invoked even if they were added after the success or failure of the asynchronous operation that the promise represents.\n• Multiple callbacks may be added by calling several times. They will be invoked one after another, in the order in which they were inserted. To avoid surprises, functions passed to will never be called synchronously, even with an already-resolved promise: Instead of running immediately, the passed-in function is put on a microtask queue, which means it runs later (only after the function which created it exits, and when the JavaScript execution stack is empty), just before control is returned to the event loop; i.e. pretty soon: const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms)); wait(0).then(() => console.log(4)); Promise.resolve() .then(() => console.log(2)) .then(() => console.log(3)); console.log(1); // 1, 2, 3, 4"
    },
    {
        "link": "https://stackoverflow.com/questions/37360567/how-to-await-multiple-promises",
        "document": "takes an array of Promises and returns an array of results.\n\nwill be an array:\n\nYou can also deconstruct the resulting array:\n\nThere are a few similar functions you can use depending on your use case:\n• - waits for all to resolve or any to reject.\n• waits for all to resolve or reject.\n• waits for any resolve or all to reject."
    },
    {
        "link": "https://playwright.dev/docs/api/class-test",
        "document": "Playwright Test provides a function to declare tests and function to write assertions.\n\nYou can tag tests by providing additional test details. Alternatively, you can include tags in the test title. Note that each tag must start with symbol.\n\nTest tags are displayed in the test report, and are available to a custom reporter via property.\n\nYou can also filter tests by their tags during test execution:\n• in the config with testConfig.grep and testProject.grep;\n\nYou can annotate tests by providing additional test details.\n\nTest annotations are displayed in the test report, and are available to a custom reporter via property.\n\nYou can also add annotations during runtime by manipulating testInfo.annotations.\n• \n• \n• Optional annotation description, for example an issue url.\n• Test body that takes one or two arguments: an object with fixtures and optional TestInfo.\n\nDeclares an hook that is executed once per worker after all tests.\n\nWhen called in the scope of a test file, runs after all tests in the file. When called inside a test.describe() group, runs after all tests in the group.\n\nAlternatively, you can declare a hook with a title.\n• Hook function that takes one or two arguments: an object with worker fixtures and optional TestInfo.\n\nWhen multiple hooks are added, they will run in the order of their registration.\n\nNote that worker process is restarted on test failures, and hook runs again in the new worker. Learn more about workers and failures.\n\nPlaywright will continue running all applicable hooks even if some of them have failed.\n\nDeclares an hook that is executed after each test.\n\nWhen called in the scope of a test file, runs after each test in the file. When called inside a test.describe() group, runs after each test in the group.\n\nYou can access all the same Fixtures as the test body itself, and also the TestInfo object that gives a lot of useful information. For example, you can check whether the test succeeded or failed.\n\nAlternatively, you can declare a hook with a title.\n• Hook function that takes one or two arguments: an object with fixtures and optional TestInfo.\n\nWhen multiple hooks are added, they will run in the order of their registration.\n\nPlaywright will continue running all applicable hooks even if some of them have failed.\n\nDeclares a hook that is executed once per worker process before all tests.\n\nWhen called in the scope of a test file, runs before all tests in the file. When called inside a test.describe() group, runs before all tests in the group.\n\nYou can use test.afterAll() to teardown any resources set up in .\n\nAlternatively, you can declare a hook with a title.\n• Hook function that takes one or two arguments: an object with worker fixtures and optional TestInfo.\n\nWhen multiple hooks are added, they will run in the order of their registration.\n\nNote that worker process is restarted on test failures, and hook runs again in the new worker. Learn more about workers and failures.\n\nPlaywright will continue running all applicable hooks even if some of them have failed.\n\nDeclares a hook that is executed before each test.\n\nWhen called in the scope of a test file, runs before each test in the file. When called inside a test.describe() group, runs before each test in the group.\n\nYou can access all the same Fixtures as the test body itself, and also the TestInfo object that gives a lot of useful information. For example, you can navigate the page before starting the test.\n\nYou can use test.afterEach() to teardown any resources set up in .\n\nAlternatively, you can declare a hook with a title.\n• Hook function that takes one or two arguments: an object with fixtures and optional TestInfo.\n\nWhen multiple hooks are added, they will run in the order of their registration.\n\nPlaywright will continue running all applicable hooks even if some of them have failed.\n\nYou can declare a group of tests with a title. The title will be visible in the test report as a part of each test's title.\n\nYou can also declare a test group without a title. This is convenient to give a group of tests a common option with test.use().\n\nYou can tag all tests in a group by providing additional details. Note that each tag must start with symbol.\n\nYou can annotate all tests in a group by providing additional details.\n• Additional details for all tests in the group.\n• A callback that is run immediately when calling test.describe(). Any tests declared in this callback will belong to the group.\n\nConfigures the enclosing scope. Can be executed either on the top level or inside a describe. Configuration applies to the entire scope, regardless of whether it run before or after the test declaration.\n\nLearn more about the execution modes here.\n• Running serially is not recommended. It is usually better to make your tests isolated, so they can be run independently.\n• Configuring retries and timeout for each test.\n• Run multiple describes in parallel, but tests inside each describe in order.\n• Object (optional)\n• Execution mode. Learn more about the execution modes here.\n• The number of retries for each test.\n• Timeout for each test in milliseconds. Overrides testProject.timeout and testConfig.timeout.\n\nDeclares a test group similarly to test.describe(). Tests in this group are marked as \"fixme\" and will not be executed.\n\nYou can also omit the title.\n• A callback that is run immediately when calling test.describe.fixme(). Any tests added in this callback will belong to the group, and will not be run.\n\nDeclares a focused group of tests. If there are some focused tests or suites, all of them will be run but nothing else.\n\nYou can also omit the title.\n• A callback that is run immediately when calling test.describe.only(). Any tests added in this callback will belong to the group.\n\nDeclares a skipped test group, similarly to test.describe(). Tests in the skipped group are never run.\n\nYou can also omit the title.\n• A callback that is run immediately when calling test.describe.skip(). Any tests added in this callback will belong to the group, and will not be run.\n\nExtends the object by defining fixtures and/or options that can be used in the tests.\n\nThen use the fixture in the test.\n\nLearn more about fixtures and parametrizing tests.\n• An object containing fixtures and/or options. Learn more about fixtures format.\n\nMarks a test as \"should fail\". Playwright runs this test and ensures that it is actually failing. This is useful for documentation purposes to acknowledge that some functionality is broken until it is fixed.\n\nTo annotate test as \"failing\" at runtime:\n\nYou can declare a test as failing, so that Playwright ensures it actually fails.\n\nIf your test fails in some configurations, but not all, you can mark the test as failing inside the test body based on some condition. We recommend passing a argument in this case.\n\nYou can mark all tests in a file or test.describe() group as \"should fail\" based on some condition with a single call.\n\nYou can also call without arguments inside the test body to always mark the test as failed. We recommend declaring a failing test with instead.\n• Test body that takes one or two arguments: an object with fixtures and optional TestInfo.\n• Test is marked as \"should fail\" when the condition is .\n• A function that returns whether to mark as \"should fail\", based on test fixtures. Test or tests are marked as \"should fail\" when the return value is .\n• Optional description that will be reflected in a test report.\n\nYou can use to focus on a specific test that is expected to fail. This is particularly useful when debugging a failing test or working on a specific issue.\n\nYou can declare a focused failing test, so that Playwright runs only this test and ensures it actually fails.\n• Test body that takes one or two arguments: an object with fixtures and optional TestInfo.\n\nMark a test as \"fixme\", with the intention to fix it. Playwright will not run the test past the call.\n\nTo annotate test as \"fixme\" at runtime:\n\nYou can declare a test as to be fixed, and Playwright will not run it.\n\nIf your test should be fixed in some configurations, but not all, you can mark the test as \"fixme\" inside the test body based on some condition. We recommend passing a argument in this case. Playwright will run the test, but abort it immediately after the call.\n\nYou can mark all tests in a file or test.describe() group as \"fixme\" based on some condition with a single call.\n\nYou can also call without arguments inside the test body to always mark the test as failed. We recommend using instead.\n• Test body that takes one or two arguments: an object with fixtures and optional TestInfo.\n• Test is marked as \"should fail\" when the condition is .\n• A function that returns whether to mark as \"should fail\", based on test fixtures. Test or tests are marked as \"should fail\" when the return value is .\n• Optional description that will be reflected in a test report.\n\nReturns information about the currently running test. This method can only be called during the test execution, otherwise it throws.\n\nDeclares a focused test. If there are some focused tests or suites, all of them will be run but nothing else.\n• Test body that takes one or two arguments: an object with fixtures and optional TestInfo.\n\nChanges the timeout for the test. Zero means no timeout. Learn more about various timeouts.\n\nTimeout for the currently running test is available through testInfo.timeout.\n• Changing timeout from a slow hook. Note that this affects the test timeout that is shared with hooks.\n• Changing timeout for a or hook. Note this affects the hook's timeout, not the test timeout.\n• Changing timeout for all tests in a test.describe() group.\n\nSkip a test. Playwright will not run the test past the call.\n\nSkipped tests are not supposed to be ever run. If you intent to fix the test, use test.fixme() instead.\n\nYou can declare a skipped test, and Playwright will not run it.\n\nIf your test should be skipped in some configurations, but not all, you can skip the test inside the test body based on some condition. We recommend passing a argument in this case. Playwright will run the test, but abort it immediately after the call.\n\nYou can skip all tests in a file or test.describe() group based on some condition with a single call.\n\nYou can also call without arguments inside the test body to always mark the test as failed. We recommend using instead.\n• Test body that takes one or two arguments: an object with fixtures and optional TestInfo.\n• Test is marked as \"should fail\" when the condition is .\n• A function that returns whether to mark as \"should fail\", based on test fixtures. Test or tests are marked as \"should fail\" when the return value is .\n• Optional description that will be reflected in a test report.\n\nMarks a test as \"slow\". Slow test will be given triple the default timeout.\n\nNote that test.slow() cannot be used in a or hook. Use test.setTimeout() instead.\n\nYou can mark a test as slow by calling inside the test body.\n\nIf your test is slow in some configurations, but not all, you can mark it as slow based on a condition. We recommend passing a argument in this case.\n\nYou can mark all tests in a file or test.describe() group as \"slow\" based on some condition by passing a callback.\n• Test is marked as \"slow\" when the condition is .\n• A function that returns whether to mark as \"slow\", based on test fixtures. Test or tests are marked as \"slow\" when the return value is .\n• Optional description that will be reflected in a test report.\n\nDeclares a test step that is shown in the report.\n• \n• Whether to box the step in the report. Defaults to . When the step is boxed, errors thrown from the step internals point to the step call site. See below for more details.\n• Specifies a custom location for the step to be shown in test reports and trace viewer. By default, location of the test.step() call is shown.\n• The maximum time, in milliseconds, allowed for the step to complete. If the step does not complete within the specified timeout, the test.step() method will throw a TimeoutError. Defaults to (no timeout).\n\nThe method returns the value returned by the step callback.\n\nYou can use TypeScript method decorators to turn a method into a step. Each call to the decorated method will show up as a step in the report.\n\nWhen something inside a step fails, you would usually see the error pointing to the exact action that failed. For example, consider the following login step:\n\nAs we see above, the test may fail with an error pointing inside the step. If you would like the error to highlight the \"login\" step instead of its internals, use the option. An error inside a boxed step points to the step call site.\n\nYou can also create a TypeScript decorator for a boxed step, similar to a regular step decorator above:\n\nMark a test step as \"skip\" to temporarily disable its execution, useful for steps that are currently failing and planned for a near-term fix. Playwright will not run the step. See also testStepInfo.skip().\n\nYou can declare a skipped step, and Playwright will not run it.\n• \n• Whether to box the step in the report. Defaults to . When the step is boxed, errors thrown from the step internals point to the step call site. See below for more details.\n• Specifies a custom location for the step to be shown in test reports and trace viewer. By default, location of the test.step() call is shown.\n• Maximum time in milliseconds for the step to finish. Defaults to (no timeout).\n\nSpecifies options or fixtures to use in a single test file or a test.describe() group. Most useful to set an option, for example set to configure fixture.\n\ncan be called either in the global scope or inside . It is an error to call it within or .\n\nIt is also possible to override a fixture by providing a function.\n\nfunction can be used to create test assertions. Read more about test assertions.\n\nDeclares a group of tests that could be run in parallel. By default, tests in a single test file run one after another, but using test.describe.parallel() allows them to run in parallel.\n\nNote that parallel tests are executed in separate processes and cannot share any state or global variables. Each of the parallel tests executes all relevant hooks.\n\nYou can also omit the title.\n• A callback that is run immediately when calling test.describe.parallel(). Any tests added in this callback will belong to the group.\n\nDeclares a focused group of tests that could be run in parallel. This is similar to test.describe.parallel(), but focuses the group. If there are some focused tests or suites, all of them will be run but nothing else.\n\nYou can also omit the title.\n• A callback that is run immediately when calling test.describe.parallel.only(). Any tests added in this callback will belong to the group.\n\nDeclares a group of tests that should always be run serially. If one of the tests fails, all subsequent tests are skipped. All tests in a group are retried together.\n\nYou can also omit the title.\n• A callback that is run immediately when calling test.describe.serial(). Any tests added in this callback will belong to the group.\n\nDeclares a focused group of tests that should always be run serially. If one of the tests fails, all subsequent tests are skipped. All tests in a group are retried together. If there are some focused tests or suites, all of them will be run but nothing else.\n\nYou can also omit the title.\n• A callback that is run immediately when calling test.describe.serial.only(). Any tests added in this callback will belong to the group."
    },
    {
        "link": "https://playwright.dev/docs/writing-tests",
        "document": "There is no need to wait for anything prior to performing an action: Playwright automatically waits for the wide range of actionability checks to pass prior to performing each action.\n\nThere is also no need to deal with the race conditions when performing the checks - Playwright assertions are designed in a way that they describe the expectations that need to be eventually met.\n\nThat's it! These design choices allow Playwright users to forget about flaky timeouts and racy checks in their tests altogether.\n• How to write the first test\n• How to use assertions\n• How to use test hooks\n\nTake a look at the following example to see how to write a test.\n\nMost of the tests will start with navigating page to the URL. After that, test will be able to interact with the page elements.\n\nPlaywright will wait for page to reach the load state prior to moving forward. Learn more about the page.goto() options.\n\nPerforming actions starts with locating the elements. Playwright uses Locators API for that. Locators represent a way to find element(s) on the page at any moment, learn more about the different types of locators available. Playwright will wait for the element to be actionable prior to performing the action, so there is no need to wait for it to become available.\n\nIn most cases, it'll be written in one line:\n\nThis is the list of the most popular Playwright actions. Note that there are many more, so make sure to check the Locator API section to learn more about them.\n\nPlaywright includes test assertions in the form of function. To make an assertion, call and choose a matcher that reflects the expectation.\n\nThere are many generic matchers like , , that can be used to assert any conditions.\n\nPlaywright also includes async matchers that will wait until the expected condition is met. Using these matchers allows making the tests non-flaky and resilient. For example, this code will wait until the page gets the title containing \"Playwright\":\n\nHere is the list of the most popular async assertions. Note that there are many more to get familiar with:\n\nPlaywright Test is based on the concept of test fixtures such as the built in page fixture, which is passed into your test. Pages are isolated between tests due to the Browser Context, which is equivalent to a brand new browser profile, where every test gets a fresh environment, even when multiple tests run in a single Browser.\n\nYou can use various test hooks such as to declare a group of tests and and which are executed before/after each test. Other hooks include the and which are executed once per worker before/after all tests.\n• See a trace of your tests"
    },
    {
        "link": "https://playwright.dev/docs/test-fixtures",
        "document": "Playwright Test is based on the concept of test fixtures. Test fixtures are used to establish the environment for each test, giving the test everything it needs and nothing else. Test fixtures are isolated between tests. With fixtures, you can group tests based on their meaning, instead of their common setup.\n\nYou have already used test fixtures in your first test.\n\nThe argument tells Playwright Test to setup the fixture and provide it to your test function.\n\nHere is a list of the pre-defined fixtures that you are likely to use most of the time:\n\nHere is how typical test environment setup differs between traditional test style and the fixture-based one.\n\nis a class that helps interacting with a \"todo list\" page of the web app, following the Page Object Model pattern. It uses Playwright's internally.\n\nFixtures have a number of advantages over before/after hooks:\n• Fixtures encapsulate setup and teardown in the same place so it is easier to write. So if you have an after hook that tears down what was created in a before hook, consider turning them into a fixture.\n• Fixtures are reusable between test files - you can define them once and use in all your tests. That's how Playwright's built-in fixture works. So if you have a helper function that is used in multiple tests, consider turning it into a fixture.\n• Fixtures are on-demand - you can define as many fixtures as you'd like, and Playwright Test will setup only the ones needed by your test and nothing else.\n• Fixtures are composable - they can depend on each other to provide complex behaviors.\n• Fixtures are flexible. Tests can use any combinations of the fixtures to tailor precise environment they need, without affecting other tests.\n• Fixtures simplify grouping. You no longer need to wrap tests in s that set up environment, and are free to group your tests by their meaning instead.\n\nTo create your own fixture, use test.extend() to create a new object that will include it.\n\nBelow we create two fixtures and that follow the Page Object Model pattern.\n\nJust mention fixture in your test function argument, and test runner will take care of it. Fixtures are also available in hooks and other fixtures. If you use TypeScript, fixtures will have the right type.\n\nBelow we use the and fixtures defined above.\n\nIn addition to creating your own fixtures, you can also override existing fixtures to fit your needs. Consider the following example which overrides the fixture by automatically navigating to some :\n\nNotice that in this example, the fixture is able to depend on other built-in fixtures such as testOptions.baseURL. We can now configure in the configuration file, or locally in the test file with test.use().\n\nFixtures can also be overridden where the base fixture is completely replaced with something different. For example, we could override the testOptions.storageState fixture to provide our own data.\n\nPlaywright Test uses worker processes to run test files. Similarly to how test fixtures are set up for individual test runs, worker fixtures are set up for each worker process. That's where you can set up services, run servers, etc. Playwright Test will reuse the worker process for as many test files as it can, provided their worker fixtures match and hence environments are identical.\n\nBelow we'll create an fixture that will be shared by all tests in the same worker, and override the fixture to login into this account for each test. To generate unique accounts, we'll use the workerInfo.workerIndex that is available to any test or fixture. Note the tuple-like syntax for the worker fixture - we have to pass so that test runner sets up this fixture once per worker.\n\nAutomatic fixtures are set up for each test/worker, even when the test does not list them directly. To create an automatic fixture, use the tuple syntax and pass .\n\nHere is an example fixture that automatically attaches debug logs when the test fails, so we can later review the logs in the reporter. Note how it uses TestInfo object that is available in each test/fixture to retrieve metadata about the test being run.\n\nBy default, fixture shares timeout with the test. However, for slow fixtures, especially worker-scoped ones, it is convenient to have a separate timeout. This way you can keep the overall test timeout small, and give the slow fixture more time.\n\nPlaywright Test supports running multiple test projects that can be separately configured. You can use \"option\" fixtures to make your configuration options declarative and type-checked. Learn more about parametrizing tests.\n\nBelow we'll create a option in addition to the fixture from other examples. This option will be set in configuration file. Note the tuple syntax and argument.\n\nWe can now use fixture as usual, and set the option in the config file.\n\nArray as an option value\n\nIf the value of your option is an array, for example , you'll need to wrap it into an extra array when providing the value. This is best illustrated with an example.\n\nEach fixture has a setup and teardown phase separated by the call in the fixture. Setup is executed before the fixture is used by the test/hook, and teardown is executed when the fixture will not be used by the test/hook anymore.\n\nFixtures follow these rules to determine the execution order:\n• When fixture A depends on fixture B: B is always set up before A and torn down after A.\n• Non-automatic fixtures are executed lazily, only when the test/hook needs them.\n• Test-scoped fixtures are torn down after each test, while worker-scoped fixtures are only torn down when the worker process executing tests is shutdown.\n\nConsider the following example:\n\nNormally, if all tests pass and no errors are thrown, the order of execution is as following.\n• worker setup and section:\n• setup because it is required by .\n• setup because automatic worker fixtures are always set up before anything else.\n• section:\n• setup because automatic test fixtures are always set up before test and hooks.\n• setup because it is required in hook.\n• teardown because it is a test-scoped fixture and should be torn down after the test finishes.\n• teardown because it is a test-scoped fixture and should be torn down after the test finishes.\n• section:\n• setup because automatic test fixtures are always set up before test and hooks.\n• setup because it is required in hook.\n• setup because it is required by that is required by the .\n• setup because it is required by the .\n• teardown because it is a test-scoped fixture and should be torn down after the test finishes.\n• teardown because it is a test-scoped fixture and should be torn down after the test finishes.\n• teardown because it is a test-scoped fixture and should be torn down after the test finishes.\n• and worker teardown section:\n• teardown because it is a workers-scoped fixture and should be torn down once at the end.\n• teardown because it is a workers-scoped fixture and should be torn down once at the end.\n• teardown because it is a workers-scoped fixture and should be torn down once at the end.\n• and are set up and torn down for each test, as test-scoped fixtures.\n• is never set up because it is not used by any tests/hooks.\n• depends on and triggers its setup.\n• is lazily set up before the second test, but torn down once during worker shutdown, as a worker-scoped fixture.\n• is set up for hook, but is not.\n\nYou can merge test fixtures from multiple files or modules:\n\nUsually, custom fixtures are reported as separate steps in the UI mode, Trace Viewer and various test reports. They also appear in error messages from the test runner. For frequently-used fixtures, this can mean lots of noise. You can stop the fixtures steps from being shown in the UI by \"boxing\" it.\n\nThis is useful for non-interesting helper fixtures. For example, an automatic fixture that sets up some common data can be safely hidden from a test report.\n\nInstead of the usual fixture name, you can give fixtures a custom title that will be shown in test reports and error messages.\n\ntest.beforeEach() and test.afterEach() hooks run before/after each test declared in the same file and same test.describe() block (if any). If you want to declare hooks that run before/after each test globally, you can declare them as auto fixtures like this:\n\nAnd then import the fixtures in all your tests:\n\ntest.beforeAll() and test.afterAll() hooks run before/after all tests declared in the same file and same test.describe() block (if any), once per worker process. If you want to declare hooks that run before/after all tests in every file, you can declare them as auto fixtures with as follows:\n\nAnd then import the fixtures in all your tests:\n\nNote that the fixtures will still run once per worker process, but you don't need to redeclare them in every file."
    },
    {
        "link": "https://testgrid.io/blog/playwright-testing",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/71573243/root-level-hooks-in-playwright-test",
        "document": "Referring the documentation provided by playwright, seems like the hooks (example: afterAll / beforeAll) can be used only inside a spec/ test file as below:\n\nMy question: is there any support where there can be only one AfterAll() or beforeAll() hook in one single file which will be called for every test files ? the piece of code that i want to have inside the afterAll and beforeAll is common for all the test/ specs files and i dont want to have the same duplicated in all the spec files/ test file. Any suggestion or thoughts on this?"
    }
]