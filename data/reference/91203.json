[
    {
        "link": "https://support.microsoft.com/en-us/office/create-custom-functions-in-excel-2f06c10b-3622-40d6-a1b2-b6748ae8231f",
        "document": "Although Excel includes a multitude of built-in worksheet functions, chances are it doesn't have a function for every type of calculation you perform. The designers of Excel couldn't possibly anticipate every user's calculation needs. Instead, Excel provides you with the ability to create custom functions, which are explained in this article. Tip: The information in this article is intended for advanced Excel users. For more information regarding functions, please go to Excel functions (by category).\n\nCustom functions, like macros, use the Visual Basic for Applications (VBA) programming language. They differ from macros in two significant ways. First, they use Function procedures instead of Sub procedures. That is, they start with a Function statement instead of a Sub statement and end with End Function instead of End Sub. Second, they perform calculations instead of taking actions. Certain kinds of statements, such as statements that select and format ranges, are excluded from custom functions. In this article, you'll learn how to create and use custom functions. To create functions and macros, you work with the Visual Basic Editor (VBE), which opens in a new window separate from Excel. Suppose your company offers a quantity discount of 10 percent on the sale of a product, provided the order is for more than 100 units. In the following paragraphs, we'll demonstrate a function to calculate this discount. The example below shows an order form that lists each item, quantity, price, discount (if any), and the resulting extended price. To create a custom DISCOUNT function in this workbook, follow these steps:\n• Press Alt+F11 to open the Visual Basic Editor (on the Mac, press FN+ALT+F11), and then click Insert > Module. A new module window appears on the right-hand side of the Visual Basic Editor.\n• Copy and paste the following code to the new module. Function DISCOUNT(quantity, price) If quantity >=100 Then DISCOUNT = quantity * price * 0.1 Else DISCOUNT = 0 End If DISCOUNT = Application.Round(Discount, 2) End Function Note: To make your code more readable, you can use the Tab key to indent lines. The indentation is for your benefit only, and is optional, as the code will run with or without it. After you type an indented line, the Visual Basic Editor assumes your next line will be similarly indented. To move out (that is, to the left) one tab character, press Shift+Tab.\n\nNow you're ready to use the new DISCOUNT function. Close the Visual Basic Editor, select cell G7, and type the following: Excel calculates the 10 percent discount on 200 units at $47.50 per unit and returns $950.00. In the first line of your VBA code, Function DISCOUNT(quantity, price), you indicated that the DISCOUNT function requires two arguments, quantity and price. When you call the function in a worksheet cell, you must include those two arguments. In the formula =DISCOUNT(D7,E7), D7 is the quantity argument, and E7 is the price argument. Now you can copy the DISCOUNT formula to G8:G13 to get the results shown below. Let's consider how Excel interprets this function procedure. When you press Enter, Excel looks for the name DISCOUNT in the current workbook and finds that it is a custom function in a VBA module. The argument names enclosed in parentheses, quantity and price, are placeholders for the values on which the calculation of the discount is based. The If statement in the following block of code examines the quantity argument and determines whether the number of items sold is greater than or equal to 100: If quantity >= 100 Then DISCOUNT = quantity * price * 0.1 Else DISCOUNT = 0 End If If the number of items sold is greater than or equal to 100, VBA executes the following statement, which multiplies the quantity value by the price value and then multiplies the result by 0.1: The result is stored as the variable Discount. A VBA statement that stores a value in a variable is called an assignment statement, because it evaluates the expression on the right side of the equal sign and assigns the result to the variable name on the left. Because the variable Discount has the same name as the function procedure, the value stored in the variable is returned to the worksheet formula that called the DISCOUNT function. If quantity is less than 100, VBA executes the following statement: Finally, the following statement rounds the value assigned to the Discount variable to two decimal places: VBA has no ROUND function, but Excel does. Therefore, to use ROUND in this statement, you tell VBA to look for the Round method (function) in the Application object (Excel). You do that by adding the word Application before the word Round. Use this syntax whenever you need to access an Excel function from a VBA module.\n\nThe number of VBA keywords you can use in custom functions is smaller than the number you can use in macros. Custom functions are not allowed to do anything other than return a value to a formula in a worksheet, or to an expression used in another VBA macro or function. For example, custom functions cannot resize windows, edit a formula in a cell, or change the font, color, or pattern options for the text in a cell. If you include \"action\" code of this kind in a function procedure, the function returns the #VALUE! error. The one action a function procedure can do (apart from performing calculations) is display a dialog box. You can use an InputBox statement in a custom function as a means of getting input from the user executing the function. You can use a MsgBox statement as a means of conveying information to the user. You can also use custom dialog boxes, or UserForms, but that's a subject beyond the scope of this introduction.\n\nEven simple macros and custom functions can be difficult to read. You can make them easier to understand by typing explanatory text in the form of comments. You add comments by preceding the explanatory text with an apostrophe. For example, the following example shows the DISCOUNT function with comments. Adding comments like these makes it easier for you or others to maintain your VBA code as time passes. If you need to make a change to the code in the future, you'll have an easier time understanding what you did originally. An apostrophe tells Excel to ignore everything to the right on the same line, so you can create comments either on lines by themselves or on the right side of lines containing VBA code. You might begin a relatively long block of code with a comment that explains its overall purpose and then use inline comments to document individual statements. Another way to document your macros and custom functions is to give them descriptive names. For example, rather than name a macro Labels, you could name it MonthLabels to describe more specifically the purpose the macro serves. Using descriptive names for macros and custom functions is especially helpful when you've created many procedures, particularly if you create procedures that have similar but not identical purposes. How you document your macros and custom functions is a matter of personal preference. What's important is to adopt some method of documentation, and use it consistently.\n\nMaking your custom functions available anywhere To use a custom function, the workbook containing the module in which you created the function must be open. If that workbook is not open, you get a #NAME? error when you try to use the function. If you reference the function in a different workbook, you must precede the function name with the name of the workbook in which the function resides. For example, if you create a function called DISCOUNT in a workbook called Personal.xlsb and you call that function from another workbook, you must type =personal.xlsb!discount(), not simply =discount(). You can save yourself some keystrokes (and possible typing errors) by selecting your custom functions from the Insert Function dialog box. Your custom functions appear in the User Defined category: An easier way to make your custom functions available at all times is to store them in a separate workbook and then save that workbook as an add-in. You can then make the add-in available whenever you run Excel. Here's how to do this:\n• After you have created the functions you need, click File > Save As.\n• In the Save As dialog box, open the Save As Type drop-down list, and select Excel Add-In. Save the workbook under a recognizable name, such as MyFunctions, in the AddIns folder. The Save As dialog box will propose that folder, so all you need to do is accept the default location.\n• After you have saved the workbook, click File > Excel Options.\n• In the Excel Options dialog box, click the Add-Ins category.\n• In the Manage drop-down list, select Excel Add-Ins. Then click the Go button.\n• In the Add-Ins dialog box, select the check box beside the name you used to save your workbook, as shown below.\n• After you have created the functions you need, click File > Save As.\n• In the Save As dialog box, open the Save As Type drop-down list, and select Excel Add-In. Save the workbook under a recognizable name, such as MyFunctions.\n• After you have saved the workbook, click Tools > Excel Add-Ins.\n• In the Add-Ins dialog box, select the Browse button to find your add-in, click Open, then check the box beside your Add-In in the Add-Ins Available box. After you follow these steps, your custom functions will be available each time you run Excel. If you want to add to your function library, return to the Visual Basic Editor. If you look in the Visual Basic Editor Project Explorer under a VBAProject heading, you will see a module named after your add-in file. Your add-in will have the extension .xlam. Double-clicking that module in the Project Explorer causes the Visual Basic Editor to display your function code. To add a new function, position your insertion point after the End Function statement that terminates the last function in the Code window, and begin typing. You can create as many functions as you need in this manner, and they will always be available in the User Defined category in the Insert Function dialog box."
    },
    {
        "link": "https://learn.microsoft.com/en-us/office/dev/add-ins/excel/custom-functions-overview",
        "document": "Custom functions enable developers to add new functions to Excel by defining those functions in JavaScript as part of an add-in. Users within Excel can access custom functions just as they would any native function in Excel, such as .\n\nNote that Excel custom functions are available on the following platforms. Excel custom functions aren't currently supported in the following:\n• volume-licensed perpetual versions of Office 2019 or earlier on Windows\n\nThe following animated image shows your workbook calling a function you've created with JavaScript or TypeScript. In this example, the custom function calculates the volume of a sphere.\n\nThe following code defines the custom function .\n\nHow a custom function is defined in code\n\nIf you use the Yeoman generator for Office Add-ins to create an Excel custom functions add-in project, it creates files which control your functions and task pane. We'll concentrate on the files that are important to custom functions.\n\nThe script file (./src/functions/functions.js or ./src/functions/functions.ts) contains the code that defines custom functions and comments which define the function.\n\nThe following code defines the custom function . The code comments are used to generate a JSON metadata file that describes the custom function to Excel. The required comment is declared first, to indicate that this is a custom function. Next, two parameters are declared, and , followed by their properties. Finally, a description is given. For more information about what comments are required for your custom function, see Autogenerate JSON metadata for custom functions.\n\nThe add-in only manifest file for an add-in that defines custom functions (./manifest.xml in the project that the Yeoman generator for Office Add-ins creates) does several things.\n• Defines the namespace for your custom functions. A namespace prepends itself to your custom functions to help customers identify your functions as part of your add-in.\n• Uses <ExtensionPoint> and <Resources> elements that are unique to a custom functions manifest. These elements contain the information about the locations of the JavaScript, JSON, and HTML files.\n• Specifies which runtime to use for your custom function. We recommend always using a shared runtime unless you have a specific need for another runtime, because a shared runtime allows for the sharing of data between functions and the task pane.\n\nTo see a full working manifest from a sample add-in, see the manifest in the one of our Office Add-in samples Github repositories.\n\nIf you'll be testing your add-in across multiple environments (for example, in development, staging, demo, etc.), we recommend that you maintain a different manifest file for each environment. In each manifest file, you can:\n• None Specify the URLs that correspond to the environment.\n• None Customize metadata values so that end users are able to identify a sideloaded add-in's corresponding environment. For example:\n• In the unified manifest for Microsoft 365, customize the \"name\" property of the add-in and the \"label\" properties for various UI controls to indicate the environment.\n• In the add-in only manifest, customize the element and and labels within the element to indicate the environment.\n• None Customize the custom functions to indicate the environment, if your add-in defines custom functions. By following this guidance, you'll streamline the testing process and avoid issues that would otherwise occur when an add-in is simultaneously sideloaded for multiple environments.\n\nExcel on the web and on Windows connected to a Microsoft 365 subscription allow end users to coauthor in Excel. If an end user's workbook uses a custom function, that end user's coauthoring colleague is prompted to load the corresponding custom functions add-in. Once both users have loaded the add-in, the custom function shares results through coauthoring.\n\nFor more information on coauthoring, see About coauthoring in Excel.\n\nWant to try out custom functions? Check out the simple custom functions quick start or the more in-depth custom functions tutorial if you haven't already.\n\nAnother easy way to try out custom functions is to use Script Lab, an add-in that allows you to experiment with custom functions right in Excel. You can try out creating your own custom function or play with the provided samples.\n• Configure your Office Add-in to use a shared runtime"
    },
    {
        "link": "https://learn.microsoft.com/en-us/office/vba/language/reference/user-interface-help/function-statement",
        "document": "Declares the name, arguments, and code that form the body of a Function procedure.\n\n[Public | Private | Friend] [ Static ] Function name [ ( arglist ) ] [ As type ]\n\n [ statements ]\n\n [ name = expression ]\n\n [ Exit Function ]\n\n [ statements ]\n\n [ name = expression ]\n\n End Function\n\nThe Function statement syntax has these parts:\n\nThe arglist argument has the following syntax and parts:\n\nIf not explicitly specified by using Public, Private, or Friend, Function procedures are public by default.\n\nIf Static isn't used, the value of local variables is not preserved between calls.\n\nThe Friend keyword can only be used in class modules. However, Friend procedures can be accessed by procedures in any module of a project. A Friend procedure does not appear in the type library of its parent class, nor can a Friend procedure be late bound.\n\nFunction procedures can be recursive; that is, they can call themselves to perform a given task. However, recursion can lead to stack overflow. The Static keyword usually isn't used with recursive Function procedures.\n\nAll executable code must be in procedures. You can't define a Function procedure inside another Function, Sub, or Property procedure.\n\nThe Exit Function statement causes an immediate exit from a Function procedure. Program execution continues with the statement following the statement that called the Function procedure. Any number of Exit Function statements can appear anywhere in a Function procedure.\n\nLike a Sub procedure, a Function procedure is a separate procedure that can take arguments, perform a series of statements, and change the values of its arguments. However, unlike a Sub procedure, you can use a Function procedure on the right side of an expression in the same way you use any intrinsic function, such as Sqr, Cos, or Chr, when you want to use the value returned by the function.\n\nYou call a Function procedure by using the function name, followed by the argument list in parentheses, in an expression. See the Call statement for specific information about how to call Function procedures.\n\nTo return a value from a function, assign the value to the function name. Any number of such assignments can appear anywhere within the procedure. If no value is assigned to name, the procedure returns a default value: a numeric function returns 0, a string function returns a zero-length string (\"\"), and a Variant function returns Empty. A function that returns an object reference returns Nothing if no object reference is assigned to name (using Set) within the Function.\n\nThe following example shows how to assign a return value to a function. In this case, False is assigned to the name to indicate that some value was not found.\n\nVariables used in Function procedures fall into two categories: those that are explicitly declared within the procedure and those that are not.\n\nVariables that are explicitly declared in a procedure (using Dim or the equivalent) are always local to the procedure. Variables that are used but not explicitly declared in a procedure are also local unless they are explicitly declared at some higher level outside the procedure.\n\nA procedure can use a variable that is not explicitly declared in the procedure, but a naming conflict can occur if anything you defined at the module level has the same name. If your procedure refers to an undeclared variable that has the same name as another procedure, constant, or variable, it is assumed that your procedure refers to that module-level name. Explicitly declare variables to avoid this kind of conflict. Use an Option Explicit statement to force explicit declaration of variables.\n\nVisual Basic may rearrange arithmetic expressions to increase internal efficiency. Avoid using a Function procedure in an arithmetic expression when the function changes the value of variables in the same expression. For more information about arithmetic operators, see Operators.\n\nThis example uses the Function statement to declare the name, arguments, and code that form the body of a Function procedure. The last example uses hard-typed, initialized Optional arguments.\n\nUsing the ParamArray keyword enables a function to accept a variable number of arguments. In the following definition, it is passed by value.\n\nOptional arguments can have default values and types other than Variant.\n\nHave questions or feedback about Office VBA or this documentation? Please see Office VBA support and feedback for guidance about the ways you can receive support and provide feedback."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-create-a-user-defined-function-in-excel-vba",
        "document": "A function is a collection of code. As a developer, we very often need a custom function (User-defined function) in our projects. These functions can be used as normal functions in Excel. These are helpful when the existing functions are not enough. In such cases, the user can create his own custom user-defined function to fulfil the need.\n\nUser Defined Function(UDF) is the custom function that is created by the user to perform a specific task in VBA(Virtual basic application) which is a programming language in Excel.\n\nIn VBA, a ‘Subroutine’ lets you run a group of commands, while a ‘Function’ provides a result.\n\nFor example, consider a list of numbers, some positive and some negative. With a subroutine, you can scan each cell and mark negative ones by changing their colour. The subroutine modifies the cell properties.\n\nOn the other hand, a custom function can be used in a separate column. It returns TRUE for negative values and FALSE for positive ones. Functions can’t change cell properties directly but can be used with conditional formatting for the same effect.\n\nWhen you create a User Defined Function (UDF) in VBA, you can use it just like any other Excel function, as I’ll explain further in the ‘Different Ways to Use a User Defined Function in Excel’ section.\n\nVBA, a function is like a helpful tool that can give you a result if you ask it nicely. It’s like having a magic box that you put some things into (we call them parameters), and it gives you something back (we call it a return value).\n\nOne cool thing about this magic box is that it can give you not just one thing but a bunch of things all at once, and we call that a list or an array.\n\nBefore you can use this magic box, you need to tell VBA how it works. You do this by using the word “Function,” giving your magic box a special name, and then describing how it should work with any parameters it needs. Finally, you use “End Function” to say you’re done explaining.\n\nHow to Create a User-Defined Function in VBA\n\nHere we explain how to create a UDF (user-defined function) to count/return the Number of vowels in a given string using Excel VBA.\n\nFollow the below steps to create a User-defined Function in Excel VBA:\n\nStep 3: Click Insert >> Module – which will add a new module as in Img1.\n\nThe VBA code window will be opened where you can write the code of the Function.\n\nStep 4: Type the below code in “code window”.\n• None Iterate each character of a given string and check the character is vowel or not. If it is vowel character increase vowelCount = vowelCount +1\n\nTo activate a function, you simply use the function name, just like in the example provided in the screenshot.\n\nStep 1: Type “Customer” in cell “A1” and “Vowels_Count” in cell “B1” as header.\n\nStep 2: Write below formula in cell “B2” and drag it to fill “B2:B6” .\n\nYou have to make your function public if you want to access that function in all worksheets of the workbook. For making a function public, you just need to use the word “Public”.\n\nWhen you make a function private you can use that particular function in the procedure of the same module. To make a function private just use the word “Private”\n\nIf you have made a function privately in Module 1, then you can it in procedures you have in Module 1. And it won’t appear in the function list of teh worksheet (when you use = sign and try to type the name) but you can use it by specifying it’s name and arguments.\n\nFunction and Sub in Excel VBA\n\nWhy you should create a User defined function?\n\nFollowing can be the reasons to create user defined function When there is no function for this Sometimes there is no specific formula for what you need to calculate. In that case you can create your own function to perform a particular task. There are some formulas which are difficult to understand and also hard to use. In that case you can create your own easy custom formula to perform a particular task. When you don’t want to use Sub Routine Although you can use a VBA code to perform a calculation but if you want to repeat the task then you have to run that code and again if you update your calculation. But if you convert that code into a function then you simply insert it as a function instead of running that code again and again.\n\nHow you can create a user defined function in Excel?\n\nWhat are the different ways to create a VBA function in Excel?\n\nWhat are the Limitations of using User Defined Function in Excel?"
    },
    {
        "link": "https://zerotomastery.io/blog/user-defined-functions-in-vba",
        "document": "If you’re an experienced Excel user, there’s a pretty good chance that you’ve already leveraged Excel’s built-in programming language, VBA.\n\nEven if just simply recording macros to automate mundane tasks; such as writing values to cells, formatting data, saving files, and the like.\n\nHowever, there's a completely different and equally useful application of VBA code called user-defined functions or ‘UDF’s’, that most people miss.\n\nSimply put, UDFs are functions that work just like standard built-in Excel functions, like SUM or VLOOKUP. The biggest difference though is that they can also be customized to your exact requirements.\n\nNow obviously, if there's a built-in Excel function that can be used to accomplish a certain task - and many times there will be since Excel has so many built-in functions - you should go ahead and use that. Not only will it be simple to use, but built-in functions perform much faster than user-defined functions created with VBA.\n\nBut as awesome as Excel is, sometimes there just isn't an Excel function that does exactly what you need, and in those cases, the ability to “roll your own” custom function with VBA is worth its weight in virtual gold.\n\nSo what's the difference between VBA subroutines and functions?\n\nYou might be thinking;\n\n“Why would I want to create a function, when the VBA macro recorder could make a subroutine instead?”\n\nWell there's a few reasons, but the main point comes down to how they actually work. You see, the fundamental difference between VBA subroutines (the batches of code generated by the macro recorder) and functions, is that while subroutines do something, functions return something: aka a single value.\n\nConsider how standard Excel functions work. If you enter a function in a cell, that function will return a single value in that cell. And sometimes, that’s exactly what you want to happen - especially if you want your function to reference that value, which is what we'll be looking into in these 2 examples.\n\nSo with that said, let's dive right into building our own simple user-defined function.\n\nExample #1: Creating your first User-Designed Function (UDF)\n\nI’m going to walk you through 2 examples, starting with a very basic UDF first so you can see how it all works, and then we’ll get into a more complex one in a second.\n\nFor this first example, we’re going to create a simple UDF that works like this. When someone writes their name into a cell, it returns with a Hello and uses their name as reference.\n\nNothing too exciting but this will help you grasp these concepts before we move on to more complex situations.\n\nSo, to demonstrate how this works, let’s head over to the VBA editor by using the keyboard shortcut Alt + F11, and then insert a new module by right-clicking in the Project Window and choosing Insert >> Module:\n\nThen we can rename the module in the Properties Window to something more descriptive, such as “UtilityFunctions”:\n\nAnd just like that, we're ready to write our first user-defined function!\n\nSo the basic syntax goes like this:\n\nWe start off by typing the word \"Function”, followed by the name of your function, which in this case will be “Hello”.\n\nWe’ll also need a pair of parentheses () after the function name, regardless of whether the function will take any arguments or not.\n\nThe other mandatory piece of syntax is that our function code should end with the keywords “End Function”.\n\nHere's a cool thing though - we don't actually even have to type that out, because if we just enter down from where we declared our function, VBA types it out for us.\n\nSo unlike macros and subroutines, user-defined functions in VBA typically take pieces of data or 'arguments' that the user passes to the function, and we specify those in between those two parentheses after the function name.\n\nIt sounds complex but this is very similar to standard Excel functions, such as passing a SUM function to make a series of numbers add together.\n\nX is one variable and Y is the other (usally we would select a range of cells, but you get the idea).\n\nWe’ll also need to specify a data type for each argument we pass in between these parentheses, after which those arguments will be available as variables in the body of the function.\n\nIn this case, the “body” is basically everything between the line where you declare the function, and “End Function”. These variables can be then used as part of the calculations that ultimately return a value from the function.\n\nSo now that we understand the basics, let's go ahead and fill out our function. First up, our function will take an argument called “name”, with a “String” data type.\n\nNote that the syntax for specifying an argument is the argument name, followed by the keyword “As”, then the data type of the argument.\n\nAnd now for the, well, 'function-ality' of our function.\n\nIn simple terms, they enter their name, and it says hello back to them. But in technical terms, our objective is to concatenate whatever name the user passes in as an argument to the function, to the word “hello” (followed by a space).\n\nThis means that our function will essentially return a personalized greeting in whatever cell of the spreadsheet that the user enters the function.\n\nSo to return a value from a function, in the last line of code in the function body, we'll need to set the name of the function itself (“Hello” in this case) to whatever value we want to return.\n\nThis is almost like the name of the function itself is a variable, and we're setting its value. Sounds weird I know, but once you've written a few user-defined functions you get used to it.\n\nNow our very simple function will only have one line of code in the entire function body, so we don’t need to worry about making it the “last” line, as it is set as this by default!\n\nAs such, we can go ahead and set up that return value by typing the name of our function, followed by an equals sign…\n\nNow we can create an expression to concatenate a greeting to whatever name the user passes into our function.\n\nSo we'll type “Hello” with a space after it (nested in quotes, since we’re dealing with a text string), then add an ampersand to concatenate the pieces of text together, and finally we'll add the “name” variable, which will capture whatever input the user provides via our function’s argument.\n\nAnd just to make the greeting especially enthusiastic, I'll also concatenate an exclamation mark at the end of the expression, like so:\n\nTo reiterate, by assigning the expression we just created to the name of the overall function, we're basically telling VBA that we want the output of this expression to be returned whenever somebody enters this function into a cell in their spreadsheet.\n\nSo at this point, our function should be good to take for a test run, so let's head over to Excel.\n\nAnd now, instead of executing our VBA by running a macro, as you might have done before, we're simply going to invoke the name of our user-defined function like any other Excel function.\n\nAnd as you can see, Excel is smart enough to recommend our user-defined function via autocomplete, just like with standard Excel functions.\n\nSo let's hit Tab to select our function, and then for the single argument it takes, I'll just enter my name:\n\nNow if we close the parentheses just like with any other function and then hit enter, it should now pull that argument (my name) and print our personalized greeting.\n\nExample #2: How to create a more complex UDF\n\nSo now that you've created your very first user-defined function, it's time to take on a slightly more complex and practical example, and write a function that calculates compound interest.\n\nThis means it will calculate the value of an investment at some point in the future, based on:\n• The rate of return on the investment\n• And how many periods the investment can appreciate over (that is to say, how many years into the future we're trying to project the value of the investment for)\n\nHere’s the formula for compound interest, assuming that interest is calculated annually.\n\nSo let's break down what this means. In this formula:\n• A represents the future value of our investment after it has appreciated\n• P stands for the principal, which is basically the initial amount we're investing\n• i is the interest rate, or rate of return\n• And N is the number of years over which that interest is compounded – basically, the time horizon of interest for our investment\n\nAnd as you can see, the formula to get to our final amount A is: 1 plus the interest rate i, raised to the power of the number of years 'n' over which the investment is compounded, all multiplied by the initial principal 'p'.\n\nHere's how to set it all up\n\nWhen translating a formula like this into VBA code, or most any other programming language, the first step in assembling the “algorithm” is typically to identify the variables (or in our specific case, function arguments), and declare them with appropriate data types.\n\nSo let’s stand up the frame of our function, and then dig into those arguments.\n\nFirst up, right below our “Hello” function definition in the same module, I'll create an empty shell of a function named “CompoundInterest”:\n\nThe next step, as we saw earlier, will be to define our function arguments with appropriate data types.\n\nOur first argument will be for the initial amount of the investment, which was P in our formula.\n\nSince that investment could potentially have a decimal component (i.e., dollars AND cents), we'll define it with a double data type.\n\nNext up is our interest rate argument i, which could also obviously have a decimal component, so we'll make it a double as well.\n\nThen there’s N, which represents the number of years over which our investment is compounding. To keep things simple, we'll only worry about whole numbers of years, so we can make that argument an integer.\n\nWith our function arguments set up, there’s actually not all that much work left to do. It’s really just a matter of replicating that formula for compound interest, but using our function arguments as the respective variables/inputs to the formula, like so:\n\nBut just like with our “Hello” function, we’ll also need to make sure the output of that formula/expression is explicitly assigned as the return value of the function, which we can do by preceding the expression with the name of our function - CompoundInterest – followed by the equals sign:\n\nAt this point, our function should be fully operational (cue Star Wars theme), so now let's see it in action!\n\nFlipping back to Excel in our workbook, in a random cell I’ll type “=comp”; note that I’m NOT entering the entire name of the function.\n\nAs you can see, Excel is once again smart enough to “guess” that we wanted to use our CompoundInterest function, in the same way that it might “guess” VLOOKUP if we typed “=VL”.\n\nSo I’ll just arrow down to select it, and then hit Tab to lock it in.\n\nAnd now for the arguments – a.k.a., just how rich do I want to be in this hypothetical scenario?\n• Then, let's assume a very optimistic rate of return of 12%, or 0.12\n• Finally, we'll see what $10,000 at a 12% rate of return does over the course of 25 years\n\nNow closing the parentheses and hitting enter...\n\nIt looks like the final value of our $10,000 investment would be about $170,000 – not too shabby!\n\nAnd just to prove that this function responds dynamically to different inputs, if I change the rate of return to a more reasonable, say, 8%…\n\nOur final value drops by about $100,000, which is kind of a bummer, but at least we know our function is working!\n\nHow to package UDFs as Add-Ins\n\nNow that we know how to create user-defined functions, it's worth considering how we can access those functions outside the workbooks that we originally created them in. After all, a function that would be useful in one workbook would probably be useful in many, right?\n\nSo to share a collection of user-defined functions with our team (or anybody else who might use them), the best option is to package our functions as a VBA add-in, which will allow anyone who installs the add-in to use the functions as though they were already built into Excel.\n\nAnd the good news is that the process of doing this is super simple! So let's go ahead and package the two user-defined functions we've created as our very own add-in.\n\nThe first step will be to save the Excel file we've been working in – but not with the standard .xlsx extension, or even as a .xlsm “macro enabled file” file.\n\nInstead, we're going to save it as a .xlam file, which specifically denotes it as an add-in.\n\nSo let’s try saving our file As “Utility Functions.xlam”…\n\nNote here that Excel is recommending the file be saved to a designated “AddIns” folder, as a result of us choosing the Excel Add-in/.xlam file type. This is where Windows stores Microsoft add-ins by default, meaning that Excel “knows” to look here for such add-ins. As such, I’ll stick with the recommended defaults and hit “Save”.\n\nAt this point it will look like our file has disappeared, but it has not; rather, it’s simply been converted to an add-in.\n\nThe logical next step then, is to officially install this add-in to Excel. Once that’s been done, whenever we open up Excel on the same machine that the add-in is saved to, those functions in our add-in will be available to us in the same way as standard functions like SUM or VLOOKUP.\n\nSo to install the add-in, in any Excel workbook (it doesn’t matter which one), we'll select the Developer tab on the Ribbon…\n\nAnd then in the “Add-ins” section I'll hit the “Excel Add-ins” button:\n\nThis presents us with a list of four optional add-ins built right into Excel, but we're interested in our own custom add in, so we'll click “Browse”…\n\nThis takes us directly to the “AddIns” folder that our add-in file was saved to by default:\n\nNow if we simply select the file and click OK…\n\nWe see our “Utility Functions” add-in listed among the other available add-ins, but with a check mark next to it. Seems like a pretty good sign, so let's go ahead and click OK once again.\n\nNow, to prove our add-in can be used in any Excel file, I’ll close out of Excel altogether, then re-open it and create a new blank file.\n\nThe only thing left at this point is to see if those functions that we built into our add-in are available to us in this new instance of Excel. Let’s try our “Hello” function first:\n\nSo far, so good!\n\nNext up is testing our CompoundInterest UDF.\n\nLet's see what would happen if we invested $20,000 at a 10% rate of return for 22 years…\n\nAs you can see, UDF’s are incredibly helpful for any data analyst. And I again want to emphasize that these functions will be available in any spreadsheet, or on any computer in which the add-in has been installed to Excel.\n\nHow handy is that!?\n\nAnd by packaging custom UDFs as an add-in, you can effectively make them usable as standard, built-in Excel functions to anyone you want.\n\nThe only real limitation is your VBA programming skills, and your creativity in conceiving new ideas for functions.\n\nI can’t help you with the coming up with new function ideas, but if you want to take your UDF-creation skills to the next level by learning more about VBA, go ahead and check out my VBA Programming course.\n\nUnlike the usual “recipe” style tutorials you’ll find on the web, this is a serious programming course that will teach you exactly how to program in VBA, and is loaded with projects and exercises to make sure you master every concept.\n\nTrust me. Not only will learning VBA help make your life easier and your Excel tasks faster and automated, but your co-workers will thank you after they’ve installed your first add-in!"
    },
    {
        "link": "https://statology.org/vba-pi",
        "document": "In mathematics, Pi is an irrational number (a decimal with no end) that is equal to roughly 3.14.\n\nTo use Pi in calculations in VBA, you can use the following syntax:\n\nThis particular function allows you to multiply any value in Excel by Pi.\n\nNote that Application.WorksheetFunction.Pi returns the value 3.14159265358979, which is the constant Pi accurate to 15 digits.\n\nIf you need a calculation to be more accurate than 15 digits, you can simply hard code Pi to as many digits as you would like.\n\nThe following example shows how to use this syntax in practice.\n\nExample: How to Use Pi in VBA\n\nSuppose we have the following list of values in Excel that we would like to multiply by Pi:\n\nTo do so, we can create the following function in VBA:\n\nOnce we’ve created this function, we can then type the following formula into cell B2 to multiply the value in cell A2 by Pi:\n\nWe can then click and drag this formula down to each remaining cell in column B:\n\nColumn B now shows each value in column A multiplied by Pi.\n\nThe following tutorials explain how to perform other common tasks in VBA:\n\nVBA: How to Sum Values in Range\n\n VBA: How to Calculate Average Value of Range\n\n VBA: How to Count Number of Rows in Range"
    },
    {
        "link": "https://stackoverflow.com/questions/72409364/2worksheetfunction-pi-vs-23-14159265358979-value-of-pi-difference-in-precisi",
        "document": "I have noticed a precision difference between the following two calculations done in VBA (I'm using the VBA immediate window for output):\n\nNotice the last digit is 8, above was 9, even though 3.14159265358979 used in the calculation is the result given by \"WorksheetFunction.Pi\".\n\nThe first result is the more accurate result looking at the longer value of PI (2 * 3.141592653589793 = 6.283185307179586 which would round to 59).\n\nAny explanation for the above, and is it possible to manually use a longer value of Pi in VBA?"
    },
    {
        "link": "https://quora.com/What-Visual-Basic-code-can-be-used-to-compute-the-digits-of-pi",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://pisquare.osisoft.com/s/Blog-Detail/a8r1I000000Gv51QAC/vba-code-to-fill-a-range-with-pi-values-very-fast",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/14803742/approximating-pi-within-error",
        "document": "To start off, this is the problem.\n\nThe mathematical constant π (pi) is an irrational number with value approximately 3.1415928... The precise value of π is equal to the following infinite sum: π = 4/1 - 4/3 + 4/5 - 4/7 + 4/9 - 4/11 + ... We can get a good approximation of π by computing the sum of the first few terms. Write a function approxPi() that takes as a parameter a floating point value error and approximates the constant π within error by computing the above sum, term by term, until the absolute value of the difference between the current sum and the previous sum (with one fewer terms) is no greater than error. Once the function finds that the difference is less than error, it should return the new sum. Please note that this function should not use any functions or constants from the math module. You are supposed to use the described algorithm to approximate π, not use the built-in value in Python.\n\nI'd really appreciate it if someone could help me understand what the problem is asking, since I've read it so many times but still can't fully understand what it's saying. I looked through my textbook and found a similar problem for approximating e using e's infinite sum: 1/0! + 1/1! + 1/2! + 1/3!+...\n\nI tried to model my program after this, but I don't feel I'm getting any closer to the solution.\n\nAgain, any help would be appreciated. I'd like to just understand what I'm doing wrong in this."
    }
]