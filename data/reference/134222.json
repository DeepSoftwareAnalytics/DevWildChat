[
    {
        "link": "https://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper",
        "document": "You create a subclass implementing , and optionally , and this class takes care of opening the database if it exists, creating it if it does not, and upgrading it as necessary. Transactions are used to make sure the database is always in a sensible state.\n\nThis class makes it easy for implementations to defer opening and upgrading the database until first use, to avoid blocking application startup with long-running database upgrades.\n\nFor an example, see the NotePadProvider class in the NotePad sample application, in the samples/ directory of the SDK.\n\nNote: the interface was first added in the release.\n\nReturn the name of the SQLite database being opened, as given to the constructor. Create and/or open a database that will be used for reading and writing. Called when the database connection is being configured, to enable features such as write-ahead logging or foreign key support. Called when the database is created for the first time. Called when the database needs to be downgraded. Called when the database has been opened. Called when the database needs to be upgraded. This method was deprecated in API level 29. DO NOT USE this method. See the javadoc of for the details. This method should be called from the constructor of the subclass, before opening the database, since lookaside memory configuration can only be changed when no connection is using it SQLite default settings will be used, if this method isn't called. Sets configuration parameters that are used for opening . Enables or disables the use of write-ahead logging for the database.\n\nCreates and returns a copy of this object. Indicates whether some other object is \"equal to\" this one. Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. Returns the runtime class of this . Returns a hash code value for the object. Wakes up a single thread that is waiting on this object's monitor. Wakes up all threads that are waiting on this object's monitor. Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed. Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed. Causes the current thread to wait until it is awakened, typically by being notified or interrupted.\n\nCreate a helper object to create, open, and/or manage a database. The database is not actually created or opened until one of or is called. Accepts input param: a concrete instance of to be used to handle corruption when sqlite reports database corruption. : to use for locating paths to the the database This value may be . : of the database file, or null for an in-memory database : to use for creating cursor objects, or null for the default : number of the database (starting at 1); if the database is older, will be used to upgrade the database; if the database is newer, will be used to downgrade the database : the to be used when sqlite reports database corruption, or null to use the default error handler.\n\nCreate and/or open a database. This will be the same object returned by unless some problem, such as a full disk, requires the database to be opened read-only. In that case, a read-only database object will be returned. If the problem is fixed, a future call to may succeed, in which case the read-only database object will be closed and the read/write object will be returned in the future. Like , this method may take a long time to return, so you should not call it from the application main thread, including from . a database object valid until or is called. if the database cannot be opened\n\nCreate and/or open a database that will be used for reading and writing. The first time this is called, the database will be opened and , and/or will be called. Once opened successfully, the database is cached, so you can call this method every time you need to write to the database. (Make sure to call when you no longer need the database.) Errors such as bad permissions or a full disk may cause this method to fail, but future attempts may succeed if the problem is fixed. Database upgrade may take a long time, you should not call this method from the application main thread, including from . if the database cannot be opened for writing\n\nCalled when the database needs to be upgraded. The implementation should use this method to drop tables, add tables, or do anything else it needs to upgrade to the new schema version. The SQLite ALTER TABLE documentation can be found here. If you add new columns you can use ALTER TABLE to insert them into a live table. If you rename or remove columns you can use ALTER TABLE to rename the old table, then create the new table and then populate the new table with the contents of the old table. This method executes within a transaction. If an exception is thrown, all changes will automatically be rolled back. Important: You should NOT modify an existing migration step from version X to X+1 once a build has been released containing that migration step. If a migration step has an error and it runs on a device, the step will NOT re-run itself in the future if a fix is made to the migration step. For example, suppose a migration step renames a database column from to when the name should have been . If that migration step is released in a build and runs on a user's device, the column will be renamed to . If the developer subsequently edits this same migration step to change the name to as intended, the user devices which have already run this step will still have the name . Instead, a NEW migration step should be created to correct the error and rename to , ensuring the error is corrected on devices which have already run the migration step with the error.\n\nThis method was deprecated in API level 29.\n\n DO NOT USE this method. See the javadoc of for the details. Sets the maximum number of milliseconds that SQLite connection is allowed to be idle before it is closed and removed from the pool. This method should be called from the constructor of the subclass, before opening the database DO NOT USE this method. This feature has negative side effects that are very hard to foresee. See the javadoc of for the details. : timeout in milliseconds. Use value to allow unlimited idle connections. Value is 0 or greater"
    },
    {
        "link": "https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase",
        "document": "SQLiteDatabase has methods to create, delete, execute SQL commands, and perform other common database management tasks.\n\nSee the Notepad sample application in the SDK for an example of creating and managing a database.\n\nDatabase names must be unique within an application, not across all applications.\n\nIn addition to SQLite's default collator, Android supplies two more, , which changes with the system's current locale, and , which is the Unicode Collation Algorithm and not tailored to the current locale.\n\nBegins a transaction in DEFERRED mode, with the android-specific constraint that the transaction is read-only. Convenience method for deleting rows in the database. Deletes a database including its journal file and other auxiliary files that may have been created by the database engine. This method disables the features enabled by . This method enables parallel execution of queries from multiple threads on the same database. Execute the given SQL statement on all connections to this database. Execute a single SQL statement that is NOT a SELECT or any other SQL statement that returns data. Execute a single SQL statement that is NOT a SELECT/INSERT/UPDATE/DELETE. Finds the name of the first table, which is editable. Returns list of full pathnames of all attached databases including the main database by executing 'pragma database_list' on the database. Return the number of database rows that were inserted, updated, or deleted by the most recent SQL statement within the current transaction. Return the \"rowid\" of the last row to be inserted on the current connection. Returns the maximum size the database may grow to. Gets the path to the database file. This method was deprecated in API level 15. This method no longer serves any useful purpose and has been deprecated. Return the total number of database rows that have been inserted, updated, or deleted on the current connection since it was created. Returns true if the current thread has a transaction pending. Convenience method for inserting a row into the database. Convenience method for inserting a row into the database. General method for inserting a row into the database. Runs 'pragma integrity_check' on the given database (and all the attached databases) and returns true if the given database (and all its attached databases) pass integrity_check, false otherwise. Returns true if the current thread is holding an active connection to the database. This method was deprecated in API level 16. Always returns false. Do not use this method. Returns true if the database is currently open. Returns true if the database is opened as read only. Returns true if write-ahead logging has been enabled for this database. This method was deprecated in API level 15. This method no longer serves any useful purpose and has been deprecated. This method was deprecated in API level 15. This method no longer serves any useful purpose and has been deprecated. Returns true if the new version code is greater than the current database version. Open the database according to the flags and/or . Open the database according to the specified Open the database according to the flags and/or . Query the given URL, returning a over the result set. Query the given table, returning a over the result set. Query the given URL, returning a over the result set. Query the given table, returning a over the result set. Query the given URL, returning a over the result set. Query the given URL, returning a over the result set. Runs the provided SQL and returns a over the result set. Runs the provided SQL and returns a over the result set. Runs the provided SQL and returns a cursor over the result set. Runs the provided SQL and returns a cursor over the result set. Attempts to release memory that SQLite holds but does not require to operate properly. Convenience method for replacing a row in the database. Convenience method for replacing a row in the database. Register a custom aggregate function that can be called from SQL expressions. Register a custom scalar function that can be called from SQL expressions. Sets whether foreign key constraints are enabled for the database. Sets the locale for this database. This method was deprecated in API level 16. This method now does nothing. Do not use. Sets the maximum size of the prepared-statement cache for this database. Sets the maximum size the database will grow to. Convenience method for updating rows in the database. Convenience method for updating rows in the database. Verifies that a SQL SELECT statement is valid by compiling it. This method was deprecated in API level 15. if the db is locked more than once (because of nested transactions) then the lock will not be yielded. Use yieldIfContendedSafely instead. Temporarily end the transaction to let other threads run. Temporarily end the transaction to let other threads run.\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2025-02-10 UTC.\"],[],[]]"
    },
    {
        "link": "https://github.com/OneSignal/OneSignal-Android-SDK/issues/988",
        "document": "Description:\n\n I was running version 3.11.1 of the SDK for a long time and recently updated it to version 3.12.7 and then to 3.13.0. After that I'm receiving crash logs related to the SDK with android.database.sqlite.SQLiteDatabaseLockedException. Besides that I've updated target and compile SDK versions from 28 to 29.\n\nIn fact I don't have steps to reproduce, but I hope the attached stack traces could help."
    },
    {
        "link": "https://stackoverflow.com/questions/6554269/no-such-table-error-found-in-sqlite-android",
        "document": "I am trying to learn about SQLite databases, but I really hate dealing with any back-end stuff, with a passion. I'm already hitting walls with a seemingly simple problem.\n\nHere is the code that I think matters from the class\n\nAnd this is the code in my main activity\n\nEclipse is telling me that there is an error in the method. It says that there is . I have no idea what I am doing wrong here. What makes it more frustrating is that only a couple of minutes before it was working perfectly, then (I think) I dropped the table and it just create it again for whatever reason, even though this code has not changed since I first created it (I think...)."
    },
    {
        "link": "http://opensource.hcltechsw.com/volt-mx-native-function-docs/Android/android.database.sqlite-Android-10.0#!/api/android.database.sqlite.SQLiteOpenHelper",
        "document": ""
    },
    {
        "link": "https://developer.android.com/topic/performance/sqlite-performance-best-practices",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nAndroid offers built-in support for SQLite, an efficient SQL database. Follow these best practices to optimize your app's performance, ensuring it remains fast and predictably fast as your data grows. By using these best practices, you also reduce the possibility of encountering performance issues that are difficult to reproduce and troubleshoot.\n• None Read fewer rows and columns: Optimize your queries to retrieve only the necessary data. Minimize the amount of data read from the database, because excess data retrieval can impact performance.\n• None Push work to SQLite engine: Perform computations, filtering, and sorting operations within the SQL queries. Using SQLite's query engine can significantly improve performance.\n• None Modify the database schema: Design your database schema to help SQLite construct efficient query plans and data representations. Properly index tables and optimize table structures to enhance performance.\n\nAdditionally, you can use the available troubleshooting tools to measure the performance of your SQLite database to help identify areas that require optimization.\n\nWe recommend using the Jetpack Room library.\n\nFollow the steps in this section to configure your database for optimal performance in SQLite.\n\nSQLite implements mutations by appending them to a log, which it occasionally compacts into the database. This is called Write-Ahead Logging (WAL).\n\nEnable WAL unless you are using .\n\nWhen using WAL, by default every commit issues an to help ensure that the data reaches the disk. This improves data durability but slows down your commits.\n\nSQLite has an option to control synchronous mode. If you enable WAL, set synchronous mode to :\n\nIn this setting, a commit can return before the data is stored in a disk. If a device shutdown occurs, such as on loss of power or a kernel panic, the committed data might be lost. However, because of logging, your database isn't corrupted.\n\nIf only your app crashes, your data still reaches the disk. For most apps, this setting yields performance improvements at no material cost.\n\nTo optimize performance and minimize data consumption, define an efficient table schema. SQLite constructs efficient query plans and data, leading to faster data retrieval. This section provides best practices for creating table schemas.\n\nFor this example, define and populate a table as follows:\n\nThe table output is as follows:\n\nThe column is an index that preserves insertion order. Queries that filter by are implemented as a fast B-tree search, but queries that filter by are a slow table scan.\n\nIf you plan on doing lookups by , you can avoid storing the column for less data in storage and an overall faster database:\n\nYour table now looks as follows:\n\nSince you don't need to store the column, queries are fast. Note that the table is now sorted based on instead of insertion order.\n\nSQLite uses indexes to accelerate queries. When filtering ( ), sorting ( ), or aggregating ( ) a column, if the table has an index for the column, the query is accelerated.\n\nIn the previous example, filtering by requires scanning the entire table:\n\nFor an app with a lot of city queries, you can accelerate those queries with an index:\n\nAn index is implemented as an additional table, sorted by the index column and mapped to :\n\nNote that the storage cost of the column is now double, because it's now present in both the original table and the index. Since you are using the index, the cost of added storage is worth the benefit of faster queries. However, don't maintain an index that you're not using to avoid paying the storage cost for no query performance gain.\n\nIf your queries combine multiple columns, you can create multi-column indexes to fully accelerate the query. You can also use an index on an outside column and let the inside search be done as a linear scan.\n\nFor instance, given the following query:\n\nYou can accelerate the query with a multi-column index in the same order as specified in the query:\n\nHowever, if you only have an index on , the outside ordering is still accelerated, while the inside ordering requires a linear scan.\n\nThis also works with prefix inquiries. For example, an index also accelerates filtering, ordering, and grouping by , since the index table for a multi-column index is ordered by the given indexes in the given order.\n\nBy default, SQLite creates a column for your table, where is an implicit . If you already have a column that is , then this column becomes an alias of .\n\nFor tables that have a primary key other than or a composite of columns, consider .\n\nStore small data as a and large data as a file\n\nIf you want to associate large data with a row, such as a thumbnail of an image or a photo for a contact, you can store the data either in a column or in a file, and then store the file path in the column.\n\nFiles are generally rounded up to 4 KB increments. For very small files, where the rounding error is significant, it's more efficient to store them in the database as a . SQLite minimizes filesystem calls and is faster than the underlying filesystem in some cases.\n\nFollow these best practices to improve query performance in SQLite by minimizing response times and maximizing processing efficiency.\n\nRead only the rows you need\n\nFilters let you narrow down your results by specifying certain criteria, such as date range, location, or name. Limits let you control the number of results you see:\n\nRead only the columns you need\n\nAvoid selecting unneeded columns, which can slow down your queries and waste resources. Instead, only select columns that are used.\n\nIn the following example, you select , , and :\n\nHowever, you only need the column:\n\nParameterize queries with SQL Cards, not with String concatenation\n\nYour query string might include a parameter that is only known at runtime, such as the following:\n\nIn the preceding code, every query constructs a different string, and thus doesn't benefit from the statement cache. Each call requires SQLite to compile it before it can execute. Instead, you can replace the argument with a parameter and bind the value with :\n\nNow the query can be compiled once and cached. The compiled query is reused between different invocations of .\n\nIterate in SQL, not in code\n\nUse a single query that returns all targeted results, instead of a programmatic loop iterating on SQL queries to return individual results. The programmatic loop is about 1000 times slower than a single SQL query.\n\nUsing the keyword can improve the performance of your queries by reducing the amount of data that needs to be processed. For example, if you want to return only the unique values from a column, use :\n\nUse aggregate functions whenever possible\n\nUse aggregate functions for aggregate results without row data. For example, the following code checks whether there is at least one matching row:\n\nTo only fetch the first row, you can use to return if a matching row does not exist and if one or more rows match:\n\nUse SQLite aggregate functions in your app code:\n• : counts how many rows are in a column.\n• or : determines the lowest or highest value. Works for numeric columns, types, and text types.\n\nUse instead of\n\nIn the following example, the function reads all the rows from the database and returns all the row values:\n\nHowever, by using , the database returns only the count:\n\nSQL is composable and supports subqueries, joins, and foreign key constraints. You can use the result of one query in another query without going through app code. This reduces the need to copy data from SQLite and lets the database engine optimize your query.\n\nIn the following example, you can run a query to find which city has the most customers, then use the result in another query to find all the customers from that city:\n\nTo get the result in half the time of the previous example, use a single SQL query with nested statements:\n\nIf a row must not be inserted unless a particular column value is unique in the table, then it might be more efficient to enforce that uniqueness as a column constraint.\n\nIn the following example, one query is run to validate the row to be inserted and another to actually insert:\n\nInstead of checking the unique constraint in Kotlin or Java, you can check it in SQL when you define the table:\n\nSQLite does the same as the following:\n\nNow you can insert a row and let SQLite check the constraint:\n\nSQLite validates constraints faster and with less overhead than Kotlin or Java code. It is a best practice to use SQLite rather than app code.\n\nA transaction commits multiple operations, which improves not only efficiency but also correctness. To improve data consistency and accelerate performance, you can batch insertions:\n\nSQLite provides the following troubleshooting tools to help measure performance.\n\nRun SQLite on your machine to run queries and learn. Different Android platform versions use different revisions of SQLite. To use the same engine that's on an Android-powered device, use and run on your target device.\n\nYou can ask SQLite to time queries:\n\nYou can ask SQLite to explain how it intends to answer a query by using :\n\nThe previous example requires a full table scan without an index to find all customers from Paris. This is called linear complexity. SQLite needs to read all the rows and only keep the rows that match customers from Paris. To fix this, you can add an index:\n\nIf you're using the interactive shell, you can ask SQLite to always explain query plans:\n\nFor more information, see Query Planning.\n\nSQLite offers the command-line interface (CLI) to dump additional information that can be used to troubleshoot performance. To install, visit the SQLite Download Page.\n\nYou can use to download a database file from a target device to your workstation for analysis:\n\nYou can also install the GUI tool SQLite Browser on the SQLite Downloads page.\n\nAndroid times SQLite queries and logs them for you:\n\nWhen configuring Perfetto, you may add the following to include tracks for individual queries:"
    },
    {
        "link": "https://developer.android.com/training/data-storage/sqlite",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nSaving data to a database is ideal for repeating or structured data, such as contact information. This page assumes that you are familiar with SQL databases in general and helps you get started with SQLite databases on Android. The APIs you'll need to use a database on Android are available in the package.\n\nCaution: Although these APIs are powerful, they are fairly low-level and require a great deal of time and effort to use:\n• There is no compile-time verification of raw SQL queries. As your data graph changes, you need to update the affected SQL queries manually. This process can be time consuming and error prone.\n• You need to use lots of boilerplate code to convert between SQL queries and data objects. For these reasons, we highly recommended using the Room Persistence Library as an abstraction layer for accessing information in your app's SQLite databases.\n\nOne of the main principles of SQL databases is the schema: a formal declaration of how the database is organized. The schema is reflected in the SQL statements that you use to create your database. You may find it helpful to create a companion class, known as a contract class, which explicitly specifies the layout of your schema in a systematic and self-documenting way.\n\nA contract class is a container for constants that define names for URIs, tables, and columns. The contract class allows you to use the same constants across all the other classes in the same package. This lets you change a column name in one place and have it propagate throughout your code.\n\nA good way to organize a contract class is to put definitions that are global to your whole database in the root level of the class. Then create an inner class for each table. Each inner class enumerates the corresponding table's columns.\n\nNote: By implementing the interface, your inner class can inherit a primary key field called that some Android classes such as expect it to have. It's not required, but this can help your database work harmoniously with the Android framework.\n\nFor example, the following contract defines the table name and column names for a single table representing an RSS feed:\n\nOnce you have defined how your database looks, you should implement methods that create and maintain the database and tables. Here are some typical statements that create and delete a table:\n\nJust like files that you save on the device's internal storage, Android stores your database in your app's private folder. Your data is secure, because by default this area is not accessible to other apps or the user.\n\nThe class contains a useful set of APIs for managing your database. When you use this class to obtain references to your database, the system performs the potentially long-running operations of creating and updating the database only when needed and not during app startup. All you need to do is call or .\n\nNote: Because they can be long-running, be sure that you call or in a background thread. See Threading on Android for more information.\n\nTo use , create a subclass that overrides the and callback methods. You may also want to implement the or methods, but they are not required.\n\nFor example, here's an implementation of that uses some of the commands shown above:\n\nTo access your database, instantiate your subclass of :\n\nInsert data into the database by passing a object to the method:\n\nThe first argument for is simply the table name.\n\nThe second argument tells the framework what to do in the event that the is empty (i.e., you did not any values). If you specify the name of a column, the framework inserts a row and sets the value of that column to null. If you specify , like in this code sample, the framework does not insert a row when there are no values.\n\nThe methods returns the ID for the newly created row, or it will return -1 if there was an error inserting the data. This can happen if you have a conflict with pre-existing data in the database.\n\nTo read from a database, use the method, passing it your selection criteria and desired columns. The method combines elements of and , except the column list defines the data you want to fetch (the \"projection\"), rather than the data to insert. The results of the query are returned to you in a object.\n\nThe third and fourth arguments ( and ) are combined to create a WHERE clause. Because the arguments are provided separately from the selection query, they are escaped before being combined. This makes your selection statements immune to SQL injection. For more detail about all arguments, see the reference.\n\nTo look at a row in the cursor, use one of the move methods, which you must always call before you begin reading values. Since the cursor starts at position -1, calling places the \"read position\" on the first entry in the results and returns whether or not the cursor is already past the last entry in the result set. For each row, you can read a column's value by calling one of the get methods, such as or . For each of the get methods, you must pass the index position of the column you desire, which you can get by calling or . When finished iterating through results, call on the cursor to release its resources. For example, the following shows how to get all the item IDs stored in a cursor and add them to a list:\n\nTo delete rows from a table, you need to provide selection criteria that identify the rows to the method. The mechanism works the same as the selection arguments to the method. It divides the selection specification into a selection clause and selection arguments. The clause defines the columns to look at, and also allows you to combine column tests. The arguments are values to test against that are bound into the clause. Because the result isn't handled the same as a regular SQL statement, it is immune to SQL injection.\n\nThe return value for the method indicates the number of rows that were deleted from the database.\n\nWhen you need to modify a subset of your database values, use the method.\n\nUpdating the table combines the syntax of with the syntax of .\n\nThe return value of the method is the number of rows affected in the database.\n\nSince and are expensive to call when the database is closed, you should leave your database connection open for as long as you possibly need to access it. Typically, it is optimal to close the database in the of the calling Activity.\n\nThe Android SDK includes a shell tool that allows you to browse table contents, run SQL commands, and perform other useful functions on SQLite databases. For more information, see how to how to issue shell commands."
    },
    {
        "link": "https://medium.com/@shivani.patel18/a-comprehensive-guide-to-sqlite-databases-in-android-development-df74f01df6c3",
        "document": "In the world of Mobile app development, data persistence is a fundamental aspect. Whether you are building a to-do list app, a note-taking app, or a complex e-commerce platform, the need to store and manage data efficiently arises in almost every application. SQLite, a lightweight and efficient relational database, is the go-to choice for many Android developers due to its simplicity and robustness.\n\nSQLite is an open-source relational database i.e. used to perform database operations on android devices such as storing, manipulating or retrieving persistent data from the database. It is embedded in android by default. So, there is no need to perform any database setup or administration task.\n\nThis article helps to provide a comprehensive guide to working with SQLite databases in Android development. We will cover the following topics:\n• Why Use SQLite in Android?\n\nSQLite is a self-contained, serverless, and transactional SQL database engine. It is embedded into the Android operating system, making it an ideal choice for local data storage in Android applications. SQLite databases are lightweight, efficient, and easy to use, making them a popular choice for developers.\n\n2. Why Use SQLite in Android?\n\nThere are several reasons why SQLite is a preferred choice for data storage in Android applications:\n• Lightweight: SQLite is designed to be lightweight and has a small footprint, making it suitable for mobile devices with limited resources.\n• Reliability: It is ACID compliant (Atomicity, Consistency, Isolation, Durability), ensuring data integrity and reliability.\n• Speed: SQLite operations are fast, and it provides efficient indexing mechanisms for quick data retrieval.\n• Compatibility: SQLite is built into the Android OS, so you don’t need to include additional libraries in your app.\n• No Network Dependency: Unlike client-server databases, SQLite doesn’t require a network connection, making it ideal for offline applications.\n\nTo start using SQLite in your Android project, follow these steps:\n• Create a Database Helper Class: Create a subclass of to manage database creation, version management, and connection.\n\n2. Initialize the Database: Open or create the database in your app’s method.\n\nTo create a SQLite database, you need to define its structure using SQL statements. Use the method of your subclass to execute these statements. Here's a simple example:\n\nSQLiteOpenHelper class provides the functionality to use the SQLite database.\n\nSQLite supports all the standard CRUD (Create, Read, Update, Delete) operations. Here’s a brief overview:\n• Create: Use the statement to add new records to the database.\n• Read: Use the statement to retrieve data from the database.\n• Update: Use the statement to modify existing records.\n• Delete: Use the statement to remove records.\n\nThe class is used for database creation and version management. It helps you handle upgrades and downgrades of your database schema. For performing any database operation, you have to provide the implementation of onCreate() and onUpgrade() methods of SQLiteOpenHelper class.\n\nThere are two constructors of SQLiteOpenHelper class.\n\n→ SQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) :- creates an object for creating, opening and managing the database.\n\n→ SQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version, DatabaseErrorHandler errorHandler) :- creates an object for creating, opening and managing the database. It specifies the error handler.\n• public abstract void onCreate(SQLiteDatabase db) :- called only once when database is created for the first time.\n• public abstract void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) :- called when database needs to be upgraded.\n• public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) :- called when database needs to be downgraded.\n• Always use parameterized queries to prevent SQL injection.\n• Avoid opening and closing the database frequently; instead, use a singleton pattern for database access.\n• Handle database operations on a background thread to avoid blocking the UI thread.\n• Monitor and optimize database queries for performance using tools like Android Profiler.\n\nLet’s see the simple example of android sqlite database.\n\nNow, let’s create the database handler class that extends SQLiteOpenHelper class and provides the implementation of its methods.\n\npublic class DatabaseHandler extends SQLiteOpenHelper {\n\n private static final int DATABASE_VERSION = 1;\n\n private static final String DATABASE_NAME = \"studentlist\";\n\n private static final String TABLE_STUDENTS = \"students\";\n\n private static final String KEY_ID = \"id\";\n\n private static final String KEY_NAME = \"name\";\n\n\n\n public DatabaseHandler(Context context) {\n\n super(context, DATABASE_NAME, null, DATABASE_VERSION);\n\n //3rd argument to be passed is CursorFactory instance\n\n }\n\n\n\n // Creating Tables\n\n @Override\n\n public void onCreate(SQLiteDatabase db) {\n\n String CREATE_STUDENTS_TABLE = \"CREATE TABLE \" + TABLE_STUDENTS + \"(\"\n\n + KEY_ID + \" INTEGER PRIMARY KEY,\" \n\n + KEY_NAME + \" TEXT\"\n\n + \")\";\n\n db.execSQL(CREATE_STUDENTS_TABLE);\n\n }\n\n \n\n // Upgrading database\n\n @Override\n\n public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n // Drop older table if existed\n\n db.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_STUDENTS);\n\n\n\n // Create tables again\n\n onCreate(db);\n\n }\n\n\n\n // code to add the new student\n\n void addStudent(StudentList student) {\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n\n\n ContentValues values = new ContentValues();\n\n values.put(KEY_NAME, student.getName()); // studentName\n\n\n\n // Inserting Row\n\n db.insert(TABLE_STUDENTS, null, values);\n\n //2nd argument is String containing nullColumnHack\n\n db.close(); // Closing database connection\n\n }\n\n\n\n // code to get the single student\n\n StudentList getStudent(int id) {\n\n SQLiteDatabase db = this.getReadableDatabase();\n\n\n\n Cursor cursor = db.query(TABLE_STUDENTS, \n\n new String[] { KEY_ID, KEY_NAME}, KEY_ID + \"=?\",\n\n new String[] { String.valueOf(id) }, \n\n null, null, null, null);\n\n if (cursor != null)\n\n cursor.moveToFirst();\n\n\n\n StudentList studentList = new StudentList(Integer.parseInt(cursor.getString(0)),\n\n cursor.getString(1), \n\n cursor.getString(2));\n\n // return studentList\n\n return studentList;\n\n }\n\n\n\n\n\n // code to get all student in a list view\n\n public List<StudentList> getAllStudentList() {\n\n List<StudentList> studentList = new ArrayList<StudentList>();\n\n // Select All Query\n\n String selectQuery = \"SELECT * FROM \" + TABLE_STUDENTS;\n\n\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n Cursor cursor = db.rawQuery(selectQuery, null);\n\n\n\n // looping through all rows and adding to list\n\n if (cursor.moveToFirst()) {\n\n do {\n\n StudentList student = new StudentList();\n\n student.setID(Integer.parseInt(cursor.getString(0)));\n\n student.setName(cursor.getString(1));\n\n // Adding student to list\n\n studentList.add(student);\n\n } while (cursor.moveToNext());\n\n }\n\n\n\n // return student list\n\n return studentList;\n\n }\n\n\n\n // code to update the single student\n\n public int updateStudent(StudentList student) {\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n\n\n ContentValues values = new ContentValues();\n\n values.put(KEY_NAME, student.getName());\n\n\n\n // updating row\n\n return db.update(TABLE_STUDENTS, values, KEY_ID + \" = ?\",\n\n new String[] { String.valueOf(student.getID()) });\n\n }\n\n\n\n\n\n // Deleting single student\n\n public void deleteStudent(StudentList student) {\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n db.delete(TABLE_STUDENTS, KEY_ID + \" = ?\",\n\n new String[] { String.valueOf(student.getID()) });\n\n db.close();\n\n }\n\n\n\n\n\n // Getting student Count\n\n public int getStudentListCount() {\n\n String countQuery = \"SELECT * FROM \" + TABLE_STUDENTS;\n\n SQLiteDatabase db = this.getReadableDatabase();\n\n Cursor cursor = db.rawQuery(countQuery, null);\n\n cursor.close();\n\n\n\n // return count\n\n return cursor.getCount();\n\n }\n\n\n\n}\n\nIn the main activity of the app, call the function to initialize the DB\n\nSQLite is a powerful and reliable choice for managing local data storage in Android applications. Understanding how to create and manipulate SQLite databases is a valuable skill for any Android developer. By following the best practices outlined in this guide, you can ensure your Android apps perform efficiently and provide a seamless user experience.\n\nIncorporate SQLite into your Android projects, experiment with different database structures, and leverage the flexibility it offers to create data-driven applications that meet your users’ needs. Happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/1725880/best-practices-for-sqlite-db-and-contentprovider",
        "document": "My Android app is reading and writing to a local SQLite DB from a few different Activities and a Service. Pretty standard. But I'm not happy with the way I've got all the DB details stored as constants that I then use anywhere I access the DB. I've been advised to wrap the DB in a ContentProvider. Sounds good to me. While I'm refactoring my code, I figured I'd ask:\n• What are your best practices for local DB data storage in Android?\n• Where and how do you store \"CREATE TABLE\" statements, column names, other SQL?\n• Would you mind sharing a list of the classes you instantiate and what goes into each (ContentProvider, DatabaseProvider, DatabaseHelper...)?\n• How do you coordinate the structure of your local Android DB with a server-side DB available through a REST interface?\n\nYeah, I realize I'm getting at the perennial \"where's the Android object-relation-mapping framework?\" question. For now, I'm mainly curious to hear how you structure your Android apps with what's available in the standard SDK.\n\nAs always, thanks for the pointers!"
    },
    {
        "link": "https://stackoverflow.com/questions/8810119/best-practices-for-creating-a-sqlite-database-on-android",
        "document": "I have read through a lot of the posts on copying the database file over from the assets or raw folders to the folder, but that would leave two copies of the DB on the device taking up valuable space. I am thinking of building a solution with a slightly smaller footprint and allowing for more flexible schema management by storing the database SQL creation text file in the raw folder and using the standard process in the DBhelper class. However I am a little confused because the examples that copy the database over bypass the methods.\n\nIs this the recommended way if you are not building the db from strings in the code?\n\nMy solution would simulate the running scripts from code method by having the scripts all in one file. The reason I am looking at building the db this way is that my DB will have close to 100 tables when the application is complete, so I need the schema to be manageable.\n\nAny guidance is welcome as I am still learning the best practices and patterns for Android.\n\nHere is an example of my code:"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/android-sqlite-database-example-tutorial",
        "document": "Welcome to Android SQLite Example Tutorial. Android SQLite is the mostly preferred way to store data for android applications. For many applications, SQLite is the apps backbone whether it’s used directly or via some third-party wrapper. Below is the final app we will create today using Android SQLite database.\n\nAndroid SQLite is a very lightweight database which comes with Android OS. Android SQLite combines a clean SQL interface with a very small memory footprint and decent speed. For Android, SQLite is “baked into” the Android runtime, so every Android application can create its own SQLite databases. Android SQLite native API is not JDBC, as JDBC might be too much overhead for a memory-limited smartphone. Once a database is created successfully its located in data/data//databases/ accessible from Android Device Monitor. SQLite is a typical relational database, containing tables (which consists of rows and columns), indexes etc. We can create our own tables to hold the data accordingly. This structure is referred to as a schema.\n\nAndroid has features available to handle changing database schemas, which mostly depend on using the class. SQLiteOpenHelper is designed to get rid of two very common problems.\n• When the application runs the first time - At this point, we do not yet have a database. So we will have to create the tables, indexes, starter data, and so on.\n• When the application is upgraded to a newer schema - Our database will still be on the old schema from the older edition of the app. We will have option to alter the database schema to match the needs of the rest of the app.\n\nwraps up these logic to create and upgrade a database as per our specifications. For that we’ll need to create a custom subclass of implementing at least the following three methods.\n• Constructor : This takes the Context (e.g., an Activity), the name of the database, an optional cursor factory (we’ll discuss this later), and an integer representing the version of the database schema you are using (typically starting from 1 and increment later).\n• onCreate(SQLiteDatabase db) : It’s called when there is no database and the app needs one. It passes us a object, pointing to a newly-created database, that we can populate with tables and initial data.\n• onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) : It’s called when the schema version we need does not match the schema version of the database, It passes us a SQLiteDatabase object and the old and new version numbers. Hence we can figure out the best way to convert the database from the old schema to the new one.\n\nWe define a class to perform all database CRUD(Create, Read, Update and Delete) operations.\n\nBefore performing any database operations like insert, update, delete records in a table, first open the database connection by calling getWritableDatabase() method as shown below:\n\nThe dbHelper is an instance of the subclass of . To close a database connection the following method is invoked.\n\nThe following code snippet shows how to insert a new record in the android SQLite database.\n\nContent Values creates an empty set of values using the given initial size. We’ll discuss the other instance values when we jump into the coding part.\n\nThe following snippet shows how to update a single record.\n\nWe just need to pass the id of the record to be deleted as shown below.\n\nA Cursor represents the entire result set of the query. Once the query is fetched a call to cursor.moveToFirst() is made. Calling moveToFirst() does two things:\n• It allows us to test whether the query returned an empty set (by testing the return value)\n• It moves the cursor to the first result (when the set is not empty)\n\nThe following code is used to fetch all records:\n\nAnother way to use a Cursor is to wrap it in a . Just as adapts arrays, adapts Cursor objects, making their data available to an like a . Let’s jump to our project that uses SQLite to store some meaningful data.\n\nIn this application we wish to create records that store Country names and their respective currencies in the form of a ListView. We cover all the features discusses above.\n\nThe application consists of 5 classes. We begin with defining with DatabaseHelper, which is a subclass of SQLiteOpenHelper as follows:\n\nAs discussed above we have overridden the and methods besides the constructor. We’ve assigned the names to the database and the table as JOURNALDEV_COUNTRIES.DB and COUNTRIES respectively. The index column is auto incremented whenever a new row is inserted. The column names for country and currency are “subject” and “description”. The DBManager classes is where the DatabaseHelper is initialized and the CRUD Operations are defined. Below is the code for this class:\n\nThe class is the activity which is launched when the application starts. Below is layout defined for it:\n\nHere a ListView component is defined to included the records stored in the database. Initially the ListView would be empty hence a TextView is used to display the same.\n\nIn this activity the DBManager object is invoked to perform the CRUD Operations. A SimpleCursorAdapter is defined to add elements to the list from the query results that are returned in an Cursor Object. On list item click an intent is performed to open the ModifyCountryActivity class. The menu contains an item to add a new record from the ActionBar. Here again an intent is performed to open the AddCountryActivity class. Below is code.\n\nThe xml layout and code of file are defined below:\n\nTwo EditText components that take the inputs for country and currency along with a button to add the values to the database and display it in the ListView are defined.\n\nThe CRUD operation performed here is adding a new record to the database. The xml layout and code of ModifyCountryActivity.java file are defined below:\n\nIt’s similar to the previous layout except that modify and delete buttons are added.\n\nThe CRUD operations performed here are updating and deleting a record. The below images are the screenshots of the final output of our project. The first image is the output seen when the application is launched for the first time. The second image is the result of clicking the menu option from the ActionBar to add a new record as shown below. The third image shows an output when 3 records are added : The fourth image shows the output when any list item is clicked to modify or delete a record : The final image is the output when a record is deleted. In this example we delete the first record :\n\nAs we’ve discussed earlier in this tutorial, the database file is stored in the internal storage that is accessible from the Android Device Monitor as visible in the pic below. To view this database we need to pull this file from the device to our desktop. This is done by clicking the menu option in the top right as seen in the image below : To open this file download the SQLiteBrowser from this link. The snippets below show the schema and tables in the browser. To view the table go to the Browse Data tab on top. The following image is seen: This brings an end to Android SQLite tutorial. The final Android SQLite Project is downloadable from the below link."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-create-and-add-data-to-sqlite-database-in-android",
        "document": "How to Create and Add Data to SQLite Database in Android?\n\nSQLite is another data storage available in Android where we can store data in the user’s device and can use it any time when required. In this article, we will take a look at creating an SQLite database in the Android app and adding data to that database in the Android app. This is a series of 4 articles in which we are going to perform the basic CRUD (Create, Read, Update, and Delete) operation with SQLite Database in Android. We are going to cover the following 4 articles in this series:\n• None How to Create and Add Data to SQLite Database in Android?\n• None How to Read Data from SQLite Database in Android?\n• None How to Update Data to SQLite Database in Android?\n• None How to Delete Data in SQLite Database in Android?\n\nAndroid SQLite Database is an open-source database provided in Android that is used to store data inside the user’s device in the form of a Text file. We can perform many operations on this data such as adding new data, updating, reading, and deleting this data. SQLite is an offline database that is locally stored in the user’s device and we do not have to create any connection to connect to this database.\n\nHow Data is Being Stored in the SQLite Database?\n\nData is stored in the Android SQLite database in the form of tables. When we store this data in our SQLite database it is arranged in the form of tables that are similar to that of an Excel sheet. Below is the representation of our SQLite database which we are storing in our SQLite database.\n\nBelow are the several important methods that we will be using in this SQLite database integration in Android.\n\nThis method is used to get the Array of column names of our SQLite table. This method will return the number of rows in the cursor. This method returns a Boolean value when our cursor is closed. This method returns the total number of columns present in our table. This method will return the name of the column when we passed the index of our column in it. This method will return the index of our column from the name of the column. This method will return the current position of our cursor in our table.\n\nWhat we are going to build in this article?\n\nWe will be building a simple application in which we will be adding data to the Android SQLite database. We will be creating a database for adding course name, course description, course duration, and course tracks. We will be saving all this data in our Android SQLite database. A sample video is given below to get an idea about what we are going to do in this article. Note that we are going to implement this project using the Java language.\n\nTo create a new project in Android Studio please refer to How to Create/Start a New Project in Android Studio. Note that select Java as the programming language.\n\nStep 2: Adding permissions to access the storage in the AndroidManifest.xml file\n\nNavigate to the app > AndroidManifest.xml and add the below code to it.\n\nNavigate to the app > res > layout > activity_main.xml and add the below code to that file.\n\nBelow is the code for the activity_main.xml file.\n\nNavigate to the app > java > your app’s package name > Right-click on it > New > Java class and name it as DBHandler and add the below code to it. Comments are added inside the code to understand the code in more detail.\n\n// below variable is for our database name. // below int is our database version // below variable is for our table name. // below variable is for our id column. // below variable is for our course name column // below variable id for our course duration column. // below variable for our course description column. // below variable is for our course tracks column. // below method is for creating a database by running a sqlite query // on below line we are creating // an sqlite query and we are // along with their data types. // at last we are calling a exec sql // this method is use to add new course to our sqlite database. // on below line we are creating a variable for // as we are writing data in our database. // on below line we are creating a // on below line we are passing all values // along with its key and value pair. // after adding all values we are passing // at last we are closing our // this method is called to check if the table exists already.\n\nGo to the MainActivity.java file and refer to the following code. Below is the code for the MainActivity.java file. Comments are added inside the code to understand the code in more detail.\n\nNow run your app and see the output of the app.\n\nAfter successfully executed the code enter the required data inside the EditText. Most importantly if you want to know How to View and Locate SQLite Database in Android Studio then please refer to this article.\n\nAnd you can see below this is how the data stored in the SQLite database.\n\nBelow is the complete project file structure after performing the create and add operation:"
    },
    {
        "link": "https://developer.android.com/training/data-storage/sqlite",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nSaving data to a database is ideal for repeating or structured data, such as contact information. This page assumes that you are familiar with SQL databases in general and helps you get started with SQLite databases on Android. The APIs you'll need to use a database on Android are available in the package.\n\nCaution: Although these APIs are powerful, they are fairly low-level and require a great deal of time and effort to use:\n• There is no compile-time verification of raw SQL queries. As your data graph changes, you need to update the affected SQL queries manually. This process can be time consuming and error prone.\n• You need to use lots of boilerplate code to convert between SQL queries and data objects. For these reasons, we highly recommended using the Room Persistence Library as an abstraction layer for accessing information in your app's SQLite databases.\n\nOne of the main principles of SQL databases is the schema: a formal declaration of how the database is organized. The schema is reflected in the SQL statements that you use to create your database. You may find it helpful to create a companion class, known as a contract class, which explicitly specifies the layout of your schema in a systematic and self-documenting way.\n\nA contract class is a container for constants that define names for URIs, tables, and columns. The contract class allows you to use the same constants across all the other classes in the same package. This lets you change a column name in one place and have it propagate throughout your code.\n\nA good way to organize a contract class is to put definitions that are global to your whole database in the root level of the class. Then create an inner class for each table. Each inner class enumerates the corresponding table's columns.\n\nNote: By implementing the interface, your inner class can inherit a primary key field called that some Android classes such as expect it to have. It's not required, but this can help your database work harmoniously with the Android framework.\n\nFor example, the following contract defines the table name and column names for a single table representing an RSS feed:\n\nOnce you have defined how your database looks, you should implement methods that create and maintain the database and tables. Here are some typical statements that create and delete a table:\n\nJust like files that you save on the device's internal storage, Android stores your database in your app's private folder. Your data is secure, because by default this area is not accessible to other apps or the user.\n\nThe class contains a useful set of APIs for managing your database. When you use this class to obtain references to your database, the system performs the potentially long-running operations of creating and updating the database only when needed and not during app startup. All you need to do is call or .\n\nNote: Because they can be long-running, be sure that you call or in a background thread. See Threading on Android for more information.\n\nTo use , create a subclass that overrides the and callback methods. You may also want to implement the or methods, but they are not required.\n\nFor example, here's an implementation of that uses some of the commands shown above:\n\nTo access your database, instantiate your subclass of :\n\nInsert data into the database by passing a object to the method:\n\nThe first argument for is simply the table name.\n\nThe second argument tells the framework what to do in the event that the is empty (i.e., you did not any values). If you specify the name of a column, the framework inserts a row and sets the value of that column to null. If you specify , like in this code sample, the framework does not insert a row when there are no values.\n\nThe methods returns the ID for the newly created row, or it will return -1 if there was an error inserting the data. This can happen if you have a conflict with pre-existing data in the database.\n\nTo read from a database, use the method, passing it your selection criteria and desired columns. The method combines elements of and , except the column list defines the data you want to fetch (the \"projection\"), rather than the data to insert. The results of the query are returned to you in a object.\n\nThe third and fourth arguments ( and ) are combined to create a WHERE clause. Because the arguments are provided separately from the selection query, they are escaped before being combined. This makes your selection statements immune to SQL injection. For more detail about all arguments, see the reference.\n\nTo look at a row in the cursor, use one of the move methods, which you must always call before you begin reading values. Since the cursor starts at position -1, calling places the \"read position\" on the first entry in the results and returns whether or not the cursor is already past the last entry in the result set. For each row, you can read a column's value by calling one of the get methods, such as or . For each of the get methods, you must pass the index position of the column you desire, which you can get by calling or . When finished iterating through results, call on the cursor to release its resources. For example, the following shows how to get all the item IDs stored in a cursor and add them to a list:\n\nTo delete rows from a table, you need to provide selection criteria that identify the rows to the method. The mechanism works the same as the selection arguments to the method. It divides the selection specification into a selection clause and selection arguments. The clause defines the columns to look at, and also allows you to combine column tests. The arguments are values to test against that are bound into the clause. Because the result isn't handled the same as a regular SQL statement, it is immune to SQL injection.\n\nThe return value for the method indicates the number of rows that were deleted from the database.\n\nWhen you need to modify a subset of your database values, use the method.\n\nUpdating the table combines the syntax of with the syntax of .\n\nThe return value of the method is the number of rows affected in the database.\n\nSince and are expensive to call when the database is closed, you should leave your database connection open for as long as you possibly need to access it. Typically, it is optimal to close the database in the of the calling Activity.\n\nThe Android SDK includes a shell tool that allows you to browse table contents, run SQL commands, and perform other useful functions on SQLite databases. For more information, see how to how to issue shell commands."
    },
    {
        "link": "https://medium.com/@shivani.patel18/a-comprehensive-guide-to-sqlite-databases-in-android-development-df74f01df6c3",
        "document": "In the world of Mobile app development, data persistence is a fundamental aspect. Whether you are building a to-do list app, a note-taking app, or a complex e-commerce platform, the need to store and manage data efficiently arises in almost every application. SQLite, a lightweight and efficient relational database, is the go-to choice for many Android developers due to its simplicity and robustness.\n\nSQLite is an open-source relational database i.e. used to perform database operations on android devices such as storing, manipulating or retrieving persistent data from the database. It is embedded in android by default. So, there is no need to perform any database setup or administration task.\n\nThis article helps to provide a comprehensive guide to working with SQLite databases in Android development. We will cover the following topics:\n• Why Use SQLite in Android?\n\nSQLite is a self-contained, serverless, and transactional SQL database engine. It is embedded into the Android operating system, making it an ideal choice for local data storage in Android applications. SQLite databases are lightweight, efficient, and easy to use, making them a popular choice for developers.\n\n2. Why Use SQLite in Android?\n\nThere are several reasons why SQLite is a preferred choice for data storage in Android applications:\n• Lightweight: SQLite is designed to be lightweight and has a small footprint, making it suitable for mobile devices with limited resources.\n• Reliability: It is ACID compliant (Atomicity, Consistency, Isolation, Durability), ensuring data integrity and reliability.\n• Speed: SQLite operations are fast, and it provides efficient indexing mechanisms for quick data retrieval.\n• Compatibility: SQLite is built into the Android OS, so you don’t need to include additional libraries in your app.\n• No Network Dependency: Unlike client-server databases, SQLite doesn’t require a network connection, making it ideal for offline applications.\n\nTo start using SQLite in your Android project, follow these steps:\n• Create a Database Helper Class: Create a subclass of to manage database creation, version management, and connection.\n\n2. Initialize the Database: Open or create the database in your app’s method.\n\nTo create a SQLite database, you need to define its structure using SQL statements. Use the method of your subclass to execute these statements. Here's a simple example:\n\nSQLiteOpenHelper class provides the functionality to use the SQLite database.\n\nSQLite supports all the standard CRUD (Create, Read, Update, Delete) operations. Here’s a brief overview:\n• Create: Use the statement to add new records to the database.\n• Read: Use the statement to retrieve data from the database.\n• Update: Use the statement to modify existing records.\n• Delete: Use the statement to remove records.\n\nThe class is used for database creation and version management. It helps you handle upgrades and downgrades of your database schema. For performing any database operation, you have to provide the implementation of onCreate() and onUpgrade() methods of SQLiteOpenHelper class.\n\nThere are two constructors of SQLiteOpenHelper class.\n\n→ SQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) :- creates an object for creating, opening and managing the database.\n\n→ SQLiteOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version, DatabaseErrorHandler errorHandler) :- creates an object for creating, opening and managing the database. It specifies the error handler.\n• public abstract void onCreate(SQLiteDatabase db) :- called only once when database is created for the first time.\n• public abstract void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) :- called when database needs to be upgraded.\n• public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) :- called when database needs to be downgraded.\n• Always use parameterized queries to prevent SQL injection.\n• Avoid opening and closing the database frequently; instead, use a singleton pattern for database access.\n• Handle database operations on a background thread to avoid blocking the UI thread.\n• Monitor and optimize database queries for performance using tools like Android Profiler.\n\nLet’s see the simple example of android sqlite database.\n\nNow, let’s create the database handler class that extends SQLiteOpenHelper class and provides the implementation of its methods.\n\npublic class DatabaseHandler extends SQLiteOpenHelper {\n\n private static final int DATABASE_VERSION = 1;\n\n private static final String DATABASE_NAME = \"studentlist\";\n\n private static final String TABLE_STUDENTS = \"students\";\n\n private static final String KEY_ID = \"id\";\n\n private static final String KEY_NAME = \"name\";\n\n\n\n public DatabaseHandler(Context context) {\n\n super(context, DATABASE_NAME, null, DATABASE_VERSION);\n\n //3rd argument to be passed is CursorFactory instance\n\n }\n\n\n\n // Creating Tables\n\n @Override\n\n public void onCreate(SQLiteDatabase db) {\n\n String CREATE_STUDENTS_TABLE = \"CREATE TABLE \" + TABLE_STUDENTS + \"(\"\n\n + KEY_ID + \" INTEGER PRIMARY KEY,\" \n\n + KEY_NAME + \" TEXT\"\n\n + \")\";\n\n db.execSQL(CREATE_STUDENTS_TABLE);\n\n }\n\n \n\n // Upgrading database\n\n @Override\n\n public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n // Drop older table if existed\n\n db.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_STUDENTS);\n\n\n\n // Create tables again\n\n onCreate(db);\n\n }\n\n\n\n // code to add the new student\n\n void addStudent(StudentList student) {\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n\n\n ContentValues values = new ContentValues();\n\n values.put(KEY_NAME, student.getName()); // studentName\n\n\n\n // Inserting Row\n\n db.insert(TABLE_STUDENTS, null, values);\n\n //2nd argument is String containing nullColumnHack\n\n db.close(); // Closing database connection\n\n }\n\n\n\n // code to get the single student\n\n StudentList getStudent(int id) {\n\n SQLiteDatabase db = this.getReadableDatabase();\n\n\n\n Cursor cursor = db.query(TABLE_STUDENTS, \n\n new String[] { KEY_ID, KEY_NAME}, KEY_ID + \"=?\",\n\n new String[] { String.valueOf(id) }, \n\n null, null, null, null);\n\n if (cursor != null)\n\n cursor.moveToFirst();\n\n\n\n StudentList studentList = new StudentList(Integer.parseInt(cursor.getString(0)),\n\n cursor.getString(1), \n\n cursor.getString(2));\n\n // return studentList\n\n return studentList;\n\n }\n\n\n\n\n\n // code to get all student in a list view\n\n public List<StudentList> getAllStudentList() {\n\n List<StudentList> studentList = new ArrayList<StudentList>();\n\n // Select All Query\n\n String selectQuery = \"SELECT * FROM \" + TABLE_STUDENTS;\n\n\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n Cursor cursor = db.rawQuery(selectQuery, null);\n\n\n\n // looping through all rows and adding to list\n\n if (cursor.moveToFirst()) {\n\n do {\n\n StudentList student = new StudentList();\n\n student.setID(Integer.parseInt(cursor.getString(0)));\n\n student.setName(cursor.getString(1));\n\n // Adding student to list\n\n studentList.add(student);\n\n } while (cursor.moveToNext());\n\n }\n\n\n\n // return student list\n\n return studentList;\n\n }\n\n\n\n // code to update the single student\n\n public int updateStudent(StudentList student) {\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n\n\n ContentValues values = new ContentValues();\n\n values.put(KEY_NAME, student.getName());\n\n\n\n // updating row\n\n return db.update(TABLE_STUDENTS, values, KEY_ID + \" = ?\",\n\n new String[] { String.valueOf(student.getID()) });\n\n }\n\n\n\n\n\n // Deleting single student\n\n public void deleteStudent(StudentList student) {\n\n SQLiteDatabase db = this.getWritableDatabase();\n\n db.delete(TABLE_STUDENTS, KEY_ID + \" = ?\",\n\n new String[] { String.valueOf(student.getID()) });\n\n db.close();\n\n }\n\n\n\n\n\n // Getting student Count\n\n public int getStudentListCount() {\n\n String countQuery = \"SELECT * FROM \" + TABLE_STUDENTS;\n\n SQLiteDatabase db = this.getReadableDatabase();\n\n Cursor cursor = db.rawQuery(countQuery, null);\n\n cursor.close();\n\n\n\n // return count\n\n return cursor.getCount();\n\n }\n\n\n\n}\n\nIn the main activity of the app, call the function to initialize the DB\n\nSQLite is a powerful and reliable choice for managing local data storage in Android applications. Understanding how to create and manipulate SQLite databases is a valuable skill for any Android developer. By following the best practices outlined in this guide, you can ensure your Android apps perform efficiently and provide a seamless user experience.\n\nIncorporate SQLite into your Android projects, experiment with different database structures, and leverage the flexibility it offers to create data-driven applications that meet your users’ needs. Happy coding!"
    },
    {
        "link": "https://abhiandroid.com/database/sqlite",
        "document": "SQLite Tutorial With Example In Android Studio\n\nSQLite is a Structure query base database, open source, light weight, no network access and standalone database. It support embedded relational database features.\n\nWhenever an application needs to store large amount of data then using sqlite is more preferable than other repository system like SharedPreferences or saving data in files.\n\nAndroid has built in SQLite database implementation. It is available locally over the device(mobile & tablet) and contain data in text format. It carry light weight data and suitable with many languages. So, it doesn’t required any administration or setup procedure of the database.\n\nThe database created is saved in a directory: data/data/APP_Name/databases/DATABASE_NAME.\n\nFor creating, updating and other operations you need to create a subclass or class. SQLiteOpenHelper is a helper class to manage database creation and version management. It provides two methods onCreate(SQLiteDatabase db), onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion).\n\nThe SQLiteOpenHelper is responsible for opening database if exist, creating database if it does not exists and upgrading if required. The SQLiteOpenHelper only require the DATABASE_NAME to create database. After extending SQLiteOpenHelper you will need to implement its methods onCreate, onUpgrade and constructor.\n\nmethod is called only once throughout the application lifecycle. It will be called whenever there is a first call to getReadableDatabase() or getWritableDatabase() function available in super SQLiteOpenHelper class. So SQLiteOpenHelper class call the onCreate() method after creating database and instantiate SQLiteDatabase object. Database name is passed in constructor call.\n\nis only called whenever there is a updation in existing version. So to update a version we have to increment the value of version variable passed in the superclass constructor.\n\nIn onUpgrade method we can write queries to perform whatever action is required. In most example you will see that existing table(s) are being dropped and again onCreate() method is being called to create tables again. But it’s not mandatory to do so and it all depends upon your requirements.\n\nWe have to change database version if we have added a new row in the database table. If we have requirement that we don’t want to lose existing data in the table then we can write alter table query in the onUpgrade(SQLiteDatabase db,int oldVersion, int newVersion) method.\n\nFor more details read: Insert, Read, Delete & Update Operation In SQLite\n\nGet Better Understanding of Sqlite Before You Read Example – To get better understanding of SQlite database, it is recommended you read below article first:\n• List Of All Operators In SQLite\n• List Of All Clauses In SQLite For Defining Specific Condition\n\nIn this example we simply want to illustrate the insert, update, delete and more operations of SQLite over a table in Android Studi. We created a activity having textview, button and edittext over it. Another class which extends SQLiteOpenHelper where the create and insert operations will be carried out. The example contain proper validation like you need to enter data before executing any operation.\n\nBelow you can download code, see final output and step by step explanation:\n\nCreate a New Project and Name it SQLiteOperations.\n\nIn this step we create a layout in our XML file adding textbox, buttons, edittext. On button onclick is defined which associate it with related function.\n\nNow open and add the below code.\n\nIn this step we used the functions that linked via the button click. These functions are defined in other class and are used here. Each function return value that define no of rows updated, using that we defined whether operation is successful or not. Also user need to define valid data to perform operation empty fields will not be entertained and return error .\n\nIn this we define the functions that are used to perform the operations insert, update and delete operations in SQLite. Further this class create another class that will extend the SQLiteOpenHelper. Each function carry equivalent methods that perform operations.\n\nAccording to naming convention it is suggested to define primary key starting with underscore example: _id.\n\nIn this step create another java class Message.class\n\nIn this just simply add toast for displaying message. This is optional, it is just added to again and again defining toast in the example.\n\n\n\n Now run the app and view the functionality added over the buttons.\n\n\n\nTo understand how to add or retrieve image from phone external storage to application using SQLite Database. Please read our step by step add & retrieve image from SQLite tutorial."
    }
]