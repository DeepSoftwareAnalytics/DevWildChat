[
    {
        "link": "https://github.com/anmolchandelCO180309/tic-tac-toe-using-alpha-beta-pruning",
        "document": "Alpha-beta pruning is a modified version of the minimax algorithm. It is an optimization technique for the minimax algorithm. As we have seen in the minimax search algorithm that the number of game states it has to examine are exponential in depth of the tree. Since we cannot eliminate the exponent, but we can cut it to half. Hence there is a technique by which without checking each node of the game tree we can compute the correct minimax decision, and this technique is called pruning. This involves two threshold parameter Alpha and beta for future expansion, so it is called alpha-beta pruning. It is also called as Alpha-Beta Algorithm. Alpha-beta pruning can be applied at any depth of a tree, and sometimes it not only prunes the tree leaves but also entire sub-tree. The two-parameter can be defined as:\n‚Ä¢ Alpha: The best (highest-value) choice we have found so far at any point along the path of Maximizer. The initial value of alpha is -‚àû.\n‚Ä¢ Beta: The best (lowest-value) choice we have found so far at any point along the path of Minimizer. The initial value of beta is +‚àû. The Alpha-beta pruning to a standard minimax algorithm returns the same move as the standard algorithm does, but it removes all the nodes which are not really affecting the final decision but making algorithm slow. Hence by pruning these nodes, it makes the algorithm fast.\n‚Ä¢ First, generate the entire game tree starting with the current position of the game all the way up to the terminal states.\n‚Ä¢ Apply the utility function to get the utility values for all the terminal states.\n‚Ä¢ Determine the utilities of the higher nodes with the help of the utilities of the terminal nodes. For instance, in the diagram below, we have the utilities for the terminal states written in the squares.\n‚Ä¢ Calculate the utility values with the help of leaves considering one layer at a time until the root of the tree.\n‚Ä¢ Eventually, all the backed-up values reach to the root of the tree, i.e., the topmost point. At that point, MAX has to choose the highest value."
    },
    {
        "link": "https://medium.com/@amadi8/tic-tac-toe-agent-using-alpha-beta-pruning-18e8691b61d4",
        "document": "This report discusses the implementation of the Alpha-Beta pruning with the Minimax algorithm in Python for the game Tic-Tac-Toe. It focuses on creating a computer player that uses Alpha-Beta pruning to make optimal moves in the game. Alpha-Beta pruning is a search algorithm commonly used in game theory to improve decision-making efficiency by reducing the number of evaluated nodes in the game tree, especially in games with large search spaces.\n‚Ä¢ Improve the decision-making efficiency of the computer player by reducing the number of evaluated nodes in the game tree.\n‚Ä¢ Tic-Tac-Toe game implementation incorporating the Alpha-Beta pruning and the Minimax algorithm with Python Code.\n\nThe project involves developing a Tic-Tac-Toe game implementation incorporating the Alpha-Beta pruning with the Minimax algorithm. Using this algorithm, the computer player analyzes the game state, evaluates possible moves, and selects the optimal action based on the anticipated outcomes.\n\nrecursively evaluates all possible moves and their potential outcomes, creating a game tree.\n\nAlpha‚ÄìBeta (ùõº‚àíùõΩ) algorithm is actually an improved minimax using a heuristic. It stops evaluating a move when it makes sure that it‚Äôs worse than a previously examined move. Such moves need not to be evaluated further.\n\nWhen added to a simple minimax algorithm, it gives the same output but cuts off certain branches that can‚Äôt possibly affect the final decision ‚Äî dramatically improving the performance\n\nIn the code below (there‚Äôs a link for it), we will be using Alpha-Beta pruning which reduces the number of unnecessary evaluations by eliminating suboptimal branches in the game tree.\n\nThe result of this game will be :\n‚Ä¢ -1 if the player ‚ÄúPlayer_O‚Äù that seeks minimum wins.\n‚Ä¢ 1 if the player ‚ÄúPlayer_X‚Äù that seeks maximum wins.\n\nClick here to access the code.\n\nBy incorporating Alpha-Beta pruning with the Minimax algorithm, this project successfully created an AI opponent capable of making optimal moves in the game, resulting in a more challenging and enjoyable gaming experience for players.\n\nAnd as you maybe noticed, winning against this kind of AI is impossible. If we assume that both player and AI are playing optimally, the game will always be a tie. Since the AI agent always plays optimally, if we slip up, we‚Äôll lose."
    },
    {
        "link": "https://stackoverflow.com/questions/65653940/tictactoe-alpha-beta-pruning",
        "document": "EDIT 30/03/2021: Question was really poorly-worded, reformulating it\n\nI implemented an Alpha-Beta Prunning algorithm in Python and I was wondering if it is normal for it not to go for the fastest victory route (sometimes it will go for a victory in 2 moves while it could have won in 1).\n\nMy conclusion on the question:\n\nAlpha-Beta Pruning is a depth-first search algorithm, not a breadth-first search algorithm, so I think it is natural for it to pick the first route it finds no matter its depth, and not search for the quickest one..."
    },
    {
        "link": "https://geeksforgeeks.org/minimax-algorithm-in-game-theory-set-4-alpha-beta-pruning",
        "document": "Prerequisites: Minimax Algorithm in Game Theory, Evaluation Function in Game Theory\n\nAlpha-Beta pruning is not actually a new algorithm, but rather an optimization technique for the minimax algorithm. It reduces the computation time by a huge factor. This allows us to search much faster and even go into deeper levels in the game tree. It cuts off branches in the game tree which need not be searched because there already exists a better move available. It is called Alpha-Beta pruning because it passes 2 extra parameters in the minimax function, namely alpha and beta.\n\nAlpha is the best value that the maximizer currently can guarantee at that level or above. \n\nBeta is the best value that the minimizer currently can guarantee at that level or below.\n\nLet‚Äôs make the above algorithm clear with an example.\n‚Ä¢ The initial call starts from A. The value of alpha here is -INFINITY and the value of beta is +INFINITY. These values are passed down to subsequent nodes in the tree. At A the maximizer must choose max of B and C, so A calls B first\n‚Ä¢ At B it the minimizer must choose min of D and E and hence calls D first.\n‚Ä¢ At D, it looks at its left child which is a leaf node. This node returns a value of 3. Now the value of alpha at D is max( -INF, 3) which is 3.\n‚Ä¢ To decide whether its worth looking at its right node or not, it checks the condition beta<=alpha. This is false since beta = +INF and alpha = 3. So it continues the search.\n‚Ä¢ D now looks at its right child which returns a value of 5.At D, alpha = max(3, 5) which is 5. Now the value of node D is 5\n‚Ä¢ D returns a value of 5 to B. At B, beta = min( +INF, 5) which is 5. The minimizer is now guaranteed a value of 5 or lesser. B now calls E to see if he can get a lower value than 5.\n‚Ä¢ At E the values of alpha and beta is not -INF and +INF but instead -INF and 5 respectively, because the value of beta was changed at B and that is what B passed down to E\n‚Ä¢ Now E looks at its left child which is 6. At E, alpha = max(-INF, 6) which is 6. Here the condition becomes true. beta is 5 and alpha is 6. So beta<=alpha is true. Hence it breaks and E returns 6 to B\n‚Ä¢ Note how it did not matter what the value of E‚Äòs right child is. It could have been +INF or -INF, it still wouldn‚Äôt matter, We never even had to look at it because the minimizer was guaranteed a value of 5 or lesser. So as soon as the maximizer saw the 6 he knew the minimizer would never come this way because he can get a 5 on the left side of B. This way we didn‚Äôt have to look at that 9 and hence saved computation time.\n‚Ä¢ E returns a value of 6 to B. At B, beta = min( 5, 6) which is 5.The value of node B is also 5\n\nSo far this is how our game tree looks. The 9 is crossed out because it was never computed.\n‚Ä¢ B returns 5 to A. At A, alpha = max( -INF, 5) which is 5. Now the maximizer is guaranteed a value of 5 or greater. A now calls C to see if it can get a higher value than 5.\n‚Ä¢ At C, alpha = 5 and beta = +INF. C calls F\n‚Ä¢ At F, alpha = 5 and beta = +INF. F looks at its left child which is a 1. alpha = max( 5, 1) which is still 5.\n‚Ä¢ F looks at its right child which is a 2. Hence the best value of this node is 2. Alpha still remains 5\n‚Ä¢ F returns a value of 2 to C. At C, beta = min( +INF, 2). The condition beta <= alpha becomes true as beta = 2 and alpha = 5. So it breaks and it does not even have to compute the entire sub-tree of G.\n‚Ä¢ The intuition behind this break-off is that, at C the minimizer was guaranteed a value of 2 or lesser. But the maximizer was already guaranteed a value of 5 if he choose B. So why would the maximizer ever choose C and get a value less than 2 ? Again you can see that it did not matter what those last 2 values were. We also saved a lot of computation by skipping a whole sub-tree.\n‚Ä¢ C now returns a value of 2 to A. Therefore the best value at A is max( 5, 2) which is a 5.\n‚Ä¢ Hence the optimal value that the maximizer can get is 5\n\nThis is how our final game tree looks like. As you can see G has been crossed out as it was never computed."
    },
    {
        "link": "https://levelup.gitconnected.com/mastering-tic-tac-toe-with-minimax-algorithm-3394d65fa88f",
        "document": "I‚Äôve been dabbling in Game Theory recently and had to re-visit the Minimax algorithm. The algorithm was already familiar to me but I never took the time to actually implement it. It seemed like a good opportunity to implement it for a simple game such as Tic-Tac-Toe and explain its basics. Full source is available here. Without further ado, let‚Äôs get into it!\n\nMinimax is a type of adversarial search algorithm for generating and exploring game trees. It is mostly used to solve zero-sum games where one side‚Äôs gain is equivalent to other side‚Äôs loss, so adding all gains and subtracting all losses end up being zero.\n\nAdversarial search differs from conventional searching algorithms by adding opponents into the mix. Minimax algorithm keeps playing the turns of both player and the opponent optimally to figure out the best possible move.\n\nLet‚Äôs consider a simple game where there are only 2 possible moves in each state, such as Figure-1. Nodes of the tree represents game states, and edges represent moves. Top node is the minimizer, which means it‚Äôs your opponents turn. Naturally, it will pick the least favorable position for you.\n\nIn order for minimizer to figure out the least favorable move given the current game state, all possible states that can be reached from there must be generated. Luckily we are only looking 3 moves ahead, so our tree is rather manageable.\n\nLet‚Äôs take a look at each level of the tree:\n‚Ä¢ (IV) These are game‚Äôs terminal states. Each of these are evaluated and assigned a score based on how favorable they are.\n‚Ä¢ (III) Last move before the game ends, and it‚Äôs minimizer‚Äôs turn. The least favorable state for the maximizer is chosen.\n‚Ä¢ (II) Now maximizer knows how minimizer will play the next turn, out of all possible states that can be reached, the most optimal one is chosen.\n‚Ä¢ (I) Now that we‚Äôre back to the top, it‚Äôs decision time. By looking three moves ahead, minimizer knows exactly which path to take. Naturally, the path that had a score of 8 is chosen.\n\nAs you can see, since leaf nodes are terminal states, once minimax algorithm plays out each turn that leads to them, everything is decided. Assuming you are the one playing against that AI, even if you‚Äôre playing perfectly there‚Äôs no way for you to get a score higher than 8 at this point.\n\nTic-Tac-Toe is a rather simply game with only 255,168 possible games that can be played. This number is trivial for today‚Äôs computers, that‚Äôs why Tic-Tac-Toe is considered to be a solved game which means the outcome can be predicted given any state. The game is so simple that we can generate the entire game tree without trouble, whereas in chess there are already 69,352,859,712,417 possible games that could‚Äôve been played after just 10 moves.\n\nI‚Äôve used the p5 library for python to create a simple Tic-Tac-Toe board. Board state is represented in a two-dimensional, 3x3 matrix. After each move, board state is evaluated to check if a terminal state is reached.\n\nImplementing minimax for Tic-Tac-Toe is simple. We will recursively generate the game tree by exploring all possible moves for each board state and upon reaching a terminal state, we will assign a value of 1 for winning, -1 for losing and 0 for draw. Then based on these terminal states, for each explored turn either maximizer or minimizer will pick the most appropriate move. Doing so will propagate these outcomes all the way up to the root of the tree. The algorithm looks somewhat like this:\n\nImplementation in python can be found below. First, we check whether the current state is terminal and return a score if it is. If it‚Äôs not a terminal state, for all possible moves, we make the move, switch players, call minimax with the new board state, add its return value to a list of scores and undo the move.\n\nAfter exhausting all possible moves, we will either return the maximum or minimum of our scores list, depending on whether we‚Äôre maximizing or minimizing.\n\nSince it‚Äôs a solved game, we already know that if both sides play perfectly, there‚Äôs no chance of winning in Tic-Tac-Toe. So putting AI against AI would only result in a series of draws."
    },
    {
        "link": "https://geeksforgeeks.org/introduction-to-evaluation-function-of-minimax-algorithm-in-game-theory",
        "document": "Prerequisite: Minimax Algorithm in Game Theory\n\nAs seen in the above article, each leaf node had a value associated with it. We had stored this value in an array. But in the real world when we are creating a program to play Tic-Tac-Toe, Chess, Backgammon, etc. we need to implement a function that calculates the value of the board depending on the placement of pieces on the board. This function is often known as Evaluation Function. It is sometimes also called a Heuristic Function.\n\nThe evaluation function is unique for every type of game. In this post, the evaluation function for the game Tic-Tac-Toe is discussed. The basic idea behind the evaluation function is to give a high value for a board if the maximizer turn or a low value for the board if the minimizer turn.\n\nFor this scenario let us consider X as the maximizer and O as the minimizer.\n\nLet us build our evaluation function :\n‚Ä¢ If X wins on the board we give it a positive value of +10.\n‚Ä¢ If O wins on the board we give it a negative value of -10.\n‚Ä¢ If no one has won or the game results in a draw then we give a value of +0. \n\n\n\nWe could have chosen any positive/negative. For the sake of simplicity, we chose 10 and shall use lowercase ‚Äòx‚Äô and lowercase ‚Äòo‚Äô to represent the players and an underscore ‚Äò_‚Äô to represent a blank space on the board. \n\nIf we represent our board as a 3√ó3 2D character matrix, like char board[3][3]; then we have to check each row, each column, and the diagonals to check if either of the players has gotten 3 in a row.\n\nThe idea of this article is to understand how to write a simple evaluation function for the game Tic-Tac-Toe. In the next article we shall see how to combine this evaluation function with the minimax function. Stay Tuned.\n\nThis article is written by Akshay L. Aradhya."
    },
    {
        "link": "https://realpython.com/tic-tac-toe-ai-python",
        "document": "When you‚Äôre a child, you learn to play tic-tac-toe, which some people know as naughts and crosses. The game remains fun and challenging until you enter your teenage years. Then, you learn to program and discover the joy of coding a virtual version of this two-player game. As an adult, you may still appreciate the simplicity of the game by using Python to create an opponent with artificial intelligence (AI).\n\nBy completing this detailed step-by-step adventure, you‚Äôll build an extensible game engine with an unbeatable computer player that uses the minimax algorithm to play tic-tac-toe. Along the way, you‚Äôll dive into immutable class design, generic plug-in architecture, and modern Python code practices and patterns.\n\nIn this tutorial, you‚Äôll learn how to:\n‚Ä¢ Model the domain of tic-tac-toe following Pythonic code style\n‚Ä¢ Implement artificial players including one based on the minimax algorithm\n‚Ä¢ Build a text-based console front end for the game with a human player\n\nClick the link below to download the complete source code for this project:\n\nBy the end of this tutorial, you‚Äôll have a highly reusable and extensible Python library with an abstract game engine for tic-tac-toe. It‚Äôll encapsulate universal game rules and computer players, including one that never loses due to bare-bones artificial intelligence support. In addition, you‚Äôll create a sample console front end that builds on top of your library and implements a text-based interactive tic-tac-toe game running in the terminal. Here‚Äôs what actual gameplay between two players might look like: Generally, you may mix and choose the players from among a human player, a dummy computer player making moves at random, and a smart computer player sticking to the optimal strategy. You can also specify which player should make the first move, increasing their chances of winning or tying. Later, you‚Äôll be able to adapt your generic tic-tac-toe library for different platforms, such as a windowed desktop environment or a web browser. While you‚Äôll only follow instructions on building a console application in this tutorial, you can find Tkinter and PyScript front end examples in the supporting materials. Note: These front ends aren‚Äôt covered here because implementing them requires considerable familiarity with threading, asyncio, and queues in Python, which is beyond the scope of this tutorial. But feel free to study and play around with the sample code on your own. The Tkinter front end is a streamlined version of the same game that‚Äôs described in a separate tutorial, which only serves as a demonstration of the library in a desktop environment: Unlike the original, it doesn‚Äôt look as slick, nor does it allow you to restart the game easily. However, it adds the option to play against the computer or another human player if you want to. The PyScript front end lets you or your friends play the game in a web browser even when they don‚Äôt have Python installed on their computer, which is a notable benefit: If you‚Äôre adventurous and know a little bit of PyScript or JavaScript, then you could extend this front end by adding the ability to play online with another human player through the network. To facilitate the communication, you‚Äôd need to implement a remote web server using the WebSocket protocol, for instance. Take a look at a working WebSocket client and server example in another tutorial to get an idea of how that might work. It‚Äôs worth noting that each of the three front ends demonstrated in this section merely implement a different presentation layer for the same Python library, which provides the underlying game logic and players. There‚Äôs no unnecessary redundancy or code duplication across them, thanks to the clear separation of concerns and other programming principles that you‚Äôll practice in this tutorial.\n\nThe project that you‚Äôre going to build consists of two high-level components depicted in the diagram below: The first component is an abstract tic-tac-toe Python library, which remains agnostic about the possible ways of presenting the game to the user in a graphical form. Instead, it contains the core logic of the game and two artificial players. However, the library can‚Äôt stand on its own, so you‚Äôre also going to create a sample front end to collect user input from the keyboard and visualize the game in the console using plain text. You‚Äôll start by implementing the low-level details of the tic-tac-toe library, and then you‚Äôll use those to implement a higher-level game front end in a bottom-up fashion. When you finish this tutorial, the complete file structure resulting will look like this: The folder is meant to house one or more concrete game implementations, such as your text-based console one, while is the home folder for the game library. You can think of both top-level folders as related yet separate projects. Notice that your console front end contains the file, making it a runnable Python package that you‚Äôll be able to invoke from the command line using Python‚Äôs option. Assuming that you changed the current working directory to after downloading the complete source code that you‚Äôll be writing in this tutorial, you can start the game with the following command: Remember that Python must be able to find the tic-tac-toe library, which your front end depends on, on the module search path. The best practice for ensuring this is by creating and activating a shared virtual environment and installing the library with . You‚Äôll find detailed instructions on how to do this in the README file in the supporting materials. The tic-tac-toe library is a Python package named consisting of two subpackages:\n‚Ä¢ : A scaffolding designed to be extended by front ends\n‚Ä¢ : The building blocks of the tic-tac-toe game You‚Äôll dive deeper into each of them soon. The file contains the metadata necessary for building and packaging the library. To install the downloaded library or the finished code that you‚Äôll build in this tutorial into an active virtual environment, try this command: During development, you can make an editable install using with the or flag to mount the library‚Äôs source code instead of the built package in your virtual environment. This will prevent you from having to repeat the installation after making changes to the library to reflect them in your front end. Okay, that‚Äôs what you‚Äôre going to build! But before you get started, check out the prerequisites.\n\nIn this step, you‚Äôll identify the parts that make up a tic-tac-toe game and implement them using an object-oriented approach. By modeling the domain of the game with immutable objects, you‚Äôll end up with modular and composable code that‚Äôs easier to test, maintain, debug, and reason about, among several other advantages. For starters, open the code editor of your choice, such as Visual Studio Code or PyCharm, and create a new project called , which will also become the name of your project folder. Nowadays, most code editors will give you the option to create a virtual environment for your project automatically, so go ahead and follow suit. If yours doesn‚Äôt, then make the virtual environment manually from the command line: This will create a folder named under . You don‚Äôt have to activate your new virtual environment unless you plan to continue working in the current command-line session. Next, scaffold this basic structure of files and folders in your new project, remembering to use underscores ( ) instead of dashes ( ) for the Python package in the subfolder: All of the files in the file tree above should be empty at this point. You‚Äôll successively fill them with content and add more files as you go through this tutorial. Start by editing the file located next to your subfolder. You can paste this fairly minimal packaging configuration for your tic-tac-toe library into it: You specify the required build tools, which Python will download and install if necessary, along with some metadata for your project. Adding the file to the library lets you build and install it as a Python package into your active virtual environment. Note: The file is a standard configuration file using the TOML format for specifying minimum build system requirements for Python projects. The concept was introduced in PEP 518 and is now the recommended way of adding packaging metadata and configuration in Python. You‚Äôre going to need this to install the tic-tac-toe library into your virtual environment. Open the terminal window and issue the following commands to activate your virtual environment if you haven‚Äôt already, and install the tic-tac-toe library using the editable mode: Even though there‚Äôs no Python code in your library yet, installing it now with the flag will let the Python interpreter import the functions and classes that you‚Äôll be adding shortly straight from your project. Otherwise, every single time you made a change in your source code and wanted to test it, you‚Äôd have to remember to build and install the library into your virtual environment again. Now that you have a general structure for your project, you can start implementing some code. By the end of this step, you‚Äôll have all the essential pieces of a tic-tac-toe game in place, including the game logic and state validation, so you‚Äôll be ready to combine them in an abstract game engine. At the start of the game, each tic-tac-toe player gets assigned one of two symbols, either cross (X) or naught (O), which they use to mark locations on the game board. Since there are only two symbols belonging to a fixed set of discrete values, you can define them within an enumerated type or enum. Using enums is preferable over constants due to their enhanced type safety, common namespace, and programmatic access to their members. Create a new Python module called in the package: You‚Äôll use this file throughout the rest of this step to define tic-tac-toe domain model objects. Now, import the module from Python‚Äôs standard library and define a new data type in your models: The two singleton instances of the class, the enum members and , represent the players‚Äô symbols. By default, you can‚Äôt compare a member of a Python enum against its value. For instance, comparing will give you . This is by design to avoid confusing identical values defined in different places and having unrelated semantics. However, it may sometimes be more convenient to think about the player marks in terms of strings instead of enum members. To make that happen, define as a mixin class of the and types: This is known as a derived enum, whose members can be compared to instances of the mixed-in type. In this case, you can now compare and to string values. Note: Python 3.10 was the latest release at the time of writing this tutorial, but if you‚Äôre using a newer release, then you can directly extend , which was added to the standard library in Python 3.11: Members of are also strings, which means that you can use them almost anywhere that a regular string is expected. Once you assign a given mark to the first player, the second player must be assigned the only remaining and unassigned mark. Because enums are glorified classes, you‚Äôre free to put ordinary methods and properties into them. For example, you can define a property of a member that‚Äôll return the other member: The body of your property is a single line of code that uses a conditional expression to determine the correct mark. The quotation marks around the return type in your property‚Äôs signature are mandatory to make a forward declaration and avoid an error due to an unresolved name. After all, you claim to return a , which hasn‚Äôt been fully defined yet. Note: Alternatively, you can postpone the evaluation of annotations until after they‚Äôve been defined: Adding a special import, which must appear at the beginning of your file, enables the lazy evaluation of type hints. You‚Äôll use this pattern later to avoid the circular reference problem when importing cross-referencing modules. In Python 3.11, you can also use a universal type to avoid the forward declaration in type hints in the first place. To reveal a few practical examples of using the enum, expand the collapsible section below: How to Use Show/Hide Before proceeding, make sure that you made the library accessible on the module search path by, for example, installing it into an active virtual environment, as shown earlier in the project overview: # Refer to a mark by its symbolic name literal # Refer to a mark by its symbolic name (string) # Refer to a mark by its value # Use the mark as if it was a string # Iterate over the available marks You‚Äôll use some of those techniques later in this tutorial. You now have a way to represent the available markings that players will leave on the board to advance the game. Next, you‚Äôll implement an abstract game board with well defined locations for those markings. While some people play variants of tic-tac-toe with different numbers of players or different sizes of grids, you‚Äôll stick with the most basic and classic rules. Recall that the game‚Äôs board is represented by a three-by-three grid of cells in the classic tic-tac-toe. Each cell can be empty or marked with either a cross or a naught. Because you represent marks with a single character, you can implement the grid using a string of precisely nine characters corresponding to the cells. A cell can be empty, in which case you‚Äôll fill it with the space character ( ), or it can contain the player‚Äôs mark. In this tutorial, you‚Äôll store the grid in row-major order by concatenating the rows from top to bottom. For example, with such a representation, you could express the three gameplays demonstrated before with the following string literals: To better visualize them, you can whip up and run this short function in an interactive Python interpreter session: The function takes a string of cells as an argument and prints it onto the screen in the form of three separate rows carved out with the slice operator from the input string. While using strings to represent the grid of cells is pretty straightforward, it falls short in terms of validating its shape and content. Other than that, plain strings can‚Äôt provide some extra, grid-specific properties that you might be interested in. For these reasons, you‚Äôll create a new data type on top of a string wrapped in an attribute: You define as a frozen data class to make its instances immutable so that once you create a grid object, you won‚Äôt be able to alter its cells. This may sound limiting and wasteful at first because you‚Äôll be forced to make many instances of the class instead of just reusing one object. However, the benefits of immutable objects, including fault tolerance and improved code readability, far outweigh the costs in modern computers. By default, when you don‚Äôt specify any value for the attribute, it‚Äôll assume a string of exactly nine spaces to reflect an empty grid. However, you can still initialize the grid with the wrong value for cells, ultimately crashing the program. You can prevent this by allowing your objects only to exist if they‚Äôre in a valid state. Otherwise, they won‚Äôt be created at all, following the fail-fast and always-valid domain model principles. Data classes take control of object initialization, but they also let you run a post-initialization hook to set derived properties based on the values of other fields, for example. You‚Äôll take advantage of this mechanism to perform cell validation and potentially discard invalid strings before instantiating a grid object: \"Must contain 9 cells of: X, O, or space\" Your special method uses a regular expression to check whether the given value of the attribute is exactly nine characters long and contains only the expected characters‚Äîthat is, , , or . There are other ways to validate strings, but regular expressions are very compact and will remain consistent with the future validation rules that you‚Äôll add later. Note: The grid is only responsible for validating the syntactical correctness of a string of cells, but it doesn‚Äôt understand the higher-level rules of the game. You‚Äôll implement the validation of a particular cell combination‚Äôs semantics elsewhere once you gain additional context. At this point, you can add a few extra properties to your class, which will become handy when determining the state of the game: \"Must contain 9 cells of: X, O, or space\" The three properties return the current number of crosses, naughts, and empty cells, respectively. Because your data class is immutable, its state will never change, so you can cache the computed property values with the help of the decorator from the module. This will ensure that their code will run at most once, no matter how many times you access these properties, for example during validation. To reveal a few practical examples of using the class, expand the collapsible section below: How to Use Show/Hide Before proceeding, make sure that you made the library accessible on the module search path by, for example, installing it into an active virtual environment, as shown earlier in the project overview: # Don't create a grid with too few cells : Must contain 9 cells of: X, O, or space : Must contain 9 cells of: X, O, or space # Get the count of Xs, Os, and empty cells Now you know how to use the class. Using Python code, you modeled a three-by-three grid of cells, which can contain a particular combination of players‚Äô marks. Now, it‚Äôs time to model the player‚Äôs move so that artificial intelligence can evaluate and choose the best option. Take a Snapshot of the Player‚Äôs Move An object representing the player‚Äôs move in tic-tac-toe should primarily answer the following two questions:\n‚Ä¢ Player‚Äôs Mark: What mark did the player place?\n‚Ä¢ Mark‚Äôs Location: Where was it placed? However, in order to have the complete picture, one must also know about the state of the game before making a move. After all, it can be a good or a bad move, depending on the current situation. You may also find it convenient to have the resulting state of the game at hand so that you can assign it a score. By simulating that move, you‚Äôll be able to compare it with other possible moves. Note: A move object can‚Äôt validate itself without knowing some of the game details, such as the starting player‚Äôs mark, which aren‚Äôt available to it. You‚Äôll check whether a given move is valid, along with validating a specific grid cell combination, in a class responsible for managing the game‚Äôs state. Based on these thoughts, you can add another immutable data class to your models: Please ignore the two forward declarations of the class for the moment. You‚Äôll define that class in the next section, using the type hint as a temporary placeholder. Your new class is strictly a data transfer object (DTO) whose main purpose is to carry data, as it doesn‚Äôt provide any behavior through methods or dynamically computed properties. Objects of the class consist of the mark identifying the player who made a move, a numeric zero-based index in the string of cells, and the two states before and after making a move. The class will be instantiated, populated with values, and manipulated by the missing class. Without it, you won‚Äôt be able to correctly create the move objects yourself. It‚Äôs time to fix that now! A tic-tac-toe game can be in one of several states, including three possible outcomes:\n‚Ä¢ The game is still going on.\n‚Ä¢ The game has finished in a tie.\n‚Ä¢ The game has finished with player X winning.\n‚Ä¢ The game has finished with player O winning. You can determine the current state of a tic-tac-toe game based on two parameters:\n‚Ä¢ The combination of cells in the grid\n‚Ä¢ The mark of the starting player Without knowing who started the game, you won‚Äôt be able to tell whose turn it is now and whether the given move is valid. Ultimately, you can‚Äôt properly assess the situation so that the artificial intelligence can make the right decision. To fix that, begin by specifying the game state as another immutable data class consisting of the grid of cells and the starting player‚Äôs mark: By convention, the player who marks the cells with crosses starts the game, hence the default value of for the starting player‚Äôs mark. However, you can change it according to your preference by supplying a different value at runtime. Now, add a cached property returning the mark of the player who should make the next move: The current player‚Äôs mark will be the same as the starting player‚Äôs mark when the grid is empty or when both players have marked an equal number of cells. In practice, you only need to check the latter condition because a blank grid implies that both players have zero marks in the grid. To determine the other player‚Äôs mark, you can take advantage of your property in the enum. Next up, you‚Äôll add some properties for evaluating the current state of the game. For example, you can tell that the game hasn‚Äôt started yet when the grid is blank, or contains exactly nine empty cells: This is where your grid‚Äôs properties come in handy. Conversely, you can conclude that the game has finished when there‚Äôs a clear winner or there‚Äôs a tie: The property, which you‚Äôll implment in a bit, will return a instance or , whereas the property will be a Boolean value. A tie is when neither player has won, which means there‚Äôs no winner, and all of the squares are filled, leaving zero empty cells: Both the and properties rely on the property, which they delegate to. Finding a winner is slightly more difficult, though. You can, for example, try to match the current grid of cells against a predefined collection of winning patterns with regular expressions: There are eight winning patterns for each of the two players, which you define using templates resembling regular expressions. The templates contain question-mark placeholders for the concrete player‚Äôs mark. You iterate over those templates and replace the question marks with both players‚Äô marks to synthesize two regular expressions per pattern. When the cells match a winning pattern, you return the corresponding mark. Otherwise, you return . Knowing the winner is one thing, but you may also want to know the matched winning cells to differentiate them visually. In this case, you can add a similar property, which uses a list comprehension to return a list of integer indices of the winning cells: You might be concerned about having a bit of code duplication between and , which violates the Don‚Äôt Repeat Yourself (DRY) principle, but that‚Äôs okay. The Zen of Python says that practicality beats purity, and indeed, extracting the common denominator would provide little value here while making the code less readable. Note: It usually makes sense to start thinking about refactoring your code when there are at least three instances of a duplicated code fragment. There‚Äôs a high chance that you‚Äôll need to reuse the same piece of code even more. Your is starting to look pretty good. It can correctly recognize all possible game states, but it lacks proper validation, making it prone to runtime errors. In the next few sections, you‚Äôll rectify that by codifying and enforcing a few tic-tac-toe rules. As with the grid, creating an instance of the class should fail when the supplied combination of cells and the starting player‚Äôs mark don‚Äôt make sense. For example, it‚Äôs currently possible to create an invalid game state that doesn‚Äôt reflect genuine gameplay. You can test it yourself. Start an interactive Python interpreter session in the virtual environment where you had previously installed your library, and then run the following code: Here, you initialize a new game state using a grid comprising a syntactically correct string with the right characters and length. However, such a cell combination is semantically incorrect because one player isn‚Äôt allowed to fill the entire grid with their mark. Because validating the game state is relatively involved, implementing it in the domain model would violate the single-responsibility principle and make your code less readable. Validation belongs to a separate layer in your architecture, so you should keep the domain model and its validation logic in two different Python modules without mixing their code. Go ahead and create two new files in your project: You‚Äôll store various helper functions in and a few exception classes in the file to decouple game state validation from the model. For improved code consistency, you can extract the grid validation that you defined earlier in the method, move it into the newly created Python module, and wrap it in a new function: \"Must contain 9 cells of: X, O, or space\" Note that you replaced with because you‚Äôre now referring to a grid instance through the function‚Äôs argument. If you‚Äôre using PyCharm, then it might have started highlighting an unresolved reference to , which isn‚Äôt present on the search path for Python modules and packages. PyCharm doesn‚Äôt seem to recognize editable installs correctly, but you can fix that by right-clicking on your folder and marking it as the so-called sources root in the project view: You can have as many folders marked as sources roots as you want. Doing so will append their absolute paths to the environment variable managed by PyCharm. However, this won‚Äôt affect your environment outside of PyCharm, so running a script through the system‚Äôs terminal won‚Äôt benefit from marking those folders. Instead, you can activate the virtual environment with your library installed to import its code. After extracting the grid validation logic, you should update the corresponding part in your model by delegating the validation to an appropriate abstraction: # tic_tac_toe/logic/models.py import enum import re from dataclasses import dataclass from functools import cached_property # ... @dataclass(frozen=True) class Grid: cells: str = \" \" * 9 def __post_init__(self) -> None: - raise ValueError(\"Must contain 9 cells of: X, O, or space\") @cached_property def x_count(self) -> int: return self.cells.count(\"X\") @cached_property def o_count(self) -> int: return self.cells.count(\"O\") @cached_property def empty_count(self) -> int: return self.cells.count(\" \") # ... You import the new helper function and call it in your grid‚Äôs post-initialization hook, which now uses a higher-level vocabulary to communicate its intent. Previously, some low-level details, such as the use of regular expressions, were leaking into your model, and it wasn‚Äôt immediately clear what the method does. Unfortunately, this change now creates the notorious circular-reference problem between your model and validator layers, which mutually depend on each other‚Äôs bits. When you try to import , you‚Äôll get this error: : cannot import name 'Grid' from partially initialized module 'tic_tac_toe.logic.models' (most likely due to a circular import) That‚Äôs because Python reads the source code from top to bottom. As soon as it encounters an statement, it‚Äôll jump to the imported file and start reading it. However, in this case, the imported module wants to import the module, which hasn‚Äôt been fully processed yet. This is a very common problem in Python when you start using type hints. The only reason you need to import is because of a type hint in your validating function. You could get away without the import statement by surrounding the type hint with quotes ( ) to make a forward declaration like before. However, you‚Äôll follow a different idiom this time. You can combine the postponed evaluation of annotations with a special constant: # tic_tac_toe/logic/validators.py import re def validate_grid(grid: Grid) -> None: if not re.match(r\"^[\\sXO]{9}$\", grid.cells): raise ValueError(\"Must contain 9 cells of: X, O, or space\") You import conditionally. The constant is false at runtime, but third-party tools, such as mypy, will pretend it‚Äôs true when performing static type checking to allow the import statement to run. However, because you no longer import the required type at runtime, you must now use forward declarations or take advantage of , which will implicitly turn annotations into string literals. Note: The import was originally intended to make the migration from Python 2 to Python 3 more seamless. Today, you can use it to enable various language features planned for future releases. Once a feature becomes part of the standard Python distribution and you don‚Äôt need to support older language versions, you can remove that import. With all this plumbing in place, you‚Äôre finally ready to constrain the game state to comply with the tic-tac-toe rules. Next up, you‚Äôll add a few validation functions to your new module. In order to reject invalid game states, you‚Äôll implement a familiar post-initialization hook in your class that delegates the processing to another function: The validating function, , receives an instance of the game state, which in turn contains the grid of cells and the starting player. You‚Äôre going to use this information, but first, you‚Äôll split the validation into a few smaller and more focused stages by delegating bits of the state further down in your module: Your new helper function serves as an entry point to the game state validation by calling a few subsequent functions that you‚Äôll define in just a bit. To prevent instantiating a game state with an incorrect number of a player‚Äôs marks in the grid, such as the one you stumbled on before, you must take the proportion of naughts to crosses into account: At any time, the number of marks left by one player must be either the same or greater by exactly one compared to the number of marks left by the other player. Initially, there are no marks, so the number of Xs and Os is equal to zero. When the first player makes a move, they‚Äôll have one more mark than their opponent. But, as soon as the other player makes their first move, the proportion evens out again, and so on. To signal an invalid state, you raise a custom exception defined in another module: \"\"\"Raised when the game state is invalid.\"\"\" It‚Äôs customary to have empty classes extend the built-in type in Python without specifying any methods or attributes in them. Such classes exist solely for their names, which convey enough information about the error that occurred at runtime. Notice that you don‚Äôt need to use the statement or the ellipsis literal ( ) as a class body placeholder if you use a docstring, which can provide additional documentation. Another game state inconsistency related to the number of marks left on the grid has to do with the starting player‚Äôs mark, which may be wrong: The player who left more marks on the grid is guaranteed to be the starting player. If not, then you know that something must have gone wrong. Because you defined as an enum derived from , you can directly compare the starting player‚Äôs mark to a string literal. Finally, there can only be one winner, and depending on who started the game, the ratio of Xs ans Os left on the grid will be different: A starting player has an advantage, so when they win, they‚Äôll have left more marks than their opponent. Conversely, the second player is at a disadvantage, so they can only win the game by making an equal number of moves as the starting player. You‚Äôre almost done with encapsulating the tic-tac-toe game‚Äôs rules in Python code, but there‚Äôs still one more important piece missing. In the next section, you‚Äôll write code to systematically produce new game states by simulating players‚Äô moves. The last property that you‚Äôll add to your class is a fixed list of possible moves, which you can find by filling the remaining empty cells in the grid with the current player‚Äôs mark: If the game‚Äôs over, then you return an empty list of moves. Otherwise, you identify the locations of empty cells using a regular expression, and then make a move to each of those cells. Making a move creates a new object, which you append to the list without mutating the game state. This is how you construct a object: A move isn‚Äôt allowed if the target cell is already occupied by either your or your opponent‚Äôs mark, in which case you raise an exception. On the other hand, if the cell is empty, then you take a snapshot of the current player‚Äôs mark, the target cell‚Äôs index, and the current game state while synthesizing the following state. Don‚Äôt forget to define the new exception type that you imported: \"\"\"Raised when the game state is invalid.\"\"\" \"\"\"Raised when the move is invalid.\"\"\" That‚Äôs it! You‚Äôve just gotten yourself a pretty solid domain model of the tic-tac-toe game, which you can use to build interactive games for various front ends. The model encapsulates the game‚Äôs rules and enforces its constraints. How to Use Show/Hide Before proceeding, make sure that you made the library accessible on the module search path by, for example, installing it into an active virtual environment, as shown earlier in the project overview: Now you know how the various attributes work and how to combine them with other domain model objects. In the next section, you‚Äôll build an abstract game engine and your first artificial player.\n\nAt this point, you should have all the domain models defined for your tic-tac-toe library. Now, it‚Äôs time to build a game engine that‚Äôll take advantage of these model classes to facilitate tic-tac-toe gameplay. Go ahead and create three more Python modules inside the package now: The module is the centerpiece of the virtual gameplay, where you‚Äôll implement the game‚Äôs main loop. You‚Äôll define abstract interfaces that the game engine uses, along with a sample computer player, in the and modules. By the end of this step, you‚Äôll be set to write a tangible front end for the tic-tac-toe library. Pull the Players‚Äô Moves to Drive the Game At the very minimum, to play a tic-tac-toe game, you need to have two players, something to draw on, and a set of rules to follow. Fortunately, you can express these elements as immutable data classes, which take advantage of the existing domain model from your library. First, you‚Äôll create the class in the module: Both and will be implemented in the following sections as Python‚Äôs abstract base classes, which only describe the high-level interface for your game engine. However, they‚Äôll eventually get replaced with concrete classes, some of which may come from an externally defined front end. The player will know what move to make, and the renderer will be responsible for visualizing the grid. To play the game, you must decide which player should make the first move, or you can assume the default one, which is the player with crosses. You should also begin with a blank grid of cells and an initial game state: The engine requests that the renderer update the view and then uses a pull strategy to advance the game by asking both players to make their moves in alternating rounds. These steps are repeated in an infinite loop until the game is over. only knows about the current player‚Äôs mark, which can be either X or O, but it doesn‚Äôt know about the specific player objects that were assigned those marks. Therefore, you need to map the current mark to a player object using this helper method: Here, you compare enum members by their identities using Python‚Äôs operator. If the current player‚Äôs mark determined by the game state is the same as the mark assigned to the first player, then that‚Äôs the player who should be making the next move. Both players supplied to the object should have opposite marks. Otherwise, you wouldn‚Äôt be able to play the game without violating its rules. So, it‚Äôs reasonable to validate the players‚Äô marks when instantiating the class: You add a post-initialization hook to your data class and call another validation function that you have to add in your module: \"Players must use different marks\" You use the identity comparison again to check both players‚Äô marks and prevent the game from starting when both players use the same mark. There‚Äôs one more thing that can go wrong. Because it‚Äôs up to the players, including human players, to decide what move they make, their choice could be invalid. Currently, your class catches the exception but doesn‚Äôt do anything useful with it other than ignore such a move and ask the player to make a different choice. It would probably help to let the front end handle errors by, for example, showing a suitable message: To let the front end decide how to take care of an invalid move, you expose a hook in your class by introducing an optional callback, which will receive the exception. You define the callback‚Äôs type using a type alias, making its type declaration more concise. The game will trigger this callback in case of an invalid move, as long as you provide the error handler. Having implemented an abstract tic-tac-toe game engine, you can proceed to code an artificial player. You‚Äôll define a generic player interface and implement it with a sample computer player that makes moves at random. First, define an abstract , which will be the base class for concrete players to extend: An abstract class is one that you can‚Äôt instantiate because its objects wouldn‚Äôt stand on their own. Its only purpose is to provide the skeleton for concrete subclasses. You can mark a class as abstract in Python by setting its metaclass to or extending the ancestor. Note: Using the argument instead of extending the base class is slightly more flexible, as it doesn‚Äôt affect your inheritance hierarchy. This is less important in languages like Python, which support multiple inheritance. Anyway, as a rule of thumb, you should favor composition over inheritance whenever possible. The player gets assigned a instance that they‚Äôll be using during the game. The player also exposes a public method to make a move, given a certain game state: \"It's the other player's turn\" \"\"\"Return the current player's move in the given game state.\"\"\" Notice how the public method defines a universal algorithm for making a move, but the individual step of getting the move is delegated to an abstract method, which you must implement in concrete subclasses. Such a design is known as the template method pattern in object-oriented programming. Making a move entails checking if it‚Äôs the given player‚Äôs turn and whether the move exists. The method returns to indicate that no more moves are possible, and the abstract class uses the Walrus operator ( ) to simplify the calling code. To make the game feel more natural, you can introduce a short delay for the computer player to wait before choosing their move. Otherwise, the computer would make its moves instantly, unlike a human player. You can define another, slightly more specific abstract base class to represent computer players: \"\"\"Return the computer's move in the given game state.\"\"\" extends by adding an additional member, , to its instances, which by default is equal to 250 milliseconds. It also implements the method to simulate a certain wait time, and then calls another abstract method specific to computer players. Having an abstract computer player data type enforces a uniform interface, which you can conveniently satisfy with a few lines of code. For example, you can implement a computer player picking moves at random in the following way: You use to pick a random element from a list of possible moves. If there are no more moves in the given game state, then you‚Äôll get an because of an empty list, so you catch it and return instead. You now have two abstract base classes, and , as well as one concrete , which you‚Äôll be able to use in your games. The only remaining element of the equation before you can put those classes into action is the abstract renderer, which you‚Äôll define next. Giving the tic-tac-toe grid a visual form is entirely up to the front end, so you‚Äôll only define an abstract interface in your library: This could‚Äôve been implemented as a regular function because the renderer exposes only a single operation while getting the whole state through an argument. However, concrete subclasses may need to maintain an additional state, such as the application‚Äôs window, so having a class may come in handy at some point. Okay, you have the tic-tac-toe library with a robust domain model, an engine encapsulating the game rules, a mechanism to simulate moves, and even a concrete computer player. In the next section, you‚Äôll combine all the pieces together and build a game front end, letting you finally see some action!\n\nSo far, you‚Äôve been working on an abstract tic-tac-toe game engine library, which provides the building blocks for the game. In this section, you‚Äôll bring it to life by coding a separate project that relies on this library. It‚Äôs going to be a bare-bones game running in the text-based console. The most important aspect of any game front end is providing visual feedback to the players through a graphical interface. Because you‚Äôre constrained to the text-based console in this example, you‚Äôll take advantage of ANSI escape codes to control things like text formatting or placement. Create the module in your console front end and define a concrete class that extends the tic-tac-toe‚Äôs abstract renderer in it: In case you‚Äôre using Visual Studio Code, and it doesn‚Äôt resolve the imports, try closing and reopening the editor. The class overrides , the only abstract method responsible for visualizing the game‚Äôs current state. In this case, you start by clearing the screen‚Äôs content using a helper function, which you can define below the class: The string literal represents a non-printable character, which starts a special code sequence. The letter that follows encodes the command to clear the screen. Note that the function automatically ends the text with a newline character. To avoid adding an unnecessary blank line, you must disable this by setting the argument. When there‚Äôs a winner, you‚Äôll want to distinguish their winning marks with blinking text. You can define another helper function to encode blinking text using the relevant ANSI escape code: Here, you wrap the supplied text with opening and closing ANSI escape codes in Python‚Äôs f-string. To render the tic-tac-toe grid filled with players‚Äô marks, you‚Äôll format a multiline template string and use the module to remove the indentation: The function takes a sequence of cells and prints them with an additional gutter around the top-left corner. It contains numbered rows and columns indexed by letters. For example, a partially filled tic-tac-toe grid may look like this on the screen: The gutter will make it easier for the player to specify the coordinates of the target cell where they want to put their mark. If there‚Äôs a winner, you‚Äôll want to blink some of their cells and print a message stating who won the game. Otherwise, you‚Äôll print a solid grid of cells and optionally inform the players that there are no winners in case of a tie: Your messages contain special syntax for name aliases of Unicode characters, including emojis, in order to make the output look more colorful and exciting. For example, will render the üéâ emoji. Note that you call yet another helper function, , which you must define now: This new function takes the sequence of cells and the numeric positions of those which should be rendered using blinking text. Then, it makes a mutable copy of the cells, overwrites the specified cells with blinking ANSI escape codes, and delegates the rendering to . At this point, you can test your custom renderer using two computer players built into the tic-tac-toe library. Save the following code in a file named located in the folder: When you run this script, you‚Äôll see two artificial players making random moves, leading to different outcomes each time: While it‚Äôs interesting to look at their gameplay, there‚Äôs no interactivity whatsoever. You‚Äôre going to change that now by letting human players decide what moves to make. At the end of this section, you‚Äôll be able to play a tic-tac-toe match between a human and a computer player or two human players, in addition to the two computer players you just saw. A human player will use the keyboard interface to specify their moves. You can define a new concrete player class in your console front end, which will implement the abstract method specified in the library. Create the front end‚Äôs module and fill it with the following content: \"Please provide coordinates in the form of A1 or 1A\" \"That cell is already occupied.\" If the game has finished, then you return to indicate that no moves were possible. Otherwise, you keep asking the player for a valid move until they provide one and make that move. Because the human player types cell coordinates like or , you must convert such text to a numeric index with the help of the function: \"Please provide coordinates in the form of A1 or 1A\" \"That cell is already occupied.\" The function uses regular expressions to extract the numeric row and column so that you can calculate the corresponding index in the flat sequence of cells. You can now modify your test script by importing and instantiating : Running this script will allow you to play as X against the computer. Unfortunately, there‚Äôs no convenient way of changing the players or stating who should start the game, because this information is baked into the code. Next up, you‚Äôll add a command-line interface to fix that. You‚Äôre almost done building your tic-tac-toe front end. However, it‚Äôs time to add the finishing touches and turn it into a playable game by implementing a useful command-line interface using the module. That way, you‚Äôll be able to choose the player types and the starting mark before running the game. The entry point to your console front end is the special module, which makes the containing package runnable through the command. Because it‚Äôs customary to put minimal wrapper code in it, you‚Äôll keep the module lightweight by delegating the processing to a function imported from another module: This makes the code that‚Äôs defined in more reusable across many places and easier to test in isolation. Here‚Äôs how that code might look: You import the game engine, your new console renderer, and a helper function, , which will be able to read command-line arguments and, based on them, return two player objects and the starting player‚Äôs mark. To implement the parsing of arguments, you can start by defining the available player types as a Python dictionary, which associates everyday names like human with concrete classes extending the abstract : This will make it more straightforward to add more player types in the future. Next, you can write a function that‚Äôll use the module to get the expected arguments from the command line: The code above translates to the following three optional arguments, all of which have default values: Assigns X to the specified player Assigns O to the specified player At this point, the function parses those arguments and stores their values as strings in a special NameSpace object under the attributes named , , and , respectively. However, the function is expected to return a tuple consisting of custom data types instead of strings. To make the function‚Äôs body comply with its signature, you can map strings provided by the user to the respective classes using your dictionary: You translate the user-supplied names to concrete player classes. If the starting player‚Äôs mark is different from the default one, then you swap the two players before returning them from the function. To make the code slightly cleaner and more expressive, you may replace the generic tuple with a typed named tuple: First, you define a subclass comprising precisely three named and typed elements. You then return an instance of your named tuple instead of a generic tuple. Doing so gives you additional type safety and access to the tuple‚Äôs elements by name as well as by index. To play against another human, you can run your console front end with these arguments: If you‚Äôd like to try your chances against the computer, then replace the value of either the or option with random, which is currently the only computer player type available. Unfortunately, it isn‚Äôt particularly challenging to play against a player making moves at random. In the next step, you‚Äôll implement a more advanced computer player leveraging the minimax algorithm, which makes the computer practically undefeatable.\n\nYou‚Äôve reached the final step in this tutorial, which involves creating another computer player, this one equipped with basic artificial intelligence. Specifically, it‚Äôll use the minimax algorithm under the surface to make the most optimal move in every possible situation in any turn-based zero-sum game like tic-tac-toe. Note: Mastering the details of the minimax algorithm isn‚Äôt your focus in this tutorial. But, if you‚Äôd like to learn more about it, then check out Minimax in Python: Learn How to Lose the Game of Nim, which uses a more straightforward game of Nim as an example. Before implementing the algorithm, you have to invent a way of assessing the game‚Äôs score, which will become the deciding factor behind choosing the best move. You‚Äôll do that by introducing an absolute scale of numeric values indicating how well both players are doing. For simplicity, you‚Äôll consider static evaluation of a finished game. There are three possible outcomes of the game, which you can assign arbitrary numeric values, for example: The protagonist player whose score you‚Äôll evaluate is known as the maximizing player because they try to maximize the game‚Äôs overall score. Therefore, greater values should correspond to better outcomes, as viewed from their perspective. The minimizing player, on the other hand, is their opponent, who tries to lower the score as much as possible. After all, they win when your player loses, while a tie can be equally good or bad for both players. Once you determine the maximizing and minimizing players, the scale remains absolute, meaning you don‚Äôt need to flip the sign when evaluating your opponent‚Äôs moves. You can express this numeric scale in Python code by adding the following method to your model in the tic-tac-toe library: Because this is a static evaluation, you can only determine the score when the game is over. Otherwise, you raise an exception, which you must add to the module in the library: \"\"\"Raised when the game state is invalid.\"\"\" \"\"\"Raised when the move is invalid.\"\"\" \"\"\"Raised when the game score is unknown.\"\"\" Knowing the score of a finished game isn‚Äôt that helpful when you want to make an informed decision about choosing a move up front. However, it‚Äôs the first step toward finding the best possible sequence of moves leading up to winning‚Äîor tying the game, in the worst-case scenario. Next, you‚Äôll use the minimax algorithm to calculate the score in any game state. Propagate the Score With the Minimax Algorithm When you have several moves to choose from, you want to pick one that‚Äôll increase your expected score. At the same time, you want to avoid moves that could potentially shift the game‚Äôs score in favor of your opponent. The minimax algorithm can help with that by using the and functions to minimize your opponent‚Äôs maximum gain while maximizing your minimum payoff. If that sounds complicated, then have a look at a graphical visualization of tic-tac-toe gameplay below. When you imagine all possible game states as a game tree, choosing the best move boils down to searching for the most optimal path in such a weighted graph, starting from the current node. The minimax algorithm propagates the scores evaluated statically for the leaf nodes, which correspond to finished games, by bubbling them up in the game tree. Either the minimum or the maximum score gets propagated at each step, depending on whose turn it is. You can visualize this process using a concrete example of the final three turns in a game of tic-tac-toe. Below, you‚Äôll find a small segment of the tic-tac-toe game tree illustrating the possible moves of the maximizing player X, whose turns are depicted in green: The minimax algorithm starts by recursively exploring the tree to look ahead and find all the possible game outcomes. Once those are found, it computes their scores and backtracks to the starting node. If it‚Äôs the maximizing player‚Äôs turn that leads to the next position, then the algorithm picks the maximum score at that level. Otherwise, it picks the minimum score, assuming the opponent will never make mistakes. In the game tree above, the leftmost branch results in an immediate win for the maximizing player, so the connecting edge has the highest weight. Choosing the middle branch could also lead to a victory, but the minimax algorithm pessimistically indicates the worst-case scenario, which is a tie. Finally, the branch on the right almost certainly represents a losing move. Create a new module in the tic-tac-toe library and implement the algorithm using the following sleek Python expression: The function returns the score associated with the move passed as an argument for the indicated maximizing player. If the game has finished, then you calculate the score by performing the static evaluation of the grid. Otherwise, you choose either the maximum or the minimum score, which you find with recursion for all the possible moves at the current position. Note: The placement of the module in your project‚Äôs directory tree is somewhat subjective because it would work equally well when defined elsewhere. However, one could argue that it logically belongs to the game‚Äôs logic layer since it only depends on the domain model. As long as you made an editable install of the tic-tac-toe library in your virtual environment, you‚Äôll be able to test your new function in an interactive Python interpreter session: The computed scores correspond to the edge weights in the game tree that you saw before. Finding the best move is only a matter of choosing the one with the highest resulting score. Note that there can sometimes be multiple alternative paths to a winning outcome in the game tree. In the next section, you‚Äôll create another concrete computer player, which will leverage the minimax algorithm, and then you‚Äôll use it in your console front end. The minimax algorithm calculates the score associated with a particular move. To find the best move in a given game state, you can sort all possible moves by score and take the one with the highest value. By doing that, you‚Äôll use AI to create an unbeatable tic-tac-toe player with Python. Go ahead and define the following function in your tic-tac-toe library‚Äôs module: The function takes some game state and returns either the best move for the current player or to indicate that no more moves are possible. Note the use of a partial function to freeze the value of the argument, which doesn‚Äôt change across invocations. This lets you use the function, which expects exactly one argument, as the ordering key. Note: Python‚Äôs is a factory that produces a new function with fewer parameters by prepopulating one or more of the original function‚Äôs arguments with concrete values. Unlike manually defining such a wrapper function when writing code, the factory can do this dynamically at runtime and offers much more concise syntax. Next, add a new computer player in the tic-tac-toe library‚Äôs module. This player will use the helper function that you‚Äôve just created: This computer player will always try to find the best tic-tac-toe move with AI and Python. However, to make the game less predictable and reduce the amount of computation, you can let it pick the first move randomly before running the expensive minimax algorithm. You‚Äôve already implemented the logic for choosing a random move in , defined above. Now, it would help to extract that common logic into a reusable component. Go ahead and modify the code of both the random and minimax computer players: # tic_tac_toe/game/players.py import abc import time from tic_tac_toe.logic.exceptions import InvalidMove from tic_tac_toe.logic.minimax import find_best_move from tic_tac_toe.logic.models import GameState, Mark, Move class Player(metaclass=abc.ABCMeta): ... class ComputerPlayer(Player, metaclass=abc.ABCMeta): ... class RandomComputerPlayer(ComputerPlayer): def get_computer_move(self, game_state: GameState) -> Move | None: class MinimaxComputerPlayer(ComputerPlayer): def get_computer_move(self, game_state: GameState) -> Move | None: You call the method on the game state in both classes. You need to define this new method to choose one of the possible moves using Python‚Äôs module: The final step is to use the new computer player in your front end. Open the module in the console front end project, and import : You add the new player type to the mapping of names and use the minimax computer player as the default opponent of the human player. Okay, you have three kinds of players to choose from now. You can take your console front end for the ultimate test drive by selecting different players to try their chances against each other. For example, you can pick two minimax computer players: In this case, you should expect the game to always end in a tie since both players use the optimal strategy. One thing you may notice when requesting at least one minimax player is rather poor performance, especially at the beginning of the game. That‚Äôs because building the entire game tree, even for a game as relatively basic as tic-tac-toe, is very costly. You‚Äôll explore a few performance optimization possibilities in the Next Steps. Congratulations! You‚Äôve reached the end of this long journey. Don‚Äôt forget about the supporting materials, which contain additional code that wasn‚Äôt covered in the tutorial. The materials include two other front ends and some performance tricks, which make the minimax player make their moves instantly. You can download this code by clicking the link below: Source Code: Click here to download the free source code that you‚Äôll use to build a tic-tac-toe game engine and AI player with Python."
    },
    {
        "link": "https://medium.com/@ma274/tic-tac-toe-game-using-heuristic-alpha-beta-tree-search-algorithm-26b13273bc5b",
        "document": "\n‚Ä¢ This project aims to implement the Heuristic Alpha-Beta Tree Search Algorithm in Tic-Tac-Toe. The algorithm combines heuristic evaluation and alpha-beta pruning to create an intelligent AI opponent for the game. The goal is to showcase the algorithm‚Äôs effectiveness, analyze its performance, and evaluate its strategic decision-making capabilities.\n\n2. Algorithm Description: The Heuristic Alpha-Beta Tree Search Algorithm combines minimax search and pruning techniques. It evaluates game states using heuristics and optimizes the search process by pruning unnecessary branches.\n\n3. Program Design: The program simulates a Tic-Tac-Toe game environment with functions for player moves, AI moves, game state evaluation, and winner determination. It is designed for code reusability, readability, and maintainability.\n\n4. Code Explanations: Key functions include handling moves, evaluating game states, and implementing the algorithm through minimax with alpha-beta pruning.\n\n5. Experimental Results: Experimental results assess the AI opponent‚Äôs performance based on win rate, average moves to win, and game completion time. The algorithm can be tested against different opponents or difficulty levels.\n\n6. Analysis: The analysis interprets results, discusses strengths and weaknesses, compares with other algorithms, and evaluates computational complexity.\n\n7. Recommendations and Future Development: Recommendations include fine-tuning heuristics, exploring enhancements to alpha-beta pruning, and extending the algorithm to other games or environments.\n\nThis project implements the Heuristic Alpha-Beta Tree Search Algorithm for Tic-Tac-Toe. The algorithm combines heuristic evaluation and alpha-beta pruning to create an intelligent AI opponent. It utilizes minimax search and pruning techniques to evaluate game states efficiently. The program includes functions for player and AI moves, game state evaluation, and determining the winner. Experimental results evaluate AI performance, and the analysis discusses strengths, weaknesses, and potential improvements. The project contributes to game theory and AI understanding.\n‚Ä¢ The program follows a modular design with separate functions for different tasks.\n‚Ä¢ The choice of programming language and libraries is not specified.\n\n# Function of each piece of code:\n\nThe first piece of code imports the ‚Äúchoice‚Äù function from the ‚Äúrandom‚Äù library and the ‚Äúinf‚Äù constant from the ‚Äúmath‚Äù library.\n\nThe second piece of code defines the initial state of the Tic-Tac-Toe board. It is represented as a 3x3 nested list where each element represents a cell on the board. The value 0 indicates an empty cell.\n\nThe third piece of code includes two functions related to the game board.\n‚Ä¢ This function takes the current state of the board as input.\n‚Ä¢ It maps the numeric values on the board to their corresponding symbols (‚ÄòX‚Äô, ‚ÄòO‚Äô, or empty space).\n‚Ä¢ It then displays the board on the console, showing the current positions of the players.\n‚Ä¢ This function clears the game board by setting all the cells to 0 (empty).\n‚Ä¢ It iterates through each cell of the board and assigns the value 0 to it.\n‚Ä¢ This function is used to reset the board for a new game or when needed.\n\nThe fourth piece of code includes functions related to checking the game‚Äôs winning condition and printing the game result.\n‚Ä¢ This function takes the game board and a player (-1 for AI, 1 for the player) as input.\n‚Ä¢ It checks all possible winning conditions on the board to determine if the specified player has won.\n‚Ä¢ The function returns True if the player has won and False otherwise.\n‚Ä¢ This function takes the game board as input.\n‚Ä¢ It uses the winningPlayer() function to check if either the player or the AI has won the game.\n‚Ä¢ The function returns True if either player has won and False otherwise.\n‚Ä¢ This function takes the game board as input.\n‚Ä¢ It uses the winningPlayer() function to determine the game‚Äôs result.\n‚Ä¢ If the player has won, it prints ‚ÄúPlayer has won!‚Äù\n‚Ä¢ If the AI has won, it prints ‚ÄúAI has won!‚Äù\n‚Ä¢ If the game is a draw, it prints ‚ÄúThe game is over with the result of Draw.‚Äù\n\nThe fifth piece of code includes functions related to checking the board‚Äôs status and available moves.\n‚Ä¢ This function takes the game board as input.\n‚Ä¢ It iterates through each cell of the board and checks if it is empty (marked with 0).\n‚Ä¢ The function collects the coordinates of empty cells and returns them as a list.\n‚Ä¢ This function takes the game board as input.\n‚Ä¢ It uses the blanks() function to obtain the list of empty positions.\n‚Ä¢ If the length of the list is zero, it means the board is full.\n‚Ä¢ The function returns True if the board is full and False otherwise.\n\nThe sixth piece of code includes functions related to setting moves, evaluating the game state, and defining the heuristic function for the AI.\n‚Ä¢ This function takes the game board, row index (x), column index (y), and player (-1 or 1) as input.\n‚Ä¢ It sets the specified position on the board with the player‚Äôs mark.\n‚Ä¢ This function takes the game board as input.\n‚Ä¢ It checks if either the player or the AI has won the game by calling the winningPlayer(board, player) function.\n‚Ä¢ If the player has won, it returns 1.\n‚Ä¢ If the AI has won, it returns -1.\n‚Ä¢ If the game is a draw, it returns 0.\n‚Ä¢ This function takes the game board as input.\n‚Ä¢ It calls the evaluate(board) function to determine the game state.\n‚Ä¢ The function returns the evaluation value as the heuristic value for the current board state.\n‚Ä¢ It recursively explores the game tree to determine the best move.\n‚Ä¢ The function considers the current game board, depth, alpha, beta, and player.\n‚Ä¢ It checks if the depth limit or a winning condition has been reached.\n‚Ä¢ If so, it returns the best move and its heuristic score.\n‚Ä¢ Otherwise, it initializes the best score based on the player.\n‚Ä¢ The function generates possible moves and evaluates each move‚Äôs score.\n‚Ä¢ It updates the best score and move based on the player‚Äôs turn.\n‚Ä¢ Alpha and beta values are updated for pruning.\n‚Ä¢ Finally, it returns the best move and score found.\n‚Ä¢ The function handles the AI's move when playing as \"O\" (AI player).\n‚Ä¢ If the board is empty, it selects a random position as the first move.\n‚Ä¢ Otherwise, it uses the Alpha-Beta Minimax algorithm to determine the best move.\n‚Ä¢ The function calls the function with appropriate parameters.\n‚Ä¢ It sets the move on the board based on the result obtained.\n‚Ä¢ Finally, it displays the updated game board using the function.\n‚Ä¢ The function handles the AI's move when playing as \"X\" (AI player).\n‚Ä¢ If the board is empty, it selects a random position as the first move.\n‚Ä¢ Otherwise, it uses the Alpha-Beta Minimax algorithm to determine the best move.\n‚Ä¢ The function calls the function with appropriate parameters.\n‚Ä¢ It sets the move on the board based on the result obtained.\n‚Ä¢ Finally, it displays the updated game board using the function.\n‚Ä¢ The function handles a player's move in the game.\n‚Ä¢ It prompts the player to enter a position (1‚Äì9) on the board.\n‚Ä¢ It checks if the input is a valid number within the range.\n‚Ä¢ If the position is valid and not already occupied, it sets the move on the board using the function.\n‚Ä¢ If the position is invalid or already occupied, it displays an appropriate error message.\n‚Ä¢ Finally, it displays the updated game board using the function.\n‚Ä¢ The function represents the player vs. player mode in the game.\n‚Ä¢ It starts by clearing the game board using the function.\n‚Ä¢ It initializes the current player as Player 1.\n‚Ä¢ Inside a loop, it checks if the board is full or if any player has won.\n‚Ä¢ If the current player is Player 1, it prompts for their move and updates the board accordingly.\n‚Ä¢ If the current player is Player 2, it prompts for their move and updates the board accordingly.\n‚Ä¢ After each move, it switches the current player by multiplying it by -1.\n‚Ä¢ Once the loop ends, it displays the game result using the function.\n‚Ä¢ The function represents the AI vs. AI mode in the game.\n‚Ä¢ It starts by clearing the game board using the function.\n‚Ä¢ It initializes the current player as Player 1.\n‚Ä¢ Inside a loop, it checks if the board is full or if any player has won.\n‚Ä¢ If the current player is Player 1, it performs the AI‚Äôs move by calling the function with the appropriate parameters.\n‚Ä¢ If the current player is Player 2, it performs the AI‚Äôs move by calling the function with the appropriate parameters.\n‚Ä¢ After each move, it switches the current player by multiplying it by -1.\n‚Ä¢ Once the loop ends, it displays the game result using the function.\n‚Ä¢ The main driver code begins by displaying a header for the Tic-Tac-Toe game.\n‚Ä¢ It prompts the user to choose a game mode: Player vs. AI or AI vs. AI.\n‚Ä¢ It reads the user‚Äôs input and stores it in the variable.\n‚Ä¢ If the chosen mode is 1 (Player vs. AI), it calls the function to start the game.\n‚Ä¢ If the chosen mode is 2 (AI vs. AI), it calls the function to start the game.\n‚Ä¢ If the chosen mode is neither 1 nor 2, it displays an error message indicating an invalid mode selection.\n‚Ä¢ The program was executed and tested with various scenarios.\n‚Ä¢ The expected outputs of the program are as follows:\n‚Ä¢ For Player vs. AI mode: The program should display the game board and prompt the player and AI to make their moves alternately until the game is won by either the player or the AI, or the game ends in a draw. The program should also display the result of the game.\n‚Ä¢ For AI vs. AI mode: The program should display the game board and simulate the moves made by AI players until the game is won by either AI player or the game ends in a draw. The program should also display the result of the game.\n‚Ä¢ The correctness of the outputs was verified by visually inspecting the displayed game board, ensuring that the moves made by the players and AI were valid and followed the rules of the game. The result of the game was compared with the expected outcome based on the game state.\n‚Ä¢ Performance Analysis: The algorithm used in Tic-Tac-Toe shows good performance and efficient decision-making.\n‚Ä¢ Efficiency Evaluation: The algorithm has a manageable time and space complexity, providing quick responses and requiring moderate memory.\n‚Ä¢ Pros of Practical Use: Strategic decision-making, adaptability to different game rules, and optimal or near-optimal solutions.\n‚Ä¢ Cons of Practical Use: Not suitable for real-time games and high computational cost for large game trees.\n‚Ä¢ The game allows players to play against each other or against an AI opponent.\n‚Ä¢ The code consists of functions for managing the game board, making moves, evaluating game states, and implementing the AI‚Äôs decision-making process.\n‚Ä¢ During testing, the program performed as expected, providing an interactive and challenging gaming experience.\n‚Ä¢ Enhance the user interface with better graphics and user-friendly input methods.\n‚Ä¢ Implement different difficulty levels for the AI opponent.\n‚Ä¢ Optimize the code for better performance and efficiency.\n‚Ä¢ Chat gpt was used as an aid in editing the code and writing the report."
    },
    {
        "link": "https://stackoverflow.com/questions/20872330/how-to-create-an-evaluation-function-for-a-tic-tac-toe-variant-game",
        "document": "I'm actually working on a board game which is a variant of the game. The specifics of the game are the followings :\n\n1. The game is played on a x board, with variable.\n\n2. A player wins if he succeeds in placing alignments the first, is variable.\n\n3. An alignment is constituted of marks (X or O) in a horizontal, vertical or diagonal. is fixed.\n\n4. If the x grid is full (no player can add a mark either X or O) and no player succeeded in placing alignments so the game is drawn.\n\nI'm using an with algorithm. This is my first program with artificial intelligence and I don't know exactly how to create the evaluation function to be used by the algorithm. I saw some examples on the net which use a material weighting to evaluate a position but I can't apply that in my case. Actually, I'm using a radom evaluation function which returns a value between and .\n\nAny idea on how can I evaluate a given board configuration ?"
    },
    {
        "link": "https://geeksforgeeks.org/finding-optimal-move-in-tic-tac-toe-using-minimax-algorithm-in-game-theory",
        "document": "Prerequisites: Minimax Algorithm in Game Theory, Evaluation Function in Game Theory\n\nLet us combine what we have learnt so far about minimax and evaluation function to write a proper Tic-Tac-Toe AI (Artificial Intelligence) that plays a perfect game. This AI will consider all possible scenarios and makes the most optimal move.\n\nWe shall be introducing a new function called findBestMove(). This function evaluates all the available moves using minimax() and then returns the best move the maximizer can make. The pseudocode is as follows :\n\nTo check whether or not the current move is better than the best move we take the help of minimax() function which will consider all the possible ways the game can go and returns the best value for that move, assuming the opponent also plays optimally\n\nThe code for the maximizer and minimizer in the minimax() function is similar to findBestMove(), the only difference is, instead of returning a move, it will return a value. Here is the pseudocode :\n\nTo check whether the game is over and to make sure there are no moves left we use isMovesLeft() function. It is a simple straightforward function which checks whether a move is available or not and returns true or false respectively. Pseudocode is as follows :\n\nOne final step is to make our AI a little bit smarter. Even though the following AI plays perfectly, it might choose to make a move which will result in a slower victory or a faster loss. Lets take an example and explain it.\n\nAssume that there are 2 possible ways for X to win the game from a given board state.\n\nOur evaluation function will return a value of +10 for both moves A and B. Even though the move A is better because it ensures a faster victory, our AI may choose B sometimes. To overcome this problem we subtract the depth value from the evaluated score. This means that in case of a victory it will choose a the victory which takes least number of moves and in case of a loss it will try to prolong the game and play as many moves as possible. So the new evaluated value will be\n‚Ä¢ Move will have a value of +10 ‚Äì 2 = 8\n‚Ä¢ Move will have a value of +10 ‚Äì 4 = 6\n\nNow since move A has a higher score compared to move B our AI will choose move A over move B. The same thing must be applied to the minimizer. Instead of subtracting the depth we add the depth value as the minimizer always tries to get, as negative a value as possible. We can subtract the depth either inside the evaluation function or outside it. Anywhere is fine. I have chosen to do it outside the function. Pseudocode implementation is as follows.\n\nBelow is implementation of above idea.\n\n\"The value of the best Move is : %d\n\n\n\n\" \"The value of the best Move \" \"The value of the best Move is :\" \"The value of the best Move \" // and choose the maximum value \"The value of the best Move \"\n\nThis image depicts all the possible paths that the game can take from the root board state. It is often called the Game Tree.\n\nThe 3 possible scenarios in the above example are :\n‚Ä¢ Left Move : If X plays [2,0]. Then O will play [2,1] and win the game. The value of this move is -10\n‚Ä¢ Middle Move : If X plays [2,1]. Then O will play [2,2] which draws the game. The value of this move is 0\n‚Ä¢ Right Move : If X plays [2,2]. Then he will win the game. The value of this move is +10;\n\nRemember, even though X has a possibility of winning if he plays the middle move, O will never let that happen and will choose to draw instead.\n\nTherefore the best choice for X, is to play [2,2], which will guarantee a victory for him.\n\nWe do encourage our readers to try giving various inputs and understanding why the AI choose to play that move. Minimax may confuse programmers as it thinks several moves in advance and is very hard to debug at times. Remember this implementation of minimax algorithm can be applied any 2 player board game with some minor changes to the board structure and how we iterate through the moves. Also sometimes it is impossible for minimax to compute every possible game state for complex games like Chess. Hence we only compute upto a certain depth and use the evaluation function to calculate the value of the board.\n\nStay tuned for next weeks article where we shall be discussing about Alpha-Beta pruning that can drastically improve the time taken by minimax to traverse a game tree."
    }
]