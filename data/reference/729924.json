[
    {
        "link": "https://json.org",
        "document": ""
    },
    {
        "link": "https://datatracker.ietf.org/doc/html/rfc7159",
        "document": ""
    },
    {
        "link": "https://datatracker.ietf.org/doc/html/rfc8259",
        "document": ""
    },
    {
        "link": "https://ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf",
        "document": ""
    },
    {
        "link": "https://en.wikipedia.org/wiki/JSON",
        "document": "JSON (JavaScript Object Notation, pronounced or ) is an open standard file format and data interchange format that uses human-readable text to store and transmit data objects consisting of name‚Äìvalue pairs and arrays (or other serializable values). It is a commonly used data format with diverse uses in electronic data interchange, including that of web applications with servers.\n\nJSON is a language-independent data format. It was derived from JavaScript, but many modern programming languages include code to generate and parse JSON-format data. JSON filenames use the extension .\n\nDouglas Crockford originally specified the JSON format in the early 2000s.[1] He and Chip Morningstar sent the first JSON message in April 2001.\n\nThe 2017 international standard (ECMA-404 and ISO/IEC 21778:2017) specifies that \"JSON\" is \"pronounced , as in 'Jason and The Argonauts'\".[2][3] The first (2013) edition of ECMA-404 did not address the pronunciation.[4] The UNIX and Linux System Administration Handbook states, \"Douglas Crockford, who named and promoted the JSON format, says it's pronounced like the name Jason. But somehow, 'JAY-sawn'[note 1] seems to have become more common in the technical community.\"[5] Crockford said in 2011, \"There's a lot of argument about how you pronounce that, but I strictly don't care.\"[1]\n\nAfter RFC 4627 had been available as its \"informational\" specification since 2006, JSON was first standardized in 2013, as ECMA-404.[4] RFC 8259, published in 2017, is the current version of the Internet Standard STD 90, and it remains consistent with ECMA-404.[6] That same year, JSON was also standardized as ISO/IEC 21778:2017.[2] The ECMA and ISO/IEC standards describe only the allowed syntax, whereas the RFC covers some security and interoperability considerations.[7]\n\nJSON grew out of a need for a real-time server-to-browser session communication protocol without using browser plugins such as Flash or Java applets, the dominant methods used in the early 2000s.[8]\n\nCrockford first specified and popularized the JSON format.[1] The acronym originated at State Software, a company cofounded by Crockford and others in March 2001. The cofounders agreed to build a system that used standard browser capabilities and provided an abstraction layer for Web developers to create stateful Web applications that had a persistent duplex connection to a Web server by holding two Hypertext Transfer Protocol (HTTP) connections open and recycling them before standard browser time-outs if no further data were exchanged. The cofounders had a round-table discussion and voted on whether to call the data format JSML (JavaScript Markup Language) or JSON (JavaScript Object Notation), as well as under what license type to make it available. The JSON.org[9] website was launched in 2001. In December 2005, Yahoo! began offering some of its Web services in JSON.[10]\n\nA precursor to the JSON libraries was used in a children's digital asset trading game project named Cartoon Orbit at Communities.com [citation needed] which used a browser side plug-in with a proprietary messaging format to manipulate DHTML elements. Upon discovery of early Ajax capabilities, digiGroups, Noosh, and others used frames to pass information into the user browsers' visual field without refreshing a Web application's visual context, realizing real-time rich Web applications using only the standard HTTP, HTML, and JavaScript capabilities of Netscape 4.0.5+ and Internet Explorer 5+. Crockford then found that JavaScript could be used as an object-based messaging format for such a system. The system was sold to Sun Microsystems, Amazon.com, and EDS.\n\nJSON was based on a subset of the JavaScript scripting language (specifically, Standard ECMA-262 3rd Edition‚ÄîDecember 1999[11]) and is commonly used with JavaScript, but it is a language-independent data format. Code for parsing and generating JSON data is readily available in many programming languages. JSON's website lists JSON libraries by language.\n\nIn October 2013, Ecma International published the first edition of its JSON standard ECMA-404.[4] That same year, RFC 7158 used ECMA-404 as a reference. In 2014, RFC 7159 became the main reference for JSON's Internet uses, superseding RFC 4627 and RFC 7158 (but preserving ECMA-262 and ECMA-404 as main references). In November 2017, ISO/IEC JTC 1/SC 22 published ISO/IEC 21778:2017[2] as an international standard. On December 13, 2017, the Internet Engineering Task Force obsoleted RFC 7159 when it published RFC 8259, which is the current version of the Internet Standard STD 90.[12][13]\n\nCrockford added a clause to the JSON license stating, \"The Software shall be used for Good, not Evil\", in order to open-source the JSON libraries while mocking corporate lawyers and those who are overly pedantic. On the other hand, this clause led to license compatibility problems of the JSON license with other open-source licenses since open-source software and free software usually imply no restrictions on the purpose of use.[14]\n\nThe following example shows a possible JSON representation describing a person.\n\nAlthough Crockford originally asserted that JSON is a strict subset of JavaScript and ECMAScript,[15] his specification actually allows valid JSON documents that are not valid JavaScript; JSON allows the Unicode line terminators U+2028 LINE SEPARATOR and U+2029 PARAGRAPH SEPARATOR to appear unescaped in quoted strings, while ECMAScript 2018 and older do not.[16][17] This is a consequence of JSON disallowing only \"control characters\". For maximum portability, these characters are backslash-escaped.\n\nJSON exchange in an open ecosystem must be encoded in UTF-8.[6] The encoding supports the full Unicode character set, including those characters outside the Basic Multilingual Plane (U+0000 to U+FFFF). However, if escaped, those characters must be written using UTF-16 surrogate pairs. For example, to include the Emoji character U+1F610 üòê NEUTRAL FACE in JSON:\n\nJSON became a strict subset of ECMAScript as of the language's 2019 revision.[17][18]\n‚Ä¢ Number: a signed decimal number that may contain a fractional part and may use exponential E notation but cannot include non-numbers such as NaN. The format makes no distinction between integer and floating-point. JavaScript uses IEEE-754 double-precision floating-point format for all its numeric values (later also supporting BigInt 19 ), but other languages implementing JSON may encode numbers differently.\n‚Ä¢ String: a sequence of zero or more Unicode characters. Strings are delimited with double quotation marks and support a backslash escaping syntax.\n‚Ä¢ Boolean: either of the values or\n‚Ä¢ Array: an ordered list of zero or more elements, each of which may be of any type. Arrays use square bracket notation with comma-separated elements.\n‚Ä¢ Object: a collection of name‚Äìvalue pairs where the names (also called keys) are strings. The current ECMA standard states, \"The JSON syntax does not impose any restrictions on the strings used as names, does not require that name strings be unique, and does not assign any significance to the ordering of name/value pairs.\" 20 Objects are delimited with curly brackets and use commas to separate each pair, while within each pair, the colon ':' character separates the key or name from its value.\n‚Ä¢ : an empty value, using the word\n\nWhitespace is allowed and ignored around or between syntactic elements (values and punctuation, but not within a string value). Four specific characters are considered whitespace for this purpose: space, horizontal tab, line feed, and carriage return. In particular, the byte order mark must not be generated by a conforming implementation (though it may be accepted when parsing JSON). JSON does not provide syntax for comments.\n\nEarly versions of JSON (such as specified by RFC 4627) required that a valid JSON text must consist of only an object or an array type, which could contain other types within them. This restriction was dropped in RFC 7158, where a JSON text was redefined as any serialized value.\n\nNumbers in JSON are agnostic with regard to their representation within programming languages. While this allows for numbers of arbitrary precision to be serialized, it may lead to portability issues. For example, since no differentiation is made between integer and floating-point values, some implementations may treat , , and as the same number, while others may not. The JSON standard makes no requirements regarding implementation details such as overflow, underflow, loss of precision, rounding, or signed zeros, but it does recommend expecting no more than IEEE 754 binary64 precision for \"good interoperability\". There is no inherent precision loss in serializing a machine-level binary representation of a floating-point number (like binary64) into a human-readable decimal representation (like numbers in JSON) and back since there exist published algorithms to do this exactly and optimally.[22]\n\nComments were intentionally excluded from JSON. In 2012, Douglas Crockford described his design decision thus: \"I removed comments from JSON because I saw people were using them to hold parsing directives, a practice which would have destroyed interoperability.\"\n\nJSON disallows \"trailing commas\", a comma after the last value inside a data structure.[23] Trailing commas are a common feature of JSON derivatives to improve ease of use.[24]\n\nRFC 8259 describes certain aspects of JSON syntax that, while legal per the specifications, can cause interoperability problems.\n‚Ä¢ Certain JSON implementations only accept JSON texts representing an object or an array. For interoperability, applications interchanging JSON should transmit messages that are objects or arrays.\n‚Ä¢ The specifications allow JSON objects that contain multiple members with the same name. The behavior of implementations processing objects with duplicate names is unpredictable. For interoperability, applications should avoid duplicate names when transmitting JSON objects.\n‚Ä¢ The specifications specifically say that the order of members in JSON objects is not significant. For interoperability, applications should avoid assigning meaning to member ordering even if the parsing software makes that ordering visible.\n‚Ä¢ While the specifications place no limits on the magnitude or precisions of JSON number literals, the widely used JavaScript implementation stores them as IEEE754 \"binary64\" quantities. For interoperability, applications should avoid transmitting numbers that cannot be represented in this way, for example, 1E400 or 3.141592653589793238462643383279.\n‚Ä¢ While the specifications do not constrain the character encoding of the Unicode characters in a JSON text, the vast majority of implementations assume UTF-8 encoding; for interoperability, applications should always and only encode JSON messages in UTF-8.\n‚Ä¢ The specifications do not forbid transmitting byte sequences that incorrectly represent Unicode characters. For interoperability, applications should transmit messages containing no such byte sequences.\n‚Ä¢ The specification does not constrain how applications go about comparing Unicode strings. For interoperability, applications should always perform such comparisons code unit by code unit.\n\nIn 2015, the IETF published RFC 7493, describing the \"I-JSON Message Format\", a restricted profile of JSON that constrains the syntax and processing of JSON to avoid, as much as possible, these interoperability issues.\n\nWhile JSON provides a syntactic framework for data interchange, unambiguous data interchange also requires agreement between producer and consumer on the semantics of specific use of the JSON syntax.[25] One example of where such an agreement is necessary is the serialization of data types that are not part of the JSON standard, for example, dates and regular expressions.\n\nThe official MIME type for JSON text is ,[26] and most modern implementations have adopted this. Legacy MIME types include , , and .[27] The standard filename extension is .json.[28]\n\nJSON Schema specifies a JSON-based format to define the structure of JSON data for validation, documentation, and interaction control. It provides a contract for the JSON data required by a given application and how that data can be modified.[29] JSON Schema is based on the concepts from XML Schema (XSD) but is JSON-based. As in XSD, the same serialization/deserialization tools can be used both for the schema and data, and it is self-describing. It is specified in an Internet Draft at the IETF, with the latest version as of 2024 being \"Draft 2020-12\".[30] There are several validators available for different programming languages,[31] each with varying levels of conformance.\n\nThe JSON standard does not support object references, but an IETF draft standard for JSON-based object references exists.[32]\n\nJSON-RPC is a remote procedure call (RPC) protocol built on JSON, as a replacement for XML-RPC or SOAP. It is a simple protocol that defines only a handful of data types and commands. JSON-RPC lets a system send notifications (information to the server that does not require a response) and multiple calls to the server that can be answered out of order.\n\nAsynchronous JavaScript and JSON (or AJAJ) refers to the same dynamic web page methodology as Ajax, but instead of XML, JSON is the data format. AJAJ is a web development technique that provides for the ability of a web page to request new data after it has loaded into the web browser. Typically, it renders new data from the server in response to user actions on that web page. For example, what the user types into a search box, client-side code then sends to the server, which immediately responds with a drop-down list of matching database items.\n\nJSON has seen ad hoc usage as a configuration language. However, it does not support comments. In 2012, Douglas Crockford, JSON creator, had this to say about comments in JSON when used as a configuration language: \"I know that the lack of comments makes some people sad, but it shouldn't. Suppose you are using JSON to keep configuration files, which you would like to annotate. Go ahead and insert all the comments you like. Then pipe it through JSMin[33] before handing it to your JSON parser.\"\n\nMongoDB uses JSON-like data for its document-oriented database.\n\nSome relational databases, such as PostgreSQL and MySQL, have added support for native JSON data types. This allows developers to store JSON data directly in a relational database without having to convert it to another data format.\n\nJSON being a subset of JavaScript can lead to the misconception that it is safe to pass JSON texts to the JavaScript function. This is not safe, due to certain valid JSON texts, specifically those containing U+2028 LINE SEPARATOR or U+2029 PARAGRAPH SEPARATOR, not being valid JavaScript code until JavaScript specifications were updated in 2019, and so older engines may not support it.[34] To avoid the many pitfalls caused by executing arbitrary code from the Internet, a new function, , was first added to the fifth edition of ECMAScript,[35] which as of 2017 is supported by all major browsers. For non-supported browsers, an API-compatible JavaScript library is provided by Douglas Crockford.[36] In addition, the TC39 proposal \"Subsume JSON\" made ECMAScript a strict JSON superset as of the language's 2019 revision.[17][18] Various JSON parser implementations have suffered from denial-of-service attack and mass assignment vulnerability.[37][38]\n\nJSON is promoted as a low-overhead alternative to XML as both of these formats have widespread support for creation, reading, and decoding in the real-world situations where they are commonly used.[39] Apart from XML, examples could include CSV and supersets of JSON. Google Protocol Buffers can fill this role, although it is not a data interchange language. CBOR has a superset of the JSON data types, but it is not text-based. Ion is also a superset of JSON, with a wider range of primary types, annotations, comments, and allowing trailing commas.[40]\n\nXML has been used to describe structured data and to serialize objects. Various XML-based protocols exist to represent the same kind of data structures as JSON for the same kind of data interchange purposes. Data can be encoded in XML in several ways. The most expansive form using tag pairs results in a much larger (in character count) representation than JSON, but if data is stored in attributes and 'short tag' form where the closing tag is replaced with , the representation is often about the same size as JSON or just a little larger. However, an XML attribute can only have a single value and each attribute can appear at most once on each element.\n\nXML separates \"data\" from \"metadata\" (via the use of elements and attributes), while JSON does not have such a concept.\n\nAnother key difference is the addressing of values. JSON has objects with a simple \"key\" to \"value\" mapping, whereas in XML addressing happens on \"nodes\", which all receive a unique ID via the XML processor. Additionally, the XML standard defines a common attribute , that can be used by the user, to set an ID explicitly.\n\nXML tag names cannot contain any of the characters , nor a space character, and cannot begin with , , or a numeric digit, whereas JSON keys can (even if quotation mark and backslash must be escaped).[41]\n\nXML values are strings of characters, with no built-in type safety. XML has the concept of schema, that permits strong typing, user-defined types, predefined tags, and formal structure, allowing for formal validation of an XML stream. JSON has several types built-in and has a similar schema concept in JSON Schema.\n\nSupport for comments and other features have been deemed useful, which has led to several nonstandard JSON supersets being created. Among them are HJSON,[43] HOCON, and JSON5 (which despite its name, is not the fifth version of JSON).[44][45]\n\nYAML version 1.2 is a superset of JSON; prior versions were not strictly compatible. For example, escaping a slash with a backslash is valid in JSON, but was not valid in YAML.[46] YAML supports comments, while JSON does not.[46][44]\n\nCSON (\"CoffeeScript Object Notation\") uses significant indentation, unquoted keys, and assumes an outer object declaration. It was used for configuring GitHub's Atom text editor.[47][48][49]\n\nThere is also an unrelated project called CSON (\"Cursive Script Object Notation\") that is more syntactically similar to JSON.[50]\n\nHOCON (\"Human-Optimized Config Object Notation\") is a format for human-readable data, and a superset of JSON.[51] The uses of HOCON are:\n‚Ä¢ It is primarily used in conjunction with the Play framework, 52 and is developed by Lightbend.\n‚Ä¢ It is also supported as a configuration format for .NET projects via Akka.NET 53 54 and Puppet. 55\n‚Ä¢ TIBCO Streaming: 56 HOCON is the primary configuration file format for the TIBCO Streaming 57 family of products (StreamBase, LiveView, and Artifact Management Server) as of TIBCO Streaming Release 10. 58\n‚Ä¢ It is also the primary configuration file format for several subsystems of Exabeam Advanced Analytics. 59\n‚Ä¢ Jitsi uses it as the \"new\" config system and .properties-Files as fallback 60 61\n\nJSON5 (\"JSON5 Data Interchange Format\") is an extension of JSON syntax that, just like JSON, is also valid JavaScript syntax. The specification was started in 2012 and finished in 2018 with version 1.0.0.[62] The main differences to JSON syntax are:\n\nJSON5 syntax is supported in some software as an extension of JSON syntax, for instance in SQLite.[63]\n\nJSONC (JSON with Comments) is a subset of JSON5 used in Microsoft's Visual Studio Code:[64]\n‚Ä¢ accepts trailing commas, but they are discouraged and the editor will display a warning\n\nSeveral serialization formats have been built on or from the JSON specification. Examples include\n‚Ä¢ JsonML, a lightweight markup language used to map between XML and JSON 70 71\n‚Ä¢ Amazon Ion ‚Äì a superset of JSON (though limited to UTF-8, like JSON for interchange, unlike general JSON)\n‚Ä¢ jaql ‚Äì a functional data processing and query language most commonly used for JSON query processing"
    },
    {
        "link": "https://docs.python.org/3/library/json.html",
        "document": "JSON (JavaScript Object Notation), specified by RFC 7159 (which obsoletes RFC 4627) and by ECMA-404, is a lightweight data interchange format inspired by JavaScript object literal syntax (although it is not a strict subset of JavaScript ).\n\nexposes an API familiar to users of the standard library and modules.\n\nUsing from the shell to validate and pretty-print:\n\nSerialize obj as a JSON formatted stream to fp (a -supporting file-like object) using this Python-to-JSON conversion table. Unlike and , JSON is not a framed protocol, so trying to serialize multiple objects with repeated calls to using the same fp will result in an invalid JSON file.\n‚Ä¢ None obj (object) ‚Äì The Python object to be serialized.\n‚Ä¢ None fp (file-like object) ‚Äì The file-like object obj will be serialized to. The module always produces objects, not objects, therefore must support input.\n‚Ä¢ None skipkeys (bool) ‚Äì If , keys that are not of a basic type ( , , , , ) will be skipped instead of raising a . Default .\n‚Ä¢ None ensure_ascii (bool) ‚Äì If (the default), the output is guaranteed to have all incoming non-ASCII characters escaped. If , these characters will be outputted as-is.\n‚Ä¢ None check_circular (bool) ‚Äì If , the circular reference check for container types is skipped and a circular reference will result in a (or worse). Default .\n‚Ä¢ None allow_nan (bool) ‚Äì If , serialization of out-of-range values ( , , ) will result in a , in strict compliance with the JSON specification. If (the default), their JavaScript equivalents ( , , ) are used.\n‚Ä¢ None cls (a subclass) ‚Äì If set, a custom JSON encoder with the method overridden, for serializing into custom datatypes. If (the default), is used.\n‚Ä¢ None indent (int | str | None) ‚Äì If a positive integer or string, JSON array elements and object members will be pretty-printed with that indent level. A positive integer indents that many spaces per level; a string (such as ) is used to indent each level. If zero, negative, or (the empty string), only newlines are inserted. If (the default), the most compact representation is used.\n‚Ä¢ None separators (tuple | None) ‚Äì A two-tuple: . If (the default), separators defaults to if indent is , and otherwise. For the most compact JSON, specify to eliminate whitespace.\n‚Ä¢ None default (callable | None) ‚Äì A function that is called for objects that can‚Äôt otherwise be serialized. It should return a JSON encodable version of the object or raise a . If (the default), is raised.\n‚Ä¢ None sort_keys (bool) ‚Äì If , dictionaries will be outputted sorted by key. Default . Changed in version 3.2: Allow strings for indent in addition to integers. Changed in version 3.4: Use as default if indent is not . Changed in version 3.6: All optional parameters are now keyword-only. Serialize obj to a JSON formatted using this conversion table. The arguments have the same meaning as in . Keys in key/value pairs of JSON are always of the type . When a dictionary is converted into JSON, all the keys of the dictionary are coerced to strings. As a result of this, if a dictionary is converted into JSON and then back into a dictionary, the dictionary may not equal the original one. That is, if x has non-string keys. Deserialize fp to a Python object using the JSON-to-Python conversion table.\n‚Ä¢ None fp (file-like object) ‚Äì A -supporting text file or binary file containing the JSON document to be deserialized.\n‚Ä¢ None cls (a subclass) ‚Äì If set, a custom JSON decoder. Additional keyword arguments to will be passed to the constructor of cls. If (the default), is used.\n‚Ä¢ None object_hook (callable | None) ‚Äì If set, a function that is called with the result of any object literal decoded (a ). The return value of this function will be used instead of the . This feature can be used to implement custom decoders, for example JSON-RPC class hinting. Default .\n‚Ä¢ None object_pairs_hook (callable | None) ‚Äì If set, a function that is called with the result of any object literal decoded with an ordered list of pairs. The return value of this function will be used instead of the . This feature can be used to implement custom decoders. If object_hook is also set, object_pairs_hook takes priority. Default .\n‚Ä¢ None parse_float (callable | None) ‚Äì If set, a function that is called with the string of every JSON float to be decoded. If (the default), it is equivalent to . This can be used to parse JSON floats into custom datatypes, for example .\n‚Ä¢ None parse_int (callable | None) ‚Äì If set, a function that is called with the string of every JSON int to be decoded. If (the default), it is equivalent to . This can be used to parse JSON integers into custom datatypes, for example .\n‚Ä¢ None parse_constant (callable | None) ‚Äì If set, a function that is called with one of the following strings: , , or . This can be used to raise an exception if invalid JSON numbers are encountered. Default .\n‚Ä¢ None JSONDecodeError ‚Äì When the data being deserialized is not a valid JSON document.\n‚Ä¢ None UnicodeDecodeError ‚Äì When the data being deserialized does not contain UTF-8, UTF-16 or UTF-32 encoded data.\n‚Ä¢ None All optional parameters are now keyword-only.\n‚Ä¢ None fp can now be a binary file. The input encoding should be UTF-8, UTF-16 or UTF-32. Changed in version 3.11: The default parse_int of now limits the maximum length of the integer string via the interpreter‚Äôs integer string conversion length limitation to help avoid denial of service attacks. Identical to , but instead of a file-like object, deserialize s (a , or instance containing a JSON document) to a Python object using this conversion table. Changed in version 3.6: s can now be of type or . The input encoding should be UTF-8, UTF-16 or UTF-32. Changed in version 3.9: The keyword argument encoding has been removed.\n\nPerforms the following translations in decoding by default: It also understands , , and as their corresponding values, which is outside the JSON spec. object_hook is an optional function that will be called with the result of every JSON object decoded and its return value will be used in place of the given . This can be used to provide custom deserializations (e.g. to support JSON-RPC class hinting). object_pairs_hook is an optional function that will be called with the result of every JSON object decoded with an ordered list of pairs. The return value of object_pairs_hook will be used instead of the . This feature can be used to implement custom decoders. If object_hook is also defined, the object_pairs_hook takes priority. parse_float is an optional function that will be called with the string of every JSON float to be decoded. By default, this is equivalent to . This can be used to use another datatype or parser for JSON floats (e.g. ). parse_int is an optional function that will be called with the string of every JSON int to be decoded. By default, this is equivalent to . This can be used to use another datatype or parser for JSON integers (e.g. ). parse_constant is an optional function that will be called with one of the following strings: , , . This can be used to raise an exception if invalid JSON numbers are encountered. If strict is false ( is the default), then control characters will be allowed inside strings. Control characters in this context are those with character codes in the 0‚Äì31 range, including (tab), , and . If the data being deserialized is not a valid JSON document, a will be raised. Changed in version 3.6: All parameters are now keyword-only. Return the Python representation of s (a instance containing a JSON document). will be raised if the given JSON document is not valid. Decode a JSON document from s (a beginning with a JSON document) and return a 2-tuple of the Python representation and the index in s where the document ended. This can be used to decode a JSON document from a string that may have extraneous data at the end. Supports the following objects and types by default: Changed in version 3.4: Added support for int- and float-derived Enum classes. To extend this to recognize other objects, subclass and implement a method with another method that returns a serializable object for if possible, otherwise it should call the superclass implementation (to raise ). If skipkeys is false (the default), a will be raised when trying to encode keys that are not , , or . If skipkeys is true, such items are simply skipped. If ensure_ascii is true (the default), the output is guaranteed to have all incoming non-ASCII characters escaped. If ensure_ascii is false, these characters will be output as-is. If check_circular is true (the default), then lists, dicts, and custom encoded objects will be checked for circular references during encoding to prevent an infinite recursion (which would cause a ). Otherwise, no such check takes place. If allow_nan is true (the default), then , , and will be encoded as such. This behavior is not JSON specification compliant, but is consistent with most JavaScript based encoders and decoders. Otherwise, it will be a to encode such floats. If sort_keys is true (default: ), then the output of dictionaries will be sorted by key; this is useful for regression tests to ensure that JSON serializations can be compared on a day-to-day basis. If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level. An indent level of 0, negative, or will only insert newlines. (the default) selects the most compact representation. Using a positive integer indent indents that many spaces per level. If indent is a string (such as ), that string is used to indent each level. Changed in version 3.2: Allow strings for indent in addition to integers. If specified, separators should be an tuple. The default is if indent is and otherwise. To get the most compact JSON representation, you should specify to eliminate whitespace. Changed in version 3.4: Use as default if indent is not . If specified, default should be a function that gets called for objects that can‚Äôt otherwise be serialized. It should return a JSON encodable version of the object or raise a . If not specified, is raised. Changed in version 3.6: All parameters are now keyword-only. Implement this method in a subclass such that it returns a serializable object for o, or calls the base implementation (to raise a ). For example, to support arbitrary iterators, you could implement like this: # Let the base class default method raise the TypeError Return a JSON string representation of a Python data structure, o. For example: Encode the given object, o, and yield each string representation as available. For example:\n\nThe JSON format is specified by RFC 7159 and by ECMA-404. This section details this module‚Äôs level of compliance with the RFC. For simplicity, and subclasses, and parameters other than those explicitly mentioned, are not considered. This module does not comply with the RFC in a strict fashion, implementing some extensions that are valid JavaScript but not valid JSON. In particular:\n‚Ä¢ None Infinite and NaN number values are accepted and output;\n‚Ä¢ None Repeated names within an object are accepted, and only the value of the last name-value pair is used. Since the RFC permits RFC-compliant parsers to accept input texts that are not RFC-compliant, this module‚Äôs deserializer is technically RFC-compliant under default settings. The RFC requires that JSON be represented using either UTF-8, UTF-16, or UTF-32, with UTF-8 being the recommended default for maximum interoperability. As permitted, though not required, by the RFC, this module‚Äôs serializer sets ensure_ascii=True by default, thus escaping the output so that the resulting strings only contain ASCII characters. Other than the ensure_ascii parameter, this module is defined strictly in terms of conversion between Python objects and , and thus does not otherwise directly address the issue of character encodings. The RFC prohibits adding a byte order mark (BOM) to the start of a JSON text, and this module‚Äôs serializer does not add a BOM to its output. The RFC permits, but does not require, JSON deserializers to ignore an initial BOM in their input. This module‚Äôs deserializer raises a when an initial BOM is present. The RFC does not explicitly forbid JSON strings which contain byte sequences that don‚Äôt correspond to valid Unicode characters (e.g. unpaired UTF-16 surrogates), but it does note that they may cause interoperability problems. By default, this module accepts and outputs (when present in the original ) code points for such sequences. The RFC does not permit the representation of infinite or NaN number values. Despite that, by default, this module accepts and outputs , , and as if they were valid JSON number literal values: # Neither of these calls raises an exception, but the results are not valid JSON In the serializer, the allow_nan parameter can be used to alter this behavior. In the deserializer, the parse_constant parameter can be used to alter this behavior. The RFC specifies that the names within a JSON object should be unique, but does not mandate how repeated names in JSON objects should be handled. By default, this module does not raise an exception; instead, it ignores all but the last name-value pair for a given name: The object_pairs_hook parameter can be used to alter this behavior. The old version of JSON specified by the obsolete RFC 4627 required that the top-level value of a JSON text must be either a JSON object or array (Python or ), and could not be a JSON null, boolean, number, or string value. RFC 7159 removed that restriction, and this module does not and has never implemented that restriction in either its serializer or its deserializer. Regardless, for maximum interoperability, you may wish to voluntarily adhere to the restriction yourself. Some JSON deserializer implementations may set limits on:\n‚Ä¢ None the maximum level of nesting of JSON objects and arrays\n‚Ä¢ None the range and precision of JSON numbers\n‚Ä¢ None the content and maximum length of JSON strings This module does not impose any such limits beyond those of the relevant Python datatypes themselves or the Python interpreter itself. When serializing to JSON, beware any such limitations in applications that may consume your JSON. In particular, it is common for JSON numbers to be deserialized into IEEE 754 double precision numbers and thus subject to that representation‚Äôs range and precision limitations. This is especially relevant when serializing Python values of extremely large magnitude, or when serializing instances of ‚Äúexotic‚Äù numerical types such as .\n\nThe module provides a simple command line interface to validate and pretty-print JSON objects. If the optional and arguments are not specified, and will be used respectively: Changed in version 3.5: The output is now in the same order as the input. Use the option to sort the output of dictionaries alphabetically by key. The JSON file to be validated or pretty-printed: python -m json.tool mp_films.json \"title\": \"And Now for Something Completely Different\", If infile is not specified, read from . Write the output of the infile to the given outfile. Otherwise, write it to . Sort the output of dictionaries alphabetically by key. Disable escaping of non-ascii characters, see for more information."
    },
    {
        "link": "https://realpython.com/python-json",
        "document": "Python‚Äôs module provides you with the tools you need to effectively handle JSON data. You can convert Python data types to a JSON-formatted string with or write them to files using . Similarly, you can read JSON data from files with and parse JSON strings with .\n\nJSON, or JavaScript Object Notation, is a widely-used text-based format for data interchange. Its syntax resembles Python dictionaries but with some differences, such as using only double quotes for strings and lowercase for Boolean values. With built-in tools for validating syntax and manipulating JSON files, Python makes it straightforward to work with JSON data.\n\nBy the end of this tutorial, you‚Äôll understand that:\n‚Ä¢ JSON in Python is handled using the standard-library module, which allows for data interchange between JSON and Python data types.\n‚Ä¢ JSON is a good data format to use with Python as it‚Äôs human-readable and straightforward to serialize and deserialize, which makes it ideal for use in APIs and data storage.\n‚Ä¢ You write JSON with Python using to serialize data to a file.\n‚Ä¢ You can minify and prettify JSON using Python‚Äôs module.\n\nSince its introduction, JSON has rapidly emerged as the predominant standard for the exchange of information. Whether you want to transfer data with an API or store information in a document database, it‚Äôs likely you‚Äôll encounter JSON. Fortunately, Python provides robust tools to facilitate this process and help you manage JSON data efficiently.\n\nWhile JSON is the most common format for data distribution, it‚Äôs not the only option for such tasks. Both XML and YAML serve similar purposes. If you‚Äôre interested in how the formats differ, then you can check out the tutorial on how to serialize your data with Python.\n\nThe acronym JSON stands for JavaScript Object Notation. As the name suggests, JSON originated from JavaScript. However, JSON has transcended its origins to become language-agnostic and is now recognized as the standard for data interchange. The popularity of JSON can be attributed to native support by the JavaScript language, resulting in excellent parsing performance in web browsers. On top of that, JSON‚Äôs straightforward syntax allows both humans and computers to read and write JSON data effortlessly. To get a first impression of JSON, have a look at this example code: You‚Äôll learn more about the JSON syntax later in this tutorial. For now, recognize that the JSON format is text-based. In other words, you can create JSON files using the code editor of your choice. Once you set the file extension to , most code editors display your JSON data with syntax highlighting out of the box: The screenshot above shows how VS Code displays JSON data using the Bearded color theme. You‚Äôll have a closer look at the syntax of the JSON format next! In the previous section, you got a first impression of how JSON data looks. And as a Python developer, the JSON structure probably reminds you of common Python data structures, like a dictionary that contains a string as a key and a value. If you understand the syntax of a dictionary in Python, you already know the general syntax of a JSON object. Note: Later in this tutorial, you‚Äôll learn that you‚Äôre free to use lists and other data types at the top level of a JSON document. The similarity between Python dictionaries and JSON objects is no surprise. One idea behind establishing JSON as the go-to data interchange format was to make working with JSON as convenient as possible, independently of which programming language you use: [A collection of key-value pairs and arrays] are universal data structures. Virtually all modern programming languages support them in one form or another. It makes sense that a data format that is interchangeable with programming languages is also based on these structures. (Source) To explore the JSON syntax further, create a new file named and add a more complex JSON structure as the content of the file: In the code above, you see data about a dog named Frieda, which is formatted as JSON. The top-level value is a JSON object. Just like Python dictionaries, you wrap JSON objects inside curly braces ( ). In line 1, you start the JSON object with an opening curly brace ( ), and then you close the object at the end of line 20 with a closing curly brace ( ). Note: Although whitespace doesn‚Äôt matter in JSON, it‚Äôs customary for JSON documents to be formatted with two or four spaces to indicate indentation. If the file size of the JSON document is important, then you may consider minifying the JSON file by removing the whitespace. You‚Äôll learn more about minifying JSON data later in the tutorial. Inside the JSON object, you can define zero, one, or more key-value pairs. If you add multiple key-value pairs, then you must separate them with a comma ( ). A key-value pair in a JSON object is separated by a colon ( ). On the left side of the colon, you define a key. A key is a string you must wrap in double quotes ( ). Unlike Python, JSON strings don‚Äôt support single quotes ( ). The values in a JSON document are limited to the following data types: Either or without quotes Just like in dictionaries and lists, you‚Äôre able to nest data in JSON objects and arrays. For example, you can include an object as the value of an object. Also, you‚Äôre free to use any other allowed value as an item in a JSON array. As a Python developer, you may need to pay extra attention to the Boolean values. Instead of using or in title case, you must use the lowercase JavaScript-style Booleans or . Unfortunately, there are some other details in the JSON syntax that you may stumble over as a developer. You‚Äôll have a look at them next. The JSON standard doesn‚Äôt allow any comments, trailing commas, or single quotes for strings. This can be confusing to developers who are used to Python dictionaries or JavaScript objects. Here‚Äôs a smaller version of the JSON file from before with invalid syntax:\n‚Ä¢ Line 5 has a trailing comma after the final key-value pair.\n‚Ä¢ Line 10 contains a trailing comma in the array. Using double quotes is something you can get used to as a Python developer. Comments can be helpful in explaining your code, and trailing commas can make moving lines around in your code less fragile. This is why some developers like to use Human JSON (Hjson) or JSON with comments (JSONC). Hjson gives you the freedom to use comments, ditch commas between properties, or create quoteless strings. Apart from the curly braces ( ), the Hjson syntax look like a mix of YAML and JSON. JSONC is a bit stricter than Hjson. Compared to regular JSON, JSONC allows you to use comments and trailing commas. You may have encountered JSONC when editing the file of VS Code. Inside its configuration files, VS Code works in a JSONC mode. For common JSON files, VS Code is more strict and points out JSON syntax errors. If you want to make sure you write valid JSON, then your coding editor can be of great help. The invalid JSON document above contains marks for each occurrence of incorrect JSON syntax: When you don‚Äôt want to rely on your code editor, you can also use online tools to verify that the JSON syntax you write is correct. Popular online tools for validating JSON are JSON Lint and JSON Formatter. Later in the tutorial, you‚Äôll learn how to validate JSON documents from the comfort of your terminal. But before that, it‚Äôs time to find out how you can work with JSON data in Python.\n\nPython supports the JSON format through the built-in module named . The module is specifically designed for reading and writing strings formatted as JSON. That means you can conveniently convert Python data types into JSON data and the other way around. The act of converting data into the JSON format is referred to as serialization. This process involves transforming data into a series of bytes for storage or transmission over a network. The opposite process, deserialization, involves decoding data from the JSON format back into a usable form within Python. You‚Äôll start with the serialization of Python code into JSON data with the help of the module. One of the most common actions when working with JSON in Python is to convert a Python dictionary into a JSON object. To get an impression of how this works, hop over to your Python REPL and follow along with the code below: After importing the module, you can use to convert a Python dictionary to a JSON-formatted string, which represents a JSON object. It‚Äôs important to understand that when you use , you get a Python string in return. In other words, you don‚Äôt create any kind of JSON data type. The result is similar to what you‚Äôd get if you used Python‚Äôs built-in function: Using gets more interesting when your Python dictionary doesn‚Äôt contain strings as keys or when values don‚Äôt directly translate to a JSON format: In the dictionary, the keys , , and are numbers. Once you use , the dictionary keys become strings in the JSON-formatted string. Note: When you convert a dictionary to JSON, the dictionary keys will always be strings in JSON. The Boolean Python values of your dictionary become JSON Booleans. As mentioned before, the tiny but significant difference between JSON Booleans and Python Booleans is that JSON Booleans are lowercase. The cool thing about Python‚Äôs module is that it takes care of the conversion for you. This can come in handy when you‚Äôre using variables as dictionary keys: When converting Python data types into JSON, the module receives the evaluated values. While doing so, sticks tightly to the JSON standard. For example, when converting integer keys like to the string . The module allows you to convert common Python data types to JSON. Here‚Äôs an overview of all Python data types and values that you can convert to JSON values: Note that different Python data types like lists and tuples serialize to the same JSON data type. This can cause problems when you convert JSON data back to Python, as the data type may not be the same as before. You‚Äôll explore this pitfall later in this tutorial when you learn how to read JSON. Dictionaries are probably the most common Python data type that you‚Äôll use as a top-level value in JSON. But you can convert the data types listed above just as smoothly as dictionaries using . Take a Boolean or a list, for example: A JSON document may contain a single scalar value, like a number, at the top level. That‚Äôs still valid JSON. But more often than not, you want to work with a collection of key-value pairs. Similar to how not every data type can be used as a dictionary key in Python, not all keys can be converted into JSON key strings: You can‚Äôt use dictionaries, lists, or tuples as JSON keys. For dictionaries and lists, this rule makes sense as they‚Äôre not hashable. But even when a tuple is hashable and allowed as a key in a dictionary, you‚Äôll get a when you try to use a tuple as a JSON key: : keys must be str, int, float, bool or None, not tuple By providing the argument, you can prevent getting a when creating JSON data with unsupported Python keys: When you set in to , then Python skips the keys that are not supported and would otherwise raise a . The result is a JSON-formatted string that only contains a subset of the input dictionary. In practice, you usually want your JSON data to resemble the input object as close as possible. So, you must use with caution to not lose information when calling . Note: If you‚Äôre ever in a situation where you need to convert an unsupported object into JSON, then you can consider creating a subclass of the and implementing a method. When you use , you can use additional arguments to control the look of the resulting JSON-formatted string. For example, you can sort the dictionary keys by setting the parameter to : When you set to , then Python sorts the keys alphabetically for you when serializing a dictionary. Sorting the keys of a JSON object can come in handy when your dictionary keys formerly represented the column names of a database, and you want to display them in an organized fashion to the user. Another notable parameter of is , which you‚Äôll probably use the most when serializing JSON data. You‚Äôll explore later in this tutorial in the prettify JSON section. When you convert Python data types into the JSON format, you usually have a goal in mind. Most commonly, you‚Äôll use JSON to persist and exchange data. To do so, you need to save your JSON data outside of your running Python program. Conveniently, you‚Äôll explore saving JSON data to a file next. The JSON format can come in handy when you want to save data outside of your Python program. Instead of spinning up a database, you may decide to use a JSON file to store data for your workflows. Again, Python has got you covered. To write Python data into an external JSON file, you use . This is a similar function to the one you saw earlier, but without the s at the end of its name: In lines 3 to 22, you define a dictionary that you write to a JSON file in line 25 using a context manager. To properly indicate that the file contains JSON data, you set the file extension to . When you use , then it‚Äôs good practice to define the encoding. For JSON, you commonly want to use as the encoding when reading and writing files: The RFC requires that JSON be represented using either UTF-8, UTF-16, or UTF-32, with UTF-8 being the recommended default for maximum interoperability. (Source) The function has two required arguments:\n‚Ä¢ The object you want to write\n‚Ä¢ The file you want to write into Other than that, there are a bunch of optional parameters for . The optional parameters of are the same as for . You‚Äôll investigate some of them later in this tutorial when you prettify and minify JSON files.\n\nIn the former sections, you learned how to serialize Python data into JSON-formatted strings and JSON files. Now, you‚Äôll see what happens when you load JSON data back into your Python program. In parallel to and , the library provides two functions to deserialize JSON data into a Python object: As a rule of thumb, you work with when your data is already present in your Python program. You use with external files that are saved on your disk. The conversion from JSON data types and values to Python follows a similar mapping as before when you converted Python objects into the JSON format: When you compare this table to the one in the previous section, you may recognize that Python offers a matching data type for all JSON types. That‚Äôs very convenient because this way, you can be sure you won‚Äôt lose any information when deserializing JSON data to Python. Note: Deserialization is not the exact reverse of the serialization process. The reason for this is that JSON keys are always strings, and not all Python data types can be converted to JSON data types. This discrepancy means that certain Python objects may not retain their original type when serialized and then deserialized. To get a better feeling for the conversion of data types, you‚Äôll start with serializing a Python object to JSON and then convert the JSON data back to Python. That way, you can spot differences between the Python object you serialize and the Python object you end up with after deserializing the JSON data. To investigate how to load a Python dictionary from a JSON object, revisit the example from before. Start by creating a dictionary and then serialize the Python dictionary to a JSON string using : By passing into , you‚Äôre creating a string with a JSON object that you save in . If you want to convert back to a Python dictionary, then you can use : By using , you can convert JSON data back into Python objects. With the knowledge about JSON that you‚Äôve gained so far, you may already suspect that the content of the dictionary is not identical to the content of : The difference between and is subtle but can be impactful in your Python programs. In JSON, the keys must always be strings. When you converted to using , the integer key became the string . When you used , there was no way for Python to know that the string key should be an integer again. That‚Äôs why your dictionary key remained a string after deserialization. You‚Äôll investigate a similar behavior by doing another conversion roundtrip with other Python data types! To explore how different data types behave in a roundtrip from Python to JSON and back, take a portion of the dictionary from a former section. Note how the dictionary contains different data types as values: The dictionary contains a bunch of common Python data types as values. For example, a string in line 2, a Boolean in line 3, a in line 7, and a tuple in line 8, just to name a few. Next, convert to a JSON-formatted string and back to Python again. Afterward, have a look at the newly created dictionary: You can convert every JSON data type perfectly into a matching Python data type. The JSON Boolean deserializes into , converts back into , and objects and arrays become dictionaries and lists. Still, there‚Äôs one exception that you may encounter in roundtrips: When you serialize a Python tuple, it becomes a JSON array. When you load JSON, a JSON array correctly deserializes into a list because Python has no way of knowing that you want the array to be a tuple. Problems like the one described above can always be an issue when you‚Äôre doing data roundtrips. When the roundtrip happens in the same program, you may be more aware of the expected data types. Data type conversions may be even more obfuscated when you‚Äôre dealing with external JSON files that originated in another program. You‚Äôll investigate a situation like this next! In a previous section, you created a file that saved a file. If you need to refresh your memory, you can expand the collapsible section below that shows the code again: Take a look at the data types of the dictionary. Is there a data type in a value that the JSON format doesn‚Äôt support? When you want to write content to a JSON file, you use . The counterpart to is . As the name suggests, you can use to load a JSON file into your Python program. Jump back into the Python REPL and load the JSON file from before: Just like when writing files, it‚Äôs a good idea to use a context manager when reading a file in Python. That way, you don‚Äôt need to bother with closing the file again. When you want to read a JSON file, then you use inside the statement‚Äôs block. The argument for the function must be either a text file or a binary file. The Python object that you get from depends on the top-level data type of your JSON file. In this case, the JSON file contains an object at the top level, which deserializes into a dictionary. When you deserialize a JSON file as a Python object, then you can interact with it natively‚Äîfor example, by accessing the value of the key with square bracket notation ( ). Still, there‚Äôs a word of caution here. Import the original dictionary from before and compare it to : When you load a JSON file as a Python object, then any JSON data type happily deserializes into Python. That‚Äôs because Python knows about all data types that the JSON format supports. Unfortunately, it‚Äôs not the same the other way around. As you learned before, there are Python data types like that you can convert into JSON, but you‚Äôll end up with an data type in the JSON file. Once you convert the JSON data back to Python, then an array deserializes into the Python data type. Generally, being cautious about data type conversions should be the concern of the Python program that writes the JSON. With the knowledge you have about JSON files, you can always anticipate which Python data types you‚Äôll end up with as long as the JSON file is valid. If you use , then the content of the file you load must contain valid JSON syntax. Otherwise, you‚Äôll receive a . Luckily, Python caters to you with more tools you can use to interact with JSON. For example, it allows you to check a JSON file‚Äôs validity from the convenience of the terminal.\n\nSo far, you‚Äôve explored the JSON syntax and have already spotted some common JSON pitfalls like trailing commas and single quotes for strings. When writing JSON, you may have also spotted some annoying details. For example, neatly indented Python dictionaries end up being a blob of JSON data. In the last section of this tutorial, you‚Äôll try out some techniques to make your life easier as you work with JSON data in Python. To start, you‚Äôll give your JSON object a well-deserved glow-up. One huge advantage of the JSON format is that JSON data is human-readable. Even more so, JSON data is human-writable. This means you can open a JSON file in your favorite text editor and change the content to your liking. Well, that‚Äôs the idea, at least! Editing JSON data by hand is not particularly easy when your JSON data looks like this in the text editor: Even with word wrapping and syntax highlighting turned on, JSON data is hard to read when it‚Äôs a single line of code. And as a Python developer, you probably miss some whitespace. But worry not, Python has got you covered! When you call or to serialize a Python object, then you can provide the argument. Start by trying out with different indentation levels: The default value for is . When you call without or with as a value, you‚Äôll end up with one line of a compact JSON-formatted string. If you want linebreaks in your JSON string, then you can set to or provide an empty string. Although probably less useful, you can even provide a negative number as the indentation or any other string. More commonly, you‚Äôll provide values like or for : When you use positive integers as the value for when calling , then you‚Äôll indent every level of the JSON object with the given count as spaces. Also, you‚Äôll have newlines for each key-value pair. Note: To actually see the whitespace in the REPL, you can wrap the calls in function calls. The parameter works exactly the same for as it does for . Go ahead and write the dictionary into a JSON file with an indentation of spaces: When you set the indentation level when serializing JSON data, then you end up with prettified JSON data. Have a look at how the file looks in your editor: Python can work with JSON files no matter how they‚Äôre indented. As a human, you probably prefer a JSON file that contains newlines and is neatly indented. A JSON file that looks like this is way more convenient to edit. The convenience of being able to edit JSON data in the editor comes with a risk. When you move key-value pairs around or add strings with one quote instead of two, you end up with an invalid JSON. To swiftly check if a JSON file is valid, you can leverage Python‚Äôs . You can run the module as an executable in the terminal using the switch. To see in action, also provide as the positional argument: When you run only with an option, then Python validates the JSON file and outputs the JSON file‚Äôs content in the terminal if the JSON is valid. Running in the example above means that contains valid JSON syntax. Note: The prints the JSON data with an indentation of 4 by default. You‚Äôll explore this behavior in the next section. To make complain, you need to invalidate your JSON document. You can make the JSON data of invalid by removing the comma ( ) between the key-value pairs: After saving , run again to validate the file: The module successfully stumbles over the missing comma in . Python notices that there‚Äôs a delimiter missing once the property name enclosed in double quotes starts in line 3 at position 5. Go ahead and try fixing the JSON file again. You can also be creative with invalidating and check how reports your error. But keep in mind that only reports the first error. So you may need to go back and forth between fixing a JSON file and running . Once is valid, you may notice that the output always looks the same. Of course, like any well-made command-line interface, offers you some options to control the program. In the previous section, you used to validate a JSON file. When the JSON syntax was valid, showed the content with newlines and an indentation of four spaces. To control how prints the JSON, you can set the option. If you followed along with the tutorial, then you‚Äôve got a file that doesn‚Äôt contain newlines or indentation. Alternatively, you can download in the materials by clicking the link below: Free Bonus: Click here to download the free sample code that shows you how to work with JSON data in Python. When you pass in to , then you can pretty print the content of the JSON file in your terminal. When you set , then you can control which indentation level uses to display the code: Seeing the prettified JSON data in the terminal is nifty. But you can step up your game even more by providing another option to the run! By default, writes the output to , just like you commonly do when calling the function. But you can also redirect the output of into a file by providing a positional argument: With as the value of the option, you write the output into the JSON file instead of showing the content in the terminal. If the file doesn‚Äôt exist yet, then Python creates the file on the way. If the target file already exists, then you overwrite the file with the new content. Note: You can prettify a JSON file in place by using the same file as and arguments. You can verify that the file exists by running the terminal command: The whitespace you added to comes with a price. Compared to the original, unindented file, the file size of is now around double that. Here, the 308-byte increase may not be significant. But when you‚Äôre dealing with big JSON data, then a good-looking JSON file will take up quite a bit of space. Having a small data footprint is especially useful when serving data over the web. Since the JSON format is the de facto standard for exchanging data over the web, it‚Äôs worth keeping the file size as small as possible. And again, Python‚Äôs has got your back! As you know by now, Python is a great helper when working with JSON. You can minify JSON data with Python in two ways:\n‚Ä¢ Use the module in your Python code Before, you used with the option to add whitespace. Instead of using here, you can use provide to do the opposite and remove any whitespace between the key-value pairs of your JSON: After calling the module, you provide a JSON file as the and another JSON file as the . If the target JSON file exists, then you overwrite its contents. Otherwise, you create a new file with the filename you provide. Just like with , you provide the same file as a source and target file to minify the file in-place. In the example above, you minify into . Run the command to see how many bytes you squeezed out of the original JSON file: Compared to , the file size of is 337 bytes smaller. That‚Äôs even 29 bytes less than the original file that didn‚Äôt contain any indentation. To investigate where Python managed to remove even more whitespace from the original JSON, open the Python REPL again and minify the content of the original file with Python‚Äôs module: In the code above, you use Python‚Äôs to get the content of as text. Then, you use to deserialize to , which is a Python dictionary. You could use to get a Python dictionary right away, but you need the JSON data as a string first to compare it properly. That‚Äôs also why you use to create and then use instead of leveraging directly to save the minified JSON data in . As you learned before, needs JSON data as the first argument and then accepts a value for the indentation. The default value for is , so you could skip setting the argument explicitly like you do above. But with , you‚Äôre making your intention clear that you don‚Äôt want any indentation, which will be a good thing for others who read your code later. The parameter for allows you to define a tuple with two values:\n‚Ä¢ The separator between the key-value pairs or list items. By default, this separator is a comma followed by a space ( ).\n‚Ä¢ The separator between the key and the value. By default, this separator is a colon followed by a space ( ). By setting to , you continue to use valid JSON separators. But you tell Python not to add any spaces after the comma ( ) and the colon ( ). That means that the only whitespace left in your JSON data can be whitespace appearing in key names and values. That‚Äôs pretty tight! With both and containing your JSON strings, it‚Äôs time to compare them: You can already spot the difference between and when you look at the output. You then use the function to verify that the size of is indeed smaller. If you‚Äôre curious about why the length of the JSON strings almost exactly matches the file size of the written files, then looking into Unicode & character encodings in Python is a great idea. Both and are excellent helpers when you want to make JSON data look prettier, or if you want to minify JSON data to save some bytes. With the module, you can conveniently interact with JSON data in your Python programs. That‚Äôs great when you need to have more control over the way you interact with JSON. The module comes in handy when you want to work with JSON data directly in your terminal."
    },
    {
        "link": "https://zyte.com/blog/json-parsing-with-python",
        "document": "JSON (JavaScript Object Notation) is a text-based data format used for exchanging and storing data between web applications. It simplifies the data transmission process between different programming languages and platforms.\n\nThe has become increasingly popular in recent years. It‚Äôs a simple and flexible way of representing data that can be easily understood and parsed by both humans and machines. JSON consists of key-value pairs enclosed in curly braces, separated by a colon.\n\nPython provides various and manipulating JSON data, making it a popular choice for data analysts, web developers, and data scientists.\n\nIn this guide, we‚Äôll explore the syntax and data types of JSON, as well as the Python libraries and methods used for parsing JSON data, including more advanced options like JMESPath and ChompJS, which are very useful for web scraping data."
    },
    {
        "link": "https://w3schools.com/python/python_json.asp",
        "document": "JSON is a syntax for storing and exchanging data.\n\nPython has a built-in package called , which can be used to work with JSON data.\n\nIf you have a JSON string, you can parse it by using the method.\n\nIf you have a Python object, you can convert it into a JSON string by using the method.\n\nYou can convert Python objects of the following types, into JSON strings:\n\nWhen you convert from Python to JSON, Python objects are converted into the JSON (JavaScript) equivalent:\n\nThe example above prints a JSON string, but it is not very easy to read, with no indentations and line breaks.\n\nThe method has parameters to make it easier to read the result:\n\nYou can also define the separators, default value is (\", \", \": \"), which means using a comma and a space to separate each object, and a colon and a space to separate keys from values:\n\nThe method has parameters to order the keys in the result:\n\nUse the parameter to specify if the result should be sorted or not: Try it Yourself ¬ª"
    },
    {
        "link": "https://brightdata.com/blog/how-tos/parse-json-data-with-python",
        "document": "In this tutorial, you will see:\n‚Ä¢ What JSON is and how to deal with it in Python\n‚Ä¢ How to parse JSON in Python with the json module\n‚Ä¢ If json is the best option for JSON parsing\n\nAn Introduction to JSON in Python\n\nBefore digging into JSON parsing with Python, let‚Äôs understand what JSON is and how to use it in Python.\n\nJSON, short for JavaScript Object Notation, is a lightweight data-interchange format. It is simple for humans to read and write and easy for machines to parse and generate. This makes it one of the most popular data formats. Specifically, JSON has become the ‚Äúlanguage of the web‚Äù because it is commonly used for transmitting data between servers and web applications via APIs.\n\nHere is an example of JSON:\n\nAs you can see, JSON consists of key-value pairs. Each key is a string and each value can be a string, number, boolean, null, array, or object. Even though it is similar to a JavaScript object, JSON can be used with any programming language, including Python.\n\nHow to Deal With JSON in Python\n\nPython natively supports JSON through the json module, which is part of the Python Standard Library. This means that you do not need to install any additional library to work with JSON in Python. You can import json as follows:\n\nThe built-in Python library exposes a complete API to deal with JSON. In particular, it has two key functions: and . The function allows you to parse JSON data from a string. Note that despite its name appearing to be plural, the ending ‚Äús‚Äù stands for ‚Äústring.‚Äù So, it should be read as ‚Äúload-s.‚Äù On the other hand, the function is for parsing JSON data into bytes.\n\nThrough those two methods, gives you the ability to convert JSON data to equivalent Python objects like dictionaries and lists, and vice versa. Plus, the module allows you to create custom encoders and decoders to handle specific data types.\n\nKeep reading and find out how to use the library to parse JSON data in Python!\n\nLet‚Äôs take a look at some real-world examples and learn how to parse JSON data from different sources into different Python data structures.\n\nAssume that you have some JSON data stored in a string and you want to convert it to a Python dictionary. This is what the JSON data looks like:\n\nAnd this is its string representation in Python:\n\nConsider using the Python triple quotes convention to store long multi-line JSON strings.\n\nYou can verify that contains a valid Python string with the line below:\n\nstands for ‚Äústring‚Äù and means that the smartphone variable has the text sequence type.\n\nParse the JSON string contained in smartphone into a Python dictionary with the json.loads() method as follows:\n\nIf you run this snippet, you would get:\n\nThus, all you have to do to convert a JSON string to a Python dictionary is to pass a valid JSON string to\n\nYou can now access the resulting dictionary fields as usual:\n\nKeep in mind that the function will not always return a dictionary. Specifically, the returning data type depends on the input string. For example, if the JSON string contains a flat value, it will be converted to the correspective Python primitive value:\n\nSimilarly, a JSON string containing an array list will become a Python list:\n\nTake a look at the conversion table below to see how JSON values are converted to Python data by :\n\nConsider that you need to make an API and convert its JSON response to a Python dictionary. In the example below, we will call the following API endpoint from the {JSON} Placeholder project to get some fake JSON data:\n\nThat RESTFul API returns the JSON response below:\n\nYou can call that API with the module from the Standard Library and convert the resulting JSON to a Python dictionary as follows:\n\npeforms the API call and returns an object. Its method is then used to get the response body body_json, which contains the API response as a JSON string. Finally, that string can be parsed into a Python dictionary through as explained earlier.\n\nSimilarly, you can achieve the same result with\n\nNote that the method automatically transforms the response object containing JSON data into the respective Python data structure.\n\nGreat! You now know how to parse a JSON API response in Python with both and .\n\nSuppose you have some JSON data stored in a file as below:\n\nYour goal is to read the JSON file and load it into a Python dictionary. Achieve that with the snippet below:\n\nThe built-in library allows you to load a file and get its corresponding file object. The method then deserializes the text file or binary file containing a JSON document to the equivalent Python object. In this case, becomes a Python dictionary.\n\nPerfect, parsing a JSON file in Python takes only a few lines of code!\n\nNow, you want to parse some JSON data into a custom Python class. This is what your custom Python class looks like:\n\nHere, the goal is to convert the following JSON string to a instance:\n\nTo accomplish this task, you need to create a custom decoder. In detail, you have to extend the class and set the parameter in the method. Assign it with the name of the class method containing the custom parsing logic. In that parsing method, you can use the values contained in the standard dictionary returned by to instantiate a object.\n\nNote that you should use the method to read the dictionary values within the custom method. This will ensure that no s are raised if a key is missing from the dictionary. Instaed, values will be returned.\n\nYou can now pass the class to the parameter in to convert a JSON string to a object:\n\nSimilarly, you can use with :\n\nEt voil√†! You now know how to parse JSON data into custom Python objects!\n\nYou can also go the other way around and convert Python data structures and primitives to JSON. This is possible thanks to the and functions, which follows the conversion table below:\n\nallows you to write a JSON string to a file, as in the following example:\n\nThis snippet will serialize the Python variable into the file.\n\nRun this snippet and you will get:\n\nThis is exactly the JSON representation of the Python dict.\n\nNote that you can also specify a custom encoder, but showing how to do it is not the purpose of this article. Follow the official documentation to learn more.\n\nIs the Standard Module the Best Resource for Parsing JSON in Python?\n\nAs is true in general for data parsing, JSON parsing comes with challenges that cannot be overlooked. For example, in case of invalid, broken, or non-standard JSON, the Python module would fall short.\n\nAlso, you need to be careful when parsing JSON data from untrusted sources. This is because a malicious JSON string can cause your parser to break or consume a large amount of resources. This is just one of the challenges a Python JSON parser should take into account.\n\nYou could introduce custom logic to deal with these particular cases. At the same time, that might take too long and result in complex and unreliable code. For this reason, you should consider a commercial tool that makes JSON parsing easier, such as Web Scraper API.\n\nWeb Scraping API is specifically designed for developers and comes with a wide range of features to parse JSON content and more. This tool can save you tons of time and help you secure your JSON parsing process. Also, it comes with Bright Data‚Äôs unblocking proxy capabilities to call JSON APIs anonymously.\n\nIf you are in hurry, you might also be interested in our Data as a Service offer. Through this service, you can ask Bright Data to provide you with a custom dataset that fits your specific needs. Bright Data will take care of everything, from performance to data quality.\n\nParsing JSON data has never been easier!\n\nPython enables you to natively parse JSON data through the standard module. This exposes a powerful API to serialize and deserialize JSON content. Specifically, it offers the and methods to deal with JSON files and JSON strings, respectively. Here, you saw how to use them to parse JSON data in Python in several real-world examples. At the same time, you also understood the limitations of this approach. This is why you may want to try a cutting-edge, fully-featured, commercial solution for data parsing, such as Bright Data‚Äôs data and proxy products."
    }
]