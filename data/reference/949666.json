[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlcommand?view=net-9.0-pp",
        "document": "The following example creates a SqlConnection, a SqlCommand, and a SqlDataReader. The example reads through the data, writing it to the console. Finally, the example closes the SqlDataReader and then the SqlConnection as it exits the code blocks.\n\nThe following sample shows how to create and execute different types of SqlCommand objects.\n\nFirst you must create the sample database, by executing the following script:\n\nNext, compile and execute the following:\n\nWhen an instance of SqlCommand is created, the read/write properties are set to their initial values. For a list of these values, see the SqlCommand constructor.\n\nSqlCommand features the following methods for executing commands at a SQL Server database:\n\nYou can reset the CommandText property and reuse the SqlCommand object. However, you must close the SqlDataReader before you can execute a new or previous command.\n\nIf a SqlException is generated by the method executing a SqlCommand, the SqlConnection remains open when the severity level is 19 or less. When the severity level is 20 or greater, the server ordinarily closes the SqlConnection. However, the user can reopen the connection and continue."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/microsoft.data.sqlclient.sqlcommand?view=sqlclient-dotnet-standard-5.2",
        "document": "The following example creates a SqlConnection, a SqlCommand, and a SqlDataReader. The example reads through the data, writing it to the console. Finally, the example closes the SqlDataReader and then the SqlConnection as it exits the code blocks.\n\nThe following sample shows how to create and execute different types of SqlCommand objects.\n\nFirst you must create the sample database, by executing the following script:\n\nNext, compile and execute the following:\n\nWhen an instance of SqlCommand is created, the read/write properties are set to their initial values. For a list of these values, see the SqlCommand constructor.\n\nSqlCommand features the following methods for executing commands at a SQL Server database:\n\nYou can reset the CommandText property and reuse the SqlCommand object. However, you must close the SqlDataReader before you can execute a new or previous command.\n\nIf a SqlException is generated by the method executing a SqlCommand, the SqlConnection remains open when the severity level is 19 or less. When the severity level is 20 or greater, the server ordinarily closes the SqlConnection. However, the user can reopen the connection and continue.\n\nInitiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this SqlCommand . Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this SqlCommand , given a callback procedure and state information. Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this SqlCommand and returns results as an XmlReader object. Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this SqlCommand , using one of the values, and retrieving one or more result sets from the server, given a callback procedure and state information. Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this SqlCommand and returns results as an XmlReader object, using a callback procedure. Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this SqlCommand using one of the CommandBehavior values. Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this SqlCommand and returns results as an XmlReader object. Initiates the asynchronous execution of the Transact-SQL statement or stored procedure that is described by this SqlCommand and returns results as an XmlReader object, using a callback procedure. Tries to cancel the execution of a SqlCommand . Creates a new SqlCommand object that is a copy of the current instance. Finishes asynchronous execution of a Transact-SQL statement, returning the requested data as XML. Executes a Transact-SQL statement against the connection and returns the number of rows affected. An asynchronous version of ExecuteNonQuery() , which executes a Transact-SQL statement against the connection and returns the number of rows affected. The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object. Sends the CommandText to the Connection and builds a SqlDataReader . Sends the CommandText to the Connection , and builds a SqlDataReader using one of the CommandBehavior values. An asynchronous version of ExecuteReader() , which sends the CommandText to the Connection and builds a SqlDataReader . Exceptions will be reported via the returned Task object. An asynchronous version of ExecuteReader() , which sends the CommandText to the Connection and builds a SqlDataReader . The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object. An asynchronous version of ExecuteReader(CommandBehavior) , which sends the CommandText to the Connection , and builds a SqlDataReader The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object. An asynchronous version of ExecuteReader(CommandBehavior) , which sends the CommandText to the Connection , and builds a SqlDataReader . Exceptions will be reported via the returned Task object. Executes the query, and returns the first column of the first row in the result set returned by the query. Additional columns or rows are ignored. An asynchronous version of ExecuteScalar() , which executes the query asynchronously and returns the first column of the first row in the result set returned by the query. Additional columns or rows are ignored. The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object. Sends the CommandText to the Connection and builds an XmlReader object. An asynchronous version of ExecuteXmlReader() , which sends the CommandText to the Connection and builds an XmlReader object. Exceptions will be reported via the returned Task object. An asynchronous version of ExecuteXmlReader() , which sends the CommandText to the Connection and builds an XmlReader object. The cancellation token can be used to request that the operation be abandoned before the command timeout elapses. Exceptions will be reported via the returned Task object. Creates a prepared version of the command on an instance of SQL Server. Registers the encryption key store providers on the SqlCommand instance. If this function has been called, any providers registered using the RegisterColumnEncryptionKeyStoreProviders(IDictionary<String,SqlColumnEncryptionKeyStoreProvider>) or RegisterColumnEncryptionKeyStoreProvidersOnConnection(IDictionary<String,SqlColumnEncryptionKeyStoreProvider>) methods will be ignored. This function can be called more than once. This does shallow copying of the dictionary so that the app cannot alter the custom provider list once it has been set. Resets the CommandTimeout property to its default value."
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/connect/ado-net/introduction-microsoft-data-sqlclient-namespace?view=sql-server-ver16",
        "document": "The Microsoft.Data.SqlClient namespace is essentially a new version of the System.Data.SqlClient namespace. Microsoft.Data.SqlClient generally maintains the same API and backwards compatibility with System.Data.SqlClient. To migrate from System.Data.SqlClient to Microsoft.Data.SqlClient, for most applications, it's simple. Add a NuGet dependency on Microsoft.Data.SqlClient and update references and statements to Microsoft.Data.SqlClient.\n\nThere are a few differences in less-used APIs compared to System.Data.SqlClient that may affect some applications. For those differences, refer to the useful porting cheat sheet.\n\nThe Microsoft.Data.SqlClient API details can be found in the .NET API Browser.\n• Added and support to as a structured parameter. #2258\n• Added object to take advantage of token caching in . #2380\n\nJSON data type support is now available in Microsoft.Data.SqlClient v6.0. This release introduces the type available as an extension to :\n\nNew types are available in the namespace that provide a strongly-typed collection of key-value pairs. These types can be captured by consuming applications for gathering diagnostic events emitted by the driver. This release introduces the following types:\n\nThe default behavior of can be overridden to disable the ten-second delay and automatic connection retries triggered by transient errors.\n\nFull release notes, including dependencies, are available in the GitHub Repository: 6.0 Release Notes.\n• Added new property to . #2004 Read more\n• Added a new API to . #1260 Read more\n• Added support for the registry option for Encrypt on .NET on Windows. #2047\n• Added explicit version for major .NET version dependencies on System.Runtime.Caching 8.0.0, System.Configuration.ConfigurationManager 8.0.0, and System.Diagnostics.DiagnosticSource 8.0.0 #2303\n• Added the ability to generate debugging symbols in a separate package file #2137\n\nSqlBulkCopy has a new property which supports value types.\n\nNote that the existing behavior is unchanged. When the value exceeds , can return a negative number.\n\nSqlConnection supports authentication by introducing a new property as a delegate to return a federated authentication access token.\n\nFull release notes, including dependencies, are available in the GitHub Repository: 5.2 Release Notes.\n• Added support for and for value and . #1813\n• Added support for TLS 1.3 for .NET Core and SNI Native. #1821\n• Added setting for or . #1822 Read more\n\nThe default value of the connection setting is an empty string. When is set to or , can be used to specify a path on the file system to a certificate file to match against the server's TLS/SSL certificate. The certificate specified must be an exact match to be valid. The accepted certificate formats are , , and . Here's a usage example:\n\nFull release notes, including dependencies, are available in the GitHub Repository: 5.1 Release Notes.\n• Added a dependency on the Microsoft.SqlServer.Server package. This new dependency may cause namespace conflicts if your application references that namespace and still has package references (direct or indirect) to System.Data.SqlClient from .NET Core.\n• Dropped classes from the namespace and replaced them with supported types from the Microsoft.SqlServer.Server package.#1585. The affected classes and enums are:\n• Added support for . To use TDS 8, users should specify Encrypt=Strict in the connection string. #1608 Read more\n• Added support for specifying Server SPN and Failover Server SPN on the connection. #1607 Read more\n• Added support for aliases when targeting .NET Core on Windows. #1588 Read more\n• Added a new AppContext switch to suppress insecure TLS warnings. #1457, Read more\n\nTo use TDS 8, specify Encrypt=Strict in the connection string. Strict mode disables TrustServerCertificate (always treated as False in Strict mode). HostNameInCertificate has been added to help some Strict mode scenarios. TDS 8 begins and continues all server communication inside a secure, encrypted TLS connection.\n\nNew Encrypt values have been added to clarify connection encryption behavior. is equivalent to and encrypts connections during the TDS connection negotiation. is equivalent to and only encrypts the connection if the server tells the client that encryption is required during the TDS connection negotiation.\n\nFor more information on encrypting connections to the server, see Encryption and certificate validation.\n\ncan be specified in the connection string when using aliases to connect with encryption to a server that has a server certificate with a different name or alternate subject name than the name used by the client to identify the server (DNS aliases, for example). Example usage:\n\nWhen connecting in an environment that has unique domain/forest topography, you might have specific requirements for Server SPNs. The ServerSPN/Server SPN and FailoverServerSPN/Failover Server SPN connection string settings can be used to override the autogenerated server SPNs used during integrated authentication in a domain environment\n\nUsers can configure Aliases by using the SQL Server Configuration Manager. These aliases are stored in the Windows registry and are already supported when targeting .NET Framework. This release brings support for aliases when targeting .NET or .NET Core on Windows.\n\nProvides a mechanism for enumerating all available instances of SQL Server within the local network.\n\nA security warning is output on the console if the TLS version less than 1.2 is used to negotiate with the server. This warning could be suppressed on SQL connection while by enabling the following AppContext switch on the application startup:\n\nFull release notes, including dependencies, are available in the GitHub Repository: 5.0 Release Notes.\n\nFull release notes, including dependencies, are available in the GitHub Repository: 4.1 Release Notes.\n\nA new attestation protocol called is allowed in the connection string. This protocol allows users to forgo enclave attestation for enclaves. When this protocol is set, the enclave attestation URL property is optional.\n\nFull release notes, including dependencies, are available in the GitHub Repository: 4.0 Release Notes.\n• Changed connection string property to be by default. #1210 Read more\n• The driver now throws replacing for active directory authentication modes. #1213\n• [.NET Framework] Exception isn't thrown if a User ID is provided in the connection string when using authentication #1359\n\nThe default value of the connection setting has been changed from to . With the growing use of cloud databases and the need to ensure those connections are secure, it's time for this backwards-compatibility-breaking change.\n\nIn scenarios where client encryption libraries were disabled or unavailable, it was possible for unencrypted connections to be made when Encrypt was set to true or the server required encryption.\n\nTLS 1.3 isn't supported by the driver; therefore, it has been removed from the supported protocols list by default. Users can switch back to forcing use of the Operating System's client protocols, by enabling the following App Context switch:\n\nMicrosoft.Data.SqlClient introduces a new API, to improve performance of queries with large number of parameters. This property is disabled by default. When set to , parameter names aren't sent to the SQL Server instance when the command is executed.\n\nThe App Context switch \"Switch.Microsoft.Data.SqlClient.EnableRetryLogic\" is no longer required to use the configurable retry logic feature. The feature is now supported in production. The default behavior of the feature continues to be a non-retry policy, which client applications need to override to enable retries.\n\nSqlLocalDb shared instances are now supported when using Managed SNI.\n\n, , types are now supported when using and .\n\nFull release notes, including dependencies, are available in the GitHub Repository: 3.0 Release Notes.\n• The minimum supported .NET Framework version has been increased to v4.6.1. .NET Framework v4.6.0 is no longer supported. #899\n• connection property now requires instead of for User-Assigned Managed Identity #1010 Read more\n• now returns a value instead of an empty . Legacy behavior can be enabled by setting switch Switch.Microsoft.Data.SqlClient.LegacyRowVersionNullBehavior #998 Read more\n\nThis new feature introduces configurable support for client applications to retry on \"transient\" or \"retriable\" errors. Configuration can be done through code or app config files and retry operations can be applied to opening a connection or executing a command. This feature is disabled by default and is currently in preview. To enable this support, client applications must turn on the following safety switch:\n\nOnce the .NET AppContext switch is enabled, a retry logic policy can be defined for and independently, or together using various customization options.\n\nNew public APIs are introduced in and for registering a custom implementation:\n\nAPI Usage examples can be found here:\n\nNew configuration sections have also been introduced to do the same registration from configuration files, without having to modify existing code:\n\nHere's a simple example of using the new configuration sections in configuration files:\n\nAlternatively, applications can implement their own provider of the base class, and register it with / .\n\nThe following counters are now available for applications targeting .NET Core 3.1+ and .NET Standard 2.1+:\n\nThese counters can be used with .NET Core global CLI tools: and in Windows or Linux and PerfView in Windows, using as the provider name. For more information, see Retrieve event counter values.\n\nMicrosoft.Data.SqlClient now depends on the Azure.Identity library to acquire tokens for \"Active Directory Managed Identity/MSI\" and \"Active Directory Service Principal\" authentication modes. This change brings the following changes to the public surface area:\n• Breaking Change\n\n The \"User ID\" connection property now requires \"Client ID\" instead of \"Object ID\" for \"User-Assigned Managed Identity\".\n\n(.NET Framework dependency) and (.NET Core/Standard dependency) versions have been updated to . Event tracing in SNI.dll is no longer enabled through a client application. Subscribing a session to the Microsoft.Data.SqlClient.EventSource provider through tools like or is sufficient. For more information, see Event tracing support in Native SNI.\n\nreturns a value instead of an empty . To enable the legacy behavior, you must enable the following AppContext switch on application startup: \"Switch.Microsoft.Data.SqlClient.LegacyRowVersionNullBehavior\"\n\nThis PR introduces a new SQL Authentication method, Active Directory Default. This authentication mode widens the possibilities of user authentication with Microsoft Entra ID, extending login solutions to the client environment, Visual Studio Code, Visual Studio, Azure CLI etc.\n\nWith this authentication mode, the driver acquires a token by passing \"DefaultAzureCredential\" from the Azure Identity library to acquire an access token. This mode attempts to use these credential types to acquire an access token in the following order:\n• EnvironmentCredential\n• Enables authentication with Microsoft Entra ID using client and secret, or username and password, details configured in the following environment variables: AZURE_TENANT_ID, AZURE_CLIENT_ID, AZURE_CLIENT_SECRET, AZURE_CLIENT_CERTIFICATE_PATH, AZURE_USERNAME, AZURE_PASSWORD (More details)\n• ManagedIdentityCredential\n• Attempts authentication with Microsoft Entra ID using a managed identity that has been assigned to the deployment environment. The \"Client Id\" of a \"user-assigned managed identity\" is read from the \"User Id\" connection property.\n• SharedTokenCacheCredential\n• Authenticates using tokens in the local cache shared between Microsoft applications.\n• VisualStudioCredential\n• Enables authentication with Microsoft Entra ID using data from Visual Studio\n• VisualStudioCodeCredential\n• Enables authentication with Microsoft Entra ID using data from Visual Studio Code.\n• AzureCliCredential\n• Enables authentication with Microsoft Entra ID using Azure CLI to obtain an access token.\n\nMicrosoft.Data.SqlClient now offers more control of where master key store providers are accessible in an application to better support multitenant applications and their use of column encryption/decryption. The following APIs are introduced to allow registration of custom master key store providers on instances of and :\n\nThe static API on , , used to register custom master key store providers globally, continues to be supported. The column encryption key cache maintained globally only applies to globally registered providers.\n\nThe built-in column master key store providers that are available for the Windows Certificate Store, CNG Store and CSP are preregistered. No providers should be registered on the connection or command instances if one of the built-in column master key store providers is needed.\n\nCustom master key store providers can be registered with the driver at three different layers. The global level is as it currently is. The new per-connection and per-command level registrations are empty initially and can be set more than once.\n\nThe precedences of the three registrations are as follows:\n• The per-command registration is checked if it isn't empty.\n• If the per-command registration is empty, the per-connection registration is checked if it isn't empty.\n• If the per-connection registration is empty, the global registration is checked.\n\nOnce any key store provider is found at a registration level, the driver does NOT fall back to the other registrations to search for a provider. If providers are registered but the proper provider isn't found at a level, an exception is thrown containing only the registered providers in the registration checked.\n\nThe driver doesn't cache the column encryption keys (CEKs) for custom key store providers registered using the new instance-level APIs. The key store providers need to implement their own cache to gain performance. The driver disables the local cache of column encryption keys implemented by custom key store providers if the key store provider instance is registered in the driver at the global level.\n\nA new API has also been introduced on the base class to set the cache time to live:\n\nA new connection property is introduced to specify the IP address family preference to the driver when establishing TCP connections. If (in .NET Framework) or is set to , this setting has no effect. There are the three accepted values for this property:\n• \n• This value is the default. The driver uses resolved IPv4 addresses first. If none of them can be connected to successfully, it tries resolved IPv6 addresses.\n• \n• The driver uses resolved IPv6 addresses first. If none of them can be connected to successfully, it tries resolved IPv4 addresses.\n• \n• The driver tries IP addresses in the order received from the DNS resolution response.\n\nFull release notes, including dependencies, are available in the GitHub Repository: 2.1 Release Notes.\n\nMicrosoft.Data.SqlClient v2.1 extends support for Always Encrypted on the following platforms:\n\nMicrosoft.Data.SqlClient v2.1 provides support for \"Device Code Flow\" authentication with MSAL.NET. Reference documentation: OAuth2.0 Device Authorization Grant flow\n\nThe following API enables customization of the Device Code Flow callback mechanism:\n\nThe following authentication mode keywords are supported:\n\nMicrosoft.Data.SqlClient v2.1 adds the following APIs to customize the Microsoft Entra Interactive authentication experience:\n\nMicrosoft.Data.SqlClient v2.1 introduces a new configuration section, (a clone of the existing ). The existing configuration section, , is still supported for backwards compatibility when the appropriate type is defined.\n\nThe new section allows application config files to contain both a SqlAuthenticationProviders section for System.Data.SqlClient and a SqlClientAuthenticationProviders section for Microsoft.Data.SqlClient.\n\nMicrosoft.Data.SqlClient v2.1 introduces support for passing a user-defined application client ID to the Microsoft Authentication Library. Application Client ID is used when authenticating with Microsoft Entra ID.\n\nThe following new APIs are introduced:\n• None A new constructor has been introduced in ActiveDirectoryAuthenticationProvider:\n\n [Applies to all .NET Platforms (.NET Framework, .NET Core, and .NET Standard)] string APP_CLIENT_ID = \"<GUID>\"; SqlAuthenticationProvider customAuthProvider = new ActiveDirectoryAuthenticationProvider(APP_CLIENT_ID); SqlAuthenticationProvider.SetProvider(SqlAuthenticationMethod.ActiveDirectoryInteractive, customAuthProvider); using (SqlConnection sqlConnection = new SqlConnection(\"<connection_string>\")) { sqlConnection.Open(); }\n• None A new configuration property has been introduced under and :\n\n [Applies to .NET Framework and .NET Core]\n\nMicrosoft.Data.SqlClient v2.1 introduces support for Data Classification's \"Sensitivity Rank\" information. The following new APIs are now available:\n\nMicrosoft.Data.SqlClient v2.1 introduces a new property, , on an active connection.\n\nMicrosoft.Data.SqlClient v2.1 extends the existing implementation to enable event tracing in SNI.dll. Events must be captured using a tool like Xperf.\n\nTracing can be enabled by sending a command to as illustrated:\n\nMicrosoft.Data.SqlClient v2.1 introduces the \"Command Timeout\" connection string property to override the default of 30 seconds. The time out for individual commands can be overridden using the property on the SqlCommand.\n\nWith Microsoft.Data.SqlClient v2.1, we've removed the symbols introduced in v2.0.0 from Microsoft.Data.SqlClient.SNI.runtime NuGet starting with v2.1.1. The public symbols are now published to Microsoft Symbols Server for tools like BinSkim that require access to public symbols.\n\nStarting with Microsoft.Data.SqlClient v2.1, Microsoft.Data.SqlClient symbols are source-linked and published to the Microsoft Symbols Server for an enhanced debugging experience without the need to download source code.\n\nFull release notes, including dependencies, are available in the GitHub Repository: 2.0 Release Notes.\n• The access modifier for the enclave provider interface has been changed from to .\n• Constants in the class have been updated to reflect changes in SQL Server.\n• The driver now performs Server Certificate validation when the target SQL Server enforces TLS encryption, which is the default for Azure connections.\n• now returns an empty instead .\n• The driver now performs decimal scale rounding to match SQL Server behavior. For backwards compatibility, the previous behavior of truncation can be enabled using an AppContext switch.\n• For .NET Framework applications consuming Microsoft.Data.SqlClient, the SNI.dll files previously downloaded to the and folders are now named and and are downloaded to the directory.\n• New connection string property synonyms replace old properties when fetching connection string from for consistency. Read More\n\nThe following new features have been introduced in Microsoft.Data.SqlClient 2.0.\n\nThe driver now caches IP addresses from every successful connection to a SQL Server endpoint that supports the feature. If a DNS resolution failure occurs during a connection attempt, the driver tries establishing a connection using a cached IP address for that server, if any exists.\n\nThis release introduces support for capturing event trace logs for debugging applications. To capture these events, client applications must listen for events from SqlClient's EventSource implementation:\n\nFor more information, see how to Enable event tracing in SqlClient.\n\nA new AppContext switch, \"Switch.Microsoft.Data.SqlClient.UseManagedNetworkingOnWindows\", enables the use of a managed SNI implementation on Windows for testing and debugging purposes. This switch toggles the driver's behavior to use a managed SNI in .NET Core 2.1+ and .NET Standard 2.0+ projects on Windows, eliminating all dependencies on native libraries for the Microsoft.Data.SqlClient library.\n\nSee AppContext Switches in SqlClient for a full list of available switches in the driver.\n\nThe driver rounds the decimal data scale, by default, as is done by SQL Server. For backwards compatibility, you can set the AppContext switch \"Switch.Microsoft.Data.SqlClient.TruncateScaledDecimal\" to true.\n\nNew synonyms have been added for the following existing connection string properties to avoid spacing confusion around properties with more than one word. Old property names continue to be supported for backwards compatibility. But the new connection string properties are now included when fetching the connection string from SqlConnectionStringBuilder.\n\nThe RowsCopied property provides read-only access to the number of rows that have been processed in the ongoing bulk copy operation. This value may not necessarily be equal to the final number of rows added to the destination table.\n\nThe default behavior of SqlConnection.Open() can be overridden to disable the ten-second delay and automatic connection retries triggered by transient errors.\n\nA username can be specified in the connection string when using Microsoft Entra Interactive authentication mode for both .NET Framework and .NET Core\n\nSet a username using the User ID or UID connection string property:\n\nOrder hints can be provided to improve performance for bulk copy operations on tables with clustered indexes. For more information, see the bulk copy operations section.\n\nMicrosoft.Data.SqlClient (.NET Core and .NET Standard) on Windows is now dependent on Microsoft.Data.SqlClient.SNI.runtime, replacing the previous dependency on runtime.native.System.Data.SqlClient.SNI. The new dependency adds support for the ARM platform along with the already supported platforms Arm64, x64, and x86 on Windows.\n\nFull release notes, including dependencies, are available in the GitHub Repository: 1.1 Release Notes.\n\nAlways Encrypted is available starting in Microsoft SQL Server 2016. Secure enclaves are available starting in Microsoft SQL Server 2019. To use the enclave feature, connection strings should include the required attestation protocol and attestation URL. For example:\n\nFor more information, see:\n• Tutorial: Develop a .NET application using Always Encrypted with secure enclaves\n\nThe initial release for the Microsoft.Data.SqlClient namespace offers more functionality over the existing System.Data.SqlClient namespace.\n\nFull release notes, including dependencies, are available in the GitHub Repository: 1.0 Release Notes.\n• None Data Classification - Available in Azure SQL Database and Microsoft SQL Server 2019.\n• None Data Classification - Available in Azure SQL Database and Microsoft SQL Server 2019.\n\nData Classification brings a new set of APIs exposing read-only Data Sensitivity and Classification information about objects retrieved via SqlDataReader when the underlying source supports the feature and contains metadata about data sensitivity and classification. See the sample application at Data Discovery and Classification in SqlClient.\n\nUTF-8 support doesn't require any application code changes. These SqlClient changes optimize client-server communication when the server supports UTF-8 and the underlying column collation is UTF-8. See the UTF-8 section under What's new in SQL Server 2019.\n\nIn general, existing documentation that uses System.Data.SqlClient on .NET Framework and built-in column master key store providers should now work with .NET Core, too.\n\nDevelop using Always Encrypted with .NET Framework Data Provider\n\nAlways Encrypted: Protect sensitive data and store encryption keys in the Windows certificate store\n\nDifferent authentication modes can be specified by using the Authentication connection string option. For more information, see the documentation for SqlAuthenticationMethod."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection?view=net-9.0-pp",
        "document": "The following example creates a SqlCommand and a SqlConnection. The SqlConnection is opened and set as the Connection for the SqlCommand. The example then calls ExecuteNonQuery. To accomplish this, the ExecuteNonQuery is passed a SqlConnection and a query string that is a Transact-SQL INSERT statement. The connection is closed automatically when the code exits the using block.\n\nA SqlConnection object represents a unique session to a SQL Server data source. With a client/server database system, it is equivalent to a network connection to the server. SqlConnection is used together with SqlDataAdapter and SqlCommand to increase performance when connecting to a Microsoft SQL Server database. For all third-party SQL Server products and other OLE DB-supported data sources, use OleDbConnection.\n\nWhen you create an instance of SqlConnection, all properties are set to their initial values. For a list of these values, see the SqlConnection constructor.\n\nSee ConnectionString for a list of the keywords in a connection string.\n\nIf the SqlConnection goes out of scope, it won't be closed. Therefore, you must explicitly close the connection by calling or . and are functionally equivalent. If the connection pooling value is set to or , the underlying connection is returned back to the connection pool. On the other hand, if is set to or , the underlying connection to the server is actually closed.\n\nTo ensure that connections are always closed, open the connection inside of a block, as shown in the following code fragment. Doing so ensures that the connection is automatically closed when the code exits the block.\n\nIf a SqlException is generated by the method executing a SqlCommand, the SqlConnection remains open when the severity level is 19 or less. When the severity level is 20 or greater, the server ordinarily closes the SqlConnection. However, the user can reopen the connection and continue.\n\nAn application that creates an instance of the SqlConnection object can require all direct and indirect callers to have sufficient permission to the code by setting declarative or imperative security demands. SqlConnection makes security demands using the SqlClientPermission object. Users can verify that their code has sufficient permissions by using the SqlClientPermissionAttribute object. Users and administrators can also use the Caspol.exe (Code Access Security Policy Tool) to modify security policy at the machine, user, and enterprise levels. For more information, see Security in .NET. For an example demonstrating how to use security demands, see Code Access Security and ADO.NET.\n\nFor more information about handling warning and informational messages from the server, see Connection Events. For more information about SQL Server engine errors and error messages, see Database Engine Events and Errors."
    },
    {
        "link": "https://stackoverflow.com/questions/35444487/how-to-use-sqlclient-in-asp-net-core",
        "document": "I am trying to use SQLClient library in the ASP.net Core but cant seem to get it working. I found this article online advising how to setup but its not working for me: http://blog.developers.ba/using-classic-ado-net-in-asp-net-vnext/\n\nI have a simple console application package. My project.json looks like this:\n\nAnd I try the following code:\n\nBut get the following errors:\n\nAnyone else got this working?"
    },
    {
        "link": "https://stackoverflow.com/questions/25257533/how-to-properly-use-async-methods-on-sqlconnection-and-sqldatareader",
        "document": "Keep in mind that does not mean \"faster\"; it means \"concurrent\". That is, the point of is that you can do something else while the operation is going on. In a UI app, this \"something else\" is normally \"responding to user input\"; the primary benefit of for UI apps is responsiveness. For ASP.NET apps, it works a little differently...\n\nIf you use \"all the way up\", then the primary benefit of on ASP.NET apps is scalability. By \"all the way up\", I mean if your method became , and the method that called it becomes , and so on and so forth all the way out to your MVC action / WebPage method / whatever (which is also ), then you're \"async all the way\".\n\nIn that scenario, then you get a scalability benefit. Note that each individual operation will not run any faster, but your application as a whole will scale better. When yields to the ASP.NET runtime, the request thread is freed up to handle other requests while that database connection is receiving the next row of data. With the synchronous code, any time your app is waiting on I/O while talking to the database, it's blocking a thread (which is doing nothing); frees up that thread while waiting for the I/O.\n\nSo the app as a whole can scale better, since it is making better use of the thread pool threads.\n\nIt's true that sometimes you can get gains by exploiting concurrency within a request; for example, if one request had to access the database and also call some web API, then you could start both of them and use to (asynchronously) wait for both results. In your first code example, you're doing the db connection and an object creation concurrently, but I suspect you won't really see any benefit in that situation unless your constructor is really computationally expensive. If you have two I/O operations or a real CPU operation, then could help you do concurrency within a request, but the primary use case is to improve scalability of the application as a whole."
    },
    {
        "link": "https://stackoverflow.com/questions/42415969/horrible-performance-using-sqlcommand-async-methods-with-large-data",
        "document": "I'm having major SQL performance problems when using async calls. I have created a small case to demonstrate the problem.\n\nI have create a database on a SQL Server 2016 which resides in our LAN (so not a localDB).\n\nIn that database, I have a table with 2 columns:\n\nIn that table, I have inserted a single record ( ='PerfUnitTest', is a 1.5mb string (a zip of a larger JSON dataset)).\n\nNow, if I execute the query in SSMS :\n\nI immediately get the result, and I see in SQL Servre Profiler that the execution time was around 20 milliseconds. All normal.\n\nWhen executing the query from .NET (4.6) code using a plain :\n\nThe execution time for this is also around 20-30 milliseconds.\n\nBut when changing it to async code :\n\nThe execution time is suddenly 1800 ms ! Also in SQL Server Profiler, I see that the query execution duration is more than a second. Although the executed query reported by the profiler is exactly the same as the non-Async version.\n\nBut it gets worse. If I play around with the Packet Size in the connection string, I get the following results :\n\n30,000 ms!! That's over a 1000x slower than the non-async version. And SQL Server Profiler reports that the query execution took over 10 seconds. That doesn't even explain where the other 20 seconds are gone to!\n\nThen I've switched back to the sync version and also played around with the Packet Size, and although it did impact a little the execution time, it was nowhere as dramatic as with the async version.\n\nAs a sidenote, if it put just a small string (< 100bytes) into the value, the async query execution is just as fast as the sync version (result in 1 or 2 ms).\n\nI'm really baffled by this, especially since I'm using the built-in , not even an ORM. Also when searching around, I found nothing which could explain this behavior. Any ideas?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/framework/data/adonet/asynchronous-programming",
        "document": "This article discusses support for asynchronous programming in .NET Framework Data Provider for SQL Server (SqlClient), including enhancements made to support asynchronous programming functionality that was introduced in .NET Framework 4.5.\n\nPrior to .NET Framework 4.5, asynchronous programming with SqlClient was done with the following methods and the connection property:\n\nThis functionality remained in SqlClient in .NET Framework 4.5.\n\nThe asynchronous programming feature provides a simple technique to make code asynchronous. For more information about the asynchronous programming feature that was introduced in .NET Framework 4.5, see:\n• Using SqlDataReader's new async methods in .NET Framework 4.5 (Part 1)\n• Using SqlDataReader's new async methods in .NET Framework 4.5 (Part 2)\n\nWhen your user interface is unresponsive or your server does not scale, it is likely that you need your code to be more asynchronous. Writing asynchronous code has traditionally involved installing a callback (also called continuation) to express the logic that occurs after the asynchronous operation finishes. This complicates the structure of asynchronous code as compared with synchronous code.\n\nYou can now call into asynchronous methods without using callbacks, and without splitting your code across multiple methods or lambda expressions.\n\nThe modifier specifies that a method is asynchronous. When calling an method, a task is returned. When the operator is applied to a task, the current method exits immediately. When the task finishes, execution resumes in the same method.\n\nCalling an method does not allocate any additional threads. It might use the existing I/O completion thread briefly at the end.\n\nThe following methods were added in .NET Framework 4.5 to support asynchronous programming:\n\nOther asynchronous members were added to support SqlClient Streaming Support.\n\nYou can upgrade an older application to use the newer asynchronous feature. For example, assume an application has a synchronous connection algorithm and blocks the UI thread every time it connects to the database and, once connected, the application calls a stored procedure that signals other users of the one who just signed in.\n\nWhen converted to use the newer asynchronous functionality, the program would look like:\n\nAdd the new asynchronous feature in an existing app (mix old and new patterns)\n\nIt is also possible to add new asynchronous capability ( ) without changing the existing asynchronous logic. For example, if an application currently uses:\n\nYou can begin to use the new asynchronous pattern without substantially changing the existing algorithm.\n\nUse the base provider model and the new asynchronous feature\n\nYou might need to create a tool that is able to connect to different databases and execute queries. You can use the base provider model and the new asynchronous feature.\n\nThe Microsoft Distributed Transaction Controller (MSDTC) must be enabled on the server to use distributed transactions. For information on how to enable MSDTC, see How to Enable MSDTC on a Web Server.\n\nUse SQL transactions and the new asynchronous feature\n\nUse SQL transactions and the new asynchronous feature\n\nIn an enterprise application, you might need to add distributed transactions in some scenarios, to enable transactions between multiple database servers. You can use the System.Transactions namespace and enlist a distributed transaction, as follows:\n\nYou can cancel an asynchronous request by using the CancellationToken.\n\nAsynchronous capabilities were also added to System.Data.SqlClient.SqlBulkCopy with SqlBulkCopy.WriteToServerAsync.\n\nThe example opens a single connection to the AdventureWorks database. Using a SqlCommand object, a SqlDataReader is created. As the reader is used, a second SqlDataReader is opened, using data from the first SqlDataReader as input to the WHERE clause for the second reader.\n\nMARS allows a connection to be used for both read operations and data manipulation language (DML) operations with more than one pending operation. This feature eliminates the need for an application to deal with connection-busy errors. In addition, MARS can replace the user of server-side cursors, which generally consume more resources. Finally, because multiple operations can operate on a single connection, they can share the same transaction context, eliminating the need to use sp_getbindtoken and sp_bindsession system stored procedures.\n\nThe following Console application demonstrates how to use two SqlDataReader objects with three SqlCommand objects and a single SqlConnection object with MARS enabled. The first command object retrieves a list of vendors whose credit rating is 5. The second command object uses the vendor ID provided from a SqlDataReader to load the second SqlDataReader with all of the products for the particular vendor. Each product record is visited by the second SqlDataReader. A calculation is performed to determine what the new OnOrderQty should be. The third command object is then used to update the ProductVendor table with the new value. This entire process takes place within a single transaction, which is rolled back at the end."
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/connect/ado-net/asynchronous-programming?view=sql-server-ver16",
        "document": "This article discusses support for asynchronous programming in the Microsoft SqlClient Data Provider for SQL Server (SqlClient).\n\nThe Microsoft SqlClient Data Provider for SQL Server includes methods from System.Data.SqlClient to maintain backwards compatibility for applications migrating to Microsoft.Data.SqlClient. It isn't recommended to use the following legacy asynchronous programming methods for new development:\n\nFor more information about asynchronous programming in .NET, see:\n\nWhen your user interface is unresponsive or your server doesn't scale, it's likely you need your code to be more asynchronous. Writing asynchronous code has traditionally involved installing a callback (also called continuation) to express the logic that occurs after the asynchronous operation finishes. This style complicates the structure of asynchronous code as compared with synchronous code.\n\nYou can call into asynchronous methods without using callbacks, and without splitting your code across multiple methods or lambda expressions.\n\nThe modifier specifies that a method is asynchronous. When calling an method, a task is returned. When the operator is applied to a task, the current method exits immediately. When the task finishes, execution resumes in the same method.\n\nCalling an method doesn't create extra threads. It may use the existing I/O completion thread briefly at the end.\n\nThe following methods in the Microsoft SqlClient Data Provider for SQL Server support asynchronous programming:\n\nYou can upgrade an existing application to use the asynchronous feature. For example, assume an application has a synchronous connection algorithm and blocks the UI thread every time it connects to the database. Once connected, the application calls a stored procedure that signals other users of the one who just signed in.\n\nWhen converted to use the asynchronous functionality, the program would look like:\n\nAdd the asynchronous feature in an existing application (mixing old and new patterns)\n\nIt's also possible to add asynchronous capability (SqlConnection::OpenAsync) without changing the existing asynchronous logic. For example, if an application currently uses:\n\nYou can begin to use the asynchronous pattern without substantially changing the existing algorithm.\n\nUse the base provider model and the asynchronous feature\n\nYou may need to create a tool that can connect to different databases and execute queries. You can use the base provider model and the asynchronous feature.\n\nThe Microsoft Distributed Transaction Controller (MSDTC) must be enabled on the server to use distributed transactions. For information on how to enable MSDTC, see How to Enable MSDTC on a Web Server.\n\nUse SQL transactions and the new asynchronous feature\n\nUse distributed transactions and the new asynchronous feature\n\nIn an enterprise application, you may need to add distributed transactions in some scenarios, to enable transactions between multiple database servers. You can use the System.Transactions namespace and enlist a distributed transaction, as follows:\n\nYou can cancel an asynchronous request by using the CancellationToken.\n\nAsynchronous capabilities are also in Microsoft.Data.SqlClient.SqlBulkCopy with SqlBulkCopy.WriteToServerAsync.\n\nThe example opens a single connection to the AdventureWorks database. Using a SqlCommand object, a SqlDataReader is created. As the reader is used, a second SqlDataReader is opened, using data from the first SqlDataReader as input to the WHERE clause for the second reader.\n\nMARS allows a connection to be used for both read operations and data manipulation language (DML) operations with more than one pending operation. This feature eliminates the need for an application to deal with connection-busy errors. Also, MARS can replace the use of server-side cursors, which generally consume more resources. Finally, because multiple operations can operate on a single connection, they can share the same transaction context, eliminating the need to use sp_getbindtoken and sp_bindsession system stored procedures.\n\nThe following Console application demonstrates how to use two SqlDataReader objects with three SqlCommand objects and a single SqlConnection object with MARS enabled. The first command object retrieves a list of vendors whose credit rating is 5. The second command object uses the vendor ID provided from a SqlDataReader to load the second SqlDataReader with all of the products for the particular vendor. Each product record is visited by the second SqlDataReader. A calculation is performed to determine what the new OnOrderQty should be. The third command object is then used to update the ProductVendor table with the new value. This entire process takes place within a single transaction, which is rolled back at the end."
    },
    {
        "link": "https://reddit.com/r/csharp/comments/1dkgm61/sql_open_connection_async_or_not_async",
        "document": "I execute all my SQLs asynchronously. BUT should i open SqlConnection asynchronously or not?\n\nTheoretically yes since it's an IO as well, BUT there is a huge chance that my app will grab connection from the pool so no IO and hence no async needed.\n\nOr is it \"bad thinking\"?"
    }
]