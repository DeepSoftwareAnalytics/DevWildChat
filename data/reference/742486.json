[
    {
        "link": "https://github.com/ocornut/imgui/issues/6863",
        "document": "I am trying to make a 2d game.\n\nso I am trying to make my window be able to move while dragging the entire thing instead of the title bar (for the loading screen, obviously not when in game)\n\nHowever, I achieved this by handling the WM_NCHITTEST case in my Window Procedure function."
    },
    {
        "link": "https://github.com/ocornut/imgui/issues/3256",
        "document": "Suppose I am drawing some custom UI inside an ImGui window. I know I can stop ImGui from moving the window by making it an invisible button. But what if I want a combination where sometimes I want to allow ImGui to move the window when clicking, and sometimes I want to take over the mouse interaction? My scenario is that I have a custom rendered UI on an OpenGL surface, displayed as an image inside an ImGui Window. I want the user to be able to click elements of that UI and interact with them, but I also want the user to be able to click outside the UI elements - in the dead space around them, to move the window in the usual ImGui way.\n\nIs there a recommended approach to this? I thought about making it an invisible button, but then forwarding the message to ImGui if I was not interested in it, so that it can implement the window drag.\n\nMy motivation is that I like the window drag, it helps stop windows getting stuck off screen. But I don't want it to universally occur at any point inside my image."
    },
    {
        "link": "https://stackoverflow.com/questions/71680516/how-do-i-handle-mouse-events-in-general-in-imgui-with-glfw",
        "document": "I used the glfw callback function to move the camera with the mouse.\n\nHowever, in this case, the camera will move even when operated in other imgui windows as shown below.\n\nI don't know how to handle this.\n\nShould I put this logic between begin and end of IMGUI, using something like ?"
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/14zq35j/how_to_learn_dear_imgui_with_so_little",
        "document": "Hello everyone, I'm a fairly new programmer moving from C to C++. I recently attempted learning Dear ImGui to create guis. This is my first non-standard library and I'm facing challenges in understanding the code involving ImGui (the C++ part is fine). Most tutorials I've come across dive into creating complex guis without explaining the basics. While I've managed to create a simple gui by googling and piecing together code snippets, I still lack a solid understanding. I can't even create a Hello World in ImGui without referring to external resources. It’s a bit confusing with all the graphics APIs like OpenGL and Vulcan, I don’t know which to choose from.\n\nI would greatly appreciate any advice on learning this library or anything that I should learn first before attempting to learn this."
    },
    {
        "link": "https://skia.googlesource.com/external/github.com/ocornut/imgui/+/features/range_select/imgui.cpp",
        "document": ""
    },
    {
        "link": "https://github.com/ocornut/imgui",
        "document": "Businesses: support continued development and maintenance via invoiced sponsoring/support contracts: \n\n E-mail: contact @ dearimgui dot com \n\nIndividuals: support continued development and maintenance here. Also see Funding page.\n\nDear ImGui is a bloat-free graphical user interface library for C++. It outputs optimized vertex buffers that you can render anytime in your 3D-pipeline-enabled application. It is fast, portable, renderer agnostic, and self-contained (no external dependencies).\n\nDear ImGui is designed to enable fast iterations and to empower programmers to create content creation tools and visualization / debug tools (as opposed to UI for the average end-user). It favors simplicity and productivity toward this goal and lacks certain features commonly found in more high-level libraries. Among other things, full internationalization (right-to-left text, bidirectional text, text shaping etc.) and accessibility features are not supported.\n\nDear ImGui is particularly suited to integration in game engines (for tooling), real-time 3D applications, fullscreen applications, embedded applications, or any applications on console platforms where operating system features are non-standard.\n• Easy to use to create dynamic UI which are the reflection of a dynamic data set.\n• Easy to use to create code-driven and data-driven tools.\n• Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n• Battle-tested, used by many major actors in the game industry.\n\nThe core of Dear ImGui is self-contained within a few platform-agnostic files which you can easily compile in your application/engine. They are all the files in the root folder of the repository (imgui*.cpp, imgui*.h). No specific build process is required. You can add the .cpp files into your existing project.\n\nBackends for a variety of graphics API and rendering platforms are provided in the backends/ folder, along with example applications in the examples/ folder. You may also create your own backend. Anywhere where you can render textured triangles, you can render Dear ImGui.\n\nSee the Getting Started & Integration section of this document for more details.\n\nAfter Dear ImGui is set up in your application, you can use it from _anywhere_ in your program loop:\n\nDear ImGui allows you to create elaborate tools as well as very short-lived ones. On the extreme side of short-livedness: using the Edit&Continue (hot code reload) feature of modern compilers you can add a few widgets to tweak variables while your application is running, and remove the code a minute later! Dear ImGui is not just for tweaking values. You can use it to trace a running algorithm by just emitting text commands. You can use it along with your own reflection data to browse your dataset live. You can use it to expose the internals of a subsystem in your engine, to create a logger, an inspection tool, a profiler, a debugger, an entire game-making editor/framework, etc.\n\nThe IMGUI paradigm through its API tries to minimize superfluous state duplication, state synchronization, and state retention from the user's point of view. It is less error-prone (less code and fewer bugs) than traditional retained-mode interfaces, and lends itself to creating dynamic user interfaces. Check out the Wiki's About the IMGUI paradigm section for more details.\n\nDear ImGui outputs vertex buffers and command lists that you can easily render in your application. The number of draw calls and state changes required to render them is fairly small. Because Dear ImGui doesn't know or touch graphics state directly, you can call its functions anywhere in your code (e.g. in the middle of a running algorithm, or in the middle of your own rendering process). Refer to the sample applications in the examples/ folder for instructions on how to integrate Dear ImGui with your existing codebase.\n\nA common misunderstanding is to mistake immediate mode GUI for immediate mode rendering, which usually implies hammering your driver/GPU with a bunch of inefficient draw calls and state changes as the GUI functions are called. This is NOT what Dear ImGui does. Dear ImGui outputs vertex buffers and a small list of draw calls batches. It never touches your GPU directly. The draw call batches are decently optimal and you can render them later, in your app or even remotely.\n\nSee Releases page for decorated Changelogs. Reading the changelogs is a good way to keep up to date with the things Dear ImGui has to offer, and maybe will give you ideas of some features that you've been ignoring until now!\n\nCalling the function will create a demo window showcasing a variety of features and examples. The code is always available for reference in . Here's how the demo looks.\n\nYou should be able to build the examples from sources. If you don't, let us know! If you want to have a quick look at some Dear ImGui features, you can download Windows binaries of the demo app here:\n\nThe demo applications are not DPI aware so expect some blurriness on a 4K screen. For DPI awareness in your application, you can load/reload your font at a different scale and scale your style with (see FAQ).\n\nSee the Getting Started guide for details.\n\nOn most platforms and when using C++, you should be able to use a combination of the imgui_impl_xxxx backends without modification (e.g. + ). If your engine supports multiple platforms, consider using more imgui_impl_xxxx files instead of rewriting them: this will be less work for you, and you can get Dear ImGui running immediately. You can later decide to rewrite a custom backend using your custom engine functions if you wish so.\n\nIntegrating Dear ImGui within your custom engine is a matter of 1) wiring mouse/keyboard/gamepad inputs 2) uploading a texture to your GPU/render engine 3) providing a render function that can bind textures and render textured triangles, which is essentially what Backends are doing. The examples/ folder is populated with applications doing just that: setting up a window and using backends. If you follow the Getting Started guide it should in theory takes you less than an hour to integrate Dear ImGui. Make sure to spend time reading the FAQ, comments, and the examples applications!\n• Languages: C, C# and: Beef, ChaiScript, CovScript, Crystal, D, Go, Haskell, Haxe/hxcpp, Java, JavaScript, Julia, Kotlin, Lobster, Lua, Nim, Odin, Pascal, PureBasic, Python, ReaScript, Ruby, Rust, Swift, Zig...\n• Many bindings are auto-generated (by good old cimgui or newer/experimental dear_bindings), you can use their metadata output to generate bindings for other languages.\n• Automation/testing, Text editors, node editors, timeline editors, plotting, software renderers, remote network access, memory editors, gizmos, etc. Notable and well supported extensions include ImPlot and Dear ImGui Test Engine.\n\nAlso see Wiki for more links and ideas.\n\nExamples projects using Dear ImGui: Tracy (profiler), ImHex (hex editor/data analysis), RemedyBG (debugger) and hundreds of others.\n\nFor more user-submitted screenshots of projects using Dear ImGui, check out the Gallery Threads!\n\nFor a list of third-party widgets and extensions, check out the Useful Extensions/Widgets wiki page.\n\nSee: Frequently Asked Questions (FAQ) where common questions are answered.\n\nSee: Getting Started and Wiki for many links, references, articles.\n\nSee: Articles about the IMGUI paradigm to read/learn about the Immediate Mode GUI paradigm.\n\nFor the purposes of getting search engines to crawl the wiki, here's a link to the Crawlable Wiki (not for humans, here's why).\n\nGetting started? For first-time users having issues compiling/linking/running or issues loading fonts, please use GitHub Discussions. For ANY other questions, bug reports, requests, feedback, please post on GitHub Issues. Please read and fill the New Issue template carefully.\n\nPrivate support is available for paying business customers (E-mail: contact @ dearimgui dot com).\n\nWhich version should I get?\n\nWe occasionally tag Releases (with nice releases notes) but it is generally safe and recommended to sync to latest or branch. The library is fairly stable and regressions tend to be fixed fast when reported. Advanced users may want to use the branch with Multi-Viewport and Docking features. This branch is kept in sync with master regularly.\n\nSee the Quotes, Funding & Sponsors, and Software using Dear ImGui Wiki pages for an idea of who is using Dear ImGui. Please add your game/software if you can! Also, see the Gallery Threads!\n\nHow can I help?\n• You may help with development and submit pull requests! Please understand that by submitting a PR you are also submitting a request for the maintainer to review your code and then take over its maintenance forever. PR should be crafted both in the interest of the end-users and also to ease the maintainer into understanding and accepting it.\n• See Help wanted on the Wiki for some more ideas.\n• Be a Funding Supporter! Have your company financially support this project via invoiced sponsors/maintenance or by buying a license for Dear ImGui Test Engine (please reach out: omar AT dearimgui DOT com).\n\nOngoing Dear ImGui development is and has been financially supported by users and private sponsors. \n\nPlease see the detailed list of current and past Dear ImGui funding supporters and sponsors for details. \n\nFrom November 2014 to December 2019, ongoing development has also been financially supported by its users on Patreon and through individual donations.\n\nTHANK YOU to all past and present supporters for helping to keep this project alive and thriving!\n\nDear ImGui is using software and services provided free of charge for open source projects:\n\nDeveloped by Omar Cornut and every direct or indirect contributors to the GitHub. The early version of this library was developed with the support of Media Molecule and first used internally on the game Tearaway (PS Vita).\n\nRecurring contributors include Rokas Kupstys @rokups (2020-2022): a good portion of work on automation system and regression tests now available in Dear ImGui Test Engine.\n\nMaintenance/support contracts, sponsoring invoices and other B2B transactions are hosted and handled by Disco Hello.\n\nOmar: \"I first discovered the IMGUI paradigm at Q-Games where Atman Binstock had dropped his own simple implementation in the codebase, which I spent quite some time improving and thinking about. It turned out that Atman was exposed to the concept directly by working with Casey. When I moved to Media Molecule I rewrote a new library trying to overcome the flaws and limitations of the first one I've worked with. It became this library and since then I have spent an unreasonable amount of time iterating and improving it.\"\n\nInspiration, feedback, and testing for early versions: Casey Muratori, Atman Binstock, Mikko Mononen, Emmanuel Briney, Stefan Kamoda, Anton Mikhailov, Matt Willis. Also thank you to everyone posting feedback, questions and patches on GitHub.\n\nDear ImGui is licensed under the MIT License, see LICENSE.txt for more information."
    },
    {
        "link": "https://codingwiththomas.com/blog/rendering-an-opengl-framebuffer-into-a-dear-imgui-window",
        "document": "Once in a while I spend some time with OpenGL and computer graphics / game development. This became sort of a hobby. A while ago I came across Dear ImGui, a graphical user interface for C++. It allows you to create windows, menues, buttons, drop downs, etc, etc, ... So it's definitely worth to check this out if you need something like that in C++. But it took me a fair amount of time, when it came down to custom render something into an ImGui window. Even though I found some StackOverflow posts, I didn't find a basic example which I can use to play around. But with reading documentation and patience I solved my problem. I'm not an expert in computer graphics nor I'm a game developer. I provide this examples to the best of my knowledge and if you can help me to improve, I appreciate every comment. So, in this article we'll create an OpenGL triangle, which then we put into an ImGui window. Please note, this is not an article about best practices, therefore I don't create classes or a certain structure. Also, I don't go into detail for the OpenGL stuff. If you're completely new to OpenGL I recommend an OpenGL beginner tutorial to get a basic understanding for it. Thats being said, this is our plan, a simple triangle from a regular window on the left in a ImGui Window on the rigth.\n\nFor this article, I'll keep it simple. We start with the OpenGL hello world, a triangle. Pretty basic for now. We have the vertices for the triangle, the shader (plus the compilation of the shader code) and the functions for the framebuffers in separate functions. So first things first, our ID's and the shader code:\n\n() { // ImGui initialization, note: we use the docking branch // this means we have the basic docking functionality as you have // in a lot of other desktop applications // and you can drag the ImGui Window out of the actual window (); :: (); ImGuiIO& io = :: (); ( )io; io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; io.ConfigFlags |= ImGuiConfigFlags_DockingEnable; io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable; // i (as always) prefer the dark mode :: (); ImGuiStyle& style = :: (); (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable){ style.WindowRounding = f; style.Colors[ImGuiCol_WindowBg].w = f; } (mainWindow, ); ( ); (! (mainWindow)) { (); // and tell our program that we'll create a ImGui frame (); (); ( f, f, f, f); (GL_COLOR_BUFFER_BIT); // we begin a new frame, and with Begin() we create a window // ultimately we have to call End() and Render() to display it :: (); :: ( ); // Here we can render into the ImGui window // ImGui Buttons, Drop Downs, etc. and later our framebuffer :: (); :: (); // ... rendering our triangle as before // and we have to pass the render data further ( :: ()); (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable) { GLFWwindow* backup_current_context = (); :: (); :: (); (backup_current_context); } (mainWindow); } (); (); :: (); ; }\n\n// here we create our framebuffer and our renderbuffer // you can find a more detailed explanation of framebuffer // on the official opengl homepage, see the link above { ( , &FBO); (GL_FRAMEBUFFER, FBO); ( , &texture_id); (GL_TEXTURE_2D, texture_id); (GL_TEXTURE_2D, , GL_RGB, WIDTH, HEIGHT, , GL_RGB, GL_UNSIGNED_BYTE, ); (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); (GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture_id, ); ( , &RBO); (GL_RENDERBUFFER, RBO); (GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, WIDTH, HEIGHT); (GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, RBO); ( (GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) std::cout << ; (GL_FRAMEBUFFER, ); (GL_TEXTURE_2D, ); (GL_RENDERBUFFER, ); } // here we bind our framebuffer { (GL_FRAMEBUFFER, FBO); } // here we unbind our framebuffer { (GL_FRAMEBUFFER, ); } // and we rescale the buffer, so we're able to resize the window { (GL_TEXTURE_2D, texture_id); (GL_TEXTURE_2D, , GL_RGB, width, height, , GL_RGB, GL_UNSIGNED_BYTE, ); (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); (GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture_id, ); (GL_RENDERBUFFER, RBO); (GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width, height); (GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, RBO); }\n\nNow we can call our functions to create and handle a framebuffer. Right between and we add our framebuffer as image to the window. I honestly don't know why, but the ordering matters: First we render the ImGui window and then we render our triangle. To render into the framebuffer we call before we render the triangle and when we're done.\n\n{ (); (); // we create the framebuffer rigth after the triangle and the shader (); (! (mainWindow)) { ImGui:: (); ImGui:: ( ); window_width = ImGui:: ().x; window_height = ImGui:: ().y; // we rescale the framebuffer to the actual window size here and reset the glViewport (window_width, window_height); ( , , window_width, window_height); // we get the screen position of the window ImVec2 pos = ImGui:: (); // and here we can add our created texture as image to ImGui // unfortunately we need to use the cast to void* or I didn't find another way tbh ImGui:: ()-> ( ( *)texture_id, (pos.x, pos.y), (pos.x + window_width, pos.y + window_height), ( , ), ( , ) ); ImGui:: (); ImGui:: (); // now we can bind our framebuffer (); // and we render our triangle as before (shader); (VAO); (GL_TRIANGLES, , ); ( ); ( ); (); (mainWindow); } ; }\n\nYou can find the final result here on GitHub. And Thats It For Now I hope that helped, if you can answer me why the ordering matters, that I first need to render the ImGui window and the the triangle, I'd appreciate that. Let's see how to continue with that. I really like Dear ImGui, once I understood it, it's fairly simple to do an GUI in C++. For now, thanks for reading."
    },
    {
        "link": "https://github.com/ocornut/imgui/blob/master/examples/example_glfw_opengl3/main.cpp",
        "document": "Your own project should not be affected, as you are likely to link with a newer binary of GLFW that is adequate for your version of Visual Studio.\n\n- If the file cannot be loaded, the function will return a nullptr. Please handle those errors in your application (e.g. use an assertion, or display an error and quit)."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/h88cvn/c_uigui_for_opengl_application",
        "document": "I wrote OpenGL application, I used FreeGLUT as Window Manager. This library doesn't contain support for buttons, sliders, and other UI elements.\n\nI want help finding a library that just works under windows development.\n\nI tried the following libraries without success:\n• wxWidgets - Downloaded Headers, Dev libs, DLL, but having problem with setting up with Visual Studio\n• Qt - Downloaded, I looked for example codes for it, but they all use #include <Qt> but I don't have that (I have diffirent headers: #include <Qt/> is a folder, what to include inside it?\n• GTK+ - I downloaded with MSYS2 - now what? I couldn't find how to use it, also the documentation says that it will be a problem to port it (distribute) application, something to do with DLL and static libraries. But I need to export it\n• I looked for options like Java built in GUI and connect Java code with C++ code (binding) but it's too complicated for what I want, also CPython (much better but also problem with exporting the application)\n• GLUI - No idea how to F*** install, looked everywhere, nothing works\n• MFC - I have no idea how to combine my C++ code with it, I don't want to create a new MFC project and copy paste my opengl code there. Also, what to do with GLUT managing the window?\n\nPlease I need to find a portable (simple header, lib, dll cross-platform if possible) that simply works, no bloat, simple buttons and gui elements. Nothing more."
    },
    {
        "link": "https://stackoverflow.com/questions/60955993/how-to-use-opengl-glfw3-render-in-a-imgui-window",
        "document": "I am learning OpenGL by glfw3 lib and I am using imgui to make a interesting application.\n\nI want to make a little Engine or CAD tool.\n\nProblem is I can not render what I want in a imgui window.\n\nI tried about two days and I have rendered a triangle in a imgui window.\n\n However when I try to render content as this link(Tutorial and Code) shows me.\n\nI tried serial days and I am going to give up, I really need your help.\n\nis a value to test. Xhader.h just is the header file in the tutorial, also .vs and .fs files. the difference is tutorial uses glad.h and I use glew.h"
    }
]