[
    {
        "link": "https://gjs-docs.gnome.org/gjs",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/8078762/gnome-javascript-documentation",
        "document": "I'm trying to dive into Gnome shell extensions development but I'm a little bit confused at the moment. I can't seem to find a proper documentation about GJS library. For example I want to know at least what imports are available and members/method of classes without that I can only rely on existing extensions code, not too much.\n\nCan anyone lead me in the right direction?"
    },
    {
        "link": "https://reddit.com/r/gnome/comments/12nf32k/autogenerate_documentation_for_gnome_shell_apis",
        "document": "This seems worth it to me because the current state seems kind of unsustainable. There's clearly an extensive community of people writing extensions for GNOME, and an equally large dependence on those extensions, and yet the documentation that I'm able to find for it is astoundingly sparse.\n\nYes, there are the API docs and official guides. However, the official guides give only a general outline and a few examples of the things you might want to do, they're not very helpful at all for understanding the details of how everything works.\n\nLikewise, the API docs seem extremely incomplete. The biggest glaring omission is that the reusable GNOME Shell components that the vast majority of all GNOME Extensions will need to use are completely absent from any kind of documentation. The best the guides offer is a limp-wristed \"you can browse around in the js/ui/ folder or any other JavaScript file under js/ for more code to be reused.\" The best API docs available are this eleven year old blog post: https://mathematicalcoffee.blogspot.com/2012/09/gnome-shell-javascript-source.html?m=1. Really? Seriously?\n\nIf it's just because the extensions reach directly into the internals of the GNOME Shell and so there's not really any stable API or behavior to document that couldn't change between commits, I think taking a little bit more effort to add comments to each function in the GNOME Shell library stuff (\"the closest GNOME Shell has in terms of stable public API\" according to the docs) and then just running an automated docs generator on them every so often feels like it would be a massive step up without causing problems with being out of date, since they'd naturally stay relatively up to date by being generated from the code.\n\nAnyway, is this going to stop me in the meantime? Absolutely not, I've dealt with this sort of shit before. I'm just more annoyed by it than usual because I'm dealing with the aftermath of a very severe concussion so everything takes a lot more effort than it would normally for me and I also have less time in the day when I feel well enough to do things so these kinds of annoying little roadblocks drive me crazy."
    },
    {
        "link": "https://gjs.guide/extensions/development/debugging.html",
        "document": "When an extension is enabled it is effectively applied like a patch, and so enabled extensions become a part of the GNOME Shell process. As a result, debugging extensions can sometimes involve non-standard methods.\n\nThis document will explain the basic workflow required to develop, test and debug GNOME Shell extensions.\n\nTo aid development additional debugging can be enabled by defining the environment variable:\n• None When a message is logged at level or , GNOME Shell will print the current JavaScript stack. These log levels correspond to and , respectively.\n• None If GNOME Shell encounters a fatal error and crashes, it will print the current JavaScript stack before exiting.\n• None Defining as will enable all options.\n\nWith defined to a suitable value, a stack trace to the JavaScript source is printed after the message:\n\nUnlike frameworks that can load and unload plugins or shared libraries, JavaScript engines can not \"unload\" code from the interpreter. This means a new GNOME Shell process must be started to load changes in an extension, and ensure a clean environment for testing the new code.\n\nWayland desktops can run a nested instance of GNOME Shell, similar to running a virtual machine, except only the process is run and there is very little isolation.\n\nA nested instance is wrapped in a new D-Bus session, which allows GNOME Shell to export D-Bus services and other tasks that would normally conflict with the host system. Start a nested instance by running the command below in a new terminal:\n\nGNOME Shell and Mutter will log many debug messages and harmless warnings to the terminal, and display a new desktop in a window. The process can be further controlled by setting environment variables used when Running GLib Applications and specifically the variable which can be used to set the display resolution:\n\nX11 desktops can't run a nested instance of GNOME Shell, but can be restarted without having to log out and log back in. Before restarting, be sure to have a terminal open for logging.\n\nStart by pressing + to open the Run a Command dialog, then enter the built-in command . GNOME Shell will restart, reloading all extensions, while logging debug messages, warnings and errors.\n\nThis section explains logging with a focus on GNOME Shell extensions. There is more complete documentation for Logging available in the API Documentation.\n\nThe API is the recommended method for logging, using a function determined by log level.\n• None Use this function to log information only useful during development. Messages are logged at .\n• None Use this function to log unexpected errors that may indicate a bug. Messages are logged at .\n• None Use this function to log programmer errors and assertion failures. Messages are logged at .\n\nThe best practice is to keep logging to a minimum, focusing on unexpected events and failures. All logged messages are included in the system log, so excessive logging can even make debugging other applications more difficult.\n\nLooking Glass is a debugger and inspector, built into GNOME Shell. Note that it is not a stepping debugger like the one started by , but more like the inspector in GTK.\n\nTo open Looking Glass, start by pressing + to open the Run a Command dialog, then enter the built-in command .\n\nThe Evaluator page is the default page of Looking Glass, and a unique REPL console that can run arbitrary JavaScript in the current GNOME Shell process. It has command history, tab completion and automatically saves the return values of expressions and function calls.\n\nThe libraries , , , , , and are imported, as well as ( ). Additionally, the following are defined:\n• - Get the at\n• - Get the return value of a previous command at\n\nEach line is executed separately, so multiple expressions and function calls must be joined by a semi-colon ( ). For example:\n\nClicking will open a dialog with the object's properties, including links to other objects. In the top-left corner of Looking Glass there is a button with a target icon ( ), which allows you to select an actor with the mouse and calls the function for you:\n\nThe Windows page lists the open windows in the current session. Clicking on the window title opens the inspector for the object, and clicking on the file name opens it for the object.\n\nThe Extensions page lists the extensions in the current session. It displays the status of the extension, such as \"Enabled\" or \"Downloading\", and buttons to view any errors, open the source directory and visit the extension's website.\n\nThe Actors page allows browsing all the widgets in the shell as a tree of objects. This is sometimes necessary to acquire a reference to an actor that is hidden from sight, or a non-visual object that exists as a property of an actor.\n\nThe Flags page contains many debugging options for Clutter and Mutter. These options are generally reserved for GNOME Shell development, and should be used with care.\n\nSimilar to Node.js, GJS also has a REPL shell (Read-Evaluate-Print-Loop) that can be used to test simple pieces of code:\n\nGJS provides bindings between JavaScript and the GNOME platform, which is written largely in C. This means that there may always be ways to crash a GJS process, despite being a high-level memory-safe language.\n\nGJS has a built-in stepping debugger for JavaScript, but the binary is not a JavaScript document that it can run. Instead, a debugger like can be used to start the process:\n\nBe sure to install any missing debug symbols, including those for mozjs, then enter at the prompt:\n\n#0 JS::MutableHandle<JS::Value>::set(JS::Value const&) (v=<optimized out>, this=<optimized out>, this=<optimized out>, v=<optimized out>) at /usr/include/mozjs-102/js/RootingAPI.h:708 #1 js::MutableWrappedPtrOperations<JS::Value, JS::MutableHandle<JS::Value> >::set(JS::Value const&) (v=<optimized out>, this=<optimized out>, this=<optimized out>, v=<optimized out>) at /usr/include/mozjs-102/js/Value.h:1285 #2 js::MutableWrappedPtrOperations<JS::Value, JS::MutableHandle<JS::Value> >::setUndefined() (this=<optimized out>, this=<optimized out>) at /usr/include/mozjs-102/js/Value.h:1290 #6 0x00007ffff5d412fc in InternalCall (reason=<optimized out>, args=<optimized out>, cx=<optimized out>) at /usr/src/debug/mozjs102-102.9.0-1.fc38.x86_64/vm/Interpreter.cpp:574 #7 js::CallFromStack(JSContext*, JS::CallArgs const&) (args=<optimized out>, cx=<optimized out>) at /usr/src/debug/mozjs102-102.9.0-1.fc38.x86_64/vm/Interpreter.cpp:578\n\nDepending on the problem being debugged, the call stack from SpiderMonkey and GNOME Shell may not provide useful or sufficient information. To print the call stack of the JavaScript being executed, you can call :\n\nThe breakpoint trapped above was set in the extension's code with , which is a convenient way to halt the process at a position in the JavaScript source, allowing you to manually step through the process while dumping the JavaScript stack.\n\nMany problems require tracking the source of a message logged at the \"warning\" or \"critical\" level ( and , respectively). To automatically break at these points, you can set the environment variable to or .\n\nThe breakpoint trapped below was triggered by the same line in the extension's code, but this time with :"
    },
    {
        "link": "https://wiki.gnome.org/Projects/GnomeShell/Extensions",
        "document": "Documenting GNOME Shell Extensions is an ongoing process and some information here may be outdated, incomplete or otherwise inaccurate. Please be patient while we continue to improve it and see the Getting Help section if you have questions that are not answered here.\n\nThe GNOME Shell extension design is designed to give a high degree of power to the parts of the GNOME interface managed by the shell, such as window management and application launching. It simply loads arbitrary JavaScript and CSS. This gives developers a way to make many kinds of changes and share those changes with others, without having to patch the original source code and recompile it, and somehow distribute the patched code.\n\nThe extension system is a replacement for the \"applets\" or \"widgets\" system of GNOME 2. Extensions can add their own items to the top panel, but they can also do much more: adding a custom search provider, for instance. For more information, see this post.\n\nExtensions can be installed from the official GNOME Extensions website, with the help of a WebExtension compatible with Mozilla Firefox and Google Chrome (Chromium) web browsers. See the documentation for your distribution if this was not already installed with GNOME.\n\nMany distributions also have popular GNOME Shell extensions available in their package repositories.\n\nSome extensions may provide a preferences dialog for configuration options or settings. These can be accessed a number of ways:\n• None The Installed page on the GNOME Extensions website\n\nEach of these tools can be used to enable, disable and launch the preferences window of extensions.\n\nAs GNOME Shell and extensions are written in GJS, it is important to understand that GJS is simply JavaScript bindings for the existing GNOME platform APIs. This means many of the classes and functions you will use are already documented in the GNOME API documentation.\n\nThe guides and tutorials for extensions are now available on gjs.guide, including:\n• None\n• None This documentation is best for those already familiar with GObject in C or Python, but unfamiliar with how to use it in JavaScript.\n• None\n• The GJS test suite is probably the most thorough example of available features and usage available.\n• None\n• None This documentation is generated from the same source as the C documentation, but formatted with JavaScript grammar and types.\n• None\n• The GNOME Shell source contains many re-usable classes and functions as well as plenty of examples of how they can be used.\n• None\n• None LookingGlass is a tool that can be used to inspect and debug GNOME Shell while it is running, including point-and-click inspection. It is NOT a stepping debugger like .\n\nAs of GNOME Shell 3.34, there is a new command-line tool for working with extensions:\n\nThese are some older pages, which are likely out of date, but may still contain useful information. These will ultimately either be reviewed and updated, or archived:\n• None Ask on discourse.gnome.org using the extensions tag\n• None Ask on StackOverflow using the gnome-shell-extensions and/or gjs tags\n• Ask in the extensions IRC/Matrix room"
    },
    {
        "link": "https://docs.gtk.org/glib/func.spawn_command_line_async.html",
        "document": "A simple version of that parses a command line with and passes it to g_spawn_async().\n\nRuns a command line in the background. Unlike g_spawn_async(), the flag is enabled, other flags are not. Note that can have security implications, so consider using directly if appropriate. Possible errors are those from and g_spawn_async().\n\nThe same concerns on Windows apply as for g_spawn_command_line_sync()."
    },
    {
        "link": "https://reddit.com/r/gnome/comments/gqvgeu/glibspawn_command_line_sync_performance_question",
        "document": "I've made an extension that handles the output of a given command using . My issue is that this command is run every 10 seconds while also being a little slow. This has resulted in minor lag spikes occurring every ~10 seconds.\n\nIt is not essential that it should run exactly every 10 seconds, it just checks the status of the operations the CLI tool is running. Is there a way to run without the performance impact?\n\nHere is a link to where the command is issued in my extension."
    },
    {
        "link": "https://stackoverflow.com/questions/33911776/gnome-shell-extensions-how-to-run-a-command-with-pipes",
        "document": "So I'm making a Gnome Shell extension. And I want to be able to run some command with a pipe. (The command is actually , but that is off topic)\n\nSo, what I have done so far is\n\nBut it doesn't work! I can't find any example of running a command in a gnome extensions with a pipe.\n\nDo I have to write in the command like I did ?"
    },
    {
        "link": "https://stackoverflow.com/questions/62354264/glib-run-command-with-root-privileges",
        "document": "I'm writing a very simple gnome extension for personal use (in javascript).\n\nI need to run only one command but with root privileges, how can I make something like work?\n\nI would like to use the default gnome dialog for password input.\n\nI read a lot the source code and I found the definition of the dialog but I don't understand how to use it because can't really find a single usage example.\n\nI have no idea how to connect those two things together (the dialog and GLib)."
    },
    {
        "link": "https://askubuntu.com/questions/1502368/detect-that-the-workspace-has-changed",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]