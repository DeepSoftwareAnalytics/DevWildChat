[
    {
        "link": "https://arduino-esp8266.readthedocs.io/en/latest/esp8266wifi/readme.html",
        "document": "ESP8266 is all about Wi-Fi. If you are eager to connect your new ESP8266 module to a Wi-Fi network to start sending and receiving data, this is a good place to start. If you are looking for more in depth details of how to program specific Wi-Fi networking functionality, you are also in the right place.\n\nThe Wi-Fi library for ESP8266 has been developed based on ESP8266 SDK, using the naming conventions and overall functionality philosophy of the Arduino WiFi library. Over time, the wealth of Wi-Fi features ported from ESP8266 SDK to esp8266 / Arduino outgrew Arduino WiFi library and it became apparent that we would need to provide separate documentation on what is new and extra. This documentation will walk you through several classes, methods and properties of the ESP8266WiFi library. If you are new to C++ and Arduino, don’t worry. We will start from general concepts and then move to detailed description of members of each particular class including usage examples. The scope of functionality offered by the ESP8266WiFi library is quite extensive and therefore this description has been broken up into separate documents marked with :arrow_right:. Hopefully, you are already familiar how to load the Blink.ino sketch to an ESP8266 module and get the LED blinking. If not, please use this tutorial by Adafruit or another great tutorial developed by Sparkfun. To hook up the ESP module to Wi-Fi (like hooking up a mobile phone to a hot spot), you need only a couple of lines of code: In the line replace and with the name and password of the Wi-Fi network you would like to connect to. Then, upload this sketch to ESP module and open the serial monitor. You should see something like: How does it work? In the first line of the sketch, we are including the ESP8266WiFi library. This library provides ESP8266 specific Wi-Fi routines that we are calling to connect to the network. The actual connection to Wi-Fi is initialized by calling: The connection process can take couple of seconds and we are checking for whether this has completed in the following loop: The loop will keep looping as long as is other than . The loop will exit only if the status changes to . The last line will then print out the IP address assigned to the ESP module by DHCP: If you don’t see the last line but just more and more dots , then likely name or password to the Wi-Fi network is entered incorrectly in the sketch. Verify the name and password by connecting from scratch to this Wi-Fi network with a PC or a mobile phone. Note: if connection is established, and then lost for some reason, ESP will automatically reconnect to the last used access point once it is again back on-line. This will be done automatically by Wi-Fi library, without any user intervention. That’s all you need to connect ESP8266 to Wi-Fi. In the following chapters we will explain what cool things can be done by the ESP once it’s connected. Devices that connect to Wi-Fi networks are called stations (STA). Connection to Wi-Fi is provided by an access point (AP), that acts as a hub for one or more stations. The access point on the other end is connected to a wired network. An access point is usually integrated with a router to provide access from a Wi-Fi network to the internet. Each access point is recognized by a SSID (Service Set IDentifier), that essentially is the name of network you select when connecting a device (station) to the Wi-Fi. ESP8266 modules can operate as a station, so we can connect it to the Wi-Fi network. It can also operate as a soft access point (soft-AP), to establish its own Wi-Fi network. When the ESP8266 module is operating as a soft access point, we can connect other stations to the ESP module. ESP8266 is also able to operate as both a station and a soft access point mode. This provides the possibility of building e.g. mesh networks. The ESP8266WiFi library provides a wide collection of C++ methods (functions) and properties to configure and operate an ESP8266 module in station and / or soft access point mode. They are described in the following chapters.\n\nIf you like to analyze in detail what is inside of the ESP8266WiFi library, go directly to the ESP8266WiFi folder of esp8266 / Arduino repository on the GitHub. To make the analysis easier, rather than looking into individual header or source files, use one of free tools to automatically generate documentation. The class index in chapter Class Description above has been prepared in no time using great Doxygen, that is the de facto standard tool for generating documentation from annotated C++ sources. The tool crawls through all header and source files collecting information from formatted comment blocks. If developer of particular class annotated the code, you will see it like in examples below. If code is not annotated, you will still see the function prototype including types of arguments, and can use provided links to jump straight to the source code to check it out on your own. Doxygen provides really excellent navigation between members of library. Several classes of ESP8266WiFi are not annotated. When preparing this document, Doxygen has been tremendous help to quickly navigate through almost 30 files that make this library."
    },
    {
        "link": "https://forum.arduino.cc/t/esp8266wifi-library/565702",
        "document": ""
    },
    {
        "link": "https://github.com/esp8266/Arduino",
        "document": "This project brings support for the ESP8266 chip to the Arduino environment. It lets you write sketches, using familiar Arduino functions and libraries, and run them directly on ESP8266, with no external microcontroller required.\n\nESP8266 Arduino core comes with libraries to communicate over WiFi using TCP and UDP, set up HTTP, mDNS, SSDP, and DNS servers, do OTA updates, use a file system in flash memory, and work with SD cards, servos, SPI and I2C peripherals.\n\nStarting with 1.6.4, Arduino allows installation of third-party platform packages using Boards Manager. We have packages available for Windows, Mac OS, and Linux (32 and 64 bit).\n• Enter into the File>Preferences>Additional Boards Manager URLs field of the Arduino IDE. You can add multiple URLs, separating them with commas.\n• Open Boards Manager from Tools > Board menu and install esp8266 platform (and don't forget to select your ESP8266 board from Tools > Board menu after installation).\n\nAlso known as latest git or master branch.\n• When using Arduino IDE, follow our instructions here.\n• When using PlatformIO, refer to platformio/espressif8266 platform documentation.\n\nPlatformIO is an open source ecosystem for IoT development with a cross-platform build system, a library manager, and full support for Espressif (ESP8266) development. It works on the following popular host operating systems: macOS, Windows, Linux 32/64, and Linux ARM (like Raspberry Pi, BeagleBone, CubieBoard).\n• Integration with Cloud and Standalone IDEs - Cloud9, Codeanywhere, Eclipse Che (Codenvy), Atom, CLion, Eclipse, Emacs, NetBeans, Qt Creator, Sublime Text, VIM, Visual Studio, and VSCode\n\nmakeEspArduino is a generic makefile for any ESP8266 Arduino project. Using make instead of the Arduino IDE makes it easier to do automated and production builds.\n\nESP8266 Community Forum is a well-established community for questions and answers about Arduino for ESP8266. Stackoverflow is also an alternative. If you need help, have a \"How do I...\" type question, have a problem with a 3rd party library not hosted in this repo, or just want to discuss how to approach a problem, please ask there.\n\nIf you find the forum useful, please consider supporting it with a donation. \n\n\n\nIf you encounter an issue which you think is a bug in the ESP8266 Arduino Core or the associated libraries, or if you want to propose an enhancement, you are welcome to submit it here on Github: https://github.com/esp8266/Arduino/issues.\n\nPlease provide as much context as possible, as well as the information requested in the issue template:\n• ESP8266 Arduino core version which you are using (you can check it in Boards Manager)\n• your sketch code; please wrap it into a code block, see Github markdown manual\n• when encountering an issue that happens at run time, attach the serial output. Wrap it into a code block, just like the code.\n• for issues that happen at compile time, enable verbose compiler output in the IDE preferences, and attach that output (also inside a code block)\n\nFor minor fixes of code and documentation, please go ahead and submit a pull request. A gentle introduction to the process can be found here.\n\nCheck out the list of issues that are easy to fix — easy issues pending. Working on them is a great way to move the project forward.\n\nLarger changes (rewriting parts of existing code from scratch, adding new functions to the core, adding new libraries) should generally be discussed by opening an issue first. PRs with such changes require testing and approval.\n\nFeature branches with lots of small commits (especially titled \"oops\", \"fix typo\", \"forgot to add file\", etc.) should be squashed before opening a pull request. At the same time, please refrain from putting multiple unrelated changes into a single pull request.\n\nArduino IDE is developed and maintained by the Arduino team. The IDE is licensed under GPL.\n\nESP8266 core includes an xtensa gcc toolchain, which is also under GPL.\n\nEsptool.py was initially created by Fredrik Ahlberg (@themadinventor, @kongo), and is currently maintained by Angus Gratton (@projectgus) under GPL 2.0 license.\n\nEspressif's NONOS SDK included in this build is under Espressif MIT License.\n\nSPI Flash File System (SPIFFS) written by Peter Andersson is used in this project. It is distributed under the MIT license.\n\numm_malloc memory management library written by Ralph Hempel is used in this project. It is distributed under the MIT license.\n\nSoftwareSerial library and examples written by Peter Lerup. Distributed under LGPL 2.1.\n\nBearSSL library written by Thomas Pornin, built from https://github.com/earlephilhower/bearssl-esp8266, is used in this project. It is distributed under the MIT License.\n\nLittleFS library written by ARM Limited and released under the BSD 3-clause license.\n\nuzlib library written and (c) 2014-2018 Paul Sokolovsky, licensed under the ZLib license (https://www.zlib.net/zlib_license.html). uzlib is based on: tinf library by Joergen Ibsen (Deflate decompression); Deflate Static Huffman tree routines by Simon Tatham; LZ77 compressor by Paul Sokolovsky; with library integrated and maintained by Paul Sokolovsky."
    },
    {
        "link": "https://arduino-esp8266.readthedocs.io",
        "document": ""
    },
    {
        "link": "https://github.com/esp8266/Arduino/issues/1869",
        "document": "I dont know what librarie use: ESP8266WebServer or WiFiServer.\n\n What is the difference ?\n\n Why are there two libraries with such similar functions?\n\n I have seen examples that use both libraries and apparently work the same way.\n\nThere is an official documentation on ESP8266 libraries? I have used this link:\n\n http://links2004.github.io/Arduino/index.html\n\nThe heritage of WiFiServer class is the Print class (??)\n\n http://links2004.github.io/Arduino/da/de6/class_wi_fi_server.html\n\n Print --> Server --> WiFiServer ???\n\nIn the documentation I find no reference to ESP8266WiFi.h library, but I have to include it in the sketch.\n\nFinally, should I upgrade both my IDE as the ESP8266 libraries involved?\n\n I am using the Arduino IDE 1.6.7 and version of ESP8266 I do not know where to check.\n\nGrateful for any help!"
    },
    {
        "link": "https://arduino.cc/en/Tutorial/Debounce",
        "document": ""
    },
    {
        "link": "https://e-tinkers.com/2021/05/the-simplest-button-debounce-solution",
        "document": ""
    },
    {
        "link": "https://esp32.com/viewtopic.php?t=10792",
        "document": "Hi ESP32:I think ESP32 is really cool & powerful. Thanks to its dual-core hardware & RTOS(much important then the previous one) I successfully made really something I've been pround of and would like to use. (And may be later I print the circuit and sells it, because my project is really awesome & useful I think)My humboldt stone in the project right now is something about \"user interaction\"-> How to deal with a push-button!Right now I use the single push-button in this project for two different thing: one click: make a gps coordinate snapshot save to sd card, a long press button click for different display mode change. Everything works most of the time. But sometimes for unknown reason it just won't do anything or even worse in some rare chance it will even crash the whole RTOS. This is the original POST describe how the project looks like. Here is the part that I read the button:It can be found inThis is pretty what I've learned from the Arduino World. Because I do not have any hardware debouncing circuit, I have to \"slow down\" the read speed. Yeh, I know its kinda amateur. But this make me wanna ask, why the problem like above happens (push button long reaction time & system crash may happen), and is there still possible without hardware debouncing using GPIO's interrupt routine to handling push button debouncing, and how?Thanks a lot!Gfast2"
    },
    {
        "link": "https://docs.arduino.cc/built-in-examples/digital/Debounce",
        "document": ""
    },
    {
        "link": "https://instructables.com/Simple-Switch-Debouncing-on-ESP8266-ESP32",
        "document": "About: Programmer, Electronics tinkerer, lover of Arduino, ESP8266 and currently building an extensive home automation system for my remote 300-year old farmhouse in France The code works on any ESP8266 or ESP32. Plus of course you will need one or more buttons / switches. Also an LED will allow you to see what your switch is doing.\n\nMany beginners assume that when you press a simple switch it goes on and then goes off when you release it - seems obvious, right? However, because the contacts are made of springy metal, rather than going \"click\" they often go \"boi-oi-oi-oi-ng\" and can switch very rapidly on and off many times before settling in the final state. This phenomenon is known as \"switch bounce\" and is discussed in extreme detail here . The short version is if you hook the switch directly to your code and do not have any \"debouncing\" code, you will get get multiple \"phantom\" presses every time you click it. These can range from none at all (if you are lucky!) to dozens. During testing I had one switch that bounced 37 times for a single press! There are two common methods of switch debouncing: Using hardware, you need external components such as capacitors, resistors and diodes etc and obviously a soldering iron and some degree of electronics knowledge, plus - it does not always work 100% unless you are an engineer (in which case, you already know all this :) Why? because not all switches bounce the same way. Even two switches of identical type from the same batch can behave very differently, so a single one-size-fits-all solution may not work for some particularly bouncy switches. The software method is by far the simplest solution for beginners, especially if someone has already done the hard work for you and written general pupose debouncing code that will work with any switch.\n\nIdentify the longest leg of the LED and connect it to the 220 ohm resistor Connect the other end of the 200 ohm resistor to pin D4 Connect the short leg of the LED to GND Connect one side of the button to D3 Connect the other side of the button to GND\n\nH4Plugins is different from other example code, for example there is no setup function or loop function: the library does all that for you as long as you always include lines 1 and 2 Lines 4 and 5 tell the code which pins you are using. Line 7 defines the LED as an output pin: \"ACTIVE_LOW\" means its is ON when pulled to GND (most builtin-LEDs work this way) and it starts with being OFF Line 8 is where the magic happens. Here we define our BUTTON as a debounced input. The value of 15 milliseconds is just a typical starting value, you need to experiment with this value (see next section) Lines 10-14 are \"glue\" code that H4Plugins needs to connect the debounced input to the function onGPIO where you can then write your own code to react to the debounced button press. Lines 16-21 are where you put your own code. In this simple example we just print the current button state so we can see in the monitor window if it is bouncing. We also set the LED to the same state as the button. If you hold the button down the LED will stay on. Release the button and the LED goes off. When you get the best value for the the number of milliseconds, this will happen once only per press / release. So how do we find the best value?\n\nStep 5: Experiment to Find Best Value for Your Button 15 mS is only a starting point. See the graph above for what this represents. As you reduce it - say 5mS - you may see some bouncing. If the switch bounces for more than 5mS you definitely will. As you increase it, you will greatly decrease the chance of any bouncing, but you will also start to notice a lag between when you press the button and when the LED lights.\n\n\n\nExperiment with the value until you get the lowest value (to reduce lag) that removes all bouncing. You will have to press the button many times to get the right figure as the switch bounce can appear very random: sometimes it will not bounce at all, other times it will bounce like a kangaroo on a trampoline - it all depends on how hard / fast you press and/or release it.\n\n\n\nHave fun finding the best value for each of the switches you will use! When you have got the ideal value, you can then use the code to guarantee that it will only ever get executed ONCE per press or release."
    }
]