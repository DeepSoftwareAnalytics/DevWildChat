[
    {
        "link": "https://docs.unity3d.com/Packages/com.unity.inputsystem@1.5/manual/PlayerInput.html",
        "document": "The Input System provides two related components that simplify how you set up and work with input: the Player Input component and the Player Input Manager component.\n\nThe Player Input component represents a single player, and that player's associated Input Actions, whereas the Player Input Manager component handles setups that allow for several concurrent users (for example, player lobbies and split-screen gameplay in a game).\n\nAbove, the Player Input component as visible in the inspector, with an Actions Asset called \"ExampleActions\" assigned.\n\nEach instance represents a separate player or user. You can use multiple instances at the same time (although not on the same ) to represent local multiplayer setups. The Input System pairs each player to a unique set of Devices that the player uses exclusively, but you can also manually pair Devices in a way that enables two or more players to share a Device (for example, left/right keyboard splits or hot seat use).\n\nEach corresponds to one . You can use to query the from the component.\n\nTo get started using the Player Input component, use the following steps:\n• Add a Player Input component to a GameObject. This would usually be the GameObject that represents the player in your game.\n• Create an Input Actions asset. You can do this by clicking the \"Create Actions...\" button which is visible in the Player Input component inspector if you have not yet assigned actions to it (shown below).\n• When creating the actions asset, Unity asks you where to create the new Asset. Choose a name and folder inside the Assets folder of your Project (or just accept the defaults) and select Okay. This creates a new Asset in your Project, connects it to the Player Input component, and brings up the editor window for the Input Action asset.\n• Configure the Actions Asset so that it contains the actions you want your users to be able to perform, bound to the controls they should use to perform them.\n• Set up Action responses, by selecting a Behaviour type from the Behaviour menu. The Behaviour type you select affects how you should implement the methods that handle your Action responses. See the notification behaviors section further down for details.\n\n\n\n \n\n\n\n\n\nYou can use the following properties to configure :\n\nTo receive input, each player must have an associated set of Input Actions. When you create these via the Player Input inspector's Create Actions button, the Input System creates a default set of Actions. However, the Player Input component places no restrictions on the arrangement of Actions.\n\nThe Player Input component automatically handles enabling and disabling Actions, and also handles installing callbacks on the Actions. When multiple Player Input components use the same Actions, the components automatically create private copies of the Actions.\n\nWhen first enabled, the Player Input component enables all Actions from the the . If no default Action Map exists, the Player Input component does not enable any Actions. To manually enable Actions, you can call and on the Action Maps or Actions, like you would do without . To check which Action Map is currently enabled, or to switch to a different one, use the property. To switch Action Maps with an Action Map name, you can also call .\n\nTo disable a player's input, call . To re-enable it, call . The latter enables the default Action Map, if it exists.\n\nWhen is disabled, it automatically disables the currently active Action Map ( ) and disassociate any Devices paired to the player.\n\nSee the notification behaviors section below for how to be notified when player triggers an Action.\n\nWhen using Send Messages or Broadcast Messages\n\nWhen the notification behavior of is set to Send Messages or Broadcast Messages, you can set your app to respond to Actions by defining methods in components like so:\n\nThe component must be on the same if you are using , or on the same or any child if you are using .\n\nWhen the notification behavior of is set to , each Action has to be routed to a target method. The methods have the same format as the , , and callbacks on .\n\nYou can use the property in the Inspector to determine how a component notifies game code when something related to the player has occurred.\n\nThe following options are available:\n\nIn addition to per-action notifications, sends the following general notifications:\n\nEach can have one or more Devices assigned to it. By default, no two components are assigned the same Devices, but you can force this; to do so, manually assign Devices to a player when calling , or call on the of a .\n\nIf the component has any Devices assigned, it matches these to the Control Schemes in the associated Action Asset, and only enables Control Schemes which match its Input Devices.\n\nThe component can work together with an to drive the UI system.\n\nTo set this up, assign a reference to a component in the field of the component. The and components should be configured to work with the same for this to work.\n\nOnce you've completed this setup, when the component configures the Actions for a specific player, it assigns the same Action configuration to the . In other words, the same Action and Device configuration that controls the player now also controls the UI.\n\nIf you use components to dispatch UI events, you can also use this setup to simultaneously have multiple UI instances on the screen, each controlled by a separate player."
    },
    {
        "link": "https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/manual/QuickStartGuide.html",
        "document": "\n• Getting input directly from an Input Device\n• Getting input indirectly through an Input Action\n\nGetting input directly from an Input Device\n\nThe quickest way to get started in script is to read the current state directly from Input Devices. For example, the following code gets the gamepad that a player last used, and reads its current state:\n\nThe same approach works for other Device types (for example, or ).\n\nGetting input indirectly through an Input Action\n\nTo get input directly through an Input Action, follow these steps:\n\nGetting input directly from an Input Device is quick and convenient, but requires a separate path for each type of Device. That also makes it harder to later change which Device Control triggers a specific event in the game.\n\nAlternatively, you can use Actions as an intermediary between Devices and the in-game responses they trigger. The easiest way to do this is to use the component. To add this component, click the Add Component button in the GameObject Inspector:\n\nEach component represents one player in the game. To receive input, the component must be connected to a set of Input Actions. The quickest way to create a new set of Actions is to click the Create Actions… button in the Inspector window for that component. This creates an Asset pre-populated with a default set of Input Action Maps, Input Actions, and Input Bindings.\n\nWhen you click the Create Actions button, Unity asks you where to create the new Asset. Choose a name and folder inside the folder of your Project (or just accept the defaults) and select Okay. This creates a new Asset in your Project, connects it to the component, and brings up the editor window for files.\n\nYou can edit the default set to fit the needs of your Project. See the in-depth documentation for the Action editor for instructions on how to use this window.\n\nOnce the component has its Actions, you must set up a response for each Action. allows you to set up responses in several ways, using the Behavior property in the Inspector window:\n\nFor more details about the options, see documentation on notification behaviors. The screenshot above uses Invoke Unity Events, which uses in the same way the Unity UI does. Unity displays an event for each Action that is linked to the component. This allows you to directly wire in the target method for each event.\n\nEach method takes an argument that gives access to the Control that triggered the Action and the Action's value. For more information, see documentation on Action callbacks.\n\nThis completes the basic setup using .\n\nThere are ways other than to set up Input Actions. For more information, see documentation on Creating Actions."
    },
    {
        "link": "https://discussions.unity.com/t/using-playerinput-with-c-events/806679",
        "document": ""
    },
    {
        "link": "https://learn.unity.com/tutorial/setting-up-the-input-system-u6",
        "document": "With the release of Unity 6, the new Input System, simply referred to as the Input System, is now the standard for managing player input in Unity projects. The Input System simplifies the process of setting up, configuring, and managing player input through code, making it easier to develop and iterate on user input systems. As of Unity 6, developers are encouraged to use the Input System for all new projects to take full advantage of its advanced features and capabilities."
    },
    {
        "link": "https://docs.unity.cn/Packages/com.unity.inputsystem@1.5/manual/PlayerInput.html",
        "document": "The Input System provides two related components that simplify how you set up and work with input: the Player Input component and the Player Input Manager component.\n\nThe Player Input component represents a single player, and that player's associated Input Actions, whereas the Player Input Manager component handles setups that allow for several concurrent users (for example, player lobbies and split-screen gameplay in a game).\n\nAbove, the Player Input component as visible in the inspector, with an Actions Asset called \"ExampleActions\" assigned.\n\nEach instance represents a separate player or user. You can use multiple instances at the same time (although not on the same ) to represent local multiplayer setups. The Input System pairs each player to a unique set of Devices that the player uses exclusively, but you can also manually pair Devices in a way that enables two or more players to share a Device (for example, left/right keyboard splits or hot seat use).\n\nEach corresponds to one . You can use to query the from the component.\n\nTo get started using the Player Input component, use the following steps:\n• Add a Player Input component to a GameObject. This would usually be the GameObject that represents the player in your game.\n• Create an Input Actions asset. You can do this by clicking the \"Create Actions...\" button which is visible in the Player Input component inspector if you have not yet assigned actions to it (shown below).\n• When creating the actions asset, Unity asks you where to create the new Asset. Choose a name and folder inside the Assets folder of your Project (or just accept the defaults) and select Okay. This creates a new Asset in your Project, connects it to the Player Input component, and brings up the editor window for the Input Action asset.\n• Configure the Actions Asset so that it contains the actions you want your users to be able to perform, bound to the controls they should use to perform them.\n• Set up Action responses, by selecting a Behaviour type from the Behaviour menu. The Behaviour type you select affects how you should implement the methods that handle your Action responses. See the notification behaviors section further down for details.\n\n\n\n \n\n\n\n\n\nYou can use the following properties to configure :\n\nTo receive input, each player must have an associated set of Input Actions. When you create these via the Player Input inspector's Create Actions button, the Input System creates a default set of Actions. However, the Player Input component places no restrictions on the arrangement of Actions.\n\nThe Player Input component automatically handles enabling and disabling Actions, and also handles installing callbacks on the Actions. When multiple Player Input components use the same Actions, the components automatically create private copies of the Actions.\n\nWhen first enabled, the Player Input component enables all Actions from the the . If no default Action Map exists, the Player Input component does not enable any Actions. To manually enable Actions, you can call and on the Action Maps or Actions, like you would do without . To check which Action Map is currently enabled, or to switch to a different one, use the property. To switch Action Maps with an Action Map name, you can also call .\n\nTo disable a player's input, call . To re-enable it, call . The latter enables the default Action Map, if it exists.\n\nWhen is disabled, it automatically disables the currently active Action Map ( ) and disassociate any Devices paired to the player.\n\nSee the notification behaviors section below for how to be notified when player triggers an Action.\n\nWhen using Send Messages or Broadcast Messages\n\nWhen the notification behavior of is set to Send Messages or Broadcast Messages, you can set your app to respond to Actions by defining methods in components like so:\n\nThe component must be on the same if you are using , or on the same or any child if you are using .\n\nWhen the notification behavior of is set to , each Action has to be routed to a target method. The methods have the same format as the , , and callbacks on .\n\nYou can use the property in the Inspector to determine how a component notifies game code when something related to the player has occurred.\n\nThe following options are available:\n\nIn addition to per-action notifications, sends the following general notifications:\n\nEach can have one or more Devices assigned to it. By default, no two components are assigned the same Devices, but you can force this; to do so, manually assign Devices to a player when calling , or call on the of a .\n\nIf the component has any Devices assigned, it matches these to the Control Schemes in the associated Action Asset, and only enables Control Schemes which match its Input Devices.\n\nThe component can work together with an to drive the UI system.\n\nTo set this up, assign a reference to a component in the field of the component. The and components should be configured to work with the same for this to work.\n\nOnce you've completed this setup, when the component configures the Actions for a specific player, it assigns the same Action configuration to the . In other words, the same Action and Device configuration that controls the player now also controls the UI.\n\nIf you use components to dispatch UI events, you can also use this setup to simultaneously have multiple UI instances on the screen, each controlled by a separate player."
    },
    {
        "link": "https://discussions.unity.com/t/new-input-system-check-if-a-key-was-pressed/804737",
        "document": ""
    },
    {
        "link": "https://gamedevdustin.medium.com/the-any-key-problem-with-the-new-input-system-for-simultaneous-input-detection-in-unity-2023-1-e436226d4818",
        "document": "TLDR\n\nIn the new Input System, the “Any Key” does not pass the name of the key that was pressed, which sucks.\n\nThe “Any Key” also fails to work accurately for detecting simultaneous keypresses when used as the trigger for checking keypress input.\n\nAs shown above when the Y, U, I, and O keys were pressed simultaneously, button states and entire buttons were missed!\n\nThe Solution is Brute Force\n\nIf you absolutely *MUST* detect all keyboard input, including up to 4 simultaneous keypresses or more, you have to accept the performance trade off of checking every key’s state every Update() frame.\n\nIt is probably best to use a for loop rather than a foreach loop to regain some of the lost performance.\n\nFor the details on how I came to this conclusion, please read on.\n\nSummary\n\nIn this article I want to briefly cover an issue I ran into while working with the new input system.\n\nBut first, why was I using the “Any key” binding in the first place?\n\nI thought that this binding would pass the name of the key pressed.\n\nIt did not.\n\nWhat was the alternative then?\n\nBind every key individually?\n\n \n\nYep, but that still had issues with simultaneous keypresses and their button states registering.\n\nSo that ended my attempts to address simultaneous keypress input through the Input Action Asset.\n\nFrom now on, it would be code only using the new Input System’s functions.\n\nThe Event Driven Input Actions Asset Approach\n\nI originally took the Input Actions Asset approach with an Action that was bound to “Any key” for detecting all keyboard input.\n\nApologies that I don’t have a screenshot of the Input Actions Asset in the Unity Editor, but the related code is shown above.\n\nThis is where the issue first cropped up.\n\n \n\nYou cannot get what key was pressed from an “Any Key” binding in the Input Actions Asset.\n\nThe InputAction.CallbackContext simply does not pass the name of the key when the binding is “Any key”.\n\nSo, as a workaround, when the “Any Key” binding was triggered in the Input Actions Asset, I checked what key was pressed that frame by checking literally every key with a foreach loop.\n\nWhile this worked for one key at a time or maybe two simultaneously, anything beyond that started to miss either button phase events (Start, Cancelled) or entire buttons.\n\nThe results were as shown above.\n\nWhen pressing Y, U, I, and O keys simultaneously, the debug logs from the InputDataCollection class only showed that Y was pressed (started) and that O was released (cancelled).\n\n \n\nIt missed a button state for both of the 2 keys it did register, and it didn’t register 2 other keys entirely!\n\nThis can be seen by the debug logs being reported of keypresses from the old Input System class that was being phased out for the new Input System.\n\nNote that the old input system did not report released / canceled states so we only get logs of the keypress in general for comparison’s sake.\n\nThe new input system debug logs are shown as full width above, while the old input system starts with “OnKeyPressDown”.\n\nThe Update() Approach with “Any key”\n\nAt this point, I was still hoping to make use of the “Any key” as a trigger in order to avoid checking all keypress input on frames when none has occurred.\n\nUsing “Keyboard.current” functionality from the new Input System, I checked the “Any key” every Update() frame.\n\nThis had the same issues shown in the debug logs earlier in this article with hit or miss detection.\n\nTesting the Check Every Key Every Update() Frame Approach\n\nAt this point I tested whether individual checking every Update() frame would correctly report simultaneous input.\n\nI had avoided this up until now with the hopes of not impacting performance with so many keypress checks since one of my use-case requirements is getting literally all keypress input on any keyboard.\n\nFor this testing though, I only set up the Y, U, I, and O keys which I then tested with simultaneous keypresses.\n\nSometimes Brute Force is What it Takes\n\nAs mentioned at the beginning of this article, when you absolutely have to catch all keyboard input including simultaneous input of up to 4 keys (perhaps more), than you just have to bite the performance bullet.\n\nKeyboard.current functions from the new Input System do the trick, but only have to button states.\n\nThese are pressed and released which correlate to Started and Canceled when using the Input Action Asset’s bindings.\n\nI hope this saves someone else a day or more’s work trying to work out issues with simultaneous keypress tracking!"
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/202101/how-does-one-detect-a-button-release-with-unitys-new-input-system",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://docs.unity3d.com/Manual/class-InputManager.html",
        "document": "The Input Manager window allows you to define input axes and their associated actions for your Project. To access it, from Unity’s main menu, go to Edit > Project Settings, then select Input Manager from the navigation on the right.\n\nThe Input Manager uses the following types of controls:\n• Key refers to any key on a physical keyboard, such as W, Shift, or the space bar.\n• Button refers to any button on a physical controller (for example, gamepads), such as the X button on a remote control.\n• A virtual axis (plural: axes) is mapped to a control, such as a button or a key. When the user activates the control, the axis receives a value in the range of [–1..1]. You can use this value in your scripts \n\n A piece of code that allows you to create your own Components, trigger game events, modify Component properties over time and respond to user input in any way you like. More info .\n\nThe Physical keys option allows you to map key codes to the physical keyboard layout, rather than to the language-specific layout that may vary between users in different regions.\n\nFor example, on some keyboards the first row of letters reads “QWERTY”, and on others it reads “AZERTY”. This means if you scripted specific controls to use the well known “WASD” keys for movement, they would not be in the correct physical arrangement (like the arrow-key arrangement) on an AZERTY-layout keyboard.\n\nWith Physical Keys enabled, Unity uses a generic ANSI/ISO “Qwerty” layout to represent the physical location of the keys regardless of the user’s actual layout. This means if you specify the “Q” key, it will always be the left-most letter on the first row of letter keys, even if the user’s keyboard has a different letter in that position.\n\nNote, you should not read key input for in-game text input, because this will not allow users to enter non-Latin characters. Instead, use .\n\nEvery Project you create has a number of input axes created by default. These axes enable you to use keyboard, mouse, and joystick input in your Project straight away.\n\nTo see more about these axes, open the Input Manager window, and click the arrow next to any axis name to expand its properties.\n\nEach input axis has the following properties:\n• Between –1 and 1 for joystick and keyboard input. The neutral position for these axes is 0. Some types of controls, such as buttons on a keyboard, aren’t sensitive to input intensity, so they can’t produce values other than –1, 0, or 1.\n• Mouse delta (how much the mouse has moved during the last frame) for mouse input. The values for mouse input axes can be larger than 1 or smaller than –1 when the user moves the mouse quickly.\n\nTo add a virtual axis, increase the number in the Size field. This creates a new axis at the bottom of the list. The new axis copies the properties of the previous axis in the list.\n\nTo remove a virtual axis, you can either:\n• Decrease the number in the Size field. This removes the last axis in the list.\n• Right-click any axis, and select Delete Array Element.\n\n Note: You can’t undo this action.\n\nTo copy a virtual axis, right-click it and select Duplicate Array Element.\n\nTo map a key or button to an axis, enter its name in the Positive Button or Negative Button property in the Input Manager.\n\nMouse buttons are named and so on.\n\nYou can also query input for a specific key or button with and the naming conventions specified above. For example:\n\nAnother way to access keys is to use the enumeration.\n\nTo access virtual axes from scripts, you can use the axis name.\n\nFor example, to query the current value of the Horizontal axis and store it in a variable, you can use like this:\n\nFor axes that describe an event rather than a movement (for example, firing a weapon in a game), use instead.\n\nIf two or more axes have the same name, the query returns the axis with the largest absolute value. This makes it possible to assign more than one input device to an axis name.\n\nFor example, you can create two axes named Horizontal and assign one to keyboard input and the other to joystick input. If the user is using the joystick, input comes from the joystick and keyboard input is null. Otherwise, input comes from the keyboard and joystick input is null. This enables you to write a single script that covers input from multiple controllers.\n\nYou can use input from the Horizontal and Vertical axes and the method to move a GameObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary in XZ space (forward, back, left, or right). Add the following code to the method on a script attached to the GameObject you want to move:\n\nrepresents the time that passed since the last frame. Multiplying the variable by ensures that the GameObject moves at a constant speed every frame."
    },
    {
        "link": "https://discussions.unity.com/t/new-input-system-how-to-use-the-hold-interaction/726823",
        "document": ""
    }
]