[
    {
        "link": "https://docs.aiogram.dev/en/v2.25.1",
        "document": "aiogram is a pretty simple and fully asynchronous framework for Telegram Bot API written in Python 3.7 with asyncio and aiohttp. It helps you to make your bots faster and simpler.\n• None Can reply into webhook. (In other words make requests in response to updates)"
    },
    {
        "link": "https://docs.aiogram.dev/_/downloads/en/v2.25.1/pdf",
        "document": ""
    },
    {
        "link": "https://docs.aiogram.dev/en/v2.25.1/telegram/bot.html",
        "document": "Instructions how to get Bot token is found here: https://core.telegram.org/bots#3-how-do-i-create-a-bot"
    },
    {
        "link": "https://github.com/aiogram/aiogram",
        "document": "aiogram is a modern and fully asynchronous framework for Telegram Bot API written in Python 3.8+ using asyncio and aiohttp.\n\nMake your bots faster and more powerful!\n• Has type hints (PEP 484) and can be used with mypy\n• Supports Telegram Bot API 8.3 and gets fast updates to the latest versions of the Bot API\n• Telegram Bot API integration code was autogenerated and can be easily re-generated when API gets updated\n\nIt is strongly advised that you have prior experience working with asyncio before beginning to use aiogram. If you have any questions, you can visit our community chats on Telegram:"
    },
    {
        "link": "https://docs.aiogram.dev",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://psycopg.org/docs/usage.html",
        "document": "The basic Psycopg usage is common to all the database adapters implementing the DB API 2.0 protocol. Here is an interactive session showing some of the basic commands:\n\nThe main entry points of Psycopg are:\n• None The function creates a new database session and returns a new instance.\n• None The class encapsulates a database session. It allows to:\n• None create new instances using the method to execute database commands and queries,\n• None terminate transactions using the methods or .\n• None The class allows interaction with the database:\n• None send commands to the database using methods such as and ,\n• None retrieve data from the database by iteration or using methods such as , , .\n\nPsycopg converts Python variables to SQL values using their types: the Python type determines the function used to convert the object into a string representation suitable for PostgreSQL. Many standard Python types are already adapted to the correct SQL representation. Passing parameters to an SQL statement happens in functions such as by using placeholders in the SQL statement, and passing a sequence of values as the second argument of the function. For example the Python function call: is converted into a SQL command similar to: Named arguments are supported too using placeholders in the query and specifying the values into a mapping. Using named arguments allows to specify the values in any order and to repeat the same value in several places in the query: Using characters , , in the argument names is not supported. When parameters are used, in order to include a literal in the query you can use the string: While the mechanism resembles regular Python strings manipulation, there are a few subtle differences you should care about when passing parameters to a query.\n• None The Python string operator must not be used: the method accepts a tuple or dictionary of values as second parameter. Never use or to merge values into queries:\n• None For positional variables binding, the second argument must always be a sequence, even if it contains a single variable (remember that Python requires a comma to create a single element tuple):\n• None The placeholder must not be quoted. Psycopg will add quotes where needed:\n• None The variables placeholder must always be a , even if a different placeholder (such as a for integers or for floats) may look more appropriate:\n• None Only query values should be bound via this method: it shouldn’t be used to merge table or field names to the query (Psycopg will try quoting the table name as a string value, generating invalid SQL). If you need to generate dynamically SQL queries (for instance choosing dynamically a table name) you can use the facilities provided by the module: The problem with the query parameters¶ The SQL representation of many data types is often different from their Python string representation. The typical example is with single quotes in strings: in SQL single quotes are used as string literal delimiters, so the ones appearing inside the string itself must be escaped, whereas in Python single quotes can be left unescaped if the string is delimited by double quotes. Because of the difference, sometime subtle, between the data types representations, a naïve approach to query strings composition, such as using Python strings concatenation, is a recipe for terrible problems: ProgrammingError: syntax error at or near \"Reilly\" If the variables containing the data to send to the database come from an untrusted source (such as a form published on a web site) an attacker could easily craft a malformed string, either gaining access to unauthorized data or performing destructive operations on the database. This form of attack is called SQL injection and is known to be one of the most widespread forms of attack to database servers. Before continuing, please print this page as a memo and hang it onto your desk. Psycopg can automatically convert Python objects to and from SQL literals: using this feature your code will be more robust and reliable. We must stress this point: Never, never, NEVER use Python string concatenation ( ) or string parameters interpolation ( ) to pass variables to a SQL query string. Not even at gunpoint. The correct way to pass variables in a SQL command is using the second argument of the method: Unlike in Python, the backslash ( ) is not used as an escape character except in patterns used with and where they are needed to escape the and characters. This can lead to confusing situations: 'SELECT * FROM mytable WHERE path LIKE The solution is to specify an character of (empty string) in your query: \"SELECT * FROM mytable WHERE path LIKE\n\nIn Psycopg transactions are handled by the class. By default, the first time a command is sent to the database (using one of the s created by the connection), a new transaction is created. The following database commands will be executed in the context of the same transaction – not only the commands issued by the first cursor, but the ones issued by all the cursors created by the same connection. Should any command fail, the transaction will be aborted and no further command will be executed until a call to the method. The connection is responsible for terminating its transaction, calling either the or method. Committed changes are immediately made persistent in the database. If the connection is closed (using the method) or destroyed (using or by letting it fall out of scope) while a transaction is in progress, the server will discard the transaction. However doing so is not advisable: middleware such as PgBouncer may see the connection closed uncleanly and dispose of it. It is possible to set the connection in autocommit mode: this way all the commands executed will be immediately committed and no rollback is possible. A few commands (e.g. , , on stored procedures using transaction control…) require to be run outside any transaction: in order to be able to run these commands from Psycopg, the connection must be in autocommit mode: you can use the property. By default even a simple will start a transaction: in long-running programs, if no further action is taken, the session will remain “idle in transaction”, an undesirable condition for several reasons (locks are held by the session, tables bloat…). For long lived scripts, either make sure to terminate a transaction as soon as possible or use an autocommit connection. A few other transaction properties can be set session-wide by the : for instance it is possible to have read-only transactions or change the isolation level. See the method for all the details. Starting from version 2.5, psycopg2’s connections and cursors are context managers and can be used with the statement: When a connection exits the block, if no exception has been raised by the block, the transaction is committed. In case of exception the transaction is rolled back. When a cursor exits the block it is closed, releasing any resource eventually associated with it. The state of the transaction is not affected. A connection can be used in more than one statement and each block is effectively wrapped in a separate transaction: Unlike file objects or other resources, exiting the connection’s block doesn’t close the connection, but only the transaction associated to it. If you want to make sure the connection is closed after a certain point, you should still use a try-catch block: Changed in version 2.9: starts a transaction also on autocommit connections.\n\nWhen a database query is executed, the Psycopg usually fetches all the records returned by the backend, transferring them to the client process. If the query returns a huge amount of data, a proportionally large amount of memory will be allocated by the client. If the dataset is too large to be practically handled on the client side, it is possible to create a server side cursor. Using this kind of cursor it is possible to transfer to the client only a controlled amount of data, so that a large dataset can be examined without keeping it entirely in memory. Server side cursor are created in PostgreSQL using the command and subsequently handled using , and commands. Psycopg wraps the database server side cursor in named cursors. A named cursor is created using the method specifying the name parameter. Such cursor will behave mostly like a regular cursor, allowing the user to move in the dataset using the method and to read the data using and methods. Normally you can only scroll forward in a cursor: if you need to scroll backwards you should declare your cursor . Named cursors are also iterable like regular cursors. Note however that before Psycopg 2.4 iteration was performed fetching one record at time from the backend, resulting in a large overhead. The attribute now controls how many records are fetched at time during the iteration: the default value of 2000 allows to fetch about 100KB per roundtrip assuming records of 10-20 columns of mixed number and strings; you may decrease this value if you are dealing with huge records. Named cursors are usually created , meaning they live only as long as the current transaction. Trying to fetch from a named cursor after a or to create a named cursor when the connection is in mode will result in an exception. It is possible to create a cursor by specifying a value for the parameter to or by setting the attribute to before calling on the cursor. It is extremely important to always such cursors, otherwise they will continue to hold server-side resources until the connection will be eventually closed. Also note that while cursors lifetime extends well after , calling will automatically close the cursor. It is also possible to use a named cursor to consume a cursor created in some other way than using the executed by . For example, you may have a PL/pgSQL function returning a cursor: You can read the cursor content by calling the function with a regular, non-named, Psycopg cursor: and then use a named cursor in the same transaction to “steal the cursor”: # do something with record\n\nThe Psycopg module and the objects are thread-safe: many threads can access the same database either using separate sessions and creating a per thread or using the same connection and creating separate s. In DB API 2.0 parlance, Psycopg is level 2 thread safe. The difference between the above two approaches is that, using different connections, the commands will be executed in different sessions and will be served by different server processes. On the other hand, using many cursors on the same connection, all the commands will be executed in the same session (and in the same transaction if the connection is not in autocommit mode), but they will be serialized. The above observations are only valid for regular threads: they don’t apply to forked processes nor to green threads. connections shouldn’t be used by a forked processes, so when using a module such as or a forking web deploy method such as FastCGI make sure to create the connections after the fork. Connections shouldn’t be shared either by different green threads: see Support for coroutine libraries for further details.\n\nPsycopg exposes the two-phase commit features available since PostgreSQL 8.1 implementing the two-phase commit extensions proposed by the DB API 2.0. The DB API 2.0 model of two-phase commit is inspired by the XA specification, according to which transaction IDs are formed from three components: For a particular global transaction, the first two components will be the same for all the resources. Every resource will be assigned a different branch qualifier. According to the DB API 2.0 specification, a transaction ID is created using the method. Once you have a transaction id, a distributed transaction can be started with , prepared using and completed using or . Transaction IDs can also be retrieved from the database using and completed using the above and . PostgreSQL doesn’t follow the XA standard though, and the ID for a PostgreSQL prepared transaction can be any string up to 200 characters long. Psycopg’s objects can represent both XA-style transactions IDs (such as the ones created by the method) and PostgreSQL transaction IDs identified by an unparsed string. The format in which the Xids are converted into strings passed to the database is the same employed by the PostgreSQL JDBC driver: this should allow interoperation between tools written in Python and in Java. For example a recovery tool written in Python would be able to recognize the components of transactions produced by a Java program. For further details see the documentation for the above methods."
    },
    {
        "link": "https://stackoverflow.com/questions/17261061/execute-sql-schema-in-psycopg2-in-python",
        "document": "You can just use :\n\nthough you may want to set psycopg2 to mode first so you can use the script's own transaction management.\n\nIt'd be nice if psycopg2 offered a smarter mode where it read the file in a statement-at-a-time and sent it to the DB, but at present there's no such mode as far as I know. It'd need a fairly solid parser to do it correctly when faced with quoting (and its variant where the deimiter may be any identifier), , strings, nested function bodies, etc.\n\nNote that this will not work with:\n\n... and therefore won't work with dumps from"
    },
    {
        "link": "https://geeksforgeeks.org/executing-sql-query-with-psycopg2-in-python",
        "document": "In this article, we are going to see how to execute SQL queries in PostgreSQL using Psycopg2 in Python.\n\nPsycopg2 is a PostgreSQL database driver, it is used to perform operations on PostgreSQL using python, it is designed for multi-threaded applications. SQL queries are executed with psycopg2 with the help of the execute() method. It is used to Execute a database operation query or command.\n\nParameters can be provided in the form of a sequence or a mapping, and they’ll be tied to variables in the operation. Positional ( % s) or named ( % (name)s) placeholders are used to specify variables. execute() method returns “none” if the query is properly executed (without errors)."
    },
    {
        "link": "https://wiki.postgresql.org/wiki/Using_psycopg2_with_PostgreSQL",
        "document": "Psycopg2 is a mature driver for interacting with PostgreSQL from the Python scripting language. It is written in C and provides a means to perform the full range of SQL operations against PostgreSQL databases. This page is focused on version 2 of the driver, only.\n• Multiple connections / connection objects (Does not force the use of a singleton)\n• Connection pooling (example to be added later)\n\nThis page was originally developed by Bendermott, with contributions from Jonjensen and others. The cookbook style remains, however the page is under development to modernize for Python 3. To see the Python 2 specific examples, use this last version from 2015.\n\nI will not assume you are perfectly familiar with Python in the below examples; therefore I have provided an excessive amount of comments and each example is a full-fledged script instead of just a snippet.\n\nYou may want to copy the examples into your favorite code editor for syntax highlighting!\n\nAll code examples were tested on Python 2.6 running OpenSUSE Linux.\n\nConnect to the Postgres Database using authentication. Catch and print a connection error if one occurs.\n\nThis example shows how to connect to a database, and then obtain and use a cursor object to retrieve records from a table.\n\nIn this example we will assume your database is named \"my_database\" in the public schema and the table you are selecting from is named \"my_table\".\n\n# print the connection string we will use to connect # get a connection, if a connect cannot be made an exception will be raised here # conn.cursor will return a cursor object, you can use this cursor to perform queries # retrieve the records from the database # print out the records using pretty print # note that the NAMES of the columns are not shown, instead just indexes. # for most people this isn't very useful so we'll show you how to return # columns as a dictionary (hash) in the next example.\n\nIn this example we will perform a select just like we did above but this time we will return columns as a Python Dictionary so column names are present.\n\nWe will also use Psycopg2's prinf-style variable replacement, as well as a different fetch method to return a row (fetchone).\n\n#note that we have to import the Psycopg2 extras library! # print the connection string we will use to connect # get a connection, if a connect cannot be made an exception will be raised here # conn.cursor will return a cursor object, you can use this query to perform queries # note that in this example we pass a cursor_factory argument that will # dictionary cursor so COLUMNS will be returned as a dictionary so we # can access columns by their name instead of index. # tell postgres to use more work memory # by passing a tuple as the 2nd argument to the execution function our # %s string variable will get replaced with the order of variables in # the list. In this case there is only 1 variable. # Note that in python you specify a tuple with one item in it by placing # a comma after the first variable and surrounding it in parentheses. # Then we get the work memory we just set -> we know we only want the # first ROW so we call fetchone. # then we use bracket access to get the FIRST value. # Note that even though we've returned the columns by name we can still # access columns by numeric index as well - which is really nice. # Call fetchone - which will fetch the first row returned from the # even though we enabled columns by name I'm showing you this to # show that you can still access columns by index and iterate over them.\n\nIf you have an extremely large result set to retrieve from your database, or you would like to iterate through a tables records without first retrieving the entire table a cursor is exactly what you need.\n\nA cursor keeps the database connection open and retrieves database records 1 by 1 as you request them.\n\nThere are several ways to accomplish this in Psycopg2, I will show you the most basic example.\n\nFor advanced usage see the documentation on the use of cursor.scroll() see:\n\n#note that we have to import the Psycopg2 extras library! # print the connection string we will use to connect # HERE IS THE IMPORTANT PART, by specifying a name for the cursor # psycopg2 creates a server-side cursor, which prevents all of the # records from being downloaded at once from the server. # Because cursor objects are iterable we can just call 'for - in' on # the cursor object and the cursor will automatically advance itself # This loop should run 1000 times, assuming there are at least 1000"
    },
    {
        "link": "https://datacamp.com/tutorial/tutorial-postgresql-python",
        "document": "Master the basics of data analysis with Python in just four hours. This online course will introduce the Python interface and explore popular packages."
    }
]