[
    {
        "link": "https://dev.to/adnanbabakan/implement-uuid-primary-key-in-laravel-and-its-benefits-55o3",
        "document": "It's been a long time since I've last written here.\n\nDuring the time that I've been absent, I've been working on some large-scale projects in which I've seen how UUIDs can benefit your application in multiple ways.\n\nI've been using UUIDs as my primary key structure for a fair amount of time now but the real advantages have shown themselves after finishing the projects and I am glad I've decided to do so.\n\nI primarily use Laravel as my back-end and love using MySQL (I know there are lots of other RDBMS/DBMS out there but I love MySQL and feel comfortable with it XD). Although when using MySQL or many other databases your primary key is set as an AI (auto-incremental) and the data type is an integer, you may use UUID with a few tweaks and believe me it's worth the hassle.\n\nAn enumeration exploit is when your data is predictable. Let's say for instance you upload a video on YouTube which is hidden from the public and can only be viewed by those whom you shared the link with. Well, Let's look at a YouTube link:\n\nAs you can see the address ends in which indicates the (let's say) ID of the video. So imagine YouTube used a numerical index and incremented it one by one for each video uploaded. Then what you might ask. In that case, someone could start from number 1 and try every link using a custom-made program to extract all the available videos on YouTube and your link-only video would be exposed as well.\n\nThis is called enumeration exploiting which can cause serious data leaks depending on what your program is supposed to do.\n\nThe algorithm YouTube uses to make IDs for their videos is custom, but the purpose of my description is the same for UUIDs.\n\nGiven a UUID such as , you wouldn't know what UUID is before or after this since there is no order. As you can see this can solve the enumeration exploit in your application.\n\nLet's imagine that you have two database instances of the same system that you want to expand or just make a new cluster for some reason and then merge both instances. Given that the database structure is the same and you have complicated relations in your database you might find it difficult to merge data without adjusting some values manually or with an automated task.\n\nAs you can see in the simple diagram above of an abstract database, your might have a table of orders which is related to both a product and a user.\n\nNow let's think about this: In each of your database instances you only have 10 users and 10 products and 10 orders which are numerically indexed from 1 to 10. Let's say in our first database instance order 2 is related to user 3 whose name is . In the other instance, order 2 is related to use 3 as well but their name is . Even if we import the orders properly and their IDs aren't referenced from other tables and their indexes are reassigned from 1 to 20, since the users are reindexed as well now our orders reference wrong users!\n\nI suppose you see the problem and solution now. If we use UUIDs, since they are globally unique there will be no collision between our data and we can merge as many instances as we want with no problem.\n\nApart from merging two databases, UUIDs make it easier to manage a cluster-based database architecture as well with multiple database instances running at the same time.\n\nThere are two main downsides to using UUIDs in databases. First is the size it takes in your database and second is the insert problem.\n\nSince UUIDs aren't ordered performing an insert operation becomes costly because your record will be inserted somewhere random rather than at the end of your table when using a numerical index system.\n\nEven though these disadvantages are present, it is forgivable as space isn't that expensive and the insert problem isn't such a big deal for most cases.\n\nThere is a way to avoid the insert problem which is using the same numerical index system as before but assigning a separate UUID for each record as well so you benefit from the points aforementioned.\n\nIn this section of the article, I will discuss how you can implement UUIDs in your Laravel application and the problems I faced and how I solved them. Remember that UUIDs are NOT for Laravel/MySQL only and you may use them in any other programming language, framework and database you like.\n\nKeep in mind this is my preferred way of implementing such an approach and you might find a more efficient way, and let me know in the comments if you did so.\n\nThe first thing you need to do is know how to define your migrations so your tables use UUID.\n\nFortunately, Laravel comes packed with many good methods and stuff to help you with your goal.\n\nFirst of all, let's change how we define our PK (primary key) in a migration. This is how you usually define your PK in a Laravel migration:\n\nThe code above is equivalent of:\n\nUnfortunately, there is no shorthand method for creating a UUID-based PK in migrations. But it isn't that much of a work either:\n\nTADA! Now your table will have a column named which holds UUIDs.\n\nNow let's talk about relations. A relation is when you want to reference a different record from another table or the same table. Referencing is done using the target record's id since it is the unique key that you are sure will never be duplicated.\n\nImagine you want to reference a user in your table, this is how you define a normal relation in your migrations:\n\nKeep in mind the method is a shorthand for:\n\nLaravel gives you the power of the shorthand at the cost of following naming conventions. So when your foreign id column is named and is called afterwards, Laravel knows you mean that this will reference the column on the table. If it is not the case you must define it using the and the methods to specifically determine what you mean.\n\nTo reference a foreign id which is a UUID, you may use the method instead of method. The rest is the same and you can apply to a foreign UUID reference as well. This is how you reference a user record given that the table utilizes UUID as its PK structure.\n\nNow that you've successfully defined your migrations, there is a small tweak you need to make on your models.\n\nA model's defaults tell it to utilize integer-based ids and we should tell the model that it is not the case.\n\nFirst, add a private property named to your model and set its value as :\n\nThis tells the model that your key is a type of string and not an integer (UUIDs are strings).\n\nThe second thing to do is tell the model not to use the incrementing system for this type of key which is done by setting the property as :\n\nAfter doing these your model know how your PK works perfectly.\n\nBut wait! Is there a problem you face when creating a new record telling you that cannot be null and doesn't have a default value?\n\nTo solve this issue either you have to define a UUID each time you create a new record such as below:\n\nThe class is imported from . The helper creates a new UUID for you.\n\nOr you can use model events to tell Laravel how to create an ID for your model when creating the record on the database.\n\nThis can be done simply by using closure events in your method. Add a static method called to your model:\n\nThen you can use an event called inside of it and tell it to make a UUID and assign it to your model's id:\n\nYou can read more about model events at https://laravel.com/docs/10.x/eloquent#events-using-closures\n\nIf you are using the old method, remember to call the parent's method so it is not overwritten:\n\nIf you've followed so far, your model or any other model should look something like this:\n\nIf you try to use Sanctum to issue your tokens you might realize that you face an error telling you that your constraints fail. This is because your table is designed to reference integer-based foreign ids (this table uses morphs as it should be able to reference multiple types of models).\n\nIn case you already have a project running you should change the column's type in your table using a new migration.\n\nThen in your migration use the method on the column:\n\nThis changes the data type of to reference UUIDs instead of integers.\n\nTo make our database structure unified I'd like to make my token records use UUID as their ids as well so add the instruction below as well:\n\nIf you receive an error running this migration install the package using composer.\n\nAlthough the method described above is the proper way to change the data type of the column, there is a simpler way of doing so if you are just starting a new project or you don't care about your current data and are willing to refresh your migration (which will delete your data).\n\nJust open the file (the date at the beginning might differ) and change:\n\nif you've already run your migrations before.\n\nNow that our can reference UUIDs and its id is also a UUID we need to make Laravel know how to treat our tokens as Sanctum uses a default model to handle these records.\n\nFirst, let's create a new model that will be the model Sanctum uses since we've changed the structure:\n\nNow open the created model's file and instead of extending the class, extend the class by :\n\nSince our class has the same name as the class used by Sanctum's default PersonalAccessToken class, you should either define an alias when importing it or use absolute naming after the keyword like:\n\nWe have to make sure Laravel knows how this model works just as before. So we should set , and define an event to create a UUID for the id of each record.\n\nThis is how your final model should look like:\n\nThe last step is to define this model as the model used by Sanctum. This step can be done by using the method. This method should be called in a provider file. I prefer which is located at .\n\nOpen the provider file and add the code below inside of the method:\n\nRemember to import and your custom classes properly. The class is imported from and your custom is imported from .\n\nAnd now you are done implementing UUIDs in your Laravel application!\n\nI hope you enjoyed this article and it helped you do what you wanted to do. Kindly let me know if there are any mistakes in this article or if you know a better way to do something.\n\nBTW! Check out my free Node.js Essentials E-book here:"
    },
    {
        "link": "https://laracasts.com/discuss/channels/laravel/change-auto-increment-id-to-uuid-in-production",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/laravel/comments/18rf1ay/migrating_from_ids_to_uuids_is_a_pain",
        "document": "In one of my projects, I'm migrating from ids (UNSIGNED INT AUTO_INCREMENT) to ulids/uuids (char(26) or char(36)). The reason why is not the subject of my post.\n\nI just wanted to discuss if you can find solutions or possibly PRs to fix some issues I encountered.\n\nTo add context, I want to keep a good migration system as I'm working on an open source project so I never know on which versions actual maintainers of forks are.\n\nIn my create_*_table migrations, I was using foreignIdFor(Model::class) but it turns out, there's no foreignUuidFor and for a good reason, foreignIdFor already guess if you are using ids or uuids. Turns out, it breaks my migrations.\n\nJust to explain the whole process:\n\nYou are on version A with ids, on point B, I add some new tables with foreignIdFor on previously defined models, so still using ids, on point C, I switch from ids to uuids, so I remove model_id tables and I want to use model_uuid column instead (yes I'm that kind of guy :/). Now if you want to upgrade, you take new version (C) and if you try to migrate, point B will not add _id columns and will crash because old models table defined on A are using ids, but models are saying uuids so foreign columns are now defined in char and not unsigned int so MySQL refuses to create the foreign link as both columns are nos the same type.\n\nI made it work using Blueprint::foreignId() instead of foreignIdFor() but I encontered the same issue with morphs() which is trying to guess which type of keys you are using... So once again I have to look at the code and use numericMorphs and uuidMorphs instead.\n\nMaybe I'm all wrong but as far as I know, the only solution to prevent that kind of issues is to break those methods and stop guessing the type based on the model as it may not reflect the state of the code when the migration was created. We should then have like foreignUuidFor? Or maybe I'm just dumb to use the recommended methods at first and should have used straight away the ones not in the documentation."
    },
    {
        "link": "https://laravel.com/docs/12.x/migrations",
        "document": "Migrations are like version control for your database, allowing your team to define and share the application's database schema definition. If you have ever had to tell a teammate to manually add a column to their local database schema after pulling in your changes from source control, you've faced the problem that database migrations solve.\n\nThe Laravel facade provides database agnostic support for creating and manipulating tables across all of Laravel's supported database systems. Typically, migrations will use this facade to create and modify database tables and columns.\n\nYou may use the Artisan command to generate a database migration. The new migration will be placed in your directory. Each migration filename contains a timestamp that allows Laravel to determine the order of the migrations:\n\nLaravel will use the name of the migration to attempt to guess the name of the table and whether or not the migration will be creating a new table. If Laravel is able to determine the table name from the migration name, Laravel will pre-fill the generated migration file with the specified table. Otherwise, you may simply specify the table in the migration file manually.\n\nIf you would like to specify a custom path for the generated migration, you may use the option when executing the command. The given path should be relative to your application's base path.\n\nAs you build your application, you may accumulate more and more migrations over time. This can lead to your directory becoming bloated with potentially hundreds of migrations. If you would like, you may \"squash\" your migrations into a single SQL file. To get started, execute the command:\n\nWhen you execute this command, Laravel will write a \"schema\" file to your application's directory. The schema file's name will correspond to the database connection. Now, when you attempt to migrate your database and no other migrations have been executed, Laravel will first execute the SQL statements in the schema file of the database connection you are using. After executing the schema file's SQL statements, Laravel will execute any remaining migrations that were not part of the schema dump.\n\nIf your application's tests use a different database connection than the one you typically use during local development, you should ensure you have dumped a schema file using that database connection so that your tests are able to build your database. You may wish to do this after dumping the database connection you typically use during local development:\n\nYou should commit your database schema file to source control so that other new developers on your team may quickly create your application's initial database structure.\n\nA migration class contains two methods: and . The method is used to add new tables, columns, or indexes to your database, while the method should reverse the operations performed by the method.\n\nWithin both of these methods, you may use the Laravel schema builder to expressively create and modify tables. To learn about all of the methods available on the builder, check out its documentation. For example, the following migration creates a table:\n\nIf your migration will be interacting with a database connection other than your application's default database connection, you should set the property of your migration:\n\nTo run all of your outstanding migrations, execute the Artisan command:\n\nIf you would like to see which migrations have run thus far, you may use the Artisan command:\n\nIf you would like to see the SQL statements that will be executed by the migrations without actually running them, you may provide the flag to the command:\n\nIf you are deploying your application across multiple servers and running migrations as part of your deployment process, you likely do not want two servers attempting to migrate the database at the same time. To avoid this, you may use the option when invoking the command.\n\nWhen the option is provided, Laravel will acquire an atomic lock using your application's cache driver before attempting to run your migrations. All other attempts to run the command while that lock is held will not execute; however, the command will still exit with a successful exit status code:\n\nSome migration operations are destructive, which means they may cause you to lose data. In order to protect you from running these commands against your production database, you will be prompted for confirmation before the commands are executed. To force the commands to run without a prompt, use the flag:\n\nTo roll back the latest migration operation, you may use the Artisan command. This command rolls back the last \"batch\" of migrations, which may include multiple migration files:\n\nYou may roll back a limited number of migrations by providing the option to the command. For example, the following command will roll back the last five migrations:\n\nYou may roll back a specific \"batch\" of migrations by providing the option to the command, where the option corresponds to a batch value within your application's database table. For example, the following command will roll back all migrations in batch three:\n\nIf you would like to see the SQL statements that will be executed by the migrations without actually running them, you may provide the flag to the command:\n\nThe command will roll back all of your application's migrations:\n\nThe command will roll back all of your migrations and then execute the command. This command effectively re-creates your entire database:\n\nYou may roll back and re-migrate a limited number of migrations by providing the option to the command. For example, the following command will roll back and re-migrate the last five migrations:\n\nThe command will drop all tables from the database and then execute the command:\n\nBy default, the command only drops tables from the default database connection. However, you may use the option to specify the database connection that should be migrated. The database connection name should correspond to a connection defined in your application's configuration file:\n\nTo create a new database table, use the method on the facade. The method accepts two arguments: the first is the name of the table, while the second is a closure which receives a object that may be used to define the new table:\n\nWhen creating the table, you may use any of the schema builder's column methods to define the table's columns.\n\nYou may determine the existence of a table, column, or index using the , , and methods:\n\nIf you want to perform a schema operation on a database connection that is not your application's default connection, use the method:\n\nIn addition, a few other properties and methods may be used to define other aspects of the table's creation. The property may be used to specify the table's storage engine when using MariaDB or MySQL:\n\nThe and properties may be used to specify the character set and collation for the created table when using MariaDB or MySQL:\n\nThe method may be used to indicate that the table should be \"temporary\". Temporary tables are only visible to the current connection's database session and are dropped automatically when the connection is closed:\n\nIf you would like to add a \"comment\" to a database table, you may invoke the method on the table instance. Table comments are currently only supported by MariaDB, MySQL, and PostgreSQL:\n\nThe method on the facade may be used to update existing tables. Like the method, the method accepts two arguments: the name of the table and a closure that receives a instance you may use to add columns or indexes to the table:\n\nTo rename an existing database table, use the method:\n\nTo drop an existing table, you may use the or methods:\n\nBefore renaming a table, you should verify that any foreign key constraints on the table have an explicit name in your migration files instead of letting Laravel assign a convention based name. Otherwise, the foreign key constraint name will refer to the old table name.\n\nThe method on the facade may be used to update existing tables. Like the method, the method accepts two arguments: the name of the table and a closure that receives an instance you may use to add columns to the table:\n\nThe schema builder blueprint offers a variety of methods that correspond to the different types of columns you can add to your database tables. Each of the available methods are listed in the table below:\n\nWhen utilizing MySQL, MariaDB, or SQL Server, you may pass and arguments to create or equivalent column:\n\nThe method creates a equivalent column with of a given length:\n\nThe method creates a (with timezone) equivalent column with an optional fractional seconds precision:\n\nThe method creates a equivalent column with an optional fractional seconds precision:\n\nThe method creates a equivalent column with the given precision (total digits) and scale (decimal digits):\n\nThe method creates a equivalent column with the given valid values:\n\nThe method creates a equivalent column with the given precision:\n\nThe method adds a equivalent column for a given model class. The column type will be , , or depending on the model key type:\n\nThe method creates a equivalent column with the given spatial type and SRID (Spatial Reference System Identifier):\n\nThe method creates a equivalent column with the given spatial type and SRID (Spatial Reference System Identifier):\n\nThe method is an alias of the method. By default, the method will create an column; however, you may pass a column name if you would like to assign a different name to the column:\n\nThe method creates an auto-incrementing equivalent column as a primary key:\n\nWhen using PostgreSQL, an column will be created.\n\nWhen using SQLite, a column will be created.\n\nWhen using SQLite, a column will be created.\n\nWhen utilizing MySQL or MariaDB, you may apply a character set to the column in order to create a equivalent column:\n\nThe method creates a column that is intended to hold a MAC address. Some database systems, such as PostgreSQL, have a dedicated column type for this type of data. Other database systems will use a string equivalent column:\n\nThe method creates an auto-incrementing equivalent column as a primary key:\n\nWhen utilizing MySQL or MariaDB, you may apply a character set to the column in order to create a equivalent column:\n\nThe method is a convenience method that adds a equivalent column and a equivalent column. The column type for the will be , , or depending on the model key type.\n\nThis method is intended to be used when defining the columns necessary for a polymorphic Eloquent relationship. In the following example, and columns would be created:\n\nThe method is similar to the morphs method; however, the columns that are created will be \"nullable\":\n\nThe method is similar to the ulidMorphs method; however, the columns that are created will be \"nullable\":\n\nThe method is similar to the uuidMorphs method; however, the columns that are created will be \"nullable\":\n\nThe method creates a nullable, equivalent column that is intended to store the current \"remember me\" authentication token:\n\nThe method creates a equivalent column with the given list of valid values:\n\nThe method creates an auto-incrementing equivalent column as a primary key:\n\nThe method adds a nullable (with timezone) equivalent column with an optional fractional seconds precision. This column is intended to store the timestamp needed for Eloquent's \"soft delete\" functionality:\n\nThe method adds a nullable equivalent column with an optional fractional seconds precision. This column is intended to store the timestamp needed for Eloquent's \"soft delete\" functionality:\n\nThe method creates a equivalent column of the given length:\n\nWhen utilizing MySQL or MariaDB, you may apply a character set to the column in order to create a equivalent column:\n\nThe method creates a (with timezone) equivalent column with an optional fractional seconds precision:\n\nThe method creates a equivalent column with an optional fractional seconds precision:\n\nThe method creates a (with timezone) equivalent column with an optional fractional seconds precision:\n\nThe method creates a equivalent column with an optional fractional seconds precision:\n\nThe method creates and (with timezone) equivalent columns with an optional fractional seconds precision:\n\nThe method creates and equivalent columns with an optional fractional seconds precision:\n\nThe method creates an auto-incrementing equivalent column as a primary key:\n\nWhen utilizing MySQL or MariaDB, you may apply a character set to the column in order to create a equivalent column:\n\nThe method is a convenience method that adds a equivalent column and a equivalent column.\n\nThis method is intended to be used when defining the columns necessary for a polymorphic Eloquent relationship that use ULID identifiers. In the following example, and columns would be created:\n\nThe method is a convenience method that adds a equivalent column and a equivalent column.\n\nThis method is intended to be used when defining the columns necessary for a polymorphic Eloquent relationship that use UUID identifiers. In the following example, and columns would be created:\n\nIn addition to the column types listed above, there are several column \"modifiers\" you may use when adding a column to a database table. For example, to make the column \"nullable\", you may use the method:\n\nThe following table contains all of the available column modifiers. This list does not include index modifiers:\n\nThe modifier accepts a value or an instance. Using an instance will prevent Laravel from wrapping the value in quotes and allow you to use database specific functions. One situation where this is particularly useful is when you need to assign default values to JSON columns:\n\nWhen using the MariaDB or MySQL database, the method may be used to add columns after an existing column in the schema:\n\nThe method allows you to modify the type and attributes of existing columns. For example, you may wish to increase the size of a column. To see the method in action, let's increase the size of the column from 25 to 50. To accomplish this, we simply define the new state of the column and then call the method:\n\nWhen modifying a column, you must explicitly include all the modifiers you want to keep on the column definition - any missing attribute will be dropped. For example, to retain the , , and attributes, you must call each modifier explicitly when changing the column:\n\nThe method does not change the indexes of the column. Therefore, you may use index modifiers to explicitly add or drop an index when modifying the column:\n\nTo rename a column, you may use the method provided by the schema builder:\n\nTo drop a column, you may use the method on the schema builder:\n\nYou may drop multiple columns from a table by passing an array of column names to the method:\n\nLaravel provides several convenient methods related to dropping common types of columns. Each of these methods is described in the table below:\n\nThe Laravel schema builder supports several types of indexes. The following example creates a new column and specifies that its values should be unique. To create the index, we can chain the method onto the column definition:\n\nAlternatively, you may create the index after defining the column. To do so, you should call the method on the schema builder blueprint. This method accepts the name of the column that should receive a unique index:\n\nYou may even pass an array of columns to an index method to create a compound (or composite) index:\n\nWhen creating an index, Laravel will automatically generate an index name based on the table, column names, and the index type, but you may pass a second argument to the method to specify the index name yourself:\n\nLaravel's schema builder blueprint class provides methods for creating each type of index supported by Laravel. Each index method accepts an optional second argument to specify the name of the index. If omitted, the name will be derived from the names of the table and column(s) used for the index, as well as the index type. Each of the available index methods is described in the table below:\n\nTo rename an index, you may use the method provided by the schema builder blueprint. This method accepts the current index name as its first argument and the desired name as its second argument:\n\nTo drop an index, you must specify the index's name. By default, Laravel automatically assigns an index name based on the table name, the name of the indexed column, and the index type. Here are some examples:\n\nIf you pass an array of columns into a method that drops indexes, the conventional index name will be generated based on the table name, columns, and index type:\n\nLaravel also provides support for creating foreign key constraints, which are used to force referential integrity at the database level. For example, let's define a column on the table that references the column on a table:\n\nSince this syntax is rather verbose, Laravel provides additional, terser methods that use conventions to provide a better developer experience. When using the method to create your column, the example above can be rewritten like so:\n\nThe method creates an equivalent column, while the method will use conventions to determine the table and column being referenced. If your table name does not match Laravel's conventions, you may manually provide it to the method. In addition, the name that should be assigned to the generated index may be specified as well:\n\nYou may also specify the desired action for the \"on delete\" and \"on update\" properties of the constraint:\n\nAn alternative, expressive syntax is also provided for these actions:\n\nAny additional column modifiers must be called before the method:\n\nTo drop a foreign key, you may use the method, passing the name of the foreign key constraint to be deleted as an argument. Foreign key constraints use the same naming convention as indexes. In other words, the foreign key constraint name is based on the name of the table and the columns in the constraint, followed by a \"_foreign\" suffix:\n\nAlternatively, you may pass an array containing the column name that holds the foreign key to the method. The array will be converted to a foreign key constraint name using Laravel's constraint naming conventions:\n\nYou may enable or disable foreign key constraints within your migrations by using the following methods:\n\nFor convenience, each migration operation will dispatch an event. All of the following events extend the base class:"
    },
    {
        "link": "https://medium.com/@thoyibh07/you-must-use-uuid-instead-of-auto-incremented-ids-in-laravel-b60e360768cd",
        "document": "In the world of web development, the choice between using auto-incremented numeric IDs or universally unique identifiers (UUIDs) as primary keys for database records is a topic that has garnered attention and discussion. In this article, we’ll explore the reasons why you should consider using UUIDs as primary keys in your Laravel applications, and we’ll refer to some valuable resources and articles for further insights.\n\nA Universally Unique Identifier (UUID) is a 128-bit identifier that is guaranteed to be unique across all devices and all time. Unlike traditional auto-incremented IDs, UUIDs are not sequential numbers but rather random or pseudo-random values.\n\nThe Benefits of Using UUIDs in Laravel\n\nUUIDs do not reveal the order or quantity of records in your database, providing an additional layer of data security. Auto-incremented IDs, on the other hand, can expose insights into your data structure, which may not be desirable.\n\nAs the name suggests, UUIDs are universally unique. This means you can confidently combine data from different sources without worrying about ID conflicts. Whether you’re merging databases, working with distributed systems, or integrating third-party data, UUIDs simplify the process.\n\nAuto-incremented IDs are subject to collisions when multiple database servers generate records concurrently. UUIDs significantly reduce the likelihood of these collisions, as they are generated using a combination of timestamps, randomness, and other factors.\n\nUUIDs promote data integrity by reducing the risk of referential integrity issues. When records need to be merged or updated, UUIDs make it easier to match records between systems without creating conflicts or errors.\n\nUUIDs are ideal for systems that operate in disconnected environments, such as mobile applications or distributed databases. Even without a centralized server to assign IDs, UUIDs ensure unique identifiers across all devices.\n\nIf you don’t already have Laravel installed, you can set up a new Laravel project using Composer:\n\nConfigure your database connection in the file as you would for any Laravel application.\n\nCreate a migration for your desired model and configure it to use UUIDs as the primary key. Since we already have a default migration file for the users table, we will make slight modifications to this file\n\nAnd we will slight modifications in User model\n\nCreate a controller and views as needed for your application. Implement your application logic as usual, utilizing the model with UUIDs as primary keys.\n\nTo gain a deeper understanding of implementing UUIDs in Laravel and their benefits, you can explore the following articles:\n• Educative: “How to Use UUIDs in Laravel”\n• dev.to: “Implement UUID Primary Key in Laravel and Its Benefits”\n\nThese resources provide detailed insights, practical examples, and Laravel-specific guidance for using UUIDs in your projects.\n\nAnd you can visit my github repo for this article example code\n\nhttps://github.com/thoyib-project/laravel-lab/tree/packages/uuid\n\nWhile auto-incremented IDs have been the conventional choice for primary keys in databases, UUIDs offer unique advantages in terms of data security, global uniqueness, and data integrity. When considering the design of your next Laravel application, it’s worth exploring the benefits of UUIDs to enhance the performance, scalability, and security of your database. Embracing UUIDs in Laravel is a step towards building more robust and adaptable systems."
    },
    {
        "link": "https://laravel.com/docs/11.x/eloquent",
        "document": "WARNING You're browsing the documentation for an old version of Laravel. Consider upgrading your project to Laravel 12.x .\n\nLaravel includes Eloquent, an object-relational mapper (ORM) that makes it enjoyable to interact with your database. When using Eloquent, each database table has a corresponding \"Model\" that is used to interact with that table. In addition to retrieving records from the database table, Eloquent models allow you to insert, update, and delete records from the table as well.\n\nIf you're new to Laravel, feel free to jump into the Laravel Bootcamp. The Laravel Bootcamp will walk you through building your first Laravel application using Eloquent. It's a great way to get a tour of everything that Laravel and Eloquent have to offer.\n\nTo get started, let's create an Eloquent model. Models typically live in the directory and extend the class. You may use the Artisan command to generate a new model:\n\nIf you would like to generate a database migration when you generate the model, you may use the or option:\n\nYou may generate various other types of classes when generating a model, such as factories, seeders, policies, controllers, and form requests. In addition, these options may be combined to create multiple classes at once:\n\nSometimes it can be difficult to determine all of a model's available attributes and relationships just by skimming its code. Instead, try the Artisan command, which provides a convenient overview of all the model's attributes and relations:\n\nModels generated by the command will be placed in the directory. Let's examine a basic model class and discuss some of Eloquent's key conventions:\n\nAfter glancing at the example above, you may have noticed that we did not tell Eloquent which database table corresponds to our model. By convention, the \"snake case\", plural name of the class will be used as the table name unless another name is explicitly specified. So, in this case, Eloquent will assume the model stores records in the table, while an model would store records in an table.\n\nIf your model's corresponding database table does not fit this convention, you may manually specify the model's table name by defining a property on the model:\n\nEloquent will also assume that each model's corresponding database table has a primary key column named . If necessary, you may define a protected property on your model to specify a different column that serves as your model's primary key:\n\nIn addition, Eloquent assumes that the primary key is an incrementing integer value, which means that Eloquent will automatically cast the primary key to an integer. If you wish to use a non-incrementing or a non-numeric primary key you must define a public property on your model that is set to :\n\nIf your model's primary key is not an integer, you should define a protected property on your model. This property should have a value of :\n\nEloquent requires each model to have at least one uniquely identifying \"ID\" that can serve as its primary key. \"Composite\" primary keys are not supported by Eloquent models. However, you are free to add additional multi-column, unique indexes to your database tables in addition to the table's uniquely identifying primary key.\n\nInstead of using auto-incrementing integers as your Eloquent model's primary keys, you may choose to use UUIDs instead. UUIDs are universally unique alpha-numeric identifiers that are 36 characters long.\n\nIf you would like a model to use a UUID key instead of an auto-incrementing integer key, you may use the trait on the model. Of course, you should ensure that the model has a UUID equivalent primary key column:\n\nBy default, The trait will generate \"ordered\" UUIDs for your models. These UUIDs are more efficient for indexed database storage because they can be sorted lexicographically.\n\nYou can override the UUID generation process for a given model by defining a method on the model. In addition, you may specify which columns should receive UUIDs by defining a method on the model:\n\nIf you wish, you may choose to utilize \"ULIDs\" instead of UUIDs. ULIDs are similar to UUIDs; however, they are only 26 characters in length. Like ordered UUIDs, ULIDs are lexicographically sortable for efficient database indexing. To utilize ULIDs, you should use the trait on your model. You should also ensure that the model has a ULID equivalent primary key column:\n\nBy default, Eloquent expects and columns to exist on your model's corresponding database table. Eloquent will automatically set these column's values when models are created or updated. If you do not want these columns to be automatically managed by Eloquent, you should define a property on your model with a value of :\n\nIf you need to customize the format of your model's timestamps, set the property on your model. This property determines how date attributes are stored in the database as well as their format when the model is serialized to an array or JSON:\n\nIf you need to customize the names of the columns used to store the timestamps, you may define and constants on your model:\n\nIf you would like to perform model operations without the model having its timestamp modified, you may operate on the model within a closure given to the method:\n\nBy default, all Eloquent models will use the default database connection that is configured for your application. If you would like to specify a different connection that should be used when interacting with a particular model, you should define a property on the model:\n\nBy default, a newly instantiated model instance will not contain any attribute values. If you would like to define the default values for some of your model's attributes, you may define an property on your model. Attribute values placed in the array should be in their raw, \"storable\" format as if they were just read from the database:\n\nLaravel offers several methods that allow you to configure Eloquent's behavior and \"strictness\" in a variety of situations.\n\nFirst, the method accepts an optional boolean argument that indicates if lazy loading should be prevented. For example, you may wish to only disable lazy loading in non-production environments so that your production environment will continue to function normally even if a lazy loaded relationship is accidentally present in production code. Typically, this method should be invoked in the method of your application's :\n\nAlso, you may instruct Laravel to throw an exception when attempting to fill an unfillable attribute by invoking the method. This can help prevent unexpected errors during local development when attempting to set an attribute that has not been added to the model's array:\n\nOnce you have created a model and its associated database table, you are ready to start retrieving data from your database. You can think of each Eloquent model as a powerful query builder allowing you to fluently query the database table associated with the model. The model's method will retrieve all of the records from the model's associated database table:\n\nThe Eloquent method will return all of the results in the model's table. However, since each Eloquent model serves as a query builder, you may add additional constraints to queries and then invoke the method to retrieve the results:\n\nIf you already have an instance of an Eloquent model that was retrieved from the database, you can \"refresh\" the model using the and methods. The method will re-retrieve the model from the database. The existing model instance will not be affected:\n\nThe method will re-hydrate the existing model using fresh data from the database. In addition, all of its loaded relationships will be refreshed as well:\n\nAs we have seen, Eloquent methods like and retrieve multiple records from the database. However, these methods don't return a plain PHP array. Instead, an instance of is returned.\n\nThe Eloquent class extends Laravel's base class, which provides a variety of helpful methods for interacting with data collections. For example, the method may be used to remove models from a collection based on the results of an invoked closure:\n\nIn addition to the methods provided by Laravel's base collection class, the Eloquent collection class provides a few extra methods that are specifically intended for interacting with collections of Eloquent models.\n\nSince all of Laravel's collections implement PHP's iterable interfaces, you may loop over collections as if they were an array:\n\nYour application may run out of memory if you attempt to load tens of thousands of Eloquent records via the or methods. Instead of using these methods, the method may be used to process large numbers of models more efficiently.\n\nThe method will retrieve a subset of Eloquent models, passing them to a closure for processing. Since only the current chunk of Eloquent models is retrieved at a time, the method will provide significantly reduced memory usage when working with a large number of models:\n\nThe first argument passed to the method is the number of records you wish to receive per \"chunk\". The closure passed as the second argument will be invoked for each chunk that is retrieved from the database. A database query will be executed to retrieve each chunk of records passed to the closure.\n\nIf you are filtering the results of the method based on a column that you will also be updating while iterating over the results, you should use the method. Using the method in these scenarios could lead to unexpected and inconsistent results. Internally, the method will always retrieve models with an column greater than the last model in the previous chunk:\n\nSince the and methods add their own \"where\" conditions to the query being executed, you should typically logically group your own conditions within a closure:\n\nThe method works similarly to the method in the sense that, behind the scenes, it executes the query in chunks. However, instead of passing each chunk directly into a callback as is, the method returns a flattened of Eloquent models, which lets you interact with the results as a single stream:\n\nIf you are filtering the results of the method based on a column that you will also be updating while iterating over the results, you should use the method. Internally, the method will always retrieve models with an column greater than the last model in the previous chunk:\n\nYou may filter the results based on the descending order of the using the method.\n\nSimilar to the method, the method may be used to significantly reduce your application's memory consumption when iterating through tens of thousands of Eloquent model records.\n\nThe method will only execute a single database query; however, the individual Eloquent models will not be hydrated until they are actually iterated over. Therefore, only one Eloquent model is kept in memory at any given time while iterating over the cursor.\n\nInternally, the method uses PHP generators to implement this functionality:\n\nThe returns an instance. Lazy collections allow you to use many of the collection methods available on typical Laravel collections while only loading a single model into memory at a time:\n\nAlthough the method uses far less memory than a regular query (by only holding a single Eloquent model in memory at a time), it will still eventually run out of memory. This is due to PHP's PDO driver internally caching all raw query results in its buffer. If you're dealing with a very large number of Eloquent records, consider using the method instead.\n\nEloquent also offers advanced subquery support, which allows you to pull information from related tables in a single query. For example, let's imagine that we have a table of flight and a table of to destinations. The table contains an column which indicates when the flight arrived at the destination.\n\nUsing the subquery functionality available to the query builder's and methods, we can select all of the and the name of the flight that most recently arrived at that destination using a single query:\n\nIn addition, the query builder's function supports subqueries. Continuing to use our flight example, we may use this functionality to sort all destinations based on when the last flight arrived at that destination. Again, this may be done while executing a single database query:\n\nIn addition to retrieving all of the records matching a given query, you may also retrieve single records using the , , or methods. Instead of returning a collection of models, these methods return a single model instance:\n\nSometimes you may wish to perform some other action if no results are found. The and methods will return a single model instance or, if no results are found, execute the given closure. The value returned by the closure will be considered the result of the method:\n\nSometimes you may wish to throw an exception if a model is not found. This is particularly useful in routes or controllers. The and methods will retrieve the first result of the query; however, if no result is found, an will be thrown:\n\nIf the is not caught, a 404 HTTP response is automatically sent back to the client:\n\nThe method will attempt to locate a database record using the given column / value pairs. If the model cannot be found in the database, a record will be inserted with the attributes resulting from merging the first array argument with the optional second array argument:\n\nThe method, like , will attempt to locate a record in the database matching the given attributes. However, if a model is not found, a new model instance will be returned. Note that the model returned by has not yet been persisted to the database. You will need to manually call the method to persist it:\n\nWhen interacting with Eloquent models, you may also use the , , , and other aggregate methods provided by the Laravel query builder. As you might expect, these methods return a scalar value instead of an Eloquent model instance:\n\nOf course, when using Eloquent, we don't only need to retrieve models from the database. We also need to insert new records. Thankfully, Eloquent makes it simple. To insert a new record into the database, you should instantiate a new model instance and set attributes on the model. Then, call the method on the model instance:\n\nIn this example, we assign the field from the incoming HTTP request to the attribute of the model instance. When we call the method, a record will be inserted into the database. The model's and timestamps will automatically be set when the method is called, so there is no need to set them manually.\n\nAlternatively, you may use the method to \"save\" a new model using a single PHP statement. The inserted model instance will be returned to you by the method:\n\nHowever, before using the method, you will need to specify either a or property on your model class. These properties are required because all Eloquent models are protected against mass assignment vulnerabilities by default. To learn more about mass assignment, please consult the mass assignment documentation.\n\nThe method may also be used to update models that already exist in the database. To update a model, you should retrieve it and set any attributes you wish to update. Then, you should call the model's method. Again, the timestamp will automatically be updated, so there is no need to manually set its value:\n\nOccasionally, you may need to update an existing model or create a new model if no matching model exists. Like the method, the method persists the model, so there's no need to manually call the method.\n\nIn the example below, if a flight exists with a location of and a location of , its and columns will be updated. If no such flight exists, a new flight will be created which has the attributes resulting from merging the first argument array with the second argument array:\n\nUpdates can also be performed against models that match a given query. In this example, all flights that are and have a of will be marked as delayed:\n\nThe method expects an array of column and value pairs representing the columns that should be updated. The method returns the number of affected rows.\n\nEloquent provides the , , and methods to examine the internal state of your model and determine how its attributes have changed from when the model was originally retrieved.\n\nThe method determines if any of the model's attributes have been changed since the model was retrieved. You may pass a specific attribute name or an array of attributes to the method to determine if any of the attributes are \"dirty\". The method will determine if an attribute has remained unchanged since the model was retrieved. This method also accepts an optional attribute argument:\n\nThe method determines if any attributes were changed when the model was last saved within the current request cycle. If needed, you may pass an attribute name to see if a particular attribute was changed:\n\nThe method returns an array containing the original attributes of the model regardless of any changes to the model since it was retrieved. If needed, you may pass a specific attribute name to get the original value of a particular attribute:\n\nYou may use the method to \"save\" a new model using a single PHP statement. The inserted model instance will be returned to you by the method:\n\nHowever, before using the method, you will need to specify either a or property on your model class. These properties are required because all Eloquent models are protected against mass assignment vulnerabilities by default.\n\nA mass assignment vulnerability occurs when a user passes an unexpected HTTP request field and that field changes a column in your database that you did not expect. For example, a malicious user might send an parameter through an HTTP request, which is then passed to your model's method, allowing the user to escalate themselves to an administrator.\n\nSo, to get started, you should define which model attributes you want to make mass assignable. You may do this using the property on the model. For example, let's make the attribute of our model mass assignable:\n\nOnce you have specified which attributes are mass assignable, you may use the method to insert a new record in the database. The method returns the newly created model instance:\n\nIf you already have a model instance, you may use the method to populate it with an array of attributes:\n\nWhen assigning JSON columns, each column's mass assignable key must be specified in your model's array. For security, Laravel does not support updating nested JSON attributes when using the property:\n\nIf you would like to make all of your attributes mass assignable, you may define your model's property as an empty array. If you choose to unguard your model, you should take special care to always hand-craft the arrays passed to Eloquent's , , and methods:\n\nBy default, attributes that are not included in the array are silently discarded when performing mass-assignment operations. In production, this is expected behavior; however, during local development it can lead to confusion as to why model changes are not taking effect.\n\nIf you wish, you may instruct Laravel to throw an exception when attempting to fill an unfillable attribute by invoking the method. Typically, this method should be invoked in the method of your application's class:\n\nEloquent's method may be used to update or create records in a single, atomic operation. The method's first argument consists of the values to insert or update, while the second argument lists the column(s) that uniquely identify records within the associated table. The method's third and final argument is an array of the columns that should be updated if a matching record already exists in the database. The method will automatically set the and timestamps if timestamps are enabled on the model:\n\nTo delete a model, you may call the method on the model instance:\n\nDeleting an Existing Model by its Primary Key\n\nIn the example above, we are retrieving the model from the database before calling the method. However, if you know the primary key of the model, you may delete the model without explicitly retrieving it by calling the method. In addition to accepting the single primary key, the method will accept multiple primary keys, an array of primary keys, or a collection of primary keys:\n\nIf you are utilizing soft deleting models, you may permanently delete models via the method:\n\nOf course, you may build an Eloquent query to delete all models matching your query's criteria. In this example, we will delete all flights that are marked as inactive. Like mass updates, mass deletes will not dispatch model events for the models that are deleted:\n\nTo delete all models in a table, you should execute a query without adding any conditions:\n\nIn addition to actually removing records from your database, Eloquent can also \"soft delete\" models. When models are soft deleted, they are not actually removed from your database. Instead, a attribute is set on the model indicating the date and time at which the model was \"deleted\". To enable soft deletes for a model, add the trait to the model:\n\nYou should also add the column to your database table. The Laravel schema builder contains a helper method to create this column:\n\nNow, when you call the method on the model, the column will be set to the current date and time. However, the model's database record will be left in the table. When querying a model that uses soft deletes, the soft deleted models will automatically be excluded from all query results.\n\nTo determine if a given model instance has been soft deleted, you may use the method:\n\nSometimes you may wish to \"un-delete\" a soft deleted model. To restore a soft deleted model, you may call the method on a model instance. The method will set the model's column to :\n\nYou may also use the method in a query to restore multiple models. Again, like other \"mass\" operations, this will not dispatch any model events for the models that are restored:\n\nThe method may also be used when building relationship queries:\n\nSometimes you may need to truly remove a model from your database. You may use the method to permanently remove a soft deleted model from the database table:\n\nYou may also use the method when building Eloquent relationship queries:\n\nAs noted above, soft deleted models will automatically be excluded from query results. However, you may force soft deleted models to be included in a query's results by calling the method on the query:\n\nThe method may also be called when building a relationship query:\n\nThe method will retrieve only soft deleted models:\n\nSometimes you may want to periodically delete models that are no longer needed. To accomplish this, you may add the or trait to the models you would like to periodically prune. After adding one of the traits to the model, implement a method which returns an Eloquent query builder that resolves the models that are no longer needed:\n\nWhen marking models as , you may also define a method on the model. This method will be called before the model is deleted. This method can be useful for deleting any additional resources associated with the model, such as stored files, before the model is permanently removed from the database:\n\nAfter configuring your prunable model, you should schedule the Artisan command in your application's file. You are free to choose the appropriate interval at which this command should be run:\n\nBehind the scenes, the command will automatically detect \"Prunable\" models within your application's directory. If your models are in a different location, you may use the option to specify the model class names:\n\nIf you wish to exclude certain models from being pruned while pruning all other detected models, you may use the option:\n\nYou may test your query by executing the command with the option. When pretending, the command will simply report how many records would be pruned if the command were to actually run:\n\nWhen models are marked with the trait, models are deleted from the database using mass-deletion queries. Therefore, the method will not be invoked, nor will the and model events be dispatched. This is because the models are never actually retrieved before deletion, thus making the pruning process much more efficient:\n\nYou may create an unsaved copy of an existing model instance using the method. This method is particularly useful when you have model instances that share many of the same attributes:\n\nTo exclude one or more attributes from being replicated to the new model, you may pass an array to the method:\n\nGlobal scopes allow you to add constraints to all queries for a given model. Laravel's own soft delete functionality utilizes global scopes to only retrieve \"non-deleted\" models from the database. Writing your own global scopes can provide a convenient, easy way to make sure every query for a given model receives certain constraints.\n\nTo generate a new global scope, you may invoke the Artisan command, which will place the generated scope in your application's directory:\n\nWriting a global scope is simple. First, use the command to generate a class that implements the interface. The interface requires you to implement one method: . The method may add constraints or other types of clauses to the query as needed:\n\nTo assign a global scope to a model, you may simply place the attribute on the model:\n\nOr, you may manually register the global scope by overriding the model's method and invoke the model's method. The method accepts an instance of your scope as its only argument:\n\nAfter adding the scope in the example above to the model, a call to the method will execute the following SQL query:\n\nEloquent also allows you to define global scopes using closures, which is particularly useful for simple scopes that do not warrant a separate class of their own. When defining a global scope using a closure, you should provide a scope name of your own choosing as the first argument to the method:\n\nIf you would like to remove a global scope for a given query, you may use the method. This method accepts the class name of the global scope as its only argument:\n\nOr, if you defined the global scope using a closure, you should pass the string name that you assigned to the global scope:\n\nIf you would like to remove several or even all of the query's global scopes, you may use the method:\n\nLocal scopes allow you to define common sets of query constraints that you may easily re-use throughout your application. For example, you may need to frequently retrieve all users that are considered \"popular\". To define a scope, prefix an Eloquent model method with .\n\nScopes should always return the same query builder instance or :\n\nOnce the scope has been defined, you may call the scope methods when querying the model. However, you should not include the prefix when calling the method. You can even chain calls to various scopes:\n\nCombining multiple Eloquent model scopes via an query operator may require the use of closures to achieve the correct logical grouping:\n\nHowever, since this can be cumbersome, Laravel provides a \"higher order\" method that allows you to fluently chain scopes together without the use of closures:\n\nSometimes you may wish to define a scope that accepts parameters. To get started, just add your additional parameters to your scope method's signature. Scope parameters should be defined after the parameter:\n\nOnce the expected arguments have been added to your scope method's signature, you may pass the arguments when calling the scope:\n\nIf you would like to use scopes to create models that have the same attributes as those used to constrain the scope, you may use the method when building the scope query:\n\nThe method will add clause constraints to the query using the given attributes, and it will also add the given attributes to any models created via the scope:\n\nSometimes you may need to determine if two models are the \"same\" or not. The and methods may be used to quickly verify two models have the same primary key, table, and database connection or not:\n\nThe and methods are also available when using the , , , and relationships. This method is particularly helpful when you would like to compare a related model without issuing a query to retrieve that model:\n\nEloquent models dispatch several events, allowing you to hook into the following moments in a model's lifecycle: , , , , , , , , , , , , , , and .\n\nThe event will dispatch when an existing model is retrieved from the database. When a new model is saved for the first time, the and events will dispatch. The / events will dispatch when an existing model is modified and the method is called. The / events will dispatch when a model is created or updated - even if the model's attributes have not been changed. Event names ending with are dispatched before any changes to the model are persisted, while events ending with are dispatched after the changes to the model are persisted.\n\nTo start listening to model events, define a property on your Eloquent model. This property maps various points of the Eloquent model's lifecycle to your own event classes. Each model event class should expect to receive an instance of the affected model via its constructor:\n\nAfter defining and mapping your Eloquent events, you may use event listeners to handle the events.\n\nInstead of using custom event classes, you may register closures that execute when various model events are dispatched. Typically, you should register these closures in the method of your model:\n\nIf needed, you may utilize queueable anonymous event listeners when registering model events. This will instruct Laravel to execute the model event listener in the background using your application's queue:\n\nIf you are listening for many events on a given model, you may use observers to group all of your listeners into a single class. Observer classes have method names which reflect the Eloquent events you wish to listen for. Each of these methods receives the affected model as their only argument. The Artisan command is the easiest way to create a new observer class:\n\nThis command will place the new observer in your directory. If this directory does not exist, Artisan will create it for you. Your fresh observer will look like the following:\n\nTo register an observer, you may place the attribute on the corresponding model:\n\nOr, you may manually register an observer by invoking the method on the model you wish to observe. You may register observers in the method of your application's class:\n\nWhen models are being created within a database transaction, you may want to instruct an observer to only execute its event handlers after the database transaction is committed. You may accomplish this by implementing the interface on your observer. If a database transaction is not in progress, the event handlers will execute immediately:\n\nYou may occasionally need to temporarily \"mute\" all events fired by a model. You may achieve this using the method. The method accepts a closure as its only argument. Any code executed within this closure will not dispatch model events, and any value returned by the closure will be returned by the method:\n\nSometimes you may wish to \"save\" a given model without dispatching any events. You may accomplish this using the method:\n\nYou may also \"update\", \"delete\", \"soft delete\", \"restore\", and \"replicate\" a given model without dispatching any events:"
    },
    {
        "link": "https://laravel.com/docs/12.x/eloquent",
        "document": "Laravel includes Eloquent, an object-relational mapper (ORM) that makes it enjoyable to interact with your database. When using Eloquent, each database table has a corresponding \"Model\" that is used to interact with that table. In addition to retrieving records from the database table, Eloquent models allow you to insert, update, and delete records from the table as well.\n\nTo get started, let's create an Eloquent model. Models typically live in the directory and extend the class. You may use the Artisan command to generate a new model:\n\nIf you would like to generate a database migration when you generate the model, you may use the or option:\n\nYou may generate various other types of classes when generating a model, such as factories, seeders, policies, controllers, and form requests. In addition, these options may be combined to create multiple classes at once:\n\nSometimes it can be difficult to determine all of a model's available attributes and relationships just by skimming its code. Instead, try the Artisan command, which provides a convenient overview of all the model's attributes and relations:\n\nModels generated by the command will be placed in the directory. Let's examine a basic model class and discuss some of Eloquent's key conventions:\n\nAfter glancing at the example above, you may have noticed that we did not tell Eloquent which database table corresponds to our model. By convention, the \"snake case\", plural name of the class will be used as the table name unless another name is explicitly specified. So, in this case, Eloquent will assume the model stores records in the table, while an model would store records in an table.\n\nIf your model's corresponding database table does not fit this convention, you may manually specify the model's table name by defining a property on the model:\n\nEloquent will also assume that each model's corresponding database table has a primary key column named . If necessary, you may define a protected property on your model to specify a different column that serves as your model's primary key:\n\nIn addition, Eloquent assumes that the primary key is an incrementing integer value, which means that Eloquent will automatically cast the primary key to an integer. If you wish to use a non-incrementing or a non-numeric primary key you must define a public property on your model that is set to :\n\nIf your model's primary key is not an integer, you should define a protected property on your model. This property should have a value of :\n\nEloquent requires each model to have at least one uniquely identifying \"ID\" that can serve as its primary key. \"Composite\" primary keys are not supported by Eloquent models. However, you are free to add additional multi-column, unique indexes to your database tables in addition to the table's uniquely identifying primary key.\n\nInstead of using auto-incrementing integers as your Eloquent model's primary keys, you may choose to use UUIDs instead. UUIDs are universally unique alpha-numeric identifiers that are 36 characters long.\n\nIf you would like a model to use a UUID key instead of an auto-incrementing integer key, you may use the trait on the model. Of course, you should ensure that the model has a UUID equivalent primary key column:\n\nBy default, The trait will generate \"ordered\" UUIDs for your models. These UUIDs are more efficient for indexed database storage because they can be sorted lexicographically.\n\nYou can override the UUID generation process for a given model by defining a method on the model. In addition, you may specify which columns should receive UUIDs by defining a method on the model:\n\nIf you wish, you may choose to utilize \"ULIDs\" instead of UUIDs. ULIDs are similar to UUIDs; however, they are only 26 characters in length. Like ordered UUIDs, ULIDs are lexicographically sortable for efficient database indexing. To utilize ULIDs, you should use the trait on your model. You should also ensure that the model has a ULID equivalent primary key column:\n\nBy default, Eloquent expects and columns to exist on your model's corresponding database table. Eloquent will automatically set these column's values when models are created or updated. If you do not want these columns to be automatically managed by Eloquent, you should define a property on your model with a value of :\n\nIf you need to customize the format of your model's timestamps, set the property on your model. This property determines how date attributes are stored in the database as well as their format when the model is serialized to an array or JSON:\n\nIf you need to customize the names of the columns used to store the timestamps, you may define and constants on your model:\n\nIf you would like to perform model operations without the model having its timestamp modified, you may operate on the model within a closure given to the method:\n\nBy default, all Eloquent models will use the default database connection that is configured for your application. If you would like to specify a different connection that should be used when interacting with a particular model, you should define a property on the model:\n\nBy default, a newly instantiated model instance will not contain any attribute values. If you would like to define the default values for some of your model's attributes, you may define an property on your model. Attribute values placed in the array should be in their raw, \"storable\" format as if they were just read from the database:\n\nLaravel offers several methods that allow you to configure Eloquent's behavior and \"strictness\" in a variety of situations.\n\nFirst, the method accepts an optional boolean argument that indicates if lazy loading should be prevented. For example, you may wish to only disable lazy loading in non-production environments so that your production environment will continue to function normally even if a lazy loaded relationship is accidentally present in production code. Typically, this method should be invoked in the method of your application's :\n\nAlso, you may instruct Laravel to throw an exception when attempting to fill an unfillable attribute by invoking the method. This can help prevent unexpected errors during local development when attempting to set an attribute that has not been added to the model's array:\n\nOnce you have created a model and its associated database table, you are ready to start retrieving data from your database. You can think of each Eloquent model as a powerful query builder allowing you to fluently query the database table associated with the model. The model's method will retrieve all of the records from the model's associated database table:\n\nThe Eloquent method will return all of the results in the model's table. However, since each Eloquent model serves as a query builder, you may add additional constraints to queries and then invoke the method to retrieve the results:\n\nIf you already have an instance of an Eloquent model that was retrieved from the database, you can \"refresh\" the model using the and methods. The method will re-retrieve the model from the database. The existing model instance will not be affected:\n\nThe method will re-hydrate the existing model using fresh data from the database. In addition, all of its loaded relationships will be refreshed as well:\n\nAs we have seen, Eloquent methods like and retrieve multiple records from the database. However, these methods don't return a plain PHP array. Instead, an instance of is returned.\n\nThe Eloquent class extends Laravel's base class, which provides a variety of helpful methods for interacting with data collections. For example, the method may be used to remove models from a collection based on the results of an invoked closure:\n\nIn addition to the methods provided by Laravel's base collection class, the Eloquent collection class provides a few extra methods that are specifically intended for interacting with collections of Eloquent models.\n\nSince all of Laravel's collections implement PHP's iterable interfaces, you may loop over collections as if they were an array:\n\nYour application may run out of memory if you attempt to load tens of thousands of Eloquent records via the or methods. Instead of using these methods, the method may be used to process large numbers of models more efficiently.\n\nThe method will retrieve a subset of Eloquent models, passing them to a closure for processing. Since only the current chunk of Eloquent models is retrieved at a time, the method will provide significantly reduced memory usage when working with a large number of models:\n\nThe first argument passed to the method is the number of records you wish to receive per \"chunk\". The closure passed as the second argument will be invoked for each chunk that is retrieved from the database. A database query will be executed to retrieve each chunk of records passed to the closure.\n\nIf you are filtering the results of the method based on a column that you will also be updating while iterating over the results, you should use the method. Using the method in these scenarios could lead to unexpected and inconsistent results. Internally, the method will always retrieve models with an column greater than the last model in the previous chunk:\n\nSince the and methods add their own \"where\" conditions to the query being executed, you should typically logically group your own conditions within a closure:\n\nThe method works similarly to the method in the sense that, behind the scenes, it executes the query in chunks. However, instead of passing each chunk directly into a callback as is, the method returns a flattened of Eloquent models, which lets you interact with the results as a single stream:\n\nIf you are filtering the results of the method based on a column that you will also be updating while iterating over the results, you should use the method. Internally, the method will always retrieve models with an column greater than the last model in the previous chunk:\n\nYou may filter the results based on the descending order of the using the method.\n\nSimilar to the method, the method may be used to significantly reduce your application's memory consumption when iterating through tens of thousands of Eloquent model records.\n\nThe method will only execute a single database query; however, the individual Eloquent models will not be hydrated until they are actually iterated over. Therefore, only one Eloquent model is kept in memory at any given time while iterating over the cursor.\n\nInternally, the method uses PHP generators to implement this functionality:\n\nThe returns an instance. Lazy collections allow you to use many of the collection methods available on typical Laravel collections while only loading a single model into memory at a time:\n\nAlthough the method uses far less memory than a regular query (by only holding a single Eloquent model in memory at a time), it will still eventually run out of memory. This is due to PHP's PDO driver internally caching all raw query results in its buffer. If you're dealing with a very large number of Eloquent records, consider using the method instead.\n\nEloquent also offers advanced subquery support, which allows you to pull information from related tables in a single query. For example, let's imagine that we have a table of flight and a table of to destinations. The table contains an column which indicates when the flight arrived at the destination.\n\nUsing the subquery functionality available to the query builder's and methods, we can select all of the and the name of the flight that most recently arrived at that destination using a single query:\n\nIn addition, the query builder's function supports subqueries. Continuing to use our flight example, we may use this functionality to sort all destinations based on when the last flight arrived at that destination. Again, this may be done while executing a single database query:\n\nIn addition to retrieving all of the records matching a given query, you may also retrieve single records using the , , or methods. Instead of returning a collection of models, these methods return a single model instance:\n\nSometimes you may wish to perform some other action if no results are found. The and methods will return a single model instance or, if no results are found, execute the given closure. The value returned by the closure will be considered the result of the method:\n\nSometimes you may wish to throw an exception if a model is not found. This is particularly useful in routes or controllers. The and methods will retrieve the first result of the query; however, if no result is found, an will be thrown:\n\nIf the is not caught, a 404 HTTP response is automatically sent back to the client:\n\nThe method will attempt to locate a database record using the given column / value pairs. If the model cannot be found in the database, a record will be inserted with the attributes resulting from merging the first array argument with the optional second array argument:\n\nThe method, like , will attempt to locate a record in the database matching the given attributes. However, if a model is not found, a new model instance will be returned. Note that the model returned by has not yet been persisted to the database. You will need to manually call the method to persist it:\n\nWhen interacting with Eloquent models, you may also use the , , , and other aggregate methods provided by the Laravel query builder. As you might expect, these methods return a scalar value instead of an Eloquent model instance:\n\nOf course, when using Eloquent, we don't only need to retrieve models from the database. We also need to insert new records. Thankfully, Eloquent makes it simple. To insert a new record into the database, you should instantiate a new model instance and set attributes on the model. Then, call the method on the model instance:\n\nIn this example, we assign the field from the incoming HTTP request to the attribute of the model instance. When we call the method, a record will be inserted into the database. The model's and timestamps will automatically be set when the method is called, so there is no need to set them manually.\n\nAlternatively, you may use the method to \"save\" a new model using a single PHP statement. The inserted model instance will be returned to you by the method:\n\nHowever, before using the method, you will need to specify either a or property on your model class. These properties are required because all Eloquent models are protected against mass assignment vulnerabilities by default. To learn more about mass assignment, please consult the mass assignment documentation.\n\nThe method may also be used to update models that already exist in the database. To update a model, you should retrieve it and set any attributes you wish to update. Then, you should call the model's method. Again, the timestamp will automatically be updated, so there is no need to manually set its value:\n\nOccasionally, you may need to update an existing model or create a new model if no matching model exists. Like the method, the method persists the model, so there's no need to manually call the method.\n\nIn the example below, if a flight exists with a location of and a location of , its and columns will be updated. If no such flight exists, a new flight will be created which has the attributes resulting from merging the first argument array with the second argument array:\n\nUpdates can also be performed against models that match a given query. In this example, all flights that are and have a of will be marked as delayed:\n\nThe method expects an array of column and value pairs representing the columns that should be updated. The method returns the number of affected rows.\n\nEloquent provides the , , and methods to examine the internal state of your model and determine how its attributes have changed from when the model was originally retrieved.\n\nThe method determines if any of the model's attributes have been changed since the model was retrieved. You may pass a specific attribute name or an array of attributes to the method to determine if any of the attributes are \"dirty\". The method will determine if an attribute has remained unchanged since the model was retrieved. This method also accepts an optional attribute argument:\n\nThe method determines if any attributes were changed when the model was last saved within the current request cycle. If needed, you may pass an attribute name to see if a particular attribute was changed:\n\nThe method returns an array containing the original attributes of the model regardless of any changes to the model since it was retrieved. If needed, you may pass a specific attribute name to get the original value of a particular attribute:\n\nThe method returns an array containing the attributes that changed when the model was last saved:\n\nYou may use the method to \"save\" a new model using a single PHP statement. The inserted model instance will be returned to you by the method:\n\nHowever, before using the method, you will need to specify either a or property on your model class. These properties are required because all Eloquent models are protected against mass assignment vulnerabilities by default.\n\nA mass assignment vulnerability occurs when a user passes an unexpected HTTP request field and that field changes a column in your database that you did not expect. For example, a malicious user might send an parameter through an HTTP request, which is then passed to your model's method, allowing the user to escalate themselves to an administrator.\n\nSo, to get started, you should define which model attributes you want to make mass assignable. You may do this using the property on the model. For example, let's make the attribute of our model mass assignable:\n\nOnce you have specified which attributes are mass assignable, you may use the method to insert a new record in the database. The method returns the newly created model instance:\n\nIf you already have a model instance, you may use the method to populate it with an array of attributes:\n\nWhen assigning JSON columns, each column's mass assignable key must be specified in your model's array. For security, Laravel does not support updating nested JSON attributes when using the property:\n\nIf you would like to make all of your attributes mass assignable, you may define your model's property as an empty array. If you choose to unguard your model, you should take special care to always hand-craft the arrays passed to Eloquent's , , and methods:\n\nBy default, attributes that are not included in the array are silently discarded when performing mass-assignment operations. In production, this is expected behavior; however, during local development it can lead to confusion as to why model changes are not taking effect.\n\nIf you wish, you may instruct Laravel to throw an exception when attempting to fill an unfillable attribute by invoking the method. Typically, this method should be invoked in the method of your application's class:\n\nEloquent's method may be used to update or create records in a single, atomic operation. The method's first argument consists of the values to insert or update, while the second argument lists the column(s) that uniquely identify records within the associated table. The method's third and final argument is an array of the columns that should be updated if a matching record already exists in the database. The method will automatically set the and timestamps if timestamps are enabled on the model:\n\nTo delete a model, you may call the method on the model instance:\n\nDeleting an Existing Model by its Primary Key\n\nIn the example above, we are retrieving the model from the database before calling the method. However, if you know the primary key of the model, you may delete the model without explicitly retrieving it by calling the method. In addition to accepting the single primary key, the method will accept multiple primary keys, an array of primary keys, or a collection of primary keys:\n\nIf you are utilizing soft deleting models, you may permanently delete models via the method:\n\nOf course, you may build an Eloquent query to delete all models matching your query's criteria. In this example, we will delete all flights that are marked as inactive. Like mass updates, mass deletes will not dispatch model events for the models that are deleted:\n\nTo delete all models in a table, you should execute a query without adding any conditions:\n\nIn addition to actually removing records from your database, Eloquent can also \"soft delete\" models. When models are soft deleted, they are not actually removed from your database. Instead, a attribute is set on the model indicating the date and time at which the model was \"deleted\". To enable soft deletes for a model, add the trait to the model:\n\nYou should also add the column to your database table. The Laravel schema builder contains a helper method to create this column:\n\nNow, when you call the method on the model, the column will be set to the current date and time. However, the model's database record will be left in the table. When querying a model that uses soft deletes, the soft deleted models will automatically be excluded from all query results.\n\nTo determine if a given model instance has been soft deleted, you may use the method:\n\nSometimes you may wish to \"un-delete\" a soft deleted model. To restore a soft deleted model, you may call the method on a model instance. The method will set the model's column to :\n\nYou may also use the method in a query to restore multiple models. Again, like other \"mass\" operations, this will not dispatch any model events for the models that are restored:\n\nThe method may also be used when building relationship queries:\n\nSometimes you may need to truly remove a model from your database. You may use the method to permanently remove a soft deleted model from the database table:\n\nYou may also use the method when building Eloquent relationship queries:\n\nAs noted above, soft deleted models will automatically be excluded from query results. However, you may force soft deleted models to be included in a query's results by calling the method on the query:\n\nThe method may also be called when building a relationship query:\n\nThe method will retrieve only soft deleted models:\n\nSometimes you may want to periodically delete models that are no longer needed. To accomplish this, you may add the or trait to the models you would like to periodically prune. After adding one of the traits to the model, implement a method which returns an Eloquent query builder that resolves the models that are no longer needed:\n\nWhen marking models as , you may also define a method on the model. This method will be called before the model is deleted. This method can be useful for deleting any additional resources associated with the model, such as stored files, before the model is permanently removed from the database:\n\nAfter configuring your prunable model, you should schedule the Artisan command in your application's file. You are free to choose the appropriate interval at which this command should be run:\n\nBehind the scenes, the command will automatically detect \"Prunable\" models within your application's directory. If your models are in a different location, you may use the option to specify the model class names:\n\nIf you wish to exclude certain models from being pruned while pruning all other detected models, you may use the option:\n\nYou may test your query by executing the command with the option. When pretending, the command will simply report how many records would be pruned if the command were to actually run:\n\nWhen models are marked with the trait, models are deleted from the database using mass-deletion queries. Therefore, the method will not be invoked, nor will the and model events be dispatched. This is because the models are never actually retrieved before deletion, thus making the pruning process much more efficient:\n\nYou may create an unsaved copy of an existing model instance using the method. This method is particularly useful when you have model instances that share many of the same attributes:\n\nTo exclude one or more attributes from being replicated to the new model, you may pass an array to the method:\n\nGlobal scopes allow you to add constraints to all queries for a given model. Laravel's own soft delete functionality utilizes global scopes to only retrieve \"non-deleted\" models from the database. Writing your own global scopes can provide a convenient, easy way to make sure every query for a given model receives certain constraints.\n\nTo generate a new global scope, you may invoke the Artisan command, which will place the generated scope in your application's directory:\n\nWriting a global scope is simple. First, use the command to generate a class that implements the interface. The interface requires you to implement one method: . The method may add constraints or other types of clauses to the query as needed:\n\nTo assign a global scope to a model, you may simply place the attribute on the model:\n\nOr, you may manually register the global scope by overriding the model's method and invoke the model's method. The method accepts an instance of your scope as its only argument:\n\nAfter adding the scope in the example above to the model, a call to the method will execute the following SQL query:\n\nEloquent also allows you to define global scopes using closures, which is particularly useful for simple scopes that do not warrant a separate class of their own. When defining a global scope using a closure, you should provide a scope name of your own choosing as the first argument to the method:\n\nIf you would like to remove a global scope for a given query, you may use the method. This method accepts the class name of the global scope as its only argument:\n\nOr, if you defined the global scope using a closure, you should pass the string name that you assigned to the global scope:\n\nIf you would like to remove several or even all of the query's global scopes, you may use the method:\n\nLocal scopes allow you to define common sets of query constraints that you may easily re-use throughout your application. For example, you may need to frequently retrieve all users that are considered \"popular\". To define a scope, prefix an Eloquent model method with .\n\nScopes should always return the same query builder instance or :\n\nOnce the scope has been defined, you may call the scope methods when querying the model. However, you should not include the prefix when calling the method. You can even chain calls to various scopes:\n\nCombining multiple Eloquent model scopes via an query operator may require the use of closures to achieve the correct logical grouping:\n\nHowever, since this can be cumbersome, Laravel provides a \"higher order\" method that allows you to fluently chain scopes together without the use of closures:\n\nSometimes you may wish to define a scope that accepts parameters. To get started, just add your additional parameters to your scope method's signature. Scope parameters should be defined after the parameter:\n\nOnce the expected arguments have been added to your scope method's signature, you may pass the arguments when calling the scope:\n\nIf you would like to use scopes to create models that have the same attributes as those used to constrain the scope, you may use the method when building the scope query:\n\nThe method will add clause constraints to the query using the given attributes, and it will also add the given attributes to any models created via the scope:\n\nSometimes you may need to determine if two models are the \"same\" or not. The and methods may be used to quickly verify two models have the same primary key, table, and database connection or not:\n\nThe and methods are also available when using the , , , and relationships. This method is particularly helpful when you would like to compare a related model without issuing a query to retrieve that model:\n\nEloquent models dispatch several events, allowing you to hook into the following moments in a model's lifecycle: , , , , , , , , , , , , , , and .\n\nThe event will dispatch when an existing model is retrieved from the database. When a new model is saved for the first time, the and events will dispatch. The / events will dispatch when an existing model is modified and the method is called. The / events will dispatch when a model is created or updated - even if the model's attributes have not been changed. Event names ending with are dispatched before any changes to the model are persisted, while events ending with are dispatched after the changes to the model are persisted.\n\nTo start listening to model events, define a property on your Eloquent model. This property maps various points of the Eloquent model's lifecycle to your own event classes. Each model event class should expect to receive an instance of the affected model via its constructor:\n\nAfter defining and mapping your Eloquent events, you may use event listeners to handle the events.\n\nInstead of using custom event classes, you may register closures that execute when various model events are dispatched. Typically, you should register these closures in the method of your model:\n\nIf needed, you may utilize queueable anonymous event listeners when registering model events. This will instruct Laravel to execute the model event listener in the background using your application's queue:\n\nIf you are listening for many events on a given model, you may use observers to group all of your listeners into a single class. Observer classes have method names which reflect the Eloquent events you wish to listen for. Each of these methods receives the affected model as their only argument. The Artisan command is the easiest way to create a new observer class:\n\nThis command will place the new observer in your directory. If this directory does not exist, Artisan will create it for you. Your fresh observer will look like the following:\n\nTo register an observer, you may place the attribute on the corresponding model:\n\nOr, you may manually register an observer by invoking the method on the model you wish to observe. You may register observers in the method of your application's class:\n\nWhen models are being created within a database transaction, you may want to instruct an observer to only execute its event handlers after the database transaction is committed. You may accomplish this by implementing the interface on your observer. If a database transaction is not in progress, the event handlers will execute immediately:\n\nYou may occasionally need to temporarily \"mute\" all events fired by a model. You may achieve this using the method. The method accepts a closure as its only argument. Any code executed within this closure will not dispatch model events, and any value returned by the closure will be returned by the method:\n\nSometimes you may wish to \"save\" a given model without dispatching any events. You may accomplish this using the method:\n\nYou may also \"update\", \"delete\", \"soft delete\", \"restore\", and \"replicate\" a given model without dispatching any events:"
    },
    {
        "link": "https://laravel.com/docs/7.x/eloquent",
        "document": "WARNING You're browsing the documentation for an old version of Laravel. Consider upgrading your project to Laravel 12.x .\n\nThe Eloquent ORM included with Laravel provides a beautiful, simple ActiveRecord implementation for working with your database. Each database table has a corresponding \"Model\" which is used to interact with that table. Models allow you to query for data in your tables, as well as insert new records into the table.\n\nBefore getting started, be sure to configure a database connection in . For more information on configuring your database, check out the documentation.\n\nTo get started, let's create an Eloquent model. Models typically live in the directory, but you are free to place them anywhere that can be auto-loaded according to your file. All Eloquent models extend class.\n\nThe easiest way to create a model instance is using the Artisan command:\n\nIf you would like to generate a database migration when you generate the model, you may use the or option:\n\nNow, let's look at an example model, which we will use to retrieve and store information from our database table:\n\nNote that we did not tell Eloquent which table to use for our model. By convention, the \"snake case\", plural name of the class will be used as the table name unless another name is explicitly specified. So, in this case, Eloquent will assume the model stores records in the table. You may specify a custom table by defining a property on your model:\n\nEloquent will also assume that each table has a primary key column named . You may define a protected property to override this convention:\n\nIn addition, Eloquent assumes that the primary key is an incrementing integer value, which means that by default the primary key will automatically be cast to an . If you wish to use a non-incrementing or a non-numeric primary key you must set the public property on your model to :\n\nIf your primary key is not an integer, you should set the protected property on your model to :\n\nBy default, Eloquent expects and columns to exist on your tables. If you do not wish to have these columns automatically managed by Eloquent, set the property on your model to :\n\nIf you need to customize the format of your timestamps, set the property on your model. This property determines how date attributes are stored in the database, as well as their format when the model is serialized to an array or JSON:\n\nIf you need to customize the names of the columns used to store the timestamps, you may set the and constants in your model:\n\nBy default, all Eloquent models will use the default database connection configured for your application. If you would like to specify a different connection for the model, use the property:\n\nIf you would like to define the default values for some of your model's attributes, you may define an property on your model:\n\nOnce you have created a model and its associated database table, you are ready to start retrieving data from your database. Think of each Eloquent model as a powerful query builder allowing you to fluently query the database table associated with the model. For example:\n\nThe Eloquent method will return all of the results in the model's table. Since each Eloquent model serves as a query builder, you may also add constraints to queries, and then use the method to retrieve the results:\n\nYou can refresh models using the and methods. The method will re-retrieve the model from the database. The existing model instance will not be affected:\n\nThe method will re-hydrate the existing model using fresh data from the database. In addition, all of its loaded relationships will be refreshed as well:\n\nFor Eloquent methods like and which retrieve multiple results, an instance of will be returned. The class provides a variety of helpful methods for working with your Eloquent results:\n\nYou may also loop over the collection like an array:\n\nIf you need to process thousands of Eloquent records, use the command. The method will retrieve a \"chunk\" of Eloquent models, feeding them to a given for processing. Using the method will conserve memory when working with large result sets:\n\nThe first argument passed to the method is the number of records you wish to receive per \"chunk\". The Closure passed as the second argument will be called for each chunk that is retrieved from the database. A database query will be executed to retrieve each chunk of records passed to the Closure.\n\nThe method allows you to iterate through your database records using a cursor, which will only execute a single query. When processing large amounts of data, the method may be used to greatly reduce your memory usage:\n\nThe returns an instance. Lazy collections allow you to use many of collection methods available on typical Laravel collections while only loading a single model into memory at a time:\n\nEloquent also offers advanced subquery support, which allows you to pull information from related tables in a single query. For example, let's imagine that we have a table of flight and a table of to destinations. The table contains an column which indicates when the flight arrived at the destination.\n\nUsing the subquery functionality available to the and methods, we can select all of the and the name of the flight that most recently arrived at that destination using a single query:\n\nIn addition, the query builder's function supports subqueries. We may use this functionality to sort all destinations based on when the last flight arrived at that destination. Again, this may be done while executing a single query against the database:\n\nIn addition to retrieving all of the records for a given table, you may also retrieve single records using , , or . Instead of returning a collection of models, these methods return a single model instance:\n\nYou may also call the method with an array of primary keys, which will return a collection of the matching records:\n\nSometimes you may wish to retrieve the first result of a query or perform some other action if no results are found. The method will return the first result that is found or, if no results are found, execute the given callback. The result of the callback will be considered the result of the method:\n\nThe method also accepts an array of columns to retrieve:\n\nSometimes you may wish to throw an exception if a model is not found. This is particularly useful in routes or controllers. The and methods will retrieve the first result of the query; however, if no result is found, a will be thrown:\n\nIf the exception is not caught, a HTTP response is automatically sent back to the user. It is not necessary to write explicit checks to return responses when using these methods:\n\nYou may also use the , , , and other aggregate methods provided by the query builder. These methods return the appropriate scalar value instead of a full model instance:\n\nTo create a new record in the database, create a new model instance, set attributes on the model, then call the method:\n\nIn this example, we assign the parameter from the incoming HTTP request to the attribute of the model instance. When we call the method, a record will be inserted into the database. The and timestamps will automatically be set when the method is called, so there is no need to set them manually.\n\nThe method may also be used to update models that already exist in the database. To update a model, you should retrieve it, set any attributes you wish to update, and then call the method. Again, the timestamp will automatically be updated, so there is no need to manually set its value:\n\nUpdates can also be performed against any number of models that match a given query. In this example, all flights that are and have a of will be marked as delayed:\n\nThe method expects an array of column and value pairs representing the columns that should be updated.\n\nEloquent provides the , , and methods to examine the internal state of your model and determine how its attributes have changed from when they were originally loaded.\n\nThe method determines if any attributes have been changed since the model was loaded. You may pass a specific attribute name to determine if a particular attribute is dirty. The method is the opposite of and also accepts an optional attribute argument:\n\nThe method determines if any attributes were changed when the model was last saved within the current request cycle. You may also pass an attribute name to see if a particular attribute was changed:\n\nThe method returns an array containing the original attributes of the model regardless of any changes since the model was loaded. You may pass a specific attribute name to get the original value of a particular attribute:\n\nYou may also use the method to save a new model in a single line. The inserted model instance will be returned to you from the method. However, before doing so, you will need to specify either a or attribute on the model, as all Eloquent models protect against mass-assignment by default.\n\nA mass-assignment vulnerability occurs when a user passes an unexpected HTTP parameter through a request, and that parameter changes a column in your database you did not expect. For example, a malicious user might send an parameter through an HTTP request, which is then passed into your model's method, allowing the user to escalate themselves to an administrator.\n\nSo, to get started, you should define which model attributes you want to make mass assignable. You may do this using the property on the model. For example, let's make the attribute of our model mass assignable:\n\nOnce we have made the attributes mass assignable, we can use the method to insert a new record in the database. The method returns the saved model instance:\n\nIf you already have a model instance, you may use the method to populate it with an array of attributes:\n\nIf you would like to make all attributes mass assignable, you may define the property as an empty array:\n\nThere are two other methods you may use to create models by mass assigning attributes: and . The method will attempt to locate a database record using the given column / value pairs. If the model can not be found in the database, a record will be inserted with the attributes from the first parameter, along with those in the optional second parameter.\n\nThe method, like will attempt to locate a record in the database matching the given attributes. However, if a model is not found, a new model instance will be returned. Note that the model returned by has not yet been persisted to the database. You will need to call manually to persist it:\n\nYou may also come across situations where you want to update an existing model or create a new model if none exists. Laravel provides an method to do this in one step. Like the method, persists the model, so there's no need to call :\n\nTo delete a model, call the method on a model instance:\n\nIn the example above, we are retrieving the model from the database before calling the method. However, if you know the primary key of the model, you may delete the model without explicitly retrieving it by calling the method. In addition to a single primary key as its argument, the method will accept multiple primary keys, an array of primary keys, or a collection of primary keys:\n\nYou can also run a delete statement on a set of models. In this example, we will delete all flights that are marked as inactive. Like mass updates, mass deletes will not fire any model events for the models that are deleted:\n\nIn addition to actually removing records from your database, Eloquent can also \"soft delete\" models. When models are soft deleted, they are not actually removed from your database. Instead, a attribute is set on the model and inserted into the database. If a model has a non-null value, the model has been soft deleted. To enable soft deletes for a model, use the trait on the model:\n\nYou should also add the column to your database table. The Laravel schema builder contains a helper method to create this column:\n\nNow, when you call the method on the model, the column will be set to the current date and time. And, when querying a model that uses soft deletes, the soft deleted models will automatically be excluded from all query results.\n\nTo determine if a given model instance has been soft deleted, use the method:\n\nAs noted above, soft deleted models will automatically be excluded from query results. However, you may force soft deleted models to appear in a result set using the method on the query:\n\nThe method may also be used on a relationship query:\n\nThe method will retrieve only soft deleted models:\n\nSometimes you may wish to \"un-delete\" a soft deleted model. To restore a soft deleted model into an active state, use the method on a model instance:\n\nYou may also use the method in a query to quickly restore multiple models. Again, like other \"mass\" operations, this will not fire any model events for the models that are restored:\n\nLike the method, the method may also be used on relationships:\n\nSometimes you may need to truly remove a model from your database. To permanently remove a soft deleted model from the database, use the method:\n\nYou may create an unsaved copy of a model instance using the method. This is particularly useful when you have model instances that share many of the same attributes:\n\nGlobal scopes allow you to add constraints to all queries for a given model. Laravel's own soft delete functionality utilizes global scopes to only pull \"non-deleted\" models from the database. Writing your own global scopes can provide a convenient, easy way to make sure every query for a given model receives certain constraints.\n\nWriting a global scope is simple. Define a class that implements the interface. This interface requires you to implement one method: . The method may add constraints to the query as needed:\n\nTo assign a global scope to a model, you should override a given model's method and use the method:\n\nAfter adding the scope, a query to will produce the following SQL:\n\nEloquent also allows you to define global scopes using Closures, which is particularly useful for simple scopes that do not warrant a separate class:\n\nIf you would like to remove a global scope for a given query, you may use the method. The method accepts the class name of the global scope as its only argument:\n\nOr, if you defined the global scope using a Closure:\n\nIf you would like to remove several or even all of the global scopes, you may use the method:\n\nLocal scopes allow you to define common sets of constraints that you may easily re-use throughout your application. For example, you may need to frequently retrieve all users that are considered \"popular\". To define a scope, prefix an Eloquent model method with .\n\nOnce the scope has been defined, you may call the scope methods when querying the model. However, you should not include the prefix when calling the method. You can even chain calls to various scopes, for example:\n\nCombining multiple Eloquent model scopes via an query operator may require the use of Closure callbacks:\n\nHowever, since this can be cumbersome, Laravel provides a \"higher order\" method that allows you to fluently chain these scopes together without the use of Closures:\n\nSometimes you may wish to define a scope that accepts parameters. To get started, just add your additional parameters to your scope. Scope parameters should be defined after the parameter:\n\nNow, you may pass the parameters when calling the scope:\n\nSometimes you may need to determine if two models are the \"same\". The method may be used to quickly verify two models have same primary key, table, and database connection:\n\nEloquent models fire several events, allowing you to hook into the following points in a model's lifecycle: , , , , , , , , , , . Events allow you to easily execute code each time a specific model class is saved or updated in the database. Each event receives the instance of the model through its constructor.\n\nThe event will fire when an existing model is retrieved from the database. When a new model is saved for the first time, the and events will fire. The / events will fire when an existing model is modified and the method is called. The / events will fire when a model is created or updated.\n\nTo get started, define a property on your Eloquent model that maps various points of the Eloquent model's lifecycle to your own event classes:\n\nAfter defining and mapping your Eloquent events, you may use event listeners to handle the events.\n\nInstead of using custom event classes, you may register Closures that execute when various model events are fired. Typically, you should register these Closures in the method of your model:\n\nIf you are listening for many events on a given model, you may use observers to group all of your listeners into a single class. Observers classes have method names which reflect the Eloquent events you wish to listen for. Each of these methods receives the model as their only argument. The Artisan command is the easiest way to create a new observer class:\n\nThis command will place the new observer in your directory. If this directory does not exist, Artisan will create it for you. Your fresh observer will look like the following:\n\nTo register an observer, use the method on the model you wish to observe. You may register observers in the method of one of your service providers. In this example, we'll register the observer in the :\n\nYou may occasionally wish to temporarily \"mute\" all events fired by a model. You may achieve this using the method. The method accepts a Closure as its only argument. Any code executed within this Closure will not fire model events. For example, the following will fetch and delete an instance without firing any model events. Any value returned by the given Closure will be returned by the method:"
    },
    {
        "link": "https://laravel-docs.readthedocs.io/en/latest/eloquent",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/20030716/change-default-primary-key-in-eloquent",
        "document": "I want to set primary key for example instead of 'id'?\n\nI know I can change table name for model like\n\nIs there something similar for primary key?"
    }
]