[
    {
        "link": "https://stackoverflow.com/questions/40156839/vba-error-handling-issue-with-blank-cells",
        "document": "This is a sample of a part of a table that I'm working with:\n\nThis table is generated from some other VBA code. I wrote a simple script to clear the #VALUE terms from the table after it's generated.\n\nNow the table looks like:\n\nFor some reason this code clears the entire column if it has any blanks and not just the #VALUE errors. I want it to just delete the #VALUE errors and keep all other cells. As far as I can tell the code should be doing that. What is the error?"
    },
    {
        "link": "https://excelmacromastery.com/vba-error-handling",
        "document": "This post provides a complete guide to VBA Error Handing. If you are looking for a quick summary then check out the quick guide table in the first section.\n\nIf you are looking for a particular topic on VBA Error Handing then check out the table of contents below(if it’s not visible click on the post header).\n\nIf you are new to VBA Error Handling, then you can read the post from start to finish as it is laid out in logical order.\n\nMembers of the Webinar Archives can access the webinar for this article by clicking on the image below.\n\nError Handling refers to code that is written to handle errors which occur when your application is running. These errors are normally caused by something outside your control like a missing file, database being unavailable, data being invalid etc.\n\nIf we think an error is likely to occur at some point, it is good practice to write specific code to handle the error if it occurs and deal with it.\n\nFor all other errors, we use generic code to deal with them. This is where the VBA error handling statement comes into play. They allow our application to deal gracefully with any errors we weren’t expecting.\n\nTo understand error handling we must first understand the different types of errors in VBA.\n\nThere are three types of errors in VBA:\n\nWe use error handling to deal with runtime errors. Let’s have a look at each of these error types so that it is clear what a runtime error is.\n\nIf you have used VBA for any length of time you will have seen a syntax error. When you type a line and press return, VBA will evaluate the syntax and if it is not correct it will display an error message.\n\nFor example if you type If and forget the Then keyword, VBA will display the following error message\n\nSome examples of syntax errors are\n\nSyntax errors relate to one line only. They occur when the syntax of one line is incorrect.\n\nNote: You can turn off the Syntax error dialog by going to Tools->Options and checking off “Auto Syntax Check”. The line will still appear red if there is an error but the dialog will not appear.\n\nCompilation errors occur over more than one line. The syntax is correct on a single line but is incorrect when all the project code is taken into account.\n• If statement without corresponding End If statement\n• For without Next\n• Calling a Sub or Function that does not exist\n• Calling a Sub or Function with the wrong parameters\n• Giving a Sub or Function the same name as a module\n• Variables not declared(Option Explicit must be present at the top of the module)\n\nThe following screenshot shows a compilation error that occurs when a For loop has no matching Next statement.\n\nTo find compilation errors, we use Debug->Compile VBA Project from the Visual Basic menu.\n\nWhen you select Debug->Compile, VBA displays the first error it comes across.\n\nWhen this error is fixed, you can run Compile again and VBA will then find the next error.\n\nDebug->Compile will also include syntax errors in it’s search which is very useful.\n\nIf there are no errors left and you run Debug->Compile , it may appear that nothing happened. However, “Compile” will be grayed out in the Debug menu. This means your application has no compilation errors at the current time.\n• It will also find syntax errors.\n• It finds one error each time you use it.\n• When there are no compilation errors left the Compile option will appear grayed out in the menu.\n\nYou should always use Debug->Compile before you run your code. This ensures that your code has no compilation errors when you run it.\n\nIf you do not run Debug->Compile then VBA may find compile errors when it runs. These should not be confused with Runtime errors.\n\nRuntime errors occur when your application is running. They are normally outside of your control but can be caused by errors in your code.\n\nFor example, imagine your application reads from an external workbook. If this file gets deleted then VBA will display an error when your code tries to open it.\n\nOther examples of runtime errors are\n• a database not being available\n• a cell containing text instead of a number\n\nAs we have seen, the purpose of error handling is to deal with runtime errors when they occur.\n\nWhen we think a runtime error could occur we put code in place to handle it. For example, we would normally put code in place to deal with a file not being found.\n\nThe following code checks if the file exists before it tries to open it. If the file does not exist then a user friendly message is displayed and the code exits the sub.\n\nWhen we think an error is likely to occur at some point, it is good practice to add code to handle the situation. We normally refer to these errors as expected errors.\n\nIf we don’t have specific code to handle an error it is considered an unexpected error. We use the VBA error handling statements to handle the unexpected errors.\n\nRuntime Errors that are not VBA Errors\n\nBefore we look at the VBA Handling there is one type of error we must mention. Some runtime errors are not considered errors by VBA but only by the user.\n\nLet me explain this with an example. Imagine you have an application that requires you to add the values in the variables a and b\n\nLet’s say you mistakenly use an asterisk instead of the plus sign\n\nThis is not a VBA error. Your code syntax is perfectly legal. However, from your requirements point of view it is an error.\n\nThese errors cannot be dealt with using error handling as they obviously won’t generate any error. You can deal with these errors using Unit Testing and Assertions. I have an in-depth post about using VBA assertions – see How to Make Your Code BulletProof.\n\nAs we have seen there are two ways to treat runtime errors\n• Unexpected errors – use VBA error handling statements to handle them.\n\nThe VBA On Error statement is used for error handling. This statement performs some action when an error occurs during runtime.\n\nThere are four different ways to use this statement\n• On Error GoTo 0 – the code stops at the line with the error and displays a message.\n• On Error Resume Next – the code moves to next line. No error message is displayed.\n• On Error GoTo [label] – the code moves to a specific line or label. No error message is displayed. This is the one we use for error handling.\n\nLet’s look at each of these statements in turn.\n\nThis is the default behavior of VBA. In other words, if you don’t use On Error then this is the behavior you will see.\n\nWhen an error occurs, VBA stops on the line with the error and displays the error message. The application requires user intervention with the code before it can continue. This could be fixing the error or restarting the application. In this scenario no error handling takes place.\n\nLet’s look at an example. In the following code, we have not used any On Error line so VBA will use the On Error GoTo 0 behavior by default.\n\n\n\n The second assignment line results in a divide by zero error. When we run this code we will get the error message shown in the screenshot below\n\n \n\n\n\n\n\n When the error appears you can choose End or Debug\n\nIf you select End then the application simply stops.\n\n If you select Debug the application stops on the error line as the screenshot below shows\n\nThis behaviour is fine when you are writing VBA code as it shows you the exact line with the error.\n\nHowever, this behavior is unsuitable when you give you application to a user. These errors look unprofessional and they make the application look unstable.\n\nAn error like this is essentially the application crashing. The user cannot continue on without restarting the application. They may not use it at all until you fix the error for them.\n\nBy using On Error GoTo [label] we can give the user a more controlled error message. It also prevents the application stopping. We can get the application to perform in a predefined manner.\n\nUsing On Error Resume Next tells VBA to ignore the error and continue on.\n\nThere are specific occasions when this is useful. Most of the time you should avoid using it.\n\nIf we add Resume Next to our example Sub then VBA will ignore the divide by zero error\n\nIt is not a good idea to do this. If you ignore the error, then the behavior can be unpredictable. The error can affect the application in multiple ways.You could end up with invalid data. The problem is that you aren’t aware that something went wrong because you have suppressed the error.\n\nThe code below is an example of where using Resume Next is valid\n\nIn this code we are checking to see if Microsoft Outlook is available on a computer. All we want to know is if it is available or not. We are not interested in the specific error.\n\nIn the code above, we continue on if there is an error. Then in the next line we check the value of the Outlook variable. If there has been an error then the value of this variable will be set to Nothing.\n\nThis is an example of when Resume could be useful. The point is that even though we use Resume we are still checking for the error. The vast majority of the time you will not need to use Resume.\n\nThis is how we use Error Handling in VBA. It is the equivalent of the Try and Catch functionality you see in languages such as C# and Java.\n\nWhen an error occurs you send the error to a specific label. It is normally at the bottom of the sub.\n\nLet’s apply this to the sub we have been using\n\nThe screenshot below shows what happens when an error occurs\n\nVBA jumps to the eh label because we specified this in the On Error Goto line.\n\nNote 1: The label we use in the On…GoTo statement, must be in the current Sub/Function. If not you will get a compilation error.\n\nNote 2: When an error occurs when using On Error GoTo [label], the error handling returns to the default behaviour i.e. The code will stop on the line with the error and display the error message. See the next section for more information about this.\n\nThis statement is different than the other three. It is used to clear the current error rather than setting a particular behaviour.\n\nWhen an error occurs using On Error GoTo [label], the error handling behaviour returns to the default behaviour i.e. “On Error GoTo 0”. That means that if another error occurs the code will stop on the current line.\n\nThis behaviour only applies to the current sub. Once we exit the sub, the error will be cleared automatically.\n\nTake a look at the code below. The first error will cause the code to jump to the eh label. The second error will stop on the line with the 1034 error.\n\nIf we add further error handling it will not work as the error trap has not been cleared.\n\nIn the code below we have added the line\n\nafter we catch the first error.\n\nThis has no effect as the error has not been cleared. In other words the code will stop on the line with the error and display the message.\n\nTo clear the error we use On Error GoTo -1. Think of it like setting a mouse trap. When the trap goes off you need to set it again.\n\nIn the code below we add this line and the second error will now cause the code to jump to the eh_other label\n\nNote 1: There are probably rare cases where using On Error GoTo -1 is useful. In most cases using Resume Next is better as it clears the error and resumes the code at the next line after the error occurs.\n\nNote 2: The Err Object has a member Clear. Using Clear clears the text and numbers in the Err object, but it does NOT reset the error.\n\nAs we have seen, VBA will do one of three things when an error occurs\n• Ignore the error and continue on.\n\nVBA will always be set to one of these behaviors. When you use On Error, VBA will change to the behaviour you specify and forget about any previous behavior.\n\nIn the following Sub, VBA changes the error behaviour each time we use the On Error statement\n\nThe Resume Next statement is used to clear the error and then resume the code from the line after where the error occurred.\n\nIf your code can have multiple errors and you want to keep detecting them then this line is very useful.\n\nFor example, in the following code we want to resume the code after the error has been reported:\n\n\n\n We could use On Error Goto -1 to clear the code and then use a goto statement to go back to the code like this:\n\n\n\n The Resume Next provides a nicer way of doing it and it always means the code is much clearer and easier to understand:\n\nWhen an error occurs you can view details of the error using the Err object.\n\nWhen an runtime error occurs, VBA automatically fills the Err object with details.\n\nThe code below will print “Error Number: 13 Type Mismatch” which occurs when we try to place a string value in the long integer total\n\nThe Err.Description provides details of the error that occurs. This is the text you normally see when an error occurs e.g. “Type Mismatch”\n\nThe Err.Number is the ID number of the error e.g. the error number for “Type Mismatch” is 13. The only time you really need this is if you are checking that a specific error occurred and this is only necessary on rare occasions.\n\nThe Err.Source property seems like a great idea but it does not work for a VBA error. The source will return the project name, which hardly narrows down where the error occurred. However, if you create an error using Err.Raise you can set the source yourself and this can be very useful.\n\nThe Erl function is used to return the line number where the error occurs.\n\nIt often causes confusion. In the following code, Erl will return zero\n\nThis is because there are no line numbers present. Most people don’t realise it but VBA allows you to have line numbers.\n\nIf we change the Sub above to have line number it will now print out 20\n\nAdding line numbers to your code manually is cumbersome. However there are tools available that will allow you to easily add and remove line numbers to a sub.\n\nWhen you are finished working on a project and hand it over to the user it can be useful to add line numbers at this point. If you use the error handling strategy in the last section of this post, then VBA will report the line where the error occurred.\n\nErr.Raise allows us to create errors. We can use it to create custom errors for our application which is very useful. It is the equivalent of the Throw statement in Java\\C#.\n\nThe format is as follows\n\nLet’s look at a simple example. Imagine we want to ensure that a cell has an entry that has a length of 5 characters. We could have a specific message for this\n\nWhen we create an error using Err.Raise we need to give it a number. We can use any number from 513 to 65535 for our error. We must use vbObjectError with the number e.g.\n\nErr.Clear is used to clear the text and numbers from the Err.Object. In other words, it clears the description and number.If you want the clear the actual error you can use either On Error GoTo -1 or Resume Next\n\nIt is rare that you will need to use Err.Clear but let’s have a look at an example where you might.\n\nIn the code below we are counting the number of errors that will occur. To keep it simple we are generating an error for each odd number.\n\nWe check the error number each time we go through the loop. If the number does not equal zero then an error has occurred. Once we count the error we need to set the error number back to zero so it is ready to check for the next error.\n\nNote 1: Err.Clear resets the text and numbers in the error object but it does not clear the error – see Resume Next Or On Error GoTo -1 for more information about clearing the actual error.\n\nLogging means writing information from your application when it is running. When an error occurs you can write the details to a text file so you have a record of the error.\n\nThe code below shows a very simple logging procedure\n\nYou can use it like this\n\nThe log is not only for recording errors. You can record other information as the application runs. When an error occurs you can then check the sequence of events before an error occurred.\n\nBelow is an example of logging. How you implement logging really depends on the nature of the application and how useful it will be:\n\nHaving a lot of information when dealing with an error can be very useful. Often the user may not give you accurate information about the error that occurred. By looking at the log you can get more accurate information about the information.\n\nThis section covers some of the other Error Handling tools that VBA has. These items are considered obsolete but I have included them as they may exist in legacy code.\n\nThe Error Function is used to print the error description from a given error number. It is included in VBA for backward compatibility and is not needed because you can use the Err.Description instead.\n\nBelow are some examples:\n\nThe Error statement allows you to simulate an error. It is included in VBA for backward compatibility. You should use Err.Raise instead.\n\nIn the following code we simulate a “Divide by zero” error.\n\nThis statement is included in VBA for backward compatibility. You should use Err.Raise instead.\n\nWith all the different options you may be confused about how to use error handling in VBA. In this section, I’m going to show you how to implement a simple error handling strategy that you can use in all your applications.\n\nThis is a simple overview of our strategy\n• Place the On Error GoTo Label line at the start of our topmost sub.\n• Place the error handling Label at the end of our topmost sub.\n• If an expected error occurs then handle it and continue.\n• If the application cannot continue then use Err.Raise to jump to the error handling label.\n• If an unexpected error occurs the code will automatically jump to the error handling label.\n\nThe following image shows an overview of how this looks\n\nThe following code shows a simple implementation of this strategy:\n\nThis is a nice way of implementing error handling because\n• We don’t need to add error handling code to every sub.\n• If an error occurs then VBA exits the application gracefully.\n\nThe above strategy has one major drawback. It doesn’t provide any information about the error. It is better than having no strategy as it prevents the application crashing. But that is the only real benefit.\n\nVBA doesn’t fill Err.Source with anything useful so we have to do this ourselves.\n\nIn this section, I am going to introduce a more complete error strategy. I have written two subs that perform all the heavy lifting so all you have to do is add them to your project.\n\nThe purpose of this strategy is to provide you with the Stack* and line number when an error exists.\n\n*The Stack is the list of sub/functions that were currently in use when the error occurred.\n\nThis is our strategy\n• Place error handling in all the subs.\n• When an error occurs, the error handler adds details to the error and raises it again.\n• When the error reaches the topmost sub it is displayed.\n\nWe are simply “bubbling” the error to the top. The following diagram shows a simple visual of what happens when an error occurs in Sub3\n\nThe only messy part to this is formatting the strings correctly. I have written two subs that handle this, so it is taken care of for you.\n\nThere are the two helper subs, RaiseError and DisplayError. You can download the library below:\n\nAn Example of using this strategy\n\nHere is a simple coding example that uses these subs. In this strategy, we don’t place any code in the topmost sub. We only call subs from it.\n\nThe result looks like this:\n\nIf your project has line numbers the result will include the line number of the error:\n• Error Handling is used to handle errors that occur when your application is running.\n• You write specific code to handle expected errors. You use the VBA error handling statement On Error GoTo [label] to send VBA to a label when an unexpected error occurs.\n• You can get details of the error from Err.Description.\n• You can create your own error using Err.Raise.\n• Using one On Error statement in the top most sub will catch all errors in subs that are called from here.\n• If you want to record the name of the Sub with the error, you can update the error and rethrow it.\n• You can use a log to record information about the application as it is running.\n\nFree VBA Tutorial If you are new to VBA or you want to sharpen your existing VBA skills then why not try out the The Ultimate VBA Tutorial.\n\nRelated Training: Get full access to the Excel VBA training webinars and all the tutorials."
    },
    {
        "link": "https://answers.microsoft.com/en-us/msoffice/forum/all/ingnore-blank-cells-in-vba-code-to-prevent-a/0f17ca64-913d-4c15-aa70-53d3304230b2",
        "document": ""
    },
    {
        "link": "https://answers.microsoft.com/en-us/msoffice/forum/all/need-vba-code-to-validate-empty-cells-in-required/5f777cf7-9615-4bc7-9fea-7a2d26361437",
        "document": ""
    },
    {
        "link": "https://trumpexcel.com/vba-error-handling",
        "document": "No matter how experienced you’re with VBA coding, errors are always going to be a part of it.\n\nThe difference between a novice and an expert VBA programmer is that the expert programmers know how to effectively handle and use errors.\n\nIn this tutorial, I will show you various ways you can use to handle errors effectively in Excel VBA.\n\nBefore we get into VBA error handling, let’s first understand the different types of errors you are likely to encounter when programming in Excel VBA.\n\nThere are four types of errors in Excel VBA:\n\nLet’s quickly understand what these errors are and when you’re likely to encounter these.\n\nA syntax error, as the name suggests, occurs when VBA finds something wrong with the syntax in the code.\n\nFor example, if you forget a part of the statement/syntax that is needed, then you will see the compile error.\n\nIn the below code, as soon as I hit enter after the second line, I see a compile error. This is because the IF statement needs to have the ‘Then‘ command, which is missing in the below code.\n\nNote: When you are typing a code in Excel VBA, it checks for each sentence as soon as you hit enter. If VBA finds something missing in the syntax, it instantly shows a message with some text that can help you understand the missing part.\n\nTo make sure you see the syntax error whenever there is something missing, you need to make sure Autosyntax check is enabled. To do this, click on ‘Tools’ and then click on ‘Options’. In the options dialog box, make sure that the ‘Auto Syntax Check’ option is enabled.\n\nIf the ‘Auto Syntax Check’ option is disabled, VBA will still highlight the line with the syntax error in red, but it will not show the error dialog box.\n\nCompile errors occur when something is missing that is needed for the code to run.\n\nFor example, in the below code, as soon as I try to run the code, it will show the following error. This happens as I have used the IF Then statement without closing it with the mandatory ‘End If’.\n\nA syntax error is also a type of compile error. A syntax error occurs as soon as you hit enter and VBA identifies that something is missing. A compilation error can also occur when VBA doesn’t find anything missing while typing the code, but it does when the code is compiled or executed.\n\nVBA checks each line as you’re typing the code and highlights the syntax error as soon as the line is incorrect and you hit enter. Compile errors, on the other hand, are only identified when the entire code is analyzed by VBA.\n\nBelow are some scenarios where you’ll encounter the compile error:\n• Using an IF Statement without the End IF\n• Using For statement with the Next\n• Using Select statement without using the End Select\n• Not declaring the variable (this works only when Option Explicit is enabled)\n• Calling a Sub/Function that does not exist (or with wrong parameters)\n\nRuntime errors are those that occur when the code is running.\n\nRun time errors will occur only when all the syntax and compile errors are being taken care of.\n\nFor example, if you run code that is supposed to open an Excel workbook, but that workbook is unavailable (either deleted or name changed), your code would give you a runtime error.\n\nWhen a runtime error occurs, it will stop the code and show you the error dialog box.\n\nThe message in the Run-time error dialog box is a little more helpful. It tries to explain the problem that can help you correct it.\n\nIf you click on the Debug button, it will highlight the part of the code that is leading to the error.\n\nIf you have corrected the error, you can click on the Run button in the toolbar (or press F5) to continue running the code from where it left.\n\nOr you can also click on the End button to come out of the code.\n\nImportant: In case you click the End button in the dialog box, it will stop the code at the line at which is encountered. However, all the lines of code before that would have been executed.\n\nLogical errors would not make your code stop but can lead to wrong results. These could also be the most difficult types of errors to troubleshoot.\n\nThese errors are not highlighted by the compiler and need to be manually tackled.\n\nOne example of logical error (that I often find myself stuck with) is running into an endless loop.\n\nAnother example could be when it gives a result which is wrong. For example, you may end up using a wrong variable in the code or add two variables where one is incorrect.\n\nThere are a few ways I use to tackle logical errors:\n• Insert Message Box at some place in the code and highlight values/data that can help understand if eberything is going as expected.\n• Instead of running the code at one go, go through each line one by one. To do this, click anywhere in the code and press F8. you would notice that each time you press F8, one line gets executed. This allows you to go through the code one line at a time and identify the logical errors.\n\nOnce you’re done with the code, it’s a good practice to first compile it before running.\n\nTo compile a code, click on the Debug option in the toolbar and click on Compile VBAProject.\n\nWhen you compile a VBA project, it goes through the code and identifies errors (if any).\n\nIn case it finds an error, it will show you a dialog box with the error. It finds errors one by one. So if it finds an error and you have corrected it, you need to run compile again to find other errors (if there are).\n\nWhen you’re code is free of errors, the Compile VBAProject option will be greyed out.\n\nNote that Compiling will only find ‘Syntax’ errors and ‘Compile’ errors. It will NOT find the run-time errors.\n\nWhen you’re writing VBA code, you don’t want the errors to crop up. To avoid this, there are many error-handling methods you can use.\n\nIn the next few sections of this article, I will be covering the methods you can use for VBA error handling in Excel.\n\nBefore you start working with your code, you need to check for one setting in Excel VBA.\n\nGo to the VBA toolbar and click on Tools and then click on Options.\n\nIn the Options dialog box, click on the General tab and make sure that within the ‘Error Trapping’ group, ‘Break on Unhandled Errors’ is checked.\n\nLet me explain the three options:\n• Break on All Errors: This will stop your code on all types of errors, even when you have used the techniques to handle these errors.\n• Break in Class Module: This will stop your code on all unhandled errors, and at the same time, if you’re using objects such as Userforms, it will also break within those objects and highlight the exact line causing the error.\n• Break on Unhandled Errors: This will stop your code only for those errors that are not handled. This is the default setting as it ensures any unhandled errors are brought to your notice. If you’re using objects such as Userforms, this will not highlight the line causing the error in the object, but will only highlight the line that’s referring to that object.\n\nNote: If you work with objects such as Userforms, you can change this setting to ‘Break on Class Modules’. The difference between #2 and #3 is that when you use Break in Class Module, it will take you to the specific line in the object that is causing the error. You can also choose to go with this instead of ‘Break on Unhandled Errors’.\n\nSo in a nutshell – if you’re just starting with Excel VBA, ensure ‘Break on Unhandled Errors’ is checked.\n\nWhen your code encounters an error, there are a few things you can do:\n• Ignore the error and let the code continue\n• Have an error handling code in place and run it when an error occurs\n\nBoth of these error handling methods ensures that the end user will not get to see an error.\n\nThere are a few ‘On Error’ statements that you can use to get these done.\n\nWhen you use ‘On Error Resume Next’ in your code, any encountered error will be ignored and the code will continue to run.\n\nThis error handling method is used quite often, but you need to be cautious when using it. Since it completely ignores any error that may occur, you may not be able to identify the errors that need to be corrected.\n\nFor example, if the below code is run, it will return an error.\n\nThis happens because you can not divide a number by zero.\n\nBut if I use the ‘On Error Resume Next’ statement in this code (as shown below), it will ignore the error and I will not know that there is an issue that needs to be corrected.\n\nOn Error Resume Next should be used only when you clearly know the kind of errors your VBA code is expected to throw and it’s alright to ignore it.\n\nFor example, below is the VBA event code that would instantly add the date and time value in cell A1 of a newly inserted sheet (this code is added in the worksheet and not in a module).\n\nWhile this works great in most cases, it would show an error if I add a chart sheet instead of a worksheet. Since a chart sheet does not have cells, the code would throw an error.\n\nSo, if I use the ‘On Error Resume Next’ statement in this code, it will work as expected with worksheets and do nothing with chart sheets.\n\nNote: On Error Resume Next Statement is best used when you know what kind of errors you’re likely to encounter. And then if you think it’s safe to ignore these errors, you can use it.\n\nYou can take this code to the next level by analyzing if there was an error, and displaying a relevant message for it.\n\nThe below code would show a message box that would inform the user that a worksheet has not been inserted.\n\n‘Err.Number’ is used to get the error number and ‘Err.Description’ is used to get the error description. These will be covered later in this tutorial.\n\n‘On Error GoTo 0’ will stop the code on the line that causes the error and shows a message box that describes the error.\n\nIn simple terms, it enables the default error checking behavior and shows the default error message.\n\nThen why even use it?\n\nNormally, you don’t need to use ‘On Error Goto 0’, but it can be useful when you use it in conjunction with ‘On Error Resume Next’\n\nThe below code would select all the blank cells in the selection.\n\nBut it would show an error when there are no blank cells in the selected cells.\n\nSo to avoid showing the error, you can use On Error Resume next’\n\nNow, it will also show any error when you run the below code:\n\nSo far, so good!\n\nThe problem arises when there is a part of the code where error can occur, and since you’re using ‘On Error Resume Next’, the code would simply ignore it and move to the next line.\n\nFor example, in the below code, there would no error prompt:\n\nIn the above code, there are two places where an error can occur. The first place is where we are selecting all blank cells (using Selection.SpecialCells) and the second is in the remaining code.\n\nWhile the first error is expected, any error after that is not.\n\nThis is where On Error Goto 0 comes to rescue.\n\nWhen you use it, you reset the error setting to default, where it will start showing errors when it encounters it.\n\nFor example, in the below code, there would be no error in case there are no blank cells, but there would be an error prompt because of ’10/0′\n\nThe above two methods – ‘On Error Resume Next’ and ‘On Error Goto 0’ – doesn’t allow us to truly handle the error. One makes the code ignore the error and the second one resume error checking.\n\nOn Error Go [Label] is a way with which you can specify what you want to do in case your code has an error.\n\nBelow is the code structure that uses this error handler:\n\nNote that before the Error handling ‘Label’, there is an Exit Sub. This ensures that in case there are no errors, the sub is exited and the ‘Label’ code is not executed. In case you don’t use Exit Sub, it will always execute the ‘Label’ code.\n\nIn the example code below, when an error occurs, the code jumps and executes the code in the handler section (and shows a message box).\n\nNote that when an error occurs, the code has already run and executed the lines before the line causing the error. In the above example, the code sets the value of X as 12, but since the error occurs in the next line, it doesn’t set the values for Y and Z.\n\nOnce the code jumps to the error handler code (ErrMsg in this example), it will continue to execute all the lines in and below the error handler code and the exit the sub.\n\nThis one is a bit complicated, and in most cases, you’re unlikely to use this.\n\nBut I will still cover this as I have faced a situation where this was needed (feel free to ignore and jump to the next section if you’re only looking for basics).\n\nBefore I get into the mechanics of it, let me try and explain where can it be useful.\n\nSuppose you have a code where an error is encountered. But all is good as you have one error handler in place. But what happens when there is another error in the error handler code (yeah.. somewhat like the inception movie).\n\nIn such a case, you can not use the second handler as the first error has not been cleared. So while you have handled the first error, in VBA’s memory it still exists. And the VBA memory only has a place for one error – not two or more than that.\n\nIn this scenario, you can use On Error Goto -1.\n\nIt clears the error and frees up VBA memory to handle the next error.\n\nLet’s me explain now by using examples.\n\nSuppose I have the below code. This will throw an error as there is division by zero.\n\nSo to handle it, I use an error handler code (with the name ErrMsg) as shown below:\n\nAll is good now again. As soon as the error occurs, the error handler is used and shows a message box as shown below.\n\nNow, I expand the code so that I have more code in or after the error handler.\n\nSince the first error has been handled but the second has not been, I again see an error as shown below.\n\nStill all good. The code is behaving in the way we expected it to.\n\nSo to handle the second error, I use another error handler (ErrMsg2).\n\nAnd this is where it doesn’t work as expected.\n\nIf you run the above code, it will still give you a run-time error, even after having the second error handler in place.\n\nThis happens as we didn’t clear the first error from VBA’s memory.\n\nYes, we handled it! But it still remains in the memory.\n\nAnd when VBA encounters another error, it’s still stuck with the first error, and hence the second error handler is not used. The code stops at the line that caused the error and shows the error prompt.\n\nTo clear VBA’s memory and clear the previous error, you need to use the ‘On Error Goto -1’.\n\nSo if you add this line in the below code and run it, it will work as expected.\n\nNote: The error automatically gets cleared when a subroutine ends. So, ‘On Error Goto -1’ can be useful when you’re getting two or more than two errors in the same subroutine.\n\nWhenever an error occurs with a code, it’s the Err object that is used to get the details about the error (such as the error number or the description).\n\nThe Err Object has the following properties:\n\nWhile in most cases you don’t need to use Err object, it can sometimes be useful while handling errors in Excel.\n\nFor example, suppose you have a dataset as shown below and for each number, in the selection, you want to calculate the square root in the adjacent cell.\n\nThe below code can do it, but since there is a text string in cell A5, it shows an error as soon as this occurs.\n\nThe problem with this type of error message is that it gives you nothing about what has gone wrong and where the issue occurred.\n\nYou can use the Err object to make these error messages more meaningful.\n\nFor example, if I now use the below VBA code, it will stop the code as soon as the error occurs and show a message box with the cell address of the cell where there is an issue.\n\nThe above code would give you a lot more information than the simple ‘Type Mismatch’, especially the cell address so that you know where the error occurred.\n\nYou can further refine this code to make sure your code runs until the end (instead of breaking at each error) and then gives you a list of cell address where the error occurs.\n\nThe below code would do this:\n\nThe above code runs until the end and gives the square root of all the cells that have numbers in it (in the adjacent column). It then shows a message that lists all the cells where there was an error (as shown below):\n\nWhile the Err properties are useful to show useful information about the errors, there are two Err methods as well that can help you with error handling.\n\nLet’s quickly learn what these are and how/why to use these with VBA in Excel.\n\nSuppose you have a dataset as shown below and you want to get the square root of all these numbers in the adjacent column.\n\nThe following code will get the square roots of all the numbers in the adjacent column and show a message that an error occurred for cell A5 and A9 (as these have text in it).\n\nNote that I have used the Err.Clear method within the If Then statement.\n\nOnce an error has occurred and trapped by the If condition, Err.Clear method resets the error number back to 0. This ensures that IF condition only trap the errors for cells where it is raised.\n\nHad I not used the Err.Clear method, once the error occurs, it would always be true in the IF condition, and the error number has not been reset.\n\nAnother way of making this work is by using the On Error Goto -1, which resets the error completely.\n\nNote: Err.Clear is different from On Error Goto -1. Err.Clear only clears the error description and the error number. it doesn’t completely reset it. This means that if there is another instance of error in the same code, you won’t be able to handle it before resetting it (which can be done with ‘On Error Goto -1’ and not by ‘Err.Clear’).\n\nThe Err.Raise method allows you to raise a run-time error.\n\nBelow is the syntax of using the Err.Raise method:\n\nAll these arguments are optional and you can use these to make your error message more meaningful.\n\nBut why would you ever want to raise an error yourself?\n\nYou can use this method when there is an instance of an error (which means that there is going to an error anyway) and then you use this method to tell the user more about the error (instead of the less helpful error message that VBA shows by default).\n\nFor example, suppose you have a dataset as shown below and you want all the cells to have numeric values only.\n\nThe above code would show an error message that has the specified description and the context file.\n\nPersonally, I have never used Err.Raise as I mostly work with Excel only. But for someone who uses VBA to work with Excel along with other applications such as Outlook, Word or PowerPoint, this can be useful.\n\nHere is a detailed article on Err.Raise method in case you want to learn more.\n\nNo matter how skilled you get a writing VBA code, errors are always going to be a part of it. The best coders are those who have the skills to handle these errors properly.\n\nHere are some best practices you can use when it comes to error handling in Excel VBA.\n• Use ‘On Error Go [Label]’ at the beginning of the code. This will make sure any error that can happen from there is handled.\n• Use ‘On Error Resume Next’ ONLY when you’re sure about the errors that can occur. Use it with expected error only. In case you use it with unexpected errors, it will simply ignore it and move forward. You can use ‘On Error Resume Next’ with ‘Err.Raise’ if you want to ignore a certain type of error and catch the rest.\n• When using error handlers, make sure you’re using Exit Sub before the handlers. This will ensure that the error handler code is executed only when there is an error (else it will always be executed).\n• Use multiple error handlers to trap different kinds of errors. Having multiple error handler ensures that an error is properly addressed. For example, you would want to handle a ‘type mismatch’ error differently than a ‘Division by 0’ run-time error.\n\nHope you found this Excel article useful!\n\nHere are some more Excel VBA Tutorials that you may like:\n• Excel VBA Loops – For Next, Do While, Do Until, For Each\n• Excel Visual Basic Editor – How to Open and Use it in Excel"
    },
    {
        "link": "https://stackoverflow.com/questions/44571250/optimizing-loop-performance-in-vba",
        "document": "Sheet calls in VBA are very slow (compared to arrays or such). Your IF statement alone makes 8 sheet calls every time you loop. This line: Rows(i).EntireRow.Delete - Makes 4 sheet calls every time you loop.\n\nA much faster solution would be to read all the data into an array - Do all processing filtering etc on the array then output the array back into the sheet.\n\nThere is a detailed answer on this with speed comparisons on SO - but I can not find it. If anyone can please add as comment"
    },
    {
        "link": "https://learn.microsoft.com/en-us/office/vba/excel/concepts/excel-performance/excel-tips-for-optimizing-performance-obstructions",
        "document": "Follow these tips for optimizing many frequently occurring performance obstructions in Excel.\n\nLearn how to improve performance related to types of references and links.\n\nDo not use forward referencing and backward referencing\n\nTo increase clarity and avoid errors, design your formulas so that they don't refer forward (to the right or below) to other formulas or cells. Forward referencing usually does not affect calculation performance, except in extreme cases for the first calculation of a workbook, where it might take longer to establish a sensible calculation sequence if there are many formulas that need to have their calculation deferred.\n\nMinimize use of circular references with iteration\n\nCalculating circular references with iterations is slow because multiple calculations are needed, and these calculations are single-threaded. Frequently you can \"unroll\" the circular references by using algebra so that iterative calculation is no longer needed. For example, in cash flow and interest calculations, try to calculate the cash flow before interest, calculate the interest, and then calculate the cash flow including the interest.\n\nExcel calculates circular references sheet-by-sheet without considering dependencies. Therefore, you usually get slow calculation if your circular references span more than one worksheet. Try to move the circular calculations onto a single worksheet or optimize the worksheet calculation sequence to avoid unnecessary calculations.\n\nBefore the iterative calculations start, Excel must recalculate the workbook to identify all the circular references and their dependents. This process is equal to two or three iterations of the calculation.\n\nAfter the circular references and their dependents are identified, each iteration requires Excel to calculate not only all the cells in the circular reference, but also any cells that depend on the cells in the circular reference chain, together with volatile cells and their dependents. If you have a complex calculation that depends on cells in the circular reference, it can be faster to isolate this into a separate closed workbook and open it for recalculation after the circular calculation has converged.\n\nIt's important to reduce the number of cells in the circular calculation and the calculation time that is taken by these cells.\n\nAvoid inter-workbook links when it is possible; they can be slow, easily broken, and not always easy to find and fix.\n\nUsing fewer larger workbooks is usually, but not always, better than using many smaller workbooks. Some exceptions to this might be when you have many front-end calculations that are so rarely recalculated that it makes sense to put them in a separate workbook, or when you have insufficient RAM.\n\nTry to use simple direct cell references that work on closed workbooks. By doing this, you can avoid recalculating all your linked workbooks when you recalculate any workbook. Also, you can see the values Excel has read from the closed workbook, which is frequently important for debugging and auditing the workbook.\n\nIf you cannot avoid using linked workbooks, try to have them all open instead of closed, and open the workbooks that are linked to before you open the workbooks that are linked from.\n\nUsing many worksheets can make your workbook easier to use, but generally it is slower to calculate references to other worksheets than references within worksheets.\n\nTo save memory and reduce file size, Excel tries to store information about only the area on a worksheet that was used. This is called the used range. Sometimes various editing and formatting operations extend the used range significantly beyond the range that you would currently consider used. This can cause performance obstructions and file-size obstructions.\n\nYou can check the visible used range on a worksheet by using Ctrl+End. Where this is excessive, you should consider deleting all the rows and columns below and to the right of your real last used cell, and then saving the workbook. Create a backup copy first. If you have formulas with ranges that extend into or refer to the deleted area, these ranges will be reduced in size or changed to #N/A.\n\nWhen you frequently add rows or columns of data to your worksheets, you need to find a way of having your Excel formulas automatically refer to the new data area, instead of trying to find and change your formulas every time.\n\nYou can do this by using a large range in your formulas that extends well beyond your current data boundaries. However, this can cause inefficient calculation under certain circumstances, and it is difficult to maintain because deleting rows and columns can decrease the range without you noticing.\n\nStarting in Excel 2007, you can use structured table references, which automatically expand and contract as the size of the referenced table increases or decreases.\n\nThis solution has several advantages:\n• None Fewer performance disadvantages exist than the alternatives of whole column referencing and dynamic ranges.\n• None It's easy to have multiple tables of data on a single worksheet.\n• None Formulas that are embedded in the table also expand and contract with the data.\n\nAlternatively, use whole column and row references\n\nAn alternative approach is to use a whole column reference, for example $A:$A. This reference returns all the rows in Column A. Therefore, you can add as much data as you want, and the reference will always include it.\n\nThis solution has both advantages and disadvantages:\n• None Many Excel built-in functions (SUM, SUMIF) calculate whole column references efficiently because they automatically recognize the last used row in the column. However, array calculation functions like SUMPRODUCT either cannot handle whole column references or calculate all the cells in the column.\n• None User-defined functions don't automatically recognize the last-used row in the column and, therefore, frequently calculate whole column references inefficiently. However, it is easy to program user-defined functions so that they recognize the last-used row.\n• None It's difficult to use whole column references when you have multiple tables of data on a single worksheet.\n• None In Excel 2007 and later versions, array formulas can handle whole-column references, but this forces calculation for all the cells in the column, including empty cells. This can be slow to calculate, especially for 1 million rows.\n\nBy using the OFFSET or INDEX and COUNTA functions in the definition of a named range, you can make the area that the named range refers to dynamically expand and contract. For example, create a defined name using one of the following formulas:\n\nWhen you use the dynamic range name in a formula, it automatically expands to include new entries.\n\nUsing the INDEX formula for a dynamic range is generally preferable to the OFFSET formula because OFFSET has the disadvantage of being a volatile function that will be calculated at every recalculation.\n\nPerformance decreases because the COUNTA function inside the dynamic range formula must examine many rows. You can minimize this performance decrease by storing the COUNTA part of the formula in a separate cell or defined name, and then referring to the cell or name in the dynamic range:\n\nYou can also use functions such as INDIRECT to construct dynamic ranges, but INDIRECT is volatile and always calculates single-threaded.\n\nDynamic ranges have the following advantages and disadvantages:\n• None Dynamic ranges work well to limit the number of calculations performed by array formulas.\n• None Using many dynamic ranges can decrease performance.\n\nIn Office 365 version 1809 and later, Excel's VLOOKUP, HLOOKUP, and MATCH for exact match on unsorted data is much faster than ever before when looking up multiple columns (or rows with HLOOKUP) from the same table range.\n\nThat said, for earlier Excel versions, Lookups continue to be frequently significant calculation obstructions. Fortunately, there are many ways of improving lookup calculation time. If you use the exact match option, the calculation time for the function is proportional to the number of cells scanned before a match is found. For lookups over large ranges, this time can be significant.\n\nLookup time using the approximate match options of VLOOKUP, HLOOKUP, and MATCH on sorted data is fast and is not significantly increased by the length of the range you are looking up. Characteristics are the same as binary search.\n\nEnsure that you understand the match-type and range-lookup options in MATCH, VLOOKUP, and HLOOKUP.\n\nThe following code example shows the syntax for the MATCH function. For more information, see the Match method of the WorksheetFunction object.\n• None Matchtype=1 returns the largest match less than or equal to the lookup value when the lookup array is sorted ascending (approximate match). If the lookup array is not sorted ascending, MATCH will return an incorrect answer. The default option is approximate match sorted ascending.\n• None Matchtype=0 requests an exact match and assumes that the data is not sorted.\n• None Matchtype=-1 returns the smallest match greater than or equal to the lookup value if the lookup array is sorted descending (approximate match).\n\nThe following code example shows the syntax for the VLOOKUP and HLOOKUP functions. For more information, see the VLOOKUP and HLOOKUP methods of the WorksheetFunction object.\n• None Range-lookup=TRUE returns the largest match less than or equal to the lookup value (approximate match). This is the default option. Table array must be sorted ascending.\n• None Range-lookup=FALSE requests an exact match and assumes the data is not sorted.\n\nAvoid performing lookups on unsorted data where possible because it is slow. If your data is sorted, but you want an exact match, see Use two lookups for sorted data with missing values.\n\nUse INDEX and MATCH or OFFSET instead of VLOOKUP\n\nTry using the INDEX and MATCH functions instead of VLOOKUP. Although VLOOKUP is slightly faster (approximately 5 percent faster), simpler, and uses less memory than a combination of MATCH and INDEX, or OFFSET, the additional flexibility that MATCH and INDEX offer often enables you to significantly save time. For example, you can store the result of an exact MATCH in a cell and reuse it in several INDEX statements.\n\nThe INDEX function is fast and is a non-volatile function, which speeds up recalculation. The OFFSET function is also fast; however, it is a volatile function, and it sometimes significantly increases the time taken to process the calculation chain.\n\nIt's easy to convert VLOOKUP to INDEX and MATCH. The following two statements return the same answer:\n\nBecause exact match lookups can be slow, consider the following options for improving performance:\n• None Use one worksheet. It's faster to keep lookups and data on the same sheet.\n• None When you can, SORT the data first (SORT is fast), and use approximate match.\n• None When you must use an exact match lookup, restrict the range of cells to be scanned to a minimum. Use tables and structured references or dynamic range names rather than referring to a large number of rows or columns. Sometimes you can pre-calculate a lower-range limit and upper-range limit for the lookup.\n\nUse two lookups for sorted data with missing values\n\nTwo approximate matches are significantly faster than one exact match for a lookup over more than a few rows. (The breakeven point is about 10-20 rows.)\n\nIf you can sort your data but still cannot use approximate match because you cannot be sure that the value you are looking up exists in the lookup range, you can use this formula:\n\nThe first part of the formula works by doing an approximate lookup on the lookup column itself.\n\nYou can check if the answer from the lookup column is the same as the lookup value (in which case you have an exact match) by using the following formula:\n\nIf this formula returns True, you have found an exact match, so you can do the approximate lookup again, but this time, return the answer from the column you want.\n\nIf the answer from the lookup column did not match the lookup value, you have a missing value, and the formula returns \"notexist\".\n\nBe aware that if you look up a value smaller than the smallest value in the list, you receive an error. You can handle this error by using IFERROR, or by adding a small test value to the list.\n\nUse IFERROR function for unsorted data with missing values\n\nIf you must use exact match lookup on unsorted data, and you cannot be sure whether the lookup value exists, you often must handle the #N/A that is returned if no match is found. Beginning with Excel 2007, you can use the IFERROR function, which is both simple and fast.\n\nIn earlier versions, a simple but slow way is to use an IF function that contains two lookups.\n\nYou can avoid the double exact lookup if you use exact MATCH once, store the result in a cell, and then test the result before doing an INDEX.\n\nIf you cannot use two cells, use COUNTIF. It's generally faster than an exact match lookup.\n\nUse MATCH and INDEX for exact match lookups on multiple columns\n\nYou can often reuse a stored exact MATCH many times. For example, if you are doing exact lookups on multiple result columns, you can save time by using one MATCH and many INDEX statements rather than many VLOOKUP statements.\n\nAdd an extra column for the MATCH to store the result ( ), and for each result column use the following:\n\nAlternatively, you can use VLOOKUP in an array formula. (Array formulas must be entered by using Ctrl+-Shift+Enter. Excel will add the { and } to show you that this is an array formula).\n\nUse INDEX for a set of contiguous rows or columns\n\nYou can also return many cells from one lookup operation. To look up several contiguous columns, you can use the INDEX function in an array formula to return multiple columns at once (use 0 as the column number). You can also use the INDEX function to return multiple rows at one time.\n\nThis returns column A to column J from the stored row created by a previous MATCH statement.\n\nUse MATCH to return a rectangular block of cells\n\nUse the MATCH and OFFSET functions to return a rectangular block of cells.\n\nUse MATCH and INDEX for two-dimensional lookup\n\nYou can efficiently do a two-dimensional table lookup by using separate lookups on the rows and columns of a table by using an INDEX function with two embedded MATCH functions, one for the row and one for the column.\n\nIn large worksheets, you may frequently need to look up by using multiple indexes, such as looking up product volumes in a country/region. To do this, you can concatenate the indexes and perform the lookup by using concatenated lookup values. However, this is inefficient for two reasons:\n\nIt's often more efficient to calculate a subset range for the lookup (for example, by finding the first and last row for the country/region, and then looking up the product within that subset range).\n\nTo look up the table to use in addition to the row and the column, you can use the following techniques, focusing on how to make Excel look up or choose the table.\n\nIf each table that you want to look up (the third dimension) is stored as a set of named structured tables, range names, or as a table of text strings that represent ranges, you might be able to use the CHOOSE or INDIRECT functions.\n• None Using CHOOSE and range names can be an efficient method. CHOOSE is not volatile, but it is best-suited to a relatively small number of tables. This example dynamically uses to choose which range name ( ) to use for the lookup table.\n• None The following example uses the INDIRECT function and to dynamically create the sheet name to use for the lookup table. This method has the advantage of being simple and able to handle a large number of tables. Because INDIRECT is a volatile single-threaded function, the lookup is single-thread calculated at every calculation even if no data has changed. Using this method is slow.\n• None You could also use the VLOOKUP function to find the name of the sheet or the text string to use for the table, and then use the INDIRECT function to convert the resulting text into a range.\n\nAnother technique is to aggregate all your tables into one giant table that has an additional column that identifies the individual tables. You can then use the techniques for multiple-index lookup shown in the previous examples.\n\nThe MATCH, VLOOKUP, and HLOOKUP functions allow you to use the wildcard characters ? (any single character) and * (no character or any number of characters) on alphabetical exact matches. Sometimes you can use this method to avoid multiple matches.\n\nArray formulas and the SUMPRODUCT function are powerful, but you must handle them carefully. A single array formula might require many calculations.\n\nThe key to optimizing the calculation speed of array formulas is to ensure that the number of cells and expressions that are evaluated in the array formula is as small as possible. Remember that an array formula is a bit like a volatile formula: if any one of the cells that it references has changed, is volatile, or has been recalculated, the array formula calculates all the cells in the formula and evaluates all the virtual cells it needs to do the calculation.\n\nTo optimize the calculation speed of array formulas:\n• None Take expressions and range references out of the array formulas into separate helper columns and rows. This makes much better use of the smart recalculation process in Excel.\n• None Do not reference complete rows, or more rows and columns than you need. Array formulas are forced to calculate all the cell references in the formula even if the cells are empty or unused. With 1 million rows available starting in Excel 2007, an array formula that references a whole column is extremely slow to calculate.\n• None Starting in Excel 2007, use structured references where you can to keep the number of cells that are evaluated by the array formula to a minimum.\n• None In versions earlier than Excel 2007, use dynamic range names where possible. Although they are volatile, it is worthwhile because they minimize the size of the ranges.\n• None Be careful with array formulas that reference both a row and a column: this forces the calculation of a rectangular range.\n• None Use SUMPRODUCT if possible; it is slightly faster than the equivalent array formula.\n\nConsider options for using SUM for multiple-condition array formulas\n\nYou should always use the SUMIFS, COUNTIFS, and AVERAGEIFS functions instead of array formulas where you can because they are much faster to calculate. Excel 2016 introduces fast MAXIFS and MINIFS functions.\n\nIn versions earlier than Excel 2007, array formulas are often used to calculate a sum with multiple conditions. This is relatively easy to do, especially if you use the Conditional Sum Wizard in Excel, but it is often slow. Usually there are much faster ways of getting the same result. If you have only a few multiple-condition SUMs, you may be able to use the DSUM function, which is much faster than the equivalent array formula.\n\nIf you must use array formulas, some good methods of speeding them up are as follows:\n• None Use dynamic range names or structured table references to minimize the number of cells.\n• None Split out the multiple conditions into a column of helper formulas that return True or False for each row, and then reference the helper column in a SUMIF or array formula. This might not appear to reduce the number of calculations for a single array formula; however, most of the time it enables the smart recalculation process to recalculate only the formulas in the helper column that need to be recalculated.\n• None Consider concatenating together all the conditions into a single condition, and then using SUMIF.\n• None If the data can be sorted, count groups of rows and limit the array formulas to looking at the subset groups.\n\nThese functions evaluate each of the conditions from left to right in turn. Therefore, it is more efficient to put the most restrictive condition first, so that subsequent conditions only need to look at the smallest number of rows.\n\nConsider options for using SUMPRODUCT for multiple-condition array formulas\n\nStarting in Excel 2007, you should always use the SUMIFS, COUNTIFS, and AVERAGEIFS functions, and in Excel 2016 MAXIFS and MINIFS functions, instead of SUMPRODUCT formulas where possible.\n\nIn earlier versions, there are a few advantages to using SUMPRODUCT instead of SUM array formulas:\n• None SUMPRODUCT does not have to be array-entered by using Ctrl+Shift+Enter.\n• None SUMPRODUCT is usually slightly faster (5 to 10 percent).\n\nUse SUMPRODUCT for multiple-condition array formulas as follows:\n\nIn this example, and are conditional expressions such as . Because conditional expressions return True or False instead of numbers, they must be coerced to numbers inside the SUMPRODUCT function. You can do this by using two minus signs (--), or by adding 0 (+0), or by multiplying by 1 (x1). Using -- is slightly faster than +0 or x1.\n\nNote that the size and shape of the ranges or arrays that are used in the conditional expressions and range to sum must be the same, and they cannot contain entire columns.\n\nYou can also directly multiply the terms inside SUMPRODUCT rather than separate them by commas:\n\nThis is usually slightly slower than using the comma syntax, and it gives an error if the range to sum contains a text value. However, it is slightly more flexible in that the range to sum may have, for example, multiple columns when the conditions have only one column.\n\nUse SUMPRODUCT to multiply and add ranges and arrays\n\nIn cases like weighted average calculations, where you need to multiply a range of numbers by another range of numbers and sum the results, using the comma syntax for SUMPRODUCT can be 20 to 25 percent faster than an array-entered SUM.\n\nThese three formulas all produce the same result, but the third formula, which uses the comma syntax for SUMPRODUCT, takes only about 77 percent of the calculation time that the other two formulas need.\n\nBe aware of potential array and function calculation obstructions\n\nThe calculation engine in Excel is optimized to exploit array formulas and functions that reference ranges. However, some unusual arrangements of these formulas and functions can sometimes, but not always, cause significantly increased calculation time.\n\nIf you find a calculation obstruction that involves array formulas and range functions, you should look for the following:\n• None Array formulas and range functions that reference part of a block of cells that are calculated in another array formula or range function. This situation can frequently occur in time series analysis.\n• None One set of formulas referencing by row, and a second set of formulas referencing the first set by column.\n• None A large set of single-row array formulas covering a block of columns, with SUM functions at the foot of each column.\n\nFunctions significantly extend the power of Excel, but the way in which you use them can often affect calculation time.\n\nMost native Excel functions work well with multi-threaded calculation. However, where possible, avoid using the following single-threaded functions:\n• VBA and Automation user-defined functions (UDFs), but XLL-based UDFs can be multi-threaded\n• CELL when either the \"format\" or \"address\" argument is used\n• ADDRESS where the fifth parameter (the ) is given\n• Any database function (DSUM, DAVERAGE, and so on) that refers to a PivotTable\n\nUse tables for functions that handle ranges\n\nFor functions like SUM, SUMIF, and SUMIFS that handle ranges, the calculation time is proportional to the number of used cells you are summing or counting. Unused cells are not examined, so whole column references are relatively efficient, but it is better to ensure that you don't include more used cells than you need. Use tables, or calculate subset ranges or dynamic ranges.\n\nVolatile functions can slow recalculation because they increase the number of formulas that must be recalculated at each calculation.\n\nYou can often reduce the number of volatile functions by using INDEX instead of OFFSET, and CHOOSE instead of INDIRECT. However, OFFSET is a fast function and can often be used in creative ways that give fast calculation.\n\nUse C or C++ user-defined functions\n\nUser-defined functions that are programmed in C or C++ and that use the C API (XLL add-in functions) generally perform faster than user-defined functions that are developed by using VBA or Automation (XLA or Automation add-ins). For more information, see Developing Excel 2010 XLLs.\n\nThe performance of VBA user-defined functions is sensitive to how you program and call them.\n\nIt's usually faster to use the Excel formula calculations and worksheet functions than to use VBA user-defined functions. This is because there is a small overhead for each user-defined function call and significant overhead transferring information from Excel to the user-defined function. But well-designed and called user-defined functions can be much faster than complex array formulas.\n\nEnsure that you have put all the references to worksheet cells in the user-defined function input parameters instead of in the body of the user-defined function, so that you can avoid adding Application.Volatile unnecessarily.\n\nIf you must have many formulas that use user-defined functions, ensure that you are in manual calculation mode, and that the calculation is initiated from VBA. VBA user-defined functions calculate much more slowly if the calculation is not called from VBA (for example, in automatic mode or when you press F9 in manual mode). This is particularly true when the Visual Basic Editor (Alt+F11) is open or has been opened in the current Excel session.\n\nYou can trap F9 and redirect it to a VBA calculation subroutine as follows. Add this subroutine to the Thisworkbook module.\n\nUser-defined functions in Automation add-ins (Excel 2002 and later versions) don't incur the Visual Basic Editor overhead because they don't use the integrated editor. Other performance characteristics of Visual Basic 6 user-defined functions in Automation add-ins are similar to VBA functions.\n\nIf your user-defined function processes each cell in a range, declare the input as a range, assign it to a variant that contains an array, and loop on that. If you want to handle whole column references efficiently, you must make a subset of the input range, dividing it at its intersection with the used range, as in this example.\n\nIf your user-defined function is using worksheet functions or Excel object model methods to process a range, it is generally more efficient to keep the range as an object variable than to transfer all the data from Excel to the user-defined function.\n\nIf your user-defined function is called early in the calculation chain, it can be passed as uncalculated arguments. Inside a user-defined function, you can detect uncalculated cells by using the following test for empty cells that contain a formula:\n\nA time overhead exists for each call to a user-defined function and for each transfer of data from Excel to VBA. Sometimes one multi-cell array formula user-defined function can help you minimize these overheads by combining multiple function calls into a single function with a multi-cell input range that returns a range of answers.\n\nMinimize range of cells that SUM and SUMIF reference\n\nThe Excel SUM and SUMIF functions are frequently used over a large number of cells. Calculation time for these functions is proportionate to the number of cells covered, so try to minimize the range of cells that the functions are referencing.\n\nUse wildcard SUMIF, COUNTIF, SUMIFS, COUNTIFS, and other IFS functions\n\nUse the wildcard characters ? (any single character) and * (no character or any number of characters) in the criteria for alphabetical ranges as part of the SUMIF, COUNTIF, SUMIFS, COUNTIFS, and other IFS functions.\n\nThere are two methods of doing period-to-date or cumulative SUMs. Suppose the numbers that you want to cumulatively SUM are in column A, and you want column B to contain the cumulative sum; you can do either of the following:\n• None You can create a formula in column B such as and drag it down as far as you need. The beginning cell of the SUM is anchored in A1, but because the finishing cell has a relative row reference, it automatically increases for each row.\n• None You can create a formula such as in cell B1 and in cell B2 and drag it down as far as you need. This calculates the cumulative cell by adding this row's number to the previous cumulative SUM.\n\nFor 1,000 rows, the first method makes Excel do about 500,000 calculations, but the second method makes Excel do only about 2,000 calculations.\n\nWhen you have multiple sorted indexes to a table (for example, Site within Area) you can often save significant calculation time by dynamically calculating the address of a subset range of rows (or columns) to use in the SUM or SUMIF function.\n\nTo calculate the address of a subset range of row or columns:\n• None Count the number of rows for each subset block.\n• None Add the counts cumulatively for each block to determine its start row.\n• None Use OFFSET with the start row and count to return a subset range to the SUM or SUMIF that covers only the subset block of rows.\n\nUse the SUBTOTAL function to SUM filtered lists. The SUBTOTAL function is useful because, unlike SUM, it ignores the following:\n• None Hidden rows that result from filtering a list. Starting in Excel 2003, you can also make SUBTOTAL ignore all hidden rows, not just filtered rows.\n\nThe AGGREGATE function is a powerful and efficient way of calculating 19 different methods of aggregating data (such as SUM, MEDIAN, PERCENTILE and LARGE). AGGREGATE has options for ignoring hidden or filtered rows, error values, and nested SUBTOTAL and AGGREGATE functions.\n\nThe DFunctions DSUM, DCOUNT, DAVERAGE, and so on are significantly faster than equivalent array formulas. The disadvantage of the DFunctions is that the criteria must be in a separate range, which makes them impractical to use and maintain in many circumstances. Starting in Excel 2007, you should use SUMIFS, COUNTIFS, and AVERAGEIFS functions instead of the DFunctions.\n\nUse the following tips to create faster VBA macros.\n\nTurn off everything but the essentials while code is running\n\nTo improve performance for VBA macros, explicitly turn off the functionality that is not required while your code executes. Often, one recalculation or one redraw after your code runs is all that is necessary and can improve performance. After your code executes, restore the functionality to its original state.\n\nThe following functionality can usually be turned off while your VBA macro executes:\n• None Application.ScreenUpdating Turn off screen updating. If Application.ScreenUpdating is set to False, Excel does not redraw the screen. While your code runs, the screen updates quickly, and it is usually not necessary for the user to see each update. Updating the screen once, after the code executes, improves performance.\n• None Application.DisplayStatusBar Turn off the status bar. If Application.DisplayStatusBar is set to False, Excel does not display the status bar. The status bar setting is separate from the screen updating setting so that you can still display the status of the current operation even while the screen is not updating. However, if you don't need to display the status of every operation, turning off the status bar while your code runs also improves performance.\n• None Application.Calculation Switch to manual calculation. If Application.Calculation is set to xlCalculationManual, Excel only calculates the workbook when the user explicitly initiates the calculation. In automatic calculation mode, Excel determines when to calculate. For example, every time a cell value that is related to a formula changes, Excel recalculates the formula. If you switch the calculation mode to manual, you can wait until all the cells associated with the formula are updated before recalculating the workbook. By only recalculating the workbook when necessary while your code runs, you can improve performance.\n• None Application.EnableEvents Turn off events. If Application.EnableEvents is set to False, Excel does not raise events. If there are add-ins listening for Excel events, those add-ins consume resources on the computer as they record the events. If it is not necessary for the add-in to record the events that occur while your code runs, turning off events improves performance.\n• None ActiveSheet.DisplayPageBreaks Turn off page breaks. If ActiveSheet.DisplayPageBreaks is set to False, Excel does not display page breaks. It's not necessary to recalculate page breaks while your code runs, and calculating the page breaks after the code executes improves performance.\n\nThe following example shows the functionality that you can turn off while your VBA macro executes.\n\nRead and write large blocks of data in a single operation\n\nOptimize your code by explicitly reducing the number of times data is transferred between Excel and your code. Instead of looping through cells one at a time to get or set a value, get or set the values in the entire range of cells in one line, using a variant containing a two-dimensional array to store values as needed. The following code examples compare these two methods.\n\nThe following code example shows non-optimized code that loops through cells one at a time to get and set the values of cells A1:C10000. These cells don't contain formulas.\n\nThe following code example shows optimized code that uses an array to get and set the values of cells A1:C10000 all at the same time. These cells don't contain formulas.\n\nUse .Value2 rather than .Value or .Text when reading data from an Excel range\n• .Text returns the formatted value of a cell. This is slow, can return ### if the user zooms, and can lose precision.\n• .Value returns a VBA currency or VBA date variable if the range was formatted as Date or Currency. This is slow, can lose precision, and can cause errors when calling worksheet functions.\n• .Value2 is fast and does not alter the data being retrieved from Excel.\n\nSelecting and activating objects is more processing intensive than referencing objects directly. By referencing an object such as a Range or a Shape directly, you can improve performance. The following code examples compare the two methods.\n\nThe following code example shows non-optimized code that selects each Shape on the active sheet and changes the text to \"Hello\".\n\nThe following code example shows optimized code that references each Shape directly and changes the text to \"Hello\".\n\nThe following is a list of additional performance optimizations you can use in your VBA code:\n• None Return results by assigning an array directly to a Range.\n• None Declare variables with explicit types to avoid the overhead of determining the data type, possibly multiple times in a loop, during code execution.\n• None For simple functions that you use frequently in your code, implement the functions yourself in VBA instead of using the WorksheetFunction object. For more information, see Use faster VBA user-defined functions.\n• None Use the Range.SpecialCells method to scope down the number of cells with which your code interacts.\n• None Consider the performance gains if you implemented your functionality by using the C API in the XLL SDK. For more information, see the Excel 2010 XLL SDK Documentation.\n\nConsider performance and size of Excel file formats\n\nStarting in Excel 2007, Excel contains a wide variety of file formats compared to earlier versions. Ignoring the Macro, Template, Add-in, PDF, and XPS file format variations, the three main formats are XLS, XLSB, and XLSX.\n• The XLS format is the same format as earlier versions. When you use this format, you are restricted to 256 columns and 65,536 rows. When you save an Excel 2007 or Excel 2010 workbook in XLS format, Excel runs a compatibility check. File size is almost the same as earlier versions (some additional information may be stored), and performance is slightly slower than earlier versions. Any multi-threaded optimization Excel does with respect to cell calculation order is not saved in the XLS format. Therefore, calculation of a workbook can be slower after saving the workbook in the XLS format, closing, and re-opening the workbook.\n• XLSB is the binary format starting in Excel 2007. It's structured as a compressed folder that contains many binary files. It's much more compact than the XLS format, but the amount of compression depends on the contents of the workbook. For example, ten workbooks show a size reduction factor ranging from two to eight with an average reduction factor of four. Starting in Excel 2007, opening and saving performance is only slightly slower than the XLS format.\n• XLSX is the XML format starting in Excel 2007, and is the default format starting in Excel 2007. The XLSX format is a compressed folder that contains many XML files (if you change the file name extension to .zip, you can open the compressed folder and examine its contents). Typically, the XLSX format creates larger files than the XLSB format (1.5 times larger on average), but they are still significantly smaller than the XLS files. You should expect opening and saving times to be slightly longer than for XLSB files.\n\nYou may find that opening, closing, and saving workbooks is much slower than calculating them. Sometimes this is just because you have a large workbook, but there can also be other reasons.\n\nIf one or more of your workbooks open and close more slowly than is reasonable, it might be caused by one of the following issues.\n• Temporary files can accumulate in your \\Windows\\Temp directory (in Windows 95, Windows 98, and Windows ME), or your \\Documents and Settings\\User Name\\Local Settings\\Temp directory (in Windows 2000 and Windows XP). Excel creates these files for the workbook and for controls that are used by open workbooks. Software installation programs also create temporary files. If Excel stops responding for any reason, you might need to delete these files. Too many temporary files can cause problems, so you should occasionally clean them out. However, if you have installed software that requires that you restart your computer, and you have not yet done so, you should restart before deleting the temporary files.\n\nAn easy way to open your temp directory is from the Windows Start menu: Click Start, and then click Run. In the text box, type %temp%, and then click OK.\n• Tracking changes in a shared workbook causes your workbook file-size to increase rapidly.\n• Be sure that your Windows swap file is located on a disk that has a lot of space and that you defragment the disk periodically.\n• A workbook that has its structure protected with a password (Tools menu > Protection > Protect Workbook > enter the optional password) opens and closes much slower than one that is protected without the optional password.\n• Oversized used ranges can cause slow opening and increased file size, especially if they are caused by hidden rows or columns that have non-standard height or width. For more information about used range problems, see Minimize the used range.\n• A large number of controls (check boxes, hyperlinks, and so on) on worksheets can slow down opening a workbook because of the number of temporary files that are used. This might also cause problems opening or saving a workbook on a WAN (or even a LAN). If you have this problem, you should consider redesigning your workbook.\n• None Large number of links to other workbooks If possible, open the workbooks that you are linking to before you open the workbook that contains the links. Often it is faster to open a workbook than to read the links from a closed workbook.\n• Some virus scanner settings can cause problems or slowness with opening, closing, or saving, especially on a server. If you think that this might be the problem, try temporarily switching the virus scanner off.\n• Under some circumstances, Excel recalculates your workbook when it opens or saves it. If the calculation time for your workbook is long and is causing a problem, ensure that you have calculation set to manual, and consider turning off the calculate before save option (Tools > Options > Calculation).\n• Check the size of your toolbar file. A typical toolbar file is between 10 KB and 20 KB. You can find your XLB files by searching for by using Windows search. Each user has a unique XLB file. Adding, changing, or customizing toolbars increases the size of your toolbar.xlb file. Deleting the file removes all your toolbar customizations (renaming it \"toolbar.OLD\" is safer). A new XLB file is created the next time you open Excel.\n\nYou can make performance improvements in the following areas.\n• PivotTables provide an efficient way to summarize large amounts of data.\n• None Totals as final results. If you need to produce totals and subtotals as part of the final results of your workbook, try using PivotTables.\n• None Totals as intermediate results. PivotTables are a great way to produce summary reports, but try to avoid creating formulas that use PivotTable results as intermediate totals and subtotals in your calculation chain unless you can ensure the following conditions:\n• None The PivotTable has been refreshed correctly during the calculation.\n• None The PivotTable has not been changed so that the information is still visible. If you still want to use PivotTables as intermediate results, use the GETPIVOTDATA function.\n• Conditional formats and data validation are great, but using a lot of them can significantly slow down calculation. If the cell is displayed, every conditional format formula is evaluated at each calculation and when the display of the cell that contains the conditional format is refreshed. The Excel object model has a Worksheet.EnableFormatConditionsCalculation property so that you can enable or disable the calculation of conditional formats.\n• Defined names are one of the most powerful features in Excel, but they do take additional calculation time. Using names that refer to other worksheets adds an additional level of complexity to the calculation process. Also, you should try to avoid nested names (names that refer to other names). Because names are calculated every time a formula that refers to them is calculated, you should avoid putting calculation-intensive formulas or functions in defined names. In these cases, it can be significantly faster to put your calculation-intensive formula or function in a spare cell somewhere and refer to that cell instead, either directly or by using a name.\n• None Formulas that are used only occasionally Many workbooks contain a significant number of formulas and lookups that are concerned with getting the input data into the appropriate shape for the calculations, or are being used as defensive measures against changes in the size or shape of the data. When you have blocks of formulas that are used only occasionally, you can copy and paste special values to temporarily eliminate the formulas, or you can put them in a separate, rarely opened workbook. Because worksheet errors are often caused by not noticing that formulas have been converted to values, the separate workbook method may be preferable.\n• The 32-bit version of Excel can use up to 2 GB of RAM or up to 4 GB of RAM for Large Address Aware 32-bit versions of Excel 2013 and 2016. However, the computer that is running Excel also requires memory resources. Therefore, if you only have 2 GB of RAM on your computer, Excel cannot take advantage of the full 2 GB because a portion of the memory is allocated to the operating system and other programs that are running. To optimize the performance of Excel on a 32-bit computer, we recommend that the computer have at least 3 GB of RAM. The 64-bit version of Excel does not have a 2 GB or up to 4 GB limit. For more information, see the \"Large data sets and the 64-bit version of Excel\" section in Excel performance: Performance and limit improvements.\n\nThis article covered ways to optimize Excel functionality such as links, lookups, formulas, functions, and VBA code to avoid common obstructions and improve performance.\n\nHave questions or feedback about Office VBA or this documentation? Please see Office VBA support and feedback for guidance about the ways you can receive support and provide feedback."
    },
    {
        "link": "https://medium.com/@info.excelassignmenthelp/optimizing-performance-in-excel-vba-macros-489f27c64816",
        "document": "Are you struggling with slow-running Excel VBA macros? Do you find yourself waiting impatiently as your code takes ages to execute? Don’t worry, because in this article, we will explore effective strategies to optimize the performance of your Excel VBA macros. By implementing these techniques, you can significantly speed up your macros and enhance your overall productivity. So let’s dive in and uncover the secrets to efficient VBA macro execution.\n\n1. Introduction: Understanding the Need for Performance Optimization\n\nWhen working with Excel VBA macros, performance optimization is crucial to ensure smooth and efficient execution. Slow-running macros can significantly impact your productivity and waste valuable time. By optimizing your macros, you can enhance their speed, responsiveness, and overall efficiency.\n\nTo optimize the performance of your VBA macros, it’s important to identify the bottlenecks in your code. Profiling tools like the VBA Profiler can help you pinpoint the areas of your code that consume the most time and resources. By identifying these bottlenecks, you can focus on optimizing the critical sections of your macros.\n\nProper variable declaration and the use of appropriate data types can significantly improve the performance of your macros. Use specific data types like Long, Double, or Variant instead of the generic Variant type wherever possible. Avoid using unnecessary variables and declare variables close to their usage to minimize memory usage.\n\n4. Minimizing the Use of Loops\n\nLoops can be a major source of slowdown in VBA macros. To optimize performance, minimize the use of loops and consider alternative approaches like using array operations or built-in Excel functions. Use the appropriate loop constructs such as For Each…Next and For…Next loops based on the specific requirements of your macro.\n\nUsing Select and Activate statements should be avoided whenever possible, as they slow down macro execution. Instead of selecting or activating objects, directly work with them using object references. This not only improves performance but also makes your code more readable and maintainable.\n\nTurning off screen updating and automatic calculation can significantly speed up macro execution. By disabling screen updating, you eliminate the overhead of refreshing the screen for each action performed by your macro. Similarly, turning off automatic calculation prevents Excel from recalculating formulas after each modification, resulting in faster macro execution.\n\nImplementing efficient error handling techniques can enhance the performance of your macros. Properly handle expected errors using structured error handling blocks (On Error…Resume Next or On Error GoTo) and avoid using unstructured error handling approaches like On Error Resume Next without proper error checking.\n\nUsing arrays instead of individual cell operations can significantly improve macro performance. Reading data into an array, manipulating it, and then writing it back to the worksheet in a single operation is much faster than reading and writing cell by cell. Utilize array functions like Transpose, Resize, and Index to efficiently work with data in your macros.\n\nExcel provides a wide range of built-in functions that can simplify and speed up your macros. Instead of reinventing the wheel, leverage these functions to perform calculations, manipulate data, or interact with worksheets. Built-in functions are usually optimized for performance and can often outperform custom VBA code.\n\nExcessive read and write operations to the worksheet can significantly impact macro performance. Minimize the number of interactions with the worksheet by storing intermediate results in variables or arrays. Reduce unnecessary read and write operations by optimizing your code logic and performing batch operations where possible.\n\nEfficient memory management is critical for optimizing macro performance. Release object references using the Set statement when they are no longer needed to free up memory. Avoid using unnecessary global variables and release resources explicitly to prevent memory leaks.\n\nFollowing VBA best practices can improve the performance and maintainability of your macros. Use descriptive variable names, add comments to explain complex sections of code, and organize your macros into logical modules. Employing proper coding conventions and adopting a modular approach can make your macros more efficient and easier to debug.\n\nIf you have large macros with multiple functionalities, consider splitting them into smaller subroutines. Breaking down complex macros into smaller, focused tasks not only improves readability and maintainability but also allows you to optimize individual subroutines for better performance.\n\nAdvanced techniques like using the Windows API, optimizing event-driven macros, or utilizing multithreading can further enhance the performance of your VBA macros. However, these techniques require a deeper understanding of VBA and should be used judiciously after thorough testing and consideration of their potential impact.\n\nIn conclusion, optimizing the performance of Excel VBA macros is crucial for enhancing productivity and efficiency. By following the strategies outlined in this article, such as profiling your code, efficient variable declaration, minimizing loops, and leveraging built-in functions, you can significantly improve the speed and responsiveness of your macros. Remember to always implement best practices and continuously test and refine your macros for optimal performance.\n\nQ: How can I measure the performance of my VBA macros?\n\nA: You can use profiling tools like the VBA Profiler to measure the execution time of your macros and identify bottlenecks.\n\nQ: Can I improve the performance of my macros without rewriting them completely?\n\nA: Yes, by implementing optimization techniques like efficient variable declaration, minimizing loops, and avoiding excessive I/O operations, you can improve performance without rewriting the entire macro."
    },
    {
        "link": "https://stackoverflow.com/questions/38480570/optimizing-performance-of-double-loop-in-vba-excel",
        "document": "I'm interested in knowing the fastest way to execute a set of instructions in double loop to loop through a two-dimensional range of cells. My code will be like this:\n\nFor example, suppose I write a simple code to implement such a following task:\n\nI ran the procedure Test1 on my machine, it took 179.6406 seconds to complete. Since I don't declare the variables (i and j), the Test1 is running with those variables defaulting to the Variant type. I then add one line to the Test1 to declare the variables as Longs, since VBA is optimized for Longs. The new procedure, Test2, brought the running time on my machine down to 168.7539 seconds (almost 11 seconds faster).\n\nTo improve performance of Test2, I turned off Excel functionality that isn't needed while Test2 code runs.\n\nThe above method helps improve the performance of Test2 and Test3 completes in 96.13672 seconds on my machine. So I'm wondering if there is a more effective way for doing this. Can anyone come up with a quicker version? If possible, even avoiding the double loop procedure."
    },
    {
        "link": "https://quora.com/What-steps-can-I-take-to-speed-up-for-loops-in-Excel-VBA",
        "document": "Something went wrong. Wait a moment and try again."
    }
]