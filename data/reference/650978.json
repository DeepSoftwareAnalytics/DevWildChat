[
    {
        "link": "https://learn.microsoft.com/en-us/cpp/mfc/reference/creating-a-file-explorer-style-mfc-application?view=msvc-170",
        "document": "Many Windows system applications use the user interface (UI) for File Explorer. When you start File Explorer, for example, you see an application with a vertical splitter bar dividing the client area. The left side of the client area provides navigation and browsing features, and the right side of the client area shows details pertinent to the selection in the left pane. When a user clicks an item in the left pane, the application repopulates the right pane. In an MDI application, you can use commands on the View menu to change the amount of detail shown in the right pane. (In an SDI or multiple top-level document application, you can change the detail using the toolbar buttons only.)\n\nThe contents of the panes depend on the application. In a file-system browser, the left pane shows a hierarchical view of directories or machines, or machine groups, while the right pane displays folders, individual files, or machines, and details about them. The contents don't necessarily have to be files. They could be e-mail messages, error reports, or other items in a database.\n\nThe wizard creates the following classes for you:\n• None The class defines the left pane of the client area. It's always derived from .\n• None The CProjNameView class defines the right pane of the client area. By default, it's derived from but can be another type of view depending on the class you specify from the Base class list in the Generated Classes page of the wizard.\n\nThe generated application can have a single document interface (SDI), a multiple document interface (MDI), or a multiple top-level documents architecture. Each frame window the application creates is vertically split using . Coding this application type is similar to coding a normal MFC application that uses a splitter, except that this type of application has separate control views within each splitter pane.\n\nIf you use the default list view in the right pane, the wizard creates additional menu choices (in MDI applications only) and toolbar buttons to switch the view's style among large icons, small icons, list, and detail modes.\n• None Follow the directions in Creating an MFC Application.\n• None In the MFC Application Wizard Application Type page, select the File Explorer project style. (It may show as Windows Explorer in your version of Visual Studio. In the past, the file manager was renamed Windows Explorer. Starting in Windows 10, it was renamed back to File Explorer. If your version of Visual Studio has Windows Explorer in the dropdown, this is the option you want for a File Explorer project).\n• None Set any other options you want on the other pages of the wizard.\n\nFor more information, see:"
    },
    {
        "link": "https://stackoverflow.com/questions/2360734/whats-a-good-directory-structure-for-larger-c-projects-using-makefile",
        "document": "Separating the .cpp of the .h file is not always a good solution. Generally I separate both of them when it is used as a library (public header in include and private header with the source code).\n\nIf it is a library, this structure is ok.\n\nIf it is a application\n\nUse the flag -I$(PROJECT_BASE)/include to specify the include path for the compilation\n\nIf it is a big project, it can be good to use tool like autoconf/automake or cmake to build everything. It will ease the development."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/v9wgqu/project_structure_and_best_bractices_for_complex",
        "document": "I'm currently working on a high performance (mainly C++) Desktop/Server Software of about 2 million lines of code (Windows and Linux) that has grown for the past 10 years.\n\nThe project has evolved organically until now, but unfortunately the team leaders lacked the processes and drive to maintain best practices properly over the years, and although it is an industry product that brings big revenue to our company, it has truly become a mess.\n\nFor obvious reasons I cannot give too many details about it, but as part of my current tasks and the team plans for the future I recently took the responsibility of owning the Codebase and starting an initiative to modernize the whole product.\n\nThe main pilars of our build are the following:\n\nHandles the core functionality (desktop/server-side), the different tools (executables) with user interfaces (Qt/QML), daemons, services, device drivers (executables), libraries, data processing, etc. all in C++. It contains also a storable library which is C++ code generated with Java to access DB tables as classes.\n\nHandles all the REST API functionality (Java) and the Front End (JavaScript) for our Web Application (an ongoing project to mirror a simplified version of the desktop application).\n\nDatabase schema (Oracle SQL) and all the logic that comes with it (client / server databases, etc.). Handles all the replication, scripts for setting and updating the database and more complicated database logic not managed by oracle itself (Java).\n\nCreates the build tools (reporting, monitoring, versioning, configuration files) that are partially used by both C++ and Java side. Creates the install folders, license files, deployment/installers, etc.\n\nOnly done for core libraries and some core functionalities, but definitely vastly incomplete, and a big improvement point for the future.\n\nThe whole project is \"managed\" with Makefiles (calling g++/gcc/ant/maven/etc.) All these sections are layered in very intricate and hacky ways, with a lot of cross references from libraries to libraries, and configuration files created here and there and used in other places in the project hierarchy.\n\nDue to this spaghetti structure, the project builds, but it is hard to add new features, refactor major parts or understand anything which creates very buggy developments by team members that don’t have the overview.\n\nAs a starting point, before changing any project structure. I'm migrating all the C++ part to CMake. It has been about 3 weeks work, but I'm about 3/4 of the way. I have realized that, the way the project is now layered it is a pain to do a 1-to-1 mapping to CMake, because CMake takes over many things and many Makefiles are very customized. I want to set-up a new project structure and start migrating and detangling every sub-module/functionality top-down from the old project to the new project.\n\nI’m obviously not expecting for anyone to give me deep advice on the specific intricacies of this project. But before I can continue, I need to have a vision of how I want the project to be structured and layered ideally in the future, in terms of the Project Structure (best practices).\n\nWhat comes to my mind is that ideally we would manage this product similar to a micro-services products. How are dependencies among the different services managed and administred?\n\nThere are some things that I’m not sure how to approach or how they’re done in big complicated projects:\n• Should I completely separete the build configuration logics for both Java/C++ into one folder taking as an input all main configuration (say from Jenkins and the Database Schema) and generates all the relevant files for the build of the Java/C++/Web out of it?\n• Should the configuration files be all centralized in one folder that the sources reach to when needed?\n• Should the build system start with a Main Makefile which then calls Maven for the Java Part (managed by another team) and the Build Makefiles/Ninja files generated by Cmake for C++? (Considering Cmake cannot be used to manage the whole project since it cannot manage or replace Maven for the Java side)\n• Where should code generator executables and generated code be placed? In the build folder or in the source folder? Should they all be compiled during the pre-build stage?\n• For the C++ part: Is the following a good project structure?\n• For Cmake, should package all libraries (core/kernel/gui) with ProjectConfig.cmake and import them when needed to each of the subprojects like Drivers and Apps? This way I can also use namespaced libraries e.g. Core::coreSubLibraryA\n\nThere's very little information online around a case like this, so I would be grateful for any advice and past experience around this. I haven't really wrapped my head fully around everything so further advice or resources to best approach a case like this would also be great."
    },
    {
        "link": "https://stackoverflow.com/questions/1398445/directory-structure-for-a-c-library",
        "document": "I am working on a C++ library. Ultimately, I would like to make it publicly available for multiple platforms (Linux and Windows at least), along with some examples and Python bindings. Work is progressing nicely, but at the moment the project is quite messy, built solely in and for Visual C++ and not multi-platform at all.\n\nTherefore, I feel a cleanup is in order. The first thing I'd like to improve is the project's directory structure. I'd like to create a structure that is suitable for the Automake tools to allow easy compilation on multiple platforms, but I've never used these before. Since I'll still be doing (most of the) coding in Visual Studio, I'll need somewhere to keep my Visual Studio project and solution files as well.\n\nI tried to google for terms like \"C++ library directory structure\", but nothing useful seems to come up. I found some very basic guidelines, but no crystal clear solutions.\n\nWhile looking at some open source libraries, I came up with the following:\n\nI have no/little previous experience with multi-platform development/open source projects and am quite amazed that I cannot find any good guidelines on how to structure such a project.\n\nHow should one generally structure such a library project? What ca be recommended to read? Are there some good examples?"
    },
    {
        "link": "https://reddit.com/r/cpp/comments/1fubvh2/best_practices_for_managing_large_c_projects",
        "document": "I’ve got a project that’s ballooned to over 600 files, and things are getting tricky to manage. I typically separate data structure definitions and functions into .hpp files, but I’m starting to feel like there might be a better way to organize everything.\n\nFor those of you managing larger C++ projects, how do you structure your code to keep it modular and maintainable? Some precise questions I have:\n• How do you manage header files vs. implementation? Do you separate them differently when the project grows this big?\n• Any go-to tools or build systems for keeping dependencies under control?\n• What’s worked best for maintaining quality and avoiding chaos as the codebase grows?\n\nThank you all for your insights!"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/mfc/reference/cfilefind-class?view=msvc-170",
        "document": "Performs local file searches and is the base class for and , which perform Internet file searches.\n\nincludes member functions that begin a search, locate a file, and return the title, name, or path of the file. For Internet searches, the member function returns the file's URL.\n\nis the base class for two other MFC classes designed to search particular server types: works specifically with gopher servers, and works specifically with FTP servers. Together, these three classes provide a seamless mechanism for the client to find files, regardless of the server protocol, the file type, or location, on either a local machine or a remote server.\n\nThe following code will enumerate all the files in the current directory, printing the name of each file:\n\nTo keep the example simple, this code uses the C++ Standard Library class. The line could be replaced with a call to , for example, in a program with a graphical user interface.\n\nFor more information about how to use and the other WinInet classes, see the article Internet Programming with WinInet.\n\nThis member function is called when a object is constructed.\n\nSee the example for .\n\nCall this member function to end the search, reset the context, and release all resources.\n\nAfter calling , you do not have to create a new instance before calling to begin a new search.\n\nSee the example for .\n\nCloses the file specified by the current search handle.\n\nCloses the file specified by the current value of the search handle. Override this function to change the default behavior.\n\nYou must call the or functions at least once to retrieve a valid search handle. The and functions use the search handle to locate files with names that match a given name.\n\n\n\n A pointer to a string containing the name of the file to find. If you pass for , does a wildcard (*.*) search.\n\n\n\n Reserved to make polymorphic with derived classes. Must be 0.\n\nNonzero if successful; otherwise 0. To get extended error information, call the Win32 function .\n\nAfter calling to begin the file search, call to retrieve subsequent files. You must call at least once before calling any of the following attribute member functions:\n\nSee the example for .\n\nCall this member function to continue a file search from a previous call to .\n\nNonzero if there are more files; zero if the file found is the last one in the directory or if an error occurred. To get extended error information, call the Win32 function . If the file found is the last file in the directory, or if no matching files can be found, the function returns .\n\nYou must call at least once before calling any of the following attribute member functions:\n\nSee the example for .\n\nCall this member function to get the time the specified file was created.\n\n\n\n A pointer to a structure containing the time the file was created.\n\nNonzero if successful; 0 if unsuccessful. returns 0 only if has never been called on this object.\n\nYou must call at least once before calling .\n\nSee the example for .\n\nCall this member function to get the name of the found file.\n\nThe name of the most-recently-found file.\n\nYou must call at least once before calling GetFileName.\n\nis one of three member functions that return some form of the file name. The following list describes the three and how they vary:\n• None returns the file name, including the extension. For example, calling to generate a user message about the file returns the file name .\n• None returns the entire path for the file. For example, calling to generate a user message about the file returns the file path .\n• None returns the file name, excluding the file extension. For example, calling to generate a user message about the file returns the file title .\n\nCall this member function to get the full path of the specified file.\n\nThe path of the specified file.\n\nYou must call at least once before calling .\n\nis one of three member functions that return some form of the file name. The following list describes the three and how they vary:\n• None returns the file name, including the extension. For example, calling to generate a user message about the file returns the file name .\n• None returns the entire path for the file. For example, calling to generate a user message about the file returns the file path .\n• None GetFileTitle returns the file name, excluding the file extension. For example, calling to generate a user message about the file returns the file title .\n\nSee the example for .\n\nCall this member function to get the title of the found file.\n\nThe title of the file.\n\nYou must call at least once before calling .\n\nis one of three member functions that return some form of the file name. The following list describes the three and how they vary:\n• None returns the file name, including the extension. For example, calling to generate a user message about the file returns the file name .\n• None returns the entire path for the file. For example, calling to generate a user message about the file returns the file path c:\\myhtml\\myfile.txt.\n• None returns the file name, excluding the file extension. For example, calling to generate a user message about the file returns the file title .\n\nSee the example for .\n\nCall this member function to retrieve the specified URL.\n\nYou must call at least once before calling .\n\nis similar to the member function , except that it returns the URL in the form . For example, calling to get the complete URL for returns the URL .\n\nSee the example for .\n\nCall this member function to get the time that the specified file was last accessed.\n\n\n\n A pointer to a structure containing the time the file was last accessed.\n\nNonzero if successful; 0 if unsuccessful. returns 0 only if has never been called on this object.\n\nYou must call at least once before calling .\n\nSee the example for .\n\nCall this member function to get the last time the file was changed.\n\n\n\n A pointer to a structure containing the time the file was last written to.\n\nNonzero if successful; 0 if unsuccessful. returns 0 only if has never been called on this object.\n\nYou must call at least once before calling .\n\nSee the example for .\n\nCall this member function to get the length of the found file, in bytes.\n\nThe length of the found file, in bytes.\n\nYou must call at least once before calling .\n\nuses the Win32 structure to get and return the value of the file size, in bytes.\n\nCall this member function to get the root of the found file.\n\nThe root of the active search.\n\nYou must call at least once before calling .\n\nThis member function returns the drive specifier and path name used to start a search. For example, calling with results in returning an empty string. Passing a path, such as , to results returning .\n\nSee the example for .\n\nCall this member function to determine if the found file is archived.\n\nApplications mark an archive file, which is to be backed up or removed, with , a file attribute identified in the structure.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nSee the example for .\n\nCall this member function to determine if the found file is compressed.\n\nA compressed file is marked with , a file attribute identified in the structure. For a file, this attribute indicates that all of the data in the file is compressed. For a directory, this attribute indicates that compression is the default for newly created files and subdirectories.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nSee the example for .\n\nCall this member function to determine if the found file is a directory.\n\nA file that is a directory is marked with a file attribute identified in the structure.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nThis small program recurses every directory on the C:\\ drive and prints the name of the directory.\n\nCall this member function to test for the current directory and parent directory markers while iterating through files.\n\nNonzero if the found file has the name \".\" or \"..\", which indicates that the found file is actually a directory. Otherwise 0.\n\nYou must call at least once before calling .\n\nSee the example for .\n\nCall this member function to determine if the found file is hidden.\n\nHidden files, which are marked with , a file attribute identified in the structure. A hidden file is not included in an ordinary directory listing.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nSee the example for .\n\nCall this member function to determine if the found file is a normal file.\n\nFiles marked with , a file attribute identified in the structure. A normal file has no other attributes set. All other file attributes override this attribute.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nSee the example for .\n\nCall this member function to determine if the found file is read-only.\n\nA read-only file is marked with , a file attribute identified in the structure. Applications can read such a file, but they cannot write to it or delete it.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nSee the example for .\n\nCall this member function to determine if the found file is a system file.\n\nA system file is marked with , a file attribute identified in the structure. A system file is part of, or is used exclusively by, the operating system.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nSee the example for .\n\nCall this member function to determine if the found file is a temporary file.\n\nA temporary file is marked with , a file attribute identified in the structure. A temporary file is used for temporary storage. Applications should write to the file only if absolutely necessary. Most of the file's data remains in memory without being flushed to the media because the file will soon be deleted.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nSee the example for .\n\nCall this member function to test the file attributes on the found file.\n\n\n\n Specifies one or more file attributes, identified in the structure, for the found file. To search for multiple attributes, use the bitwise OR ( ) operator. Any combination of the following attributes is acceptable:\n• None The file is an archive file. Applications use this attribute to mark files for backup or removal.\n• None The file or directory is compressed. For a file, this means that all of the data in the file is compressed. For a directory, this means that compression is the default for newly created files and subdirectories.\n• None The file has no other attributes set. This attribute is valid only if used alone. All other file attributes override this attribute.\n• None The file is hidden. It is not to be included in an ordinary directory listing.\n• None The file is read only. Applications can read the file but cannot write to it or delete it.\n• None The file is part of or is used exclusively by the operating system.\n• None The file is being used for temporary storage. Applications should write to the file only if absolutely necessary. Most of the file's data remains in memory without being flushed to the media because the file will soon be deleted.\n\nNonzero if successful; otherwise 0. To get extended error information, call the Win32 function .\n\nYou must call at least once before calling ."
    },
    {
        "link": "https://github.com/MicrosoftDocs/cpp-docs/blob/main/docs/mfc/reference/cfilefind-class.md",
        "document": "Performs local file searches and is the base class for and , which perform Internet file searches.\n\nincludes member functions that begin a search, locate a file, and return the title, name, or path of the file. For Internet searches, the member function returns the file's URL.\n\nis the base class for two other MFC classes designed to search particular server types: works specifically with gopher servers, and works specifically with FTP servers. Together, these three classes provide a seamless mechanism for the client to find files, regardless of the server protocol, the file type, or location, on either a local machine or a remote server.\n\nThe following code will enumerate all the files in the current directory, printing the name of each file:\n\nTo keep the example simple, this code uses the C++ Standard Library class. The line could be replaced with a call to , for example, in a program with a graphical user interface.\n\nFor more information about how to use and the other WinInet classes, see the article Internet Programming with WinInet.\n\nThis member function is called when a object is constructed.\n\nSee the example for .\n\nCall this member function to end the search, reset the context, and release all resources.\n\nAfter calling , you do not have to create a new instance before calling to begin a new search.\n\nSee the example for .\n\nCloses the file specified by the current search handle.\n\nCloses the file specified by the current value of the search handle. Override this function to change the default behavior.\n\nYou must call the or functions at least once to retrieve a valid search handle. The and functions use the search handle to locate files with names that match a given name.\n\n\n\n A pointer to a string containing the name of the file to find. If you pass for , does a wildcard (*.*) search.\n\n\n\n Reserved to make polymorphic with derived classes. Must be 0.\n\nNonzero if successful; otherwise 0. To get extended error information, call the Win32 function .\n\nAfter calling to begin the file search, call to retrieve subsequent files. You must call at least once before calling any of the following attribute member functions:\n\nSee the example for .\n\nCall this member function to continue a file search from a previous call to .\n\nNonzero if there are more files; zero if the file found is the last one in the directory or if an error occurred. To get extended error information, call the Win32 function . If the file found is the last file in the directory, or if no matching files can be found, the function returns .\n\nYou must call at least once before calling any of the following attribute member functions:\n\nSee the example for .\n\nCall this member function to get the time the specified file was created.\n\n\n\n A pointer to a structure containing the time the file was created.\n\nNonzero if successful; 0 if unsuccessful. returns 0 only if has never been called on this object.\n\nYou must call at least once before calling .\n\nSee the example for .\n\nCall this member function to get the name of the found file.\n\nThe name of the most-recently-found file.\n\nYou must call at least once before calling GetFileName.\n\nis one of three member functions that return some form of the file name. The following list describes the three and how they vary:\n• returns the file name, including the extension. For example, calling to generate a user message about the file returns the file name .\n• returns the entire path for the file. For example, calling to generate a user message about the file returns the file path .\n• returns the file name, excluding the file extension. For example, calling to generate a user message about the file returns the file title .\n\nCall this member function to get the full path of the specified file.\n\nThe path of the specified file.\n\nYou must call at least once before calling .\n\nis one of three member functions that return some form of the file name. The following list describes the three and how they vary:\n• returns the file name, including the extension. For example, calling to generate a user message about the file returns the file name .\n• returns the entire path for the file. For example, calling to generate a user message about the file returns the file path .\n• GetFileTitle returns the file name, excluding the file extension. For example, calling to generate a user message about the file returns the file title .\n\nSee the example for .\n\nCall this member function to get the title of the found file.\n\nThe title of the file.\n\nYou must call at least once before calling .\n\nis one of three member functions that return some form of the file name. The following list describes the three and how they vary:\n• returns the file name, including the extension. For example, calling to generate a user message about the file returns the file name .\n• returns the entire path for the file. For example, calling to generate a user message about the file returns the file path c:\\myhtml\\myfile.txt.\n• returns the file name, excluding the file extension. For example, calling to generate a user message about the file returns the file title .\n\nSee the example for .\n\nCall this member function to retrieve the specified URL.\n\nYou must call at least once before calling .\n\nis similar to the member function , except that it returns the URL in the form . For example, calling to get the complete URL for returns the URL .\n\nSee the example for .\n\nCall this member function to get the time that the specified file was last accessed.\n\n\n\n A pointer to a structure containing the time the file was last accessed.\n\nNonzero if successful; 0 if unsuccessful. returns 0 only if has never been called on this object.\n\nYou must call at least once before calling .\n\nSee the example for .\n\nCall this member function to get the last time the file was changed.\n\n\n\n A pointer to a structure containing the time the file was last written to.\n\nNonzero if successful; 0 if unsuccessful. returns 0 only if has never been called on this object.\n\nYou must call at least once before calling .\n\nSee the example for .\n\nCall this member function to get the length of the found file, in bytes.\n\nThe length of the found file, in bytes.\n\nYou must call at least once before calling .\n\nuses the Win32 structure to get and return the value of the file size, in bytes.\n\nCall this member function to get the root of the found file.\n\nThe root of the active search.\n\nYou must call at least once before calling .\n\nThis member function returns the drive specifier and path name used to start a search. For example, calling with results in returning an empty string. Passing a path, such as , to results returning .\n\nSee the example for .\n\nCall this member function to determine if the found file is archived.\n\nApplications mark an archive file, which is to be backed up or removed, with , a file attribute identified in the structure.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nSee the example for .\n\nCall this member function to determine if the found file is compressed.\n\nA compressed file is marked with , a file attribute identified in the structure. For a file, this attribute indicates that all of the data in the file is compressed. For a directory, this attribute indicates that compression is the default for newly created files and subdirectories.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nSee the example for .\n\nCall this member function to determine if the found file is a directory.\n\nA file that is a directory is marked with a file attribute identified in the structure.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nThis small program recurses every directory on the C:\\ drive and prints the name of the directory.\n\nCall this member function to test for the current directory and parent directory markers while iterating through files.\n\nNonzero if the found file has the name \".\" or \"..\", which indicates that the found file is actually a directory. Otherwise 0.\n\nYou must call at least once before calling .\n\nSee the example for .\n\nCall this member function to determine if the found file is hidden.\n\nHidden files, which are marked with , a file attribute identified in the structure. A hidden file is not included in an ordinary directory listing.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nSee the example for .\n\nCall this member function to determine if the found file is a normal file.\n\nFiles marked with , a file attribute identified in the structure. A normal file has no other attributes set. All other file attributes override this attribute.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nSee the example for .\n\nCall this member function to determine if the found file is read-only.\n\nA read-only file is marked with , a file attribute identified in the structure. Applications can read such a file, but they cannot write to it or delete it.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nSee the example for .\n\nCall this member function to determine if the found file is a system file.\n\nA system file is marked with , a file attribute identified in the structure. A system file is part of, or is used exclusively by, the operating system.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nSee the example for .\n\nCall this member function to determine if the found file is a temporary file.\n\nA temporary file is marked with , a file attribute identified in the structure. A temporary file is used for temporary storage. Applications should write to the file only if absolutely necessary. Most of the file's data remains in memory without being flushed to the media because the file will soon be deleted.\n\nYou must call at least once before calling .\n\nSee the member function for a complete list of file attributes.\n\nSee the example for .\n\nCall this member function to test the file attributes on the found file.\n\n\n\n Specifies one or more file attributes, identified in the structure, for the found file. To search for multiple attributes, use the bitwise OR ( ) operator. Any combination of the following attributes is acceptable:\n• The file is an archive file. Applications use this attribute to mark files for backup or removal.\n• The file or directory is compressed. For a file, this means that all of the data in the file is compressed. For a directory, this means that compression is the default for newly created files and subdirectories.\n• The file has no other attributes set. This attribute is valid only if used alone. All other file attributes override this attribute.\n• The file is hidden. It is not to be included in an ordinary directory listing.\n• The file is read only. Applications can read the file but cannot write to it or delete it.\n• The file is part of or is used exclusively by the operating system.\n• The file is being used for temporary storage. Applications should write to the file only if absolutely necessary. Most of the file's data remains in memory without being flushed to the media because the file will soon be deleted.\n\nNonzero if successful; otherwise 0. To get extended error information, call the Win32 function .\n\nYou must call at least once before calling ."
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/mfc/reference/cftpfilefind-class?view=msvc-170",
        "document": "includes member functions that begin a search, locate a file, and return the URL or other descriptive information about the file.\n\nOther MFC classes designed for Internet and local file searched include CGopherFileFind and CFileFind. Together with , these classes provide a seamless mechanism for the client to find specific files, regardless of the server protocol or file type (either a local machine or a remote server). There's no MFC class for searching on HTTP servers because HTTP doesn't support the direct file manipulation required for searches.\n\nFor more information about how to use and the other WinInet classes, see the article Internet Programming with WinInet.\n\nThe following code demonstrates how to enumerate all files in the current directory of the FTP server.\n\nThis member function is called to construct a object.\n\npConnection\n\n A pointer to a object. You can obtain an FTP connection by calling CInternetSession::GetFtpConnection.\n\ndwContext\n\n The context identifier for the object. For more information, see the following remarks.\n\nThe default value for dwContext is sent by MFC to the object from the CInternetSession object that created the object. You can override the default to set the context identifier to a value of your choosing. The context identifier is returned to CInternetSession::OnStatusCallback to provide status on the object with which it's identified. See the article Internet First Steps: WinInet for more information about the context identifier.\n\nSee the example in the class overview earlier in this topic.\n\nCall this member function to find an FTP file.\n\npstrName\n\n A pointer to a string containing the name of the file to find. If NULL, the call will do a wildcard search (*).\n\ndwFlags\n\n The flags describing how to handle this session. These flags can be combined with the bitwise OR operator ( ) and are as follows:\n• None Get the data from the wire even if it's locally cached. This is the default flag.\n• None Don't cache the data, either locally or in any gateways.\n• None Override the default to return the raw data ( WIN32_FIND_DATA structures for FTP).\n• None Secures transactions on the wire with Secure Sockets Layer or PCT. This flag applies to HTTP requests only.\n• None If possible, reuse the existing connections to the server for new requests instead of creating a new session for each request.\n\nNonzero if successful; otherwise 0. To get extended error information, call the Win32 function GetLastError.\n\nAfter calling to retrieve the first FTP file, you can call FindNextFile to retrieve subsequent FTP files.\n\nSee the earlier example in this topic.\n\nCall this member function to continue a file search begun with a call to the FindFile member function.\n\nNonzero if there are more files; zero if the file found is the last one in the directory or if an error occurred. To get extended error information, call the Win32 function GetLastError. If the file found is the last file in the directory, or if no matching files can be found, the function returns ERROR_NO_MORE_FILES.\n\nYou must call this function at least once before calling any attribute function (see CFileFind::FindNextFile).\n\nSee the example earlier in this topic.\n\nCall this member function to get the URL of the specified file.\n\nThe file and path of the Universal Resource Locator (URL).\n\nis similar to the member function CFileFind::GetFilePath except that it provides the result in URL format. As with , the result doesn't include the filename. For example, located in returns ."
    },
    {
        "link": "https://github.com/MicrosoftDocs/cpp-docs/blob/main/docs/mfc/reference/cftpfilefind-class.md",
        "document": "includes member functions that begin a search, locate a file, and return the URL or other descriptive information about the file.\n\nOther MFC classes designed for Internet and local file searched include CGopherFileFind and CFileFind. Together with , these classes provide a seamless mechanism for the client to find specific files, regardless of the server protocol or file type (either a local machine or a remote server). There's no MFC class for searching on HTTP servers because HTTP doesn't support the direct file manipulation required for searches.\n\nFor more information about how to use and the other WinInet classes, see the article Internet Programming with WinInet.\n\nThe following code demonstrates how to enumerate all files in the current directory of the FTP server.\n\nThis member function is called to construct a object.\n\npConnection\n\n A pointer to a object. You can obtain an FTP connection by calling CInternetSession::GetFtpConnection.\n\ndwContext\n\n The context identifier for the object. For more information, see the following remarks.\n\nThe default value for dwContext is sent by MFC to the object from the CInternetSession object that created the object. You can override the default to set the context identifier to a value of your choosing. The context identifier is returned to CInternetSession::OnStatusCallback to provide status on the object with which it's identified. See the article Internet First Steps: WinInet for more information about the context identifier.\n\nSee the example in the class overview earlier in this topic.\n\nCall this member function to find an FTP file.\n\npstrName\n\n A pointer to a string containing the name of the file to find. If NULL, the call will do a wildcard search (*).\n\ndwFlags\n\n The flags describing how to handle this session. These flags can be combined with the bitwise OR operator ( ) and are as follows:\n• Get the data from the wire even if it's locally cached. This is the default flag.\n• Don't cache the data, either locally or in any gateways.\n• Override the default to return the raw data ( WIN32_FIND_DATA structures for FTP).\n• Secures transactions on the wire with Secure Sockets Layer or PCT. This flag applies to HTTP requests only.\n• If possible, reuse the existing connections to the server for new requests instead of creating a new session for each request.\n\nNonzero if successful; otherwise 0. To get extended error information, call the Win32 function GetLastError.\n\nAfter calling to retrieve the first FTP file, you can call FindNextFile to retrieve subsequent FTP files.\n\nSee the earlier example in this topic.\n\nCall this member function to continue a file search begun with a call to the FindFile member function.\n\nNonzero if there are more files; zero if the file found is the last one in the directory or if an error occurred. To get extended error information, call the Win32 function GetLastError. If the file found is the last file in the directory, or if no matching files can be found, the function returns ERROR_NO_MORE_FILES.\n\nYou must call this function at least once before calling any attribute function (see CFileFind::FindNextFile).\n\nSee the example earlier in this topic.\n\nCall this member function to get the URL of the specified file.\n\nThe file and path of the Universal Resource Locator (URL).\n\nis similar to the member function CFileFind::GetFilePath except that it provides the result in URL format. As with , the result doesn't include the filename. For example, located in returns ."
    },
    {
        "link": "http://icodeguru.com/vc&mfc/mfcreference/html/_mfc_cfilefind.htm",
        "document": "The MFC class CFileFind performs local file searches and is the base class for CGopherFileFind and CFtpFileFind, which perform Internet file searches. CFileFind includes member functions that begin a search, locate a file, and return the title, name, or path of the file. For Internet searches, the member function GetFileURL returns the file’s URL.\n\nCFileFind is the base class for two other MFC classes designed to search particular server types: CGopherFileFind works specifically with gopher servers, and CFtpFileFind works specifically with FTP servers. Together, these three classes provide a seamless mechanism for the client to find files, regardless of the server protocol, the file type, or location, on either a local machine or a remote server.\n\nThe following code will enumerate all the files in the current directory, printing the name of each file:\n\nTo keep the example simple, this code uses the standard C++ library cout class. The cout line could be replaced with a call to CListBox::AddString, for example, in a program with a graphical user interface.\n\nFor more information about how to use CFileFind and the other WinInet classes, see the article Internet Programming with WinInet in Visual C++ Programmer's Guide."
    }
]