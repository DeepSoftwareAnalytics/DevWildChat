[
    {
        "link": "https://lua.org/manual/5.1/manual.html",
        "document": "The language constructs will be explained using the usual extended BNF notation, in which {a} means 0 or more a's, and [a] means an optional a. Non-terminals are shown like non-terminal, keywords are shown like kword, and other terminal symbols are shown like `=´. The complete syntax of Lua can be found in §8 at the end of this manual.\n\nBefore the assignment, the list of values is adjusted to the length of the list of variables. If there are more values than needed, the excess values are thrown away. If there are fewer values than needed, the list is extended with as many nil's as needed. If the list of expressions ends with a function call, then all values returned by that call enter the list of values, before the adjustment (except when the call is enclosed in parentheses; see §2.5).\n\nThe condition expression of a control structure can return any value. Both false and nil are considered false. All values different from nil and false are considered true (in particular, the number 0 and the empty string are also true).\n\nNumbers and literal strings are explained in §2.1; variables are explained in §2.3; function definitions are explained in §2.5.9; function calls are explained in §2.5.8; table constructors are explained in §2.5.7. Vararg expressions, denoted by three dots (' '), can only be used when directly inside a vararg function; they are explained in §2.5.9.\n\nEquality ( ) first compares the type of its operands. If the types are different, then the result is false. Otherwise, the values of the operands are compared. Numbers and strings are compared in the usual way. Objects (tables, userdata, threads, and functions) are compared by reference: two objects are considered equal only if they are the same object. Every time you create a new object (a table, userdata, thread, or function), this new object is different from any previously existing object.\n\nThe order operators work as follows. If both arguments are numbers, then they are compared as such. Otherwise, if both arguments are strings, then their values are compared according to the current locale. Otherwise, Lua tries to call the \"lt\" or the \"le\" metamethod (see §2.8). A comparison is translated to and is translated to .\n\nThreads are created sharing the environment of the creating thread. Userdata and C functions are created sharing the environment of the creating C function. Non-nested Lua functions (created by , or ) are created sharing the environment of the creating thread. Nested Lua functions are created sharing the environment of the creating Lua function.\n\nUnless otherwise noted, any function that accepts valid indices can also be called with pseudo-indices, which represent some Lua values that are accessible to C code but which are not in the stack. Pseudo-indices are used to access the thread environment, the function environment, the registry, and the upvalues of a C function (see §3.4).\n\nThe type of the memory-allocation function used by Lua states. The allocator function must provide a functionality similar to , but not exactly the same. Its arguments are , an opaque pointer passed to ; , a pointer to the block being allocated/reallocated/freed; , the original size of the block; , the new size of the block. is if and only if is zero. When is zero, the allocator must return ; if is not zero, it should free the block pointed to by . When is not zero, the allocator returns if and only if it cannot fill the request. When is not zero and is zero, the allocator should behave like . When and are not zero, the allocator behaves like . Lua assumes that the allocator never fails when .\n\nTo call a function you must use the following protocol: first, the function to be called is pushed onto the stack; then, the arguments to the function are pushed in direct order; that is, the first argument is pushed first. Finally you call ; is the number of arguments that you pushed onto the stack. All arguments and the function value are popped from the stack when the function is called. The function results are pushed onto the stack when the function returns. The number of results is adjusted to , unless is . In this case, all results from the function are pushed. Lua takes care that the returned values fit into the stack space. The function results are pushed onto the stack in direct order (the first result is pushed first), so that after the call the last result is on the top of the stack.\n\nGets information about a closure's upvalue. (For Lua functions, upvalues are the external local variables that the function uses, and that are consequently included in its closure.) gets the index of an upvalue, pushes the upvalue's value onto the stack, and returns its name. points to the closure in the stack. (Upvalues have no particular order, as they are active through the whole function. So, they are numbered in an arbitrary order.)"
    },
    {
        "link": "https://lua.org/manual/5.1",
        "document": ""
    },
    {
        "link": "https://devdocs.io/lua~5.1",
        "document": ""
    },
    {
        "link": "http://stevedonovan.github.io/lua-5.1.4/doc/manual.html",
        "document": "The language constructs will be explained using the usual extended BNF notation, in which {a} means 0 or more a's, and [a] means an optional a. Non-terminals are shown like non-terminal, keywords are shown like kword, and other terminal symbols are shown like `=´. The complete syntax of Lua can be found in §8 at the end of this manual.\n\nBefore the assignment, the list of values is adjusted to the length of the list of variables. If there are more values than needed, the excess values are thrown away. If there are fewer values than needed, the list is extended with as many nil's as needed. If the list of expressions ends with a function call, then all values returned by that call enter the list of values, before the adjustment (except when the call is enclosed in parentheses; see §2.5).\n\nThe condition expression of a control structure can return any value. Both false and nil are considered false. All values different from nil and false are considered true (in particular, the number 0 and the empty string are also true).\n\nNumbers and literal strings are explained in §2.1; variables are explained in §2.3; function definitions are explained in §2.5.9; function calls are explained in §2.5.8; table constructors are explained in §2.5.7. Vararg expressions, denoted by three dots (' '), can only be used when directly inside a vararg function; they are explained in §2.5.9.\n\nEquality ( ) first compares the type of its operands. If the types are different, then the result is false. Otherwise, the values of the operands are compared. Numbers and strings are compared in the usual way. Objects (tables, userdata, threads, and functions) are compared by reference: two objects are considered equal only if they are the same object. Every time you create a new object (a table, userdata, thread, or function), this new object is different from any previously existing object.\n\nThe order operators work as follows. If both arguments are numbers, then they are compared as such. Otherwise, if both arguments are strings, then their values are compared according to the current locale. Otherwise, Lua tries to call the \"lt\" or the \"le\" metamethod (see §2.8). A comparison is translated to and is translated to .\n\nThreads are created sharing the environment of the creating thread. Userdata and C functions are created sharing the environment of the creating C function. Non-nested Lua functions (created by , or ) are created sharing the environment of the creating thread. Nested Lua functions are created sharing the environment of the creating Lua function.\n\nUnless otherwise noted, any function that accepts valid indices can also be called with pseudo-indices, which represent some Lua values that are accessible to C code but which are not in the stack. Pseudo-indices are used to access the thread environment, the function environment, the registry, and the upvalues of a C function (see §3.4).\n\nThe type of the memory-allocation function used by Lua states. The allocator function must provide a functionality similar to , but not exactly the same. Its arguments are , an opaque pointer passed to ; , a pointer to the block being allocated/reallocated/freed; , the original size of the block; , the new size of the block. is if and only if is zero. When is zero, the allocator must return ; if is not zero, it should free the block pointed to by . When is not zero, the allocator returns if and only if it cannot fill the request. When is not zero and is zero, the allocator should behave like . When and are not zero, the allocator behaves like . Lua assumes that the allocator never fails when .\n\nTo call a function you must use the following protocol: first, the function to be called is pushed onto the stack; then, the arguments to the function are pushed in direct order; that is, the first argument is pushed first. Finally you call ; is the number of arguments that you pushed onto the stack. All arguments and the function value are popped from the stack when the function is called. The function results are pushed onto the stack when the function returns. The number of results is adjusted to , unless is . In this case, all results from the function are pushed. Lua takes care that the returned values fit into the stack space. The function results are pushed onto the stack in direct order (the first result is pushed first), so that after the call the last result is on the top of the stack.\n\nGets information about a closure's upvalue. (For Lua functions, upvalues are the external local variables that the function uses, and that are consequently included in its closure.) gets the index of an upvalue, pushes the upvalue's value onto the stack, and returns its name. points to the closure in the stack. (Upvalues have no particular order, as they are active through the whole function. So, they are numbered in an arbitrary order.)"
    },
    {
        "link": "https://download.redis.io/redis-stable/deps/lua/doc/manual.html",
        "document": "The language constructs will be explained using the usual extended BNF notation, in which {a} means 0 or more a's, and [a] means an optional a. Non-terminals are shown like non-terminal, keywords are shown like kword, and other terminal symbols are shown like `=´. The complete syntax of Lua can be found in §8 at the end of this manual.\n\nBefore the assignment, the list of values is adjusted to the length of the list of variables. If there are more values than needed, the excess values are thrown away. If there are fewer values than needed, the list is extended with as many nil's as needed. If the list of expressions ends with a function call, then all values returned by that call enter the list of values, before the adjustment (except when the call is enclosed in parentheses; see §2.5).\n\nThe condition expression of a control structure can return any value. Both false and nil are considered false. All values different from nil and false are considered true (in particular, the number 0 and the empty string are also true).\n\nNumbers and literal strings are explained in §2.1; variables are explained in §2.3; function definitions are explained in §2.5.9; function calls are explained in §2.5.8; table constructors are explained in §2.5.7. Vararg expressions, denoted by three dots (' '), can only be used when directly inside a vararg function; they are explained in §2.5.9.\n\nEquality ( ) first compares the type of its operands. If the types are different, then the result is false. Otherwise, the values of the operands are compared. Numbers and strings are compared in the usual way. Objects (tables, userdata, threads, and functions) are compared by reference: two objects are considered equal only if they are the same object. Every time you create a new object (a table, userdata, thread, or function), this new object is different from any previously existing object.\n\nThe order operators work as follows. If both arguments are numbers, then they are compared as such. Otherwise, if both arguments are strings, then their values are compared according to the current locale. Otherwise, Lua tries to call the \"lt\" or the \"le\" metamethod (see §2.8). A comparison is translated to and is translated to .\n\nThreads are created sharing the environment of the creating thread. Userdata and C functions are created sharing the environment of the creating C function. Non-nested Lua functions (created by , or ) are created sharing the environment of the creating thread. Nested Lua functions are created sharing the environment of the creating Lua function.\n\nUnless otherwise noted, any function that accepts valid indices can also be called with pseudo-indices, which represent some Lua values that are accessible to C code but which are not in the stack. Pseudo-indices are used to access the thread environment, the function environment, the registry, and the upvalues of a C function (see §3.4).\n\nThe type of the memory-allocation function used by Lua states. The allocator function must provide a functionality similar to , but not exactly the same. Its arguments are , an opaque pointer passed to ; , a pointer to the block being allocated/reallocated/freed; , the original size of the block; , the new size of the block. is if and only if is zero. When is zero, the allocator must return ; if is not zero, it should free the block pointed to by . When is not zero, the allocator returns if and only if it cannot fill the request. When is not zero and is zero, the allocator should behave like . When and are not zero, the allocator behaves like . Lua assumes that the allocator never fails when .\n\nTo call a function you must use the following protocol: first, the function to be called is pushed onto the stack; then, the arguments to the function are pushed in direct order; that is, the first argument is pushed first. Finally you call ; is the number of arguments that you pushed onto the stack. All arguments and the function value are popped from the stack when the function is called. The function results are pushed onto the stack when the function returns. The number of results is adjusted to , unless is . In this case, all results from the function are pushed. Lua takes care that the returned values fit into the stack space. The function results are pushed onto the stack in direct order (the first result is pushed first), so that after the call the last result is on the top of the stack.\n\nGets information about a closure's upvalue. (For Lua functions, upvalues are the external local variables that the function uses, and that are consequently included in its closure.) gets the index of an upvalue, pushes the upvalue's value onto the stack, and returns its name. points to the closure in the stack. (Upvalues have no particular order, as they are active through the whole function. So, they are numbered in an arbitrary order.)"
    },
    {
        "link": "https://stackoverflow.com/questions/8695378/how-to-sum-a-table-of-numbers-in-lua",
        "document": "I disagree, it would be redundant to have something that primitive and specific as in the standard library.\n\nIt'd be more useful to implement along the lines of:\n\nAnd use it with a simple lambda:\n\nThe example implementation of lacks type-checking but you should get the idea."
    },
    {
        "link": "https://stackoverflow.com/questions/43416757/why-is-this-function-to-add-the-contents-of-a-table-together-in-lua-returning-no",
        "document": "A more generic solution to this problem of reducing the contents of a table (in this case by summing the elements) is outlined in this answer (warning: no type checking in code sketch).\n\nIf your function is not returning at all, it is probably because you are missing an statement in the function definition.\n\nIf your function is returning zero, it is possible that there is a problem with the table you are passing as an argument. In other words, the parameter may be or an empty table. In that case, the function would return zero, the value to which your is initialized.\n\nIf you add in the loop for debugging, you can determine whether the function has anything to add. So I would try:\n\nThe expected output when running this code is\n\nNotice that I've changed the variable name inside the function from to . It's preferable not to use the function name as the variable holding the sum in the function definition. The in the function overrides the global one, so for example, you couldn't call recursively (i.e. call in the definition of )."
    },
    {
        "link": "https://lua.org/gems/sample.pdf",
        "document": ""
    },
    {
        "link": "https://forums.civfanatics.com/threads/lua-table-with-multiple-values.529374",
        "document": "I can't quite figure out what you're trying to do.But I think you might be confusing things by using the table.insert method. It's documented here and you shouldn't try to use it in any other way. For one thing, you don't ever need #t+1 because insert uses that by default. Just supply table name and value to insert a new element at end. Or supply an index if you want to insert anywhere else (shifting everything else up).But no need to ever use that library method anyway, since it's so easy (and much faster) to manipulate tables directly.These two statements are exactly equivalent, except the 2nd will run much faster:Lua does support multiple assignment, if you like to do that (some would argue that it makes code harder to read):Use local wherever possible, since they can be read and assigned to much faster than global. Use global when you need to access a value from different files. Note: globals aren't truely global in Lua since they are only defined within a state. Your mod should probably all be running in the same Lua state even if you have many files, but the UI lua files are running in different states (there is a \"super global\" called MapModData available across all Lua states). But even if you define a table as a global, it is optimal to localize it in a particular file:The 2nd line is kind of a lie, since myGlobalTable is now a local variable in the scope where that line occurs (i.e., for the whole file if the line is outside of a function at the top of the file).You can speed up your Lua code by 30 - 50% or so (depending) by localizing all the tables that happen to be used in a particular file. These include global Tables defined by Firaxis such as GameInfoTypes, ImprovementTypes, GameDefines, Players, Teams, MapModData etc...Btw, \"print\" is a global variable. It just happens to hold a function. Lua variables can hold exactly 8 different things: nil, Boolean, Number, String, Table, Function, Userdata and Thread (don't worry about the last two). So it is a perfectly valid statement in Lua to say:That just assigns the function to a local variable with the same name, which will make it run faster by some small amount (which is silly to do in this case because you shouldn't be printing millions of lines). But if you use a library method or a method on a static object (like Map) in time critical code (i.e., anything that runs 1000s of times a turn such as per plot tests), then absolutely you should localize it:etc...The reason local variables are so much faster in Lua is that they are held in your processor register. Global variables are held elsewhere and require a bit of time to find. There is a limit, however, which is that any of your functions can only access 60 \"upvalues\" (local variables defined above and outside the function). You will get a Syntax Error if you violate that. But if you run into this limit, then you really should be writing smaller more focused functions (a lesson I'm learning)."
    },
    {
        "link": "https://devforum.roblox.com/t/how-do-i-add-all-the-values-in-a-table-together/716906",
        "document": "local value = 0\n\n for i,v in pairs(Example:GetChildren()) do\n\n value = value + v\n\n end\n\n print(value)\n\nthat’s what I could think of right now. Maybe I’m wrong and it doesn’t work"
    }
]