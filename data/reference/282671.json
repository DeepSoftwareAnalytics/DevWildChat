[
    {
        "link": "https://stackoverflow.com/questions/26684029/select2-field-implementation-in-flask-flask-admin",
        "document": "I'm trying to implement Select2 field in one of my flask views. Basically I want the same select2 field in my flask application view (not a flask admin modelview) as in Flask-admin model create views. Currently my solution has been from wtforms that looks something like this\n\nThis allows me to load and select all the data I need, but it does not provide select2 search box etc. Currently all that I have found is and from flask/admin/form/fields and flask/admin/form/widgets similarly like in this post https://stackoverflow.com/questions/24644960/how-to-steal-flask-admin-tag-form-field and also select2 documentation at http://ivaynberg.github.io/select2/ As I understand these could be reusable, meaning there is no need for other custom widgets, custom fields.\n\nWould be grateful if someone could provide more information about select2 field implementation in flask application (including views, templates, forms files and how to correctly \"connect\" with neccessary js and css files, also how to load the field up with the database model I need)."
    },
    {
        "link": "https://flask-admin.readthedocs.io/en/latest/api/mod_form_fields",
        "document": "You must include select2.js, form-x.x.x.js and select2 stylesheet for it to work.\n• None label – The label of the field.\n• None validators – A sequence of validators to call when is called.\n• None filters – A sequence of callable which are run by to filter or transform the input data. For example . Note that filters are applied after processing the default and incoming data, but before validation.\n• None description – A description for the field, typically used for help text.\n• None id – An id to use for the field. A reasonable default is set by the form, and you shouldn’t need to set this manually.\n• None default – The default value to assign to the field, if no form or object input is provided. May be a callable.\n• None widget – If provided, overrides the widget used to render the field.\n• None render_kw (dict) – If provided, a dictionary which provides default keywords that will be given to the widget at render time.\n• None name – The HTML name of this field. The default value is the Python attribute name.\n• None _form – The form holding this field. It is passed by the form itself during construction. You should never pass this value yourself.\n• None _prefix – The prefix to prepend to the form name of this field, passed by the enclosing form during construction.\n• None _translations – A translations object providing message translations. Usually passed by the enclosing form during construction. See I18n docs for information on message translations.\n• None _meta – If provided, this is the ‘meta’ instance from the form. You usually don’t pass this yourself.\n\nIf isn’t provided, an will be returned instead. Call its method with a form instance and a name to construct the field.\n\nProcess the Python data applied to this field and store the result. This will be called during form construction by the form’s or argument. value – The python object containing the value to process."
    },
    {
        "link": "https://flask-admin.readthedocs.io/en/stable/api/mod_model",
        "document": "This view does not make any assumptions on how models are stored or managed, but expects the following:\n\nEssentially, if you want to support a new data store, all you have to do is:\n\nDictionary of value type formatters to be used in the list view. By default, three types are formatted:\n• will be displayed as an empty string\n• will be displayed as a checkmark if it is\n• will be joined using ‘, ‘ If you don’t like the default behavior and don’t want any type formatters applied, just override this property with an empty dictionary: If you want to display instead of an empty string, you can do something like this. Also comes with bonus formatter: The callback function has following prototype: # `value` value to format"
    },
    {
        "link": "https://flask-admin.readthedocs.io/en/latest/api/mod_model",
        "document": "This view does not make any assumptions on how models are stored or managed, but expects the following:\n\nEssentially, if you want to support a new data store, all you have to do is:\n\nDictionary of value type formatters to be used in the list view. By default, three types are formatted:\n• None will be displayed as an empty string\n• None will be displayed as a checkmark if it is\n• None will be joined using ‘, ‘ If you don’t like the default behavior and don’t want any type formatters applied, just override this property with an empty dictionary: If you want to display instead of an empty string, you can do something like this. Also comes with bonus formatter: The callback function has following prototype: # `value` value to format"
    },
    {
        "link": "https://stackoverflow.com/questions/40626768/how-to-compute-options-of-dropdown-for-column-filter-in-flask-admin",
        "document": "In Flask Admin, I got a column of String values (I can't change the DB definition). When filtering this column in the index view, the user should be able to select the value from a dropdown.\n\nThe possible options for the filter should be computed when the user selects the filter. So I need a way to set the options based on a custom model query. Querying is rather fast as the column is indexed.\n\nThe SQLA custom filter example only shows how to apply a custom filter, but not how to make the options of a filter dynamic."
    },
    {
        "link": "https://stackoverflow.com/questions/41569206/flask-sqlalchemy-foreign-key-relationships",
        "document": "I'm having a lot of trouble getting my head around foreign keys and relationships in SQLAlchemy. I have two tables in my database. The first one is and the second one is . Each contains one and each has one .\n\nWhen I am running I get the following error"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-use-one-to-many-database-relationships-with-flask-sqlalchemy",
        "document": "The author selected the Free and Open Source Fund to receive a donation as part of the Write for DOnations program.\n\nFlask is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. SQLAlchemy is an SQL toolkit that provides efficient and high-performing database access for relational databases. It provides ways to interact with several database engines such as SQLite, MySQL, and PostgreSQL. It gives you access to the database’s SQL functionalities. And it also gives you an Object Relational Mapper (ORM), which allows you to make queries and handle data using simple Python objects and methods. Flask-SQLAlchemy is a Flask extension that makes using SQLAlchemy with Flask easier, providing you tools and methods to interact with your database in your Flask applications through SQLAlchemy.\n\nA one-to-many database relationship is a relationship between two database tables where a record in one table can reference several records in another table. For example, in a blogging application, a table for storing posts can have a one-to-many relationship with a table for storing comments. Each post can reference many comments, and each comment references a single post; therefore, one post has a relationship with many comments. The post table is a parent table, while the comments table is a child table — a record in the parent table can reference many records in the child table. This relationship is important to enable access to related data in each table.\n\nIn this tutorial, you’ll build a small blogging system that demonstrates how to build one-to-many relationships using the Flask-SQLAlchemy extension. You’ll create a relationship between posts and comments, where each blog post can have several comments.\n• A local Python 3 programming environment. Follow the tutorial for your distribution in How To Install and Set Up a Local Programming Environment for Python 3 series. In this tutorial we’ll call our project directory .\n• An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out How to Create Your First Web Application Using Flask and Python and How to Use Templates in a Flask Application.\n• An understanding of basic HTML concepts. You can review our How To Build a Website with HTML tutorial series for background knowledge.\n\nIn this step, you’ll install the necessary packages for your application.\n\nWith your virtual environment activated, use to install Flask and Flask-SQLAlchemy:\n\nOnce the installation is successfully finished, you’ll see a line similar to the following at the end of the output:\n\nWith the required Python packages installed, you’ll set up the database next.\n\nStep 2 — Setting up the Database and Models\n\nIn this step, you’ll set up your database, and create SQLAlchemy database models — Python classes that represent your database tables. You’ll create a model for your blog posts and a model for comments. You’ll initiate the database, create a table for posts, and add a table for comments based on the models you’ll declare. You’ll also insert a few posts and comments into your database.\n\nOpen a file called in your directory. This file will have code for setting up the database and your Flask routes:\n\nThis file will connect to an SQLite database called , and will have two classes: A class called that represents your database posts table, and a class representing the comments table. This file will also contain your Flask routes. Add the following statements at the top of :\n\nHere, you import the module, which gives you access to miscellaneous operating system interfaces. You’ll use it to construct a file path for your database file.\n\nFrom the package, you then import the necessary helpers you need for your application: the class to create a Flask application instance, the function to render templates, the object to handle requests, the function to construct URLs for routes, and the function for redirecting users. For more information on routes and templates, see How To Use Templates in a Flask Application.\n\nYou then import the class from the Flask-SQLAlchemy extension, which gives you access to all the functions and classes from SQLAlchemy, in addition to helpers, and functionality that integrates Flask with SQLAlchemy. You’ll use it to create a database object that connects to your Flask application, allowing you to create and manipulate tables using Python classes, objects, and functions without needing to use the SQL language.\n\nBelow the imports, you’ll set up a database file path, instantiate your Flask application, and configure and connect your application with SQLAlchemy. Add the following code:\n\nHere, you construct a path for your SQLite database file. You first define a base directory as the current directory. You use the function to get the absolute path of the current file’s directory. The special variable holds the pathname of the current file. You store the absolute path of the base directory in a variable called .\n\nYou then create a Flask application instance called , which you use to configure two Flask-SQLAlchemy configuration keys:\n• : The database URI to specify the database you want to establish a connection with. In this case, the URI follows the format . You use the function to intelligently join the base directory you constructed and stored in the variable, and the file name. This will connect to a database file in your directory. The file will be created once you initiate the database.\n• : A configuration to enable or disable tracking modifications of objects. You set it to to disable tracking and use less memory. For more, see the configuration page in the Flask-SQLAlchemy documentation.\n\nAfter configuring SQLAlchemy by setting a database URI and disabling tracking, you create a database object using the class, passing the application instance to connect your Flask application with SQLAlchemy. You store your database object in a variable called . You’ll use this object to interact with your database.\n\nWith the database connection established and the database object created, you’ll use the database object to create a database table for posts and one for comments. Tables are represented by a model — a Python class that inherits from a base class Flask-SQLAlchemy provides through the database instance you created earlier. To define the posts and comments tables as models, add the following two classes to your file:\n\nHere, you create a model and a model, which inherit from the class.\n\nThe model represents the post table. You use the class to define its columns. The first argument represents the column type, and additional arguments represent the column configuration.\n\nYou define the following columns for the model:\n• : The post ID. You define it as an integer with . defines this column as a primary key, which will assign it a unique value by the database for each entry (that is, each post).\n• : The post’s title. A string with a maximum length of 100 characters.\n• : The post’s content. indicates the column holds long texts.\n\nThe class attribute defines a One-to-Many relationship between the model and the model. You use the method, passing it the name of the comments model ( in this case). You use the parameter to add a back reference that behaves like a column to the model. This way, you can access the post the comment was posted on using a attribute. For example, if you have a comment object in a variable called , you will be able to access the post the comment belongs to using . You’ll see an example demonstrating this later.\n\nSee the SQLAlchemy documentation for column types other than the types you used in the preceding code block.\n\nThe special function allows you to give each object a string representation to recognize it for debugging purposes.\n\nThe model represents the comment table. You define the following columns for it:\n• : The comment ID. You define it as an integer with . defines this column as a primary key, which will assign it a unique value by the database for each entry (that is, each comment).\n• : The comment’s content. indicates the column holds long texts.\n• : An integer foreign key you construct using the class, which is a key that links a table with another, using that table’s primary key. This links a comment to a post using the primary key of the post, which is its ID. Here, the table is a parent table, which indicates that each post has many comments. The table is a child table. Each comment is related to a parent post using the post’s ID. Therefore, each comment has a column that can be used to access the post the comment was posted on.\n\nThe special function in the model shows the first 20 characters of the comment’s content to give a comment object a short string representation.\n\nThe file will now look as follows:\n\nNow that you’ve set the database connection and the post and comment models, you’ll use the Flask shell to create your database and your post and comment tables based on the models you declared.\n\nWith your virtual environment activated, set the file as your Flask application using the environment variable:\n\nThen open the Flask shell using the following command in your directory:\n\nA Python interactive shell will be opened. This special shell runs commands in the context of your Flask application, so that the Flask-SQLAlchemy functions you’ll call are connected to your application.\n\nImport the database object and the post and comment models, and then run the function to create the tables that are associated with your models:\n\nLeave the shell running, open another terminal window and navigate to your directory. You will now see a new file called in .\n\nIf you receive an error, make sure your database URI and your model declaration are correct.\n\nAfter creating the database and the post and comment tables, you’ll create a file in your directory to add some posts and comments to your database.\n\nAdd the following code to it. This file will create three post objects and four comment objects, and add them to the database:\n\nHere, you import the database object, the model, and the model from the file.\n\nYou create a few post objects using the model, passing the post’s title to the parameter and the post’s content to the parameter.\n\nYou then create a few comment objects, passing the comment’s content. You have two methods you can use to associate a comment with the post it belongs to. You can pass the post object to the parameter as demonstrated in the and objects. And you can also pass the post ID to the parameter, as demonstrated in the and objects. So you can just pass the integer ID of the post if you don’t have the post object in your code.\n\nAfter defining the post and comment objects, you use the to add all post and comment objects to the database session, which manages transactions. Then you use the method to commit the transaction and apply the changes to the database. For more on SQLAlchemy database sessions, see step 2 of the How to Use Flask-SQLAlchemy to Interact with Databases in a Flask Application tutorial.\n\nRun the file to execute the code and add the data to the database:\n\nTo take a look at the data you added to your database, open the flask shell to query all posts and display their titles and the content of each post’s comments:\n\nRun the following code. This queries all posts and displays each post title and the comments of each post below it:\n\nHere, you import the model from the file. You query all the posts that exist in the database using the method on the attribute, and save the result in a variable called . Then you use a loop to go through each item in the variable. You print the title and then use another loop to go through each comment belonging to the post. You access the post’s comments using . You print the comment’s content and then print the string to separate between posts.\n\nYou’ll get the following output:\n\nAs you can see, you can access the data of each post and the comments of each post with very little code.\n\nAt this point, you have several posts and comments in your database. Next, you’ll create a Flask route for the index page and display all of the posts in your database on it.\n\nIn this step, you’ll create a route and a template to display all the posts in the database on the index page.\n\nOpen your file to add a route for the index page to it:\n\nAdd the following route at the end of the file:\n\nHere, you create an view function using the decorator. In this function, you query the database and get all the posts like you did in the previous step. You store the query result in a variable called and then you pass it to a template file you render using the helper function.\n\nBefore you create the template file on which you’ll display the existing posts in the database, you’ll first create a base template, which will have all the basic HTML code other templates will also use to avoid code repetition. Then you’ll create the template file you rendered in your function. To learn more about templates, see How to Use Templates in a Flask Application.\n\nAdd the following code inside the file:\n\nThis base template has all the HTML boilerplate you’ll need to reuse in your other templates. The block will be replaced to set a title for each page, and the block will be replaced with the content of each page. The navigation bar has three links: one for the index page, which links to the view function using the helper function, one for a Comments page, and one for an About page if you choose to add one to your application. You’ll edit this file later after you add a page for displaying all the latest comments to make the Comments link functional.\n\nNext, open a new template file. This is the template you referenced in the file:\n\nAdd the following code to it:\n\nHere, you extend the base template and replace the contents of the content block. You use an heading that also serves as a title. You use a Jinja loop in the line to go through each post in the variable that you passed from the view function to this template. You display the post ID, its title, and the post content. The post title will later link to a page that displays the individual post and its comments.\n\nWhile in your directory with your virtual environment activated, tell Flask about the application ( in this case) using the environment variable. Then set the environment variable to to run the application in development mode and get access to the debugger. For more information about the Flask debugger, see How To Handle Errors in a Flask Application. Use the following commands to do this:\n\nWith the development server running, visit the following URL using your browser:\n\nYou’ll see the posts you added to the database in a page similar to the following:\n\nYou’ve displayed the posts you have in your database on the index page. Next, you’ll create a route for a post page, where you will display the details of each post and its comments below it.\n\nIn this step, you’ll create a route and a template to display the details of each post on a dedicated page, and the post’s comments below it.\n\nBy the end of this step, the URL will be a page that displays the first post (because it has the ID ) and its comments. The URL will display the post with the associated number, if it exists.\n\nLeave the development server running and open a new terminal window.\n\nAdd the following route at the end of the file:\n\nHere, you use the route , with being a converter that converts the default string in the URL into an integer. is the URL variable that will determine the post you’ll display on the page.\n\nThe ID is passed from the URL to the view function through the parameter. Inside the function, you query the post table and retrieve a post by its ID using the method. This will save the post data in the variable if it exists, and respond with a HTTP error if no post with the given ID exists in the database.\n\nYou render a template called and pass it the post you retrieved.\n\nType the following code in it. This will be similar to the template, except that it will only display a single post:\n\nHere, you extend the base template, set the post title as a page title, display the post ID, post title, and the post content. Then, you go through the post comments available via . You display the comment ID, and the contents of the comment.\n\nUse your browser to navigate to the URL for the second post:\n\nYou’ll see a page similar to the following:\n\nNext, edit to make the title of the post link to the individual post:\n\nEdit the value of the attribute of the post title’s link inside the loop:\n\nNavigate to your index page or refresh it:\n\nClick on each of the post titles on the index page. You’ll now see that each post links to the proper post page.\n\nYou’ve now created a page for displaying individual posts. Next, you’ll add a web form to the post page to allow users to add new comments.\n\nIn this step, you’ll edit the route and its view function, which handles displaying an individual post. You’ll add a web form below each post to allow users to add comments to that post, then you’ll handle the comment submission and add it to the database.\n\nFirst, open the template file to add a web form consisting of a text area for the comment’s content, and an Add Comment submit button.\n\nEdit the file by adding a form below the H3 heading, and directly above the loop:\n\nHere, you add a tag with the attribute set to to indicate that the form will submit a POST request.\n\nYou have a text area for the comment’s content, and a submit button.\n\nWith the development server running, use your browser to navigate to a post:\n\nYou’ll see a page similar to the following:\n\nThis form sends a POST request to the view function, but because there is no code to handle the form submission, the form currently does not work.\n\nNext, you will add code to the view function to handle the form submission and add the new comment to the database. Open to handle the POST request the user submits:\n\nEdit the route and its view function to look as follows:\n\nYou allow both GET and POST requests using the parameter. GET requests are used to retrieve data from the server. POST requests are used to post data to a specific route. By default, only GET requests are allowed.\n\nInside the condition, you handle the POST request the user will submit via the form. You create a comment object using the model, passing it the content of the submitted comment which you extract from the object. You specify the post the comment belongs to using the parameter, passing it the object you retrieved using the post ID, with the method.\n\nYou add the comment object you constructed to the database session, commit the transaction, and redirect to the post page.\n\nNow refresh the post page on your browser, write a comment, and submit it. You’ll see your new comment below the post.\n\nYou now have a web form that allows users to add comments to a post. For more on web forms, see How To Use Web Forms in a Flask Application. For a more advanced and more secure method of managing web forms, see How To Use and Validate Web Forms with Flask-WTF. Next, you’ll add a page that displays all the comments in the database and the posts they were posted on.\n\nIn this step, you’ll add a Comments page where you will display all the comments in the database, ordering them by displaying the newest comments first. Each comment will have the title and link of the post the comment was posted on.\n\nAdd the following route to the end of the file. This fetches all the comments in the database, ordered by the latest first. It then passes them to a template file called , which you’ll create later:\n\nYou use the method on the attribute to fetch all the comments in a specific order. In this case you use the method on the column to fetch comments in descending order, with the latest comments being first. Then you use the method to get the result and save it to a variable called .\n\nYou render a template called , passing it the object which contains all comments ordered by the latest first.\n\nType the following code inside it. This will display the comments and link to the post they belong to:\n\nHere, you extend the base template, set a title, and go through the comments using a loop. You display the comment’s ID, its content, and a link to the post it belongs to. You access the post data via .\n\nUse your browser to navigate to the comments page:\n\nYou’ll see a page similar to the following:\n\nNow edit the template to make the Comments navbar link point to this Comments page:\n\nEdit the navigation bar to look as follows:\n\nRefresh your comments page, and you’ll see that the Comments navbar link works.\n\nYou now have a page that displays all the comments in the database. Next, you’ll add a button below each comment on the post page to allow users to delete it.\n\nIn this step, you’ll add a Delete Comment button below each comment to allow users to delete unwanted comments.\n\nFirst, you’ll add a new route that accepts POST requests. The view function will receive the ID of the comment you want to delete, fetch it from the database, delete it, and the redirect to post page the deleted comment was on.\n\nAdd the following route to the end of the file.\n\nHere, instead of using the usual decorator, you use the decorator introduced in Flask version 2.0.0, which added shortcuts for common HTTP methods. For example, is a shortcut for . This means that this view function only accepts POST requests, and navigating to the route on your browser will return a error, because web browsers default to GET requests. To delete a comment, the user clicks on a button that sends a POST request to this route.\n\nThis view function receives the ID of the comment to be deleted via the URL variable. You use the method to get a comment and save it in a variable, or respond with a in case the comment doesn’t exist. You save the post ID of the post the comment belongs to in a variable, which you’ll use to redirect to the post after deleting the comment.\n\nYou use the method on the database session in the line , passing it the comment object. This sets up the session to delete the comment whenever the transaction is committed. Because you don’t need to perform any other modifications, you directly commit the transaction using . Lastly, you redirect the user to the post the now-deleted comment was posted on.\n\nNext, edit the template to add a Delete Comment button below each comment:\n\nEdit the loop by adding a new tag directly below the comment content:\n\nHere, you have a web form that submits a POST request to the view function. You pass as an argument for the parameter to specify the comment that will be deleted. You use the method function available in web browsers to display a confirmation message before submitting the request.\n\nNow navigate to a post page on your browser:\n\nYou’ll see a Delete Comment button below each comment. Click on it, and confirm the deletion. You’ll see that the comment has been deleted.\n\nYou now have a way of deleting comments from the database.\n\nYou built a small blogging system that demonstrates how to manage one-to-many relationships using the Flask-SQLAlchemy extension. You learned how to connect a parent table with a child table, associate a child object with its parent and add it to the database, and how to access child data from a parent entry and vise versa.\n\nIf you would like to read more about Flask, check out the other tutorials in the How To Build Web Applications with Flask series."
    },
    {
        "link": "https://stackoverflow.com/questions/44251089/flask-admin-how-to-display-meaningful-foreign-key-info-in-edit-and-create-forms",
        "document": "I have a Flask-Admin interface to a flask app using SQLAlechemy, and I can't seem to figure out how to handle foreign keys. Specifically, I have the following two models:\n\nI'd like for the doctor_type_id field in the create or edit forms of flask-admin to be a dropdown list of doctor_type_english_name rather than just being an integer input like this:\n\nI have functions on the models (I'm using python 2.7). I tried tinkering with form_ajax_refs in my custom form views but with no success. Any help would be much appreciated!"
    },
    {
        "link": "https://flask-admin.readthedocs.io/en/v1.2.0/db_sqla",
        "document": ""
    },
    {
        "link": "https://codingnomads.com/create-models-relationships-python-flask-sqlalchemy",
        "document": "Once you have Flask-SQLAlchemy installed and configured, you're ready to start playing with models and relationships, whether that be Barbie doll drama or SQL, and preferably it's the latter. The basics are described in this lesson.\n\nA model is an object that abstracts away much of the technical SQL functionality and that represents a persistent entity. The models are the objects that your webapp interacts with to get the data it needs and update data as needed. For you, that means it's just a Python object that has attributes that match the columns of a table.\n\nCreating a model means defining a new class that represents a database table. Flask SQLAlchemy gives you a way to do that by providing you a base class for models called . It also provides several helper classes and functions.\n\nThink back to the theme of the app in this course for a second: a music-sharing social media webapp. That involves having users that can share content, so you'll want to create a model that can represent each user's information. Give defining s a spin by putting this in your file:\n\nGreat, you've got a couple of nice-looking models now! Roles will be talked about in a bit. For now, notice the class variable, which defines the name of the table in your database. So, a class instance represents a row in the table, and a represents a row in the table.\n\nYou won't need to do much with the table name, but it's defined here so that a default name isn't chosen instead. Using plurals for the table name is popular, but unfortunately, it is not what Flask-SQLAlchemy sets as the default.\n\nAfter are the attributes of the model, which are instances of the helper class.\n\nEvery has a type, and Flask SQLAlchemy gives you helper classes for those, too.\n\nThe and column types have been defined here, but there are many others. Here are the most common:\n\nAfter the first argument, other configuration options can be specified for a column. Some of them are:\n\nFor the new model, is specified for the attribute since you'd of course want your users to have something unique and unused from other users.\n\nThe option is set to true which makes username lookups much faster. You'll be querying for usernames quite often later in the course.\n\nFlask SQLAlchemy One to Many Relationships\n\nSince relational databases are relational, they gotta have relationships. Relationships are connections between rows of different tables. In the next code snippet, you'll establish a one-to-many relationship between and .\n\nEach user of many will have one role in the application. Examples of roles include a normal user, a moderator to manage comments, or a site admin to delete or edit certain content. This relationship between models can be defined with another column in the user table and a in the role table. To establish a one-to-many relationship from to , you do this:\n\nLook at the model. Why would you want to add a column? Since each user has one role, to know which role that corresponds to, you can add a foreign key with the helper class that references a row in the table.\n\nThink of a foreigner, a tourist. This person brought an ID or passport from their home country to the new country. It's similar in a database with foreign keys. In this case, the is like a tourist's ID. It references a in the table, but is an attribute of , like the person in the new country. The argument is the column in the table that contains the primary key.\n\nThe attribute of represents all the users that have a particular role. With an instance of , you can see the \"many\" side of the relationship with the attribute. It's simply the list of all users with that role! The purpose of the is to tell the application what model is on the other side.\n\nThe keyword argument allows you to specify as an attribute of a instance in addition to the attribute. Instead of to get the ID of the role, you can use to get the actual .\n\nThere are a few other relationship options available in SQLAlchemy:\n\nThere is a somewhat rare chance that won't be able to locate the foreign key by itself. For example, it could happen when you define two foreign keys in the model. It can't be sure which one you mean, so giving it additional arguments to remove any ambiguity should solve the problem. In particular, both and are options you can use to specify join conditions to remove ambiguity.\n\nThe option is an interesting one because it can change how the data from the is loaded from the database to the program. You'll see it in action in a bit.\n\nYou just got through the basics of models and relationships! Does it feel like boot camp? Good, that means you're learning. Now drop and gimme 20 pushups, then carry on to the next lesson.\n\nYou just got through the basics models and relationships! Does it feel like boot camp? Good, that means you're learning.\n\nYou've taken your first steps into modeling with Flask-SQLAlchemy and have a foundational understanding of how to create database models and define relationships in your web applications. In this lesson, you've:\n• Realized that models act as Python classes mapping to database tables.\n• Defined a model by inheriting from and represented table rows with class attributes tied to .\n• Noted the importance of , which overrides the default naming conventions and usually is set to the plural form of the model name.\n• Explored the various data types and column options, such as , , and , as well as configuration options like and .\n• Gained insight into relationships, especially one-to-many, allowing you to connect users to roles and vice versa through the use of and .\n• Became familiar with , which adds a back-reference from one model to another, providing a convenient way to access related data.\n\nBy understanding these basics, you've created a strong foundation to build more complex data models. Keep practicing and explore how different configurations and types can affect your database interactions."
    }
]