[
    {
        "link": "https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.agg.html",
        "document": "Aggregate using one or more operations over the specified axis.\n\nThe aggregation operations are always performed over an axis, either the index (default) or the column axis. This behavior is different from aggregation functions ( , , , , , ), where the default is to compute the aggregation of the flattened array, e.g., as opposed to .\n\nis an alias for . Use the alias.\n\nFunctions that mutate the passed object can produce unexpected behavior or errors and are not supported. See Mutating with User Defined Function (UDF) methods for more details.\n\nA passed user-defined-function will be passed a Series for evaluation.\n\nAggregate these functions over the rows.\n\nAggregate different functions over the columns and rename the index of the resulting DataFrame."
    },
    {
        "link": "https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.aggregate.html",
        "document": "Aggregate using one or more operations over the specified axis.\n\nThe aggregation operations are always performed over an axis, either the index (default) or the column axis. This behavior is different from aggregation functions ( , , , , , ), where the default is to compute the aggregation of the flattened array, e.g., as opposed to .\n\nis an alias for . Use the alias.\n\nFunctions that mutate the passed object can produce unexpected behavior or errors and are not supported. See Mutating with User Defined Function (UDF) methods for more details.\n\nA passed user-defined-function will be passed a Series for evaluation.\n\nAggregate these functions over the rows.\n\nAggregate different functions over the columns and rename the index of the resulting DataFrame."
    },
    {
        "link": "https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.agg.html",
        "document": "None, in which case are used with Named Aggregation. Here the output has one column for each element in . The name of the column is keyword, whereas the value determines the aggregation used to compute the values in the column.\n\nCan also accept a Numba JIT function with specified. Only passing a single function is supported with this engine.\n\nIf the engine is chosen, the function must be a user defined function with and as the first and second arguments respectively in the function signature. Each group’s index will be passed to the user defined function and optionally available for use."
    },
    {
        "link": "https://pandas.pydata.org/docs/dev/reference/api/pandas.DataFrame.agg.html",
        "document": "Aggregate using one or more operations over the specified axis.\n\nThe aggregation operations are always performed over an axis, either the index (default) or the column axis. This behavior is different from aggregation functions ( , , , , , ), where the default is to compute the aggregation of the flattened array, e.g., as opposed to .\n\nis an alias for . Use the alias.\n\nFunctions that mutate the passed object can produce unexpected behavior or errors and are not supported. See Mutating with User Defined Function (UDF) methods for more details.\n\nA passed user-defined-function will be passed a Series for evaluation.\n\nIf defines an index relabeling, must be or .\n\nAggregate these functions over the rows.\n\nAggregate different functions over the columns and rename the index of the resulting DataFrame."
    },
    {
        "link": "https://pandas.pydata.org/pandas-docs/dev/reference/api/pandas.DataFrame.aggregate.html",
        "document": "Aggregate using one or more operations over the specified axis.\n\nThe aggregation operations are always performed over an axis, either the index (default) or the column axis. This behavior is different from aggregation functions ( , , , , , ), where the default is to compute the aggregation of the flattened array, e.g., as opposed to .\n\nis an alias for . Use the alias.\n\nFunctions that mutate the passed object can produce unexpected behavior or errors and are not supported. See Mutating with User Defined Function (UDF) methods for more details.\n\nA passed user-defined-function will be passed a Series for evaluation.\n\nIf defines an index relabeling, must be or .\n\nAggregate these functions over the rows.\n\nAggregate different functions over the columns and rename the index of the resulting DataFrame."
    },
    {
        "link": "https://labex.io/tutorials/python-how-to-create-flexible-function-parameters-420307",
        "document": "In Python, function parameters are fundamental to defining how functions receive and process input data. They provide a flexible mechanism for passing information into functions, allowing developers to create more dynamic and reusable code.\n\nPositional parameters are the most straightforward way to pass arguments to a function. They are assigned based on their position in the function call.\n• They determine how data is passed and processed\n• Consider the readability and flexibility of your function design\n\nAt LabEx, we recommend mastering these fundamental parameter concepts to write more efficient and adaptable Python code."
    },
    {
        "link": "https://informit.com/articles/article.aspx?p=2314818",
        "document": "Accepting optional positional arguments (often called star args in reference to the conventional name for the parameter, ) can make a function call more clear and remove visual noise.\n\nFor example, say you want to log some debug information. With a fixed number of arguments, you would need a function that takes a message and a list of values.\n\nHaving to pass an empty list when you have no values to log is cumbersome and noisy. It’d be better to leave out the second argument entirely. You can do this in Python by prefixing the last positional parameter name with . The first parameter for the log message is required, whereas any number of subsequent positional arguments are optional. The function body doesn’t need to change, only the callers do.\n\nIf you already have a list and want to call a variable argument function like , you can do this by using the operator. This instructs Python to pass items from the sequence as positional arguments.\n\nThere are two problems with accepting a variable number of positional arguments.\n\nThe first issue is that the variable arguments are always turned into a tuple before they are passed to your function. This means that if the caller of your function uses the operator on a generator, it will be iterated until it’s exhausted. The resulting tuple will include every value from the generator, which could consume a lot of memory and cause your program to crash.\n\nFunctions that accept are best for situations where you know the number of inputs in the argument list will be reasonably small. It’s ideal for function calls that pass many literals or variable names together. It’s primarily for the convenience of the programmer and the readability of the code.\n\nThe second issue with is that you can’t add new positional arguments to your function in the future without migrating every caller. If you try to add a positional argument in the front of the argument list, existing callers will subtly break if they aren’t updated.\n\nThe problem here is that the second call to used as the parameter because a argument wasn’t given. Bugs like this are hard to track down because the code still runs without raising any exceptions. To avoid this possibility entirely, you should use keyword-only arguments when you want to extend functions that accept (see Item 21: “Enforce Clarity with Keyword-Only Arguments”).\n• Functions can accept a variable number of positional arguments by using in the statement.\n• You can use the items from a sequence as the positional arguments for a function with the operator.\n• Using the operator with a generator may cause your program to run out of memory and crash.\n• Adding new positional parameters to functions that accept can introduce hard-to-find bugs.\n\nLike most other programming languages, calling a function in Python allows for passing arguments by position.\n\nAll positional arguments to Python functions can also be passed by keyword, where the name of the argument is used in an assignment within the parentheses of a function call. The keyword arguments can be passed in any order as long as all of the required positional arguments are specified. You can mix and match keyword and positional arguments. These calls are equivalent:\n\nPositional arguments must be specified before keyword arguments.\n\nEach argument can only be specified once.\n\nThe flexibility of keyword arguments provides three significant benefits.\n\nThe first advantage is that keyword arguments make the function call clearer to new readers of the code. With the call , it’s not evident which argument is the number and which is the divisor without looking at the implementation of the method. In the call with keyword arguments, and make it immediately obvious which parameter is being used for each purpose.\n\nThe second impact of keyword arguments is that they can have default values specified in the function definition. This allows a function to provide additional capabilities when you need them but lets you accept the default behavior most of the time. This can eliminate repetitive code and reduce noise.\n\nFor example, say you want to compute the rate of fluid flowing into a vat. If the vat is also on a scale, then you could use the difference between two weight measurements at two different times to determine the flow rate.\n\nIn the typical case, it’s useful to know the flow rate in kilograms per second. Other times, it’d be helpful to use the last sensor measurements to approximate larger time scales, like hours or days. You can provide this behavior in the same function by adding an argument for the time period scaling factor.\n\nThe problem is that now you need to specify the argument every time you call the function, even in the common case of flow rate per second (where the period is ).\n\nTo make this less noisy, I can give the argument a default value.\n\nThe argument is now optional.\n\nThis works well for simple default values (it gets tricky for complex default values—see Item 20: “Use and Docstrings to Specify Dynamic Default Arguments”).\n\nThe third reason to use keyword arguments is that they provide a powerful way to extend a function’s parameters while remaining backwards compatible with existing callers. This lets you provide additional functionality without having to migrate a lot of code, reducing the chance of introducing bugs.\n\nFor example, say you want to extend the function above to calculate flow rates in weight units besides kilograms. You can do this by adding a new optional parameter that provides a conversion rate to your preferred measurement units.\n\nThe default argument value for is , which makes the returned weight units remain as kilograms. This means that all existing callers will see no change in behavior. New callers to can specify the new keyword argument to see the new behavior.\n\nThe only problem with this approach is that optional keyword arguments like and may still be specified as positional arguments.\n\nSupplying optional arguments positionally can be confusing because it isn’t clear what the values and correspond to. The best practice is to always specify optional arguments using the keyword names and never pass them as positional arguments.\n• Function arguments can be specified by position or by keyword.\n• Keywords make it clear what the purpose of each argument is when it would be confusing with only positional arguments.\n• Keyword arguments with default values make it easy to add new behaviors to a function, especially when the function has existing callers.\n• Optional keyword arguments should always be passed by keyword instead of by position.\n\nItem 20: Use and Docstrings to Specify Dynamic Default Arguments\n\nSometimes you need to use a non-static type as a keyword argument’s default value. For example, say you want to print logging messages that are marked with the time of the logged event. In the default case, you want the message to include the time when the function was called. You might try the following approach, assuming the default arguments are reevaluated each time the function is called.\n\nThe timestamps are the same because is only executed a single time: when the function is defined. Default argument values are evaluated only once per module load, which usually happens when a program starts up. After the module containing this code is loaded, the default argument will never be evaluated again.\n\nThe convention for achieving the desired result in Python is to provide a default value of and to document the actual behavior in the docstring (see Item 49: “Write Docstrings for Every Function, Class, and Module”). When your code sees an argument value of , you allocate the default value accordingly.\n\nNow the timestamps will be different.\n\nUsing for default argument values is especially important when the arguments are mutable. For example, say you want to load a value encoded as JSON data. If decoding the data fails, you want an empty dictionary to be returned by default. You might try this approach.\n\nThe problem here is the same as the example above. The dictionary specified for will be shared by all calls to because default argument values are only evaluated once (at module load time). This can cause extremely surprising behavior.\n\nYou’d expect two different dictionaries, each with a single key and value. But modifying one seems to also modify the other. The culprit is that and are both equal to the parameter. They are the same dictionary object.\n\nThe fix is to set the keyword argument default value to and then document the behavior in the function’s docstring.\n\nNow, running the same test code as before produces the expected result.\n• Default arguments are only evaluated once: during function definition at module load time. This can cause odd behaviors for dynamic values (like or ).\n• Use as the default value for keyword arguments that have a dynamic value. Document the actual default behavior in the function’s docstring.\n\nPassing arguments by keyword is a powerful feature of Python functions (see Item 19: “Provide Optional Behavior with Keyword Arguments”). The flexibility of keyword arguments enables you to write code that will be clear for your use cases.\n\nFor example, say you want to divide one number by another but be very careful about special cases. Sometimes you want to ignore exceptions and return infinity instead. Other times, you want to ignore exceptions and return zero instead.\n\nUsing this function is straightforward. This call will ignore the overflow from division and will return zero.\n\nThis call will ignore the error from dividing by zero and will return infinity.\n\nThe problem is that it’s easy to confuse the position of the two Boolean arguments that control the exception-ignoring behavior. This can easily cause bugs that are hard to track down. One way to improve the readability of this code is to use keyword arguments. By default, the function can be overly cautious and can always re-raise exceptions.\n\nThen callers can use keyword arguments to specify which of the ignore flags they want to flip for specific operations, overriding the default behavior.\n\nThe problem is, since these keyword arguments are optional behavior, there’s nothing forcing callers of your functions to use keyword arguments for clarity. Even with the new definition of , you can still call it the old way with positional arguments.\n\nWith complex functions like this, it’s better to require that callers are clear about their intentions. In Python 3, you can demand clarity by defining your functions with keyword-only arguments. These arguments can only be supplied by keyword, never by position.\n\nHere, I redefine the function to accept keyword-only arguments. The symbol in the argument list indicates the end of positional arguments and the beginning of keyword-only arguments.\n\nNow, calling the function with positional arguments for the keyword arguments won’t work.\n\nKeyword arguments and their default values work as expected.\n\nUnfortunately, Python 2 doesn’t have explicit syntax for specifying keyword-only arguments like Python 3. But you can achieve the same behavior of raising for invalid function calls by using the operator in argument lists. The operator is similar to the operator (see Item 18: “Reduce Visual Noise with Variable Positional Arguments”), except that instead of accepting a variable number of positional arguments, it accepts any number of keyword arguments, even when they’re not defined.\n\nTo make take keyword-only arguments in Python 2, you have the function accept . Then you keyword arguments that you expect out of the dictionary, using the method’s second argument to specify the default value when the key is missing. Finally, you make sure there are no more keyword arguments left in to prevent callers from supplying arguments that are invalid.\n\nNow, you can call the function with or without keyword arguments.\n\nTrying to pass keyword-only arguments by position won’t work, just like in Python 3.\n\nTrying to pass unexpected keyword arguments also won’t work.\n• Keyword arguments make the intention of a function call more clear.\n• Use keyword-only arguments to force callers to supply keyword arguments for potentially confusing functions, especially those that accept multiple Boolean flags.\n• Python 2 can emulate keyword-only arguments for functions by using and manually raising exceptions."
    },
    {
        "link": "https://stackoverflow.com/questions/27271876/handling-flexible-function-arguments-in-python",
        "document": "TL;TR Looking for idioms and patterns to unpack positional and keyword arguments into ordered sequence of positional arguments, based on simple specification, e.g. a list of names. The idea seems similar to scanf-like parsing.\n\nI'm wrapping functions of a Python module, called . Functions of only expect positional arguments, which are in pain numbers in most cases. I'd like to enable callers with flexibility of how they can pass arguments to my wrappers. Here are examples of the wrappers invocations I'd like to allow:\n\nI don't see any need to support convoluted case of mixed positional and keyword arguments:\n\nHere is my first stab at implementing such arguments handling for the wrapper calling :\n\nIt does the job as expected, as far as I can tell, but it there are two issues:\n• Can I do it better in more Python idiomatic fashion?\n• I have dozen(s) of functions to wrap, so how to avoid copying and adjusting the whole block between BEGIN/END marks in every wrapper?\n\nI don't know the answer for the question 1, yet.\n\nHere, however, is my attempt to address the issue 2.\n\nSo, I defined a generic handler for arguments based on the simple specification of . The specify a couple of things, depending on the actual wrapper invocation:\n• How many arguments to unpack from ? (see test below)\n• What keyword arguments are expected in ? (see generator expression returning tuple below)\n\nHere is new version:\n\nThis allows me to implement the wrapper functions in the following way:\n\nI think I have achieved all the advantages over the version above that I was looking for:\n• None Flexible protocol for positional arguments: can be called with 7, 8 and more positional arguments or a long list of numbers, but only first 6 are taken into account. For example, it would allow iterations processing long list of numbers (e.g. think of geometry coordinates):\n• Flexible protocol for keyword arguments: more keywords may be specified than actually used or dictionary can have more items than used.\n\nGetting back to the question 1 above, can I do better and make it more Pythonic?\n\nAlso, I'd like to ask for review of my solution: you see any bugs? have I overlooked anything? how to improve it?"
    },
    {
        "link": "https://medium.com/@chigwel/four-tips-for-writing-better-functions-in-python-from-pass-to-return-types-4fe247d4e323",
        "document": "In this article, we will discuss 4 tips for writing better functions in Python. These tips will help you create more efficient, readable, and maintainable code. By following these best practices, you can improve your Python programming skills and make your functions more effective.\n• Avoid using pass or ellipses as placeholders\n• Specify return types for better understanding and type checking\n• Force explicit keyword arguments and use the asterisk for variable arguments\n\n1. Avoid using pass or ellipses as placeholders\n\nWhen writing functions in Python, it can be tempting to use the pass keyword or ellipses (‘…’) as placeholders for functionality that you plan to implement later. However, this approach can lead to silent errors and make your code more difficult to debug.\n\nInstead of using pass or ellipses, it’s better to raise a NotImplementedError with a descriptive message explaining why the functionality is not implemented yet. This will make it clear to anyone reading your code that the function is not complete, and will help you avoid accidentally using it before it’s ready.\n\nFor example, instead of writing:\n\nThis will raise an error if anyone tries to call the connect() function before it’s fully implemented, making it easier to catch and fix any issues.\n\n2. Specify return types for better understanding and type checking\n\nSpecifying return types for your functions can help improve code readability and maintainability. By explicitly stating the expected return type, other developers can quickly understand the purpose of the function and what it is expected to return. Additionally, specifying return types can help catch type-related errors during development.\n\nFor example, consider the following function that retrieves user information from a database:\n\nWhile this function may work as intended, it does not provide any information about the return type. By specifying the return type, other developers can quickly understand the expected output:\n\nIn this example, we have imported the Dict type from the typing module and used it to specify that the get_users() function returns a dictionary with integer keys and string values.\n\nBy specifying return types, you can also take advantage of type checking tools like mypy to catch type-related errors before they become a problem.\n\nProviding documentation for your functions is essential for making your code more readable and maintainable. Documentation can help other developers understand the purpose of your functions, how to use them, and what they are expected to return.\n\nOne way to provide documentation for your functions is to use docstrings. Docstrings are triple-quoted strings that appear immediately after the function definition. They should provide a brief description of the function, its parameters, and its return value.\n\nFor example, consider the following function that calculates the factorial of a number:\n\nIn this example, we have used a docstring to provide a brief description of the function, its parameter, and its return value. This information can be accessed using the built-in help() function or by using a tool like Sphinx to generate documentation.\n\nAnother way to provide documentation for your functions is to use type annotations. Type annotations can help provide additional context for your functions and make it easier to understand what they are expected to do.\n\nFor example, consider the following function that takes a list of numbers and returns the sum of the even numbers:\n\nIn this example, we have used type annotations to specify that the numbers parameter is expected to be a list of integers, and that the function returns an integer. This information can be used by type checkers like mypy to catch type-related errors before they become a problem.\n\n4. Force explicit keyword arguments and use the asterisk for variable arguments\n\nForcing explicit keyword arguments can help prevent errors and make your code more readable. By requiring developers to specify the argument name when calling a function, you can ensure that they are passing the correct arguments and avoid confusion.\n\nTo force explicit keyword arguments, you can add an asterisk (*) before the argument name in the function definition. This tells Python to treat any arguments passed after the asterisk as keyword arguments.\n\nFor example, consider the following function that uploads a video to a server:\n\nIn this example, we have added an asterisk before the timeout argument to force it to be a keyword argument. This means that developers must specify the timeout argument by name when calling the function, like this:\n\nUsing the asterisk for variable arguments can also be useful when you want to allow developers to pass an arbitrary number of arguments to a function. By adding an asterisk before the argument name, you can tell Python to treat any arguments passed after the asterisk as a tuple.\n\nFor example, consider the following function that takes an arbitrary number of arguments and returns their sum:\n\nIn this example, we have added an asterisk before the args argument to tell Python to treat any arguments passed to the function as a tuple. This allows developers to pass an arbitrary number of arguments to the function, like this:"
    },
    {
        "link": "https://nobledesktop.com/learn/python/an-introduction-to-functions-in-python-enhancing-reusability",
        "document": "In this video, we're going to look at how to use the Range Function in Python"
    }
]