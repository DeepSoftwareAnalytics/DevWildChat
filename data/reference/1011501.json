[
    {
        "link": "https://reddit.com/r/godot/comments/8v2xco/introduction_to_procedural_generation_with_godot",
        "document": "The official subreddit for the Godot Engine. Meet your fellow game developers as well as engine contributors, stay up to date on Godot news, and share your projects and resources with each other. Maintained by the Godot Foundation, the non-profit taking good care of the Godot project - consider donating to https://fund.godotengine.org/ to keep us going!"
    },
    {
        "link": "https://reddit.com/r/proceduralgeneration/comments/1dhwmka/any_good_resources_for_procedural_generation_in",
        "document": "Do you have any good resources to recommend for procedural generation in godot4? I only create 2d games and the question is mainly about them.\n\nI'm thinking of creating dungeons, open maps, story, enemies, all equipment, events, economy etc.\n\nI will accept everything with open arms!"
    },
    {
        "link": "https://docs.godotengine.org/en/stable/tutorials/3d/procedural_geometry/index.html",
        "document": "There are many ways to procedurally generate geometry in Godot. In this tutorial series, we will explore a few of them. Each technique has its own benefits and drawbacks, so it is best to understand each one and how it can be useful in a given situation.\n\nMany things in Godot have mesh in their name: the Mesh, the ArrayMesh, the ImmediateMesh, the MeshInstance3D, the MultiMesh, and the MultiMeshInstance3D. While they are all related, they have slightly different uses. Meshes and ArrayMeshes are resources that are drawn using a MeshInstance3D node. Resources like Meshes and ArrayMeshes cannot be added to the scene directly. A MeshInstance3D represents one instance of a mesh in your scene. You can reuse a single mesh in multiple MeshInstance3Ds to draw it in different parts of your scene with different materials or transformations (scale, rotation, position etc.). If you are going to draw the same object many times, it can be helpful to use a MultiMesh with a MultiMeshInstance3D. MultiMeshInstance3Ds draw meshes thousands of times very cheaply by taking advantage of hardware instancing. The drawback with using a MultiMeshInstance3D is that each of your mesh's surfaces are limited to one material for all instances. It uses an instance array to store different colors and transformations for each instance, but all the instances of each surface use the same material.\n\nA Mesh is composed of one or more surfaces. A surface is an array composed of multiple sub-arrays containing vertices, normals, UVs, etc. Normally the process of constructing surfaces and meshes is hidden from the user in the RenderingServer, but with ArrayMeshes, the user can construct a Mesh manually by passing in an array containing the surface information. Each surface has its own material. Alternatively, you can override the material for all surfaces in the Mesh when you use a MeshInstance3D using the material_override property. The surface array is an array of length . Each position in the array is filled with a sub-array containing per-vertex information. For example, the array located at is a PackedVector3Array of vertex normals. See Mesh.ArrayType for more information. The surface array can be indexed or non-indexed. Creating a non-indexed array is as easy as not assigning an array at the index . A non-indexed array stores unique vertex information for every triangle, meaning that when two triangles share a vertex, the vertex is duplicated in the array. An indexed surface array only stores vertex information for each unique vertex and then also stores an array of indices which maps out how to construct the triangles from the vertex array. In general, using an indexed array is faster, but it means you have to share vertex data between triangles, which is not always desired (e.g. when you want per-face normals).\n\nWhich one should I use?ÔÉÅ Which approach you use depends on what you are trying to do and what kind of procedure you are comfortable with. Both SurfaceTool and ArrayMesh are excellent for generating static geometry (meshes) that don't change over time. Using an ArrayMesh is slightly faster than using a SurfaceTool, but the API is a little more challenging. Additionally, SurfaceTool has a few quality of life methods such as and . ImmediateMesh is more limited than both ArrayMesh and SurfaceTool. However, if you need the geometry to change every frame anyway, it provides a much easier interface that can be slightly faster than generating an ArrayMesh every frame. The MeshDataTool is not fast, but it gives you access to all kinds of properties of the mesh that you don't get with the others (edges, faces, etc.). It is incredibly useful when you need that sort of data to transform the mesh, but it is not a good idea to use it if that extra information is not needed. The MeshDataTool is best used if you are going to be using an algorithm that requires access to the face or edge array."
    },
    {
        "link": "https://docs.godotengine.org/en/3.1/tutorials/content/procedural_geometry.html",
        "document": "Users often ask how to generate geometry from code. This is not very complicated, but it‚Äôs not obvious. Godot provides a few classes entirely dedicated to make it this easy. Still, the best tool for the job depends entirely on the use case.\n\nThis is the most common helper. SurfaceTool is a class you can instantiate to generate Meshes, specifically Mesh Surfaces. It has a similar API to OpenGL 1.x, and it‚Äôs meant for static content. This means, the mesh is generated once and then used. Here is a simple example of how to use it to add a single triangle. # Call last for each vertex, adds the above attributes. Just explore the APIs and the possibilities.\n\nUnlike SurfaceTool, ImmediateGeometry is an actual node. It‚Äôs similar in the ‚ÄúOpenGL 1.x‚Äù style API, but it‚Äôs actually designed to create content on the fly and modify it every frame efficiently. Generating complex geometry (several thousand vertices) with this node is inefficient, even if it‚Äôs done only once. Instead, ImmediateGeometry is designed to generate simple geometry that changes every frame. # Call last for each vertex, adds the above attributes.\n\nLastly, the final way to do this is to create arrays themselves. This is the most efficient way to create static geometry, and is only recommended when SurfaceTool is not fast enough. Similar code as before, but draw a square using indices: # Indices are optional in Godot, but if they exist they are used."
    },
    {
        "link": "https://school.gdquest.com/products/pcg_secrets_godot_3",
        "document": "I published 6 games on Steam. All of them are made with Godot and GDQuest is my day one teacher. Thank you so much. üòÑ"
    },
    {
        "link": "https://docs.godotengine.org/en/latest/tutorials/math/random_number_generation.html",
        "document": "Checking the stable version of the documentation...\n\nThis is the latest (unstable) version of this documentation, which may document features not available in or compatible with released stable versions of Godot.\n\nMany games rely on randomness to implement core game mechanics. This page guides you through common types of randomness and how to implement them in Godot.\n\nAfter giving you a brief overview of useful functions that generate random numbers, you will learn how to get random elements from arrays, dictionaries, and how to use a noise generator in GDScript. Lastly, we'll take a look at cryptographically secure random number generation and how it differs from typical random number generation.\n\nGodot exposes two ways to generate random numbers: via global scope methods or using the RandomNumberGenerator class. Global scope methods are easier to set up, but they don't offer as much control. RandomNumberGenerator requires more code to use, but allows creating multiple instances, each with their own seed and state. This tutorial uses global scope methods, except when the method only exists in the RandomNumberGenerator class.\n\nSince Godot 4.0, the random seed is automatically set to a random value when the project starts. This means you don't need to call in anymore to ensure that results are random across project runs. However, you can still use if you want to use a specific seed number, or generate it using a different method. In global scope, you can find a randomize() method. This method should be called only once when your project starts to initialize the random seed. Calling it multiple times is unnecessary and may impact performance negatively. Putting it in your main scene script's method is a good choice: You can also set a fixed random seed instead using seed(). Doing so will give you deterministic results across runs: # To use a string as a seed, you can hash it to a number. // To use a string as a seed, you can hash it to a number. When using the RandomNumberGenerator class, you should call on the instance since it has its own seed:\n\nLet's look at some of the most commonly used functions and methods to generate random numbers in Godot. The function randi() returns a random number between and . Since the maximum value is huge, you most likely want to use the modulo operator ( ) to bound the result between 0 and the denominator: randf() returns a random floating-point number between 0 and 1. This is useful to implement a Weighted random probability system, among other things. randfn() returns a random floating-point number following a normal distribution. This means the returned value is more likely to be around the mean (0.0 by default), varying by the deviation (1.0 by default): # Prints a random floating-point number from a normal distribution with a mean 0.0 and deviation 1.0. // Prints a random floating-point number from a normal distribution with a mean 0.0 and deviation 1.0. randf_range() takes two arguments and , and returns a random floating-point number between and : randi_range() takes two arguments and , and returns a random integer between and :\n\nWe can use random integer generation to get a random element from an array, or use the Array.pick_random method to do it for us: # Pick 100 fruits randomly, this time using the `Array.pick_random()` # helper method. This has the same behavior as `get_fruit()`. # Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. # We may get the same fruit multiple times in a row. // Use Godot's Array type instead of a BCL type so we can use `PickRandom()` on it. // Pick 100 fruits randomly, this time using the `Array.PickRandom()` // helper method. This has the same behavior as `GetFruit()`. // Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. // We may get the same fruit multiple times in a row. To prevent the same fruit from being picked more than once in a row, we can add more logic to the above method. In this case, we can't use Array.pick_random since it lacks a way to prevent repetition: # The last fruit was picked. Try again until we get a different fruit. # Note: if the random element to pick is passed by reference, # such as an array or dictionary, # Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. # The function will never return the same fruit more than once in a row. // The last fruit was picked. Try again until we get a different fruit. // Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. // The function will never return the same fruit more than once in a row. This approach can be useful to make random number generation feel less repetitive. Still, it doesn't prevent results from \"ping-ponging\" between a limited set of values. To prevent this, use the shuffle bag pattern instead.\n\nThe randf() method returns a floating-point number between 0.0 and 1.0. We can use this to create a \"weighted\" probability where different outcomes have different likelihoods: You can also get a weighted random index using the rand_weighted() method on a RandomNumberGenerator instance. This returns a random integer between 0 and the size of the array that is passed as a parameter. Each value in the array is a floating-point number that represents the relative likelihood that it will be returned as an index. A higher value means the value is more likely to be returned as an index, while a value of means it will never be returned as an index. For example, if is passed as a parameter, then the method is twice as likely to return (the index of the value ) and twice as unlikely to return (the index of the value ) compared to the indices and . Since the returned value matches the array's size, it can be used as an index to get a value from another array as follows: # Prints a random element using the weighted index that is returned by `rand_weighted()`. # Here, \"apple\" will be returned twice as rarely as \"orange\" and \"pear\". # \"banana\" is twice as common as \"orange\" and \"pear\", and four times as common as \"apple\". // Prints a random element using the weighted index that is returned by `RandWeighted()`. // Here, \"apple\" will be returned twice as rarely as \"orange\" and \"pear\". // \"banana\" is twice as common as \"orange\" and \"pear\", and four times as common as \"apple\".\n\nTaking the same example as above, we would like to pick fruits at random. However, relying on random number generation every time a fruit is selected can lead to a less uniform distribution. If the player is lucky (or unlucky), they could get the same fruit three or more times in a row. You can accomplish this using the shuffle bag pattern. It works by removing an element from the array after choosing it. After multiple selections, the array ends up empty. When that happens, you reinitialize it to its default value: # A copy of the fruits array so we can restore the original value into `fruits`. # Fill the fruits array again and shuffle it. # Get a random fruit, since we shuffled the array, # and remove it from the `_fruits` array. # Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs, removing it from the array. # When all fruit are removed, it refills the array. // A copy of the fruits array so we can restore the original value into `fruits`. // Fill the fruits array again and shuffle it. // Get a random fruit, since we shuffled the array, // and remove it from the `_fruits` array. // Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs, removing it from the array. // When all fruit are removed, it refills the array. When running the above code, there is a chance to get the same fruit twice in a row. Once we picked a fruit, it will no longer be a possible return value unless the array is now empty. When the array is empty, we reset it back to its default value, making it possible to have the same fruit again, but only once.\n\nSo far, the approaches mentioned above are not suitable for cryptographically secure pseudorandom number generation (CSPRNG). This is fine for games, but this is not sufficient for scenarios where encryption, authentication or signing is involved. Godot offers a Crypto class for this. This class can perform asymmetric key encryption/decryption, signing/verification, while also generating cryptographically secure random bytes, RSA keys, HMAC digests, and self-signed X509Certificates. The downside of is that it's much slower than standard pseudorandom number generation. Its API is also less convenient to use. As a result, should be avoided for gameplay elements. Example of using the Crypto class to generate 2 random integers between and (inclusive): # Request as many bytes as you need, but try to minimize the amount # Each 32-bit integer requires 4 bytes, so we request 8 bytes. # Use the ``decode_u32()`` method from PackedByteArray to decode a 32-bit unsigned integer # from the beginning of `byte_array`. This method doesn't modify `byte_array`. # Do the same as above, but with an offset of 4 bytes since we've already decoded See PackedByteArray's documentation for other methods you can use to decode the generated bytes into various types of data, such as integers or floats."
    },
    {
        "link": "https://docs.godotengine.org/en/stable/classes/class_randomnumbergenerator.html",
        "document": "To generate a random float number (within a given range) based on a time-dependent seed:\n\nNote: The underlying algorithm is an implementation detail and should not be depended upon.\n\nRandomNumberGenerator is a class for generating pseudo-random numbers. It currently uses PCG32 .\n\nInitializes the random number generator state based on the given seed value. A given seed will give a reproducible sequence of pseudo-random numbers.\n\nNote: The RNG does not have an avalanche effect, and can output similar random streams given similar seeds. Consider using a hash function to improve your seed quality if they're sourced externally.\n\nNote: Setting this property produces a side effect of changing the internal state, so make sure to initialize the seed before modifying the state:\n\nNote: The default value of this property is pseudo-random, and changes when calling randomize(). The value documented here is a placeholder, and not the actual default seed.\n\nThe current state of the random number generator. Save and restore this property to restore the generator to a previous state:\n\nNote: Do not set state to arbitrary values, since the random number generator requires the state to have certain qualities to behave properly. It should only be set to values that came from the state property itself. To initialize the random number generator with arbitrary input, use seed instead.\n\nNote: The default value of this property is pseudo-random, and changes when calling randomize(). The value documented here is a placeholder, and not the actual default seed."
    },
    {
        "link": "https://docs.godotengine.org/en/4.3/tutorials/math/random_number_generation.html",
        "document": "This page is up to date for Godot 4.3 . If you still find outdated information, please open an issue .\n\nMany games rely on randomness to implement core game mechanics. This page guides you through common types of randomness and how to implement them in Godot.\n\nAfter giving you a brief overview of useful functions that generate random numbers, you will learn how to get random elements from arrays, dictionaries, and how to use a noise generator in GDScript. Lastly, we'll take a look at cryptographically secure random number generation and how it differs from typical random number generation.\n\nGodot exposes two ways to generate random numbers: via global scope methods or using the RandomNumberGenerator class. Global scope methods are easier to set up, but they don't offer as much control. RandomNumberGenerator requires more code to use, but allows creating multiple instances, each with their own seed and state. This tutorial uses global scope methods, except when the method only exists in the RandomNumberGenerator class.\n\nSince Godot 4.0, the random seed is automatically set to a random value when the project starts. This means you don't need to call in anymore to ensure that results are random across project runs. However, you can still use if you want to use a specific seed number, or generate it using a different method. In global scope, you can find a randomize() method. This method should be called only once when your project starts to initialize the random seed. Calling it multiple times is unnecessary and may impact performance negatively. Putting it in your main scene script's method is a good choice: You can also set a fixed random seed instead using seed(). Doing so will give you deterministic results across runs: # To use a string as a seed, you can hash it to a number. // To use a string as a seed, you can hash it to a number. When using the RandomNumberGenerator class, you should call on the instance since it has its own seed:\n\nLet's look at some of the most commonly used functions and methods to generate random numbers in Godot. The function randi() returns a random number between and . Since the maximum value is huge, you most likely want to use the modulo operator ( ) to bound the result between 0 and the denominator: randf() returns a random floating-point number between 0 and 1. This is useful to implement a Weighted random probability system, among other things. randfn() returns a random floating-point number following a normal distribution. This means the returned value is more likely to be around the mean (0.0 by default), varying by the deviation (1.0 by default): # Prints a random floating-point number from a normal distribution with a mean 0.0 and deviation 1.0. // Prints a random floating-point number from a normal distribution with a mean of 0.0 and deviation of 1.0. randf_range() takes two arguments and , and returns a random floating-point number between and : randi_range() takes two arguments and , and returns a random integer between and :\n\nWe can use random integer generation to get a random element from an array, or use the Array.pick_random method to do it for us: # Pick 100 fruits randomly, this time using the `Array.pick_random()` # helper method. This has the same behavior as `get_fruit()`. # Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. # We may get the same fruit multiple times in a row. // Use Godot's Array type instead of a BCL type so we can use `PickRandom()` on it. // Pick 100 fruits randomly, this time using the `Array.PickRandom()` // helper method. This has the same behavior as `GetFruit()`. // Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. // We may get the same fruit multiple times in a row. To prevent the same fruit from being picked more than once in a row, we can add more logic to the above method. In this case, we can't use Array.pick_random since it lacks a way to prevent repetition: # The last fruit was picked. Try again until we get a different fruit. # Note: if the random element to pick is passed by reference, # such as an array or dictionary, # Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. # The function will never return the same fruit more than once in a row. // The last fruit was picked. Try again until we get a different fruit. // Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. // The function will never return the same fruit more than once in a row. This approach can be useful to make random number generation feel less repetitive. Still, it doesn't prevent results from \"ping-ponging\" between a limited set of values. To prevent this, use the shuffle bag pattern instead.\n\nThe randf() method returns a floating-point number between 0.0 and 1.0. We can use this to create a \"weighted\" probability where different outcomes have different likelihoods: You can also get a weighted random index using the rand_weighted() method on a RandomNumberGenerator instance. This returns a random integer between 0 and the size of the array that is passed as a parameter. Each value in the array is a floating-point number that represents the relative likelihood that it will be returned as an index. A higher value means the value is more likely to be returned as an index, while a value of means it will never be returned as an index. For example, if is passed as a parameter, then the method is twice as likely to return (the index of the value ) and twice as unlikely to return (the index of the value ) compared to the indices and . Since the returned value matches the array's size, it can be used as an index to get a value from another array as follows: # Prints a random element using the weighted index that is returned by `rand_weighted()`. # Here, \"apple\" will be returned twice as rarely as \"orange\" and \"pear\". # \"banana\" is twice as common as \"orange\" and \"pear\", and four times as common as \"apple\". // Prints a random element using the weighted index that is returned by `RandWeighted()`. // Here, \"apple\" will be returned twice as rarely as \"orange\" and \"pear\". // \"banana\" is twice as common as \"orange\" and \"pear\", and four times as common as \"apple\".\n\nTaking the same example as above, we would like to pick fruits at random. However, relying on random number generation every time a fruit is selected can lead to a less uniform distribution. If the player is lucky (or unlucky), they could get the same fruit three or more times in a row. You can accomplish this using the shuffle bag pattern. It works by removing an element from the array after choosing it. After multiple selections, the array ends up empty. When that happens, you reinitialize it to its default value: # A copy of the fruits array so we can restore the original value into `fruits`. # Fill the fruits array again and shuffle it. # Get a random fruit, since we shuffled the array, # and remove it from the `_fruits` array. # Prints \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. When running the above code, there is a chance to get the same fruit twice in a row. Once we picked a fruit, it will no longer be a possible return value unless the array is now empty. When the array is empty, we reset it back to its default value, making it possible to have the same fruit again, but only once.\n\nSo far, the approaches mentioned above are not suitable for cryptographically secure pseudorandom number generation (CSPRNG). This is fine for games, but this is not sufficient for scenarios where encryption, authentication or signing is involved. Godot offers a Crypto class for this. This class can perform asymmetric key encryption/decryption, signing/verification, while also generating cryptographically secure random bytes, RSA keys, HMAC digests, and self-signed X509Certificates. The downside of is that it's much slower than standard pseudorandom number generation. Its API is also less convenient to use. As a result, should be avoided for gameplay elements. Example of using the Crypto class to generate 2 random integers between and (inclusive): # Request as many bytes as you need, but try to minimize the amount # Each 32-bit integer requires 4 bytes, so we request 8 bytes. # Use the ``decode_u32()`` method from PackedByteArray to decode a 32-bit unsigned integer # from the beginning of `byte_array`. This method doesn't modify `byte_array`. # Do the same as above, but with an offset of 4 bytes since we've already decoded See PackedByteArray's documentation for other methods you can use to decode the generated bytes into various types of data, such as integers or floats."
    },
    {
        "link": "https://docs.godot.community/tutorials/math/random_number_generation.html",
        "document": "Many games rely on randomness to implement core game mechanics. This page guides you through common types of randomness and how to implement them in Godot.\n\nAfter giving you a brief overview of useful functions that generate random numbers, you will learn how to get random elements from arrays, dictionaries, and how to use a noise generator in GDScript.\n\nGodot exposes two ways to generate random numbers: via global scope methods or using the RandomNumberGenerator class. Global scope methods are easier to set up, but they don't offer as much control. RandomNumberGenerator requires more code to use, but allows creating multiple instances, each with their own seed and state. This tutorial uses global scope methods, except when the method only exists in the RandomNumberGenerator class.\n\nIn global scope, you can find a randomize() method. This method should be called only once when your project starts to initialize the random seed. Calling it multiple times is unnecessary and may impact performance negatively. Putting it in your main scene script's method is a good choice: You can also set a fixed random seed instead using seed(). Doing so will give you deterministic results across runs: # To use a string as a seed, you can hash it to a number. When using the RandomNumberGenerator class, you should call on the instance since it has its own seed:\n\nLet's look at some of the most commonly used functions and methods to generate random numbers in Godot. The function randi() returns a random number between 0 and 2^32-1. Since the maximum value is huge, you most likely want to use the modulo operator ( ) to bound the result between 0 and the denominator: randf() returns a random floating-point number between 0 and 1. This is useful to implement a Weighted random probability system, among other things. randfn() returns a random floating-point number following a normal distribution. This means the returned value is more likely to be around the mean (0.0 by default), varying by the deviation (1.0 by default): # Prints a random floating-point number from a normal distribution with a mean 0.0 and deviation 1.0. // Prints a normally distributed floating-point number between 0.0 and 1.0. randf_range() takes two arguments and , and returns a random floating-point number between and : RandomNumberGenerator.randi_range() takes two arguments and , and returns a random integer between and :\n\nWe can use random integer generation to get a random element from an array: # Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. # We may get the same fruit multiple times in a row. // Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. // We may get the same fruit multiple times in a row. To prevent the same fruit from being picked more than once in a row, we can add more logic to this method: # The last fruit was picked, try again until we get a different fruit. # Note: if the random element to pick is passed by reference, # such as an array or dictionary, # Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. # The function will never return the same fruit more than once in a row. // The last fruit was picked, try again until we get a different fruit. // Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. // The function will never return the same fruit more than once in a row. This approach can be useful to make random number generation feel less repetitive. Still, it doesn't prevent results from \"ping-ponging\" between a limited set of values. To prevent this, use the shuffle bag pattern instead.\n\nTaking the same example as above, we would like to pick fruits at random. However, relying on random number generation every time a fruit is selected can lead to a less uniform distribution. If the player is lucky (or unlucky), they could get the same fruit three or more times in a row. You can accomplish this using the shuffle bag pattern. It works by removing an element from the array after choosing it. After multiple selections, the array ends up empty. When that happens, you reinitialize it to its default value: # A copy of the fruits array so we can restore the original value into `fruits`. # Fill the fruits array again and shuffle it. # Get a random fruit, since we shuffled the array, # and remove it from the `_fruits` array. # Prints \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. When running the above code, there is a chance to get the same fruit twice in a row. Once we picked a fruit, it will no longer be a possible return value unless the array is now empty. When the array is empty, we reset it back to its default value, making it possible to have the same fruit again, but only once.\n\nThe random number generation shown above can show its limits when you need a value that slowly changes depending on the input. The input can be a position, time, or anything else. To achieve this, you can use random noise functions. Noise functions are especially popular in procedural generation to generate realistic-looking terrain. Godot provides FastNoiseLite for this, which supports 1D, 2D and 3D noise. Here's an example with 1D noise:"
    },
    {
        "link": "https://docs.godotengine.org/en/3.5/tutorials/math/random_number_generation.html",
        "document": "Many games rely on randomness to implement core game mechanics. This page guides you through common types of randomness and how to implement them in Godot.\n\nAfter giving you a brief overview of useful functions that generate random numbers, you will learn how to get random elements from arrays, dictionaries, and how to use a noise generator in GDScript.\n\nGodot exposes two ways to generate random numbers: via global scope methods or using the RandomNumberGenerator class. Global scope methods are easier to set up, but they don't offer as much control. RandomNumberGenerator requires more code to use, but exposes many methods not found in global scope such as randi_range() and randfn(). On top of that, it allows creating multiple instances each with their own seed. This tutorial uses global scope methods, except when the method only exists in the RandomNumberGenerator class.\n\nIn global scope, you can find a randomize() method. This method should be called only once when your project starts to initialize the random seed. Calling it multiple times is unnecessary and may impact performance negatively. Putting it in your main scene script's method is a good choice: You can also set a fixed random seed instead using seed(). Doing so will give you deterministic results across runs: # To use a string as a seed, you can hash it to a number. When using the RandomNumberGenerator class, you should call on the instance since it has its own seed:\n\nLet's look at some of the most commonly used functions and methods to generate random numbers in Godot. The function randi() returns a random number between 0 and 2^32-1. Since the maximum value is huge, you most likely want to use the modulo operator ( ) to bound the result between 0 and the denominator: randf() returns a random floating-point number between 0 and 1. This is useful to implement a Weighted random probability system, among other things. randfn() returns a random floating-point number following a normal distribution. This means the returned value is more likely to be around the mean (0.0 by default), varying by the deviation (1.0 by default): # Prints a random floating-point number from a normal distribution with a mean 0.0 and deviation 1.0. // Prints a normally distributed floating-point number between 0.0 and 1.0. rand_range() takes two arguments and , and returns a random floating-point number between and : RandomNumberGenerator.randi_range() takes two arguments and , and returns a random integer between and :\n\nWe can use random integer generation to get a random element from an array: # Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. # We may get the same fruit multiple times in a row. // Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. // We may get the same fruit multiple times in a row. To prevent the same fruit from being picked more than once in a row, we can add more logic to this method: # The last fruit was picked, try again until we get a different fruit. # Note: if the random element to pick is passed by reference, # such as an array or dictionary, # Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. # The function will never return the same fruit more than once in a row. // The last fruit was picked, try again until we get a different fruit. // Returns \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. // The function will never return the same fruit more than once in a row. This approach can be useful to make random number generation feel less repetitive. Still, it doesn't prevent results from \"ping-ponging\" between a limited set of values. To prevent this, use the shuffle bag pattern instead.\n\nTaking the same example as above, we would like to pick fruits at random. However, relying on random number generation every time a fruit is selected can lead to a less uniform distribution. If the player is lucky (or unlucky), they could get the same fruit three or more times in a row. You can accomplish this using the shuffle bag pattern. It works by removing an element from the array after choosing it. After multiple selections, the array ends up empty. When that happens, you reinitialize it to its default value: # A copy of the fruits array so we can restore the original value into `fruits`. # Fill the fruits array again and shuffle it. # Get a random fruit, since we shuffled the array, # and remove it from the `_fruits` array. # Prints \"apple\", \"orange\", \"pear\", or \"banana\" every time the code runs. When running the above code, there is a chance to get the same fruit twice in a row. Once we picked a fruit, it will no longer be a possible return value unless the array is now empty. When the array is empty, we reset it back to its default value, making it possible to have the same fruit again, but only once.\n\nThe random number generation shown above can show its limits when you need a value that slowly changes depending on the input. The input can be a position, time, or anything else. To achieve this, you can use random noise functions. Noise functions are especially popular in procedural generation to generate realistic-looking terrain. Godot provides OpenSimplexNoise for this, which supports 1D, 2D, 3D, and 4D noise. Here's an example with 1D noise:"
    }
]