[
    {
        "link": "https://processing.org/reference",
        "document": "\n• break Ends the execution of a structure such as switch, for, or while and jumps to the next statement after\n• case Denotes the different names to be evaluated with the parameter in the switch structure\n• ?: (conditional) A shortcut for writing an if and else structure\n• continue When run inside of a for or while, it skips the remainder of the block and starts the next iteration\n• default Keyword for defining the default condition of a switch\n• else Extends the if structure allowing the program to choose between two or more blocks of code\n• if Allows the program to make a decision about which code to execute\n• switch Works like an if else structure, but switch is more convenient when you need to select between three or more alternatives\n• cursor() Sets the cursor to a predefined symbol, an image, or makes it visible if already hidden\n• delay() The delay() function causes the program to halt for a specified time\n• displayDensity() Returns \"2\" if the screen is high-density and \"1\" if not\n• displayHeight Variable that stores the height of the computer screen\n• displayWidth Variable that stores the width of the computer screen\n• frameCount The system variable that contains the number of frames displayed since the program started\n• frameRate The system variable that contains the approximate frame rate of the software as it executes\n• frameRate() Specifies the number of frames to be displayed every second\n• fullScreen() Opens a sketch using the full size of the computer's display\n• height System variable which stores the height of the display window\n• noSmooth() Draws all geometry and fonts with jagged (aliased) edges and images with hard edges between the pixels when enlarged rather than interpolating pixels\n• pixelDensity() It makes it possible for Processing to render using all the pixels on high resolutions screens\n• pixelHeight The actual pixel height when using high resolution display\n• pixelWidth The actual pixel width when using high resolution display\n• settings() Used when absolutely necessary to define the parameters to size() with a variable\n• size() Defines the dimension of the display window in units of pixels\n• width System variable which stores the width of the display window\n• windowMove() The windowMove() function defines the position of the Processing sketch in relation to the upper-left corner of the computer screen\n• windowMoved() Called every time the sketch window is moved\n• windowRatio() Scale the sketch as if it fit a specific width and height\n• windowResizable() Define whether the sketch window can be resized while it's running\n• windowResize() The windowResize() function defines the size of the sketch window\n• windowResized() Called every time the sketch window is resized\n• windowTitle() The windowTitle() function defines the title to appear at the top of the sketch window"
    },
    {
        "link": "https://processing.org/examples/loop.html",
        "document": ""
    },
    {
        "link": "https://web.engr.oregonstate.edu/~mjb/cs419ab/Handouts/processing_cheat_sheet_english.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/42796405/for-loop-drawing-pgraphics-in-an-array-processing",
        "document": "I'm trying to build a Drawing Program using Processing. I am currently stuck on using .\n\nWhen the user draws a rectangle, it shows the shape being drawn. When the user releases their mouse, it then creates a of the final shape. I would then like the user to draw on top of that. Here is my problem:\n\nI had to reset the background of the canvas when drawing a rectangle because otherwise, it shows a trail of rectangles. The result is that while the user draws a new rectangle the old ones disappear and come back once the mouse has been releasd\n\nSome thoughts: I would also like to add features where the user can select on a previously drawn rectangle and change it's colour, stroke, send to back, bring to front etc..\n\nTo achieve this, I'm storing all drawn rectangles (PGraphics) into an which will be drawn via a for loop. This will allow me to adjust the behaviour by moving the elements up and down the .\n\nPS: Instead of creating my own class of am I better off using PShape?\n\nHere is the Class:"
    },
    {
        "link": "https://docs.nvidia.com/cuda/cuda-c-programming-guide",
        "document": "The programming guide to the CUDA model and interface."
    },
    {
        "link": "https://processing.org/reference/beginshape_",
        "document": ""
    },
    {
        "link": "https://processing.org/reference/createshape_",
        "document": ""
    },
    {
        "link": "https://p5js.org/reference/p5/beginShape",
        "document": "The and endShape() functions allow for creating custom shapes in 2D or 3D. begins adding vertices to a custom shape and endShape() stops adding them.\n\nThe parameter, , sets the kind of shape to make. By default, any irregular polygon can be drawn. The available modes for kind are:\n• to draw a series of connected triangles sharing the first vertex in a fan-like fashion.\n• to draw a series of connected triangles in strip fashion.\n• to draw quad strip using adjacent edges to form the next quad.\n• to create a filling curve by explicit tessellation (WebGL only).\n\nAfter calling , shapes can be built by calling vertex(), bezierVertex(), quadraticVertex(), and/or curveVertex(). Calling endShape() will stop adding vertices to the shape. Each shape will be outlined with the current stroke color and filled with the current fill color.\n\nTransformations such as translate(), rotate(), and scale() don't work between and endShape(). It's also not possible to use other shapes, such as ellipse() or rect(), between and endShape()."
    },
    {
        "link": "https://thecodingtrain.com/tracks/p5-tips-and-tricks/more-p5/custom-shapes",
        "document": "The Showcase is collection of projects created by viewers like you! Have you made something? Please share your work!"
    },
    {
        "link": "https://programmingdesignsystems.com/shape/custom-shapes/index.html",
        "document": "Although it is a good exercise to design only with simple shapes, complex shapes offer more possibilities. In a manual design process, complex shapes often take a long time to draw, as every detail of a design will need to be created by hand. Although efforts have been made to automate such tasks, some designs are still tedious to create in current digital design tools like Adobe Illustrator or Sketch. This is particularly true for designs that require the use of repetition or randomization, like a pattern of Sine curves with changing amplitudes. In code, we have the ability to procedurally generate very complex shapes in an instant, and the code required can be quite simple. On the other hand, shapes drawn randomly with a pen can be hard to recreate in code, especially if there is no underlying rule to explain the outline of the shape.\n\nIn the following chapters, I will introduce a range of techniques to procedurally draw custom shapes. However, we must first understand the basic concepts of drawing shapes in code, which means looking at the function, as well as the many vertex functions that can be used to define the outline of a shape.\n\nMost graphics programming languages allow you to draw custom shapes like a Connect the Dots drawing: You define a series of points – which we will refer to as vertices – that are connected via lines to form the outline of a shape. Each vertex in a shape determines how it is connected to the vertex before it. If it is a simple vertex, it will be connected with a straight line. If it is a curved vertex, it will be connected with a curved line. The shape can optionally become a closed shape by connecting the last vertex to the first vertex. P5.js follows this same concept. Use the function to start a new custom shape, define the vertices of the shape with the desired vertex functions, and finally connect the lines in the shape by calling the function with an optional argument to close the shape. In the following, we will examine these vertex functions.\n\nThe function creates a simple vertex that connects to the vertex before it with a straight line. This is the simplest of the vertex functions, and all shapes created with must start with a function call to define the starting point of the shape. This is illustrated in the example below. Try dragging the vertices to see the resulting code. The following examples are all created with simple vertices, but use strokes and fills to achieve very different designs.\n\nTo create a vertex that is connected to the vertex before it with a curved line, we use the and functions. These are a bit more complex than the function, because they need several and coordinates to control the curve of the line. To understand how this works, let us have a brief look at the concept of Bézier curves. The Bézier curve algorithm was popularized by Pierre Bézier in the 1960’s as a solution to a common problem in computational geometry: Drawing curved lines that can scale to any size. The Bézier curve algorithm solves this problem in a very elegant way by introducing the idea of control points: Invisible gravity points that attract the line to bend it into a curve. A Bézier curve with a single control point is called a quadratic Bézier, while a Bézier curve with two control points is called a cubic Bézier. If you have ever used the Pen tool in Adobe Illustrator, you are already familiar with this concept. This animation shows how a quadratic Bézier curve is calculated. This animation shows how a cubic Bézier curve is calculated. You can draw a quadratic bezier curve with the function, passing the coordinates for the single control point and the vertex itself. Likewise, you can draw a cubic Bézier curve with the function, passing coordinates for the two control points and the vertex itself. The only difference between the two functions is the addition of an extra control point in the function, which allows you to draw more sophisticated curves. This is illustrated below where both types of curves are used to draw a custom shape. Try dragging the vertices and control points to see the resulting code. It takes a bit of practice to master the Bézier functions, and knowing how many Béziers you need to draw a specific shape can be hard in the beginning. It does not help that control points are invisible, so it can be helpful to spend some time playing around with the example above before diving into the code. Below are three examples that all use the Bézier functions to create custom shapes.\n\nWhile we can draw most shapes with , , and , these functions won't allow us to create shapes with holes. In P5.js, a hole is called a contour, and you can draw shapes with contours using the and functions. In essence, the function instructs P5 that you are starting a new shape that will be subtracted from your main shape. Like , you use the vertex functions to draw your contour, and use to end the contour.\n\nYou can practice designing custom shapes by continuing the ‘design a word’ exercise from the previous chapters. My assignment to students sound something like this: Make a design with two shapes in black and white that represents the words ‘wet’ and ‘sharp’. There are several reasons why this is a challenging assignment. First of all, the student has to consider how the outline of a shape can help communicate either of those words. Most designs end up using curved vertices to represent wet and simple vertices to represent sharp, but some designs cleverly achieve the goal by doing the opposite. Also, the fact that these shapes exist in the same canvas encourages the student to consider how the shapes can interact with each other to achieve a more dramatic effect. Pointing a knife-like shape directly at a smooth shape will create a certain tension which would not exist if the shape pointed in the other direction.\n\nThe examples in this chapter have a lot of vertices meticulously defined in code, exactly like you would draw them with the mouse. This is of course not the ultimate promise of algorithmic design. Why make shapes in code when they are faster to draw with a mouse? In the following chapters, we will look at a number of techniques that can be used to draw shapes in a more procedural way."
    }
]