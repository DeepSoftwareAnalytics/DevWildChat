[
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa",
        "document": "Installs an application-defined hook procedure into a hook chain. You would install a hook procedure to monitor the system for certain types of events. These events are associated either with a specific thread or with all threads in the same desktop as the calling thread.\n\nThe type of hook procedure to be installed. This parameter can be one of the following values.\n\nInstalls a hook procedure that monitors messages before the system sends them to the destination window procedure. For more information, see the CallWndProc hook procedure. Installs a hook procedure that monitors messages after they have been processed by the destination window procedure. For more information, see the [HOOKPROC callback function](nc-winuser-hookproc.md) hook procedure. Installs a hook procedure that receives notifications useful to a CBT application. For more information, see the [CBTProc](/windows/win32/winmsg/cbtproc) hook procedure. Installs a hook procedure useful for debugging other hook procedures. For more information, see the DebugProc hook procedure. Installs a hook procedure that will be called when the application's foreground thread is about to become idle. This hook is useful for performing low priority tasks during idle time. For more information, see the ForegroundIdleProc hook procedure. Installs a hook procedure that monitors messages posted to a message queue. For more information, see the GetMsgProc hook procedure. Windows 11 and newer: Journaling hook APIs are not supported. We recommend using the SendInput TextInput API instead. Installs a hook procedure that posts messages previously recorded by a WH_JOURNALRECORD hook procedure. For more information, see the JournalPlaybackProc hook procedure. Windows 11 and newer: Journaling hook APIs are not supported. We recommend using the SendInput TextInput API instead. Installs a hook procedure that records input messages posted to the system message queue. This hook is useful for recording macros. For more information, see the JournalRecordProc hook procedure. Installs a hook procedure that monitors keystroke messages. For more information, see the KeyboardProc hook procedure. Installs a hook procedure that monitors low-level keyboard input events. For more information, see the LowLevelKeyboardProc hook procedure. Installs a hook procedure that monitors mouse messages. For more information, see the MouseProc hook procedure. Installs a hook procedure that monitors low-level mouse input events. For more information, see the LowLevelMouseProc hook procedure. Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar. For more information, see the MessageProc hook procedure. Installs a hook procedure that receives notifications useful to shell applications. For more information, see the [ShellProc](/windows/win32/winmsg/shellproc) hook procedure. Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar. The hook procedure monitors these messages for all applications in the same desktop as the calling thread. For more information, see the SysMsgProc hook procedure.\n\nA pointer to the hook procedure. If the dwThreadId parameter is zero or specifies the identifier of a thread created by a different process, the lpfn parameter must point to a hook procedure in a DLL. Otherwise, lpfn can point to a hook procedure in the code associated with the current process.\n\nA handle to the DLL containing the hook procedure pointed to by the lpfn parameter. The hMod parameter must be set to NULL if the dwThreadId parameter specifies a thread created by the current process and if the hook procedure is within the code associated with the current process.\n\nThe identifier of the thread with which the hook procedure is to be associated. For desktop apps, if this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread. For Windows Store apps, see the Remarks section.\n\nIf the function succeeds, the return value is the handle to the hook procedure.\n\nIf the function fails, the return value is NULL. To get extended error information, call GetLastError.\n\nSetWindowsHookEx can be used to inject a DLL into another process. A 32-bit DLL cannot be injected into a 64-bit process, and a 64-bit DLL cannot be injected into a 32-bit process. If an application requires the use of hooks in other processes, it is required that a 32-bit application call SetWindowsHookEx to inject a 32-bit DLL into 32-bit processes, and a 64-bit application call SetWindowsHookEx to inject a 64-bit DLL into 64-bit processes. The 32-bit and 64-bit DLLs must have different names.\n\nBecause hooks run in the context of an application, they must match the \"bitness\" of the application. If a 32-bit application installs a global hook on 64-bit Windows, the 32-bit hook is injected into each 32-bit process (the usual security boundaries apply). In a 64-bit process, the threads are still marked as \"hooked.\" However, because a 32-bit application must run the hook code, the system executes the hook in the hooking app's context; specifically, on the thread that called SetWindowsHookEx. This means that the hooking application must continue to pump messages or it might block the normal functioning of the 64-bit processes.\n\nIf a 64-bit application installs a global hook on 64-bit Windows, the 64-bit hook is injected into each 64-bit process, while all 32-bit processes use a callback to the hooking application.\n\nTo hook all applications on the desktop of a 64-bit Windows installation, install a 32-bit global hook and a 64-bit global hook, each from appropriate processes, and be sure to keep pumping messages in the hooking application to avoid blocking normal functioning. If you already have a 32-bit global hooking application and it doesn't need to run in each application's context, you may not need to create a 64-bit version.\n\nAn error may occur if the hMod parameter is NULL and the dwThreadId parameter is zero or specifies the identifier of a thread created by another process.\n\nCalling the CallNextHookEx function function to chain to the next hook procedure is optional, but it is highly recommended; otherwise, other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result. You should call CallNextHookEx unless you absolutely need to prevent the notification from being seen by other applications.\n\nBefore terminating, an application must call the UnhookWindowsHookEx function function to free system resources associated with the hook.\n\nThe scope of a hook depends on the hook type. Some hooks can be set only with global scope; others can also be set for only a specific thread, as shown in the following table.\n\nFor a specified hook type, thread hooks are called first, then global hooks. Be aware that the WH_MOUSE, WH_KEYBOARD, WH_JOURNAL*, WH_SHELL, and low-level hooks can be called on the thread that installed the hook rather than the thread processing the hook. For these hooks, it is possible that both the 32-bit and 64-bit hooks will be called if a 32-bit hook is ahead of a 64-bit hook in the hook chain.\n\nThe global hooks are a shared resource, and installing one affects all applications in the same desktop as the calling thread. All global hook functions must be in libraries. Global hooks should be restricted to special-purpose applications or to use as a development aid during application debugging. Libraries that no longer need a hook should remove its hook procedure.\n\nWindows Store app development If dwThreadId is zero, then window hook DLLs are not loaded in-process for the Windows Store app processes and the Windows Runtime broker process unless they are installed by either UIAccess processes (accessibility tools). The notification is delivered on the installer's thread for these hooks:\n\nThis behavior is similar to what happens when there is an architecture mismatch between the hook DLL and the target application process, for example, when the hook DLL is 32-bit and the application process 64-bit.\n\nFor an example, see Installing and Releasing Hook Procedures."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/winmsg/using-hooks",
        "document": "The following code examples demonstrate how to perform the following tasks associated with hooks:\n\nYou can install a hook procedure by calling the SetWindowsHookEx function and specifying the type of hook calling the procedure, whether the procedure should be associated with all threads in the same desktop as the calling thread or with a particular thread, and a pointer to the procedure entry point.\n\nYou must place a global hook procedure in a DLL separate from the application installing the hook procedure. The installing application must have the handle to the DLL module before it can install the hook procedure. To retrieve a handle to the DLL module, call the LoadLibrary function with the name of the DLL. After you have obtained the handle, you can call the GetProcAddress function to retrieve a pointer to the hook procedure. Finally, use SetWindowsHookEx to install the hook procedure address in the appropriate hook chain. SetWindowsHookEx passes the module handle, a pointer to the hook-procedure entry point, and 0 for the thread identifier, indicating that the hook procedure should be associated with all threads in the same desktop as the calling thread. This sequence is shown in the following example.\n\nYou can release a thread-specific hook procedure (remove its address from the hook chain) by calling the UnhookWindowsHookEx function, specifying the handle to the hook procedure to release. Release a hook procedure as soon as your application no longer needs it.\n\nYou can release a global hook procedure by using UnhookWindowsHookEx, but this function does not free the DLL containing the hook procedure. This is because global hook procedures are called in the process context of every application in the desktop, causing an implicit call to the LoadLibrary function for all of those processes. Because a call to the FreeLibrary function cannot be made for another process, there is then no way to free the DLL. The system eventually frees the DLL after all processes explicitly linked to the DLL have either terminated or called FreeLibrary and all processes that called the hook procedure have resumed processing outside the DLL.\n\nAn alternative method for installing a global hook procedure is to provide an installation function in the DLL, along with the hook procedure. With this method, the installing application does not need the handle to the DLL module. By linking with the DLL, the application gains access to the installation function. The installation function can supply the DLL module handle and other details in the call to SetWindowsHookEx. The DLL can also contain a function that releases the global hook procedure; the application can call this hook-releasing function when terminating.\n\nThe following example uses a variety of thread-specific hook procedures to monitor the system for events affecting a thread. It demonstrates how to process events for the following types of hook procedures:\n\nThe user can install and remove a hook procedure by using the menu. When a hook procedure is installed and an event that is monitored by the procedure occurs, the procedure writes information about the event to the client area of the application's main window."
    },
    {
        "link": "https://stackoverflow.com/questions/5931864/documentation-of-setwindowshookex-question",
        "document": "The Windows API documentation explains all the arguments better than anyone here can: http://msdn.microsoft.com/en-us/library/ms644990(v=vs.85).aspx\n\nThe second argument is either NULL or a pointer to an HOOKPROC. Note that \"If the dwThreadId parameter is zero or specifies the identifier of a thread created by a different process, the lpfn parameter must point to a hook procedure in a DLL. Otherwise, lpfn can point to a hook procedure in the code associated with the current process.\" Here is an example HOOKPROC from MSDN:\n\nThe third argument must be \"set to NULL if the dwThreadId parameter specifies a thread created by the current process and if the hook procedure is within the code associated with the current process.\n\nThe fourth is \"The identifier of the thread with which the hook procedure is to be associated. If this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread.\""
    },
    {
        "link": "https://stackoverflow.com/questions/214022/how-to-correctly-use-setwindowshookex-callnexthookex",
        "document": "I can correctly setup up a windows hook, but I get confused by the line in MSDN that says \"Calling the CallNextHookEx function to chain to the next hook procedure is optional, but it is highly recommended; otherwise, other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result. You should call CallNextHookEx unless you absolutely need to prevent the notification from being seen by other applications.\".\n\nI want to be a good programming citizen and call the next hook. But, my hook procedure looks like this:\n\nSo, what happens in the hook procedure if the code isn't the one I'm interested in? How do I call the next hook?\n\nEdit: The main problem is that a HHOOK is returned from the SetWindowsHookEx, and that needs to be passed to the CallNextHookEx function.\n\nUpdate: It seems the hook parameter is ignored on the NT platforms:\n\n http://msdn.microsoft.com/en-us/library/ms644974.aspx\n\n http://www.klenotic.com/pl/null_hhook/"
    },
    {
        "link": "https://github.com/MicrosoftDocs/sdk-api/blob/docs/sdk-api-src/content/winuser/nf-winuser-setwindowshookexa.md",
        "document": "Installs an application-defined hook procedure into a hook chain. You would install a hook procedure to monitor the system for certain types of events. These events are associated either with a specific thread or with all threads in the same desktop as the calling thread.\n\nThe type of hook procedure to be installed. This parameter can be one of the following values.\n\nInstalls a hook procedure that monitors messages before the system sends them to the destination window procedure. For more information, see the CallWndProc hook procedure. Installs a hook procedure that monitors messages after they have been processed by the destination window procedure. For more information, see the HOOKPROC callback function hook procedure. Installs a hook procedure that receives notifications useful to a CBT application. For more information, see the CBTProc hook procedure. Installs a hook procedure useful for debugging other hook procedures. For more information, see the DebugProc hook procedure. Installs a hook procedure that will be called when the application's foreground thread is about to become idle. This hook is useful for performing low priority tasks during idle time. For more information, see the ForegroundIdleProc hook procedure. Installs a hook procedure that monitors messages posted to a message queue. For more information, see the GetMsgProc hook procedure. Windows 11 and newer: Journaling hook APIs are not supported. We recommend using the SendInput TextInput API instead. Installs a hook procedure that posts messages previously recorded by a WH_JOURNALRECORD hook procedure. For more information, see the JournalPlaybackProc hook procedure. Windows 11 and newer: Journaling hook APIs are not supported. We recommend using the SendInput TextInput API instead. Installs a hook procedure that records input messages posted to the system message queue. This hook is useful for recording macros. For more information, see the JournalRecordProc hook procedure. Installs a hook procedure that monitors keystroke messages. For more information, see the KeyboardProc hook procedure. Installs a hook procedure that monitors low-level keyboard input events. For more information, see the LowLevelKeyboardProc hook procedure. Installs a hook procedure that monitors mouse messages. For more information, see the MouseProc hook procedure. Installs a hook procedure that monitors low-level mouse input events. For more information, see the LowLevelMouseProc hook procedure. Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar. For more information, see the MessageProc hook procedure. Installs a hook procedure that receives notifications useful to shell applications. For more information, see the ShellProc hook procedure. Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or scroll bar. The hook procedure monitors these messages for all applications in the same desktop as the calling thread. For more information, see the SysMsgProc hook procedure.\n\nA pointer to the hook procedure. If the dwThreadId parameter is zero or specifies the identifier of a thread created by a different process, the lpfn parameter must point to a hook procedure in a DLL. Otherwise, lpfn can point to a hook procedure in the code associated with the current process.\n\nA handle to the DLL containing the hook procedure pointed to by the lpfn parameter. The hMod parameter must be set to NULL if the dwThreadId parameter specifies a thread created by the current process and if the hook procedure is within the code associated with the current process.\n\nThe identifier of the thread with which the hook procedure is to be associated. For desktop apps, if this parameter is zero, the hook procedure is associated with all existing threads running in the same desktop as the calling thread. For Windows Store apps, see the Remarks section.\n\nIf the function succeeds, the return value is the handle to the hook procedure.\n\nIf the function fails, the return value is NULL. To get extended error information, call GetLastError.\n\nSetWindowsHookEx can be used to inject a DLL into another process. A 32-bit DLL cannot be injected into a 64-bit process, and a 64-bit DLL cannot be injected into a 32-bit process. If an application requires the use of hooks in other processes, it is required that a 32-bit application call SetWindowsHookEx to inject a 32-bit DLL into 32-bit processes, and a 64-bit application call SetWindowsHookEx to inject a 64-bit DLL into 64-bit processes. The 32-bit and 64-bit DLLs must have different names.\n\nBecause hooks run in the context of an application, they must match the \"bitness\" of the application. If a 32-bit application installs a global hook on 64-bit Windows, the 32-bit hook is injected into each 32-bit process (the usual security boundaries apply). In a 64-bit process, the threads are still marked as \"hooked.\" However, because a 32-bit application must run the hook code, the system executes the hook in the hooking app's context; specifically, on the thread that called SetWindowsHookEx. This means that the hooking application must continue to pump messages or it might block the normal functioning of the 64-bit processes.\n\nIf a 64-bit application installs a global hook on 64-bit Windows, the 64-bit hook is injected into each 64-bit process, while all 32-bit processes use a callback to the hooking application.\n\nTo hook all applications on the desktop of a 64-bit Windows installation, install a 32-bit global hook and a 64-bit global hook, each from appropriate processes, and be sure to keep pumping messages in the hooking application to avoid blocking normal functioning. If you already have a 32-bit global hooking application and it doesn't need to run in each application's context, you may not need to create a 64-bit version.\n\nAn error may occur if the hMod parameter is NULL and the dwThreadId parameter is zero or specifies the identifier of a thread created by another process.\n\nCalling the CallNextHookEx function function to chain to the next hook procedure is optional, but it is highly recommended; otherwise, other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result. You should call CallNextHookEx unless you absolutely need to prevent the notification from being seen by other applications.\n\nBefore terminating, an application must call the UnhookWindowsHookEx function function to free system resources associated with the hook.\n\nThe scope of a hook depends on the hook type. Some hooks can be set only with global scope; others can also be set for only a specific thread, as shown in the following table.\n\nFor a specified hook type, thread hooks are called first, then global hooks. Be aware that the WH_MOUSE, WH_KEYBOARD, WH_JOURNAL*, WH_SHELL, and low-level hooks can be called on the thread that installed the hook rather than the thread processing the hook. For these hooks, it is possible that both the 32-bit and 64-bit hooks will be called if a 32-bit hook is ahead of a 64-bit hook in the hook chain.\n\nThe global hooks are a shared resource, and installing one affects all applications in the same desktop as the calling thread. All global hook functions must be in libraries. Global hooks should be restricted to special-purpose applications or to use as a development aid during application debugging. Libraries that no longer need a hook should remove its hook procedure.\n\nWindows Store app development If dwThreadId is zero, then window hook DLLs are not loaded in-process for the Windows Store app processes and the Windows Runtime broker process unless they are installed by either UIAccess processes (accessibility tools). The notification is delivered on the installer's thread for these hooks:\n\nFor an example, see Installing and Releasing Hook Procedures."
    },
    {
        "link": "https://stackoverflow.com/questions/7719693/prevent-hook-dll-loading",
        "document": "You might be able to disable all hooks by installing your own hook and then not calling from your hook. To do this correctly you will want to make sure that your hook will be the first hook that's going to be called.\n\nThe order the hooks are being called doesn't seem to be documented but it's easy enough to check by trial and error. Just install several hooks from different processes and see which is called first. The most likely cases are\n• The first hook that's installed is the first being called. This is the easy option. Just make sure to install your hook as soon as possible.\n• The first hook called is the only installed last. This one is more tricky. You'll have to make sure at all times that your's is the last hook that was installed. a hackish way to do this is to create a thread that every second or so removes the hook and adds it again.\n\nThis solution is far from perfect and, considering that the order is not documented, it may conceivably change at some point in the future. it is also possible that the hook invocation order is completely random, in which case this solution will not do you much good."
    },
    {
        "link": "https://stackoverflow.com/questions/869320/how-do-i-prevent-dll-injection",
        "document": "How to defend against those 3 techniques:\n\nYou can prevent the first technique (CreateRemoteThread which calls LoadLibrary) by hooking LoadLibrary. In your hook you check against a list of DLL names that you know are part of the process and that may be loaded, or you can check against a list of known DLLs you don't want to load.\n\nWhen you find a DLL you don't want to load SetLastError(ERROR_ACCESS_DENIED) then return NULL. I set the last error so that people that write code looking for an error code get one. This appears to work, perhaps a different code may be more appropriate.\n\nThat will stop the DLL from loading.\n\nI think the same technique for CreateRemoteThread blocking will work for SetWindowsHookEx, but only if you can get your hook installed before the SetWindowsHookEx technique has started loading its code (which is typically when the first Window is created in an app - so early in its lifetime).\n\nNice technique. Not seen that before. You can defend against this, but you'll have to hook the LoadLibrary entry point (not the IAT table) as the Code Cave calls LoadLibrary directly.\n\nAs the author of the article commented - there are many ways you can be attacked and you probably will have a hard time defeating them all. But often you only want to defend against certain DLL loads (such as a particular 3rd party DLL that is incompatible with your software because the 3rd party DLL wasn't written properly to accomodate the fact that another hook may also be present, so you block it from loading)."
    },
    {
        "link": "https://apriorit.com/dev-blog/679-windows-dll-injection-for-api-hooks",
        "document": "Being able to control and manipulate system behavior and API calls is a useful skill for any Windows developer. It allows you to investigate internal processes and detect suspicious and malicious code. Previously, we described an easy way to set a global API hook by manipulating the AppInit_DLLs registry key and make the calc.exe process invisible in the list of running processes.\n\nThis time, we dive even deeper into dynamic-link library (DLL) injection techniques. We demonstrate how to make any Windows process immortal so that no other process can terminate it. This DLL injection tutorial will be useful for Windows developers who want to know more about different ways of modifying the flow and behavior of API calls in Windows applications.\n\nBefore we dive into the depths of code manipulations, let’s go over some of the basics of API hooking.\n\nWhat is API hooking? API hooking is a technique that developers use for manipulating the behavior of a system or an application. With the help of API hooking, you can intercept calls in a Windows application or capture information related to API calls. Additionally, API hooking is one of the techniques that antivirus and Endpoint Detection and Response solutions use for identifying malicious code.\n\nThere are many ways you can implement API hooking. The three most popular methods are:\n• — Allows you to run your code inside a Windows process to perform different tasks\n• — Implemented via the WriteProcessMemory API used for pasting custom code into another process\n• toolset — Provides you with full control over a debugged application, making it easy to manipulate the memory of a debugged process\n\nIn this article, we focus on the DLL injection method as it’s the most flexible, best-known, and most studied approach to manipulating system behavior through API calls. But what is DLL injection to begin with? In short, it’s the process of running custom code within the address space of a different process. DLL injection is also the most universal API hooking method and has fewer limitations than other API hooking techniques.\n\nThere are three widely used DLL injection methods based on the use of:\n• the function. This method is only applicable to applications that use a graphical user interface (GUI).\n• the function. This method can be used for hooking any process but requires a lot of coding.\n• remote thread context patching. This method is efficient but rather complex, so it’s better to use it only if the other two methods don’t work out for some reason.\n\nFurther in this article, we explain how to implement each of these methods and provide a practical example of setting API hooks with one of them. Our journey begins with overviewing the first technique on this list — using the SetWindowsHookEx function.\n\nThe first DLL injection technique we overview in this post is based on the SetWindowsHookEx function. Using the WH_GETMESSAGE hook, we set a process that will watch for messages processed by system windows. To set the hook, we call the SetWindowsHookEx function:\n\nThe WH_GETMESSAGE argument determines the type of hook, and the functionAddress parameter determines the address of the function (in the address space of your process) that the system should call whenever a window is about to process a message.\n\nThe dllToBeInjected parameter identifies the DLL containing the functionAddress function. The last argument, 0, indicates the thread for which the hook is intended. Passing 0, we tell the system that we’re setting a hook for all GUI threads that exist in it. So this method can be applied to hook a specific process or all processes in the system.\n\nLet’s see how all this works:\n• The Some_application.exe thread is about to send a message to some window.\n• The system checks if the WH_GETMESSAGE hook is set for this thread.\n• Then the system finds out whether Inject.dll, the DLL containing the callback for the message, is mapped to the address space of the Some_application.exe process.\n• If Inject.dll isn’t mapped yet, the system maps it to the address space of the Some_application.exe process and increments the lock count of the DLL in that process.\n• The function of Inject.dll is called with the parameter.\n• Then a callback is called in the address space of the Some_application.exe process.\n• After returning from the callback, the DLL lock counter in the address space of the process is reduced by 1.\n\nNow let’s see how we can inject DLL with a second method — using the CreateRemoteThread function.\n\nNow we’re going to look at the most flexible way of injecting DLL — using the CreateRemoteThread function. The overall flow looks like this:\n\nInjecting a DLL involves invoking the LoadLibrary function within the thread of the target process to load the desired DLL. Since managing threads of another process is extremely complicated, it’s better to create your own thread in it. Fortunately, the CreateRemoteThread function makes this easy:\n\nThis function is very similar to the CreateThread function but has an additional hProcess parameter that identifies the process to which the new thread will belong.\n\nWe start with getting the handle of the process we’re going to hook:\n\nThen, we should allocate some memory in the target process in order to pass the DLL path, as the target process can access only its private memory:\n\nUsing the WriteProcessMemory function, we can place the DLL path into the address space of our target process:\n\nThen we can start a new thread. With the help of this thread, our DLL will be loaded into the target process.\n\nFinally, we can move to the third DLL injection method that’s based on thread context patching.\n\nThis method of DLL injection isn’t easy to detect, as it mostly looks like a regular thread activity. To succeed, we need to manipulate the context of an existing remote thread and make sure the thread doesn’t know about these manipulations. The instruction pointer of the target thread is first set to a custom piece of code. When the code is executed, the pointer is redirected to its original location.\n\nThis is what the whole process looks like:\n\nLet’s see how we can implement this DLL injection method in an x64 system.\n\nFirst, we need to locate the target process and pick a thread within it. It’s better to choose a thread that’s already running or is likely to run so that our DLL can be loaded as early as possible. Selecting a waiting thread isn’t the best idea, as such a thread won’t run the code unless it’s ready to run.\n\nFirst, we use the OpenThread function to open the handle of the remote thread:\n\nThen we need to allocate memory in the remote process to store our injected code and the DLL path in it:\n\nNext we write the DLL path in the middle of the remote allocated buffer:\n\nThen we suspend the remote thread and retrieve its context:\n\nNow we compile assembly code and save it in the buffer:\n\nWe set the remote IP (RIP) register of our remote thread to the buffer:\n\nFinally, we set a new context and resume the thread:\n\nNow that you’ve got a better understanding of different DLL injection techniques, it’s time to see how these techniques work in practice.\n\nWhile using the CreateRemoteThread function is the most universal way of setting API hooks with DLL injection, this method requires an extensive amount of preliminary coding. That’s why we’ll illustrate how to set API hooks with DLL injection using the SetWindowsHookEx function, which is a less time-consuming method.\n\nThis example is based on a basic user-mode DLL written in C++. To be able to follow your trail, make sure to add the latest version of the Mhook sources to your project.\n\nOur main goal here is to create an immortal process that’s impossible for any other process in the system to terminate. We begin with setting a global API hook.\n• We inject our DLL with the function:\n• To make sure we can restore the original function after removing our hook, we need to store its address.\n\nTo terminate a process, we need to call the TerminateProcess function from kernel32.dll. Thanks to the creation and initialization of a global variable, we can now store the original function’s address:\n• We’ve hooked the function instead of the original function. The hooked function first calls the function from kernel32.dll and gets the full name of the executable image for the process.\n\nNow we need to check the process name. If it has the “_immortal” suffix, it’s the process we should not allow to be terminated.\n\nNote: Both functions, the original and the hooked, must have identical signatures.\n• Here, we can finally inject our DLL into the code of the target process to set our hook.\n\nOnce loaded in the target process, the DllMain function will receive the DLL_PROCESS_ATTACH parameter. Now we can manipulate this process and hook the chosen function with the help of the Mhook library:\n• Once the DLL is unloaded from the target process’s address space, the function receives the parameter. After that, we remove the hook and restore the original function.\n\nWe now have all the code needed for setting API hooks with Windows DLL injection. It’s time to check if this code is actually working.\n\nFor a practical illustration, we used the Structured Storage Viewer utility and turned it into an immortal process by injecting a DLL with the SetWindowsHookEx function. As a result of this process, we got an executable with the name SSView_immortal.exe. Let’s launch this executable and look at it in Task Manager. We’ll also need the Process Explorer utility installed to check if our DLL is, in fact, injected in the Taskmgr.exe process:\n\nIn Task Manager, we can see the SSView_immortal.exe process. Let’s try to terminate it:\n\nWhen we click End task, we get a message box with an error (the same error we show in our hooked function):\n\nThen we also receive a message saying “Access is denied.” This is the ERROR_ACCESS_DENIED response we set earlier with the help of the SetLastError function when implementing our hooked function:\n\nAs you can see, we successfully hooked a system process and made it impossible for any other Windows process to terminate it, which is exactly what we intended to do.\n\nThere are many methods to hook an API call. DLL injection is one of the most flexible, effective, and well-studied methods for injecting custom code into a system process. When performing DLL injection, it’s important to insert code into a running process, as DLLs are meant to be loaded as needed at runtime.\n\nThere are many ways you can hook a function with DLL injection — by setting hooks in specific functions or manipulating the context of a remote thread. From our experience, we can say that setting hooks with the CreateRemoteThread function is the most effective approach. As this function is supported by the Windows operating system, there’s no need to use any additional tricks, complicated executable file structures, or operating system internals when working with it. However, if you’re working with a GUI application, you can use the most effortless option — the SetWindowsHookEx function.\n\nAt Apriorit, we’ve already set thousands of hooks and know how to find our way around different operating systems and processes. Get a step closer to realizing your dream project — contact us and tell us all about it!"
    },
    {
        "link": "https://m417z.com/Implementing-Global-Injection-and-Hooking-in-Windows",
        "document": "A couple of weeks ago, Windhawk, the customization marketplace for Windows programs, was released. You can read the announcement for more details and for the motivation behind creating it. In this post, I’ll focus on my journey in implementing the technical aspects of Windhawk. If you prefer reading code to reading text, check out the demo implementation.\n\nWindhawk allows creating mods, which are C++ snippets that are compiled to DLLs and loaded in third party programs to customize them. The technical challenge is to be able to load these DLLs in the context of the required processes. For example, one can create a mod that hooks the WinAPI function, and define that the mod should apply to all processes.\n\nWindhawk implements a mod manager which is injected into all processes. Injecting a DLL into all processes is not a novel task, it has been done multiple times before by antiviruses, customization tools, and other programs. To the best of my knowledge, these are the most common approaches:\n• Using a kernel driver - A nice proof-of-concept implementation can be found here.\n• Using - Can be used to install a hook procedure to monitor the system for certain types of events. Only applies to processes that load . Limited to processes in the same desktop. Has limitations regarding UWP apps.\n• Using - A legacy infrastructure that provides an easy way for custom DLLs to be loaded into the address space of every interactive application. Only applies to processes that load . Starting in Windows 8, the infrastructure is disabled when secure boot is enabled.\n• Using esoteric, undocumented hooks - You can see several examples for these in the Hooking Nirvana talk by Alex Ionescu.\n\nThese were my goals for the global injection solution:\n• Minimal privileges - I wanted Windhawk to be able to run even without administrator rights. And in general, I preferred to avoid installing a driver which is too intrusive to my taste and can affect the system’s stability.\n• Minimal intrusiveness - I preferred to avoid modifying system files or registry entries, doing all the work in memory, such that all changes are temporary and there’s no risk of causing permanent damage to the system.\n• Minimal limitations - I strived to allow customizing as many programs as possible. For example, I tried to find a solution that is not limited to processes that load , and that has no limitations regarding UWP apps.\n• Universal solution - I looked for a solution that works on all or most Windows versions, and that is unlikely to stop working in the future.\n\nAlso, it’s worth listing some of the non-goals for the solution:\n• Stealth - DLL injection is often misused by malware, and one of their goals is staying undetected for as long as possible. To achieve that, malware authors try to find novel injection methods which are not known to security vendors and are not detected by security software. As my project has no malicious intentions, hiding the injection is not necessary. In fact, I preferred a standard solution that is as transparent as possible.\n• Security - DLL injection is often used by security software. An antivirus, for example, may decide to intercept all file access and limit access to sensitive files. In this case, it’s important to make sure that the limitation can’t be bypassed. My project has no security implications and doesn’t need to be protected from bypasses.\n\nLooking for the best approach\n\nI started by looking for the approach that fits my goals best. Here’s a table which summarizes my findings (note that those are not yes/no criteria and the table is mostly a judgment call):\n\nOut of the four approaches, the approach seemed to be the best fit, but it has its limitations which I hoped to avoid. Also, using felt like a misuse of a tool designed for different purposes as I must choose an event to get notified about, even if I don’t need any.\n\nAfter some thought, I decided to try another approach: Instead of using a dedicated global injection mechanism, implement injection for a single process. Then, use it to implement global injection as following:\n• Initially, enumerate all processes and inject into each of them.\n• For each of the injected processes, intercept new process creation (e.g. by hooking the WinAPI function) and inject into each newly created process.\n\nThis approach looks rather obvious and simple to implement, but in practice there are various tricky details that have to be taken care of. I’ll go through them in this post. I’m sure this approach was implemented and used before, but I didn’t find a fully working implementation which I could use as a reference.\n\nTypically, process injection follows these steps: Memory allocation, memory writing, code execution. I’ve used the classic and straightforward injection method:\n• for allocating memory in the target process.\n• for writing the code into the allocated memory.\n• for creating a new thread in the target process to run the code that was written.\n\nThe injected code loads the DLL, achieving the required task.\n\nThis injection method is very old and well known, and there are many tutorials and examples for it on the internet, so I won’t elaborate further.\n\nAs mentioned before, the idea is to enumerate all processes and inject the DLL into each of them. To make sure the DLL is also loaded in newly created processes, intercept new process creation and inject into each newly created process.\n\nA simple implementation can be found here. A couple of notes about the implementation:\n• When launched as administrator, the program enables debug privilege. This allows injecting the DLL into system services. As a result, this enables injecting the DLL into newly created processes that are launched as administrator, since those processes are in fact created by the service, and so hooking its function is required. For details, refer to the blog post Parent Process vs. Creator Process by Pavel Yosifovich.\n• doesn’t allow creating a thread in a remote 64-bit process from a 32-bit process. The wow64ext library is used to overcome this limitation.\n• In Windows 7, fails if the target process is in a different session than the calling process. A workaround is to use instead.\n• To intercept new process creation, is hooked. Looks like all documented process creation functions end up calling it:\n• The MinHook library is used for hooking the , functions.\n• After being injected, the DLL waits for an event to be signaled, then unloads itself.\n• Refer to the repository’s README file for compiling and running instructions.\n\nAt first glance, it seemed to be working nicely and looked pretty much complete. But upon a closer inspection and after some careful testing, I found that there are several limitations that have to be addressed.\n\nEven when the injection program is running as administrator, and even when debug privilege is enabled, there are processes which are out of reach. Several core system processes in Windows are marked as Protected Processes, and as the name implies, they’re protected from tampering and the injection program can’t inject the DLL into them. That’s not a problem by itself, these processes are protected for a reason and I’m OK with not being able to fiddle with them. The real problem is that because they’re protected, is not hooked and there’s no opportunity to inject the DLL into processes created by protected processes, even if the created processes are not themselves protected.\n\nFor example, you can see on the screenshot below that is a protected process. As a result, the DLL won’t be injected into child processes which are launched after the injection program. processes which were already running are handled by the process enumeration.\n\nA similar problem exists when the injection program is not running as administrator - it can’t inject the DLL into elevated processes, which is a security limitation and that’s OK, but it also loses the opportunity to inject into unelevated processes created by elevated processes.\n\nFor example, in the screenshot below Windows Explorer was restarted via the Task Manager. The new process was created by , which is elevated.\n\nAnother common example where an elevated process creates an unelevated process is when a process crashes. See the screenshot below from the presentation Exploiting Errors in Windows Error Reporting by Gal De Leon. In this case, the injection program misses the opportunity to inject the DLL into which is unelevated. may in turn restart the crashed program, and it will be missed as well.\n\nThe solution that I came up with is to make the injection program monitor for new process creation, and for each newly created process, try to inject into it from the injection program.\n\nIf the new process was created by an inaccessible process, the injection program injects the DLL, as depicted below.\n\nIf, on the other hand, the new process was created by a process with an injected DLL, there’s a race between the creating process and the injection program. I used a mutex to make sure only one of them injects the DLL, as depicted below.\n\nThis approach works, but it has a serious drawback - if the new process is created by an inaccessible process, the DLL is injected asynchronously, possibly after the new process begins running, which might be too late depending on the customization use case. Unfortunately, I didn’t find a better solution, and because this problem is not very common (especially if the injection program is running as administrator), it’s not too bad.\n\nAlso, this solution created a new problem which is described below, which was happening when the injection program injected the DLL too early.\n\nAfter implementing the solution above, I noticed that sometimes, new processes failed to start. After a bit of investigation, I saw that it only happened with console programs. And after more investigation, I found the root cause.\n\nAll user mode threads begin their execution in the function. The first thread that a process runs performs process initialization tasks before the execution is transferred to the user-supplied thread entry point. One of the process initialization tasks is creating the console window in case the process is a console process. For more details about the function, check out this blog post by Ken Johnson.\n\nNormally, a new process starts with a single, suspended thread. Then, the Client/Server Runtime Subsystem ( ) gets notified about the new process that was just created, and does its own handling. Finally, the suspended thread is resumed, the function performs process initialization tasks and transfers the execution to the process entry point.\n\nWith the injection program injecting the DLL too early, the new process starts with a single, suspended thread, as usual. But before the Client/Server Runtime Subsystem ( ) gets notified about it, the injection program creates a new thread in the new process which starts executing right away (marked with red in the image below). As the first running thread, it performs the process initialization tasks. Only then, gets notified about the new process, but it doesn’t expect the process to have an initialized console, and returns an error.\n\nTo overcome this and other potential problems caused by the early injected thread execution, I switched from creating a new thread with to queuing an APC (Asynchronous Procedure Call) in cases when the process didn’t start executing yet. For a great technical blog post about APCs check out APC Series: User APC API by Ori Damari. A couple of notes about the implementation:\n• The undocumented function is used, since the documented function is not suited for inter-process APC queuing because of the activation context handling.\n• doesn’t allow queuing an APC in a remote 64-bit process from a 32-bit process. The wow64ext library is used to overcome this limitation.\n• For queuing an APC in a remote 32-bit process from a 64-bit process, the address parameter has to be encoded. I used the APC Series: KiUserApcDispatcher and Wow64 blog post by Ori Damari as a reference.\n\nBut how does the injection program know whether the process started executing (and then is used as before) or not (and then an APC is queued)? It checks whether there’s only a single thread, and if so, whether it’s suspended with the instruction pointer at . In that case it concludes that the process didn’t start executing and queues an APC instead of creating a remote thread.\n\nThe next thing I noticed is that the DLL wasn’t getting injected into processes of UWP apps such as Windows Calculator. The code to load the DLL was being injected successfully, but the DLL failed to load with . The problem was that UWP apps have limited access to the filesystem and they didn’t have permissions to load the DLL. Changing the DLL file permissions fixed this issue. For example, the following commands can be used to change the DLL file permissions such that UWP apps are able to load it:\n\nAnother problem was that a mutex can’t be shared between the injection program and UWP apps by using the same mutex name. UWP apps are sandboxed, and each UWP app has its own object directory. A UWP app can’t refer to objects outside of its object directory by name. I was able to overcome this limitation by using the little-known private namespaces API. For a great overview of named objects in Windows, including the UWP sandboxing and private namespaces, check out the blog post A Brief History of BaseNamedObjects on Windows NT by James Forshaw.\n\nAnother case in which the DLL wasn’t getting injected into processes was for processes with a mitigation policy that restricts image loading to images that are signed. On my test Windows 10 machine there were two such processes: and which hosts the service ( ).\n\nSimilarly to the UWP case, the code to load the DLL was being injected successfully, but the DLL failed to load, this time with . But unlike the UWP case, there’s no straightforward workaround. I could try and use reflective DLL injection (manually loading the DLL from memory), but I didn’t bother since it complicates the solution and might have pitfalls for the little benefit of being able to customize programs which are not very interesting anyway.\n\nI was OK with not being able to customize programs with this mitigation, but this limitation had an unpleasant side effect. In some cases, Windows was displaying a system error when the DLL loading failed:\n\nThe system error can be reproduced by running the following program and then running the injection program:\n\nAfter some investigation, I found that this behavior can be controlled with the , WinAPI functions. I used to turn off the critical-error-handler message box while trying to load the DLL.\n\nAfter handling all of the limitations above, the solution felt pretty solid and I didn’t encounter any other problems. But after using the computer with it for a while, I noticed that it takes noticeably longer for some programs to launch. The reason for this was that MinHook, the hooking library that I used, enumerates all the threads on the system and looks for threads that belong to the current process to suspend them. Enumerating all system threads can be very slow, on my system it took more than 300 milliseconds. I improved this by doing the following:\n• Instead of enumerating all threads on the system, I use the undocumented function to directly enumerate threads that belong to the current process. In addition to improving performance, it also improves stability by avoiding race conditions. For a comprehensive overview, check out the Suspending Techniques research by diversenok.\n• When injecting into a process which didn’t start executing yet, I skip the thread enumeration altogether, since there should be no other running threads anyway.\n\nYou can find the code that enables this in my MinHook multihook branch. Among other changes the branch has is the ability for a function to be hooked more than once. In general, I found that reliable function hooking is more tricky than it might seem at first. For example, consider what happens if a DLL sets a hook and then needs to be unloaded. When is it safe to unload it? Can you be sure? But that’s a topic for another post.\n\nAn implementation that handles all the limitations mentioned in this post can be found here. I’m pretty satisfied with the result. I’ve been using my computer with Windhawk, which uses this global injection and hooking implementation, for several months, and I didn’t experience any stability, performance, or any other problems. I hope that Windhawk will prove itself as a reliable tool for customizing Windows programs, and I invite you to try it out."
    },
    {
        "link": "https://apriorit.com/dev-blog/secure-windows-software-against-dll-attacks",
        "document": "Any Windows application that handles sensitive data is a potential target for cyber attacks like dynamic link library (DLL) injection. By injecting malicious code into software, attackers can change the way processes behave to turn off security measures, steal data, or harm software.\n\nThus, taking relevant protection mechanisms into consideration during software development is a must. Protecting your software from DLL injection attacks can help your team reduce the risk of product hacking, preventing unjustified spending of money and time on handling incidents and mitigating reputational losses.\n\nThis article covers the DLL injection workflow, consequences of DLL injection, as well as nuances of detection and prevention. In the practical part, we show two simple but unique DLL injection attack examples and how to use popular API hooking libraries and a protection mechanism to prevent such attacks. You’ll also see a real-life example of how DLL injection can be detected and countered within a running process monitoring application.\n\nThis article will be helpful for project and development leaders working on Windows applications who want to enhance protection against cybersecurity attacks.\n\nMalicious actors can use many methods to hack or change the behavior of your software, aiming to steal sensitive data, request a ransom, or inject malware for some other reason.\n\nA common approach to hacking Windows software is DLL injection — inserting a DLL into the address space of a running process to execute code. When a DLL is injected, it becomes part of the target process. To inject a malicious DLL, attackers often use API hooking to add code that intercepts and modifies the behavior of existing functions within an application.\n\nDLL injection attacks don’t require access to the target application’s source code. This approach is common in Trojan horse malware that changes the behavior of running applications. For instance, DLL injection and API hooking can be used to hide some processes that the user should not see or cannot close. This way, an attacker, for example, can use the victim’s system to mine cryptocurrency. When applying both techniques simultaneously, hackers can integrate suspicious code into almost any existing process and gain control over it.\n\nBy inserting malicious code into a legitimate process, attackers can execute arbitrary code with the same privilege as the target process. The security consequences of DLL injection include:\n• Access sensitive information from the host and steal credentials, credit card information, and other personal data.\n• Crash a target process or potentially cause system-wide crashes or instability.\n• Gain unauthorized access and modify or turn off security measures.\n\nThe good and the bad of DLL injection\n\nDetecting malicious DLL injections is a challenging task, especially since you need to understand the context and intent behind each injection.\n\nOn the one hand, this technique can be used for legitimate and illegitimate purposes. Initially, Remote library injection was introduced as an exploitation technique in 2004 by Skape and JT [PDF]. Later, more libraries appeared allowing programmers to quickly and easily inject their DLL and set hooks on an API function.\n\nHere are a few examples of using DLL injection for good:\n• Software applications often use DLL injection as a legitimate means to extend a program’s functionality via plugins or extensions.\n• Security specialists might alter system behavior to investigate internal processes and detect suspicious and dangerous code.\n• Developers use DLL injection during debugging and profiling to analyze and monitor the behavior of running processes.\n• Security software, like antivirus or intrusion detection systems, may inject DLLs into processes to monitor and protect against malicious activity.\n\nOn the other hand, unwanted DLL injection is dangerous:\n• Malware often uses DLL injection to add malicious code to legitimate processes, changing the solution’s behavior.\n• Hackers can use DLL injection as part of an attack to gain unauthorized access to a system.\n• Game cheaters might use DLL injection to modify the behavior of games to gain unfair advantages.\n\nTo monitor unauthorized DLL injection in programs, organizations have developed various antivirus solutions and game anti-cheat software. For example, Microsoft Defender Antivirus in Windows scans DLLs and executables and flags malicious ones. But you shouldn’t entirely rely on such solutions, as they might not identify certain malicious injection techniques. One reason is that every time cybersecurity experts come up with a solution to prevent illegal DLL injection, attackers find ways to bypass it.\n\nBefore we move to showing methods for protecting against DLL injection, let’s briefly explore how DLL injection works.\n\nTo effectively detect and mitigate attacks, it’s crucial to understand the logic behind the injection process. Let’s overview a common DLL injection workflow and explore which Windows APIs and functions are usually involved in DLL injection attacks.\n\nHackers can run a DLL injection attack in four steps:\n• Attach their injection application to the target process\n• Upload the DLL data or path to the process’s memory and locate memory addresses appropriate for injection\n• Instruct the process to execute the injected DLL\n\nHow does DLL injection work in detail?\n\nFirst, hackers determine a target for DLL injection. The most popular Windows functions that injection applications can use for this purpose are:\n\nThese functions read all system processes to find a target process. As a result, the injection application can get all necessary information about the target process.\n\nNext, the injection application can call the following functions to obtain a handle value to access the target process:\n\nThen, hackers allocate memory for writing the name of the malicious DLL within the memory area of the target process. To do so, malicious actors can use the Kernel32.dll!VirtualAllocEx() function. The process of writing the DLL into allocated memory mainly occurs through the Kernel32.dll!WriteProcessMemory() function call.\n\nFinally, to make the target process execute their code, hackers might use the Kernel32.dll!LoadLibrary function and pass the result to one of these Windows API functions:\n\nAfter all of this, a remote process must execute the injected DLL in the target application.\n\nWith basic information about the DLL injection workflow in mind, let’s overview a few simple examples of DLL injection apps and a way to protect software from them.\n\nTo showcase an example of protecting software from malicious DLL injection, we’ll do the following:\n\n1. Create two unique applications that can inject a DLL into a target application and insert a hook for the Kernel32.dll!OpenProcess function. These apps will simulate Trojan malware that hides the running process named DangerMiner from users. We’ll develop these injection apps using two different libraries to show different algorithms for DLL injection.\n\n2. Create a mechanism to prevent DLL injection. You’ll see how this protection program blocks our unique apps that try to inject DLLs.\n\nTo demonstrate how these apps work, we’ve created a simple process monitoring program into which we’ll inject the DLL file and set the hook. This program monitors all existing and newly created processes in the system and prints information about them in the console.\n\nWe decided to create such a program because injecting a DLL into an existing solution’s process without permission from its developers or owners can be considered a violation of software terms of use, service agreements, or end-user license agreements. It also might be a breach of intellectual property rights and copyright laws. We believe it’s necessary to respect the boundaries and guidelines set by software developers and the law to ensure ethical and legal behavior.\n\nNote: The injection examples below are pretty simple, focused on only affecting one process in a system. They are created for security research purposes only. Tools like Windows Security Defender (which is built into Windows) can easily detect and prevent such injection attempts.\n\nHere’s what our custom process monitoring application looks like with the DangerMiner process running:\n\nNow, let’s move to developing two DLL injection apps and a program for protecting against them.\n\nOur first DLL injection program aims to:\n• Deny the target application the ability to open the DangerMiner process so a process with this name won’t appear in our custom process monitoring app\n\nWe’ll use Nektra Deviare, a library written in C++ and built on COM objects that you can use in different programming languages. This library opens a target process, allocates memory, then tries to load a DLL that must be injected.\n\nThe C# source code below demonstrates how to inject a DLL into a running process. After a DLL is injected, it will set hooks and start to intercept the target function.\n\nAs a result, the DLL is injected into CustomProcessMonitor.exe, and the DangerMiner process isn’t shown in our process monitor app. Everything works as expected:\n\nYou can find the full source code for this project on Apriorit’s GitHub page for ProcessHide_Deviare and on the page for ProcessHidePlugin_Deviare.\n• Inject a DLL called ProcessHidePlugin_EasyHook.dll into the target application. It works the same way as our previous application.\n• Prevent the target application from opening a DangerMiner process so that a process with this name won’t appear in our custom process monitoring app\n\nEasyHook is written in C# and divided into different DLLs like EasyHook.dll and EasyLoad32.dll. Because of that division, the library first loads these DLLs into the target process and only then injects the DLL.\n\nThe C# source code below demonstrates how to inject DLL into a running process using the EasyHook library:\n\nAs a result, the DLL is injected into CustomProcessMonitor.exe, and the DangerMiner process isn’t shown in our process monitoring app. The second program also works as intended.\n\nTo see the full source code of this app, check out Apriorit’s GitHub pages for ProcessHide_EasyHook and ProcessHidePlugin_EasyHook.\n\nIn previous articles, we proposed methods for protecting against hook and return-oriented programming attacks as well as security techniques to mitigate splicer-type hooking attacks. This time, we’d like to offer another way to safeguard your applications from DLL injection attacks.\n\nAs described earlier, to perform DLL injection, hackers can use function calls like Kernel32.dll!LoadLibrary and Kernel32.dll!CreateRemoteThread to upload to and execute DLLs in the target process. Therefore, we came up with the idea of hooking the LoadLibrary function to help us:\n\nThe LoadLibrary function takes as a parameter the full path to the DLL to be loaded. In this case, we need to figure out how to determine that injection of a particular DLL should be blocked.\n\nTo determine that a DLL can be injected, you can use many options like digital signature verification, hash verification, or vendor and source validation.\n\nFor the purposes of this article, we decided to use two methods:\n\nEvery time our application loads a DLL library, we check whether this DLL passes signature validation and is contained in the allow-list folder. After all checks, we can determine with a high degree of probability whether the library is legitimate.\n\nNote that such a technique isn’t comprehensive enough to detect and prevent illegal DLL injection. You can add other checks to more accurately determine the legitimacy of the downloaded DLL as well as hook other calls to prevent malicious injection.\n\nTo set protection from illegal DLL injection, let’s use the Microsoft Detours library. Here’s how it can help us set a hook to the Kernel32.dll!LoadLibrary function call:\n\nAfter setting the hook, the protection plugin intercepts all LoadLibrary calls. Thus, when LoadLibrary is called, we need to determine whether the loading DLL is legal. In case it’s not, we must deny the function call to prevent DLL injection. Here’s how to do so:\n\nTo illustrate how such detection and prevention of illegal DLL injection works, let’s try injecting the earlier created DLLs aimed at changing the behavior of our custom process monitoring app.\n\nHere are the results of an attempt to inject a DLL using the Nektra Deviare library:\n\nLet’s also try injecting a DLL using the EasyHook library:\n\nAs you can see, our solution managed to properly detect a DLL injection and block it, informing the user about this malicious attempt. The injection process failed, and the target application continued working as before.\n\nCheck out the source code of all these projects on Apriorit’s GitHub page.\n\nYou can use the described DLL injection prevention approach for almost every Windows process. Thus, it’s applicable for a wide range of projects, especially those that work with sensitive data and critical processes where protection against unauthorized or malicious code injection is a priority.\n\nThe offered approach won’t work for some processes: not because of our technique, but because of other reasons such as process design, security, or access rights. For example:\n• Processes designed to be more secure and resistant to tampering, such as antivirus or anti-malware processes, as they employ various security mechanisms to prevent external interference, including DLL injection\n• Processes that require administrator privileges to be attached to or injected into\n• Critical system processes and services that are protected against modification to ensure system stability\n• Universal Windows Platform apps that run in a more isolated environment for security reasons and have restrictions on attaching and manipulating them\n• Processes that enable debugging protection to prevent unauthorized debugging or code injection, which can restrict or disable attaching to, setting hooks, or injecting into those processes\n\nYou can use our approach both as a standalone security check and as part of a larger product like a cybersecurity system, antivirus software, game anti-cheat solution, or system monitoring application.\n\nNote that this method doesn’t protect against other common attacks. Also, this is not the primary technique to detect and prevent illegal DLL injection. To get the most out of this method, you might need to add more checks to accurately determine the legitimacy of the downloaded DLL as well as hook some other calls to prevent injections. We believe that such DLL injection protection works well as part of (and can complement) larger protection systems.\n\nThe solution we presented above is a simple example aimed to demonstrate one of many ways to secure your applications and systems from DLL injection attacks. Thus, our proposed solution has its flaws.\n\nOnly relying on a folder-based whitelist and signature verification might not provide foolproof protection against all forms of DLL injection or unauthorized DLL loading. A signature verification may return an invalid value for an illegal DLL, or the returned value may be modified by an attacker. Also, sophisticated attackers can find ways to place malicious DLLs in trusted folders, modify the whitelist, or bypass whitelist checks altogether.\n\nTo achieve robust protection from DLL injection, your team requires enough experience and knowledge to understand the possible context behind a particular DLL injection. Remember that security measures should be comprehensive and multi-layered to effectively address various attack vectors. We also recommend your team take the following steps to keep your systems secure:\n• Install security updates and patches as soon as they become available to ensure that your system is protected against known vulnerabilities.\n• Download software only from reputable sources and verify its authenticity before installing it.\n• Turn off any unneeded services or applications.\n• Use the principle of least privilege, giving users and processes only the access they need to carry out their tasks.\n• Enable Windows Defender Application Control to prevent the loading of unsigned DLLs.\n• Sign your DLLs using code signing certificates to ensure they have not been modified.\n• Monitor your systems for suspicious activity and investigate any anomalies you detect.\n\nIn all Apriorit projects, we assess a variety of security risks and choose relevant security measures that ensure complex software protection. Our experts will gladly help you protect your solutions against malicious attacks.\n\nKnowing how to detect DLL injections and mitigate them in your software can prevent costly incident handling, improve your reputation, and help your product better handle security threats. You can use the method for protecting against DLL injections proposed in this article as one way to increase product and data security. But keep in mind that your product will need more robust defenses to achieve comprehensive protection against various attacks.\n\nIn this article, we discussed the basics of how to prevent DLL injection. A comprehensive protection strategy requires a combination of security measures and a proactive security mindset. It’s essential to follow secure coding practices, implement proper access controls, and stay informed about the latest security threats and best practices.\n\nAt Apriorit, we have dedicated teams of Windows developers and cybersecurity experts with vast experience delivering efficient and protected software to our clients. Our engineers are ready to help you enhance your project’s security."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32first",
        "document": "Retrieves information about the first process encountered in a system snapshot.\n\nA handle to the snapshot returned from a previous call to the CreateToolhelp32Snapshot function.\n\nA pointer to a PROCESSENTRY32 structure. It contains process information such as the name of the executable file, the process identifier, and the process identifier of the parent process.\n\nReturns TRUE if the first entry of the process list has been copied to the buffer or FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError function if no processes exist or the snapshot does not contain process information.\n\nThe calling application must set the dwSize member of PROCESSENTRY32 to the size, in bytes, of the structure.\n\nTo retrieve information about other processes recorded in the same snapshot, use the Process32Next function.\n\nFor an example, see Taking a Snapshot and Viewing Processes."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32next",
        "document": "Retrieves information about the next process recorded in a system snapshot.\n\nA handle to the snapshot returned from a previous call to the CreateToolhelp32Snapshot function.\n\nReturns TRUE if the next entry of the process list has been copied to the buffer or FALSE otherwise. The ERROR_NO_MORE_FILES error value is returned by the GetLastError function if no processes exist or the snapshot does not contain process information.\n\nTo retrieve information about the first process recorded in a snapshot, use the Process32First function.\n\nFor an example, see Taking a Snapshot and Viewing Processes."
    },
    {
        "link": "https://stackoverflow.com/questions/865152/how-can-i-get-a-process-handle-by-its-name-in-c",
        "document": "There are two basic techniques. The first uses PSAPI; MSDN has an example that uses , , , and .\n\nThe other uses Toolhelp, which I prefer. Use to get a snapshot of the process list, walk over it with and , which provides module name and process ID, until you find the one you want, and then call to get a handle."
    },
    {
        "link": "https://cocomelonc.github.io/pentest/2021/09/29/findmyprocess.html",
        "document": "This post is a Proof of Concept and is for educational purposes only. \n\n Author takes no responsibility of any damage you cause.\n\nWhen I was writing my injector, I wondered how, for example, to find processes by name?\n\nWhen writing code or DLL injectors, it would be nice to find, for example, all processes running in the system and try to inject into the process launched by the administrator.\n\nIn this post I will try to solve a simplest problem first: find a process ID by name.\n\nFortunately, we have some cool functions in the Win32 API.\n\nLet’s go to examine our code. \n\n So first we parse process name from arguments. Then we find process ID by name and print it:\n\nTo find PID we call function which basically, what it does, it takes the name of the process we want to inject to and try to find it in a memory of the operating system, and if it exists, it’s running, this function return a process ID of that process:\n\nI added comments to the code, so I think you shouldn’t have so many questions. \n\n First we get a snapshot of currently executing processes in the system using CreateToolhelp32Snapshot:\n\nAnd then we walks through the list recorded in the snapshot using Process32First and Process32Next:\n\nif we find the process which is match by name with our return it’s ID.\n\nAs I wrote earlier, for simplicity, we just print this PID.\n\nLet’s go to compile our code:\n\nAnd now launch it in Windows machine (Windows 7 x64 in my case):\n\nAs you can see, everything work perfectly.\n\nNow, if we think like a red teamer, we can write a more interesting injector, which, for example, find process by name and inject our payload to it.\n\nLet’s go! \n\n Again for simplicity I’ll take my injector from one of my posts and just add the function :\n\n“Evil” DLL is the same:\n\ncompile and put it in a directory of our choice:\n\nAs you can see, everything is good: We launch and our simple injector find PID (1) \n\n Our DLL with simple pop-up (Meow) is work! (2)\n\nTo verify our DLL is indeed injected into process we can use Process Hacker, in memory section we can see: \n\n\n\nIt seems our simple injection logic worked!\n\nIn this case, I didn’t check if is “enabled” in my own process. And how can I get this privileges??? I have to study this with all the caveats in the future.\n\nThanks for your time and good bye! \n\n PS. All drawings and screenshots are mine"
    },
    {
        "link": "https://stackoverflow.com/questions/69193728/get-name-list-of-all-running-processes-windows",
        "document": "The code you have written does not work like a generator function to yield multiple values. It just exits when returning the first value. You cannot return from a function more than once.\n\nAlthough, coroutines offer to accomplish this.\n\nThe most basic repair would be to redesign your function to return a of strings rather than just a single string.\n\nThen, to call it, you could use something like this:"
    }
]