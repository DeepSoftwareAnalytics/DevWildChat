[
    {
        "link": "https://developers.google.com/custom-search/v1/overview",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nThe Custom Search JSON API lets you develop websites and applications to retrieve and display search results from Programmable Search Engine programmatically. With this API, you can use RESTful requests to get either web search or image search results in JSON format.\n\nThe Custom Search JSON API uses the OpenSearch 1.1 Specification.\n\nBefore using the Custom Search JSON API you will first need to create and configure your Programmable Search Engine. If you have not already created a Programmable Search Engine, you can start by visiting the Programmable Search Engine control panel.\n\nFollow the tutorial to learn more about different configuration options.\n\nAfter you have created a Programmable Search Engine, visit the help center to learn how to locate your Search engine ID.\n\nCustom Search JSON API requires the use of an API key. Get a Key\n\nCustom Search JSON API provides 100 search queries per day for free. If you need more, you may sign up for billing in the API Console. Additional requests cost $5 per 1000 queries, up to 10k queries per day.\n\nBasic monitoring for the Custom Search JSON API is available through Cloud Platform Console's API Dashboard. For more advanced monitoring Google Cloud's Operations suite (formerly Stackdriver) is available.\n\nWith Google Cloud Operations you can create custom dashboards, set up alerts, and access metrics data programmatically. To access Custom Search JSON API usage data in Google Cloud Operations, select \"Resource type: Consumed API\" and filter on \"service = 'customsearch.googleapis.com'\" in the Query Builder.\n\nSee Monitoring Your API Usage for a discussion of the different monitoring and alerting capabilities provided by the API Dashboard and the Google Cloud Operations suite."
    },
    {
        "link": "https://zenserp.com/how-to-integrate-a-google-image-search-api-with-javascript",
        "document": "In today’s digital age, images are significant in our online experiences. But have you ever wondered how websites fetch and display those images so effortlessly? It’s all thanks to APIs (Application Programming Interfaces) and a little bit of JavaScript magic! In this exciting journey, we’ll explore the world of images and learn how to create our custom image search engine. Moreover, we will use Zenserp Google image API. You will also learn about the features of this Image Search API.\n\nImagine searching for any image you can think of and displaying it on your design webpage. Sounds cool, right? We’ll use a powerful tool called the Zenserp Image API. It allows us to fetch image search results programmatically. Don’t worry if the name sounds technical – we’ll break it down step by step. We’ll also use JavaScript, a popular and beginner-friendly programming language, to bring our image search engine to life.\n\nMoreover, you’ll not only have a better understanding of how websites work behind the scenes, but you’ll also have the skills to create your own unique image search feature. Let’s begin.\n\nThe Google Image Search API is a tool that allows developers to programmatically access and retrieve image search results from Google’s vast image database. Developers can integrate image search functionality into their applications, websites, or projects through this API. Hence, enhancing user experiences with visual content.\n\nThe Zenserp API is a powerful tool that helps you gather information from search engine result pages without any interruptions. One cool thing it can do is use the Google Image Search API, which lets you get pictures from Google’s image search in real time. You use similar settings when you do a normal Google search. However, you must include a special phrase and a code for an image search.\n\nAlso, the Zenserp image search API is useful for putting together collections of pictures to teach computer programs how to learn things. Many options let you choose the exact kind of pictures you want.\n\nRegarding how much it costs, Zenserp has a free plan that lets you make 50 requests every month. If you need more requests, there are other choices. For example, you could pay $29.99 to get 5,000 requests or $379.99 to get 100,000 requests monthly.\n\nWhy Should You Choose JavaScript To Integrate Zenserp Image Search API?\n\nChoosing JavaScript to integrate the Zenserp Image Search API brings simplicity and interactivity to your web projects.\n\nJavaScript is a beginner-friendly language commonly used for website magic, making things move and respond.\n\nWith JavaScript, you can easily fetch and show images from Zenserp’s API on your webpage, creating a custom image search tool.\n\nIts friendly nature and wide use in creating cool features like animations and forms make it a great choice.\n\nSo, if you’re keen to craft a personalized image search experience and add a touch of web wizardry, JavaScript is the way to go!\n\nHow To Integrate Zenserp Image Search API in JavaScript?\n\nFirst, get an API key from the Zenserp website.\n\nNext, create a directory using the command prompt.\n\nOpen the directory in Visual Studio Code and create an HTML file. We will write the HTML and JavaScript code in the same file.\n\nThis section sets up the basic structure of an HTML document. The `<meta>` tags specify the character set and viewport settings. Next, the `<title>` tag sets the page title. Then, the `<style>` tag is used for adding CSS styles that define the page’s layout and appearance.\n\nIt defines CSS styles to control the layout and appearance of the page. Then, it styles the `<body>` element with a background image, font family, and background color. Furthermore, it sets the margin and padding to 0 to eliminate extra spacing around the page. Then, it defines styles for `.header`, `.search-container`, and `.result-image` elements.\n\nIt creates a `<div>` element with the class `header` to contain the main heading. Inside the `<div>`, there’s an `<h1>` element displaying the main heading text.\n\nIt creates a `<div>` element with the class `search-container` to contain the search input and button. Then, it includes an `<input>` element with the type “text” and an ID of `searchTerm` for entering search terms. Moreover, it adds a `<button>` element with the ID `searchButton` to initiate the search.\n\nIt creates an empty `<div>` element with the ID `imageResults` to hold fetched image results from the API.\n\n`document.addEventListener(‘DOMContentLoaded’, function () { … });` ensures that the JavaScript code runs after the page’s content is fully loaded. Then, the `const apiKey = ‘YOURAPIKEY’;` replaces `’YOURAPIKEY’` with your actual Zenserp API key. Next, `const searchButton = document.getElementById(‘searchButton’);` retrieves a reference to the search button element using its ID.\n\nThe `const searchTermInput = document.getElementById(‘searchTerm’);` retrieves a reference to the search input field element using its ID. Next, `const imageResultsDiv = document.getElementById(‘imageResults’);` retrieves a reference to the image results container element using its ID.\n\n`searchButton.addEventListener(‘click’, function () { … });` adds a click event listener to the search button. When the button is clicked, the provided function is executed.\n• Retrieves the user’s search term from the input field.\n• Constructs the API URL using the search term and API key.\n• Uses the `fetch()` function to send a request to the Zenserp API and retrieve image search results in JSON format.\n• Processes the API response: If images are found, it creates `<img>` elements for each image and appends them to the `imageResultsDiv`. If no images are found, it displays a “No results found.” message.\n• `.catch(error => { console.error(‘Error:’, error); });`: If any errors occur during the API request or processing, they are caught and logged to the console.\n\nIntegrating a Google Image Search API with JavaScript empowers developers to create dynamic image search experiences within their web applications. Users can seamlessly search and display relevant images by leveraging the API’s capabilities. Hence, enhancing user engagement and enriching content. This integration highlights the versatile potential of JavaScript in modern web development.\n\nIs There an API for Google Image Search?\n\nYes, Google provides a Custom Search JSON API that allows programmatic access to their image search functionality. Also, you can use the alternative options like Zenserp Google Image Search API.\n\nHow Do I Use Google Images API?\n\nTo use Google Images API, obtain an API key, make HTTP requests, and process responses to fetch and display images programmatically.\n\nYes, Google offers a Custom Search JSON API, which allows limited free usage for custom search functionality in applications.\n\nNo, the Bing Image Search API is not free and typically requires a subscription or payment for usage.\n\nUnlock Enhanced Search Experiences with Zenserp! Try Now and Elevate Your Data Retrieval Efforts."
    },
    {
        "link": "https://developers.google.com/custom-search/v1/using_rest",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nThis document describes how to use the Custom Search JSON API.\n\nREST, or Representational State Transfer, in the Custom Search JSON API is somewhat different from the usual RESTful APIs. Instead of providing access to resources, the API provides access to a service. As a result, the API provides a single URI that acts as the service endpoint.\n\nYou can retrieve results for a particular search by sending an HTTP request to its URI. You pass in the details of the search request as query parameters. The format for the Custom Search JSON API URI is:\n\nThree query are required with each search request:\n• None API key - Use the query parameter to identify your application.\n• Programmable Search Engine ID - Use to specify the Programmable Search Engine you want to use to perform this search. The search engine must be created with the Control Panel Note: The Search Engine ID (cx) can be of different format (e.g. 8ac1ab64606d234f1)\n• None Search query - Use the query parameter to specify your search expression.\n\nAll other query parameters are optional.\n\nHere is an example of a request which searches a test Programmable Search Engine for lectures:\n\nThere are two types of parameters that you can pass in your request:\n• API-specific parameters - define properties of your search, like the search expression, number of results, language etc.\n• Standard query parameters - define technical aspects of your request, like the API key.\n\nAll parameter values need to be URL encoded.\n\nRequest parameters that apply specifically to the Custom Search JSON API and define your search request are summarized in the reference.\n\nQuery parameters that apply to all Custom Search JSON API operations are documented at System Parameters.\n\nIf the request succeeds, the server responds with a HTTP status code and the response data in JSON format. You can look up the response data structure in the reference.\n\nThe response data is a JSON object that includes three types of properties:\n\nFor a detailed description of each property, see the reference.\n• property, which has information about the OpenSearch template used for the results returned in this request.\n• property, which is an array of objects describing the characteristics of possible searches. The name of each object in the array is either the name of an OpenSearch query role or one of the two custom roles defined by this API: and . Possible query role objects include:\n• : Metadata describing the query for the current set of results.\n• This role is always present in the response.\n• It is always an array with just one element.\n• : Metadata describing the query to use for the next page of results.\n• This role is not present if the current results are the last page. Note: This API returns up to the first 100 results only.\n• When present, it is always a array with just one element.\n• : Metadata describing the query to use for the previous page of results.\n• Not present if the current results are the first page.\n• When present, it is always a array with just one element.\n\nThe property has metadata describing the search engine that performed the search query. It includes the name of the search engine, and any facet objects it provides for refining a search.\n\nThe array contains the actual search results. The search results include the URL, title and text snippets that describe the result. In addition, they can contain rich snippet information, if applicable.\n\nIf the search results include a property, it contains a set of promotions.\n\nYou can invoke the Custom Search JSON API using REST from JavaScript, using the query parameter and a callback function. This lets you write rich applications that display Programmable Search Engine data without writing any server side code.\n\nThe following example uses this approach to display the first page of search results for the query lecture:"
    },
    {
        "link": "https://stackoverflow.com/questions/8448788/google-custom-search-for-images-only",
        "document": "Since Google image search API is deprecated, one should use Google custom search API for this.\n\nI've made a small example using it. My problem is I want to return google image search results only. Whereby this shows web results, and the user may switch to the image result. How can I show only the image results by default?\n\nThe API documentation is quite poor, it only describes how to add additional results."
    },
    {
        "link": "https://serphouse.com/blog/google-images-api-integration-guide",
        "document": ""
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest_API/Using_XMLHttpRequest",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nIn this guide, we'll take a look at how to use to issue HTTP requests in order to exchange data between the website and a server. Examples of both common and more obscure use cases for are included. After the transaction completes, the object will contain useful information such as the response body and the HTTP status of the result.\n\nA request made via can fetch the data in one of two ways, asynchronously or synchronously. The type of request is dictated by the optional argument (the third argument) that is set on the method. If this argument is or not specified, the is processed asynchronously, otherwise the process is handled synchronously. A detailed discussion and demonstrations of these two types of requests can be found on the synchronous and asynchronous requests page. You can't use synchronous requests outside web workers as it freezes the main interface. Note: The constructor isn't limited to only XML documents. It starts with \"XML\" because when it was created the main format that was originally used for asynchronous data exchange was XML.\n\nAlthough is most commonly used to send and receive textual data, it can be used to send and receive binary content. There are several well tested methods for coercing the response of an into sending binary data. These involve utilizing the method on the object and is a workable solution. However, more modern techniques are available, since the attribute now supports a number of additional content types, which makes sending and receiving binary data much easier. For example, consider this snippet, which uses the of to fetch the remote content into a object, which stores the raw binary data. For more examples check out the Sending and Receiving Binary Data page.\n\nprovides the ability to listen to various events that can occur while the request is being processed. This includes periodic progress notifications, error notifications, and so forth. Support for DOM event monitoring of transfers follows the specification for progress events: these events implement the interface. The actual events you can monitor to determine the state of an ongoing transfer are: The amount of data that has been retrieved has changed. The transfer is complete; all data is now in the const req = new XMLHttpRequest(); req.addEventListener(\"progress\", updateProgress); req.addEventListener(\"load\", transferComplete); req.addEventListener(\"error\", transferFailed); req.addEventListener(\"abort\", transferCanceled); req.open(); // … // progress on transfers from the server to the client (downloads) function updateProgress(event) { if (event.lengthComputable) { const percentComplete = (event.loaded / event.total) * 100; // … } else { // Unable to compute progress information since the total size is unknown } } function transferComplete(evt) { console.log(\"The transfer is complete.\"); } function transferFailed(evt) { console.log(\"An error occurred while transferring the file.\"); } function transferCanceled(evt) { console.log(\"The transfer has been canceled by the user.\"); } We add event listeners for the various events that are sent while performing a data transfer using . Note: You need to add the event listeners before calling on the request. Otherwise the events will not fire. The progress event handler, specified by the function in this example, receives the total number of bytes to transfer as well as the number of bytes transferred so far in the event's and fields. However, if the field is false, the total length is not known and will be zero. Progress events exist for both download and upload transfers. The download events are fired on the object itself, as shown in the above sample. The upload events are fired on the object, as shown below: Note: Progress events are not available for the protocol. Progress events come in for every chunk of data received, including the last chunk in cases in which the last packet is received and the connection closed before the progress event is fired. In this case, the progress event is automatically fired when the load event occurs for that packet. This lets you now reliably monitor progress by only watching the \"progress\" event. One can also detect all three load-ending conditions ( , , or ) using the event: req.addEventListener(\"loadend\", loadEnd); function loadEnd(e) { console.log( \"The transfer finished (although we don't know if it succeeded or not).\", ); } Note there is no way to be certain, from the information received by the event, as to which condition caused the operation to terminate; however, you can use this to handle tasks that need to be performed in all end-of-transfer scenarios.\n\nIf you conclude with an XMLHttpRequest receiving and , this means the request was not allowed to be performed. It was . A likely cause for this is when the origin (at the creation of the XMLHttpRequest) has changed when the XMLHttpRequest is subsequently . This case can happen, for example, when one has an XMLHttpRequest that gets fired on an onunload event for a window, the expected XMLHttpRequest is created when the window to be closed is still there, and finally sending the request (in other words, ) when this window has lost its focus and another window gains focus. The most effective way to avoid this problem is to set a listener on the new window's event which is set once the terminated window has its event triggered."
    },
    {
        "link": "https://stackoverflow.com/questions/21317672/getting-started-with-calling-apis-via-xmlhttprequest",
        "document": "I've just started to learn how to use APIs, but I'm having a little bit of trouble understanding exactly how to utilize them.\n\nI was able to write the following code thanks to some online documentation, but I have some questions about how to add to it:\n\nNow, when I run this code in my browser and I open the console, I get a dropdown with a whole bunch of stuff under it. First of all, how can I get the code to display JUST the response? I want the console to display just the XML to show when I run my code. Second of all, how do I parse the XML? Is there any way to get a value from an XML element and assign it to a JavaScript variable?"
    },
    {
        "link": "https://javascript.info/xmlhttprequest",
        "document": "is a built-in browser object that allows to make HTTP requests in JavaScript.\n\nDespite having the word “XML” in its name, it can operate on any data, not only in XML format. We can upload/download files, track progress and much more.\n\nRight now, there’s another, more modern method , that somewhat deprecates .\n\nIn modern web-development is used for three reasons:\n• Historical reasons: we need to support existing scripts with .\n• We need to support old browsers, and don’t want polyfills (e.g. to keep scripts tiny).\n• We need something that can’t do yet, e.g. to track upload progress.\n\nDoes that sound familiar? If yes, then all right, go on with . Otherwise, please head on to Fetch.\n\nXMLHttpRequest has two modes of operation: synchronous and asynchronous.\n\nLet’s see the asynchronous first, as it’s used in the majority of cases.\n\nTo do the request, we need 3 steps:\n• The constructor has no arguments.\n• Initialize it, usually right after : This method specifies the main parameters of the request:\n• – the URL to request, a string, can be URL object.\n• – if explicitly set to , then the request is synchronous, we’ll cover that a bit later.\n• , – login and password for basic HTTP auth (if required). Please note that call, contrary to its name, does not open the connection. It only configures the request, but the network activity only starts with the call of .\n• This method opens the connection and sends the request to server. The optional parameter contains the request body. Some request methods like do not have a body. And some of them like use to send the data to the server. We’ll see examples of that later.\n• These three events are the most widely used:\n• – when the request is complete (even if HTTP status is like 400 or 500), and the response is fully downloaded.\n• – when the request couldn’t be made, e.g. network down or invalid URL.\n• – triggers periodically while the response is being downloaded, reports how much has been downloaded. xhr.onload = function() { alert(`Loaded: ${xhr.status} ${xhr.response}`); }; xhr.onerror = function() { // only triggers if the request couldn't be made at all alert(`Network Error`); }; xhr.onprogress = function(event) { // triggers periodically // event.loaded - how many bytes downloaded // event.lengthComputable = true if the server sent Content-Length header // event.total - total number of bytes (if lengthComputable) alert(`Received ${event.loaded} of ${event.total}`); };\n\nHere’s a full example. The code below loads the URL at from the server and prints the progress:\n\nOnce the server has responded, we can receive the result in the following properties:\n\nWe can also specify a timeout using the corresponding property:\n\nIf the request does not succeed within the given time, it gets canceled and event triggers.\n\nWe can use property to set the response format:\n• – get as (for binary data, see chapter ArrayBuffer, binary arrays),\n• – get as (for binary data, see chapter Blob),\n• – get as XML document (can use XPath and other XML methods) or HTML document (based on the MIME type of the received data),\n\nFor example, let’s get the response as JSON:\n\nchanges between states as it progresses. The current state is accessible as .\n\nAll states, as in the specification:\n\nAn object travels them in the order → → → → … → → . State repeats every time a data packet is received over the network.\n\nWe can track them using event:\n\nYou can find listeners in really old code, it’s there for historical reasons, as there was a time when there were no and other events. Nowadays, handlers deprecate it.\n\nWe can terminate the request at any time. The call to does that:\n\nThat triggers event, and becomes .\n\nIf in the method the third parameter is set to , the request is made synchronously.\n\nIn other words, JavaScript execution pauses at and resumes when the response is received. Somewhat like or commands.\n\nHere’s the rewritten example, the 3rd parameter of is :\n\nIt might look good, but synchronous calls are used rarely, because they block in-page JavaScript till the loading is complete. In some browsers it becomes impossible to scroll. If a synchronous call takes too much time, the browser may suggest to close the “hanging” webpage.\n\nMany advanced capabilities of , like requesting from another domain or specifying a timeout, are unavailable for synchronous requests. Also, as you can see, no progress indication.\n\nBecause of all that, synchronous requests are used very sparingly, almost never. We won’t talk about them any more.\n\nallows both to send custom headers and read headers from the response.\n\nThere are 3 methods for HTTP-headers:\n\nTo make a POST request, we can use the built-in FormData object.\n\nWe create it, optionally fill from a form, more fields if needed, and then:\n• to submit the form to the server.\n\nThe form is sent with encoding.\n\nOr, if we like JSON more, then and send as a string.\n\nJust don’t forget to set the header , many server-side frameworks automatically decode JSON with it:\n\nThe method is pretty omnivore. It can send almost any , including and objects.\n\nThe event triggers only on the downloading stage.\n\nThat is: if we something, first uploads our data (the request body), then downloads the response.\n\nIf we’re uploading something big, then we’re surely more interested in tracking the upload progress. But doesn’t help here.\n\nThere’s another object, without methods, exclusively to track upload events: .\n\nIt generates events, similar to , but triggers them solely on uploading:\n• – upload timed out (if property is set).\n• – upload finished with either success or error.\n\ncan make cross-origin requests, using the same CORS policy as fetch.\n\nJust like , it doesn’t send cookies and HTTP-authorization to another origin by default. To enable them, set to :\n\nSee the chapter Fetch: Cross-Origin Requests for details about cross-origin headers.\n\nTypical code of the GET-request with :\n\nThere are actually more events, the modern specification lists them (in the lifecycle order):\n• – a data packet of the response has arrived, the whole response body at the moment is in .\n• – the request was canceled by the call .\n• – connection error has occurred, e.g. wrong domain name. Doesn’t happen for HTTP-errors like 404.\n• – the request was canceled due to timeout (only happens if it was set).\n\nThe , , , and events are mutually exclusive. Only one of them may happen.\n\nThe most used events are load completion ( ), load failure ( ), or we can use a single handler and check the properties of the request object to see what happened.\n\nWe’ve already seen another event: . Historically, it appeared long ago, before the specification settled. Nowadays, there’s no need to use it, we can replace it with newer events, but it can often be found in older scripts.\n\nIf we need to track uploading specifically, then we should listen to same events on object."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest_API",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nNote: This feature is available in Web Workers, except for Service Workers. The XMLHttpRequest API enables web apps to make HTTP requests to web servers and receive the responses programmatically using JavaScript. This in turn enables a website to update just part of a page with data from the server, rather than having to navigate to a whole new page. This practice is also sometimes known as AJAX. The Fetch API is the more flexible and powerful replacement for the XMLHttpRequest API. The Fetch API uses promises instead of events to handle asynchronous responses, integrates well with service workers, and supports advanced aspects of HTTP such as CORS. For these reasons, the Fetch API is usually used in modern web apps instead of .\n\nThe central interface in the XMLHttpRequest API is . To make an HTTP request:\n• Create a new instance by calling its constructor.\n• Initialize it by calling . At this point you provide the URL for the request, the HTTP method to use, and optionally, a username and password.\n• Attach event handlers to get the result of the request. For example, the event is fired when the request has successfully completed, and the event is fired in various error conditions. For an in-depth guide to the XMLHttpRequest API, see Using XMLHttpRequest.\n\nAn object representing fields and their values, which can be sent to a server using or . A subclass of which is passed into the , and which contains information about how much of the request has been completed. A superclass of both and , defining the events that are available in both of those interfaces. Represents the upload process for an HTTP upload. Provides events enabling code to track the progress of an upload."
    },
    {
        "link": "https://w3schools.com/xml/xml_http.asp",
        "document": "All modern browsers have a built-in XMLHttpRequest object to request data from a server.\n\nThe XMLHttpRequest object can be used to request data from a web server.\n\nThe XMLHttpRequest object is a developers dream, because you can:\n• Request data from a server - after the page has loaded\n• Receive data from a server - after the page has loaded\n• Send data to a server - in the background\n\nWhen you type a character in the input field below, an XMLHttpRequest is sent to the server, and some name suggestions are returned (from the server):\n\nThe example above is explained in the AJAX chapters of this tutorial.\n\nA common JavaScript syntax for using the XMLHttpRequest object looks much like this:\n\nvar xhttp = new XMLHttpRequest();\n\nxhttp.onreadystatechange = function() {\n\n if (this.readyState == 4 && this.status == 200) {\n\n // Typical action to be performed when the document is ready:\n\n document.getElementById(\"demo\").innerHTML = xhttp.responseText;\n\n }\n\n};\n\n xhttp.open(\"GET\", \"filename\", true);\n\n xhttp.send(); Try it Yourself »\n\nThe first line in the example above creates an XMLHttpRequest object:\n\nThe onreadystatechange property specifies a function to be executed every time the status of the XMLHttpRequest object changes:\n\nWhen readyState property is 4 and the status property is 200, the response is ready:\n\nThe responseText property returns the server response as a text string.\n\nThe text string can be used to update a web page:\n\nYou will learn a lot more about the XMLHttpRequest object in the AJAX chapters of this tutorial."
    }
]