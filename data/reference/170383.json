[
    {
        "link": "https://docs.python.org/3/library/datetime.html",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/python-datetime-module",
        "document": "In Python, date and time are not data types of their own, but a module named DateTime in Python can be imported to work with the date as well as time. Python Datetime module comes built into Python, so there is no need to install it externally.\n\nIn this article, we will explore How DateTime in Python works and what are the main classes of DateTime module in Python.\n\nPython Datetime module supplies classes to work with date and time. These classes provide several functions to deal with dates, times, and time intervals. Date and DateTime are an object in Python, so when you manipulate them, you are manipulating objects and not strings or timestamps.\n\nThe DateTime module is categorized into 6 main classes –\n• date – An idealized naive date, assuming the current Gregorian calendar always was, and always will be, in effect. Its attributes are year, month, and day. you can refer to –\n• time – An idealized time, independent of any particular day, assuming that every day has exactly 24*60*60 seconds. Its attributes are hour, minute, second, microsecond, and tzinfo. You can refer to –\n• date-time – It is a combination of date and time along with the attributes year, month, day, hour, minute, second, microsecond, and tzinfo. You can refer to –\n• timedelta – A duration expressing the difference between two date, time, or datetime instances to microsecond resolution. You can refer to –\n• tzinfo – It provides time zone information objects. You can refer to –\n• timezone – A class that implements the tzinfo abstract base class as a fixed offset from the UTC (New in version 3.2). You can refer to –\n\nThe date class is used to instantiate date objects in Python. When an object of this class is instantiated, it represents a date in the format YYYY-MM-DD. The constructor of this class needs three mandatory arguments year, month, and date.\n\nThe arguments must be in the following range –\n• None 1 <= day <= number of days in the given month and year\n\nNote – If the argument is not an integer it will raise a TypeError and if it is outside the range a ValueError will be raised.\n\nInitializing the constructor and passing arguments in the format year, month, and date.\n\nTo return the current local date today() function of the date class is used. today() function comes with several attributes (year, month, and day). These can be printed individually.\n\nWe can get the year, month, and date attributes from the date object using the year, month and date attribute of the date class.\n\nWe can create date objects from timestamps y=using the fromtimestamp() method. The timestamp is the number of seconds from 1st January 1970 at UTC to a particular date.\n\nWe can convert date object to a string representation using two functions isoformat() and strftime().\n\nThe time class creates the time object which represents local time, independent of any day.\n\nAll the arguments are optional. tzinfo can be None otherwise all the attributes must be integer in the following range –\n\nExample 2: Get hours, minutes, seconds, and microseconds\n\nAfter creating a time object, its attributes can also be printed separately.\n\nWe can convert time object to string using the isoformat() method.\n\nThe DateTime class contains information on both date and time. Like a date object, datetime assumes the current Gregorian calendar extended in both directions; like a time object, datetime assumes there are exactly 3600*24 seconds in every day.\n\nThe year, month, and day arguments are mandatory. tzinfo can be None, rest all the attributes must be an integer in the following range –\n• None 1 <= day <= number of days in the given month and year\n\nNote – Passing an argument other than integer will raise a TypeError and passing arguments outside the range will raise ValueError.\n\nAfter creating a DateTime object, its attributes can also be printed separately.\n\nYou can print the current date and time using the Datetime.now() function. now() function returns the current local date and time.\n\nWe can convert Datetime to string in Python using the datetime.strftime and datetime.isoformat methods.\n\nPython timedelta class is used for calculating differences in dates and also can be used for date manipulations in Python. It is one of the easiest ways to perform date manipulations.\n\nDifference between two date and times\n\nDate and Time differences can also be found using this class.\n\nFormatting DateTime can be very necessary as the date representation may differ from place to place. In some countries, it can be yyyy-mm-dd and in other countries, it can be dd-mm-yyyy. To format Python Datetime strptime and strftime functions can be used.\n\nA strftime() method converts the given date, time, or DateTime object to the string representation of the given format.\n\nNote: For more information, refer to strftime() method.\n\nThe strptime() creates a DateTime object from the given string.\n\nThe datetime.now() function contains no information regarding time zones. It only makes use of the current system time. Tzinfo is an abstract base class in Python. It cannot be directly instantiated. A concrete subclass must derive from this abstract class and implement the methods offered by it.\n\nThe tzinfo class instance can be provided to the DateTime and time object constructors. It is used in scenarios such as converting local time to UTC or accounting for daylight savings time.\n\nTimezones in DateTime can be used in the case where one might want to display time according to the timezone of a specific region. This can be done using the pytz module of Python. This module serves the date-time conversion functionalities and helps users serving international client bases."
    },
    {
        "link": "https://stackoverflow.com/questions/71734320/python-datetime-module-how-to-compare-datetime-time-against-datetime-now",
        "document": "I have two set times and I am trying to see if the current time is within those times. When I attempt to do this I get the error\n\n TypeError: '<=' not supported between instances of 'datetime.time' and 'str' Below is the code that retrieves this error, How would I properly compare between datetime and time?"
    },
    {
        "link": "https://medium.com/towards-data-science/introducing-pythons-datetime-module-13c5895b85a9",
        "document": "A time series is a sequence of data points indexed chronologically. They’re common components in scientific and financial datasets where observations are made over time.\n\nAlthough you and I recognize “11/11/1918” as a date, a computer sees this value as a text string. For Python to intelligently work with calendar dates, hours, minutes, seconds, and so on, these strings must be converted into special objects that are “aware” of the mechanics of the Gregorian calendar, the sexagesimal (base 60) time system, time zones, daylight-saving time, leap years, and more.\n\nNative Python supports times series through its module. I’ll introduce the basics of working with in this Quick Success Data Science article. In a subsequent article, I’ll cover how to handle time series using Python’s pandas data analysis library.\n\nPython can properly and efficiently manipulate time information by treating it as specific data types. Its built-in module includes , , and combined types that permit working with time zones, daylight saving time (DST), leap years, and different…"
    },
    {
        "link": "https://labex.io/tutorials/python-what-is-the-best-way-to-handle-date-and-time-calculations-in-python-395117",
        "document": "Python provides a powerful set of tools for working with dates and times, which are essential for a wide range of applications. In this section, we'll explore the fundamental concepts and usage of these tools.\n\nIn Python, the module is the primary way to work with dates and times. This module provides several classes, including , , , and , which allow you to represent and manipulate date and time information.\n\nThe class is the most commonly used, as it combines both date and time information into a single object. Here's an example of creating a object:\n\nThe and classes can be used to represent only the date or time components, respectively. The class is used to represent a duration or a difference between two dates or times.\n\nTime zones are an important aspect of working with dates and times, especially when dealing with data from different geographical locations. Python's module provides support for time zones through the library.\n\nHere's an example of working with time zones:\n\nIn this example, we create a object in the 'America/New_York' time zone, and then convert it to the UTC time zone.\n\nWhen working with dates and times, you often need to parse and format them for input and output purposes. Python's module provides several methods and functions for this purpose.\n\nHere's an example of parsing and formatting a date and time string:\n\nIn this example, we use the function to parse a date and time string, and the function to format a object as a string.\n\nBy understanding these fundamental concepts and techniques, you'll be well on your way to effectively handling dates and times in your Python applications."
    },
    {
        "link": "https://stackoverflow.com/questions/29965357/time-based-for-loop-in-python",
        "document": "Sure. Here's an iterator that gives you the time since start over and over until it reaches the end:\n\nWhen I run this, it outputs:\n\nIf you need some different value, just change the expression.\n\nIf you don't need any value… then you don't need a statement; your existing code is already perfectly readable, and a loop that iterates over and discards some meaningless values is just going to make it confusing."
    },
    {
        "link": "https://geeksforgeeks.org/loops-in-python",
        "document": "Loops in Python are used to repeat actions efficiently. The main types are For loops (counting through items) and While loops (based on conditions). Additionally, Nested Loops allow looping within loops for more complex tasks. While all the ways provide similar basic functionality, they differ in their syntax and condition-checking time. In this article, we will look at Python loops and understand their working with the help of examples.\n\nIn Python, a while loop is used to execute a block of statements repeatedly until a given condition is satisfied. When the condition becomes false, the line immediately after the loop in the program is executed.\n\nAll the statements indented by the same number of character spaces after a programming construct are considered to be part of a single block of code. Python uses indentation as its method of grouping statements.\n\nExample of Python While Loop:\n\nUsing else statement with While Loop in Python\n\nElse clause is only executed when our while condition becomes false. If we break out of the loop or if an exception is raised then it won’t be executed.\n\nSyntax of While Loop with else statement:\n\nThe code prints “Hello Geek” three times using a ‘while’ loop and then after the loop it prints “In Else Block” because there is an “else” block associated with the ‘while’ loop.\n\nIf we want a block of code to execute infinite number of times then we can use the while loop in Python to do so.\n\nThe code given below uses a ‘while’ loop with the condition (count == 0) and this loop will only run as long as count is equal to 0. Since count is initially set to 0, the loop will execute indefinitely because the condition is always true.\n\nNote: It is suggested not to use this type of loop as it is a never-ending infinite loop where the condition is always true and we have to forcefully terminate the compiler.\n\nFor loops are used for sequential traversal. For example: traversing a list or string or array etc. In Python, there is “for in” loop which is similar to foreach loop in other languages. Let us learn how to use for loops in Python for sequential traversals with examples.\n\nExplanation: This code prints the numbers from 0 to 3 (inclusive) using a for loop that iterates over a range from 0 to n-1 (where n = 4).\n\nExample with List, Tuple, String, and Dictionary Iteration Using for Loops in Python\n\nWe can use for loop to iterate lists, tuples, strings and dictionaries in Python.\n\nIterating by the Index of Sequences\n\nWe can also use the index of elements in the sequence to iterate. The key idea is to first calculate the length of the list and in iterate over the sequence within the range of this length.\n\nExplanation: This code iterates through each element of the list using its index and prints each element one by one. The range(len(list)) generates indices from 0 to the length of the list minus 1.\n\nUsing else Statement with for Loop in Python\n\nWe can also combine else statement with for loop like in while loop. But as there is no condition in for loop based on which the execution will terminate so the else block will be executed immediately after for block finishes execution.\n\nExplanation: The code iterates through the list and prints each element. After the loop ends it prints “Inside Else Block” as the else block executes when the loop completes without a break.\n\nPython programming language allows to use one loop inside another loop which is called nested loop. Following section shows few examples to illustrate the concept.\n\nThe syntax for a nested while loop statement in the Python programming language is as follows:\n\nA final note on loop nesting is that we can put any type of loop inside of any other type of loops in Python. For example, a for loop can be inside a while loop or vice versa.\n\nExplanation: In the above code we use nested loops to print the value of i multiple times in each row, where the number of times it prints i increases with each iteration of the outer loop. The print() function prints the value of i and moves to the next line after each row.\n\nLoop control statements change execution from their normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed. Python supports the following control statements.\n\nThe continue statement in Python returns the control to the beginning of the loop.\n\nExplanation: The continue statement is used to skip the current iteration of a loop and move to the next iteration. It is useful when we want to bypass certain conditions without terminating the loop.\n\nThe break statement in Python brings control out of the loop.\n\nExplanation: break statement is used to exit the loop prematurely when a specified condition is met. In this example, the loop breaks when the letter is either ‘e’ or ‘s’, stopping further iteration.\n\nWe use pass statement in Python to write empty loops. Pass is also used for empty control statements, functions and classes.\n\nExplanation: In this example, the loop iterates over each letter in ‘geeksforgeeks’ but doesn’t perform any operation, and after the loop finishes, the last letter (‘s’) is printed.\n\nHow for loop works internally in Python?\n\nBefore proceeding to this section, we should have a prior understanding of Python Iterators.\n\nFirstly, lets see how a simple for loops in Python looks like.\n\nExample: This Python code iterates through a list called fruits, containing “apple”, “orange” and “kiwi.” It prints each fruit name on a separate line, displaying them in the order they appear in the list.\n\nThis code iterates over each item in the fruits list and prints the item (fruit) on each iteration and the output will display each fruit on a new line.\n\nThis Python code manually iterates through a list of fruits using an iterator. It prints each fruit’s name one by one and stops when there are no more items in the list.\n\nWe can see that under the hood we are calling iter() and next() method.\n• None Difference between for loop and while loop in Python\n• None Use for Loop That Loops Over a Sequence in Python\n\nWhich loop is faster in Python?\n\nWhy is Python slow in loops?\n\nHow many loops are used in Python?\n\nIs for loop bad in Python?"
    },
    {
        "link": "https://realpython.com/python-for-loop",
        "document": "Python’s loop allows you to iterate over the items in a collection, such as lists, tuples, strings, and dictionaries. The loop syntax declares a loop variable that takes each item from the collection in each iteration. This loop is ideal for repeatedly executing a block of code on each item in the collection. You can also tweak loops further with features like , , and .\n\nBy the end of this tutorial, you’ll understand that:\n• Python’s loop iterates over items in a data collection, allowing you to execute code for each item.\n• To iterate from to , you use the construct.\n• To repeat code a number of times without processing the data of an iterable, use the construct.\n• To do index-based iteration, you can use for index, value in enumerate(iterable): to access both index and item.\n\nIn this tutorial, you’ll gain practical knowledge of using loops to traverse various collections and learn Pythonic looping techniques. Additionally, you’ll learn how to handle exceptions and how to use asynchronous iterations to make your Python code more robust and efficient.\n\nGetting Started With the Python Loop In programming, loops are control flow statements that allow you to repeat a given set of operations a number of times. In practice, you’ll find two main types of loops:\n• loops are mostly used to iterate a known number of times, which is common when you’re processing data collections with a specific number of data items.\n• loops are commonly used to iterate an unknown number of times, which is useful when the number of iterations depends on a given condition. Python has both of these loops and in this tutorial, you’ll learn about loops. In Python, you’ll generally use loops when you need to iterate over the items in a data collection. This type of loop lets you traverse different data collections and run a specific group of statements on or with each item in the input collection. In Python, loops are compound statements with a header and a code block that runs a predefined number of times. The basic syntax of a loop is shown below: In this syntax, is the loop variable. In each iteration, this variable takes the value of the current item in , which represents the data collection you need to iterate over. The loop body can consist of one or more statements that must be indented properly. Here’s a more detailed breakdown of this syntax:\n• is the keyword that initiates the loop header.\n• is a variable that holds the current item in the input iterable.\n• is a keyword that connects the loop variable with the iterable.\n• is a data collection that can be iterated over.\n• consists of one or more statements to execute in each iteration. Here’s a quick example of how you can use a loop to iterate over a list: In this example, is the loop variable, while the list is the target collection. Each time through the loop, takes on a successive item from . In this loop, the body consists of a call to that displays the value on the screen. This loop runs once for each item in the target iterable. The way the code above is written is the Pythonic way to write it. However, what’s an iterable anyway? In Python, an iterable is an object—often a data collection—that can be iterated over. Common examples of iterables in Python include lists, tuples, strings, dictionaries, and sets, which are all built-in data types. You can also have custom classes that support iteration. Note: Python has both iterables and iterators. Iterables support the iterable protocol consisting of the special method. Similarly, iterators support the iterator protocol that’s based on the and special methods. Both iterables and iterators can be iterated over. All iterators are iterables, but not all iterables are iterators. Python iterators play a fundamental role in loops because they drive the iteration process. A deeper discussion on iterables and iterators is beyond the scope of this tutorial. However, to learn more about them, check out the Iterators and Iterables in Python: Run Efficient Iterations tutorial. You can also have a loop with multiple loop variables: In this loop, you have two loop variables, and . Note that to use this syntax, you just need to provide a tuple of loop variables. Also, you can have as many loop variables as you need as long as you have the correct number of items to unpack into them. You’ll also find this pattern useful when iterating over dictionary items or when you need to do parallel iteration. Sometimes, the input iterable may be empty. In that case, the loop will run its header once but won’t execute its body: In this example, the target iterable is an empty list. The loop checks whether the iterable has items. If that’s the case, then the loop runs once for each item. If the iterable has no items, then the loop body doesn’t run, and the program’s execution flow jumps onto the statement after the loop. Now that you know the basic syntax of loops, it’s time to dive into some practical examples. In the following section, you’ll learn how to use loops with the most common built-in data collections in Python.\n\nWhen writing Python code, you’ll often need to iterate over built-in data types such as lists, tuples, strings, numeric ranges, dictionaries, and sets. All of them support iteration, and you can feed them into a loop. In the next sections, you’ll learn how to tackle this requirement in a Pythonic way. When it comes to iterating over sequence data types like lists, tuples, strings, and ranges, the iteration happens in the same order that the items appear in the sequence. Consider the following example where you iterate over the numbers in a list: In this example, the iteration goes through the list in the definition order, starting with and ending with . Note that to iterate over a sequence in Python, you don’t need to be aware of the index of each item as in other languages where loops often rely on indices. Often, you use plural nouns to name lists. This naming practice allows you to use singular nouns as the loop variable, making your code descriptive and readable. Note: To learn more about using lists, check out Python’s Data Type: A Deep Dive With Examples. You’ll note the same behavior with other built-in sequences: In these examples, you iterate over a tuple, string, and numeric range. Again, the loop traverses the sequence in the order of definition. Note: For more information about tuples, strings, and ranges, you can check out the following tutorials: Tuples are often used to represent rows of data. In the example above, the tuple holds data about a person. You can iterate over each field using a readable loop. When it comes to iterating over string objects, the loop lets you process the string on a character-by-character basis. Finally, iterating over a numeric range is sometimes a requirement, especially when you need to iterate a given number of times and need control over the consecutive index. When traversing dictionaries with a loop, you’ll find that you can iterate over the keys, values, and items of the dictionary at hand. Note: To learn more about dictionary iteration, check out the How to Iterate Through a Dictionary in Python tutorial. You’ll have two different ways to iterate over the keys of a dictionary. You can either use: The following examples show how to use these two approaches: In these examples, you first iterate over the keys of a dictionary using the dictionary directly in the loop header. In the second loop, you use the method to iterate over the keys. While both approaches are equivalent, the first one is more commonly used, whereas the second might be more readable and explicit. In both loops, you can access the dictionary values using the keys: To access the values in this type of iteration, you can use the original dictionary and a key lookup operation, as shown in the highlighted line. You can use the method to feed the loop when you need to iterate over the values of a dictionary: The method lets you traverse the values in the target dictionary. In this example, you iterate over team names one by one. Note that when you use the method, you can’t access the dictionary keys. Finally, iterating over both keys and values in a Python dictionary is a common requirement. In this case, the recommended and most Pythonic approach is to use the method in a loop like the following: When iterating over keys and values this way, you typically use a tuple of loop variables. The first variable will get the key, while the second will get the associated value. In this example, you have the and variables, which make the code clear and readable. When it comes to iterating over sets, you only have to keep in mind that sets are unordered data types. This means that looping in order isn’t guaranteed: As you can see, the loop goes through the elements of your set in a different order than they were inserted. So, you can’t rely on the order of the elements when traversing sets in Python.\n\nThe Python loop has some advanced features that make it flexible and powerful. These features can be helpful when you need to fine-tune the loop to meet specific execution flows. These features include the and statements and the clause, which you’ll learn about in the following sections. You’ll also learn that loops can be nested inside one another. This feature can be pretty useful in situations where you need to iterate over nested data structures like lists of lists. The statement immediately exits the loop and jumps to the first statement after the loop. For example, say that you want to write a loop to determine whether a number is in a list. To avoid unnecessary work, the loop should terminate once it finds the target value. You can do this with the statement: In this example, the statement jumps out of the loop as soon as the target number is found. The remaining values, and , aren’t processed. You can think of the statement as a way to short-circuit the loop execution once you’ve gotten the desired result. It’s important to note that it makes little sense to have statements outside conditionals. Suppose you include a statement directly in the loop body without wrapping it in a conditional. In that case, the loop will terminate in the first iteration, potentially without running the entire loop body. The statement terminates the current iteration and proceeds to the next one. For example, if you have a list of numbers and only want to process the even ones, you can use a statement to skip the odd numbers: In this example, the code that processes the numbers is only reached if the number is even. Otherwise, the statement skips that code and jumps right into the next iteration. Again, it doesn’t make much sense to have a statement without wrapping it in a conditional. If you do so, the code after the statement will be unreachable and never run. In Python, loops can have an clause at the end. The clause will only run if the loop terminates because of the exhaustion of the input iterable. This feature is useful when you have a statement that can terminate the loop in certain situations. If the loop doesn’t break, then you can run additional code in the clause. To illustrate, say that you want to continue improving the loop that determines whether a number is in a list. You’d like to explicitly inform the user if the number isn’t in the list. You can do this with the clause: The clause won’t run if the loop breaks out with the statement. It only runs if the loop terminates normally, allowing you to inform the user that the target number wasn’t found. It doesn’t make sense to have an clause in a loop that doesn’t have a statement. In that case, placing the block’s content after the loop—without indentation—will work the same and be cleaner. You can also have nested loops. In the example below, you create a multiplication table that shows the products of all combinations of integers up to ten using nested loops. The outer loop iterates over the numbers between and , and the inner loop calculates and prints the products: In this example, you use two nested loops. Together, they create a two-dimensional multiplication table. First, you loop over the numbers from one up to and including ten. These represent the rows in the table, and you can see those numbers at the beginning of each row. In the inner loop, you calculate the products for the current by iterating from the itself up to its tenth multiple. Then, you format each product using the format specifier. This ensures the table is nicely aligned. By setting to an empty string, you skip the newline until the products on the current row are printed. After printing all products for a row, you use without arguments to move to the next row.\n\nWhen people switch from other programming languages to Python, they often write loops like they did in their previous language. This practice makes Python code look odd and hard to read. In the following sections, you’ll explore some looping techniques, practices, and tips that are considered Pythonic. These techniques can make your Python code look clearer, more elegant, and more efficient. Iterating With Indices: The Pythonic Way Sometimes, you need to use the indices of items when you iterate over a sequence with a Python loop. Up to this point, you’ve seen examples where you can access the items but don’t know their corresponding indices. To get both the item and its index, you can end up writing a loop like the one shown in the following example: This loop gets the job done, but it’s not as clean or readable as you’d expect from Python code. Fortunately, there’s a better way—the built-in function: The function takes an iterable as an argument and generates tuples of the form . Note that the loop reads almost like plain English, which makes your code way more Pythonic than the previous version using . Note: To learn more about working with , check out the Python : Simplify Loops That Need Counters tutorial. The function also takes an optional argument called that lets you tweak the initial value. This feature is useful when you need to create counts. Consider the following example that mimics an option menu for a command-line application: In this example, instead of using to produce zero-based indices, you start the count at . From the end user’s perspective, starting the menu at is the natural way to go. Looping Over Several Iterables in Parallel Looping through two or more iterables in parallel may be another common task you encounter in Python programming. To do this, you can use the built-in function, which takes two or more iterables and yields tuples that combine items from each iterable. Note: To learn more about , check out the Using the Python zip() Function for Parallel Iteration tutorial. Consider the following toy example: In this example, you use to create an iterator that produces tuples of the form . In this case, the values are taken from , and the values are taken from . There may be times when you need to iterate over multiple iterables sequentially in a single loop. In such cases, you can use the function from Python’s module. Note: To learn more about the module and the tools it provides, check out the Python By Example tutorial. For example, say that you have several lists of numbers and want to calculate the square of each number in all lists. You can use as follows: This loops over all three lists in sequence and prints the square of each value. You can also use to work through a list of lists. Say that you, again, need to process each value in a sequence and calculate its square: In this example, you use to iterate over the rows of the matrix. To feed the rows into , you use the unpacking operator ( ). Inside the loop, you calculate and print the square of each value. Using , like in this example, essentially flattens the matrix into a single iterable, helping you avoid a nested loop, which can be difficult to read and understand in some contexts. Iteration is all about repeating some fragment of code multiple times. As you’ve learned so far, loops are designed to repeat a given set of actions on the items of an iterable. However, you can also use this type of loop to quickly iterate a specific number of times. This is useful when you need to repeat a bunch of statements, but they don’t operate on the items of an iterable. Here’s a fun example about Penny and Sheldon to illustrate this: This loop runs three times and repeats a series of statements that don’t operate on any iterable. Note that the loop variable is a single underscore character in this example. This variable name communicates that you don’t need to use the loop variable inside the loop. It’s a throwaway variable. With this looping construct that takes advantage of , you have full control over the number of times your code runs. Iterating over the items of an iterable in reverse or sorted order is also a common requirement in programming. To achieve this, you can combine a loop with the built-in or function, respectively. Note: To learn more about and , check out the following tutorials:\n• Reverse Strings in Python: , Slicing, and More\n• How to Use and in Python For example, say that you’re working on a text editor and want to implement a basic Undo option. You can implement it with the function and a loop like the following: In this example, you have a list of hypothetical user actions in a text editor. The actions are stored in a list from oldest to newest. To implement the Undo operation, you need to reverse the actions, which you do with . To iterate in sorted order, say that you have a dictionary that maps student names to their corresponding average grades. You need to create a quick report and want to sort the data from highest to lowest grades. For this, you can do something like the following: The function returns a list of sorted values. In this example, you sort the dictionary by its values in ascending order. To do this, you use a function that takes a two-value tuple as an argument and returns the second item, which has an index of . You also set the argument to so that the function stores the data in reverse order. In this case, this means that the grades are ordered in descending order. The loop iterates over the sorted data and generates a nicely formatted report using an f-string with a custom format specifier.\n\nWhen working with loops in your Python code, you may encounter some issues related to incorrect ways to use this tool. Some of the most common bad practices and incorrect assumptions include:\n• Modifying the loop collection or iterable during iteration\n• Changing the loop variable to affect the underlying collection\n• Ignoring possible exceptions that may occur In the following sections, you’ll explore these pitfalls and how to avoid them in your loops. Python has mutable collections, such as lists and dictionaries, that you can modify in place. You may want to change a list while looping over it. In this situation, you need to distinguish between safe and unsafe changes. For example, say that you have a list of names and want to convert them into uppercase. You may think of doing something like the following: In this example, you only change the existing items in the list without adding or removing any. This operation is safe. However, modifying a mutable iterable like a list while iterating over it always raises a warning. Issues may appear when you add or remove items from a list while iterating over it. To understand why this is best avoided, say that you want to remove all the even numbers from a list. You might write the following code: After running the loop, some even numbers remain, even though you expected the list to be empty. On the first iteration, is removed, and the list shifts left, becoming . The loop then jumps to the next item, skipping and processing instead. Then is removed, and the list shifts again, becoming . The iteration ends before reaching . When you need to resize a list during iteration like in the example above, it’s recommended to create a copy of the list: The slicing operator ( ) with no indices creates a copy of the original list for iteration purposes. The loop traverses the copy while removing values from the original list. In some cases, creating a copy of the input list isn’t enough. Say that on top of removing even numbers, you want to calculate the square of odd numbers. You might modify the previous loop as shown in the following code: This time, you use to generate index-item pairs. Then, you think of using the index to update the value of a given item. However, the code fails with a exception. Creating a copy of the input list isn’t enough in this case. You’d have to make a separate list to store the result: In this new loop implementation, you’re using a new list to store the result. Because of this, you don’t have to remove items anymore. You add the square values to the end of the new list using the method. Python doesn’t allow you to add or remove items from a dictionary while you’re iterating through it: If you try to expand or shrink a dictionary during iteration, you get a exception. Again, you can work around this by creating a copy of the dictionary using the method or by building a new dictionary with the resulting data. Changing the loop variable in the loop body doesn’t have an effect on the original data: In this example, the highlighted line changes the loop variable, . This change doesn’t affect the original data in your list of names. The loop variable is just a temporary reference to the current item in the iterable, and reassigning it doesn’t affect the loop iterable. If an exception occurs in a loop body and isn’t handled, the loop will terminate prematurely, skipping subsequent iterations. This result can generate unexpected issues, especially when you rely on the loop to process data, perform logging, or run cleanup actions in each iteration. As an example, say that you want to process some text files in a loop: : [Errno 2] No such file or directory: 'file1.txt' In this example, none of the files exist in your working directory. The loop tries to process the first file and fails with a exception. Because the exception wasn’t handled properly, the loop terminates in the first iteration, skipping the rest of the files in the list. To avoid this behavior, you need to catch and handle the exception: In this new implementation, the loop catches any exception and prints an error message to the screen. The loop runs entirely without abrupt interruptions."
    },
    {
        "link": "https://mysteryweevil.medium.com/mastering-looping-best-practices-for-writing-loops-in-python-84d59e283e40",
        "document": "Looping is a fundamental aspect of programming, allowing developers to iterate over data, perform repetitive tasks, and automate processes efficiently. In Python, loops are versatile and powerful constructs that come in various forms, each suitable for different scenarios.\n\nHowever, writing efficient and readable loops requires adherence to best practices to avoid common pitfalls and optimize performance.\n\nIn this article, we’ll explore the best practices for writing loops in Python, accompanied by up-to-date code examples to illustrate each concept.\n\nPython offers several looping constructs, including loops, loops, and comprehensions. When deciding which loop to use, consider the nature of the task and the type of data you're working with.\n• For Loops: Ideal for iterating over sequences such as lists, tuples, or strings when the number of iterations is known."
    },
    {
        "link": "https://stackoverflow.com/questions/53359210/how-to-reduce-execution-time-in-algorithm-by-replacing-for-loop-in-python",
        "document": "I'm trying to solve an algorithm problem,consider the following list:\n\nin this problem I have to find the average of the elements up to index i:\n\nthe final result should be stored in a list:\n\nthis is my code so far:\n\nIt works fine the problem is that when I submitted it, I faced a time limit execution.I think the problem is the for loop since it takes a lot of time when is more than ten-thousand. Previously I used to do the averaging but that took a lot of time too, when I turned that to the algorithm got faster(It solved more test cases).I think that if instead of an for loop I use another function(like lambda) then the problem is solved.So do you think there is a way? thank you for your time."
    }
]