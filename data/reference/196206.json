[
    {
        "link": "https://cryptojs.gitbook.io/docs",
        "document": "CryptoJS is a growing collection of standard and secure cryptographic algorithms implemented in JavaScript using best practices and patterns. They are fast, and they have a consistent and simple interface.\n\nIf you have a problem with CryptoJS, if you want to discuss new features, or if you want to contribute to the project, you can visit the CryptoJS discussion group.\n\nMD5 is a widely used hash function. It's been used in a variety of security applications and is also commonly used to check the integrity of files. Though, MD5 is not collision resistant, and it isn't suitable for applications like SSL certificates or digital signatures that rely on this property.\n\nThe SHA hash functions were designed by the National Security Agency (NSA). SHA-1 is the most established of the existing SHA hash functions, and it's used in a variety of security applications and protocols. Though, SHA-1's collision resistance has been weakening as new attacks are discovered or improved.\n\nSHA-256 is one of the four variants in the SHA-2 set. It isn't as widely used as SHA-1, though it appears to provide much better security.\n\nSHA-512 is largely identical to SHA-256 but operates on 64-bit words rather than 32.\n\nCryptoJS also supports SHA-224 and SHA-384, which are largely identical but truncated versions of SHA-256 and SHA-512 respectively.\n\nSHA-3 is the winner of a five-year competition to select a new cryptographic hash algorithm where 64 competing designs were evaluated.\n\nNOTE: I made a mistake when I named this implementation SHA-3. It should be named Keccak[c=2d]. Each of the SHA-3 functions is based on an instance of the Keccak algorithm, which NIST selected as the winner of the SHA-3 competition, but those SHA-3 functions won't produce hashes identical to Keccak.\n\nSHA-3 can be configured to output hash lengths of one of 224, 256, 384, or 512 bits. The default is 512 bits.\n\nThe hash algorithms accept either strings or instances of CryptoJS.lib.WordArray. A WordArray object represents an array of 32-bit words. When you pass a string, it's automatically converted to a WordArray encoded as UTF-8.\n\nThe hash you get back isn't a string yet. It's a WordArray object. When you use a WordArray object in a string context, it's automatically converted to a hex string.\n\nYou can convert a WordArray object to other formats by explicitly calling the toString method and passing an encoder.\n\nKeyed-hash message authentication codes (HMAC) is a mechanism for message authentication using cryptographic hash functions.\n\nHMAC can be used in combination with any iterated cryptographic hash function.\n\nPBKDF2 is a password-based key derivation function. In many applications of cryptography, user security is ultimately dependent on a password, and because a password usually can't be used directly as a cryptographic key, some processing is required.\n\nA salt provides a large set of keys for any given password, and an iteration count increases the cost of producing keys from a password, thereby also increasing the difficulty of attack.\n\nThe Advanced Encryption Standard (AES) is a U.S. Federal Information Processing Standard (FIPS). It was selected after a 5-year process where 15 competing designs were evaluated.\n\nCryptoJS supports AES-128, AES-192, and AES-256. It will pick the variant by the size of the key you pass in. If you use a passphrase, then it will generate a 256-bit key.\n\nDES is a previously dominant algorithm for encryption, and was published as an official Federal Information Processing Standard (FIPS). DES is now considered to be insecure due to the small key size.\n\nTriple DES applies DES three times to each block to increase the key size. The algorithm is believed to be secure in this form.\n\nRabbit is a high-performance stream cipher and a finalist in the eSTREAM Portfolio. It is one of the four designs selected after a 3 1/2-year process where 22 designs were evaluated.\n\nRC4 is a widely-used stream cipher. It's used in popular protocols such as SSL and WEP. Although remarkable for its simplicity and speed, the algorithm's history doesn't inspire confidence in its security.\n\nIt was discovered that the first few bytes of keystream are strongly non-random and leak information about the key. We can defend against this attack by discarding the initial portion of the keystream. This modified algorithm is traditionally called RC4-drop.\n\nBy default, 192 words (768 bytes) are dropped, but you can configure the algorithm to drop any number of words.\n\nAnd CryptoJS supports the following padding schemes:\n\nFor the plaintext message, the cipher algorithms accept either strings or instances of CryptoJS.lib.WordArray.\n\nFor the key, when you pass a string, it's treated as a passphrase and used to derive an actual key and IV. Or you can pass a WordArray that represents the actual key. If you pass the actual key, you must also pass the actual IV.\n\nFor the ciphertext, the cipher algorithms accept either strings or instances of CryptoJS.lib.CipherParams. A CipherParams object represents a collection of parameters such as the IV, a salt, and the raw ciphertext itself. When you pass a string, it's automatically converted to a CipherParams object according to a configurable format strategy.\n\nThe plaintext you get back after decryption is a WordArray object. See Hashing's Output for more detail.\n\nThe ciphertext you get back after encryption isn't a string yet. It's a CipherParams object. A CipherParams object gives you access to all the parameters used during encryption. When you use a CipherParams object in a string context, it's automatically converted to a string according to a format strategy. The default is an OpenSSL-compatible format.\n\nYou can define your own formats in order to be compatible with other crypto implementations. A format is an object with two methods— stringify and parse—that converts between CipherParams objects and ciphertext strings.\n\nHere's how you might write a JSON formatter:\n\nCryptoJS can convert from encoding formats such as Base64, Latin1 or Hex to WordArray objects and vice-versa."
    },
    {
        "link": "https://dev.to/shubhamkhan/beginners-guide-to-aes-encryption-and-decryption-in-javascript-using-cryptojs-592",
        "document": "In today’s digital world, safeguarding sensitive information is critical. One of the most trusted ways to secure data is by using AES (Advanced Encryption Standard). This guide will walk you through how to use AES for encryption and decryption in JavaScript with the help of the CryptoJS library, making it both secure and easy to implement.\n\nBy the end of this post, you’ll have a solid understanding of how to encrypt data and decrypt it when needed. Let’s dive in!\n\nIn an age of increasing cyber threats, encryption is no longer optional—it’s essential. Whether you're building a simple web app or a complex platform, AES encryption helps ensure that your users' data remains safe and secure.\n\nAES is a symmetric encryption method, meaning the same key is used to encrypt and decrypt data. It's a well-regarded standard due to its speed and security, making it a popular choice for protecting sensitive data like passwords, personal information, and financial details.\n\nWhy You Need Encryption\n\nData breaches, phishing attacks, and other threats make encryption essential for any web or mobile app that handles sensitive information. With AES encryption, even if an unauthorized person intercepts your data, they won’t be able to read it without the secret key.\n\nCryptoJS is a robust JavaScript library that offers a range of cryptographic functionalities, including encryption, decryption, and hashing. It’s widely used for implementing AES encryption in web development, thanks to its simplicity and performance.\n\nEncryption and decryption using AES involve the following steps:\n• Plain text is transformed into unreadable ciphertext using a secret key.\n• The encrypted data is then encoded into a safe format for transmission.\n• The ciphertext is decrypted back into the original plain text using the same secret key.\n• Both processes ensure the confidentiality and integrity of the data being exchanged.\n\nHere’s a step-by-step guide to creating AES encryption and decryption functions in JavaScript using CryptoJS. We'll utilize environment variables to securely store our secret key.\n• The Initialization Vector (IV) is randomly generated for each encryption, adding an extra layer of security.\n• The encryption process uses AES in CBC (Cipher Block Chaining) mode, making it more secure by using the IV along with the secret key.\n• The result is encoded in Base64 for safe transmission in URLs.\n• Decryption reverses the encryption process by using the same IV and secret keys that were used for encryption.\n• If the decryption fails due to an incorrect key or other issues, the error is logged and null is returned.\n\nSecret Key: The key that encrypts and decrypts the data. This should be stored securely in environment variables, not hard-coded in your application.\n\n Initialization Vector (IV): A unique value that makes the encryption more secure. It ensures that even the same input text results in different ciphertexts every time.\n\n Base64 Encoding: After encryption, the ciphertext is Base64 encoded to make it suitable for storage or transmission, such as in URLs or APIs.\n\nAES encryption provides several advantages:\n\n Performance: AES is highly optimized for speed, making it ideal for web applications.\n\n Security: AES has been rigorously tested and is widely regarded as one of the most secure encryption methods.\n\n Simplicity: With libraries like CryptoJS, implementing AES encryption in JavaScript is straightforward and efficient.\n• Use environment variables to store sensitive data like your secret key. Never hard-code secrets in your application code.\n• Always generate a new IV for each encryption operation to ensure the highest level of security.\n• Handle errors properly during decryption to prevent issues like data loss or unauthorized access.\n\nAES encryption using CryptoJS is a powerful and efficient way to protect sensitive data in your JavaScript applications. With the steps outlined above, you can easily implement encryption and decryption for secure communication or data storage.\n\nThis guide provides you with all the tools you need to secure your app and protect your users’ data. By following best practices, you can confidently handle sensitive information, knowing it’s encrypted and secure.\n\nNow that you’ve learned the basics of AES encryption, it’s time to put it into practice in your projects. Keep your data secure, and your users will trust your application more!"
    },
    {
        "link": "https://stackoverflow.com/questions/39311514/how-to-decrypt-aes-with-cryptojs",
        "document": "I'm trying for some time to decrypt a message in AES that use a Java app , but it never works . Can someone help me?\n\nBut it is always generated a different ciphertext, never the same from my database."
    },
    {
        "link": "https://github.com/brix/crypto-js/blob/develop/docs/QuickStartGuide.wiki",
        "document": "MD5 is a widely used hash function. It's been used in a variety of security applications and is also commonly used to check the integrity of files. Though, MD5 is not collision resistant, and it isn't suitable for applications like SSL certificates or digital signatures that rely on this property.\n\nThe SHA hash functions were designed by the National Security Agency (NSA). SHA-1 is the most established of the existing SHA hash functions, and it's used in a variety of security applications and protocols. Though, SHA-1's collision resistance has been weakening as new attacks are discovered or improved.\n\nSHA-256 is one of the four variants in the SHA-2 set. It isn't as widely used as SHA-1, though it appears to provide much better security.\n\nSHA-512 is largely identical to SHA-256 but operates on 64-bit words rather than 32.\n\nCryptoJS also supports SHA-224 and SHA-384, which are largely identical but truncated versions of SHA-256 and SHA-512 respectively.\n\nSHA-3 is the winner of a five-year competition to select a new cryptographic hash algorithm where 64 competing designs were evaluated.\n\nSHA-3 can be configured to output hash lengths of one of 224, 256, 384, or 512 bits. The default is 512 bits.\n\nThe hash algorithms accept either strings or instances of CryptoJS.lib.WordArray. A WordArray object represents an array of 32-bit words. When you pass a string, it's automatically converted to a WordArray encoded as UTF-8.\n\nThe hash you get back isn't a string yet. It's a WordArray object. When you use a WordArray object in a string context, it's automatically converted to a hex string.\n\nYou can convert a WordArray object to other formats by explicitly calling the toString method and passing an encoder.\n\nKeyed-hash message authentication codes (HMAC) is a mechanism for message authentication using cryptographic hash functions.\n\nHMAC can be used in combination with any iterated cryptographic hash function.\n\nPBKDF2 is a password-based key derivation function. In many applications of cryptography, user security is ultimately dependent on a password, and because a password usually can't be used directly as a cryptographic key, some processing is required.\n\nA salt provides a large set of keys for any given password, and an iteration count increases the cost of producing keys from a password, thereby also increasing the difficulty of attack.\n\nThe Advanced Encryption Standard (AES) is a U.S. Federal Information Processing Standard (FIPS). It was selected after a 5-year process where 15 competing designs were evaluated.\n\nCryptoJS supports AES-128, AES-192, and AES-256. It will pick the variant by the size of the key you pass in. If you use a passphrase, then it will generate a 256-bit key.\n\nDES is a previously dominant algorithm for encryption, and was published as an official Federal Information Processing Standard (FIPS). DES is now considered to be insecure due to the small key size.\n\nTriple DES applies DES three times to each block to increase the key size. The algorithm is believed to be secure in this form.\n\nRabbit is a high-performance stream cipher and a finalist in the eSTREAM Portfolio. It is one of the four designs selected after a 3 1/2-year process where 22 designs were evaluated.\n\nRC4 is a widely-used stream cipher. It's used in popular protocols such as SSL and WEP. Although remarkable for its simplicity and speed, the algorithm's history doesn't inspire confidence in its security.\n\nIt was discovered that the first few bytes of keystream are strongly non-random and leak information about the key. We can defend against this attack by discarding the initial portion of the keystream. This modified algorithm is traditionally called RC4-drop.\n\nBy default, 192 words (768 bytes) are dropped, but you can configure the algorithm to drop any number of words.\n\nAnd CryptoJS supports the following padding schemes:\n\nFor the plaintext message, the cipher algorithms accept either strings or instances of CryptoJS.lib.WordArray.\n\nFor the key, when you pass a string, it's treated as a passphrase and used to derive an actual key and IV. Or you can pass a WordArray that represents the actual key. If you pass the actual key, you must also pass the actual IV.\n\nFor the ciphertext, the cipher algorithms accept either strings or instances of CryptoJS.lib.CipherParams. A CipherParams object represents a collection of parameters such as the IV, a salt, and the raw ciphertext itself. When you pass a string, it's automatically converted to a CipherParams object according to a configurable format strategy.\n\nThe plaintext you get back after decryption is a WordArray object. See Hashers' Output for more detail.\n\nThe ciphertext you get back after encryption isn't a string yet. It's a CipherParams object. A CipherParams object gives you access to all the parameters used during encryption. When you use a CipherParams object in a string context, it's automatically converted to a string according to a format strategy. The default is an OpenSSL-compatible format.\n\nYou can define your own formats in order to be compatible with other crypto implementations. A format is an object with two methods—stringify and parse—that converts between CipherParams objects and ciphertext strings.\n\nHere's how you might write a JSON formatter:\n\nCryptoJS can convert from encoding formats such as Base64, Latin1 or Hex to WordArray objects and vica versa."
    },
    {
        "link": "https://npmjs.com/package/crypto-js",
        "document": "Active development of CryptoJS has been discontinued. This library is no longer maintained.\n\nNowadays, NodeJS and modern browsers have a native module. The latest version of CryptoJS already uses the native Crypto module for random number generation, since is not crypto-safe. Further development of CryptoJS would result in it only being a wrapper of native Crypto. Therefore, development and maintenance has been discontinued, it is time to go for the native module.\n\nIncluding all libraries, for access to extra methods:\n\nIncluding all libraries, for access to extra methods:\n\nChange default hash algorithm and iteration's for PBKDF2 to prevent weak security by using the default configuration.\n\nInclude the browser field in the released package.json.\n\nThis is an update including breaking changes for some environments.\n\nIn this version has been replaced by the random methods of the native crypto module.\n\nFor this reason CryptoJS might not run in some JavaScript environments without native crypto module. Such as IE 10 or before or React Native.\n\nRollback, is the same as .\n\nThe move of using native secure crypto module will be shifted to a new version. As it is a breaking change the impact is too big for a minor release.\n\nThe usage of the native crypto module has been fixed. The import and access of the native crypto module has been improved.\n\nIn this version has been replaced by the random methods of the native crypto module.\n\nFor this reason CryptoJS might does not run in some JavaScript environments without native crypto module. Such as IE 10 or before.\n\nIf it's absolute required to run CryptoJS in such an environment, stay with version. Encrypting and decrypting stays compatible. But keep in mind versions still use which is cryptographically not secure, as it's not random enough.\n\nThis version came along with .\n\nDO NOT USE THIS VERSION! Please, go for a newer version!\n\nThe are based on the original CryptoJS, wrapped in CommonJS modules."
    },
    {
        "link": "https://dvmhn07.medium.com/jwt-authentication-in-node-js-a-practical-guide-c8ab1b432a49",
        "document": "Implementing authentication for a web application using Node.js typically involves several steps. “Token-based authentication” is a common approach for securing web applications. It involves generating and validating tokens (usually JSON Web Tokens, JWTs) to authenticate users. Here’s how you can implement token-based authentication in a Node.js web application with an example and coding sample:\n\n1. Choose an Authentication Strategy:\n\n Decide on the type of authentication you want to implement. Common options include username/password, social media login (e.g., using OAuth), or token-based authentication (e.g., JWT).\n\n2. Set Up Your Node.js Project:\n\n Create a new Node.js project or use an existing one. You can initialize a new project using npm or yarn:\n\n3. Install Required Packages:\n\n Depending on your chosen authentication strategy, you may need to install relevant packages. For example, if you’re using JWT, you can install the ‘jsonwebtoken’ package:\n\n4. Create a User Model:\n\n Define a user model to store user data in your database (e.g., MongoDB, PostgreSQL, or MySQL). You can use an ORM like Mongoose (for MongoDB) or Sequelize (for SQL databases). Here’s a simplified example for MongoDB and Mongoose:\n\n5. Create Routes and Controllers:\n\n Set up routes and controllers for user registration, login, and authentication. Here’s a basic example using Express.js:\n\n6. Protect Routes:\n\n Implement middleware to protect routes that require authentication. For example, you can use a middleware function to verify JWT tokens:\n\n7. Use Authentication Middleware:\n\n Apply the authentication middleware to protect specific routes in your application:\n\n8. Start Your Express Application:\n\n Set up your main application file and start the Express server:\n\n9. Run Your Application:\n\n Start your Node.js application using `node app.js`.\n\nThis example demonstrates a basic implementation of authentication in a Node.js web application using Express.js, MongoDB for storing user data, and JWT for token-based authentication. Remember to replace `’your-secret-key’` with a strong, secret key and consider using environment variables for configuration and security. Additionally, in a production environment, you should use HTTPS to secure communication between the client and server."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-implement-jwt-authentication-in-express-js-app",
        "document": "Authentication is important in web apps to make sure only the right people can access certain pages or information. It helps keep user data safe and prevents unauthorized access. Implementing JSON Web Token (JWT) authentication in an Express.js application secures routes by ensuring that only authenticated users can access specific resources.\n\nWhat is the JWT authentication?\n\nJWT (JSON Web Token) authentication helps websites and apps keep users logged in securely. Instead of storing login details on the server, it gives the user a special token after logging in. This token is used to access protected pages without needing to log in again every time.\n• None JWTs are stateless, compact tokens that facilitate secure information exchange between parties.\n• None Incorporating JWTs into your Express.js app enhances security and scalability.\n\nA JWT is composed of three parts, each serving a distinct purpose:\n• Header: Specifies the token type (JWT) and the signing algorithm used, such as HMAC SHA256 or RSA.\n• Payload: Contains the claims, which are statements about an entity (typically, the user) and additional data.\n• Signature: Ensures the token’s integrity by verifying that the token hasn’t been altered.\n\nThis JWT is composed of three Base64Url-encoded segments divided by periods\n\nWe can implement JWT authentication in the Express app by following the below steps:\n• None We’ve brought in essential libraries – express, mongoose, and JSON web token, including the User model for database interaction. Creating an Express app\n• None Using express.json() initially helps recognize incoming requests as JSON. Two routes are set up for login and signup.\n• None In the login route, we extract the email and password from the request body, searching for the user in the database. If found, we verify the provided password.\n• None For signup, we extract user details (name, email, password) and use the Mongoose method to register users in the database.\n\nFinally, we have created a token with a 1-hour expiry by providing payload as user id and email because only this is sufficient to extract the user information. The sign method accepts payload, secret jwt key, and expiry time, then generates a token.\n\nWe are testing our API with the Postman, we have provided the data for signup in the request body, and finally, got our token with some other details.\n• None We can receive our request with a token to grant the permissions, here we are showing a simple example of how a token is being decoded.\n• None The token is being sent by request header, we are extracting the token here from the authorization header we are using the split function because the token remains in the form of “Bearer Token,” and we only want to extract the token, that’s why providing the one index.\n• None The verify method accepts the token and jwt key and provides the decode of the token. After this, we can get the information of the user.\n\nHere, we are testing the API which is responsible for accepting the token, we have passed the token in the header and finally, the server is successful in decoding the user details.\n\nWhy do we need JWT in the authentication?\n\nJSON Web Tokens (JWTs) are essential in authentication for securely transmitting user identity and permissions in a stateless manner.\n• None They enable servers to verify and grant access without storing session data, enhancing scalability and efficiency.\n• None JWTs facilitate seamless user authentication across multiple requests by embedding necessary information within the token.\n\nBest Practices of Implementing JWT in Express APP\n• Use Strong Secret Keys : Ensure that your JWT secret key is complex and stored securely, preferably in environment variables.\n• Set Token Expiration : Define appropriate expiration times for tokens to minimize the risk of misuse.\n• Implement HTTPS: Always use HTTPS to encrypt data transmitted between the client and server.\n• Stateless: No need to store sessions in the database.\n\nHow to implement JWT authentication in Express app -FAQs\n\nHow does JWT differ from traditional session-based authentication?\n\nWhere should I store the JWT on the client side?\n\nCan JWTs be used for both authentication and authorization?\n\nWhat are the components of a JSON Web Token?"
    },
    {
        "link": "https://medium.com/deno-the-complete-reference/5-jwt-authentication-best-practices-for-node-js-apps-f1aaceda3f81",
        "document": "In this beginner article, we’ll go over the five commonly used JWT authentication best practices for Node.js applications. JWT needs no introduction, therefore let’s jump directly to the best practices.\n\nThis is obvious, but definitely needs a mention. When using JWT-based authentication in Node.js, it’s crucial to use a secure secret key to sign and verify JWTs. A secure secret key is essential to prevent unauthorized access to your application.\n\nA secure secret key is used to sign and verify JWTs. When a user logs in, a JWT is generated and signed with the secret key. The signed JWT is then sent to the client, and on subsequent requests, the client sends the JWT back to the server. The server verifies the JWT by checking the signature, which ensures that the JWT has not been tampered with.\n\nIf an attacker gains access to the secret key, they can generate and sign their own JWTs, effectively bypassing authentication and gaining unauthorized access to your application.\n\nA secure secret key should have the following characteristics:\n• Long: A secure secret key should be at least 32 characters long. The longer the key, the harder it is to guess or brute-force.\n• Random: A secure secret key should be randomly generated. This ensures that the key is unpredictable and cannot be guessed.\n• Unique: A secure secret key should be unique to your application. Do not use the same secret key across multiple applications.\n\nYou can generate a secure secret key using a cryptographically secure pseudorandom number generator (CSPRNG). In Node.js, you can use the module to generate a secure secret key:\n\nThis code generates a 32-byte random key and encodes it as a hexadecimal string.\n\nWhen using a JWT library like , you can pass the secure secret key as an option when signing and verifying JWTs:\n\nIn this example, the library uses the secure secret key to sign the JWT.\n\nRemember to store your secure secret key securely, such as using environment variables or a reliable secrets manager. Never hardcode your secret key in your code or store it in a publicly accessible location.\n\nBest practice 2 — Use appropriate expiration times\n\nWhen using JWT-based authentication in Node.js, it’s a must to set appropriate expiration times for JWTs. Expiration times determine how long a JWT remains valid, and setting appropriate expiration times can help prevent token theft and unauthorized access.\n\nWhy are appropriate expiration times important?\n\nJWTs are self-contained tokens that contain user data and are signed with a secret key. Once a JWT is issued, it can be used by the client to access protected routes until it expires. If a JWT is stolen or compromised, an attacker can use it to access protected routes until it expires.\n\nSetting appropriate expiration times helps limit the damage in case a JWT is stolen or compromised. For example, if an access token expires after 1 hour, an attacker can only use it to access protected routes for 1 hour, even if they obtain the token.\n\nThere are two types of expiration times you should consider:\n• Access token expiration: Access tokens should have a short expiration time, typically between 15 minutes to 1 hour. This is because access tokens are used to access protected routes and should be short-lived to minimize damage in case of token theft.\n• Refresh token expiration: Refresh tokens should have a longer expiration time, typically between 1 day to 1 week. This is because refresh tokens are used to obtain new access tokens and should be longer-lived to minimize the need for users to re-authenticate.\n\nWith a popular JWT library like , you can set the expiration time using the option:\n\nIn this example, the library uses the option to set the expiration time for the access token and refresh token.\n\nRemember to set appropriate expiration times based on your use case and security requirements. Shorter expiration times provide better security, but may require more frequent re-authentication.\n\nYes, this is a best practice. In short, you must verify the token. It is crucial to validate and verify tokens on each request to prevent token tampering and expiration.\n\nWhy is token validation and verification important?\n\nJWTs are self-contained tokens that contain user data and are signed with a secret key. However, JWTs can be tampered with or expired, which can lead to unauthorized access to your application.\n\nValidating and verifying tokens on each request ensures that:\n• The token is valid and has not been tampered with\n• The token has not expired\n• The token was issued by your application (using the correct secret key)\n\nTo validate and verify tokens, follow these steps:\n• Check the token format: Ensure the token is in the correct format (e.g., ).\n• Verify the signature: Use the secret key to verify the token’s signature.\n• Check the expiration time: Ensure the token has not expired.\n• Check the issuer: Ensure the token was issued by your application (using the correct secret key).\n\nUsing a JWT library to validate and verify tokens\n\nWhen using a JWT library like , you can use the function to validate and verify tokens:\n\nIn this example, the library verifies the token using the secret key and checks for any errors.\n\nAgain, remember to validate and verify tokens on each request to ensure the security of your application.\n\nWhen using JWT-based authentication, it’s essential to use HTTPS to encrypt data in transit and prevent token interception.\n\nHTTPS ensures that data exchanged between the client and server is encrypted, making it difficult for attackers to intercept and steal JWTs. Without HTTPS, JWTs can be intercepted and stolen, allowing attackers to access protected routes and compromise user data.\n\nHTTPS uses Transport Layer Security (TLS) or Secure Sockets Layer (SSL) to encrypt data in transit. When a client requests a secure connection, the server responds with its SSL/TLS certificate, which contains the public key and identity information. The client then uses this information to establish an encrypted connection.\n\nTo configure HTTPS in Node.js, you need:\n• Private key: Generate a private key to pair with the SSL/TLS certificate.\n• HTTPS server: Create an HTTPS server using the module in Node.js:\n\nIn this example, the module creates an HTTPS server using the private key and SSL/TLS certificate.\n\nRemember to use HTTPS to encrypt data in transit and prevent token interception.\n\nThe storage of tokens is important on client-side as well. After all, tokens provide access to important data. It is crucial to store tokens securely on the client-side to prevent token theft and unauthorized access.\n\nJWTs contain sensitive user data and are used to access protected routes. If tokens are stored insecurely, attackers can steal them and gain unauthorized access to your application.\n\nTo store tokens securely, follow these best practices:\n• Use HttpOnly cookies: Store tokens in HttpOnly cookies, which are inaccessible to JavaScript and can only be sent to the server.\n• Use secure local storage: Use secure local storage solutions like encrypted localStorage or IndexedDB to store tokens.\n• Use a token vault: Use a token vault like a secure token storage library to manage and store tokens.\n• Avoid storing tokens in plain text: Never store tokens in plain text, as this makes them easily accessible to attackers.\n\nExample: Using HttpOnly cookies to store tokens\n\nYou can set the and options when signing tokens to store them in HttpOnly cookies:\n\nIn this example, the library sets the and options to store the token in an HttpOnly cookie.\n\nRemember to store tokens securely on client side also, to prevent token theft and unauthorized access."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/nodejs-jwt-expressjs",
        "document": "One common use case is for allowing clients to preserve their session information after logging in. By storing the session information locally and passing it to the server for authentication when making requests, the server can trust that the client is a registered user.\n\nIn this article, you will learn about the applications of JWTs in a server-client relationship using Node.js and vanilla JavaScript.\n\nTo follow along with this article, you will need the following installed on your machine:\n• Node.js installed locally, which you can do by following How to Install Node.js and Create a Local Development Environment.\n\nis an implementation of JSON Web Tokens.\n\nYou can add it to your JavaScript project by running the following command in your terminal:\n\nAnd import it into your files like so:\n\nTo sign a token, you will need to have 3 pieces of information:\n• The piece of data to hash in the token\n\nThe token secret is a long random string used to encrypt and decrypt the data.\n\nTo generate this secret, one option is to use Node.js’s built-in library, like so:\n\nNow, store this secret in your project’s file:\n\nTo bring this token into a Node.js file and to use it, you have to use :\n\nAnd import it into your files like so:\n\nThe piece of data that you hash in your token can be something either a user ID or username or a much more complex object. In either case, it should be an identifier for a specific user.\n\nThe token expire time is a string, such as 1800 seconds (30 minutes), that details how long until the token will be invalid.\n\nHere’s an example of a function for signing tokens:\n\nThis can be sent back from a request to sign in or log in a user:\n\nThis example takes the value from the (request). And provides the token as the (response).\n\nThat concludes how , , and can be used to generate a JWT.\n\nThere are many ways to go about implementing a JWT authentication system in an Express.js application.\n\nOne approach is to utilize the middleware functionality in Express.js.\n\nHow it works is when a request is made to a specific route, you can have the variables sent to an intermediary function before the one specified in the .\n\nThe middleware is a function that takes parameters of .\n• The is the sent request (GET, POST, DELETE, PUT, etc.).\n• The is the response that can be sent back to the user in a multitude of ways ( , , etc.).\n• The is a function that can be called to move the execution past the piece of middleware and into the actual server response.\n\nHere is an example middleware function for authentication:\n\nAn example request using this middleware function would resemble something like this:\n\nAnd an example of a request that would use that piece of middleware would resemble something like this:\n\nThis code will authenticate the token provided by the client. If it is valid, it can proceed to the request. If it is not valid, it can be handled as an error.\n\nWhen the client receives the token, they often want to store it for gathering user information in future requests.\n\nThe most popular manner for storing auth tokens is in an cookie.\n\nHere’s an implementation for storing a cookie using client-side JavaScript code:\n\nThis approach stores the response locally where they can be referenced for future requests to the server.\n\nThat concludes the flow of requesting a token, generating a token, receiving a token, passing a token with new requests, and verifying a token.\n\nIn this article, you were introduced to JWTs and one approach to applying them to a Node.js application. This approach relied upon a combination of , , , and .\n\nFor another approach to using JWTs, there is How To Implement API Authentication with JSON Web Tokens and Passport.\n\nFor more background on JWTs, there is the “Introduction” documentation.\n\nIf you’d like to learn more about Node.js, check out our Node.js topic page for exercises and programming projects."
    },
    {
        "link": "https://stackoverflow.com/questions/59760081/best-practice-using-jwt-refresh-token-in-nodejs",
        "document": "I'm using JSON Web Tokens for authentication in my react-native app. When a user signs in, a token is created and send to the user to store in the local storage. The token is valid for 24 hours. Whenever the server (nodejs) is called, the token is send in a header.\n\nThe problem is, after 24 hours, the user has to sign in again. I don't want this, so I started searching for solutions. The solution I found: refresh tokens.\n\nMy approach so far. Please correct me if I'm doing something wrong.\n\n1) A user signs in. An auth token and a refresh token are both send to the user to store in the local storage. (Is this safe enough?)\n\n2) The user wants to change his profile. I send a request to the server with the auth token in a header.\n\n3) The server receives the auth token. If the auth token is still valid, do whatever you have to do. If the auth token is expired, check if the user has a refresh token (that's still valid). At this point, I'm stuck. Should I send a new request from the server to the user with the question \"do you have a refresh token?\" and if so, send this refresh token to the server to create a new auth token?\n\nThe problem for me is the following:\n\nLet's say the user wants to get the last 10 messages from a list. A request with the auth token is send to the server.\n\n=> the auth token is valid: the response is a list of 10 messages\n\n=> the auth token is invalid: the response is a new request from the server to the client for the refresh token\n\nThese are 2 different responses. Wouldn't that mess up my code at the client side? How should I handle this?\n\nAn alternative could be to send the auth token AND the refresh token in every request. But would that make sense?"
    }
]