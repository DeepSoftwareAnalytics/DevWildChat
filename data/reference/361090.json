[
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/json/json-data-sql-server?view=sql-server-ver16",
        "document": "Applies to: SQL Server 2016 (13.x) and later versions Azure SQL Database Azure SQL Managed Instance Azure Synapse Analytics SQL database in Microsoft Fabric\n\nJSON is a popular textual data format that's used for exchanging data in modern web and mobile applications. JSON is also used for storing unstructured data in log files or NoSQL databases such as Microsoft Azure Cosmos DB. Many REST web services return results that are formatted as JSON text or accept data that's formatted as JSON. For example, most Azure services, such as Azure Search, Azure Storage, and Azure Cosmos DB, have REST endpoints that return or consume JSON. JSON is also the main format for exchanging data between webpages and web servers by using AJAX calls.\n\nJSON functions, first introduced in SQL Server 2016 (13.x), enable you to combine NoSQL and relational concepts in the same database. You can combine classic relational columns with columns that contain documents formatted as JSON text in the same table, parse and import JSON documents in relational structures, or format relational data to JSON text.\n\nHere's an example of JSON text:\n\nBy using SQL Server built-in functions and operators, you can do the following things with JSON text:\n• Run any Transact-SQL query on the converted JSON objects.\n• Format the results of Transact-SQL queries in JSON format.\n\nThe next sections discuss the key capabilities that SQL Server provides with its built-in JSON support.\n\nThe new json data type that stores JSON documents in a native binary format that provides the following benefits over storing JSON data in varchar/nvarchar:\n• More efficient reads, as the document is already parsed\n• More efficient writes, as the query can update individual values without accessing the entire document\n• No change in compatibility with existing code\n\nUsing the JSON same functions described in this article remain the most efficient way to query the json data type. For more information on the native json data type, see JSON data type.\n\nExtract values from JSON text and use them in queries\n\nIf you have JSON text that's stored in database tables, you can read or modify values in the JSON text by using the following built-in functions:\n• JSON_QUERY (Transact-SQL) extracts an object or an array from a JSON string.\n• JSON_MODIFY (Transact-SQL) changes a value in a JSON string.\n\nIn the following example, the query uses both relational and JSON data (stored in a column named ) from a table called :\n\nApplications and tools see no difference between the values taken from scalar table columns and the values taken from JSON columns. You can use values from JSON text in any part of a Transact-SQL query (including WHERE, ORDER BY, or GROUP BY clauses, window aggregates, and so on). JSON functions use JavaScript-like syntax for referencing values inside JSON text.\n\nFor more information, see Validate, Query, and Change JSON Data with Built-in Functions (SQL Server), JSON_VALUE (Transact-SQL), and JSON_QUERY (Transact-SQL).\n\nIf you must modify parts of JSON text, you can use the JSON_MODIFY (Transact-SQL) function to update the value of a property in a JSON string and return the updated JSON string. The following example updates the value of a property in a variable that contains JSON:\n\nYou don't need a custom query language to query JSON in SQL Server. To query JSON data, you can use standard T-SQL. If you must create a query or report on JSON data, you can easily convert JSON data to rows and columns by calling the rowset function. For more information, see Parse and Transform JSON Data with OPENJSON.\n\nThe following example calls and transforms the array of objects that is stored in the variable to a rowset that can be queried with a standard Transact-SQL statement:\n\ntransforms the array of JSON objects into a table in which each object is represented as one row, and key/value pairs are returned as cells. The output observes the following rules:\n• converts JSON values to the types that are specified in the clause.\n• can handle both flat key/value pairs and nested, hierarchically organized objects.\n• You don't have to return all the fields that are contained in the JSON text.\n• You can optionally specify a path after the type specification to reference a nested property or to reference a property by a different name.\n• The optional prefix in the path specifies that values for the specified properties must exist in the JSON text.\n\nFor more information, see Parse and Transform JSON Data with OPENJSON and OPENJSON (Transact-SQL).\n\nJSON documents might have sub-elements and hierarchical data that can't be directly mapped into the standard relational columns. In this case, you can flatten JSON hierarchy by joining parent entity with sub-arrays.\n\nIn the following example, the second object in the array has sub-array representing person skills. Every sub-object can be parsed using additional function call:\n\nThe array is returned in the first as original JSON text fragment and passed to another function using operator. The second function parses JSON array and return string values as single column rowset that will be joined with the result of the first .\n\njoins first-level entity with sub-array and return flatten resultset. Due to JOIN, the second row is repeated for every skill.\n\nFormat SQL Server data or the results of SQL queries as JSON by adding the clause to a statement. Use to delegate the formatting of JSON output from your client applications to SQL Server. For more information, see Format query results as JSON with FOR JSON.\n\nThe following example uses PATH mode with the clause:\n\nThe clause formats SQL results as JSON text that can be provided to any app that understands JSON. The PATH option uses dot-separated aliases in the SELECT clause to nest objects in the query results.\n\nFor more information, see Format query results as JSON with FOR JSON and FOR Clause (Transact-SQL).\n\nJSON aggregate functions enable construction of JSON objects or arrays based on an aggregate from SQL data.\n• JSON_OBJECTAGG constructs a JSON object from an aggregation of SQL data or columns.\n• JSON_ARRAYAGG constructs a JSON array from an aggregation of SQL data or columns.\n\nUse cases for JSON data in SQL Server\n\nJSON support in SQL Server and Azure SQL Database lets you combine relational and NoSQL concepts. You can easily transform relational to semi-structured data and vice-versa. JSON isn't a replacement for existing relational models, however. Here are some specific use cases that benefit from the JSON support in SQL Server and in SQL Database.\n\nConsider denormalizing your data model with JSON fields in place of multiple child tables.\n\nStore info about products with a wide range of variable attributes in a denormalized model for flexibility.\n\nLoad, query, and analyze log data stored as JSON files with all the power of the Transact-SQL language.\n\nWhen you need real-time analysis of IoT data, load the incoming data directly into the database instead of staging it in a storage location.\n\nTransform relational data from your database easily into the JSON format used by the REST APIs that support your web site.\n\nSQL Server provides a hybrid model for storing and processing both relational and JSON data by using standard Transact-SQL language. You can organize collections of your JSON documents in tables, establish relationships between them, combine strongly typed scalar columns stored in tables with flexible key/value pairs stored in JSON columns, and query both scalar and JSON values in one or more tables by using full Transact-SQL.\n\nJSON text is stored in or columns and is indexed as plain text. Any SQL Server feature or component that supports text supports JSON, so there are almost no constraints on interaction between JSON and other SQL Server features. You can store JSON in In-memory or Temporal tables, apply Row-Level Security predicates on JSON text, and so on.\n\nHere are some use cases that show how you can use the built-in JSON support in SQL Server.\n\nJSON is a textual format so the JSON documents can be stored in columns in a SQL Database. Since type is supported in all SQL Server subsystems you can put JSON documents in tables with clustered columnstore indexes, memory optimized tables, or external files that can be read using OPENROWSET or PolyBase.\n\nTo learn more about your options for storing, indexing, and optimizing JSON data in SQL Server, see the following articles:\n\nYou can format information that's stored in files as standard JSON or line-delimited JSON. SQL Server can import the contents of JSON files, parse it by using the or functions, and load it into tables.\n• None If your JSON documents are stored in local files, on shared network drives, or in Azure Files locations that can be accessed by SQL Server, you can use bulk import to load your JSON data into SQL Server.\n• None If your line-delimited JSON files are stored in Azure Blob storage or the Hadoop file system, you can use PolyBase to load JSON text, parse it in Transact-SQL code, and load it into tables.\n\nIf you must load JSON data from an external service into SQL Server, you can use to import the data into SQL Server instead of parsing the data in the application layer.\n\nIn supported platforms, use the native json data type instead of nvarchar(max) for improved performance and more efficient storage.\n\nYou can provide the content of the JSON variable by an external REST service, send it as a parameter from a client-side JavaScript framework, or load it from external files. You can easily insert, update, or merge results from JSON text into a SQL Server table.\n\nIf you must filter or aggregate JSON data for reporting purposes, you can use to transform JSON to relational format. You can then use standard Transact-SQL and built-in functions to prepare the reports.\n\nYou can use both standard table columns and values from JSON text in the same query. You can add indexes on the expression to improve the performance of the query. For more information, see Index JSON data.\n\nIf you have a web service that takes data from the database layer and returns it in JSON format, or if you have JavaScript frameworks or libraries that accept data formatted as JSON, you can format JSON output directly in a SQL query. Instead of writing code or including a library to convert tabular query results and then serialize objects to JSON format, you can use to delegate the JSON formatting to SQL Server.\n\nFor example, you might want to generate JSON output that's compliant with the OData specification. The web service expects a request and response in the following format:\n\nThis OData URL represents a request for the ProductID and ProductName columns for the product with 1. You can use to format the output as expected in SQL Server.\n\nThe output of this query is JSON text that's fully compliant with the OData spec. Formatting and escaping are handled by SQL Server. SQL Server can also format query results in any format, such as OData JSON or GeoJSON.\n\nTo get the AdventureWorks sample database, download at least the database file and the samples and scripts file from GitHub.\n\nAfter you restore the sample database to an instance of SQL Server, extract the samples file, and then open the file from the JSON folder. Run the scripts in this file to reformat some existing data as JSON data, test sample queries and reports over the JSON data, index the JSON data, and import and export JSON.\n\nHere's what you can do with the scripts that are included in the file:\n• None Denormalize the existing schema to create columns of JSON data.\n• None Store information from , , , , and other tables that contain information related to sales order into JSON columns in the table.\n• None Store information from and tables in the table as arrays of JSON objects.\n• None Import and export JSON. Create and run procedures that export the content of the and the tables as JSON results, and import and update the and the tables by using JSON input.\n• None Run query examples. Run some queries that call the stored procedures and views that you created in steps 2 and 4.\n• None Clean up scripts. Don't run this part if you want to keep the stored procedures and views that you created in steps 2 and 4."
    },
    {
        "link": "https://stackoverflow.com/questions/66937613/how-to-combine-multiple-rows-with-json-path-in-sql-server",
        "document": "I have this dataset with 4 tables. I am trying to write the SQL query as following:\n\nbut this produces the result where company names are duplicated because of the differences in link. For e.g., UnitedHeath Group (rows 4 & 5) is in two rows because the link is different. I want the result in such a way that the company name is shown just once, and tags are in the same group together. I don't need link to be shown; only included for this SO."
    },
    {
        "link": "https://stackoverflow.com/questions/72596959/group-by-and-merge-to-a-json-record-in-sql-server",
        "document": "I have rows in a table like this:\n\nNow I need to group based on ORG, Tenant and remaining columns I need to convert into a single JSON as below.\n\nHow can I achieve this in SQL Server or using C#? Do we have an out of the box support for this?\n\nThanks for your help, Nikesh"
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/json/format-query-results-as-json-with-for-json-sql-server?view=sql-server-ver16",
        "document": "Format query results as JSON with FOR JSON\n\nApplies to: SQL Server Azure SQL Managed Instance Azure Synapse Analytics (serverless SQL pool only) SQL analytics endpoint in Microsoft Fabric Warehouse in Microsoft Fabric\n\nFormat query results as JSON, or export data from SQL Server as JSON, by adding the clause to a statement. Use the clause to simplify client applications by delegating the formatting of JSON output from the app to SQL Server.\n\nIn Fabric Data Warehouse, must be the last operator in the query, and so is not allowed inside subqueries.\n\nWhen you use the clause, you can specify the structure of the JSON output explicitly, or let the structure of the statement determine the output.\n• None To maintain full control over the format of the JSON output, use . You can create wrapper objects and nest complex properties.\n• None To format the JSON output automatically based on the structure of the statement, use .\n\nHere's an example of a statement with the clause and its output.\n\nIn mode, you can use the dot syntax - for example, - to format nested output. Here's a sample query that uses mode with the clause. The following example also uses the option to specify a named root element. More info about FOR JSON PATH For more detailed info and examples, see Format Nested JSON Output with PATH Mode. For syntax and usage, see SELECT - FOR Clause (Transact-SQL). In mode, the structure of the statement determines the format of the JSON output. By default, values aren't included in the output. You can use to change this behavior. Here's a sample query that uses mode with the clause. SELECT name, surname FROM emp FOR JSON AUTO; Example with JOIN and The following example of includes a display of what the JSON results look like when there's a 1:many relationship between data from joined tables. The absence of the null value from the returned JSON is also illustrated. However, you can override this default behavior by use of the keyword on the clause. DROP TABLE IF EXISTS #tabStudent; DROP TABLE IF EXISTS #tabClass; GO CREATE TABLE #tabClass ( ClassGuid UNIQUEIDENTIFIER NOT NULL DEFAULT newid(), ClassName NVARCHAR(32) NOT NULL ); CREATE TABLE #tabStudent ( StudentGuid UNIQUEIDENTIFIER NOT NULL DEFAULT newid(), StudentName NVARCHAR(32) NOT NULL, ClassGuid UNIQUEIDENTIFIER NULL -- Foreign key. ); GO INSERT INTO #tabClass (ClassGuid, ClassName) VALUES ('DE807673-ECFC-4850-930D-A86F921DE438', 'Algebra Math'), ('C55C6819-E744-4797-AC56-FF8A729A7F5C', 'Calculus Math'), ('98509D36-A2C8-4A65-A310-E744F5621C83', 'Art Painting'); INSERT INTO #tabStudent (StudentName, ClassGuid) VALUES ('Alice Apple', 'DE807673-ECFC-4850-930D-A86F921DE438'), ('Alice Apple', 'C55C6819-E744-4797-AC56-FF8A729A7F5C'), ('Betty Boot', 'C55C6819-E744-4797-AC56-FF8A729A7F5C'), ('Betty Boot', '98509D36-A2C8-4A65-A310-E744F5621C83'), ('Carla Cap', null); GO SELECT c.ClassName, s.StudentName FROM #tabClass AS c RIGHT JOIN #tabStudent AS s ON s.ClassGuid = c.ClassGuid ORDER BY c.ClassName, s.StudentName FOR JSON AUTO -- To include NULL values in the output, uncomment the following line: --, INCLUDE_NULL_VALUES ; GO DROP TABLE IF EXISTS #tabStudent; DROP TABLE IF EXISTS #tabClass; GO And next is the JSON that is output by the preceding SELECT. More info about FOR JSON AUTO For more detailed info and examples, see Format JSON Output Automatically with AUTO Mode (SQL Server). For syntax and usage, see SELECT - FOR Clause (Transact-SQL).\n\nControl the output of the clause, using the following extra options.\n• To add a single, top-level element to the JSON output, specify the option. If you don't specify this option, the JSON output doesn't have a root element. For more info, see Add a Root Node to JSON Output with the ROOT Option (SQL Server).\n• To include null values in the JSON output, specify the option. If you don't specify this option, the output doesn't include JSON properties for values in the query results. For more info, see Include Null Values in JSON - INCLUDE_NULL_VALUES Option.\n• To remove the square brackets that surround the JSON output of the clause by default, specify the option. Use this option to generate a single JSON object as output from a single-row result. If you don't specify this option, the JSON output is formatted as an array - that is, the output is enclosed within square brackets. For more info, see Remove Square Brackets from JSON - WITHOUT_ARRAY_WRAPPER Option.\n\nOutput of the FOR JSON clause\n\nThe output of the clause has the following characteristics:\n• \n• A large result set splits the long JSON string across multiple rows.\n• None By default, SQL Server Management Studio (SSMS) concatenates the results into a single row when the output setting is Results to Grid. The SSMS status bar displays the actual row count.\n• None Other client applications might require code to recombine lengthy results into a single, valid JSON string by concatenating the contents of multiple rows. For an example of this code in a C# application, see Use FOR JSON output in a C# client app.\n• None The results are formatted as an array of JSON objects.\n• None The number of elements in the JSON array is equal to the number of rows in the results of the SELECT statement (before the FOR JSON clause is applied).\n• None Each row in the results of the SELECT statement (before the FOR JSON clause is applied) becomes a separate JSON object in the array.\n• None Each column in the results of the SELECT statement (before the FOR JSON clause is applied) becomes a property of the JSON object.\n• None Both the names of columns and their values are escaped according to JSON syntax. For more info, see How FOR JSON escapes special characters and control characters (SQL Server).\n\nHere's an example that demonstrates how the clause formats the JSON output.\n• How FOR JSON converts SQL Server data types to JSON data types (SQL Server)\n• How FOR JSON escapes special characters and control characters (SQL Server)\n• Video: JSON as a bridge between NoSQL and relational worlds\n• Use FOR JSON output in SQL Server and in client apps (SQL Server)"
    },
    {
        "link": "https://docs.retool.com/queries/guides/sql/query-json",
        "document": "You can create queries that use SQL statements to query JSON data, such as data from other queries, using the Query JSON with SQL resource. Instead of referencing database tables for data, you use to reference JSON arrays of objects.\n\nRetool uses the AlaSQL JavaScript library for JSON SQL queries. Some SQL syntax may differ since queries run in the browser. For example, AlaSQL uses square brackets and backticks to enclose column names that contain whitespace, rather than double quotes. Refer to the AlaSQL documentation for a complete reference on supported operations.\n\nResource queries, such as database queries or API requests, have a property with retrieved data. You can reference this property when writing an SQL statement using , such as . You can also perform SQL joins when querying JSON. This allows you to combine and query APIs and other data sources. The following example queries data from two separate API requests for posts and comments. The SQL statement uses a JOIN to connect the data together. The end result is a query that can retrieve comments for the specified post. Resource queries, such as database queries or API requests, have a property with retrieved data. You can reference this property when writing an SQL statement using , such as . You can also perform SQL joins when querying JSON. This allows you to combine and query APIs and other data sources. The following example queries data from two separate API requests for posts and comments. The SQL statement uses a JOIN to connect the data together. The end result is a query that can retrieve comments for the specified post.\n\nClick Save & Run to save the query and then execute it. The query results then appear in the Output tab. You can reference the query output elsewhere in the app using the query's property. This contains an object with key names that correspond to the column names. Each key contains an array of values. Click ▶︎ to run the block. The query results then appear in the Data and JSON tabs. You can reference the query output further down the control flow using the query's property. This contains an object with key names that correspond to the column names. Each key contains an array of values.\n\nIf you need to reference an array within a query, such as a list of values for an clause, prefix the array with ."
    },
    {
        "link": "https://docs.oracle.com/database/122/ADJSN/generation.htm",
        "document": "You can use SQL/JSON functions , , , and to construct JSON data from non-JSON data in the database. The JSON data is returned as a SQL value. These generation functions make it easy to construct JSON data directly from a SQL query. They allow non-JSON data to be represented as JSON objects and JSON arrays. You can generate complex, hierarchical JSON documents by nesting calls to these functions. Nested subqueries can generate JSON collections that represent one-to-many relationships.Foot 1 The Best Way to Construct JSON Data from Non-JSON Data Alternatives to using the SQL/JSON generation functions are generally error prone or inefficient.\n• Using string concatenation to generate JSON documents is error prone. In particular, there are a number of complex rules that must be respected concerning when and how to escape special characters, such as double quotation marks ( ). It is easy to overlook or misunderstand these rules, which can result in generating incorrect JSON data.\n• Reading non-JSON result sets from the database and using client-side application code to generate JSON data is typically quite inefficient, particularly due to network overhead. When representing one-to-many relationships as JSON data, multiple operations are often required, to collect all of the non-JSON data needed. If the documents to be generated represent multiple levels of one-to-many relationships then this technique can be quite costly. The SQL/JSON generation functions do not suffer from such problems; they are designed for the job of constructing JSON data from non-JSON database data.\n• By using SQL subqueries with these functions, you can generate an entire set of JSON documents using a single SQL statement, which allows the generation operation to be optimized.\n• Because only the generated documents are returned to a client, network overhead is minimized: there is at most one round trip per document generated.\n• Functions and construct a JSON object or array, respectively, given as arguments SQL name–value pairs and values, respectively. The number of arguments corresponds to the number of object members and array elements, respectively (except when an argument expression evaluates to SQL and the clause applies). Each name must have the syntax of a SQL identifier. Each value can be any SQL value, including a value computed using a scalar SQL (sub)query that returns at most one item (a single row with a single column — an error is raised if such a query argument returns more than one row.)\n• Functions , and are aggregate SQL functions. They transform information that is contained in the rows of a grouped SQL query into JSON objects and arrays, respectively. Evaluation of the arguments determines the number of object members and array elements, respectively; that is, the size of the result reflects the current queried data. For , the order of object members is unspecified. For , the order of array elements reflects the query result order. You can use SQL in the query to control the array element order. Formats of Input Values for JSON_OBJECT and JSON_ARRAY For function you can use any SQL value of the supported data types as arguments. Similarly for the value arguments of name–value pairs that you pass to function . In some cases you know or expect that such a value is in fact JSON data (represented as a SQL string or number). You can add keywords after any input value expression to declare this expectation for the value that results from that expression. If Oracle can determine that the value is in fact JSON data then it is treated as if it were followed by an explicit declaration. This is the case, for instance, if the value expression is an invocation of a SQL/JSON generation function. specify , and if Oracle determine that the value is JSON data, then it is assumed to be ordinary (non-JSON) SQL data. In that case it is serialized as follows (any other SQL value raises an error):\n• A or value is wrapped in double quotation marks ( ).\n• A numeric value is converted to a JSON number. (It is not quoted.)\n• A or value is converted to ISO 8601 format, and the result is enclosed in double quotation marks ( ).\n• A PL/SQL value is converted to JSON or . (It is not quoted.)\n• A value is converted to JSON , regardless of the data type. If you dospecify, and if Oracledetermine that the value is JSON data, then it is assumed to be ordinary (non-JSON) SQL data. In that case it is serialized as follows (any other SQL value raises an error): Because Oracle SQL treats an empty string as there is no way to construct an empty JSON string ( ). The format of an input argument can affect the format of the data that is returned by the function. In particular, if an input is determined to be of format JSON then it is treated as JSON data when computing the return value. Example 19-1 illustrates this — it explicitly uses to interpret the SQL string as JSON Boolean value . You can optionally specify a SQL -handling clause, a clause, and keyword .\n• -handling clause — Determines how a SQL value resulting from input evaluation is handled.\n• — An input SQL value is converted to JSON for output. This is the default behavior for and .\n• — An input SQL value results in no corresponding output. This is the default behavior for and .\n• clause — The SQL data type used for the function return value. The default is .\n• keyword — If present, the returned JSON data is checked, to be sure it is well-formed. If is present and the returned data is not well-formed then an error is raised. The generated JSON data is returned from the function as a SQL value, whose size can be controlled by the optional clause. For the aggregate SQL functions ( and ), you can also specify as the SQL data type in the clause. JSON values within the returned data are derived from SQL values in the input as follows:\n• A non- and non-number SQL value is converted to a JSON string.\n• A SQL value is handled by the optional -handling clause. Example 19-1 Declaring an Input Value To Be JSON This example specifies for SQL string values and , in order that the JSON Boolean values and are used. SELECT json_object('name' VALUE first_name || ' ' || last_name, 'hasCommission' VALUE CASE WHEN commission_pct IS NULL THEN 'false' ELSE 'true' END ) FROM employees WHERE first_name LIKE 'W%'; JSON_OBJECT('NAME'ISFIRST_NAME||''||LAST_NAME,' ----------------------------------------------- {\"name\":\"William Gietz\",\"hasCommission\": } {\"name\":\"William Smith\",\"hasCommission\": } {\"name\":\"Winston Taylor\",\"hasCommission\": }\n\nSQL/JSON function constructs JSON objects from name–value pairs. Each pair is provided as an explicit argument. Each name of a pair must evaluate to a SQL identifier. Each value of a pair can be any SQL expression. The name and value are separated by keyword . The evaluated arguments you provide to are explicit object field names and field values. The resulting object has an member for each pair of name–value arguments you provide (except when an value expression evaluates to SQL and the clause applies). Example 19-2 Using JSON_OBJECT to Construct JSON Objects This example constructs a JSON object for each employee of table (from standard database schema ) whose salary is less than 15000. The object includes, as the value of its field , an object with fields and . Because the return value of is JSON data, is deduced for the input format of field — the explicit here is not needed. SELECT ('id' VALUE employee_id, 'name' VALUE first_name || ' ' || last_name, 'hireDate' VALUE hire_date, 'pay' VALUE salary, 'contactInfo' VALUE ('mail' VALUE email, 'phone' VALUE phone_number) FORMAT JSON) FROM employees WHERE salary > 15000; -- The query returns rows such as this (pretty-printed here for clarity): {\"id\":101, \"name\":\"Neena Kochhar\", \"hireDate\":\"21-SEP-05\", \"pay\":17000, \"contactInfo\":{\"mail\":\"NKOCHHAR\", \"phone\":\"515.123.4568\"}} Example 19-3 Using JSON_OBJECT With ABSENT ON NULL This example queries table from standard database schema to create JSON objects with fields and . The default -handling behavior for json_object is . In order to prevent the creation of a field with a JSON value, the example uses . The SQL value for column when column has value means that no field is created for that location. SELECT JSON_OBJECT('city' VALUE city, 'province' VALUE state_province ) FROM locations WHERE city LIKE 'S%'; JSON_OBJECT('CITY'ISCITY,'PROVINCE'ISSTATE_PROVINCEABSENTONNULL) ---------------------------------------------------------------- {\"city\":\"Southlake\", :\"Texas\"} {\"city\":\"South San Francisco\", :\"California\"} {\"city\":\"South Brunswick\", :\"New Jersey\"} {\"city\":\"Seattle\", :\"Washington\"} {\"city\":\"Sydney\", :\"New South Wales\"} {\"city\":\"Stretford\", :\"Manchester\"} {\"city\":\"Sao Paulo\", :\"Sao Paulo\"}\n\nSQL/JSON function constructs a JSON array from the results of evaluating its argument SQL expressions. Each argument can be any SQL expression. Array element order is the same as the argument order. The evaluated arguments you provide to are explicit array element values. The resulting array has an element for each argument you provide (except when an argument expression evaluates to SQL and the clause applies). An argument expression that evaluates to a SQL number is converted to a JSON number. A non- and non-number argument value is converted to a JSON string. Example 19-4 Using JSON_ARRAY to Construct a JSON Array This example constructs a JSON object for each job in database table (from standard database schema ). The fields of the objects are the job title and salary range. The salary range (field ) is an array of two numeric values, the minimum and maximum salaries for the job. These values are taken from SQL columns and . SELECT json_object('title' VALUE job_title, 'salaryRange' VALUE (min_salary, max_salary)) FROM jobs; JSON_OBJECT('TITLE'ISJOB_TITLE,'SALARYRANGE'ISJSON_ARRAY(MIN_SALARY,MAX_SALARY)) -------------------------------------------------------------------------------- {\"title\":\"President\",\"salaryRange\":[20080,40000]} {\"title\":\"Administration Vice President\",\"salaryRange\":[15000,30000]} {\"title\":\"Administration Assistant\",\"salaryRange\":[3000,6000]} {\"title\":\"Finance Manager\",\"salaryRange\":[8200,16000]} {\"title\":\"Accountant\",\"salaryRange\":[4200,9000]} {\"title\":\"Accounting Manager\",\"salaryRange\":[8200,16000]} {\"title\":\"Public Accountant\",\"salaryRange\":[4200,9000]} {\"title\":\"Sales Manager\",\"salaryRange\":[10000,20080]} {\"title\":\"Sales Representative\",\"salaryRange\":[6000,12008]} {\"title\":\"Purchasing Manager\",\"salaryRange\":[8000,15000]} {\"title\":\"Purchasing Clerk\",\"salaryRange\":[2500,5500]} {\"title\":\"Stock Manager\",\"salaryRange\":[5500,8500]} {\"title\":\"Stock Clerk\",\"salaryRange\":[2008,5000]} {\"title\":\"Shipping Clerk\",\"salaryRange\":[2500,5500]} {\"title\":\"Programmer\",\"salaryRange\":[4000,10000]} {\"title\":\"Marketing Manager\",\"salaryRange\":[9000,15000]} {\"title\":\"Marketing Representative\",\"salaryRange\":[4000,9000]} {\"title\":\"Human Resources Representative\",\"salaryRange\":[4000,9000]} {\"title\":\"Public Relations Representative\",\"salaryRange\":[4500,10500]}\n\nFootnote 1: The behavior of the SQL/JSON generation functions for JSON data is similar to that of the SQL/XML generation functions for XML data."
    },
    {
        "link": "https://stackoverflow.com/questions/70700607/how-to-add-a-unique-id-to-each-entry-in-my-json-object",
        "document": "I have this array of JSON objects:\n\nand I want to add a unique ID (string) to each entry, like this:\n\nI just can't think of the right logic to achieve this. I have written this recursive function, which obviously does not achieve what I want:\n\nHow can I solve this problem?"
    },
    {
        "link": "https://stackoverflow.com/questions/17688349/sql-like-operator-to-find-words-in-stored-json",
        "document": "I have this JSON stored in a MySQL DB, column name:\n\nI want to make a search using operator to find all categories with \"Category\" word:\n\nAt the moment I'm doing it this way, but it only return a complete phrase:\n\nHow can I build a query that returns all categories containing the word \"Category\"?"
    },
    {
        "link": "https://docs.retool.com/queries/guides/sql/query-json",
        "document": "You can create queries that use SQL statements to query JSON data, such as data from other queries, using the Query JSON with SQL resource. Instead of referencing database tables for data, you use to reference JSON arrays of objects.\n\nRetool uses the AlaSQL JavaScript library for JSON SQL queries. Some SQL syntax may differ since queries run in the browser. For example, AlaSQL uses square brackets and backticks to enclose column names that contain whitespace, rather than double quotes. Refer to the AlaSQL documentation for a complete reference on supported operations.\n\nResource queries, such as database queries or API requests, have a property with retrieved data. You can reference this property when writing an SQL statement using , such as . You can also perform SQL joins when querying JSON. This allows you to combine and query APIs and other data sources. The following example queries data from two separate API requests for posts and comments. The SQL statement uses a JOIN to connect the data together. The end result is a query that can retrieve comments for the specified post. Resource queries, such as database queries or API requests, have a property with retrieved data. You can reference this property when writing an SQL statement using , such as . You can also perform SQL joins when querying JSON. This allows you to combine and query APIs and other data sources. The following example queries data from two separate API requests for posts and comments. The SQL statement uses a JOIN to connect the data together. The end result is a query that can retrieve comments for the specified post.\n\nClick Save & Run to save the query and then execute it. The query results then appear in the Output tab. You can reference the query output elsewhere in the app using the query's property. This contains an object with key names that correspond to the column names. Each key contains an array of values. Click ▶︎ to run the block. The query results then appear in the Data and JSON tabs. You can reference the query output further down the control flow using the query's property. This contains an object with key names that correspond to the column names. Each key contains an array of values.\n\nIf you need to reference an array within a query, such as a list of values for an clause, prefix the array with ."
    },
    {
        "link": "https://cloud.google.com/bigquery/docs/json-data",
        "document": "Save and categorize content based on your preferences.\n\nThis document describes how to create a table with a column, insert JSON data into a BigQuery table, and query JSON data.\n\nJSON is a widely used format that allows for semi-structured data, because it does not require a schema. Applications can use a \"schema-on-read\" approach, where the application ingests the data and then queries based on assumptions about the schema of that data. This approach differs from the type in BigQuery, which requires a fixed schema that is enforced for all values stored in a column of type.\n\nBy using the data type, you can load semi-structured JSON into BigQuery without providing a schema for the JSON data upfront. This lets you store and query data that doesn't always adhere to fixed schemas and data types. By ingesting JSON data as a data type, BigQuery can encode and process each JSON field individually. You can then query the values of fields and array elements within the JSON data by using the field access operator, which makes JSON queries intuitive and cost efficient.\n• If you use a batch load job to ingest JSON data into a table, the source data must be in CSV, Avro, or JSON format. Other batch load formats are not supported.\n• The data type has a nesting limit of 500.\n• You can't use legacy SQL to query a table that contains types.\n• Row-level access policies cannot be applied on columns.\n\nTo learn about the properties of the data type, see type.\n\nYou can create an empty table with a column by using SQL or by using the bq command-line tool.\n\nYou can't partition or cluster a table on columns, because the equality and comparison operators are not defined on the type.\n\nYou can create values in the following ways:\n• Use the function to convert a value to a value.\n• Use the function to convert a SQL value to a value.\n• Use the function to create a JSON array from SQL values.\n• Use the function to create a JSON object from key-value pairs.\n\nThe following example inserts values into a table:\n\nThe following example converts a JSON-formatted value by using the function. The example converts a column from an existing table to a type and saves the results in a new table.\n\nThe prefix used in this example ensures that any conversion errors are returned as values.\n\nThe following example converts key-value pairs to JSON using the function.\n\nThe result is the following:\n\nThe following example converts a SQL value to a value by using the function:\n\nThe result is the following:\n\nYou can ingest JSON data into a BigQuery table in the following ways:\n• Use a batch load job to load into columns from the following formats.\n\nThe following example assumes that you have a CSV file named that contains the following records:\n\nNote that the second column contains JSON data that is encoded as a string. This involves correctly escaping the quotes for the CSV format. In CSV format, quotes are escaped by using the two character sequence .\n\nTo load this file using the bq command-line tool, use the command:\n\nThe following example assumes that you have a file named that contains the following records:\n\nTo load this file using the bq command-line tool, use the command:\n\nYou can use the Storage Write API to ingest JSON data. The following example uses the Storage Write API Python client to write data into a table with a JSON data type column.\n\nDefine a protocol buffer to hold the serialized streaming data. The JSON data is encoded as a string. In the following example, the field holds JSON data.\n\nFormat the JSON data for each row as a value:\n\nAppend the rows to the write stream as shown in the code example. The client library handles serialization to protocol buffer format.\n\nIf you aren't able to format the incoming JSON data, you need to use the method in your code. Here is an example:\n\nThe following example loads JSON data from a local file and streams it to a BigQuery table with a JSON data-type column named using the legacy streaming API.\n\nFor more information, see Streaming data into BigQuery.\n\nThis section describes how to use GoogleSQL to extract values from JSON. JSON is case-sensitive and supports UTF-8 in both fields and values.\n\nThe examples in this section use the following table:\n\nGiven a type in BigQuery, you can access the fields in a JSON expression by using the field access operator. The following example returns the field of the column.\n\nTo access an array element, use the JSON subscript operator. The following example returns the first element of the array:\n\nYou can also use the JSON subscript operator to reference the members of a JSON object by name:\n\nFor subscript operations, the expression inside the brackets can be any arbitrary string or integer expression, including non-constant expressions:\n\nField access and subscript operators both return types, so you can chain expressions that use them or pass the result to other functions that take types.\n\nThese operators improve readability for the basic functionality of the function. For example, the expression is equivalent to .\n\nIf a member with the specified name is not found in the JSON object, or if the JSON array doesn't have an element with the specified position, then these operators return SQL .\n\nThe equality and comparison operators are not defined on the data type. Therefore, you can't use values directly in clauses like or . Instead, use the function to extract field values as SQL strings, as described in the next section.\n\nThe function extracts a scalar value and returns it as a SQL string. It returns SQL if doesn't point to a scalar value in the JSON.\n\nYou can use the function in contexts that require equality or comparison, such as clauses and clauses. The following example shows a clause that filters against a value:\n\nAlternatively, you can use the function which extracts a JSON string and returns that value as a SQL . For example:\n\nIn addition to , you might have to extract values and return them as another SQL data type. The following value extraction functions are available:\n\nTo obtain the type of the value, you can use the function.\n\nYou can convert a value to a scalar SQL value flexibly with functions.\n\nThe following example uses the function to extract an value from a value.\n\nIn addition to , you can convert to other SQL types flexibly to JSON with the following functions:\n\nJSON can contain JSON arrays, which are not directly equivalent to an type in BigQuery. You can use the following functions to extract a BigQuery from JSON:\n• : extracts an array and returns it as an of JSON.\n• : extracts an array of scalar values and returns it as an of scalar values.\n\nThe following example uses to extract JSON arrays:\n\nTo split an array into its individual elements, use the operator, which returns a table with one row for each element in the array. The following example selects the member from each member of the array:\n\nThe next example is similar but uses the function to aggregate the values back into a SQL array.\n\nFor more information about arrays, see Working with arrays in GoogleSQL.\n\nThe type has a special value that is different from the SQL . A JSON is not treated as a SQL value, as the following example shows.\n\nWhen you extract a JSON field with a value, the behavior depends on the function:\n• The function returns a JSON , because it is a valid value.\n• The function returns the SQL , because JSON is not a scalar value.\n\nThe following example shows the different behaviors:"
    }
]