[
    {
        "link": "https://github.com/ccxt/ccxt/wiki/manual",
        "document": "The ccxt library is a collection of available crypto exchanges or exchange classes. Each class implements the public and private API for a particular crypto exchange. All exchanges are derived from the base Exchange class and share a set of common methods. To access a particular exchange from ccxt library you need to create an instance of corresponding exchange class. Supported exchanges are updated frequently and new exchanges are added regularly.\n\nThe structure of the library can be outlined as follows:\n\nFull public and private HTTP REST APIs for all exchanges are implemented. WebSocket implementations in JavaScript, PHP, Python are available in CCXT Pro, which is a professional addon to CCXT with support for WebSocket streams.\n\nThe CCXT library currently supports the following 106 cryptocurrency exchange markets and trading APIs:\n\nBesides making basic market and limit orders, some exchanges offer margin trading (leverage), various derivatives (like futures contracts and options) and also have dark pools, OTC (over-the-counter trading), merchant APIs and much more.\n\nTo connect to an exchange and start trading you need to instantiate an exchange class from ccxt library.\n\nTo get the full list of ids of supported exchanges programmatically:\n\nAn exchange can be instantiated like shown in the examples below:\n\nThe ccxt library in PHP uses builtin UTC/GMT time functions, therefore you are required to set date.timezone in your php.ini or call date_default_timezone_set() function before using the PHP version of the library. The recommended timezone setting is .\n\nMajor exchanges have the property available, where you can see what methods and functionalities are supported for each market-type (if any method is set to it means method is \"not supported\" by the exchange)\n\nthis feature is currently a work in progress and might be incomplete, feel free to report any issues you find in it\n\nMost of exchange properties as well as specific options can be overrided upon exchange class instantiation or afterwards, like shown below:\n\nIn all CCXT-supported languages, you can override instance methods during runtime:\n\nSome exchanges also offer separate APIs for testing purposes that allows developers to trade virtual money for free and test out their ideas. Those APIs are called \"testnets\", \"sandboxes\" or \"staging environments\" (with virtual testing assets) as opposed to \"mainnets\" and \"production environments\" (with real assets). Most often a sandboxed API is a clone of a production API, so, it's literally the same API, except for the URL to the exchange server.\n\nCCXT unifies that aspect and allows the user to switch to the exchange's sandbox (if supported by the underlying exchange). To switch to the sandbox one has to call the or immediately after creating the exchange before any other call!\n• The has to be your first call immediately after creating the exchange (before any other calls)\n• To obtain the API keys to the sandbox the user has to register with the sandbox website of the exchange in question and create a sandbox keypair\n• Sandbox keys are not interchangeable with production keys!\n\nEvery exchange has a set of properties and methods, most of which you can override by passing an associative array of params to an exchange constructor. You can also make a subclass and override everything.\n\nHere's an overview of generic exchange properties with values added for example:\n\nBelow is a detailed description of each of the base exchange properties:\n• : Each exchange has a default id. The id is not used for anything, it's a string literal for user-land exchange instance identification purposes. You can have multiple links to the same exchange and differentiate them by ids. Default ids are all lowercase and correspond to exchange names.\n• : This is a string literal containing the human-readable exchange name.\n• : An array of string literals of 2-symbol ISO country codes, where the exchange is operating from.\n• : The single string literal base URL for API calls or an associative array of separate URLs for private and public APIs.\n• : A single string URL link to original documentation for exchange API on their website or an array of links to docs.\n• : A string literal containing version identifier for current exchange API. The ccxt library will append this version string to the API Base URL upon each request. You don't have to modify it, unless you are implementing a new exchange API. The version identifier is a usually a numeric string starting with a letter 'v' in some cases, like v1.1. Do not override it unless you are implementing your own new crypto exchange class.\n• : An associative array containing a definition of all API endpoints exposed by a crypto exchange. The API definition is used by ccxt to automatically construct callable instance methods for each available endpoint.\n• : This is an associative array of exchange capabilities (e.g , or ).\n• : An associative array of timeframes, supported by the fetchOHLCV method of the exchange. This is only populated when property is true.\n• : A timeout in milliseconds for a request-response roundtrip (default timeout is 10000 ms = 10 seconds). If the response is not received in that time, the library will throw an exception. You can leave the default timeout value or set it to a reasonable value. Hanging forever with no timeout is not your option, for sure. You don't have to override this option in general case.\n• : A request rate limit in milliseconds. Specifies the required minimal delay between two consequent HTTP requests to the same exchange. The built-in rate-limiter is enabled by default and can be turned off by setting the property to false.\n• : A boolean (true/false) value that enables the built-in rate limiter and throttles consecutive requests. This setting is (enabled) by default. The user is required to implement own rate limiting or leave the built-in rate limiter enabled to avoid being banned from the exchange.\n• : An object to set HTTP User-Agent header to. The ccxt library will set its User-Agent by default. Some exchanges may not like it. If you are having difficulties getting a reply from an exchange and want to turn User-Agent off or use the default one, set this value to false, undefined, or an empty string. The value of may be overrided by HTTP property below.\n• : An associative array of HTTP headers and their values. Default value is empty . All headers will be prepended to all requests. If the header is set within , it will override whatever value is set in the property above.\n• : A boolean flag indicating whether to log HTTP requests to stdout (verbose flag is false by default). Python people have an alternative way of DEBUG logging with a standard pythonic logger, which is enabled by adding these two lines to the beginning of their code:\n• : An associative array of markets indexed by common trading pairs or symbols. Markets should be loaded prior to accessing this property. Markets are unavailable until you call the method on exchange instance.\n• : A non-associative array (a list) of symbols available with an exchange, sorted in alphabetical order. These are the keys of the property. Symbols are loaded and reloaded from markets. This property is a convenient shorthand for all market keys.\n• : An associative array (a dict) of currencies by codes (usually 3 or 4 letters) available with an exchange. Currencies are loaded and reloaded from markets.\n• : An associative array of arrays of markets indexed by exchange-specific ids. Typically a length one array unless there are multiple markets with the same marketId. Markets should be loaded prior to accessing this property.\n• : This is your public API key string literal. Most exchanges require API keys setup.\n• : Your private secret API key string literal. Most exchanges require this as well together with the apiKey.\n• : A string literal with your password/phrase. Some exchanges require this parameter for trading, but most of them don't.\n• : A unique id of your account. This can be a string literal or a number. Some exchanges also require this for trading, but most of them don't.\n• : A unified associative dictionary that shows which of the above API credentials are required for sending private API calls to the underlying exchange (an exchange may require a specific set of keys).\n• : An exchange-specific associative dictionary containing special keys and options that are accepted by the underlying exchange and supported in CCXT.\n• : The exchange decimal precision counting mode, read more about Precision And Limits\n• For proxies - , , , , , , : An url of specific proxy. Read details in Proxy section.\n\nSee this section on Overriding exchange properties.\n• : An assoc-array containing flags for exchange capabilities, including the following: : : // has Cross-Origin Resource Sharing enabled (works from browser) or not // unified methods availability flags (can be true, false, or 'emulated'): : : : : : : : : : : : : : : : : : : : : : : : ... The meaning of each flag showing availability of this or that method is:\n• a value of / / means the method is not currently implemented in ccxt (either ccxt has not unified it yet or the method isn't natively available from the exchange API)\n• boolean specifically means that the endpoint isn't natively available from the exchange API\n• boolean means the endpoint is natively available from the exchange API and unified in the ccxt library\n• string means the endpoint isn't natively available from the exchange API but reconstructed (as much as possible) by the ccxt library from other available true-methods For a complete list of all exchages and their supported methods, please, refer to this example: https://github.com/ccxt/ccxt/blob/master/examples/js/exchange-capabilities.js\n\nExchanges usually impose what is called a rate limit. Exchanges will remember and track your user credentials and your IP address and will not allow you to query the API too frequently. They balance their load and control traffic congestion to protect API servers from (D)DoS and misuse.\n\nWARNING: Stay under the rate limit to avoid ban!\n\nMost exchanges allow up to 1 or 2 requests per second. Exchanges may temporarily restrict your access to their API or ban you for some period of time if you are too aggressive with your requests.\n\nThe property is set to a safe default which is sub-optimal. Some exchanges may have varying rate limits for different endpoints. It is up to the user to tweak according to application-specific purposes.\n\nThe CCXT library has a built-in experimental rate-limiter that will do the necessary throttling in background transparently to the user. WARNING: users are responsible for at least some type of rate-limiting: either by implementing a custom algorithm or by doing it with the built-in rate-limiter..\n\nYou can turn on/off the built-in rate-limiter with property, like so:\n\nIn case your calls hit a rate limit or get nonce errors, the ccxt library will throw an exception, or, in some cases, one of the following types:\n\nA later retry is usually enough to handle that.\n\nThe rate limiter is a property of the exchange instance, in other words, each exchange instance has its own rate limiter that is not aware of the other instances. In many cases the user should reuse the same exchange instance throughout the program. Do not use multiple instances of the same exchange with the same API keypair from the same IP address.\n\nReuse the exchange instance as much as possible as shown below:\n\nSince the rate limiter belongs to the exchange instance, destroying the exchange instance will destroy the rate limiter as well. Among the most common pitfalls with the rate limiting is creating and dropping the exchange instance over and over again. If in your program you are creating and destroying the exchange instance (say, inside a function that is called multiple times), then you are effectively resetting the rate limiter over and over and that will eventually break the rate limits. If you are recreating the exchange instance every time instead of reusing it, CCXT will try to load the markets every time. Therefore, you will force-load the markets over and over as explained in the Loading Markets section. Abusing the markets endpoint will eventually break the rate limiter as well.\n\nDo not break this rule unless you really understand the inner workings of the rate-limiter and you are 100% sure you know what you're doing. In order to stay safe always reuse the exchange instance throughout your functions and methods callchain like shown below:\n\nSome exchanges are DDoS-protected by Cloudflare or Incapsula. Your IP can get temporarily blocked during periods of high load. Sometimes they even restrict whole countries and regions. In that case their servers usually return a page that states a HTTP 40x error or runs an AJAX test of your browser / captcha test and delays the reload of the page for several seconds. Then your browser/fingerprint is granted access temporarily and gets added to a whitelist or receives a HTTP cookie for further use.\n\nThe most common symptoms for a DDoS protection problem, rate-limiting problem or for a location-based filtering issue:\n• Getting exceptions with all types of exchange methods\n• Catching or with HTTP error codes 400, 403, 404, 429, 500, 501, 503, etc..\n• Getting a template HTML page instead of JSON from the exchange\n\nIf you encounter DDoS protection errors and cannot reach a particular exchange then:\n• use a proxy (this is less responsive, though)\n• ask the exchange support to add you to a whitelist\n• try an alternative IP within a different geographic region\n• run your software in a distributed network of servers\n• run your software in close proximity to the exchange (same country, same city, same datacenter, same server rack, same server)\n\nEach exchange is a place for trading some kinds of valuables. The exchanges may use differing terms to call them: \"a currency\", \"an asset\", \"a coin\", \"a token\", \"stock\", \"commodity\", \"crypto\", \"fiat\", etc. A place for trading one asset for another is usually called \"a market\", \"a symbol\", \"a trading pair\", \"a contract\", etc.\n\nIn terms of the ccxt library, every exchange offers multiple markets within itself. Each market is defined by two or more currencies. The set of markets differs from exchange to exchange opening possibilities for cross-exchange and cross-market arbitrage.\n\nEach currency is an associative array (aka dictionary) with the following keys:\n• . The string or numeric ID of the currency within the exchange. Currency ids are used inside exchanges internally to identify coins during the request/response process.\n• . An uppercase string code representation of a particular currency. Currency codes are used to reference currencies within the ccxt library (explained below).\n• . A human-readable name of the currency (can be a mix of uppercase & lowercase characters).\n• . The withdrawal fee value as specified by the exchange. In most cases it means a flat fixed amount paid in the same currency. If the exchnange does not specify it via public endpoints, the can be or missing.\n• . A boolean indicating whether trading or funding (depositing or withdrawing) for this currency is currently possible, more about it here: status.\n• . An associative array of non-common market properties, including fees, rates, limits and other general market information. The internal info array is different for each particular market, its contents depend on the exchange.\n• . Precision accepted in values by exchanges upon referencing this currency. The value of this property depends on .\n• . The minimums and maximums for amounts (volumes), withdrawals and deposits.\n\nEach network is an associative array (aka dictionary) with the following keys:\n• . The string or numeric ID of the network within the exchange. Network ids are used inside exchanges internally to identify networks during the request/response process.\n• . An uppercase string representation of a particular network. Networks are used to reference networks within the ccxt library.\n• . A human-readable name of the network (can be a mix of uppercase & lowercase characters).\n• . The withdrawal fee value as specified by the exchange. In most cases it means a flat fixed amount paid in the same currency. If the exchnange does not specify it via public endpoints, the can be or missing.\n• . A boolean indicating whether trading or funding (depositing or withdrawing) for this currency is currently possible, more about it here: status.\n• . An associative array of non-common market properties, including fees, rates, limits and other general market information. The internal info array is different for each particular market, its contents depend on the exchange.\n• . Precision accepted in values by exchanges upon referencing this currency. The value of this property depends on .\n• . The minimums and maximums for amounts (volumes), withdrawals and deposits.\n\nEach market is an associative array (aka dictionary) with the following keys:\n• . The string or numeric ID of the market or trade instrument within the exchange. Market ids are used inside exchanges internally to identify trading pairs during the request/response process.\n• . An uppercase string code representation of a particular trading pair or instrument. This is usually written as with a slash as in , or , etc. Symbols are used to reference markets within the ccxt library (explained below).\n• . A unified uppercase string code of base fiat or crypto currency. This is the standardized currency code that is used to refer to that currency or token throughout CCXT and throughout the Unified CCXT API, it's the language that CCXT understands.\n• . An exchange-specific id of the base currency for this market, not unified. Can be any string, literally. This is communicated to the exchange using the language the exchange understands.\n• . An exchange-specific id of the quote currency, not unified.\n• . A boolean indicating whether or not trading this market is currently possible, more about it here: status.\n• . Float, 0.0015 = 0.15%. Maker fees are paid when you provide liquidity to the exchange i.e. you market-make an order and someone else fills it. Maker fees are usually lower than taker fees. Fees can be negative, this is very common amongst derivative exchanges. A negative fee means the exchange will pay a rebate (reward) to the user for trading this market (note, 'taker' and 'maker' publicly available fees, not taking into consideration your vip-level/volume/etc. Use to get the fees specific to your account).\n• . Float, 0.002 = 0.2%. Taker fees are paid when you take liquidity from the exchange and fill someone else's order.\n• . A boolean true/false value indicating whether and are multipliers or fixed flat amounts.\n• . A boolean true/false value indicating whether the fee depends on your trading tier (usually, your traded volume over a period of time).\n• . An associative array of non-common market properties, including fees, rates, limits and other general market information. The internal info array is different for each particular market, its contents depend on the exchange.\n• . Precision accepted in order values by exchanges upon order placement for price, amount and cost. (The value inside this property depend on the ).\n• . The minimums and maximums for prices, amounts (volumes) and costs (where cost = price * amount).\n• . The type of the option, option represents an option with the right to buy and an option with the right to sell.\n• . Price at which an option can be bought or sold when it is exercised.\n\nThe flag is typically used in and . The exchanges might put a slightly different meaning into it. If a currency is inactive, most of the time all corresponding tickers, orderbooks and other related endpoints return empty responses, all zeroes, no data or outdated information. The user should check if the currency is and reload markets periodically.\n\nNote: the value for the property doesn't always guarantee that all of the possible features like trading, withdrawing or depositing are disabled on the exchange. Likewise, neither the value guarantees that all those features are enabled on the exchange. Check the underlying exchanges' documentation and the code in CCXT for the exact meaning of the flag for this or that exchange. This flag is not yet supported or implemented by all markets and may be missing.\n\nWARNING! The information about the fee is experimental, unstable and may be partial or not available at all.\n\nDo not confuse with ! Precision has nothing to do with min limits. A precision of 8 digits does not necessarily mean a min limit of 0.00000001. The opposite is also true: a min limit of 0.0001 does not necessarily mean a precision of 4.\n\nIn this example the amount of any order placed on the market must satisfy both conditions:\n• The amount value should be >= 0.05:\n• Precision of the amount should be up to 4 decimal digits:\n\nIn this example the price of any order placed on the market must satisfy both conditions:\n• The price value should be >= 0.019:\n• Precision of price should be 5 decimal digits or less:\n\nIn this example both conditions must be satisfied:\n• The amount value should be greater than or equal to 50:\n• A negative amount precision means that the amount should be an integer multiple of 10 (to the absolute power specified):\n\nThe and params are currently under heavy development, some of these fields may be missing here and there until the unification process is complete. This does not influence most of the orders but can be significant in extreme cases of very large or very small orders.\n\nThe user is required to stay within all limits and precision! The values of the order should satisfy the following conditions:\n• Precision of must be <=\n• Precision of must be <=\n\nThe above values can be missing with some exchanges that don't provide info on limits from their API or don't have it implemented yet.\n\nEach exchange has its own rounding, counting and padding modes.\n• – will round the last decimal digits to precision\n• – will cut off the digits after certain precision\n\nThe decimal precision counting mode is available in the property.\n• – counts all digits, 99% of exchanges use this counting mode. With this mode of precision, the numbers in designate the number of decimal digits after the dot for further rounding or truncation.\n• – counts non-zero digits only, some exchanges ( and maybe a few other) implement this mode of counting decimals. With this mode of precision, the numbers in designate the Nth place of the last significant (non-zero) decimal digit after the dot.\n• – some exchanges only allow a multiple of a specific value ( uses this mode, for example). In this mode, the numbers in designate the minimal precision fractions (floats) for rounding or truncating.\n• – appends zero characters up to precision\n\nMost of the time the user does not have to take care of precision formatting, since CCXT will handle that for the user when the user places orders or sends withdrawal requests, if the user follows the rules as described on Precision And Limits. However, in some cases precision-formatting details may be important, so the following methods may be useful in the userland.\n\nThe exchange base class contains the method to help format values to the required decimal precision with support for different rounding, counting and padding modes.\n\nFor examples of how to use the to format strings and floats, please, see the following files:\n\nPython WARNING! The method is susceptible to\n\nFor users' convenience CCXT base exchange class also implements the following methods:\n\nEvery exchange has its own precision settings, the above methods will help format those values according to exchange-specific precision rules, in a way that is portable and agnostic of the underlying exchange. In order to make that possible, markets and currencies have to be loaded prior to formatting any values.\n\nMake sure to load the markets with before calling these methods!\n\nMore practical examples that describe the behavior of :\n\nIn most cases you are required to load the list of markets and trading symbols for a particular exchange prior to accessing other API methods. If you forget to load markets the ccxt library will do that automatically upon your first call to the unified API. It will send two HTTP requests, first for markets and then the second one for other data, sequentially. For that reason, your first call to a unified CCXT API method like fetchTicker, fetchBalance, etc will take more time, than the consequent calls, since it has to do more work loading the market information from the exchange API. See Notes On Rate Limiter for more details.\n\nIn order to load markets manually beforehand call the / method on an exchange instance. It returns an associative array of markets indexed by trading symbol. If you want more control over the execution of your logic, preloading markets by hand is recommended.\n\nApart from the market info, the call will also load the currencies from the exchange and will cache the info in the and the properties respectively.\n\nThe user can also bypass the cache and call unified methods for fetching that information from the exchange endpoints directly, and , though using these methods is not recommended for end-users. The recommended way to preload markets is by calling the unified method. However, new exchange integrations are required to implement these methods if the underlying exchange has the corresponding API endpoints.\n\nA currency code is a code of three to five letters, like , , , , , , , , , , , etc. Some exchanges have exotic currencies with longer codes.\n\nA symbol is usually an uppercase string literal name of a pair of traded currencies with a slash in between. The first currency before the slash is usually called base currency, and the one after the slash is called quote currency. Examples of a symbol are: , , , , , , .\n\nMarket ids are used during the REST request-response process to reference trading pairs within exchanges. The set of market ids is unique per exchange and cannot be used across exchanges. For example, the BTC/USD pair/market may have different ids on various popular exchanges, like , , , , (numeric id), , , , . You don't need to remember or use market ids, they are there for internal HTTP request-response purposes inside exchange implementations.\n\nThe ccxt library abstracts uncommon market ids to symbols, standardized to a common format. Symbols aren't the same as market ids. Every market is referenced by a corresponding symbol. Symbols are common across exchanges which makes them suitable for arbitrage and many other things.\n\nSometimes the user might notice a symbol like or or some other \"exotic/rare symbols\". The symbol is not required to have a slash or to be a pair of currencies. The string in the symbol really depends on the type of the market (whether it is a spot market or a futures market, a darkpool market or an expired market, etc). Attempting to parse the symbol string is highly discouraged, one should not rely on the symbol format, it is recommended to use market properties instead.\n\nMarket structures are indexed by symbols and ids. The base exchange class also has builtin methods for accessing markets by symbols. Most API methods require a symbol to be passed in their first argument. You are often required to specify a symbol when querying current prices, making orders, etc.\n\nMost of the time users will be working with market symbols. You will get a standard userland exception if you access non-existent keys in these dicts.\n\nThere is a bit of term ambiguity across various exchanges that may cause confusion among newcoming traders. Some exchanges call markets as pairs, whereas other exchanges call symbols as products. In terms of the ccxt library, each exchange contains one or more trading markets. Each market has an id and a symbol. Most symbols are pairs of base currency and quote currency.\n\nHistorically various symbolic names have been used to designate same trading pairs. Some cryptocurrencies (like Dash) even changed their names more than once during their ongoing lifetime. For consistency across exchanges the ccxt library will perform the following known substitutions for symbols and currencies:\n• : is newer but is more common among exchanges and sounds more like bitcoin (read more).\n• : The Bitcoin Cash fork is often called with two different symbolic names: and . The name is ambiguous for Bitcoin Cash, it is confused with BitConnect. The ccxt library will convert to where it is appropriate (some exchanges and aggregators confuse them).\n• : was Darkcoin then became Dash (read more).\n• : On November 15 2018 Bitcoin Cash forked the second time, so, now there is (for BCH ABC) and (for BCH SV).\n• : This is a common substitution mapping for the Bitcoin Cash SV fork (some exchanges call it , others call it , we use the former).\n• : Try not to confuse symbols and currencies. The (Dashcoin) is not the same as (Dash). Some exchanges have labelled inconsistently as , the ccxt library does a correction for that as well ( ), but only on certain exchanges that have these two currencies confused, whereas most exchanges have them both correct. Just remember that is not the same as .\n• → : is the newer code for RaiBlocks, thus, CCXT unified API uses will replace the older with where needed. https://hackernoon.com/nano-rebrand-announcement-9101528a7b76\n• → : Some exchanges, like Bitfinex, HitBTC and a few other name the currency as in their listings, but those markets are actually trading . The confusion can come from a 3-letter limitation on symbol names or may be due to other reasons. In cases where the traded currency is actually and is not – the CCXT library will perform → conversion. Note, however, that some exchanges have both and symbols, for example, Kraken has a trading pair.\n\nEach exchange has an associative array of substitutions for cryptocurrency symbolic codes in the property, like:\n\nwhere key represents actual name how exchange engine refers to that coin, and the value represents what you want to refer to it with through ccxt.\n\nSometimes the user may notice exotic symbol names with mixed-case words and spaces in the code. The logic behind having these names is explained by the rules for resolving conflicts in naming and currency-coding when one or more currencies have the same symbolic code with different exchanges:\n• First, we gather all info available from the exchanges themselves about the currency codes in question. They usually have a description of their coin listings somewhere in their API or their docs, knowledgebases or elsewhere on their websites.\n• When we identify each particular cryptocurrency standing behind the currency code, we look them up on CoinMarketCap.\n• The currency that has the greatest market capitalization of all wins the currency code and keeps it. For example, HOT often stand for either or . In this case retains the code , and will have its name as its code, literally, . So, there may be trading pairs with symbols like (for ) and – those are two different markets.\n• If market cap of a particular coin is unknown or is not enough to determine the winner, we also take trading volumes and other factors into consideration.\n• When the winner is determined all other competing currencies get their code names properly remapped and substituted within conflicting exchanges via . Note, it should be defined before '.loadMarkets()' happens!\n• Unfortunately this is a work in progress, because new currencies get listed daily and new exchanges are added from time to time, so, in general this is a never-ending process of self-correction in a quickly changing environment, practically, in \"live mode\". We are thankful for all reported conflicts and mismatches you may find.\n\nIs it possible for symbols to change?\n\nIn short, yes, sometimes, but rarely. Symbolic mappings can be changed if that is absolutely required and cannot be avoided. However, all previous symbolic changes were related to resolving conflicts or forks. So far, there was no precedent of a market cap of one coin overtaking another coin with the same symbolic code in CCXT.\n\nCan we rely on always listing the same crypto with the same symbol?\n\nMore or less ) First, this library is a work in progress, and it is trying to adapt to the everchanging reality, so there may be conflicts that we will fix by changing some mappings in the future. Ultimately, the license says \"no warranties, use at your own risk\". However, we don't change symbolic mappings randomly all over the place, because we understand the consequences and we'd want to rely on the library as well and we don't like to break the backward-compatibility at all.\n\nIf it so happens that a symbol of a major token is forked or has to be changed, then the control is still in the users' hands. The property can be overrided upon initialization or later, just like any other exchange property. If a significant token is involved, we usually post instructions on how to retain the old behavior by adding a couple of lines to the constructor params.\n\nIt depends on which exchange you are using, but some of them have a reversed (inconsistent) pairing of and . They actually have base and quote misplaced (switched/reversed sides). In that case you'll see a difference of parsed and currency values with the unparsed in the market substructure.\n\nFor those exchanges the ccxt will do a correction, switching and normalizing sides of base and quote currencies when parsing exchange replies. This logic is financially and terminologically correct. If you want less confusion, remember the following rule: base is always before the slash, quote is always after the slash in any symbol and with any market.\n\nWe currently load spot markets with the unified symbol schema into the mapping, indexed by symbol. This would cause a naming conflict for futures and other derivatives that have the same symbol as their spot market counterparts. To accomodate both types of markets in the we require the symbols between 'future' and 'spot' markets to be distinct, as well as the symbols between 'linear' and 'inverse' contracts to be distinct.\n\nCCXT supports the following types of derivative contracts:\n• – for expiring futures contracts that have a delivery/settlement date\n• – for perpetual swap futures that don't have a delivery date\n\nA future market symbol consists of the underlying currency, the quoting currency, the settlement currency and an arbitrary identifier. Most often the identifier is the settlement date of the future contract in format:\n\nThe is also a dirty method with a side effect of saving the array of markets on the exchange instance. You only need to call it once per exchange. All subsequent calls to the same method will return the locally saved (cached) array of markets.\n\nWhen exchange markets are loaded, you can then access market information any time via the property. This property contains an associative array of markets indexed by symbol. If you need to force reload the list of markets after you have them loaded already, pass the reload = true flag to the same method again.\n\nEach exchange offers a set of API methods. Each method of the API is called an endpoint. Endpoints are HTTP URLs for querying various types of information. All endpoints return JSON in response to client requests.\n\nUsually, there is an endpoint for getting a list of markets from an exchange, an endpoint for retrieving an order book for a particular market, an endpoint for retrieving trade history, endpoints for placing and canceling orders, for money deposit and withdrawal, etc... Basically every kind of action you could perform within a particular exchange has a separate endpoint URL offered by the API.\n\nBecause the set of methods differs from exchange to exchange, the ccxt library implements the following:\n• a public and private API for all possible URLs and methods\n\nThe endpoint URLs are predefined in the property for each exchange. You don't have to override it, unless you are implementing a new exchange API (at least you should know what you're doing).\n\nMost of exchange-specific API methods are implicit, meaning that they aren't defined explicitly anywhere in code. The library implements a declarative approach for defining implicit (non-unified) exchanges' API methods.\n\nEach method of the API usually has its own endpoint. The library defines all endpoints for each particular exchange in the property. Upon exchange construction an implicit magic method (aka partial function or closure) will be created inside on the exchange instance for each endpoint from the list of endpoints. This is performed for all exchanges universally. Each generated method will be accessible in both and notations.\n\nThe endpoints definition is a full list of ALL API URLs exposed by an exchange. This list gets converted to callable methods upon exchange instantiation. Each URL in the API endpoint list gets a corresponding callable method. This is done automatically for all exchanges, therefore the ccxt library supports all possible URLs offered by crypto exchanges.\n\nEach implicit method gets a unique name which is constructed from the definition. For example, a private HTTPS PUT endpoint will have a corresponding exchange method named / . A public HTTPS GET endpoint would result in the corresponding method named / , and so on.\n\nAn implicit method takes a dictionary of parameters, sends the request to the exchange and returns an exchange-specific JSON result from the API as is, unparsed. To pass a parameter, add it to the dictionary explicitly under a key equal to the parameter's name. For the examples above, this would look like and .\n\nThe recommended way of working with exchanges is not using exchange-specific implicit methods but using the unified ccxt methods instead. The exchange-specific methods should be used as a fallback in cases when a corresponding unified method isn't available (yet).\n\nTo get a list of all available methods with an exchange instance, including implicit methods and unified methods you can simply do the following:\n\nAPI URLs are often grouped into two sets of methods called a public API for market data and a private API for trading and account access. These groups of API methods are usually prefixed with a word 'public' or 'private'.\n\nA public API is used to access market data and does not require any authentication whatsoever. Most exchanges provide market data openly to all (under their rate limit). With the ccxt library anyone can access market data out of the box without having to register with the exchanges and without setting up account keys and passwords.\n\nThe private API is mostly used for trading and for accessing account-specific private data, therefore it requires authentication. You have to get the private API keys from the exchanges. It often means registering with an exchange website and creating the API keys for your account. Most exchanges require personal information or identification. Some exchanges will only allow trading after completing the KYC verification. Private APIs allow the following:\n\nSome exchanges offer the same logic under different names. For example, a public API is also often called market data, basic, market, mapi, api, price, etc... All of them mean a set of methods for accessing data available to public. A private API is also often called trading, trade, tapi, exchange, account, etc...\n\nA few exchanges also expose a merchant API which allows you to create invoices and accept crypto and fiat payments from your clients. This kind of API is often called merchant, wallet, payment, ecapi (for e-commerce).\n\nTo get a list of all available methods with an exchange instance, you can simply do the following:\n\ncontract only and margin only\n• methods in this documentation that are documented as contract only or margin only are only intended to be used for contract trading and margin trading respectively. They may work when trading in other types of markets but will most likely return irrelevant information.\n\nIn the JavaScript version of CCXT all methods are asynchronous and return Promises that resolve with a decoded JSON object. In CCXT we use the modern async/await syntax to work with Promises. If you're not familiar with that syntax, you can read more about it here.\n\nThe ccxt library supports asynchronous concurrency mode in Python 3.5+ with async/await syntax. The asynchronous Python version uses pure asyncio with aiohttp. In async mode you have all the same properties and methods, but most methods are decorated with an async keyword. If you want to use async mode, you should link against the subpackage, like in the following example:\n\nCCXT support PHP 8+ versions. The library has both synchronous and asynchronous versions. To use synchronous version, use namespace (i.e. ) and to use asynchronous version, use namespace (i.e. ). Asynchronous version uses ReactPHP library in the background. In async mode you have all the same properties and methods, but any networking API method should be decorated with the keyword and your script should be in a ReactPHP wrapper:\n\nSee further examples in the directory; look for filenames that include the word. Also, make sure you have installed the required dependencies using . Lastly, this article provides a good introduction to the methods used here. While syntactically the change is simple (i.e., just using a keyword before relevant methods), concurrency has significant implications for the overall design of your code.\n\nAll public and private API methods return raw decoded JSON objects in response from the exchanges, as is, untouched. The unified API returns JSON-decoded objects in a common format and structured uniformly across all exchanges.\n\nThe set of all possible API endpoints differs from exchange to exchange. Most of methods accept a single associative array (or a Python dict) of key-value parameters. The params are passed as follows:\n\nThe unified methods of exchanges might expect and will accept various which affect their functionality, like:\n\nAn exchange will not accept the params from a different exchange, they're not interchangeable. The list of accepted parameters is defined by each specific exchange.\n\nTo find which parameters can be passed to a unified method:\n• either open the exchange-specific implementation file and search for the desired function (i.e. ) to inspect and find out the details of usage\n• or go to the exchange's API docs and read the list of parameters for your specific function or endpoint (i.e. )\n\nFor a full list of accepted method parameters for each exchange, please consult API docs.\n\nAn exchange method name is a concatenated string consisting of type (public or private), HTTP method (GET, POST, PUT, DELETE) and endpoint URL path like in the following examples:\n\nThe ccxt library supports both camelcase notation (preferred in JavaScript) and underscore notation (preferred in Python and PHP), therefore all methods can be called in either notation or coding style in any language. Both of these notations work in JavaScript, Python and PHP:\n\nTo get a list of all available methods with an exchange instance, you can simply do the following:\n\nThe unified ccxt API is a subset of methods common among the exchanges. It currently contains the following methods:\n• : Fetches a list of all available markets from an exchange and returns an array of markets (objects with properties such as , , etc.). Some exchanges do not have means for obtaining a list of markets via their online API. For those, the list of markets is hardcoded.\n• : Fetches all available currencies an exchange and returns an associative dictionary of currencies (objects with properties such as , , etc.). Some exchanges do not have means for obtaining currencies via their online API. For those, the currencies will be extracted from market pairs or hardcoded.\n• : Returns the list of markets as an object indexed by symbol and caches it with the exchange instance. Returns cached markets if loaded already, unless the flag is forced.\n• : Returns information regarding the exchange status from either the info hardcoded in the exchange instance or the API, if available.\n\nNote, that most of methods of the unified API accept an optional argument. It is an associative array (a dictionary, empty by default) containing the params you want to override. The contents of are exchange-specific, consult the exchanges' API documentation for supported fields and values. Use the dictionary if you need to pass a custom setting or an optional parameter to your unified query.\n\nMost of unified methods will return either a single object or a plain array (a list) of objects (trades, orders, transactions and so on). However, very few exchanges (if any at all) will return all orders, all trades, all ohlcv candles or all transactions at once. Most often their APIs output to a certain number of most recent objects. YOU CANNOT GET ALL OBJECTS SINCE THE BEGINNING OF TIME TO THE PRESENT MOMENT IN JUST ONE CALL. Practically, very few exchanges will tolerate or allow that.\n\nTo fetch historical orders or trades, the user will need to traverse the data in portions or \"pages\" of objects. Pagination often implies \"fetching portions of data one by one\" in a loop.\n\nIn most cases users are required to use at least some type of pagination in order to get the expected results consistently. If the user does not apply any pagination, most methods will return the exchanges' default, which may start from the beginning of history or may be a subset of most recent objects. The default behaviour (without pagination) is exchange-specific! The means of pagination are often used with the following methods in particular:\n\nWith methods returning lists of objects, exchanges may offer one or more types of pagination. CCXT unifies date-based pagination by default, with timestamps in milliseconds throughout the entire library.\n\nWarning: this is an experimental feature and might produce unexpected/incorrect results in some instances.\n\nRecently, CCXT introduced a way to paginate through several results automatically by just providing the flag inside lifting this work from the userland. Most leading exchanges support it, and more will be added in the future, but the easiest way to check it is to look in the method's documentation and search for the pagination parameter. As always there are exceptions, and some endpoints might not provide a way to paginate either through a timestamp or a cursor, and in those cases, there's nothing CCXT can do about it.\n\nRight now, we have three different ways of paginating:\n• dynamic/time-based: uses the and parameters to paginate through dynamic results like (trades, orders, transactions, etc). Since we don't know a priori how many entries are available to be fetched, it will perform one request at a time until we reach the end of the data or the maximum amount of pagination calls (configurable through an option)\n• deterministic: when we can pre-compute the boundaries of each page, it will perform the requests concurrently for maximum performance. This applies to OHLCV, Funding Rates, and Open Interest and also respects the option.\n• cursor-based: when the exchange provides a cursor inside the response, we extract the cursor and perform the subsequent request until the end of the data or reach the maximum number of pagination calls.\n\nThe user cannot select the pagination method used, it will depend from implementation to implementation, considering the exchange API's features.\n\nWe can't perform an infinite amount of requests, and some of them might throw an error for different reasons, thus, we have some options that allow the user to control these variables and other pagination specificities.\n\nAll the options below, should be provided inside , you can check the examples below\n• paginate: (boolean) indicates that the user wants to paginate through different pages to get more data. Default is false.\n• paginationCalls: (integer) allows the user to control the maximum amount of requests to paginate the data. Due to the rate limits, this value should not be too high. Default is 10.\n• maxRetries: (integer) how many times should the pagination mechanism retry upon getting an error. Default is 3\n• paginationDirection: (string) Only applies to the dynamic pagination and it can be either forward (start the pagination from some time in the past and paginate forward) or backward (start from the most recent time and paginate backward). If forward is selected then a since parameter must also be provided. Default is backward.\n• maxEntriesPerRequest: (integer): The max amount of entries per request so that we can maximize the data retrieved per call. It varies from endpoint to endpoint and CCXT will populate this value for you, but you can override it if needed.\n\nAll unified timestamps throughout the CCXT library are integers in milliseconds unless explicitly stated otherwise.\n\nBelow is the set of methods for working with UTC dates and timestamps and for converting between them:\n\nThis is the type of pagination currently used throughout the CCXT Unified API. The user supplies a timestamp in milliseconds (!) and a number to results. To traverse the objects of interest page by page, the user runs the following (below is pseudocode, it may require overriding some exchange-specific params, depending on the exchange in question):\n\nThe user supplies a of the object, from where the query should continue returning results, and a number to results. This is the default with some exchanges, however, this type is not unified (yet). To paginate objects based on their ids, the user would run the following:\n\nThe user supplies a page number or an initial \"cursor\" value. The exchange returns a page of results and the next \"cursor\" value, to proceed from. Most of exchanges that implement this type of pagination will either return the next cursor within the response itself or will return the next cursor values within HTTP response headers.\n\nSee an example implementation here: https://github.com/ccxt/ccxt/blob/master/examples/py/coinbasepro-fetch-my-trades-pagination.py\n\nUpon each iteration of the loop the user has to take the next cursor and put it into the overrided params for the next query (on the following iteration):\n\nExchanges expose information on open orders with bid (buy) and ask (sell) prices, volumes and other data. Usually there is a separate endpoint for querying current state (stack frame) of the order book for a particular market. An order book is also often called market depth. The order book information is used in the trading decision making process.\n\nTo get data on order books, you can use\n• // for the order books of all markets\n• limit (Integer) The number of orders to return in the order book (e.g. )\n• limit (Integer) The number of orders to return in the order book (e.g. )\n\nThe timestamp and datetime may be missing ( ) if the exchange in question does not provide a corresponding value in the API response.\n\nPrices and amounts are floats. The bids array is sorted by price in descending order. The best (highest) bid price is the first element and the worst (lowest) bid price is the last element. The asks array is sorted by price in ascending order. The best (lowest) ask price is the first element and the worst (highest) ask price is the last element. Bid/ask arrays can be empty if there are no corresponding orders in the order book of an exchange.\n\nExchanges may return the stack of orders in various levels of details for analysis. It is either in full detail containing each and every order, or it is aggregated having slightly less detail where orders are grouped and merged by price and volume. Having greater detail requires more traffic and bandwidth and is slower in general but gives a benefit of higher precision. Having less detail is usually faster, but may not be enough in some very specific cases.\n• The is the time when the exchange generated this orderbook response (before replying it back to you). This may be missing ( ), as documented in the Manual, not all exchanges provide a timestamp there. If it is defined, then it is the UTC timestamp in milliseconds since 1 Jan 1970 00:00:00.\n• Some exchanges may index orders in the orderbook by order ids, in that case the order id may be returned as the third element of bids and asks: . This is often the case with L3 orderbooks without aggregation. The order , if shown in the orderbook, refers to the orderbook and does not necessarily correspond to the actual order id from the exchanges' database as seen by the owner or by the others. The order id is an of the row inside the orderbook, but not necessarily the true- of the order (though, they may be equal as well, depending on the exchange in question).\n• In some cases the exchanges may supply L2 aggregated orderbooks with order counts for each aggregated level, in that case the order count may be returned as the third element of bids and asks: . The tells how many orders are aggregated on each price level in bids and asks.\n• Also, some exchanges may return the order timestamp as the third element of bids and asks: . The tells when the order was placed on the orderbook.\n\nSome exchanges accept a dictionary of extra parameters to the function. All extra are exchange-specific (non-unified). You will need to consult exchanges docs if you want to override a particular param, like the depth of the order book. You can get a limited count of returned orders or a desired level of aggregation (aka market depth) by specifying an limit argument and exchange-specific extra like so:\n\nThe levels of detail or levels of order book aggregation are often number-labelled like L1, L2, L3...\n• L1: less detail for quickly obtaining very basic info, namely, the market price only. It appears to look like just one order in the order book.\n• L2: most common level of aggregation where order volumes are grouped by price. If two orders have the same price, they appear as one single order for a volume equal to their total sum. This is most likely the level of aggregation you need for the majority of purposes.\n• L3: most detailed level with no aggregation where each order is separate from other orders. This LOD naturally contains duplicates in the output. So, if two orders have equal prices they are not merged together and it's up to the exchange's matching engine to decide on their priority in the stack. You don't really need L3 detail for successful trading. In fact, you most probably don't need it at all. Therefore some exchanges don't support it and always return aggregated order books.\n\nIf you want to get an L2 order book, whatever the exchange returns, use the or unified method for that.\n\nThe argument does not guarantee that the number of bids or asks will always be equal to . It designates the upper boundary or the maximum, so at some moment in time there may be less than bids or asks. This is the case when the exchange does not have enough orders on the orderbook. However, if the underlying exchange API does not support a parameter for the orderbook endpoint at all, then the argument will be ignored. CCXT does not trim and if the exchange returns more than you request.\n\nIn order to get current best price (query market price) and calculate bidask spread take first elements from bid and ask, like so:\n\nA price ticker contains statistics for a particular market/symbol for some period of time in recent past, usually last 24 hours. The methods for fetching tickers are described below.\n\nCheck the and properties of the exchange instance to determine if the exchange in question does support these methods.\n\nPlease, note, that calling without a symbol is usually strictly rate-limited, an exchange may ban you if you poll that endpoint too frequently.\n\nA ticker is a statistical calculation with the information calculated over the past 24 hours for a specific market.\n\nThe structure of a ticker is as follows:\n• All fields in the ticker represent the past 24 hours prior to .\n• The is the volume (amount) of current best bid in the orderbook.\n• The is the volume (amount) of current best ask in the orderbook.\n• The is the amount of base currency traded (bought or sold) in last 24 hours.\n• The is the amount of quote currency traded (bought or sold) in last 24 hours.\n\nAll prices in ticker structure are in quote currency. Some fields in a returned ticker structure may be undefined/None/null.\n\nTimestamp and datetime are both Universal Time Coordinated (UTC) in milliseconds.\n• is the time when the exchange generated this response (before replying it back to you). It may be missing ( ), as documented in the Manual, not all exchanges provide a timestamp there. If it is defined, then it is a UTC timestamp in milliseconds since 1 Jan 1970 00:00:00.\n• is the date-time string of the last HTTP response received (from HTTP headers). The 'Date' parser should respect the timezone designated there. The precision of the date-time is 1 second, 1000 milliseconds. This date should be set by the exchange server when the message originated according to the following standards:\n\nAlthough some exchanges do mix-in orderbook's top bid/ask prices into their tickers (and some exchanges even serve top bid/ask volumes) you should not treat a ticker as a replacement. The main purpose of a ticker is to serve statistical data, as such, treat it as \"live 24h OHLCV\". It is known that exchanges discourage frequent requests by imposing stricter rate limits on these queries. If you need a unified way to access bids and asks you should use family instead.\n\nTo get historical prices and volumes use the unified method where available. To get historical mark, index, and premium index prices, add one of , , respectively to the params-overrides of . There are also convenience methods , , and that obtain the mark, index and premiumIndex historical prices and volumes.\n\nTo get the individual ticker data from an exchange for a particular trading pair or a specific symbol – call the :\n\nSome exchanges (not all of them) also support fetching all tickers at once. See their docs for details. You can fetch all tickers with a single call like so:\n\nFetching all tickers requires more traffic than fetching a single ticker. Also, note that some exchanges impose higher rate-limits on subsequent fetches of all tickers (see their docs on corresponding endpoints for details). The cost of the call in terms of rate limit is often higher than average. If you only need one ticker, fetching by a particular symbol is faster as well. You probably want to fetch all tickers only if you really need all of them and, most likely, you don't want to fetchTickers more frequently than once in a minute or so.\n\nAlso, some exchanges may impose additional requirements on the call, sometimes you can't fetch the tickers for all symbols because of the API limitations of the exchange in question. Some exchanges accept a list of symbols in HTTP URL query params, however, because URL length is limited, and in extreme cases exchanges can have thousands of markets – a list of all their symbols simply would not fit in the URL, so it has to be a limited subset of their symbols. Sometimes, there are other reasons for requiring a list of symbols, and there may be a limit on the number of symbols you can fetch at once, but whatever the limitation, please, blame the exchange. To pass the symbols of interest to the exchange, you can supply a list of strings as the first argument to fetchTickers:\n\nNote that the list of symbols is not required in most cases, but you must add additional logic if you want to handle all possible limitations that might be imposed on the exchanges' side.\n\nLike most methods of the Unified CCXT API, the last argument to fetchTickers is the argument for overriding request parameters that are sent towards the exchange.\n\nThe structure of the returned value is as follows:\n\nA general solution for fetching all tickers from all exchanges (even the ones that don't have a corresponding API endpoint) is on the way, this section will be updated soon.\n\nMost exchanges have endpoints for fetching OHLCV data, but some of them don't. The exchange boolean (true/false) property named indicates whether the exchange supports candlestick data series or not.\n\nTo fetch OHLCV candles/bars from an exchange, ccxt has the method, which is declared in the following way:\n\nYou can call the unified / method to get the list of OHLCV candles for a particular symbol like so:\n\nTo get the list of available timeframes for your exchange see the property. Note that it is only populated when is true as well.\n\nThe returned list of candles may have one or more missing periods, if the exchange did not have any trades for the specified timerange and symbol. To a user that would appear as gaps in a continuous list of candles. That is considered normal. If the exchange did not have any candles at that time, the CCXT library will show the results as returned from the exchange itself.\n\nThere's a limit on how far back in time your requests can go. Most of exchanges will not allow to query detailed candlestick history (like those for 1-minute and 5-minute timeframes) too far in the past. They usually keep a reasonable amount of most recent candles, like 1000 last candles for any timeframe is more than enough for most of needs. You can work around that limitation by continuously fetching (aka REST polling) latest OHLCVs and storing them in a CSV file or in a database.\n\nNote that the info from the last (current) candle may be incomplete until the candle is closed (until the next candle starts).\n\nLike with most other unified and implicit methods, the method accepts as its last argument an associative array (a dictionary) of extra , which is used to override default values that are sent in requests to the exchanges. The contents of are exchange-specific, consult the exchanges' API documentation for supported fields and values.\n\nThe argument is an integer UTC timestamp in milliseconds (everywhere throughout the library with all unified methods).\n\nIf is not specified the method will return the time range as is the default from the exchange itself. This is not a bug. Some exchanges will return candles from the beginning of time, others will return most recent candles only, the exchanges' default behaviour is expected. Thus, without specifying the range of returned candles will be exchange-specific. One should pass the argument to ensure getting precisely the history range needed.\n\nCurrently, the structure CCXT uses does not include the raw response from the exchange. However, users might be able to override the return value by doing:\n\nTrading strategies require fresh up-to-date information for technical analysis, indicators and signals. Building a speculative trading strategy based on the OHLCV candles received from the exchange may have critical drawbacks. Developers should account for the details explained in this section to build successful bots.\n\nFirst and foremost, when using CCXT you're talking to the exchanges directly. CCXT is not a server, nor a service, it's a software library. All data that you are getting with CCXT is received directly from the exchanges first-hand.\n\nThe exchanges usually provide two categories of public market data:\n• Fast primary first-order data that includes real time orderbooks and trades or fills\n• Slow second-order data that includes secondary tickers and kline OHLCV candles, that are calculated from the first-order data\n\nThe primary first-order data is updated by the exchanges APIs in pseudo real time, or as close to real time as possible, as fast as possible. The second-order data requires time for the exchange to calculate it. For example, a ticker is nothing more than a rolling 24-hour statistical cut of orderbooks and trades. OHLCV candles and volumes are also calculated from first-order trades and represent fixed statistical cuts of specific periods. The volume traded within an hour is just a sum of traded volumes of the corresponding trades that happened within that hour.\n\nObviously, it takes some time for the exchange to collect the first-order data and calculate the secondary statistical data from it. That literally means that tickers and OHLCVs are always slower than orderbooks and trades. In other words, there is always some latency in the exchange API between the moment when a trade happens and the moment when a corresponding OHLCV candle is updated or published by the exchange API.\n\nThe latency (or how much time is needed by the exchange API for calculating the secondary data) depends on how fast the exchange engine is, so it is exchange-specific. Top exchange engines will usually return and update fresh last-minute OHLCV candles and tickers at a very fast rate. Some exchanges might do it in regular intervals like once a second or once in a few seconds. Slow exchange engines might take minutes to update the secondary statistical information, their APIs might return the current most recent OHLCV candle a few minutes late.\n\nIf your strategy depends on the fresh last-minute most recent data you don't want to build it based on tickers or OHLCVs received from the exchange. Tickers and exchanges' OHLCVs are only suitable for display purposes, or for simple trading strategies for hour-timeframes or day-timeframes that are less susceptible to latency.\n\nThankfully, the developers of time-critical trading strategies don't have to rely on secondary data from the exchanges and can calculate the OHLCVs and tickers in the userland. That may be faster and more efficient than waiting for the exchanges to update the info on their end. One can aggregate the public trade history by polling it frequently and calculate candles by walking over the list of trades - please take a look into \"build-ohlcv-bars\" file inside examples folder\n\nDue to the differences in their internal implementations the exchanges may be faster to update their primary and secondary market data over WebSockets. The latency remains exchange-specific, cause the exchange engine still needs time to calculate the secondary data, regardless of whether you're polling it over the RESTful API with CCXT or getting updates via WebSockets with CCXT Pro. WebSockets can improve the networking latency, so a fast exchange will work even better, but adding the support for WS subscriptions will not make a slow exchange engine work much faster.\n\nIf you want to stay on top of the second-order data latency, then you will have to calculate it on your side and beat the exchange engine in speed of doing so. Depending on the needs of your application, it may be tricky, since you will need to handle redundancy, \"data holes\" in the history, exchange downtimes, and other aspects of data aggregation which is a whole universe in itself that is impossible to fully cover in this Manual.\n\nThe fetchOHLCV method shown above returns a list (a flat array) of OHLCV candles represented by the following structure:\n\nThe list of candles is returned sorted in ascending (historical/chronological) order, oldest candle first, most recent candle last.\n\nTo obtain historical Mark, Index Price and Premium Index candlesticks pass the params-override to . The parameter accepts one of the following values:\n\nThere are also convenience methods , and\n\nSome exchanges don't offer any OHLCV method, and for those, the ccxt library will emulate OHLCV candles from Public Trades. In that case you will see . However, because the trade history is usually very limited, the emulated fetchOHLCV methods cover most recent info only and should only be used as a fallback, when no other option is available.\n\nYou can call the unified / method to get the list of most recent trades for a particular symbol. The method is declared in the following way:\n\nFor example, if you want to print recent trades for all symbols one by one sequentially (mind the rateLimit!) you would do it like so:\n\nThe fetchTrades method shown above returns an ordered list of trades (a flat array, sorted by timestamp in ascending order, oldest trade first, most recent trade last). A list of trades is represented by the trade structure.\n\nMost exchanges return most of the above fields for each trade, though there are exchanges that don't return the type, the side, the trade id or the order id of the trade. Most of the time you are guaranteed to have the timestamp, the datetime, the symbol, the price and the amount of each trade.\n\nThe second optional argument reduces the array by timestamp, the third argument reduces by number (count) of returned items.\n\nIf the user does not specify , the method will return the default range of public trades from the exchange. The default set is exchange-specific, some exchanges will return trades starting from the date of listing a pair on the exchange, other exchanges will return a reduced set of trades (like, last 24 hours, last 100 trades, etc). If the user wants precise control over the timeframe, the user is responsible for specifying the argument.\n\nMost of unified methods will return either a single object or a plain array (a list) of objects (trades). However, very few exchanges (if any at all) will return all trades at once. Most often their APIs output to a certain number of most recent objects. YOU CANNOT GET ALL OBJECTS SINCE THE BEGINNING OF TIME TO THE PRESENT MOMENT IN JUST ONE CALL. Practically, very few exchanges will tolerate or allow that.\n\nTo fetch historical trades, the user will need to traverse the data in portions or \"pages\" of objects. Pagination often implies \"fetching portions of data one by one\" in a loop.\n\nIn most cases users are required to use at least some type of pagination in order to get the expected results consistently.\n\nOn the other hand, some exchanges don't support pagination for public trades at all. In general the exchanges will provide just the most recent trades.\n\nThe / method also accepts an optional (assoc-key array/dict, empty by default) as its fourth argument. You can use it to pass extra params to method calls or to override a particular default value (where supported by the exchange). See the API docs for your exchange for more details.\n\nThe method (if available) returns the current integer timestamp in milliseconds from the exchange server.\n\nThe exchange status describes the latest known information on the availability of the exchange API. This information is either hardcoded into the exchange class or fetched live directly from the exchange API. The method can be used to get this information. The status returned by is one of:\n• Hardcoded into the exchange class, e.g. if the API has been broken or shutdown.\n• Updated using the exchange ping or endpoint to see if its alive\n\nThe method will return a status structure like shown below:\n\nThe possible values in the field are:\n• ' means the exchange was closed, and the field should contain the datetime of the shutdown\n• means that either the exchange API is broken, or the implementation of the exchange in CCXT is broken\n• means regular maintenance, and the field should contain the datetime when the exchange is expected to be operational again\n\nWhen short trading or trading with leverage on a spot market, currency must be borrowed. Interest is accrued for the borrowed currency.\n\nData on the borrow rate for a currency can be retrieved using\n• for the borrow rates of currencies in individual markets\n• A dictionary of borrow rate structures with unified currency codes as keys\n• A dictionary of isolated borrow rate structures with unified market symbols as keys\n\nThe method retrieves a history of a currencies borrow interest rate at specific time slots\n• since (Integer) Timestamp for the earliest borrow rate (e.g. )\n• limit (Integer) The maximum number of borrow rate structures to retrieve (e.g. )\n\nThe method can be used to obtain the maximum leverage for a market at varying position sizes. It can also be used to obtain the maintenance margin rate, and the max tradeable amount for a market when that information is not available from the market object\n\nWhile you can obtain the absolute maximum leverage for a market by accessing , for many contract markets, the maximum leverage will depend on the size of your position.\n\nYou can access those limits by using\n\nIn the example above:\n\nNote for Huobi users: Huobi uses both leverage and amount to determine maintenance margin rates: https://www.huobi.com/support/en-us/detail/900000089903\n\nData on the current, most recent, and next funding rates can be obtained using the methods\n• An array of funding rate structures indexed by market symbols\n\nRetrieve the current funding interval using the following methods:\n• since (Integer) Timestamp for the earliest funding rate (e.g. )\n• limit (Integer) The maximum number of funding rates to retrieve (e.g. )\n\nUse the method to get the current open interest for a symbol from the exchange.\n\nUse the method to get a history of open interest for a symbol from the exchange.\n• since (Integer) Timestamp for the earliest open interest record (e.g. )\n• limit (Integer) The maximum number of open interest structures to retrieve (e.g. )\n\nNote for OKX users: instead of a unified symbol okx.fetchOpenInterestHistory expects a unified currency code in the symbol argument (e.g. ).\n\nUse the method to get the volatility history for the code of an options underlying asset from the exchange.\n\nUse the method to get the market id's of underlying assets for a contract market type from the exchange.\n\nUse the method to get the public settlement history for a contract market from the exchange.\n• since (Integer) Timestamp for the earliest settlement (e.g. )\n• limit (Integer) The maximum number of settlements to retrieve (e.g. )\n\nUse the method to get the public liquidations of a trading pair from the exchange.\n• since (Integer) Timestamp for the earliest liquidation (e.g. )\n• limit (Integer) The maximum number of liquidations to retrieve (e.g. )\n\nUse the method to get the public greeks and implied volatility of an options trading pair from the exchange. The greeks measure how factors like the underlying assets price, time to expiration, volatility, and interest rates, affect the price of an options contract.\n\nUse the method to get the public details of a single option contract from the exchange.\n\nUse the method to get the public option chain data of an underlying currency from the exchange.\n\nUse the method to fetch the current long short ratio of a symbol and use the to fetch the history of long short ratios for a symbol.\n• for the current ratio of a single market symbol\n• for the history of ratios of a single market symbol\n• period (String) The period to calculate the ratio from (e.g. )\n• period (String) The period to calculate the ratio from (e.g. )\n• since (Integer) Timestamp for the earliest ratio (e.g. )\n• limit (Integer) The maximum number of ratios to retrieve (e.g. )\n\nIn order to be able to access your user account, perform algorithmic trading by placing market and limit orders, query balances, deposit and withdraw funds and so on, you need to obtain your API keys for authentication from each exchange you want to trade with. They usually have it available on a separate tab or page within your user account settings. API keys are exchange-specific and cannnot be interchanged under any circumstances.\n\nThe exchanges' private APIs will usually allow the following types of interaction:\n• the current state of the user's account balance can be obtained with the method as described in the Account Balance section\n• the user can place and cancel orders with , , as well as fetch current open orders and the past order history with methods like , , , , , , , as described in the section on Orders\n• the user can query the history of past trades executed with their account using , as described in the My Trades section, also see How Orders Are Related To Trades\n• the user can query their positions with and as described in the Positions section\n• the user can fetch the history of their transactions (on-chain transactions which are either deposits to the exchange account or withdrawals from the exchange account) with , or with , , and separately, depending on what is available from the exchange API\n• if the exchange API provides a ledger endpoint, the user can fetch a history of all money movements that somehow affected the balance, with that will return all accounting ledger entries such as trades, deposits, withdrawals, internal transfers between accounts, rebates, bonuses, fees, staking profits and so on, as described in the Ledger section.\n\nAuthentication with all exchanges is handled automatically if provided with proper API keys. The process of authentication usually goes through the following pattern:\n• Generate new nonce. A nonce is an integer, often a Unix Timestamp in seconds or milliseconds (since epoch January 1, 1970). The nonce should be unique to a particular request and constantly increasing, so that no two requests share the same nonce. Each next request should have greater nonce than the previous request. The default nonce is a 32-bit Unix Timestamp in seconds.\n• Append public apiKey and nonce to other endpoint params, if any, then serialize the whole thing for signing.\n• Sign the serialized params using HMAC-SHA256/384/512 or MD5 with your secret key.\n• Append the signature in Hex or Base64 and nonce to HTTP headers or body.\n\nThis process may differ from exchange to exchange. Some exchanges may want the signature in a different encoding, some of them vary in header and body param names and formats, but the general pattern is the same for all of them.\n\nYou should not share the same API keypair across multiple instances of an exchange running simultaneously, in separate scripts or in multiple threads. Using the same keypair from different instances simultaneously may cause all sorts of unexpected behaviour.\n\nDO NOT REUSE API KEYS WITH DIFFERENT SOFTWARE! The other software will screw your nonce too high. If you get InvalidNonce errors – make sure to generate a fresh new keypair first and foremost.\n\nThe authentication is already handled for you, so you don't need to perform any of those steps manually unless you are implementing a new exchange class. The only thing you need for trading is the actual API key pair.\n\nThe API credentials usually include the following:\n• . This is your public API Key and/or Token. This part is non-secret, it is included in your request header or body and sent over HTTPS in open text to identify your request. It is often a string in Hex or Base64 encoding or an UUID identifier.\n• . This is your private key. Keep it secret, don't tell it to anybody. It is used to sign your requests locally before sending them to exchanges. The secret key does not get sent over the internet in the request-response process and should not be published or emailed. It is used together with the nonce to generate a cryptographically strong signature. That signature is sent with your public key to authenticate your identity. Each request has a unique nonce and therefore a unique cryptographic signature.\n• . Some exchanges (not all of them) also generate a user id or uid for short. It can be a string or numeric literal. You should set it, if that is explicitly required by your exchange. See their docs for details.\n• . Some exchanges (not all of them) also require your password/phrase for trading. You should set this string, if that is explicitly required by your exchange. See their docs for details.\n\nIn order to create API keys find the API tab or button in your user settings on the exchange website. Then create your keys and copy-paste them to your config file. Your config file permissions should be set appropriately, unreadable to anyone except the owner.\n\nRemember to keep your apiKey and secret key safe from unauthorized use, do not send or tell it to anybody. A leak of the secret key or a breach in security can cost you a fund loss.\n\nFor checking if the user has supplied all the required credentials the base class has a method called or . Calling that method will throw an , if some of the credentials are missing or empty. The base class also has property that allows a user to see which credentials are required for this or that exchange, as shown below:\n\nTo set up an exchange for trading just assign the API credentials to an existing exchange instance or pass them to exchange constructor upon instantiation, like so:\n\nNote that your private requests will fail with an exception or error if you don't set up your API credentials before you start trading. To avoid character escaping always write your credentials in single quotes, not double quotes ( , ).\n\nWhen you get errors like or , then, most likely, the problem is not within ccxt, please avoid opening a new issue unless you ensure that:\n• You don't have typos, empty spaces, or quotes in your keys\n• Your current IP address (check IPv4 or IPv6) is added into API-KEY's whitelist (if you use proxy, consider that too)\n• You have selected the correct options in permissions list for that api-key\n• You are not accidentally mixing \"testnet\" api-keys or \"testnet\" mode in your script\n• You have checked already reported issues about this error\n\nSome exchanges required you to sign in prior to calling private methods, which can be done using the method\n\nThe default nonce is defined by the underlying exchange. You can override it with a milliseconds-nonce if you want to make private requests more frequently than once per second! Most exchanges will throttle your requests if you hit their rate limits, read API docs for your exchange carefully!\n\nIn case you need to reset the nonce it is much easier to create another pair of keys for using with private APIs. Creating new keys and setting up a fresh unused keypair in your config is usually enough for that.\n\nIn some cases you are unable to create new keys due to lack of permissions or whatever. If that happens you can still override the nonce. Base market class has the following methods for convenience:\n• : same in milliseconds (ms = 1000 * s, thousandths of a second).\n• : same in microseconds (μs = 1000 * ms, millionths of a second).\n\nThere are exchanges that confuse milliseconds with microseconds in their API docs, let's all forgive them for that, folks. You can use methods listed above to override the nonce value. If you need to use the same keypair from multiple instances simultaneously use closures or a common function to avoid nonce conflicts. In Javascript you can override the nonce by providing a parameter to the exchange constructor or by setting it explicitly on exchange object:\n\nIn Python and PHP you can do the same by subclassing and overriding nonce function of a particular exchange class:\n\nYou can get all the accounts associated with a profile by using the method\n\nThe method will return a structure like shown below:\n\nTypes of account is one of the unified account types or\n\nTo query for balance and get the amount of funds available for trading or funds locked in orders, use the method:\n\nThe and values may be undefined or missing if the underlying exchange does not provide them.\n\nSome exchanges may not return full balance info. Many exchanges do not return balances for your empty or unused accounts. In that case some currencies may be missing in returned balance structure.\n\nMost of the time you can query orders by an id or by a symbol, though not all exchanges offer a full and flexible set of endpoints for querying orders. Some exchanges might not have a method for fetching recently closed orders, the other can lack a method for getting an order by id, etc. The ccxt library will target those cases by making workarounds where possible.\n\nThe list of methods for querying orders consists of the following:\n\nNote that the naming of those methods indicates if the method returns a single order or multiple orders (an array/list of orders). The method requires a mandatory order id argument (a string). Some exchanges also require a symbol to fetch an order by id, where order ids can intersect with various trading pairs. Also, note that all other methods above return an array (a list) of orders. Most of them will require a symbol argument as well, however, some exchanges allow querying with a symbol unspecified (meaning all symbols).\n\nThe library will throw a NotSupported exception if a user calls a method that is not available from the exchange or is not implemented in ccxt.\n\nTo check if any of the above methods are available, look into the property of the exchange:\n\nA typical structure of the property usually contains the following flags corresponding to order API methods for querying orders:\n\nThe meanings of boolean and are obvious. A string value of means that particular method is missing in the exchange API and ccxt will workaround that where possible on the client-side.\n\nThe exchanges' order management APIs differ by design. The user has to understand the purpose of each specific method and how they're combined together into a complete order API:\n• – though not a part of the orders' API, it is closely related, since it provides the history of settled trades.\n• – fetches a list of all orders (either open or closed/canceled).\n• – used for placing multiple orders within the same request\n• - used for canceling all orders\n• - used for canceling all orders after the given timeout\n\nThe majority of the exchanges will have a way of fetching currently-open orders. Thus, the . If that method is not available, then most likely the that will provide a list of all orders. The exchange will return a list of open orders either from or from . One of the two methods is usually available from any exchange.\n\nSome exchanges will provide the order history, other exchanges will not. If the underlying exchange provides the order history, then the or the . If the underlying exchange does not provide the order history, then and are not available. In the latter case, the user is required to build a local cache of orders and track the open orders using and for order statuses and for marking them as closed locally in the userland (when they're not open anymore).\n\nIf the underlying exchange does not have methods for order history ( and ), then it will provide + the trade history with (see How Orders Are Related To Trades). That set of information is in many cases enough for tracking in a live-trading robot. If there's no order history – you have to track your live orders and restore historical info from open orders and historical trades.\n\nIn general, the underlying exchanges will usually provide one or more of the following types of historical data:\n\nAny of the above three methods may be missing, but the exchanges APIs will usually provide at least one of the three methods.\n\nIf the underlying exchange does not provide historical orders, the CCXT library will not emulate the missing functionality – it has to be added on the user side where necessary.\n\nPlease, note, that a certain method may be missing either because the exchange does not have a corresponding API endpoint, or because CCXT has not implemented it yet (the library is also a work in progress). In the latter case, the missing method will be added as soon as possible.\n\nAll methods returning lists of trades and lists of orders, accept the second argument and the third argument:\n\nThe second argument reduces the array by timestamp, the third argument reduces by number (count) of returned items.\n\nIf the user does not specify , the methods will return the default set of results from the exchange. The default set is exchange-specific, some exchanges will return trades or recent orders starting from the date of listing a pair on the exchange, other exchanges will return a reduced set of trades or orders (like, last 24 hours, last 100 trades, first 100 orders, etc). If the user wants precise control over the timeframe, the user is responsible for specifying the argument.\n\nNOTE: not all exchanges provide means for filtering the lists of trades and orders by starting time, so, the support for and is exchange-specific. However, most exchanges do provide at least some alternative for \"pagination\" and \"scrolling\" which can be overrided with extra argument.\n\nSome exchanges do not have a method for fetching closed orders or all orders. They will offer just the endpoint, and sometimes also a endpoint as well. Those exchanges don't have any methods for fetching the order history. To maintain the order history for those exchanges the user has to store a dictionary or a database of orders in the userland and update the orders in the database after calling methods like , , , .\n\nTo get the details of a particular order by its id, use the / method. Some exchanges also require a symbol even when fetching a particular order by id.\n\nThe signature of the fetchOrder/fetch_order method is as follows:\n\nSome exchanges don't have an endpoint for fetching an order by id, ccxt will emulate it where possible. For now it may still be missing here and there, as this is a work in progress.\n\nYou can pass custom overrided key-values in the additional params argument to supply a specific order type, or some other setting if needed.\n\nBelow are examples of using the fetchOrder method to get order info from an authenticated exchange instance:\n\nSome exchanges don't have an endpoint for fetching all orders, ccxt will emulate it where possible. For now it may still be missing here and there, as this is a work in progress.\n\nDo not confuse closed orders with trades aka fills ! An order can be closed (filled) with multiple opposing trades! So, a closed order is not the same as a trade. In general, the order does not have a at all, but each particular user trade does have , and other properties. However, many exchanges propagate those properties to the orders as well.\n\nSome exchanges don't have an endpoint for fetching closed orders, ccxt will emulate it where possible. For now it may still be missing here and there, as this is a work in progress.\n\nMost of methods returning orders within ccxt unified API will yield an order structure as described below:\n• The of an order is usually either (not filled or partially filled), (fully filled), or (unfilled and canceled, or partially filled then canceled).\n• Some exchanges allow the user to specify an expiration timestamp upon placing a new order. If the order is not filled by that time, its becomes .\n• Use the value to determine if the order is filled, partially filled or fully filled, and by how much.\n• The work on info is still in progress, fee info may be missing partially or entirely, depending on the exchange capabilities.\n• The currency may be different from both traded currencies (for example, an ETH/BTC order with fees in USD).\n• The timestamp may have no value and may be where not supported by the exchange or in case of an open order (an order that has not been filled nor partially filled yet).\n• The , if any, designates the timestamp of the last trade, in case the order is filled fully or partially, otherwise is .\n• Order prevails or has precedence over the .\n• The of an order is:\n• The of an order means the total quote volume of the order (whereas the is the base volume). The value of should be as close to the actual most recent known order cost as possible. The field itself is there mostly for convenience and can be deduced from other fields.\n• The field can be set upon placing orders by the user with custom order params. Using the the user can later distinguish between own orders. This is only available for the exchanges that do support at this time.\n\nThe field may be if not specified by the exchange. The unification of is a work in progress.\n\nPossible values for the field:\n• = Good Till Cancel(ed), the order stays on the orderbook until it is matched or canceled.\n• = Immediate Or Cancel, the order has to be matched immediately and filled either partially or completely, the unfilled remainder is canceled (or the entire order is canceled).\n• = Fill Or Kill, the order has to get fully filled and closed immediately, otherwise the entire order is canceled.\n• = Post Only, the order is either placed as a maker order, or it is canceled. This means the order must be placed on orderbook for at at least time in an unfilled state. The unification of as a option is a work in progress with unified exchanges having .\n\nThere are different types of orders that a user can send to the exchange, regular orders eventually land in the orderbook of a corresponding symbol, others orders may be more advanced. Here is a list outlining various types of orders:\n• Limit Orders – regular orders having an in base currency (how much you want to buy or sell) and a in quote currency (for which price you want to buy or sell).\n• Market Orders – regular orders having an in base currency (how much you want to buy or sell)\n• Market Buys – some exchanges require market buy orders with an in quote currency (how much you want to spend for buying)\n• Trigger Orders aka conditional orders – an advanced type of order used to wait for a certain condition on a market and then react automatically: when a is reached, the trigger order gets triggered and then a regular limit or market price order is placed, that eventually results in entering a position or exiting a position\n• Stop Loss Orders – almost the same as trigger orders, but used to close a position to stop further losses on that position: when the price reaches then the stop loss order is triggered that results in placing another regular limit or market order to close a position at a specific limit or at market price (a position with a stop loss order attached to it).\n• Take Profit Orders – a counterpart to stop loss orders, this type of order is used to close a position to take existing profits on that position: when the price reaches then the take profit order is triggered that results in placing another regular limit or market order to close a position at a specific limit or at market price (a position with a take profit order attached to it).\n• StopLoss And TakeProfit Orders Attached To A Position – advanced orders, consisting of three orders of types listed above: a regular limit or market order placed to enter a position with stop loss and/or take profit orders that will be placed upon opening that position and will be used to close that position later (when a stop loss is reached, it will close the position and will cancel its take profit counterpart, and vice versa, when a take profit is reached, it will close the position and will cancel its stop loss counterpart, these two counterparts are also known as \"OCO orders – one cancels the other), apart from the (and for the limit order) to open a position it will also require a for a stop loss order (with a limit if it's a stop loss limit order) and/or a for a take profit order (with a limit if it's a take profit limit order).\n• Trailing Orders – an order that is automatically adjusted relative to an open position, can be set to trail a specified quote amount behind the open position or can be set to trail a specified percent behind the open position, when the market price of the position is equal to the trailing order this results in entering a new position or exiting a position depending on if the trailing order has the parameter set to true or not.\n\nPlacing an order always requires a that the user has to specify (which market you want to trade).\n\nTo place an order use the method. You can use the from the returned unified order structure to query the status and the state of the order later. If you need to place multiple orders simultaneously, you can check the availability of the method.\n• symbol (String) required Unified CCXT market symbol\n• Make sure the symbol in question exists with the target exchange and is available for trading.\n• side required a string literal for the direction of your order. Unified sides:\n• give quote currency and receive base currency; for example, buying means that you will receive bitcoins for your dollars.\n• give base currency and receive quote currency; for example, buying means that you will receive dollars for your bitcoins.\n• type a string literal type of order Unified types:\n• market not allowed by some exchanges, see their docs for details\n• see #custom-order-params and #other-order-types for non-unified types\n• amount, how much of currency you want to trade usually, but not always, in units of the base currency of the trading pair symbol (the units for some exchanges are dependent on the side of the order: see their API docs for details.)\n• price the price at which the order is to be fullfilled at in units of the quote currency (ignored in market orders)\n• Some exchanges will allow to trade with limit orders only.\n\nSome fields from the returned order structure may be if that information is not returned from the exchange API's response. The user is guaranteed that the method will return a unified order structure that will contain at least the order and the (a raw response from the exchange \"as is\"):\n• There is a common error that happens when creating orders for contract markets:\n\nThis error happens when the exchange is expecting a natural number of contracts (1,2,3, etc) in the argument of . The market structure has a key called . Each contract is worth a certain amount of the base asset that is determined by the . The number of contracts multiplied by the is equal to the base amount. so to derive the number of contracts you should enter in the argument you can solve for contracts: .\n\nHere is an example of finding the :\n\nLimit orders placed on the order book of the exchange for a price specified by the trader. They are fullfilled(closed) when there are no orders in the same market at a better price, and another trader creates a market order or an opposite order for a price that matches or exceeds the price of the limit order.\n\nLimit orders may not be fully filled. This happens when the filling order is for a smaller amount than the amount specified by the limit order.\n\nalso known as\n\nMarket orders are executed immediately by fulfilling one of more already existing orders from the ask side of the exchanges order book. The orders that your market order fulfills are chosen from th top of the order book stack, meaning your market order is fulfilled at the best price available. When placing a market order you don't need to specify the price of the order, and if the price is specified, it will be ignored.\n\nYou are not guaranteed that the order will be executed for the price you observe prior to placing your order. There are multiple reasons for this, including:\n• price slippage a slight change of the price for the traded market while your order is being executed. Reasons for price slippage include, but are not limited to\n• unequivocal order sizes if a market order is for an amount that is larger than the size of the top order on the order book, then after the top order is filled, the market order will proceed to fill the next order in the order book, which means the market order is filled at multiple prices\n\nNote, that some exchanges will not accept market orders (they allow limit orders only). In order to detect programmatically if the exchange in question does support market orders or not, you can use the exchange property:\n\nIn general, when placing a or order the user has to specify just the amount of the base currency to buy or sell. However, with some exchanges market buy orders implement a different approach to calculating the value of the order.\n\nSuppose you're trading BTC/USD and the current market price for BTC is over 9000 USD. For a market buy or market sell you could specify an of 2 BTC and that would result in plus or minus 18000 USD (more or less ;)) on your account, depending on the side of the order.\n\nWith market buys some exchanges require the total cost of the order in the quote currency! The logic behind it is simple, instead of taking the amount of base currency to buy or sell some exchanges operate with \"how much quote currency you want to spend on buying in total\".\n\nTo place a market buy order with those exchanges you would not specify an amount of 2 BTC, instead you should somehow specify the total cost of the order, that is, 18000 USD in this example. The exchanges that treat orders in this way have an exchange-specific option that allows specifying the total cost of a order in two ways.\n\nThe first is the default and if you specify the along with the the total cost of the order would be calculated inside the lib from those two values with a simple multiplication ( ). The resulting would be the amount in USD quote currency that will be spent on this particular market buy order.\n\nThe second alternative is useful in cases when the user wants to calculate and specify the resulting total cost of the order himself. That can be done by setting the option to to switch it off:\n\nMore about it:\n\nIt is also possible to emulate a order with a order.\n\nWARNING this method can be risky due to high volatility, use it at your own risk and only use it when you know really well what you're doing!\n\nMost of the time a can be emulated with a at a very low price – the exchange will automatically make it a taker order for market price (the price that is currently in your best interest from the ones that are available in the order book). When the exchange detects that you're selling for a very low price it will automatically offer you the best buyer price available from the order book. That is effectively the same as placing a market sell order. Thus market orders can be emulated with limit orders (where missing).\n\nThe opposite is also true – a can be emulated with a for a very high price. Most exchanges will again close your order for best available price, that is, the market price.\n\nHowever, you should never rely on that entirely, ALWAYS test it with a small amount first! You can try that in their web interface first to verify the logic. You can sell the minimal amount at a specified limit price (an affordable amount to lose, just in case) and then check the actual filling price in trade history.\n\nLimit price orders are also known as limit orders. Some exchanges accept limit orders only. Limit orders require a price (rate per unit) to be submitted with the order. The exchange will close limit orders if and only if market price reaches the desired level.\n\nComing from traditional trading, the term \"Stop order\" has been a bit ambigious, so instead of it, in CCXT we use term \"Trigger\" order. When symbol's price reaches your \"trigger\"(\"stop\") price, the order is activated as or order, depending which one you had chosen.\n\nWe have different classification of trigger orders:\n• standalone Stop Loss or Take Profit designed to close open positions.\n• a Stop Loss or Take Profit order attached to a primary order (Conditional Trigger Order).\n\nTraditional \"stop\" order (which you might see across exchanges' websites) is now called \"trigger\" order across CCXT library. Implemented by adding a parameter. They are independent basic trigger orders that can open or close a position.\n• Typically, it is activated when price of the underlying asset/contract crosses the from any direction. However, some exchanges' API require to set too, which triggers order depending whether price is above or below . For example, if you want to trigger limit order (buy 0.1 at limit price ) once pair price crosses :\n\nTypically, exchange automatically determines 's direction (whether it is \"above\" or \"below\" current price), however, some exchanges require that you provide with either or values:\n\nNote, you can also add param to the trigger order (with a possible param), so it would act as \"stop-loss\" or \"take-profit\" order. However, for some exchanges we support \"stop-loss\" and \"take-profit\" trigger order types, which automatically involve and handling (see them below).\n\nThe same as Trigger Orders, but the direction matters. Implemented by specifying a parameter (for the stop loss triggerPrice), and also automatically implemented on behalf of user, so instead of regular Trigger Order, you can use this as an alternative.\n\nSuppose you entered a long position (you bought) at 1000 and want to protect yourself from losses from a possible price drop below 700. You would place a stop loss order with triggerPrice at 700. For that stop loss order either you would specify a limit price or it will be executed at market price.\n\nSuppose you entered a short position (you sold) at 700 and want to protect yourself from losses from a possible price pump above 1300. You would place a stop loss order with triggerPrice at 1300. For that stop loss order either you would specify a limit price or it will be executed at market price.\n\nStop Loss orders are activated when the price of the underlying asset/contract:\n• drops below the from above, for sell orders. (eg: to close a long position, and avoid further losses)\n• rises above the from below, for buy orders (eg: to close a short position, and avoid further losses)\n\nThe same as Stop Loss Orders, but the direction matters. Implemented by specifying a parameter (for the take profit triggerPrice).\n\nSuppose you entered a long position (you bought) at 1000 and want to get your profits from a possible price pump above 1300. You would place a take profit order with triggerPrice at 1300. For that take profit order either you would specify a limit price or it will be executed at market price.\n\nSuppose you entered a short position (you sold) at 700 and want to get your profits from a possible price drop below 600. You would place a take profit order with triggerPrice at 600. For that take profit order either you would specify a limit price or it will be executed at market price.\n\nTake Profit orders are activated when the price of the underlying:\n• rises above the from below, for sell orders (eg: to close a long position, at a profit)\n• drops below the from above, for buy orders (eg: to close a short position, at a profit)\n\nTake Profit / Stop Loss Orders which are tied to a position-opening primary order. Implemented by supplying a dictionary parameters for and describing each respectively.\n• By default stopLoss and takeProfit orders will be the same magnitude as primary order but in the opposite direction.\n• Attached trigger orders are conditional on the primary order being executed.\n• Not supported by all exchanges.\n• Both and or either can be supplied, this depends on exchange.\n\nNote: This is still under unification and is work in progress\n\nFor exchanges, where it is not possible to use attached SL &TP, after submitting an entry order, you can immediatelly submit another order (even though position might not be open yet) with and params, so it can still act as a stoploss order for your upcoming position (note, this approach might not work for some exchanges).\n\nTrailing Orders trail behind an open position. Implemented by supplying float parameters for or .\n• A trailing order continually adjusts the order price at a fixed percent or fixed quote amount away from the current market price.\n• A trailing order trails behind a position as it moves in one direction, but not in the opposite direction.\n• If the position value rises, the trailing order changes, but if the position value drops the trailing order stays the same until the order is executed.\n• A trailing order can be placed independently after opening a position.\n• Implemented by filling in either the or parameter depending on the exchange.\n• The price argument can be used as the , and the type argument can be used to differentiate between limit and market trailing orders if needed.\n\nNot supported by all exchanges.\n\nNote: This is still under unification and is a work in progress\n\nSome exchanges allow you to specify optional parameters for your order. You can pass your optional parameters and override your query with an associative array using the argument to your unified API call. All custom params are exchange-specific, of course, and aren't interchangeable, do not expect those custom params for one exchange to work with another exchange.\n\nThe user can specify a custom field can be set upon placing orders with the . Using the one can later distinguish between own orders. This is only available for the exchanges that do support at this time. For the exchanges that don't support it will either throw an error upon supplying the or will ignore it setting the to .\n\nTo edit an order, you can use the method\n• side (String) required the direction of your order. Unified sides:\n• give quote currency and receive base currency; for example, buying means that you will receive bitcoins for your dollars.\n• give base currency and receive quote currency; for example, buying means that you will receive dollars for your bitcoins.\n• type (String) required type of order Unified types:\n• not allowed by some exchanges, see their docs for details\n• see #custom-order-params and #other-order-types for non-unified types\n• amount (Number) required how much of currency you want to trade usually, but not always, in units of the base currency of the trading pair symbol (the units for some exchanges are dependent on the side of the order: see their API docs for details.)\n• price (Float) the price at which the order is to be fullfilled at in units of the quote currency (ignored in market orders)\n\nTo cancel an existing order use\n• for all open orders after the given timeout\n• timeout (number) countdown time in milliseconds required on some exchanges, 0 represents cancel the timer (e.g. \\ )\n\nThe is usually used on open orders only. However, it may happen that your order gets executed (filled and closed) before your cancel-request comes in, so a cancel-request might hit an already-closed order.\n\nA cancel-request might also throw a indicating that the order might or might not have been canceled successfully and whether you need to retry or not. Consecutive calls to may hit an already canceled order as well.\n\nAs such, can throw an exception in these cases:\n\nA trade is also often called . Each trade is a result of order execution. Note, that orders and trades have a one-to-many relationship: an execution of one order may result in several trades. However, when one order matches another opposing order, the pair of two matching orders yields one trade. Thus, when an order matches multiple opposing orders, this yields multiple trades, one trade per each pair of matched orders.\n\nTo put it shortly, an order can contain one or more trades. Or, in other words, an order can be filled with one or more trades.\n\nFor example, an orderbook can have the following orders (whatever trading symbol or pair it is):\n\nAll specific numbers above aren't real, this is just to illustrate the way orders and trades are related in general.\n\nA seller decides to place a sell limit order on the ask side for a price of 0.700 and an amount of 150.\n\nAs the price and amount of the incoming sell (ask) order cover more than one bid order (orders and ), the following sequence of events usually happens within an exchange engine very quickly, but not immediately:\n• Order is matched against the incoming sell because their prices intersect. Their volumes \"mutually annihilate\" each other, so, the bidder gets 100 for a price of 0.800. The seller (asker) will have their sell order partially filled by bid volume 100 for a price of 0.800. Note that for the filled part of the order the seller gets a better price than he asked for initially. He asked for 0.7 at least but got 0.8 instead which is even better for the seller. Most conventional exchanges fill orders for the best price available.\n• A trade is generated for the order against the incoming sell order. That trade \"fills\" the entire order and most of the sell order. One trade is generated per each pair of matched orders, whether the amount was filled completely or partially. In this example the seller amount (100) fills order completely (closes the order ) and also fills the selling order partially (leaves it open in the orderbook).\n• Order now has a status of and a filled volume of 100. It contains one trade against the selling order. The selling order has an status and a filled volume of 100. It contains one trade against order . Thus each order has just one fill-trade so far.\n• The incoming sell order has a filled amount of 100 and has yet to fill the remaining amount of 50 from its initial amount of 150 in total.\n\nThe intermediate state of the orderbook is now (order is and is not in the orderbook anymore):\n• Order is matched against the remaining part of incoming sell, because their prices intersect. The amount of buying order which is 200 completely annihilates the remaining sell amount of 50. The order is filled partially by 50, but the rest of its volume, namely the remaining amount of 150 will stay in the orderbook. The selling order, however, is fulfilled completely by this second match.\n• A trade is generated for the order against the incoming sell order. That trade partially fills order . And completes the filling of the sell order. Again, this is just one trade for a pair of matched orders.\n• Order now has a status of , a filled amount of 50, and a remaining amount of 150. It contains one filling trade against the selling order. The selling order has a status now and it has completely filled its total initial amount of 150. However, it contains two trades, the first against order and the second against order . Thus each order can have one or more filling trades, depending on how their volumes were matched by the exchange engine.\n\nAfter the above sequence takes place, the updated orderbook will look like this.\n\nNotice that the order has disappeared, the selling order also isn't there. All closed and fully-filled orders disappear from the orderbook. The order which was filled partially and still has a remaining volume and an status, is still there.\n\nMost of unified methods will return either a single object or a plain array (a list) of objects (trades). However, very few exchanges (if any at all) will return all trades at once. Most often their APIs output to a certain number of most recent objects. YOU CANNOT GET ALL OBJECTS SINCE THE BEGINNING OF TIME TO THE PRESENT MOMENT IN JUST ONE CALL. Practically, very few exchanges will tolerate or allow that.\n\nAs with all other unified methods for fetching historical data, the method accepts a argument for date-based pagination. Just like with all other unified methods throughout the CCXT library, the argument for must be an integer timestamp in milliseconds.\n\nTo fetch historical trades, the user will need to traverse the data in portions or \"pages\" of objects. Pagination often implies \"fetching portions of data one by one\" in a loop.\n\nIn many cases a argument is required by the exchanges' APIs, therefore you have to loop over all symbols to get all your trades. If the is missing and the exchange requires it then CCXT will throw an exception to signal the requirement to the user. And then the has to be specified. One of the approaches is to filter the relevant symbols from the list of all symbols by looking at non-zero balances as well as transactions (withdrawals and deposits). Also, the exchanges will have a limit on how far back in time you can go.\n\nIn most cases users are required to use at least some type of pagination in order to get the expected results consistently.\n\nReturns ordered array of trades (most recent trade last).\n\nTrades denote the exchange of one currency for another, unlike transactions, which denote a transfer of a given coin.\n• The work on and info is still in progress, fee info may be missing partially or entirely, depending on the exchange capabilities.\n• The currency may be different from both traded currencies (for example, an ETH/BTC order with fees in USD).\n• The of the trade means . It is the total quote volume of the trade (whereas is the base volume). The cost field itself is there mostly for convenience and can be deduced from other fields.\n• The of the trade is a \"gross\" value. That is the value pre-fee, and the fee has to be applied afterwards.\n\nThe ledger is simply the history of changes, actions done by the user or operations that altered the user's balance in any way, that is, the history of movements of all funds from/to all accounts of the user which includes\n• amounts incoming and outcoming in result of a trade or an order\n• rebates, cashbacks and other types of events that are subject to accounting.\n\nData on ledger entries can be retrieved using\n• for multiple ledger entries of the same currency\n• code (String) Unified CCXT currency code; required if fetching all ledger entries for all assets at once is not supported (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve withdrawals for (e.g. )\n• limit (Integer) The number of ledger entry structures to retrieve (e.g. )\n\nThe type of the ledger entry is the type of the operation associated with it. If the amount comes due to a sell order, then it is associated with a corresponding trade type ledger entry, and the referenceId will contain associated trade id (if the exchange in question provides it). If the amount comes out due to a withdrawal, then is associated with a corresponding transaction.\n\nThe field holds the id of the corresponding event that was registered by adding a new item to the ledger.\n\nThe field is there to support for exchanges that include pending and canceled changes in the ledger. The ledger naturally represents the actual changes that have taken place, therefore the status is in most cases.\n\nThe ledger entry type can be associated with a regular trade or a funding transaction (deposit or withdrawal) or an internal between two accounts of the same user. If the ledger entry is associated with an internal transfer, the field will contain the id of the account that is being altered with the ledger entry in question. The field will contain the id of the opposite account the funds are transferred to/from, depending on the ( or ).\n\nIn order to deposit cryptocurrency funds to an exchange you must get an address from the exchange for the currency you want to deposit using . You can then call the method with the specified currency and address.\n\nTo deposit fiat currency on an exchange you can use the method with data retrieved from the method. this deposit feature is currently supported on coinbase only, feel free to report any issues you find\n\nThe deposit id structure returned from , look like this:\n\nData on deposits made to an account can be retrieved using\n• for multiple deposits of the same currency\n• for all deposits to an account\n• since (Integer) Timestamp (ms) of the earliest time to retrieve deposits for (e.g. )\n• limit (Integer) The number of transaction structures to retrieve (e.g. )\n\nThe method can be used to withdraw funds from an account\n\nSome exchanges require a manual approval of each withdrawal by means of 2FA (2-factor authentication). In order to approve your withdrawal you usually have to either click their secret link in your email inbox or enter a Google Authenticator code or an Authy code on their website to verify that withdrawal transaction was requested intentionally.\n\nIn some cases you can also use the withdrawal id to check withdrawal status later (whether it succeeded or not) and to submit 2FA confirmation codes, where this is supported by the exchange. See their docs for details.\n• amount (Float) required The amount of currency to withdraw (e.g. )\n• address (String) required The recipient address of the withdrawal (e.g. )\n\nData on withdrawals made to an account can be retrieved using\n• for multiple withdrawals of the same currency\n• for all withdrawals from an account\n• since (Integer) Timestamp (ms) of the earliest time to retrieve withdrawals for (e.g. )\n• limit (Integer) The number of transaction structures to retrieve (e.g. )\n\nIt is also possible to pass the parameters as the fourth argument with or without a specified tag\n\nThe following aliases of allow for withdrawing crypto on multiple chains\n\nYou may set the value of in order to withdraw USDT on the TRON chain, or 'BSC' to withdraw USDT on Binance Smart Chain. In the table above BSC and BEP20 are equivalent aliases, so it doesn't matter which one you use as they both will achieve the same effect.\n\nTransactions denote a transfer of a given coin, unlike trades, which denote the exchange of one currency for another.\n• or may be , if the exchange in question does not specify all sides of the transaction\n• The semantics of the field is exchange-specific. In some cases it can contain the address of the sender, in other cases it may contain the address of the receiver. The actual value depends on the exchange.\n• The field is the UTC timestamp in milliseconds of the most recent change of status of that funding operation, be it or . It is necessary if you want to track your changes in time, beyond a static snapshot. For example, if the exchange in question reports and for a transaction, then the field will take the value of , that is, the timestamp of the most recent change of the status.\n• The field may be in certain exchange-specific cases.\n• The substructure may be missing, if not supplied within the reply coming from the exchange.\n• The field may be , otherwise it will contain a message or note defined by the user upon creating the transaction.\n• Be careful when handling the and the . The is NOT an arbitrary user-defined string of your choice! You cannot send user messages and comments in the . The purpose of the field is to address your wallet properly, so it must be correct. You should only use the received from the exchange you're working with, otherwise your transaction might never arrive to its destination.\n• The field may be or, in some cases (when the exchange's endpoint returns both internal transfers and blockchain transactions, e.g. ), could be .\n\nThe address for depositing can be either an already existing address that was created previously with the exchange or it can be created upon request. In order to see which of the two methods are supported, check the and properties.\n\nSome exchanges may also have a method for fetching multiple deposit addresses at once or all of them at once.\n• code ([String]) Array of unified CCXT currency codes. May or may not be required depending on the exchange (e.g. )\n\nThe address structures returned from , , and look like this:\n\nWith certain currencies, like AEON, BTS, GXS, NXT, SBD, STEEM, STR, XEM, XLM, XMR, XRP, an additional argument is usually required by exchanges. Other currencies will have the set to . The tag is a memo or a message or a payment id that is attached to a withdrawal transaction. The tag is mandatory for those currencies and it identifies the recipient user account.\n\nBe careful when specifying the and the . The is NOT an arbitrary user-defined string of your choice! You cannot send user messages and comments in the . The purpose of the field is to address your wallet properly, so it must be correct. You should only use the received from the exchange you're working with, otherwise your transaction might never arrive to its destination.\n\nThe field is relatively new, it may be or missing entirely in certain cases (with some exchanges), but will be added everywhere eventually. It is still in the process of unification.\n\nThe method makes internal transfers of funds between accounts on the same exchange. This can include subaccounts or accounts of different types ( , , , ...). If an exchange is separated on CCXT into a spot and futures class (e.g. , , ...), then the method may be available to transfer funds into the futures account, and the method may be available to transfer funds out of the futures account\n• amount (Float) The amount of currency to transfer (e.g. )\n• fromAccount (String) The account to transfer funds from.\n• toAccount (String) The account to transfer funds to.\n• params.symbol (String) Market symbol when transfering to or from a margin account (e.g. )\n\nand can accept the exchange account id or one of the following unified values:\n• for some exchanges and are the same account\n• for some exchanges that allow for subaccounts\n\nYou can retrieve all the account types by selecting the keys from `exchange.options['accountsByType']\n\nSome exchanges allow transfers to email addresses, phone numbers or to other users by user id.\n• amount (Float) The amount of currency to transfer (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve transfers for (e.g. )\n• limit (Integer) The number of transfer structures to retrieve (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve transfers for (e.g. )\n• limit (Integer) The number of transfer structures to retrieve (e.g. )\n\nThis section of the Unified CCXT API is under development.\n\nFees are often grouped into two categories:\n• Trading fees. Trading fee is the amount payable to the exchange, usually a percentage of volume traded (filled).\n• Transaction fees. The amount payable to the exchange upon depositing and withdrawing as well as the underlying crypto transaction fees (tx fees).\n\nBecause the fee structure can depend on the actual volume of currencies traded by the user, the fees can be account-specific. Methods to work with account-specific fees:\n\nThe fee methods will return a unified fee structure, which is often present with orders and trades as well. The fee structure is a common format for representing the fee info throughout the library. Fee structures are usually indexed by market or currency.\n\nBecause this is still a work in progress, some or all of methods and info described in this section may be missing with this or that exchange.\n\nDO NOT use the property of the exchange instance as most often it contains the predefined/hardcoded info. Actual fees should only be accessed from markets and currencies.\n\nNOTE: Previously we used fetchTransactionFee(s) to fetch the transaction fees, which are now DEPRECATED and these functions have been replace by fetchDepositWithdrawFee(s)\n\nYou call / to fetch the trading fees, / to fetch the deposit & withdraw fees.\n\nOrders, private trades, transactions and ledger entries may define the following info in their field:\n\nTrading fees are properties of markets. Most often trading fees are loaded into the markets by the call. Sometimes, however, the exchanges serve fees from different endpoints.\n\nThe method can be used to precalculate trading fees that will be paid. WARNING! This method is experimental, unstable and may produce incorrect results in certain cases. You should only use it with caution. Actual fees may be different from the values returned from , this is just for precalculation. Do not rely on precalculated values, because market conditions change frequently. It is difficult to know in advance whether your order will be a market taker or maker.\n\nThe method will return a unified fee structure with precalculated fees for an order with specified params.\n\nAccessing trading fee rates should be done via which is the recommended approach. If that method is not supported by exchange, then via the property, like so:\n\nThe markets stored under the property may contain additional fee related information:\n\nWARNING! fee related information is experimental, unstable and may only be partial available or not at all.\n\nMaker fees are paid when you provide liquidity to the exchange i.e. you market-make an order and someone else fills it. Maker fees are usually lower than taker fees. Similarly, taker fees are paid when you take liquidity from the exchange and fill someone else's order.\n\nFees can be negative, this is very common amongst derivative exchanges. A negative fee means the exchange will pay a rebate (reward) to the user for the trading.\n\nAlso, some exchanges might not specify fees as percentage of volume, check the field of the market to be sure.\n\nSome exchanges have an endpoint for fetching the trading fee schedule, this is mapped to the unified methods , and\n\nAccessing transaction fee rates should be done via the property. This aspect is not unified yet and is subject to change.\n\nSome exchanges have an endpoint for fetching the transaction fee schedule, this is mapped to the unified methods\n\nTo trade with leverage in spot or margin markets, currency must be borrowed as a loan. This borrowed currency must be payed back with interest. To obtain the amount of interest that has accrued you can use the method\n• code (String) The unified currency code for the currency of the interest (e.g. )\n• symbol (String) The market symbol of an isolated margin market, if undefined, the interest for cross margin markets is returned (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to receive interest records for (e.g. )\n• limit (Integer) The number of borrow interest structures to retrieve (e.g. )\n\nTo borrow and repay currency as a margin loan use , , and .\n• code (String) required The unified currency code for the currency to be borrowed or repaid (e.g. )\n• amount (Float) required The amount of margin to borrow or repay (e.g. )\n• symbol (String) required The unified CCXT market symbol of an isolated margin market (e.g. )\n• code (String) required The unified currency code for the currency to be borrowed or repaid (e.g. )\n• amount (Float) required The amount of margin to borrow or repay (e.g. )\n\nNote: through the manual we use term \"collateral\" which means current margin balance, but do not confuse it with \"initial margin\" or \"maintenance margin\":\n\nFor example, when you had opened an isolated position with 50$ initial margin and the position has unrealized profit of -15$, then your position's collateral will be 35$. However, if we take that Maintenance Margin requirement (to keep the position open) by exchange hints $25 for that position, then your collateral should not drop below it, otherwise the position will be liquidated.\n\nTo increase, reduce or set your margin balance (collateral) in an open leveraged position, use , and respectively. This is kind of like adjusting the amount of leverage you're using with a position that's already open.\n\nSome scenarios to use these methods include\n• if the trade is going against you, you can add margin to, reducing the risk of liquidation\n• if your trade is going well you can reduce your position's margin balance and take profits\n• amount (String) required Amount of margin to add or reduce (e.g. )\n\nYou can fetch the history of margin adjustments made using the methods above or automatically by the exchange using the following method\n• since (Integer) Timestamp (ms) of the earliest time to retrieve margin adjustments for for (e.g. )\n• limit (Integer) The number of margin structures to retrieve (e.g. )\n\nUpdates the type of margin used to be either\n• One account is used to share collateral between markets. Margin is taken from total account balance to avoid liquidation when needed.\n• Each market, keeps collateral in a separate account\n• marginMode (String) required the type of margin used Unified margin types:\n• symbol (String) Unified CCXT market symbol (e.g. ) required on most exchanges. Is not required when the margin mode is not specific to a market\n\nCommon reasons for why an exchange might have\n• the exchange does not offer leveraged trading\n• the exchange only offers one of or margin modes, but does not offer both\n• margin mode must be set using an exchange specific parameter within when using\n\nSome exchange apis return an error response when a request is sent to set the margin mode to the mode that it is already set to (e.g. Sending a request to set the margin mode to for the market when the account already has set to use cross margin). CCXT doesn't see this as an error because the end result is what the user wanted, so the error is suppressed and the error result is returned as an object.\n\nSome methods allow the usage of a parameter that can be set to either or . This can be useful for specifying the directly within the methods params, for use with spot margin or contract markets. To specify a spot margin market, you need to use a unified spot symbol or set the market type to spot, while setting the marginMode parameter to or .\n\nUse a unified spot symbol, while setting the marginMode parameter.\n\nThe method can be used to obtain the set margin mode for a market. The method can be used to obtain the set margin mode for multiple markets at once.\n\nYou can access the set margin mode by using:\n• symbol (String) Unified CCXT market symbol (e.g. ) required on most exchanges. Is not required when leverage is not specific to a market (e.g. If leverage is set for the account and not per market)\n\nThe method can be used to obtain the set leverage for a market. The method can be used to obtain the set leverage for multiple markets at once.\n\nYou can access the set leverage by using:\n\nThis can include futures with a set expiry date, perpetual swaps with funding payments, and inverse futures or swaps. Information about the positions can be served from different endpoints depending on the exchange. In the case that there are multiple endpoints serving different types of derivatives CCXT will default to just loading the \"linear\" (as oppose to the \"inverse\") contracts or the \"swap\" (as opposed to the \"future\") contracts.\n\nTo get information about positions currently held in contract markets, use\n• symbols ([String]) Unified CCXT market symbols, do not set to retrieve all positions (e.g. )\n• symbol ([String]) Unified CCXT market symbols, do not set to retrieve all positions (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve positions for (e.g. )\n• limit (Integer) The number of position structures to retrieve (e.g. )\n\nPositions allow you to borrow money from an exchange to go long or short on an market. Some exchanges require you to pay a funding fee to keep the position open.\n\nWhen you go long on a position you are betting that the price will be higher in the future and that the price will never be less than the .\n\nAs the price of the underlying index changes so does the unrealisedPnl and as a consequence the amount of collateral you have left in the position (since you can only close it at market price or worse). At some price you will have zero collateral left, this is called the \"bust\" or \"zero\" price. Beyond this point, if the price goes in the opposite direction far enough, the collateral of the position will drop below the . The maintenanceMargin acts as a safety buffer between your position and negative collateral, a scenario where the exchange incurs losses on your behalf. To protect itself the exchange will swiftly liquidate your position if and when this happens. Even if the price returns back above the liquidationPrice you will not get your money back since the exchange sold all the you bought at market. In other words the maintenanceMargin is a hidden fee to borrow money.\n\nIt is recommended to use the and instead of the and since these tend to be more accurate. The maintenanceMargin might be calculated from other factors outside of the maintenanceMarginPercentage including the funding rate and taker fees, for example on kucoin.\n\nAn inverse contract will allow you to go long or short on BTC/USD by putting up BTC as collateral. Our API for inverse contracts is the same as for linear contracts. The amounts in an inverse contracts are quoted as if they were traded USD/BTC, however the price is still quoted terms of BTC/USD. The formula for the profit and loss of a inverse contract is . The profit and loss and collateral will now be quoted in BTC, and the number of contracts are quoted in USD.\n\nTo quickly close open positions with a market order, use\n• side optional a string literal for the direction of your order. Some exchanges require it. Unified sides:\n• give quote currency and receive base currency; for example, buying means that you will receive bitcoins for your dollars.\n• give base currency and receive quote currency; for example, buying means that you will receive dollars for your bitcoins.\n\nIt is the price at which the . The price has gone in the opposite direction of your position to the point where the is only maintenanceMargin collateral left and if it goes any further the position will have negative collateral.\n\nPerpetual swap (also known as perpetual future) contracts maintain a market price that mirrors the price of the asset they are based on because funding fees are exchanged between traders who hold positions in perpetual swap markets.\n\nIf the contract is being traded at a price that is higher than the price of the asset they represent, then traders in long positions pay a funding fee to traders in short positions at specific times of day, which encourages more traders to enter short positions prior to these times.\n\nIf the contract is being traded at a price that is lower than the price of the asset they represent, then traders in short positions pay a funding fee to traders in long positions at specific times of day, which encourages more traders to enter long positions prior to these times.\n\nThese fees are usually exchanged between traders with no commission going to the exchange\n\nThe method can be used to retrieve an accounts history of funding fees paid or received\n• since (Integer) Timestamp (ms) of the earliest time to retrieve funding history for (e.g. )\n• limit (Integer) The number of funding history structures to retrieve (e.g. )\n\nThe method can be used to retrieve a quote that can be used for a conversion trade. The quote usually needs to be used within a certain timeframe specified by the exchange for the convert trade to execute successfully.\n• fromCode (String) required The unified currency code for the currency to convert from (e.g. )\n• toCode (String) required The unified currency code for the currency to be converted into (e.g. )\n• amount (Float) Amount to convert in units of the from currency (e.g. )\n\nThe method can be used to create a conversion trade order using the id retrieved from fetchConvertQuote. The quote usually needs to be used within a certain timeframe specified by the exchange for the convert trade to execute successfully.\n• fromCode (String) required The unified currency code for the currency to convert from (e.g. )\n• toCode (String) required The unified currency code for the currency to be converted into (e.g. )\n• amount (Float) Amount to convert in units of the from currency (e.g. )\n\nThe method can be used to fetch a specific conversion trade using the trades id.\n• code (String) The unified currency code of the conversion trade (e.g. )\n\nThe method can be used to fetch the conversion history for a specified currency code.\n• code (String) The unified currency code to fetch conversion trade history for (e.g. )\n• since (Integer) Timestamp of the earliest conversion (e.g. )\n• limit (Integer) The maximum number of conversion structures to retrieve (e.g. )\n\nIn some specific cases you may want a proxy, when:\n• Exchange is not available in your location\n• Your IP is forbidden by exchange\n• You experience random restriction by exchange, like DDoS protection by Cloudflare\n\nHowever, beware that each added intermediary might add some latency to requests.\n\nNote for Go users: After setting any proxy property, you must call to apply the changes:\n\nHowever be aware that each added intermediary might add some latency to requests.\n\nCCXT supports the following proxy types (note, each of them also have callback support):\n\nThis property prepends an url to API requests. It might be useful for simple redirection or bypassing CORS browser restriction.\n\nwhile 'YOUR_PROXY_URL' could be like (use the slash accordingly):\n\nSo requests will be made to i.e. . ( You can also have a small proxy script running on your device/webserver to use it in - \"sample-local-proxy-server\" in examples folder).\n\nThis approach works only for REST requests, but not for websocket connections. ((How to test if your proxy works))[#test-if-your-proxy-works]\n\nTo set a real http(s) proxy for your scripts, you need to have an access to a remote http or https proxy, so calls will be made directly to the target exchange, tunneled through your proxy server:\n\nThis approach only affects non-websocket requests of ccxt. To route CCXT's WebSockets connections through proxy, you need to specifically set (or ) property, in addition to the (or ), so your script should be like:\n\nSo, both connections (HTTP & WS) would go through proxies. ((How to test if your proxy works))[#test-if-your-proxy-works]\n\nYou can also use socks proxy with the following format:\n\n((How to test if your proxy works))[#test-if-your-proxy-works]\n\nAfter setting any of the above listed proxy properties in your ccxt snippet, you can test whether it works by pinging some IP echoing websites - check a \"proxy-usage\" file in examples.\n\n**Instead of setting a property, you can also use callbacks :\n\nIf you need for special cases, you can override property like:\n\nDepending your programming language, you can set custom proxy agents.\n• For JS, see this example\n• For Python, see the following examples: proxies-for-synchronous-python, proxy-asyncio-aiohttp-python-3, proxy-asyncio-aiohttp-socks, proxy-sync-python-requests-2-and-3\n\nCORS (known as Cross-Origin Resource Sharing) affects mostly browsers and is the cause of the well-know warning No 'Access-Control-Allow-Origin' header is present on the requested resource . It happens when a script (running in a browser) makes a request to a 3rd party domain (by default such requests are blocked, unless the target domain explicitly allows it). So, in such cases you will need to communicate with a \"CORS\" proxy, which would redirect requests (as opposed to direct browser-side request) to the target exchange. To set a CORS proxy, you can run sample-local-proxy-server-with-cors example file and in ccxt set the property to route requests through cors/proxy server.\n\nSome users might want to control how CCXT handles arithmetic operations. Even though it uses numeric types by default, users can switch to fixed-point math using string types. This can be done by:\n\nThe error handling with CCXT is done with the exception mechanism that is natively available with all languages.\n\nTo handle the errors you should add a block around the call to a unified method and catch the exceptions like you would normally do with your language:\n\nWhen dealing with HTTP requests, it's important to understand that requests might fail for various reasons. Common causes of these failures include the server being unavailable, network instability, or temporary server issues. To handle such scenarios gracefully, CCXT provide an option to automatically retry failed requests. You can set the value of and to configure the number of retries and the delay between retries, example:\n\nIt's important to highlight that only server/network-related issues will be part of the retry mechanism; if the user gets an error due to or the request will not be repeated.\n\nAll exceptions are derived from the base BaseError exception, which, in its turn, is defined in the ccxt library like so:\n\nThe exception inheritance hierarchy lives in this file: https://github.com/ccxt/ccxt/blob/master/ts/src/base/errorHierarchy.ts , and visually can be outlined like shown below:\n\nThe class is a generic root error class for all sorts of errors, including accessibility and request/response mismatch. If you don't need to catch any specific subclass of exceptions, you can just use , where all exception types are being caught.\n\nFrom derives two different families of errors: and (they also have their specific sub-types, as explained below).\n\nAn might happen when user sends correctly constructed & valid request to exchange, but a non-deterministic problem occurred:\n\nSuch exceptions are temporary and re-trying the request again might be enough. However, if the error still happens, then it may indicate some persistent problem with the exchange or with your connection.\n\nhas the following sub-types: , (includes sub-type ), , .\n\nThis exception is thrown in cases when cloud/hosting services (Cloudflare, Incapsula or etc..) limits requests from user/region/location or when the exchange API restricts user because of making abnormal requests. This exception also contains specific sub-type exception , which directly means that user makes much frequent requests than tolerated by exchange API engine.\n\nThis exception is raised when the connection with the exchange fails or data is not fully received in a specified amount of time. This is controlled by the exchange's property. When a is raised, the user doesn't know the outcome of a request (whether it was accepted by the exchange server or not).\n\nThus it's advised to handle this type of exception in the following manner:\n• for fetching requests it is safe to retry the call\n• for a request to a user is required to retry the same call the second time. A subsequent retry to will return one of the following possible results:\n• a request is completed successfully, meaning the order has been properly canceled now\n• an exception is raised, which means the order was either already canceled on the first attempt or has been executed (filled and closed) in the meantime between the two attempts.\n• if a request to fails with a the user should:\n• call , , to check if the request to place the order has succeeded and the order is now open\n• if the order is not the user should to check if the balance has changed since the order was created on the first run and then was filled and closed by the time of the second check.\n\nThis type of exception is thrown when the underlying exchange is unreachable. The ccxt library also throws this error if it detects any of the following keywords in response:\n\nRaised when your nonce is less than the previous nonce used with your keypair, as described in the Authentication section. This type of exception is thrown in these cases (in order of precedence for checking):\n• You are not rate-limiting your requests or sending too many of them too often.\n• Your API keys are not fresh and new (have been used with some different software or script already, just always create a new keypair when you add this or that exchange).\n• The same keypair is shared across multiple instances of the exchange class (for example, in a multithreaded environment or in separate processes).\n• Your system clock is out of synch. System time should be synched with UTC in a non-DST timezone at a rate of once every ten minutes or even more frequently because of the clock drifting. Enabling time synch in Windows is usually not enough! You have to set it up with the OS Registry (Google \"time synch frequency\" for your OS).\n\nIn contrast to , the is mostly happening when the request is impossible to succeed (because of factors listed below), so even if you retry the same request hundreds of times, they will still fail, because the request is being made incorrectly.\n\nPossible reasons for this exception:\n• endpoint is switched off by the exchange\n• symbol not found on the exchange\n• the format of parameters is incorrect\n• some problem happening on user-side that needs to be fixed\n\nhas the following sub-type exceptions:\n• : when the endpoint/operation is not offered or supported by the exchange API.\n• : user sends an incorrectly constructed request/parameter/action that is invalid/unallowed (i.e.: \"invalid number\", \"forbidden symbol\", \"size beyond min/max limits\", \"incorrect precision\", etc). Retrying would not help in this case, the request needs to be fixed/adjusted first.\n• - user sends a correctly constructed request (that should be accepted by the exchange in a typical case), but some deterministic factor prevents your request to succeed. For example, your current account status might not allow it (i.e. \"please close existing positions before changing the leverage\", \"too many pending orders\", \"your account in wrong position/margin mode\") or at the give moment symbol is not tradable (i.e. \"MarketClosed\") or some explained factors, where you need to take a specific action (i.e. change some setting at first, or wait till specific moment). So, once again: OperationFailed can be blindly re-tried and should success, while is a failure that depends on specific exact factors that need to be considered, before request can be retried.\n• : when an exchange requires one of the API credentials that you've missed to specify, or when there's a mistake in the keypair or an outdated nonce. Most of the time you need and , sometimes you also need and/or if exchange API requires it.\n• : when there's no access for specified action or insufficient permissions on the specified .\n• : when you don't have enough currency on your account balance to place an order.\n• : when encountering a bad funding address or a funding address shorter than (10 characters by default) in a call to , or .\n• : the base class for all exceptions related to the unified order API.\n• : when you are trying to fetch or cancel a non-existent order.\n\nIn case you experience any difficulty connecting to a particular exchange, do the following in order of precedence:\n• Make sure that you have the most recent version of ccxt. Never trust your package installer (whether it is , or ), instead always check your actual (real) runtime version number by running this code in your environment:\n• Check the Issues or Announcements for recent updates.\n• Make sure you have not turned off rate-limiter with (If anyone has custom rate-limit solution built, ensure it does not misbehave).\n• If you use ccxt's proxy functionality, ensure it does not misbehave.\n• Turn to get more detail about it! exchange = ccxt.binance() exchange.load_markets() exchange.verbose = True # for less noise, you can set that after `load_markets`, but if the error happens during `load_markets` then place this line before it # ... your codes here ... Your code to reproduce the issue + verbose output is required in order to get help.\n• Python people can turn on DEBUG logging level with a standard pythonic logger, by adding these two lines to the beginning of their code:\n• Use verbose mode to make sure that the used API credentials correspond to the keys you intend to use. Make sure there's no confusion of keypairs.\n• Try a fresh new keypair if possible.\n• Check the permissions on the keypair with the exchange website!\n• Check your nonce. If you used your API keys with other software, you most likely should override your nonce function to match your previous nonce value. A nonce usually can be easily reset by generating a new unused keypair. If you are getting nonce errors with an existing key, try with a new API key that hasn't been used yet.\n• Check your request rate if you are getting nonce errors. Your private requests should not follow one another quickly. You should not send them one after another in a split second or in short time. The exchange will most likely ban you if you don't make a delay before sending each new request. In other words, you should not hit their rate limit by sending unlimited private requests too frequently. Add a delay to your subsequent requests or enable the built-in rate-limiter, like shown in the long-poller examples, also here.\n• Read the docs for your exchange and compare your verbose output to the docs.\n• Check your connectivity with the exchange by accessing it with your browser.\n• Check your connection with the exchange through a proxy.\n• Try accesing the exchange from a different computer or a remote server, to see if this is a local or global issue with the exchange.\n• Check if there were any news from the exchange recently regarding downtime for maintenance. Some exchanges go offline for updates regularly (like once a week).\n• Make sure that your system time in sync with the rest of the world's clocks since otherwise you may get invalid nonce errors.\n• Use the option or instantiate your troublesome exchange with to see the HTTP requests and responses in details. The verbose output will also be of use for us to debug it if you submit an issue on GitHub.\n• Some exchanges are not available in certain countries, using a proxy might be the solution in such cases.\n• If you are getting authentication errors or 'invalid keys' errors, those are most likely due to a nonce issue.\n• Some exchanges do not state it clearly if they fail to authenticate your request. In those circumstances they might respond with an exotic error code, like HTTP 502 Bad Gateway Error or something that's even less related to the actual cause of the error."
    },
    {
        "link": "https://docs.ccxt.com",
        "document": ""
    },
    {
        "link": "https://medium.com/@deepml1818/comprehensive-cryptocurrency-trading-utility-with-ccxt-real-time-and-historical-data-analysis-6b9cbba57375",
        "document": "Let’s break down the code into several parts and organize them into functions.\n• Scenario: Traders or algorithms may use this functionality to fetch real-time market data for a specific trading pair (e.g., BTC/USDT) from the Huobi exchange.\n• Use: Analyze the latest ticker data (price, volume, etc.) to make informed trading decisions.\n\nIn this part, the code uses the library to fetch market data (ticker) for a specified trading symbol from the Huobi exchange. The function takes the exchange object and the trading symbol as parameters, fetches the ticker data, and prints the result.\n• Scenario: Traders may want to backtest their trading strategies using historical OHLCV data to evaluate the performance of their strategies under different market conditions.\n• Use: Fetch historical data for a specific trading pair (e.g., BTC/USDT) and timeframe (e.g., 1-hour) to simulate trading strategies.\n\nThis part fetches historical Open, High, Low, Close, and Volume (OHLCV) data for a specified trading symbol and timeframe. The function takes the exchange object, trading symbol, timeframe, and the number of days back as parameters. It then calculates the start time ( ) based on the specified days back and fetches the historical OHLCV data.\n• Scenario: Users or developers building applications may need an overview of available trading pairs, symbols, and other general information about the exchange.\n• Use: Retrieve and display general exchange information to understand available markets.\n\nThis part retrieves general exchange information using the method. The function takes the exchange object as a parameter, loads the markets, and prints the resulting exchange information.\n• Scenario: Users or applications requiring information about available cryptocurrencies and their details on the exchange.\n• Use: Fetch and display information about available currencies, including details such as minimum deposit amounts.\n\nHere, the code fetches information about available currencies on the exchange using the method. The function takes the exchange object as a parameter, fetches the currency data, and prints the result.\n• Scenario: Traders or algorithms may analyze the order book to understand market depth and potential price movements.\n• Use: Fetch the order book for a specific trading pair (e.g., BTC/USDT) with a specified limit and analyze buy/sell orders.\n\nThis part retrieves the order book for a specified trading symbol and limit. The function takes the exchange object, trading symbol, and limit as parameters, fetches the order book data, and prints the result.\n• Scenario: Users or developers building applications may need a list of available trading pairs on the exchange.\n• Use: Fetch and display a list of ticker symbols to provide users with an overview of available markets.\n\nThe code in this part loads the markets to get trading pairs and then extracts the ticker symbols. The function takes the exchange object as a parameter, loads the markets, retrieves the ticker symbols, and prints them.\n• Scenario: Applications requiring synchronization with the exchange server time for accurate timestamping of orders or data.\n• Use: Fetch the current server time to ensure synchronization with the exchange.\n\nThis part fetches the current server time of the exchange using the method. The function takes the exchange object as a parameter, fetches the server time, and prints the result.\n• Scenario: Users or applications dynamically integrating available trading pairs without hardcoding them.\n• Use: Fetch and display the list of trading pairs to allow users to choose from dynamically updated options.\n\nThe code in this part loads the markets to get trading pairs. The function takes the exchange object as a parameter, loads the markets, retrieves the trading pairs, and prints them.\n\nYou can run each part independently as needed. Each part contains a specific functionality encapsulated in a function for better modularity."
    },
    {
        "link": "https://github.com/ccxt/ccxt/wiki/Manual/075e7b319ba37f1ac1f3a8a329af70d6a2c436d9",
        "document": "The ccxt library is a collection of available crypto exchanges or exchange classes. Each class implements the public and private API for a particular crypto exchange. All exchanges are derived from the base Exchange class and share a set of common methods. To access a particular exchange from ccxt library you need to create an instance of corresponding exchange class. Supported exchanges are updated frequently and new exchanges are added regularly.\n\nThe structure of the library can be outlined as follows:\n\nFull public and private HTTP REST APIs for all exchanges are implemented. WebSocket implementations in JavaScript, PHP, Python are available in CCXT Pro, which is a professional addon to CCXT with support for WebSocket streams.\n\nThe CCXT library currently supports the following 97 cryptocurrency exchange markets and trading APIs:\n\nBesides making basic market and limit orders, some exchanges offer margin trading (leverage), various derivatives (like futures contracts and options) and also have dark pools, OTC (over-the-counter trading), merchant APIs and much more.\n\nTo connect to an exchange and start trading you need to instantiate an exchange class from ccxt library.\n\nTo get the full list of ids of supported exchanges programmatically:\n\nAn exchange can be instantiated like shown in the examples below:\n\nThe ccxt library in PHP uses builtin UTC/GMT time functions, therefore you are required to set date.timezone in your php.ini or call date_default_timezone_set() function before using the PHP version of the library. The recommended timezone setting is .\n\nMost of exchange properties as well as specific options can be overrided upon exchange class instantiation or afterwards, like shown below:\n\nIn all CCXT-supported languages, you can override instance methods during runtime:\n\nSome exchanges also offer separate APIs for testing purposes that allows developers to trade virtual money for free and test out their ideas. Those APIs are called \"testnets\", \"sandboxes\" or \"staging environments\" (with virtual testing assets) as opposed to \"mainnets\" and \"production environments\" (with real assets). Most often a sandboxed API is a clone of a production API, so, it's literally the same API, except for the URL to the exchange server.\n\nCCXT unifies that aspect and allows the user to switch to the exchange's sandbox (if supported by the underlying exchange). To switch to the sandbox one has to call the or immediately after creating the exchange before any other call!\n• The has to be your first call immediately after creating the exchange (before any other calls)\n• To obtain the API keys to the sandbox the user has to register with the sandbox website of the exchange in question and create a sandbox keypair\n• Sandbox keys are not interchangeable with production keys!\n\nEvery exchange has a set of properties and methods, most of which you can override by passing an associative array of params to an exchange constructor. You can also make a subclass and override everything.\n\nHere's an overview of generic exchange properties with values added for example:\n\nBelow is a detailed description of each of the base exchange properties:\n• : Each exchange has a default id. The id is not used for anything, it's a string literal for user-land exchange instance identification purposes. You can have multiple links to the same exchange and differentiate them by ids. Default ids are all lowercase and correspond to exchange names.\n• : This is a string literal containing the human-readable exchange name.\n• : An array of string literals of 2-symbol ISO country codes, where the exchange is operating from.\n• : The single string literal base URL for API calls or an associative array of separate URLs for private and public APIs.\n• : A single string URL link to original documentation for exchange API on their website or an array of links to docs.\n• : A string literal containing version identifier for current exchange API. The ccxt library will append this version string to the API Base URL upon each request. You don't have to modify it, unless you are implementing a new exchange API. The version identifier is a usually a numeric string starting with a letter 'v' in some cases, like v1.1. Do not override it unless you are implementing your own new crypto exchange class.\n• : An associative array containing a definition of all API endpoints exposed by a crypto exchange. The API definition is used by ccxt to automatically construct callable instance methods for each available endpoint.\n• : This is an associative array of exchange capabilities (e.g , or ).\n• : An associative array of timeframes, supported by the fetchOHLCV method of the exchange. This is only populated when property is true.\n• : A timeout in milliseconds for a request-response roundtrip (default timeout is 10000 ms = 10 seconds). If the response is not received in that time, the library will throw an exception. You can leave the default timeout value or set it to a reasonable value. Hanging forever with no timeout is not your option, for sure. You don't have to override this option in general case.\n• : A request rate limit in milliseconds. Specifies the required minimal delay between two consequent HTTP requests to the same exchange. The built-in rate-limiter is enabled by default and can be turned off by setting the property to false.\n• : A boolean (true/false) value that enables the built-in rate limiter and throttles consecutive requests. This setting is (enabled) by default. The user is required to implement own rate limiting or leave the built-in rate limiter enabled to avoid being banned from the exchange.\n• : An object to set HTTP User-Agent header to. The ccxt library will set its User-Agent by default. Some exchanges may not like it. If you are having difficulties getting a reply from an exchange and want to turn User-Agent off or use the default one, set this value to false, undefined, or an empty string. The value of may be overrided by HTTP property below.\n• : An associative array of HTTP headers and their values. Default value is empty . All headers will be prepended to all requests. If the header is set within , it will override whatever value is set in the property above.\n• : A boolean flag indicating whether to log HTTP requests to stdout (verbose flag is false by default). Python people have an alternative way of DEBUG logging with a standard pythonic logger, which is enabled by adding these two lines to the beginning of their code:\n• : An associative array of markets indexed by common trading pairs or symbols. Markets should be loaded prior to accessing this property. Markets are unavailable until you call the method on exchange instance.\n• : A non-associative array (a list) of symbols available with an exchange, sorted in alphabetical order. These are the keys of the property. Symbols are loaded and reloaded from markets. This property is a convenient shorthand for all market keys.\n• : An associative array (a dict) of currencies by codes (usually 3 or 4 letters) available with an exchange. Currencies are loaded and reloaded from markets.\n• : An associative array of arrays of markets indexed by exchange-specific ids. Typically a length one array unless there are multiple markets with the same marketId. Markets should be loaded prior to accessing this property.\n• : This is your public API key string literal. Most exchanges require API keys setup.\n• : Your private secret API key string literal. Most exchanges require this as well together with the apiKey.\n• : A string literal with your password/phrase. Some exchanges require this parameter for trading, but most of them don't.\n• : A unique id of your account. This can be a string literal or a number. Some exchanges also require this for trading, but most of them don't.\n• : A unified associative dictionary that shows which of the above API credentials are required for sending private API calls to the underlying exchange (an exchange may require a specific set of keys).\n• : An exchange-specific associative dictionary containing special keys and options that are accepted by the underlying exchange and supported in CCXT.\n• : The exchange decimal precision counting mode, read more about Precision And Limits\n• For proxies - , , , : An url of specific proxy. Read details in Proxy section.\n\nSee this section on Overriding exchange properties.\n• : An assoc-array containing flags for exchange capabilities, including the following: : : // has Cross-Origin Resource Sharing enabled (works from browser) or not // unified methods availability flags (can be true, false, or 'emulated'): : : : : : : : : : : : : : : : : : : : : : : : ... The meaning of each flag showing availability of this or that method is:\n• a value of / / means the method is not currently implemented in ccxt (either ccxt has not unified it yet or the method isn't natively available from the exchange API)\n• boolean specifically means that the endpoint isn't natively available from the exchange API\n• boolean means the endpoint is natively available from the exchange API and unified in the ccxt library\n• string means the endpoint isn't natively available from the exchange API but reconstructed (as much as possible) by the ccxt library from other available true-methods For a complete list of all exchages and their supported methods, please, refer to this example: https://github.com/ccxt/ccxt/blob/master/examples/js/exchange-capabilities.js\n\nExchanges usually impose what is called a rate limit. Exchanges will remember and track your user credentials and your IP address and will not allow you to query the API too frequently. They balance their load and control traffic congestion to protect API servers from (D)DoS and misuse.\n\nWARNING: Stay under the rate limit to avoid ban!\n\nMost exchanges allow up to 1 or 2 requests per second. Exchanges may temporarily restrict your access to their API or ban you for some period of time if you are too aggressive with your requests.\n\nThe property is set to a safe default which is sub-optimal. Some exchanges may have varying rate limits for different endpoints. It is up to the user to tweak according to application-specific purposes.\n\nThe CCXT library has a built-in experimental rate-limiter that will do the necessary throttling in background transparently to the user. WARNING: users are responsible for at least some type of rate-limiting: either by implementing a custom algorithm or by doing it with the built-in rate-limiter..\n\nYou can turn on/off the built-in rate-limiter with property, like so:\n\nIn case your calls hit a rate limit or get nonce errors, the ccxt library will throw an exception, or, in some cases, one of the following types:\n\nA later retry is usually enough to handle that.\n\nThe rate limiter is a property of the exchange instance, in other words, each exchange instance has its own rate limiter that is not aware of the other instances. In many cases the user should reuse the same exchange instance throughout the program. Do not use multiple instances of the same exchange with the same API keypair from the same IP address.\n\nReuse the exchange instance as much as possible as shown below:\n\nSince the rate limiter belongs to the exchange instance, destroying the exchange instance will destroy the rate limiter as well. Among the most common pitfalls with the rate limiting is creating and dropping the exchange instance over and over again. If in your program you are creating and destroying the exchange instance (say, inside a function that is called multiple times), then you are effectively resetting the rate limiter over and over and that will eventually break the rate limits. If you are recreating the exchange instance every time instead of reusing it, CCXT will try to load the markets every time. Therefore, you will force-load the markets over and over as explained in the Loading Markets section. Abusing the markets endpoint will eventually break the rate limiter as well.\n\nDo not break this rule unless you really understand the inner workings of the rate-limiter and you are 100% sure you know what you're doing. In order to stay safe always reuse the exchange instance throughout your functions and methods callchain like shown below:\n\nSome exchanges are DDoS-protected by Cloudflare or Incapsula. Your IP can get temporarily blocked during periods of high load. Sometimes they even restrict whole countries and regions. In that case their servers usually return a page that states a HTTP 40x error or runs an AJAX test of your browser / captcha test and delays the reload of the page for several seconds. Then your browser/fingerprint is granted access temporarily and gets added to a whitelist or receives a HTTP cookie for further use.\n\nThe most common symptoms for a DDoS protection problem, rate-limiting problem or for a location-based filtering issue:\n• Getting exceptions with all types of exchange methods\n• Catching or with HTTP error codes 400, 403, 404, 429, 500, 501, 503, etc..\n• Getting a template HTML page instead of JSON from the exchange\n\nIf you encounter DDoS protection errors and cannot reach a particular exchange then:\n• use a proxy (this is less responsive, though)\n• ask the exchange support to add you to a whitelist\n• try an alternative IP within a different geographic region\n• run your software in a distributed network of servers\n• run your software in close proximity to the exchange (same country, same city, same datacenter, same server rack, same server)\n\nEach exchange is a place for trading some kinds of valuables. The exchanges may use differing terms to call them: \"a currency\", \"an asset\", \"a coin\", \"a token\", \"stock\", \"commodity\", \"crypto\", \"fiat\", etc. A place for trading one asset for another is usually called \"a market\", \"a symbol\", \"a trading pair\", \"a contract\", etc.\n\nIn terms of the ccxt library, every exchange offers multiple markets within itself. Each market is defined by two or more currencies. The set of markets differs from exchange to exchange opening possibilities for cross-exchange and cross-market arbitrage.\n\nEach currency is an associative array (aka dictionary) with the following keys:\n• . The string or numeric ID of the currency within the exchange. Currency ids are used inside exchanges internally to identify coins during the request/response process.\n• . An uppercase string code representation of a particular currency. Currency codes are used to reference currencies within the ccxt library (explained below).\n• . A human-readable name of the currency (can be a mix of uppercase & lowercase characters).\n• . The withdrawal fee value as specified by the exchange. In most cases it means a flat fixed amount paid in the same currency. If the exchnange does not specify it via public endpoints, the can be or missing.\n• . A boolean indicating whether trading or funding (depositing or withdrawing) for this currency is currently possible, more about it here: status.\n• . An associative array of non-common market properties, including fees, rates, limits and other general market information. The internal info array is different for each particular market, its contents depend on the exchange.\n• . Precision accepted in values by exchanges upon referencing this currency. The value of this property depends on .\n• . The minimums and maximums for amounts (volumes), withdrawals and deposits.\n\nEach network is an associative array (aka dictionary) with the following keys:\n• . The string or numeric ID of the network within the exchange. Network ids are used inside exchanges internally to identify networks during the request/response process.\n• . An uppercase string representation of a particular network. Networks are used to reference networks within the ccxt library.\n• . A human-readable name of the network (can be a mix of uppercase & lowercase characters).\n• . The withdrawal fee value as specified by the exchange. In most cases it means a flat fixed amount paid in the same currency. If the exchnange does not specify it via public endpoints, the can be or missing.\n• . A boolean indicating whether trading or funding (depositing or withdrawing) for this currency is currently possible, more about it here: status.\n• . An associative array of non-common market properties, including fees, rates, limits and other general market information. The internal info array is different for each particular market, its contents depend on the exchange.\n• . Precision accepted in values by exchanges upon referencing this currency. The value of this property depends on .\n• . The minimums and maximums for amounts (volumes), withdrawals and deposits.\n\nEach market is an associative array (aka dictionary) with the following keys:\n• . The string or numeric ID of the market or trade instrument within the exchange. Market ids are used inside exchanges internally to identify trading pairs during the request/response process.\n• . An uppercase string code representation of a particular trading pair or instrument. This is usually written as with a slash as in , or , etc. Symbols are used to reference markets within the ccxt library (explained below).\n• . A unified uppercase string code of base fiat or crypto currency. This is the standardized currency code that is used to refer to that currency or token throughout CCXT and throughout the Unified CCXT API, it's the language that CCXT understands.\n• . An exchange-specific id of the base currency for this market, not unified. Can be any string, literally. This is communicated to the exchange using the language the exchange understands.\n• . An exchange-specific id of the quote currency, not unified.\n• . A boolean indicating whether or not trading this market is currently possible, more about it here: status.\n• . Float, 0.0015 = 0.15%. Maker fees are paid when you provide liquidity to the exchange i.e. you market-make an order and someone else fills it. Maker fees are usually lower than taker fees. Fees can be negative, this is very common amongst derivative exchanges. A negative fee means the exchange will pay a rebate (reward) to the user for trading this market.\n• . Float, 0.002 = 0.2%. Taker fees are paid when you take liquidity from the exchange and fill someone else's order.\n• . A boolean true/false value indicating whether and are multipliers or fixed flat amounts.\n• . A boolean true/false value indicating whether the fee depends on your trading tier (usually, your traded volume over a period of time).\n• . An associative array of non-common market properties, including fees, rates, limits and other general market information. The internal info array is different for each particular market, its contents depend on the exchange.\n• . Precision accepted in order values by exchanges upon order placement for price, amount and cost. (The value inside this property depend on the ).\n• . The minimums and maximums for prices, amounts (volumes) and costs (where cost = price * amount).\n• . The type of the option, option represents an option with the right to buy and an option with the right to sell.\n• . Price at which an option can be bought or sold when it is exercised.\n\nThe flag is typically used in and . The exchanges might put a slightly different meaning into it. If a currency is inactive, most of the time all corresponding tickers, orderbooks and other related endpoints return empty responses, all zeroes, no data or outdated information. The user should check if the currency is and reload markets periodically.\n\nNote: the value for the property doesn't always guarantee that all of the possible features like trading, withdrawing or depositing are disabled on the exchange. Likewise, neither the value guarantees that all those features are enabled on the exchange. Check the underlying exchanges' documentation and the code in CCXT for the exact meaning of the flag for this or that exchange. This flag is not yet supported or implemented by all markets and may be missing.\n\nWARNING! The information about the fee is experimental, unstable and may be partial or not available at all.\n\nDo not confuse with ! Precision has nothing to do with min limits. A precision of 8 digits does not necessarily mean a min limit of 0.00000001. The opposite is also true: a min limit of 0.0001 does not necessarily mean a precision of 4.\n\nIn this example the amount of any order placed on the market must satisfy both conditions:\n• The amount value should be >= 0.05:\n• Precision of the amount should be up to 4 decimal digits:\n\nIn this example the price of any order placed on the market must satisfy both conditions:\n• The price value should be >= 0.019:\n• Precision of price should be 5 decimal digits or less:\n\nIn this example both conditions must be satisfied:\n• The amount value should be greater than or equal to 50:\n• A negative amount precision means that the amount should be an integer multiple of 10 (to the absolute power specified):\n\nThe and params are currently under heavy development, some of these fields may be missing here and there until the unification process is complete. This does not influence most of the orders but can be significant in extreme cases of very large or very small orders.\n\nThe user is required to stay within all limits and precision! The values of the order should satisfy the following conditions:\n• Precision of must be <=\n• Precision of must be <=\n\nThe above values can be missing with some exchanges that don't provide info on limits from their API or don't have it implemented yet.\n\nEach exchange has its own rounding, counting and padding modes.\n• – will round the last decimal digits to precision\n• – will cut off the digits after certain precision\n\nThe decimal precision counting mode is available in the property.\n• – counts all digits, 99% of exchanges use this counting mode. With this mode of precision, the numbers in designate the number of decimal digits after the dot for further rounding or truncation.\n• – counts non-zero digits only, some exchanges ( and maybe a few other) implement this mode of counting decimals. With this mode of precision, the numbers in designate the Nth place of the last significant (non-zero) decimal digit after the dot.\n• – some exchanges only allow a multiple of a specific value ( uses this mode, for example). In this mode, the numbers in designate the minimal precision fractions (floats) for rounding or truncating.\n• – appends zero characters up to precision\n\nMost of the time the user does not have to take care of precision formatting, since CCXT will handle that for the user when the user places orders or sends withdrawal requests, if the user follows the rules as described on Precision And Limits. However, in some cases precision-formatting details may be important, so the following methods may be useful in the userland.\n\nThe exchange base class contains the method to help format values to the required decimal precision with support for different rounding, counting and padding modes.\n\nFor examples of how to use the to format strings and floats, please, see the following files:\n\nPython WARNING! The method is susceptible to\n\nFor users' convenience CCXT base exchange class also implements the following methods:\n\nEvery exchange has its own precision settings, the above methods will help format those values according to exchange-specific precision rules, in a way that is portable and agnostic of the underlying exchange. In order to make that possible, markets and currencies have to be loaded prior to formatting any values.\n\nMake sure to load the markets with before calling these methods!\n\nMore practical examples that describe the behavior of :\n\nIn most cases you are required to load the list of markets and trading symbols for a particular exchange prior to accessing other API methods. If you forget to load markets the ccxt library will do that automatically upon your first call to the unified API. It will send two HTTP requests, first for markets and then the second one for other data, sequentially. For that reason, your first call to a unified CCXT API method like fetchTicker, fetchBalance, etc will take more time, than the consequent calls, since it has to do more work loading the market information from the exchange API. See Notes On Rate Limiter for more details.\n\nIn order to load markets manually beforehand call the / method on an exchange instance. It returns an associative array of markets indexed by trading symbol. If you want more control over the execution of your logic, preloading markets by hand is recommended.\n\nApart from the market info, the call will also load the currencies from the exchange and will cache the info in the and the properties respectively.\n\nThe user can also bypass the cache and call unified methods for fetching that information from the exchange endpoints directly, and , though using these methods is not recommended for end-users. The recommended way to preload markets is by calling the unified method. However, new exchange integrations are required to implement these methods if the underlying exchange has the corresponding API endpoints.\n\nA currency code is a code of three to five letters, like , , , , , , , , , , , etc. Some exchanges have exotic currencies with longer codes.\n\nA symbol is usually an uppercase string literal name of a pair of traded currencies with a slash in between. The first currency before the slash is usually called base currency, and the one after the slash is called quote currency. Examples of a symbol are: , , , , , , .\n\nMarket ids are used during the REST request-response process to reference trading pairs within exchanges. The set of market ids is unique per exchange and cannot be used across exchanges. For example, the BTC/USD pair/market may have different ids on various popular exchanges, like , , , , (numeric id), , , , . You don't need to remember or use market ids, they are there for internal HTTP request-response purposes inside exchange implementations.\n\nThe ccxt library abstracts uncommon market ids to symbols, standardized to a common format. Symbols aren't the same as market ids. Every market is referenced by a corresponding symbol. Symbols are common across exchanges which makes them suitable for arbitrage and many other things.\n\nSometimes the user might notice a symbol like or or some other \"exotic/rare symbols\". The symbol is not required to have a slash or to be a pair of currencies. The string in the symbol really depends on the type of the market (whether it is a spot market or a futures market, a darkpool market or an expired market, etc). Attempting to parse the symbol string is highly discouraged, one should not rely on the symbol format, it is recommended to use market properties instead.\n\nMarket structures are indexed by symbols and ids. The base exchange class also has builtin methods for accessing markets by symbols. Most API methods require a symbol to be passed in their first argument. You are often required to specify a symbol when querying current prices, making orders, etc.\n\nMost of the time users will be working with market symbols. You will get a standard userland exception if you access non-existent keys in these dicts.\n\nThere is a bit of term ambiguity across various exchanges that may cause confusion among newcoming traders. Some exchanges call markets as pairs, whereas other exchanges call symbols as products. In terms of the ccxt library, each exchange contains one or more trading markets. Each market has an id and a symbol. Most symbols are pairs of base currency and quote currency.\n\nHistorically various symbolic names have been used to designate same trading pairs. Some cryptocurrencies (like Dash) even changed their names more than once during their ongoing lifetime. For consistency across exchanges the ccxt library will perform the following known substitutions for symbols and currencies:\n• : is newer but is more common among exchanges and sounds more like bitcoin (read more).\n• : The Bitcoin Cash fork is often called with two different symbolic names: and . The name is ambiguous for Bitcoin Cash, it is confused with BitConnect. The ccxt library will convert to where it is appropriate (some exchanges and aggregators confuse them).\n• : was Darkcoin then became Dash (read more).\n• : On November 15 2018 Bitcoin Cash forked the second time, so, now there is (for BCH ABC) and (for BCH SV).\n• : This is a common substitution mapping for the Bitcoin Cash SV fork (some exchanges call it , others call it , we use the former).\n• : Try not to confuse symbols and currencies. The (Dashcoin) is not the same as (Dash). Some exchanges have labelled inconsistently as , the ccxt library does a correction for that as well ( ), but only on certain exchanges that have these two currencies confused, whereas most exchanges have them both correct. Just remember that is not the same as .\n• → : is the newer code for RaiBlocks, thus, CCXT unified API uses will replace the older with where needed. https://hackernoon.com/nano-rebrand-announcement-9101528a7b76\n• → : Some exchanges, like Bitfinex, HitBTC and a few other name the currency as in their listings, but those markets are actually trading . The confusion can come from a 3-letter limitation on symbol names or may be due to other reasons. In cases where the traded currency is actually and is not – the CCXT library will perform → conversion. Note, however, that some exchanges have both and symbols, for example, Kraken has a trading pair.\n\nEach exchange has an associative array of substitutions for cryptocurrency symbolic codes in the property. Sometimes the user may notice exotic symbol names with mixed-case words and spaces in the code. The logic behind having these names is explained by the rules for resolving conflicts in naming and currency-coding when one or more currencies have the same symbolic code with different exchanges:\n• First, we gather all info available from the exchanges themselves about the currency codes in question. They usually have a description of their coin listings somewhere in their API or their docs, knowledgebases or elsewhere on their websites.\n• When we identify each particular cryptocurrency standing behind the currency code, we look them up on CoinMarketCap.\n• The currency that has the greatest market capitalization of all wins the currency code and keeps it. For example, HOT often stand for either or . In this case retains the code , and will have its name as its code, literally, . So, there may be trading pairs with symbols like (for ) and – those are two different markets.\n• If market cap of a particular coin is unknown or is not enough to determine the winner, we also take trading volumes and other factors into consideration.\n• When the winner is determined all other competing currencies get their code names properly remapped and substituted within conflicting exchanges via .\n• Unfortunately this is a work in progress, because new currencies get listed daily and new exchanges are added from time to time, so, in general this is a never-ending process of self-correction in a quickly changing environment, practically, in \"live mode\". We are thankful for all reported conflicts and mismatches you may find.\n\nIs it possible for symbols to change?\n\nIn short, yes, sometimes, but rarely. Symbolic mappings can be changed if that is absolutely required and cannot be avoided. However, all previous symbolic changes were related to resolving conflicts or forks. So far, there was no precedent of a market cap of one coin overtaking another coin with the same symbolic code in CCXT.\n\nCan we rely on always listing the same crypto with the same symbol?\n\nMore or less ) First, this library is a work in progress, and it is trying to adapt to the everchanging reality, so there may be conflicts that we will fix by changing some mappings in the future. Ultimately, the license says \"no warranties, use at your own risk\". However, we don't change symbolic mappings randomly all over the place, because we understand the consequences and we'd want to rely on the library as well and we don't like to break the backward-compatibility at all.\n\nIf it so happens that a symbol of a major token is forked or has to be changed, then the control is still in the users' hands. The property can be overrided upon initialization or later, just like any other exchange property. If a significant token is involved, we usually post instructions on how to retain the old behavior by adding a couple of lines to the constructor params.\n\nIt depends on which exchange you are using, but some of them have a reversed (inconsistent) pairing of and . They actually have base and quote misplaced (switched/reversed sides). In that case you'll see a difference of parsed and currency values with the unparsed in the market substructure.\n\nFor those exchanges the ccxt will do a correction, switching and normalizing sides of base and quote currencies when parsing exchange replies. This logic is financially and terminologically correct. If you want less confusion, remember the following rule: base is always before the slash, quote is always after the slash in any symbol and with any market.\n\nWe currently load spot markets with the unified symbol schema into the mapping, indexed by symbol. This would cause a naming conflict for futures and other derivatives that have the same symbol as their spot market counterparts. To accomodate both types of markets in the we require the symbols between 'future' and 'spot' markets to be distinct, as well as the symbols between 'linear' and 'inverse' contracts to be distinct.\n\nCCXT supports the following types of derivative contracts:\n• – for expiring futures contracts that have a delivery/settlement date\n• – for perpetual swap futures that don't have a delivery date\n\nA future market symbol consists of the underlying currency, the quoting currency, the settlement currency and an arbitrary identifier. Most often the identifier is the settlement date of the future contract in format:\n\nThe is also a dirty method with a side effect of saving the array of markets on the exchange instance. You only need to call it once per exchange. All subsequent calls to the same method will return the locally saved (cached) array of markets.\n\nWhen exchange markets are loaded, you can then access market information any time via the property. This property contains an associative array of markets indexed by symbol. If you need to force reload the list of markets after you have them loaded already, pass the reload = true flag to the same method again.\n\nEach exchange offers a set of API methods. Each method of the API is called an endpoint. Endpoints are HTTP URLs for querying various types of information. All endpoints return JSON in response to client requests.\n\nUsually, there is an endpoint for getting a list of markets from an exchange, an endpoint for retrieving an order book for a particular market, an endpoint for retrieving trade history, endpoints for placing and canceling orders, for money deposit and withdrawal, etc... Basically every kind of action you could perform within a particular exchange has a separate endpoint URL offered by the API.\n\nBecause the set of methods differs from exchange to exchange, the ccxt library implements the following:\n• a public and private API for all possible URLs and methods\n\nThe endpoint URLs are predefined in the property for each exchange. You don't have to override it, unless you are implementing a new exchange API (at least you should know what you're doing).\n\nMost of exchange-specific API methods are implicit, meaning that they aren't defined explicitly anywhere in code. The library implements a declarative approach for defining implicit (non-unified) exchanges' API methods.\n\nEach method of the API usually has its own endpoint. The library defines all endpoints for each particular exchange in the property. Upon exchange construction an implicit magic method (aka partial function or closure) will be created inside on the exchange instance for each endpoint from the list of endpoints. This is performed for all exchanges universally. Each generated method will be accessible in both and notations.\n\nThe endpoints definition is a full list of ALL API URLs exposed by an exchange. This list gets converted to callable methods upon exchange instantiation. Each URL in the API endpoint list gets a corresponding callable method. This is done automatically for all exchanges, therefore the ccxt library supports all possible URLs offered by crypto exchanges.\n\nEach implicit method gets a unique name which is constructed from the definition. For example, a private HTTPS PUT endpoint will have a corresponding exchange method named / . A public HTTPS GET endpoint would result in the corresponding method named / , and so on.\n\nAn implicit method takes a dictionary of parameters, sends the request to the exchange and returns an exchange-specific JSON result from the API as is, unparsed. To pass a parameter, add it to the dictionary explicitly under a key equal to the parameter's name. For the examples above, this would look like and .\n\nThe recommended way of working with exchanges is not using exchange-specific implicit methods but using the unified ccxt methods instead. The exchange-specific methods should be used as a fallback in cases when a corresponding unified method isn't available (yet).\n\nTo get a list of all available methods with an exchange instance, including implicit methods and unified methods you can simply do the following:\n\nAPI URLs are often grouped into two sets of methods called a public API for market data and a private API for trading and account access. These groups of API methods are usually prefixed with a word 'public' or 'private'.\n\nA public API is used to access market data and does not require any authentication whatsoever. Most exchanges provide market data openly to all (under their rate limit). With the ccxt library anyone can access market data out of the box without having to register with the exchanges and without setting up account keys and passwords.\n\nThe private API is mostly used for trading and for accessing account-specific private data, therefore it requires authentication. You have to get the private API keys from the exchanges. It often means registering with an exchange website and creating the API keys for your account. Most exchanges require personal information or identification. Some exchanges will only allow trading after completing the KYC verification. Private APIs allow the following:\n\nSome exchanges offer the same logic under different names. For example, a public API is also often called market data, basic, market, mapi, api, price, etc... All of them mean a set of methods for accessing data available to public. A private API is also often called trading, trade, tapi, exchange, account, etc...\n\nA few exchanges also expose a merchant API which allows you to create invoices and accept crypto and fiat payments from your clients. This kind of API is often called merchant, wallet, payment, ecapi (for e-commerce).\n\nTo get a list of all available methods with an exchange instance, you can simply do the following:\n\ncontract only and margin only\n• methods in this documentation that are documented as contract only or margin only are only intended to be used for contract trading and margin trading respectively. They may work when trading in other types of markets but will most likely return irrelevant information.\n\nIn the JavaScript version of CCXT all methods are asynchronous and return Promises that resolve with a decoded JSON object. In CCXT we use the modern async/await syntax to work with Promises. If you're not familiar with that syntax, you can read more about it here.\n\nThe ccxt library supports asynchronous concurrency mode in Python 3.5+ with async/await syntax. The asynchronous Python version uses pure asyncio with aiohttp. In async mode you have all the same properties and methods, but most methods are decorated with an async keyword. If you want to use async mode, you should link against the subpackage, like in the following example:\n\nCCXT support PHP 8+ versions. The library has both synchronous and asynchronous versions. To use synchronous version, use namespace (i.e. ) and to use asynchronous version, use namespace (i.e. ). Asynchronous version uses ReactPHP library in the background. In async mode you have all the same properties and methods, but any networking API method should be decorated with the keyword and your script should be in a ReactPHP wrapper:\n\nSee further examples in the directory; look for filenames that include the word. Also, make sure you have installed the required dependencies using . Lastly, this article provides a good introduction to the methods used here. While syntactically the change is simple (i.e., just using a keyword before relevant methods), concurrency has significant implications for the overall design of your code.\n\nAll public and private API methods return raw decoded JSON objects in response from the exchanges, as is, untouched. The unified API returns JSON-decoded objects in a common format and structured uniformly across all exchanges.\n\nThe set of all possible API endpoints differs from exchange to exchange. Most of methods accept a single associative array (or a Python dict) of key-value parameters. The params are passed as follows:\n\nThe unified methods of exchanges might expect and will accept various which affect their functionality, like:\n\nAn exchange will not accept the params from a different exchange, they're not interchangeable. The list of accepted parameters is defined by each specific exchange.\n\nTo find which parameters can be passed to a unified method:\n• either open the exchange-specific implementation file and search for the desired function (i.e. ) to inspect and find out the details of usage\n• or go to the exchange's API docs and read the list of parameters for your specific function or endpoint (i.e. )\n\nFor a full list of accepted method parameters for each exchange, please consult API docs.\n\nAn exchange method name is a concatenated string consisting of type (public or private), HTTP method (GET, POST, PUT, DELETE) and endpoint URL path like in the following examples:\n\nThe ccxt library supports both camelcase notation (preferred in JavaScript) and underscore notation (preferred in Python and PHP), therefore all methods can be called in either notation or coding style in any language. Both of these notations work in JavaScript, Python and PHP:\n\nTo get a list of all available methods with an exchange instance, you can simply do the following:\n\nThe unified ccxt API is a subset of methods common among the exchanges. It currently contains the following methods:\n• : Fetches a list of all available markets from an exchange and returns an array of markets (objects with properties such as , , etc.). Some exchanges do not have means for obtaining a list of markets via their online API. For those, the list of markets is hardcoded.\n• : Fetches all available currencies an exchange and returns an associative dictionary of currencies (objects with properties such as , , etc.). Some exchanges do not have means for obtaining currencies via their online API. For those, the currencies will be extracted from market pairs or hardcoded.\n• : Returns the list of markets as an object indexed by symbol and caches it with the exchange instance. Returns cached markets if loaded already, unless the flag is forced.\n• : Returns information regarding the exchange status from either the info hardcoded in the exchange instance or the API, if available.\n\nNote, that most of methods of the unified API accept an optional argument. It is an associative array (a dictionary, empty by default) containing the params you want to override. The contents of are exchange-specific, consult the exchanges' API documentation for supported fields and values. Use the dictionary if you need to pass a custom setting or an optional parameter to your unified query.\n\nMost of unified methods will return either a single object or a plain array (a list) of objects (trades, orders, transactions and so on). However, very few exchanges (if any at all) will return all orders, all trades, all ohlcv candles or all transactions at once. Most often their APIs output to a certain number of most recent objects. YOU CANNOT GET ALL OBJECTS SINCE THE BEGINNING OF TIME TO THE PRESENT MOMENT IN JUST ONE CALL. Practically, very few exchanges will tolerate or allow that.\n\nTo fetch historical orders or trades, the user will need to traverse the data in portions or \"pages\" of objects. Pagination often implies \"fetching portions of data one by one\" in a loop.\n\nIn most cases users are required to use at least some type of pagination in order to get the expected results consistently. If the user does not apply any pagination, most methods will return the exchanges' default, which may start from the beginning of history or may be a subset of most recent objects. The default behaviour (without pagination) is exchange-specific! The means of pagination are often used with the following methods in particular:\n\nWith methods returning lists of objects, exchanges may offer one or more types of pagination. CCXT unifies date-based pagination by default, with timestamps in milliseconds throughout the entire library.\n\nWarning: this is an experimental feature and might produce unexpected/incorrect results in some instances.\n\nRecently, CCXT introduced a way to paginate through several results automatically by just providing the flag inside lifting this work from the userland. Most leading exchanges support it, and more will be added in the future, but the easiest way to check it is to look in the method's documentation and search for the pagination parameter. As always there are exceptions, and some endpoints might not provide a way to paginate either through a timestamp or a cursor, and in those cases, there's nothing CCXT can do about it.\n\nRight now, we have three different ways of paginating:\n• dynamic/time-based: uses the and parameters to paginate through dynamic results like (trades, orders, transactions, etc). Since we don't know a priori how many entries are available to be fetched, it will perform one request at a time until we reach the end of the data or the maximum amount of pagination calls (configurable through an option)\n• deterministic: when we can pre-compute the boundaries of each page, it will perform the requests concurrently for maximum performance. This applies to OHLCV, Funding Rates, and Open Interest and also respects the option.\n• cursor-based: when the exchange provides a cursor inside the response, we extract the cursor and perform the subsequent request until the end of the data or reach the maximum number of pagination calls.\n\nThe user cannot select the pagination method used, it will depend from implementation to implementation, considering the exchange API's features.\n\nWe can't perform an infinite amount of requests, and some of them might throw an error for different reasons, thus, we have some options that allow the user to control these variables and other pagination specificities.\n\nAll the options below, should be provided inside , you can check the examples below\n• paginate: (boolean) indicates that the user wants to paginate through different pages to get more data. Default is false.\n• paginationCalls: (integer) allows the user to control the maximum amount of requests to paginate the data. Due to the rate limits, this value should not be too high. Default is 10.\n• maxRetries: (integer) how many times should the pagination mechanism retry upon getting an error. Default is 3\n• paginationDirection: (string) Only applies to the dynamic pagination and it can be either forward (start the pagination from some time in the past and paginate forward) or backward (start from the most recent time and paginate backward). If forward is selected then a since parameter must also be provided. Default is backward.\n• maxEntriesPerRequest: (integer): The max amount of entries per request so that we can maximize the data retrieved per call. It varies from endpoint to endpoint and CCXT will populate this value for you, but you can override it if needed.\n\nThe set of methods for working with UTC dates and timestamps and for converting between them:\n\nThis is the type of pagination currently used throughout the CCXT Unified API. The user supplies a timestamp in milliseconds (!) and a number to results. To traverse the objects of interest page by page, the user runs the following (below is pseudocode, it may require overriding some exchange-specific params, depending on the exchange in question):\n\nThe user supplies a of the object, from where the query should continue returning results, and a number to results. This is the default with some exchanges, however, this type is not unified (yet). To paginate objects based on their ids, the user would run the following:\n\nThe user supplies a page number or an initial \"cursor\" value. The exchange returns a page of results and the next \"cursor\" value, to proceed from. Most of exchanges that implement this type of pagination will either return the next cursor within the response itself or will return the next cursor values within HTTP response headers.\n\nSee an example implementation here: https://github.com/ccxt/ccxt/blob/master/examples/py/coinbasepro-fetch-my-trades-pagination.py\n\nUpon each iteration of the loop the user has to take the next cursor and put it into the overrided params for the next query (on the following iteration):\n\nExchanges expose information on open orders with bid (buy) and ask (sell) prices, volumes and other data. Usually there is a separate endpoint for querying current state (stack frame) of the order book for a particular market. An order book is also often called market depth. The order book information is used in the trading decision making process.\n\nTo get data on order books, you can use\n• // for the order books of all markets\n• limit (Integer) The number of orders to return in the order book (e.g. )\n• limit (Integer) The number of orders to return in the order book (e.g. )\n\nThe timestamp and datetime may be missing ( ) if the exchange in question does not provide a corresponding value in the API response.\n\nPrices and amounts are floats. The bids array is sorted by price in descending order. The best (highest) bid price is the first element and the worst (lowest) bid price is the last element. The asks array is sorted by price in ascending order. The best (lowest) ask price is the first element and the worst (highest) ask price is the last element. Bid/ask arrays can be empty if there are no corresponding orders in the order book of an exchange.\n\nExchanges may return the stack of orders in various levels of details for analysis. It is either in full detail containing each and every order, or it is aggregated having slightly less detail where orders are grouped and merged by price and volume. Having greater detail requires more traffic and bandwidth and is slower in general but gives a benefit of higher precision. Having less detail is usually faster, but may not be enough in some very specific cases.\n• The is the time when the exchange generated this orderbook response (before replying it back to you). This may be missing ( ), as documented in the Manual, not all exchanges provide a timestamp there. If it is defined, then it is the UTC timestamp in milliseconds since 1 Jan 1970 00:00:00.\n• Some exchanges may index orders in the orderbook by order ids, in that case the order id may be returned as the third element of bids and asks: . This is often the case with L3 orderbooks without aggregation. The order , if shown in the orderbook, refers to the orderbook and does not necessarily correspond to the actual order id from the exchanges' database as seen by the owner or by the others. The order id is an of the row inside the orderbook, but not necessarily the true- of the order (though, they may be equal as well, depending on the exchange in question).\n• In some cases the exchanges may supply L2 aggregated orderbooks with order counts for each aggregated level, in that case the order count may be returned as the third element of bids and asks: . The tells how many orders are aggregated on each price level in bids and asks.\n• Also, some exchanges may return the order timestamp as the third element of bids and asks: . The tells when the order was placed on the orderbook.\n\nSome exchanges accept a dictionary of extra parameters to the function. All extra are exchange-specific (non-unified). You will need to consult exchanges docs if you want to override a particular param, like the depth of the order book. You can get a limited count of returned orders or a desired level of aggregation (aka market depth) by specifying an limit argument and exchange-specific extra like so:\n\nThe levels of detail or levels of order book aggregation are often number-labelled like L1, L2, L3...\n• L1: less detail for quickly obtaining very basic info, namely, the market price only. It appears to look like just one order in the order book.\n• L2: most common level of aggregation where order volumes are grouped by price. If two orders have the same price, they appear as one single order for a volume equal to their total sum. This is most likely the level of aggregation you need for the majority of purposes.\n• L3: most detailed level with no aggregation where each order is separate from other orders. This LOD naturally contains duplicates in the output. So, if two orders have equal prices they are not merged together and it's up to the exchange's matching engine to decide on their priority in the stack. You don't really need L3 detail for successful trading. In fact, you most probably don't need it at all. Therefore some exchanges don't support it and always return aggregated order books.\n\nIf you want to get an L2 order book, whatever the exchange returns, use the or unified method for that.\n\nThe argument does not guarantee that the number of bids or asks will always be equal to . It designates the upper boundary or the maximum, so at some moment in time there may be less than bids or asks. This is the case when the exchange does not have enough orders on the orderbook. However, if the underlying exchange API does not support a parameter for the orderbook endpoint at all, then the argument will be ignored. CCXT does not trim and if the exchange returns more than you request.\n\nIn order to get current best price (query market price) and calculate bidask spread take first elements from bid and ask, like so:\n\nA price ticker contains statistics for a particular market/symbol for some period of time in recent past, usually last 24 hours. The methods for fetching tickers are described below.\n\nCheck the and properties of the exchange instance to determine if the exchange in question does support these methods.\n\nPlease, note, that calling without a symbol is usually strictly rate-limited, an exchange may ban you if you poll that endpoint too frequently.\n\nA ticker is a statistical calculation with the information calculated over the past 24 hours for a specific market.\n\nThe structure of a ticker is as follows:\n• All fields in the ticker represent the past 24 hours prior to .\n• The is the volume (amount) of current best bid in the orderbook.\n• The is the volume (amount) of current best ask in the orderbook.\n• The is the amount of base currency traded (bought or sold) in last 24 hours.\n• The is the amount of quote currency traded (bought or sold) in last 24 hours.\n\nAll prices in ticker structure are in quote currency. Some fields in a returned ticker structure may be undefined/None/null.\n\nTimestamp and datetime are both Universal Time Coordinated (UTC) in milliseconds.\n• is the time when the exchange generated this response (before replying it back to you). It may be missing ( ), as documented in the Manual, not all exchanges provide a timestamp there. If it is defined, then it is a UTC timestamp in milliseconds since 1 Jan 1970 00:00:00.\n• is the date-time string of the last HTTP response received (from HTTP headers). The 'Date' parser should respect the timezone designated there. The precision of the date-time is 1 second, 1000 milliseconds. This date should be set by the exchange server when the message originated according to the following standards:\n\nAlthough some exchanges do mix-in orderbook's top bid/ask prices into their tickers (and some exchanges even serve top bid/ask volumes) you should not treat a ticker as a replacement. The main purpose of a ticker is to serve statistical data, as such, treat it as \"live 24h OHLCV\". It is known that exchanges discourage frequent requests by imposing stricter rate limits on these queries. If you need a unified way to access bids and asks you should use family instead.\n\nTo get historical prices and volumes use the unified method where available. To get historical mark, index, and premium index prices, add one of , , respectively to the params-overrides of . There are also convenience methods , , and that obtain the mark, index and premiumIndex historical prices and volumes.\n\nTo get the individual ticker data from an exchange for a particular trading pair or a specific symbol – call the :\n\nSome exchanges (not all of them) also support fetching all tickers at once. See their docs for details. You can fetch all tickers with a single call like so:\n\nFetching all tickers requires more traffic than fetching a single ticker. Also, note that some exchanges impose higher rate-limits on subsequent fetches of all tickers (see their docs on corresponding endpoints for details). The cost of the call in terms of rate limit is often higher than average. If you only need one ticker, fetching by a particular symbol is faster as well. You probably want to fetch all tickers only if you really need all of them and, most likely, you don't want to fetchTickers more frequently than once in a minute or so.\n\nAlso, some exchanges may impose additional requirements on the call, sometimes you can't fetch the tickers for all symbols because of the API limitations of the exchange in question. Some exchanges accept a list of symbols in HTTP URL query params, however, because URL length is limited, and in extreme cases exchanges can have thousands of markets – a list of all their symbols simply would not fit in the URL, so it has to be a limited subset of their symbols. Sometimes, there are other reasons for requiring a list of symbols, and there may be a limit on the number of symbols you can fetch at once, but whatever the limitation, please, blame the exchange. To pass the symbols of interest to the exchange, you can supply a list of strings as the first argument to fetchTickers:\n\nNote that the list of symbols is not required in most cases, but you must add additional logic if you want to handle all possible limitations that might be imposed on the exchanges' side.\n\nLike most methods of the Unified CCXT API, the last argument to fetchTickers is the argument for overriding request parameters that are sent towards the exchange.\n\nThe structure of the returned value is as follows:\n\nA general solution for fetching all tickers from all exchanges (even the ones that don't have a corresponding API endpoint) is on the way, this section will be updated soon.\n\nMost exchanges have endpoints for fetching OHLCV data, but some of them don't. The exchange boolean (true/false) property named indicates whether the exchange supports candlestick data series or not.\n\nThe method is declared in the following way:\n\nYou can call the unified / method to get the list of OHLCV candles for a particular symbol like so:\n\nTo get the list of available timeframes for your exchange see the property. Note that it is only populated when is true as well.\n\nThe returned list of candles may have one or more missing periods, if the exchange did not have any trades for the specified timerange and symbol. To a user that would appear as gaps in a continuous list of candles. That is considered normal. If the exchange did not have any candles at that time, the CCXT library will show the results as returned from the exchange itself.\n\nThere's a limit on how far back in time your requests can go. Most of exchanges will not allow to query detailed candlestick history (like those for 1-minute and 5-minute timeframes) too far in the past. They usually keep a reasonable amount of most recent candles, like 1000 last candles for any timeframe is more than enough for most of needs. You can work around that limitation by continuously fetching (aka REST polling) latest OHLCVs and storing them in a CSV file or in a database.\n\nNote that the info from the last (current) candle may be incomplete until the candle is closed (until the next candle starts).\n\nLike with most other unified and implicit methods, the method accepts as its last argument an associative array (a dictionary) of extra , which is used to override default values that are sent in requests to the exchanges. The contents of are exchange-specific, consult the exchanges' API documentation for supported fields and values.\n\nThe argument is an integer UTC timestamp in milliseconds (everywhere throughout the library with all unified methods).\n\nIf is not specified the method will return the time range as is the default from the exchange itself. This is not a bug. Some exchanges will return candles from the beginning of time, others will return most recent candles only, the exchanges' default behaviour is expected. Thus, without specifying the range of returned candles will be exchange-specific. One should pass the argument to ensure getting precisely the history range needed.\n\nTrading strategies require fresh up-to-date information for technical analysis, indicators and signals. Building a speculative trading strategy based on the OHLCV candles received from the exchange may have critical drawbacks. Developers should account for the details explained in this section to build successful bots.\n\nFirst and foremost, when using CCXT you're talking to the exchanges directly. CCXT is not a server, nor a service, it's a software library. All data that you are getting with CCXT is received directly from the exchanges first-hand.\n\nThe exchanges usually provide two categories of public market data:\n• Fast primary first-order data that includes real time orderbooks and trades or fills\n• Slow second-order data that includes secondary tickers and kline OHLCV candles, that are calculated from the first-order data\n\nThe primary first-order data is updated by the exchanges APIs in pseudo real time, or as close to real time as possible, as fast as possible. The second-order data requires time for the exchange to calculate it. For example, a ticker is nothing more than a rolling 24-hour statistical cut of orderbooks and trades. OHLCV candles and volumes are also calculated from first-order trades and represent fixed statistical cuts of specific periods. The volume traded within an hour is just a sum of traded volumes of the corresponding trades that happened within that hour.\n\nObviously, it takes some time for the exchange to collect the first-order data and calculate the secondary statistical data from it. That literally means that tickers and OHLCVs are always slower than orderbooks and trades. In other words, there is always some latency in the exchange API between the moment when a trade happens and the moment when a corresponding OHLCV candle is updated or published by the exchange API.\n\nThe latency (or how much time is needed by the exchange API for calculating the secondary data) depends on how fast the exchange engine is, so it is exchange-specific. Top exchange engines will usually return and update fresh last-minute OHLCV candles and tickers at a very fast rate. Some exchanges might do it in regular intervals like once a second or once in a few seconds. Slow exchange engines might take minutes to update the secondary statistical information, their APIs might return the current most recent OHLCV candle a few minutes late.\n\nIf your strategy depends on the fresh last-minute most recent data you don't want to build it based on tickers or OHLCVs received from the exchange. Tickers and exchanges' OHLCVs are only suitable for display purposes, or for simple trading strategies for hour-timeframes or day-timeframes that are less susceptible to latency.\n\nThankfully, the developers of time-critical trading strategies don't have to rely on secondary data from the exchanges and can calculate the OHLCVs and tickers in the userland. That may be faster and more efficient than waiting for the exchanges to update the info on their end. One can aggregate the public trade history by polling it frequently and calculate candles by walking over the list of trades. CCXT offers a base method for that:\n\nDue to the differences in their internal implementations the exchanges may be faster to update their primary and secondary market data over WebSockets (see https://ccxt.pro). The latency remains exchange-specific, cause the exchange engine still needs time to calculate the secondary data, regardless of whether you're polling it over the RESTful API with CCXT or getting updates via WebSockets with CCXT Pro. WebSockets can improve the networking latency, so a fast exchange will work even better, but adding the support for WS subscriptions will not make a slow exchange engine work much faster.\n\nIf you want to stay on top of the second-order data latency, then you will have to calculate it on your side and beat the exchange engine in speed of doing so. Depending on the needs of your application, it may be tricky, since you will need to handle redundancy, \"data holes\" in the history, exchange downtimes, and other aspects of data aggregation which is a whole universe in itself that is impossible to fully cover in this Manual.\n\nThe fetchOHLCV method shown above returns a list (a flat array) of OHLCV candles represented by the following structure:\n\nThe list of candles is returned sorted in ascending (historical/chronological) order, oldest candle first, most recent candle last.\n\nTo obtain historical Mark, Index Price and Premium Index candlesticks pass the params-override to . The parameter accepts one of the following values:\n\nThere are also convenience methods , and\n\nSome exchanges don't offer any OHLCV method, and for those, the ccxt library will emulate OHLCV candles from Public Trades. In that case you will see . However, because the trade history is usually very limited, the emulated fetchOHLCV methods cover most recent info only and should only be used as a fallback, when no other option is available.\n\nYou can call the unified / method to get the list of most recent trades for a particular symbol. The method is declared in the following way:\n\nFor example, if you want to print recent trades for all symbols one by one sequentially (mind the rateLimit!) you would do it like so:\n\nThe fetchTrades method shown above returns an ordered list of trades (a flat array, sorted by timestamp in ascending order, oldest trade first, most recent trade last). A list of trades is represented by the trade structure.\n\nMost exchanges return most of the above fields for each trade, though there are exchanges that don't return the type, the side, the trade id or the order id of the trade. Most of the time you are guaranteed to have the timestamp, the datetime, the symbol, the price and the amount of each trade.\n\nThe second optional argument reduces the array by timestamp, the third argument reduces by number (count) of returned items.\n\nIf the user does not specify , the method will return the default range of public trades from the exchange. The default set is exchange-specific, some exchanges will return trades starting from the date of listing a pair on the exchange, other exchanges will return a reduced set of trades (like, last 24 hours, last 100 trades, etc). If the user wants precise control over the timeframe, the user is responsible for specifying the argument.\n\nMost of unified methods will return either a single object or a plain array (a list) of objects (trades). However, very few exchanges (if any at all) will return all trades at once. Most often their APIs output to a certain number of most recent objects. YOU CANNOT GET ALL OBJECTS SINCE THE BEGINNING OF TIME TO THE PRESENT MOMENT IN JUST ONE CALL. Practically, very few exchanges will tolerate or allow that.\n\nTo fetch historical trades, the user will need to traverse the data in portions or \"pages\" of objects. Pagination often implies \"fetching portions of data one by one\" in a loop.\n\nIn most cases users are required to use at least some type of pagination in order to get the expected results consistently.\n\nOn the other hand, some exchanges don't support pagination for public trades at all. In general the exchanges will provide just the most recent trades.\n\nThe / method also accepts an optional (assoc-key array/dict, empty by default) as its fourth argument. You can use it to pass extra params to method calls or to override a particular default value (where supported by the exchange). See the API docs for your exchange for more details.\n\nThe method (if available) returns the current integer timestamp in milliseconds from the exchange server.\n\nThe exchange status describes the latest known information on the availability of the exchange API. This information is either hardcoded into the exchange class or fetched live directly from the exchange API. The method can be used to get this information. The status returned by is one of:\n• Hardcoded into the exchange class, e.g. if the API has been broken or shutdown.\n• Updated using the exchange ping or endpoint to see if its alive\n\nThe method will return a status structure like shown below:\n\nThe possible values in the field are:\n• ' means the exchange was closed, and the field should contain the datetime of the shutdown\n• means that either the exchange API is broken, or the implementation of the exchange in CCXT is broken\n• means regular maintenance, and the field should contain the datetime when the exchange is expected to be operational again\n\nWhen short trading or trading with leverage on a spot market, currency must be borrowed. Interest is accrued for the borrowed currency.\n\nData on the borrow rate for a currency can be retrieved using\n• for the borrow rates of currencies in individual markets\n• A dictionary of borrow rate structures with unified currency codes as keys\n• A dictionary of borrow rate structures with unified market symbols as keys\n\nThe method retrieves a history of a currencies borrow interest rate at specific time slots\n• since (Integer) Timestamp for the earliest borrow rate (e.g. )\n• limit (Integer) The maximum number of borrow rate structures to retrieve (e.g. )\n\nThe method can be used to obtain the maximum leverage for a market at varying position sizes. It can also be used to obtain the maintenance margin rate, and the max tradeable amount for a market when that information is not available from the market object\n\nWhile you can obtain the absolute maximum leverage for a market by accessing , for many contract markets, the maximum leverage will depend on the size of your position.\n\nYou can access those limits by using\n\nIn the example above:\n\nNote for Huobi users: Huobi uses both leverage and amount to determine maintenance margin rates: https://www.huobi.com/support/en-us/detail/900000089903\n\nData on the current, most recent, and next funding rates can be obtained using the methods\n• since (Integer) Timestamp for the earliest funding rate (e.g. )\n• limit (Integer) The maximum number of funding rates to retrieve (e.g. )\n\nUse the method to get the current open interest for a symbol from the exchange.\n\nUse the method to get a history of open interest for a symbol from the exchange.\n• since (Integer) Timestamp for the earliest open interest record (e.g. )\n• limit (Integer) The maximum number of open interest structures to retrieve (e.g. )\n\nNote for OKX users: instead of a unified symbol okx.fetchOpenInterestHistory expects a unified currency code in the symbol argument (e.g. ).\n\nUse the method to get the volatility history for the code of an options underlying asset from the exchange.\n\nUse the method to get the market id's of underlying assets for a contract market type from the exchange.\n\nUse the method to get the public settlement history for a contract market from the exchange.\n• since (Integer) Timestamp for the earliest settlement (e.g. )\n• limit (Integer) The maximum number of settlements to retrieve (e.g. )\n\nUse the method to get the public liquidations of a trading pair from the exchange.\n• since (Integer) Timestamp for the earliest liquidation (e.g. )\n• limit (Integer) The maximum number of liquidations to retrieve (e.g. )\n\nIn order to be able to access your user account, perform algorithmic trading by placing market and limit orders, query balances, deposit and withdraw funds and so on, you need to obtain your API keys for authentication from each exchange you want to trade with. They usually have it available on a separate tab or page within your user account settings. API keys are exchange-specific and cannnot be interchanged under any circumstances.\n\nThe exchanges' private APIs will usually allow the following types of interaction:\n• the current state of the user's account balance can be obtained with the method as described in the Account Balance section\n• the user can place and cancel orders with , , as well as fetch current open orders and the past order history with methods like , , , , , , , as described in the section on Orders\n• the user can query the history of past trades executed with their account using , as described in the My Trades section, also see How Orders Are Related To Trades\n• the user can query their positions with and as described in the Positions section\n• the user can fetch the history of their transactions (on-chain transactions which are either deposits to the exchange account or withdrawals from the exchange account) with , or with , , and separately, depending on what is available from the exchange API\n• if the exchange API provides a ledger endpoint, the user can fetch a history of all money movements that somehow affected the balance, with that will return all accounting ledger entries such as trades, deposits, withdrawals, internal transfers between accounts, rebates, bonuses, fees, staking profits and so on, as described in the Ledger section.\n\nAuthentication with all exchanges is handled automatically if provided with proper API keys. The process of authentication usually goes through the following pattern:\n• Generate new nonce. A nonce is an integer, often a Unix Timestamp in seconds or milliseconds (since epoch January 1, 1970). The nonce should be unique to a particular request and constantly increasing, so that no two requests share the same nonce. Each next request should have greater nonce than the previous request. The default nonce is a 32-bit Unix Timestamp in seconds.\n• Append public apiKey and nonce to other endpoint params, if any, then serialize the whole thing for signing.\n• Sign the serialized params using HMAC-SHA256/384/512 or MD5 with your secret key.\n• Append the signature in Hex or Base64 and nonce to HTTP headers or body.\n\nThis process may differ from exchange to exchange. Some exchanges may want the signature in a different encoding, some of them vary in header and body param names and formats, but the general pattern is the same for all of them.\n\nYou should not share the same API keypair across multiple instances of an exchange running simultaneously, in separate scripts or in multiple threads. Using the same keypair from different instances simultaneously may cause all sorts of unexpected behaviour.\n\nDO NOT REUSE API KEYS WITH DIFFERENT SOFTWARE! The other software will screw your nonce too high. If you get InvalidNonce errors – make sure to generate a fresh new keypair first and foremost.\n\nThe authentication is already handled for you, so you don't need to perform any of those steps manually unless you are implementing a new exchange class. The only thing you need for trading is the actual API key pair.\n\nThe API credentials usually include the following:\n• . This is your public API Key and/or Token. This part is non-secret, it is included in your request header or body and sent over HTTPS in open text to identify your request. It is often a string in Hex or Base64 encoding or an UUID identifier.\n• . This is your private key. Keep it secret, don't tell it to anybody. It is used to sign your requests locally before sending them to exchanges. The secret key does not get sent over the internet in the request-response process and should not be published or emailed. It is used together with the nonce to generate a cryptographically strong signature. That signature is sent with your public key to authenticate your identity. Each request has a unique nonce and therefore a unique cryptographic signature.\n• . Some exchanges (not all of them) also generate a user id or uid for short. It can be a string or numeric literal. You should set it, if that is explicitly required by your exchange. See their docs for details.\n• . Some exchanges (not all of them) also require your password/phrase for trading. You should set this string, if that is explicitly required by your exchange. See their docs for details.\n\nIn order to create API keys find the API tab or button in your user settings on the exchange website. Then create your keys and copy-paste them to your config file. Your config file permissions should be set appropriately, unreadable to anyone except the owner.\n\nRemember to keep your apiKey and secret key safe from unauthorized use, do not send or tell it to anybody. A leak of the secret key or a breach in security can cost you a fund loss.\n\nFor checking if the user has supplied all the required credentials the base class has a method called or . Calling that method will throw an , if some of the credentials are missing or empty. The base class also has property that allows a user to see which credentials are required for this or that exchange, as shown below:\n\nTo set up an exchange for trading just assign the API credentials to an existing exchange instance or pass them to exchange constructor upon instantiation, like so:\n\nNote that your private requests will fail with an exception or error if you don't set up your API credentials before you start trading. To avoid character escaping always write your credentials in single quotes, not double quotes ( , ).\n\nWhen you get errors like , then, most likely, the problem is not within ccxt, please avoid opening issues unless you ensure that:\n• You don't have typos, empty spaces, or quotes in your keys\n• Your current IP address (check IPv4 or IPv6) is added into API-KEY's whitelisted IP addresses\n• You have selected the correct options in permissions list for that api-key.\n• You are not accidentally mixing \"testnet\" api-keys or \"testnet\" mode in your script\n• You have checked already reported issues about this error.\n\nSome exchanges required you to sign in prior to calling private methods, which can be done using the method\n\nThe default nonce is defined by the underlying exchange. You can override it with a milliseconds-nonce if you want to make private requests more frequently than once per second! Most exchanges will throttle your requests if you hit their rate limits, read API docs for your exchange carefully!\n\nIn case you need to reset the nonce it is much easier to create another pair of keys for using with private APIs. Creating new keys and setting up a fresh unused keypair in your config is usually enough for that.\n\nIn some cases you are unable to create new keys due to lack of permissions or whatever. If that happens you can still override the nonce. Base market class has the following methods for convenience:\n• : same in milliseconds (ms = 1000 * s, thousandths of a second).\n• : same in microseconds (μs = 1000 * ms, millionths of a second).\n\nThere are exchanges that confuse milliseconds with microseconds in their API docs, let's all forgive them for that, folks. You can use methods listed above to override the nonce value. If you need to use the same keypair from multiple instances simultaneously use closures or a common function to avoid nonce conflicts. In Javascript you can override the nonce by providing a parameter to the exchange constructor or by setting it explicitly on exchange object:\n\nIn Python and PHP you can do the same by subclassing and overriding nonce function of a particular exchange class:\n\nYou can get all the accounts associated with a profile by using the method\n\nThe method will return a structure like shown below:\n\nTypes of account is one of the unified account types or\n\nTo query for balance and get the amount of funds available for trading or funds locked in orders, use the method:\n\nThe and values may be undefined or missing if the underlying exchange does not provide them.\n\nSome exchanges may not return full balance info. Many exchanges do not return balances for your empty or unused accounts. In that case some currencies may be missing in returned balance structure.\n\nMost of the time you can query orders by an id or by a symbol, though not all exchanges offer a full and flexible set of endpoints for querying orders. Some exchanges might not have a method for fetching recently closed orders, the other can lack a method for getting an order by id, etc. The ccxt library will target those cases by making workarounds where possible.\n\nThe list of methods for querying orders consists of the following:\n\nNote that the naming of those methods indicates if the method returns a single order or multiple orders (an array/list of orders). The method requires a mandatory order id argument (a string). Some exchanges also require a symbol to fetch an order by id, where order ids can intersect with various trading pairs. Also, note that all other methods above return an array (a list) of orders. Most of them will require a symbol argument as well, however, some exchanges allow querying with a symbol unspecified (meaning all symbols).\n\nThe library will throw a NotSupported exception if a user calls a method that is not available from the exchange or is not implemented in ccxt.\n\nTo check if any of the above methods are available, look into the property of the exchange:\n\nA typical structure of the property usually contains the following flags corresponding to order API methods for querying orders:\n\nThe meanings of boolean and are obvious. A string value of means that particular method is missing in the exchange API and ccxt will workaround that where possible on the client-side.\n\nThe exchanges' order management APIs differ by design. The user has to understand the purpose of each specific method and how they're combined together into a complete order API:\n• – though not a part of the orders' API, it is closely related, since it provides the history of settled trades.\n• – fetches a list of all orders (either open or closed/canceled).\n\nThe majority of the exchanges will have a way of fetching currently-open orders. Thus, the . If that method is not available, then most likely the that will provide a list of all orders. The exchange will return a list of open orders either from or from . One of the two methods is usually available from any exchange.\n\nSome exchanges will provide the order history, other exchanges will not. If the underlying exchange provides the order history, then the or the . If the underlying exchange does not provide the order history, then and are not available. In the latter case, the user is required to build a local cache of orders and track the open orders using and for order statuses and for marking them as closed locally in the userland (when they're not open anymore).\n\nIf the underlying exchange does not have methods for order history ( and ), then it will provide + the trade history with (see How Orders Are Related To Trades). That set of information is in many cases enough for tracking in a live-trading robot. If there's no order history – you have to track your live orders and restore historical info from open orders and historical trades.\n\nIn general, the underlying exchanges will usually provide one or more of the following types of historical data:\n\nAny of the above three methods may be missing, but the exchanges APIs will usually provide at least one of the three methods.\n\nIf the underlying exchange does not provide historical orders, the CCXT library will not emulate the missing functionality – it has to be added on the user side where necessary.\n\nPlease, note, that a certain method may be missing either because the exchange does not have a corresponding API endpoint, or because CCXT has not implemented it yet (the library is also a work in progress). In the latter case, the missing method will be added as soon as possible.\n\nAll methods returning lists of trades and lists of orders, accept the second argument and the third argument:\n\nThe second argument reduces the array by timestamp, the third argument reduces by number (count) of returned items.\n\nIf the user does not specify , the methods will return the default set of results from the exchange. The default set is exchange-specific, some exchanges will return trades or recent orders starting from the date of listing a pair on the exchange, other exchanges will return a reduced set of trades or orders (like, last 24 hours, last 100 trades, first 100 orders, etc). If the user wants precise control over the timeframe, the user is responsible for specifying the argument.\n\nNOTE: not all exchanges provide means for filtering the lists of trades and orders by starting time, so, the support for and is exchange-specific. However, most exchanges do provide at least some alternative for \"pagination\" and \"scrolling\" which can be overrided with extra argument.\n\nSome exchanges do not have a method for fetching closed orders or all orders. They will offer just the endpoint, and sometimes also a endpoint as well. Those exchanges don't have any methods for fetching the order history. To maintain the order history for those exchanges the user has to store a dictionary or a database of orders in the userland and update the orders in the database after calling methods like , , , .\n\nTo get the details of a particular order by its id, use the / method. Some exchanges also require a symbol even when fetching a particular order by id.\n\nThe signature of the fetchOrder/fetch_order method is as follows:\n\nSome exchanges don't have an endpoint for fetching an order by id, ccxt will emulate it where possible. For now it may still be missing here and there, as this is a work in progress.\n\nYou can pass custom overrided key-values in the additional params argument to supply a specific order type, or some other setting if needed.\n\nBelow are examples of using the fetchOrder method to get order info from an authenticated exchange instance:\n\nSome exchanges don't have an endpoint for fetching all orders, ccxt will emulate it where possible. For now it may still be missing here and there, as this is a work in progress.\n\nDo not confuse closed orders with trades aka fills ! An order can be closed (filled) with multiple opposing trades! So, a closed order is not the same as a trade. In general, the order does not have a at all, but each particular user trade does have , and other properties. However, many exchanges propagate those properties to the orders as well.\n\nSome exchanges don't have an endpoint for fetching closed orders, ccxt will emulate it where possible. For now it may still be missing here and there, as this is a work in progress.\n\nMost of methods returning orders within ccxt unified API will yield an order structure as described below:\n• The of an order is usually either (not filled or partially filled), (fully filled), or (unfilled and canceled, or partially filled then canceled).\n• Some exchanges allow the user to specify an expiration timestamp upon placing a new order. If the order is not filled by that time, its becomes .\n• Use the value to determine if the order is filled, partially filled or fully filled, and by how much.\n• The work on info is still in progress, fee info may be missing partially or entirely, depending on the exchange capabilities.\n• The currency may be different from both traded currencies (for example, an ETH/BTC order with fees in USD).\n• The timestamp may have no value and may be where not supported by the exchange or in case of an open order (an order that has not been filled nor partially filled yet).\n• The , if any, designates the timestamp of the last trade, in case the order is filled fully or partially, otherwise is .\n• Order prevails or has precedence over the .\n• The of an order is:\n• The of an order means the total quote volume of the order (whereas the is the base volume). The value of should be as close to the actual most recent known order cost as possible. The field itself is there mostly for convenience and can be deduced from other fields.\n• The field can be set upon placing orders by the user with custom order params. Using the the user can later distinguish between own orders. This is only available for the exchanges that do support at this time.\n\nThe field may be if not specified by the exchange. The unification of is a work in progress.\n\nPossible values for the field:\n• = Good Till Cancel(ed), the order stays on the orderbook until it is matched or canceled.\n• = Immediate Or Cancel, the order has to be matched immediately and filled either partially or completely, the unfilled remainder is canceled (or the entire order is canceled).\n• = Fill Or Kill, the order has to get fully filled and closed immediately, otherwise the entire order is canceled.\n• = Post Only, the order is either placed as a maker order, or it is canceled. This means the order must be placed on orderbook for at at least time in an unfilled state. The unification of as a option is a work in progress with unified exchanges having .\n\nThere are different types of orders that a user can send to the exchange, regular orders eventually land in the orderbook of a corresponding symbol, others orders may be more advanced. Here is a list outlining various types of orders:\n• Limit Orders – regular orders having an in base currency (how much you want to buy or sell) and a in quote currency (for which price you want to buy or sell).\n• Market Orders – regular orders having an in base currency (how much you want to buy or sell)\n• Market Buys – some exchanges require market buy orders with an in quote currency (how much you want to spend for buying)\n• Trigger Orders – an advanced type of order used to wait for a certain condition on a market and then react automatically: when a is reached, the trigger order gets triggered and then a regular limit or market price order is placed, that eventually results in entering a position or exiting a position\n• Stop Loss Orders – almost the same as trigger orders, but used to close a position to stop further losses on that position: when the price eaches then the stop loss order is triggered that results in placing another regular limit or market order to close a position at a specific limit or at market price (a position with a stop loss order attached to it).\n• Take Profit Orders – a counterpart to stop loss orders, this type of order is used to close a position to take existing profits on that position: when the price reaches then the take profit order is triggered that results in placing another regular limit or market order to close a position at a specific limit or at market price (a position with a take profit order attached to it).\n• StopLoss And TakeProfit Orders Attached To A Position – advanced orders, consisting of three orders of types listed above: a regular limit or market order placed to enter a position with stop loss and/or take profit orders that will be placed upon opening that position and will be used to close that position later (when a stop loss is reached, it will close the position and will cancel its take profit counterpart, and vice versa, when a take profit is reached, it will close the position and will cancel its stop loss counterpart, these two counterparts are also known as \"OCO orders – one cancels the other), apart from the (and for the limit order) to open a position it will also require a for a stop loss order (with a limit if it's a stop loss limit order) and/or a for a take profit order (with a limit if it's a take profit limit order).\n\nPlacing an order always requires a that the user has to specify (which market you want to trade).\n\nTo place an order use the method. You can use the from the returned unified order structure to query the status and the state of the order later.\n• symbol (String) required Unified CCXT market symbol\n• Make sure the symbol in question exists with the target exchange and is available for trading.\n• side required a string literal for the direction of your order. Unified sides:\n• give quote currency and receive base currency; for example, buying means that you will receive bitcoins for your dollars.\n• give base currency and receive quote currency; for example, buying means that you will receive dollars for your bitcoins.\n• type a string literal type of order Unified types:\n• market not allowed by some exchanges, see their docs for details\n• see #custom-order-params and #other-order-types for non-unified types\n• amount, how much of currency you want to trade usually, but not always, in units of the base currency of the trading pair symbol (the units for some exchanges are dependent on the side of the order: see their API docs for details.)\n• price the price at which the order is to be fullfilled at in units of the quote currency (ignored in market orders)\n• Some exchanges will allow to trade with limit orders only.\n\nSome fields from the returned order structure may be if that information is not returned from the exchange API's response. The user is guaranteed that the method will return a unified order structure that will contain at least the order and the (a raw response from the exchange \"as is\"):\n\nLimit orders placed on the order book of the exchange for a price specified by the trader. They are fullfilled(closed) when there are no orders in the same market at a better price, and another trader creates a market order or an opposite order for a price that matches or exceeds the price of the limit order.\n\nLimit orders may not be fully filled. This happens when the filling order is for a smaller amount than the amount specified by the limit order.\n\nalso known as\n\nMarket orders are executed immediately by fulfilling one of more already existing orders from the ask side of the exchanges order book. The orders that your market order fulfills are chosen from th top of the order book stack, meaning your market order is fulfilled at the best price available. When placing a market order you don't need to specify the price of the order, and if the price is specified, it will be ignored.\n\nYou are not guaranteed that the order will be executed for the price you observe prior to placing your order. There are multiple reasons for this, including:\n• price slippage a slight change of the price for the traded market while your order is being executed. Reasons for price slippage include, but are not limited to\n• unequivocal order sizes if a market order is for an amount that is larger than the size of the top order on the order book, then after the top order is filled, the market order will proceed to fill the next order in the order book, which means the market order is filled at multiple prices\n\nNote, that some exchanges will not accept market orders (they allow limit orders only). In order to detect programmatically if the exchange in question does support market orders or not, you can use the exchange property:\n\nIn general, when placing a or order the user has to specify just the amount of the base currency to buy or sell. However, with some exchanges market buy orders implement a different approach to calculating the value of the order.\n\nSuppose you're trading BTC/USD and the current market price for BTC is over 9000 USD. For a market buy or market sell you could specify an of 2 BTC and that would result in plus or minus 18000 USD (more or less ;)) on your account, depending on the side of the order.\n\nWith market buys some exchanges require the total cost of the order in the quote currency! The logic behind it is simple, instead of taking the amount of base currency to buy or sell some exchanges operate with \"how much quote currency you want to spend on buying in total\".\n\nTo place a market buy order with those exchanges you would not specify an amount of 2 BTC, instead you should somehow specify the total cost of the order, that is, 18000 USD in this example. The exchanges that treat orders in this way have an exchange-specific option that allows specifying the total cost of a order in two ways.\n\nThe first is the default and if you specify the along with the the total cost of the order would be calculated inside the lib from those two values with a simple multiplication ( ). The resulting would be the amount in USD quote currency that will be spent on this particular market buy order.\n\nThe second alternative is useful in cases when the user wants to calculate and specify the resulting total cost of the order himself. That can be done by setting the option to to switch it off:\n\nMore about it:\n\nIt is also possible to emulate a order with a order.\n\nWARNING this method can be risky due to high volatility, use it at your own risk and only use it when you know really well what you're doing!\n\nMost of the time a can be emulated with a at a very low price – the exchange will automatically make it a taker order for market price (the price that is currently in your best interest from the ones that are available in the order book). When the exchange detects that you're selling for a very low price it will automatically offer you the best buyer price available from the order book. That is effectively the same as placing a market sell order. Thus market orders can be emulated with limit orders (where missing).\n\nThe opposite is also true – a can be emulated with a for a very high price. Most exchanges will again close your order for best available price, that is, the market price.\n\nHowever, you should never rely on that entirely, ALWAYS test it with a small amount first! You can try that in their web interface first to verify the logic. You can sell the minimal amount at a specified limit price (an affordable amount to lose, just in case) and then check the actual filling price in trade history.\n\nLimit price orders are also known as limit orders. Some exchanges accept limit orders only. Limit orders require a price (rate per unit) to be submitted with the order. The exchange will close limit orders if and only if market price reaches the desired level.\n\nStop orders, are placed onto the order book when the price of the underlying asset reaches the trigger price.\n• They can be used to close positions when a certain profit level is reached, or to mitigate a large loss.\n• They can be stand-alone orders (Trigger, Stop Loss, Take Profit).\n• Or they can be attached to a primary order (Conditional Stop Orders).\n• Stop Orders can be limit or market orders\n\nTraditional \"stop\" order (which you might see across exchanges' websites) is now called \"trigger\" order across CCXT library. Implemented by adding a parameter. They are independent basic trigger orders that can open and close a position.\n• Activated when price of the underlying asset/contract crosses the from any direction\n\nThe same as Trigger Orders, but the direction matters. Implemented by specifying a parameter (for the spot loss triggerPrice).\n\nSuppose you entered a long position (you bought) at 1000 and want to protect yourself from losses from a possible price drop below 700. You would place a stop loss order with triggerPrice at 700. For that stop loss order either you would specify a limit price or it will be executed at market price.\n\nSuppose you entered a short position (you sold) at 700 and want to protect yourself from losses from a possible price pump above 1300. You would place a stop loss order with triggerPrice at 1300. For that stop loss order either you would specify a limit price or it will be executed at market price.\n\nStop Loss orders are activated when the price of the underlying asset/contract:\n• drops below the from above, for sell orders. (eg: to close a long position, and avoid further losses)\n• rises above the from below, for buy orders (eg: to close a short position, and avoid further losses)\n\nThe same as Stop Loss Orders, but the direction matters. Implemented by specifying a parameter (for the take profit triggerPrice).\n\nSuppose you entered a long position (you bought) at 1000 and want to get your profits from a possible price pump above 1300. You would place a take profit order with triggerPrice at 1300. For that take profit order either you would specify a limit price or it will be executed at market price.\n\nSuppose you entered a short position (you sold) at 700 and want to get your profits from a possible price drop below 600. You would place a take profit order with triggerPrice at 600. For that take profit order either you would specify a limit price or it will be executed at market price.\n\nTake Profit orders are activated when the price of the underlying:\n• rises above the from below, for sell orders (eg: to close a long position, at a profit)\n• drops below the from above, for buy orders (eg: to close a short position, at a profit)\n\nTake Profit / Stop Loss Orders which are tied to a position-opening primary order. Implemented by supplying a dictionary parameters for and describing each respectively.\n• By default stopLoss and takeProfit orders will be the same magnitude as primary order but in the opposite direction.\n• Attached stop orders are conditional on the primary order being executed.\n• Not supported by all exchanges.\n• Both and or either can be supplied, this depends on exchange.\n\nNote: This is still under unification and is work in progress\n\nSome exchanges allow you to specify optional parameters for your order. You can pass your optional parameters and override your query with an associative array using the argument to your unified API call. All custom params are exchange-specific, of course, and aren't interchangeable, do not expect those custom params for one exchange to work with another exchange.\n\nThe user can specify a custom field can be set upon placing orders with the . Using the one can later distinguish between own orders. This is only available for the exchanges that do support at this time. For the exchanges that don't support it will either throw an error upon supplying the or will ignore it setting the to .\n\nTo edit an order, you can use the method\n• side (String) required the direction of your order. Unified sides:\n• give quote currency and receive base currency; for example, buying means that you will receive bitcoins for your dollars.\n• give base currency and receive quote currency; for example, buying means that you will receive dollars for your bitcoins.\n• type (String) required type of order Unified types:\n• not allowed by some exchanges, see their docs for details\n• see #custom-order-params and #other-order-types for non-unified types\n• amount (Number) required how much of currency you want to trade usually, but not always, in units of the base currency of the trading pair symbol (the units for some exchanges are dependent on the side of the order: see their API docs for details.)\n• price (Float) the price at which the order is to be fullfilled at in units of the quote currency (ignored in market orders)\n\nTo cancel an existing order use\n\nThe is usually used on open orders only. However, it may happen that your order gets executed (filled and closed) before your cancel-request comes in, so a cancel-request might hit an already-closed order.\n\nA cancel-request might also throw a indicating that the order might or might not have been canceled successfully and whether you need to retry or not. Consecutive calls to may hit an already canceled order as well.\n\nAs such, can throw an exception in these cases:\n\nA trade is also often called . Each trade is a result of order execution. Note, that orders and trades have a one-to-many relationship: an execution of one order may result in several trades. However, when one order matches another opposing order, the pair of two matching orders yields one trade. Thus, when an order matches multiple opposing orders, this yields multiple trades, one trade per each pair of matched orders.\n\nTo put it shortly, an order can contain one or more trades. Or, in other words, an order can be filled with one or more trades.\n\nFor example, an orderbook can have the following orders (whatever trading symbol or pair it is):\n\nAll specific numbers above aren't real, this is just to illustrate the way orders and trades are related in general.\n\nA seller decides to place a sell limit order on the ask side for a price of 0.700 and an amount of 150.\n\nAs the price and amount of the incoming sell (ask) order cover more than one bid order (orders and ), the following sequence of events usually happens within an exchange engine very quickly, but not immediately:\n• Order is matched against the incoming sell because their prices intersect. Their volumes \"mutually annihilate\" each other, so, the bidder gets 100 for a price of 0.800. The seller (asker) will have their sell order partially filled by bid volume 100 for a price of 0.800. Note that for the filled part of the order the seller gets a better price than he asked for initially. He asked for 0.7 at least but got 0.8 instead which is even better for the seller. Most conventional exchanges fill orders for the best price available.\n• A trade is generated for the order against the incoming sell order. That trade \"fills\" the entire order and most of the sell order. One trade is generated per each pair of matched orders, whether the amount was filled completely or partially. In this example the seller amount (100) fills order completely (closes the order ) and also fills the selling order partially (leaves it open in the orderbook).\n• Order now has a status of and a filled volume of 100. It contains one trade against the selling order. The selling order has an status and a filled volume of 100. It contains one trade against order . Thus each order has just one fill-trade so far.\n• The incoming sell order has a filled amount of 100 and has yet to fill the remaining amount of 50 from its initial amount of 150 in total.\n\nThe intermediate state of the orderbook is now (order is and is not in the orderbook anymore):\n• Order is matched against the remaining part of incoming sell, because their prices intersect. The amount of buying order which is 200 completely annihilates the remaining sell amount of 50. The order is filled partially by 50, but the rest of its volume, namely the remaining amount of 150 will stay in the orderbook. The selling order, however, is fulfilled completely by this second match.\n• A trade is generated for the order against the incoming sell order. That trade partially fills order . And completes the filling of the sell order. Again, this is just one trade for a pair of matched orders.\n• Order now has a status of , a filled amount of 50, and a remaining amount of 150. It contains one filling trade against the selling order. The selling order has a status now and it has completely filled its total initial amount of 150. However, it contains two trades, the first against order and the second against order . Thus each order can have one or more filling trades, depending on how their volumes were matched by the exchange engine.\n\nAfter the above sequence takes place, the updated orderbook will look like this.\n\nNotice that the order has disappeared, the selling order also isn't there. All closed and fully-filled orders disappear from the orderbook. The order which was filled partially and still has a remaining volume and an status, is still there.\n\nMost of unified methods will return either a single object or a plain array (a list) of objects (trades). However, very few exchanges (if any at all) will return all trades at once. Most often their APIs output to a certain number of most recent objects. YOU CANNOT GET ALL OBJECTS SINCE THE BEGINNING OF TIME TO THE PRESENT MOMENT IN JUST ONE CALL. Practically, very few exchanges will tolerate or allow that.\n\nAs with all other unified methods for fetching historical data, the method accepts a argument for date-based pagination. Just like with all other unified methods throughout the CCXT library, the argument for must be an integer timestamp in milliseconds.\n\nTo fetch historical trades, the user will need to traverse the data in portions or \"pages\" of objects. Pagination often implies \"fetching portions of data one by one\" in a loop.\n\nIn many cases a argument is required by the exchanges' APIs, therefore you have to loop over all symbols to get all your trades. If the is missing and the exchange requires it then CCXT will throw an exception to signal the requirement to the user. And then the has to be specified. One of the approaches is to filter the relevant symbols from the list of all symbols by looking at non-zero balances as well as transactions (withdrawals and deposits). Also, the exchanges will have a limit on how far back in time you can go.\n\nIn most cases users are required to use at least some type of pagination in order to get the expected results consistently.\n\nReturns ordered array of trades (most recent trade last).\n• The work on and info is still in progress, fee info may be missing partially or entirely, depending on the exchange capabilities.\n• The currency may be different from both traded currencies (for example, an ETH/BTC order with fees in USD).\n• The of the trade means . It is the total quote volume of the trade (whereas is the base volume). The cost field itself is there mostly for convenience and can be deduced from other fields.\n• The of the trade is a \"gross\" value. That is the value pre-fee, and the fee has to be applied afterwards.\n\nThe ledger is simply the history of changes, actions done by the user or operations that altered the user's balance in any way, that is, the history of movements of all funds from/to all accounts of the user which includes\n• amounts incoming and outcoming in result of a trade or an order\n• rebates, cashbacks and other types of events that are subject to accounting.\n\nData on ledger entries can be retrieved using\n• for multiple ledger entries of the same currency\n• code (String) Unified CCXT currency code; required if fetching all ledger entries for all assets at once is not supported (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve withdrawals for (e.g. )\n• limit (Integer) The number of ledger entry structures to retrieve (e.g. )\n\nThe type of the ledger entry is the type of the operation associated with it. If the amount comes due to a sell order, then it is associated with a corresponding trade type ledger entry, and the referenceId will contain associated trade id (if the exchange in question provides it). If the amount comes out due to a withdrawal, then is is associated with a corresponding transaction.\n\nThe field holds the id of the corresponding event that was registered by adding a new item to the ledger.\n\nThe field is there to support for exchanges that include pending and canceled changes in the ledger. The ledger naturally represents the actual changes that have taken place, therefore the status is in most cases.\n\nThe ledger entry type can be associated with a regular trade or a funding transaction (deposit or withdrawal) or an internal between two accounts of the same user. If the ledger entry is associated with an internal transfer, the field will contain the id of the account that is being altered with the ledger entry in question. The field will contain the id of the opposite account the funds are transferred to/from, depending on the ( or ).\n\nIn order to deposit funds to an exchange you must get an address from the exchange for the currency you want to deposit there. Most of exchanges will create and manage those addresses for the user.\n\nData on deposits made to an account can be retrieved using\n• for multiple deposits of the same currency\n• for all deposits to an account\n• since (Integer) Timestamp (ms) of the earliest time to retrieve deposits for (e.g. )\n• limit (Integer) The number of transaction structures to retrieve (e.g. )\n\nThe method can be used to withdraw funds from an account\n\nSome exchanges require a manual approval of each withdrawal by means of 2FA (2-factor authentication). In order to approve your withdrawal you usually have to either click their secret link in your email inbox or enter a Google Authenticator code or an Authy code on their website to verify that withdrawal transaction was requested intentionally.\n\nIn some cases you can also use the withdrawal id to check withdrawal status later (whether it succeeded or not) and to submit 2FA confirmation codes, where this is supported by the exchange. See their docs for details.\n• amount (Float) required The amount of currency to withdraw (e.g. )\n• address (String) required The recipient address of the withdrawal (e.g. )\n\nData on withdrawals made to an account can be retrieved using\n• for multiple withdrawals of the same currency\n• for all withdrawals from an account\n• since (Integer) Timestamp (ms) of the earliest time to retrieve withdrawals for (e.g. )\n• limit (Integer) The number of transaction structures to retrieve (e.g. )\n\nIt is also possible to pass the parameters as the fourth argument with or without a specified tag\n\nThe following aliases of allow for withdrawing crypto on multiple chains\n\nYou may set the value of in order to withdraw USDT on the TRON chain, or 'BSC' to withdraw USDT on Binance Smart Chain. In the table above BSC and BEP20 are equivalent aliases, so it doesn't matter which one you use as they both will achieve the same effect.\n• or may be , if the exchange in question does not specify all sides of the transaction\n• The semantics of the field is exchange-specific. In some cases it can contain the address of the sender, in other cases it may contain the address of the receiver. The actual value depends on the exchange.\n• The field is the UTC timestamp in milliseconds of the most recent change of status of that funding operation, be it or . It is necessary if you want to track your changes in time, beyond a static snapshot. For example, if the exchange in question reports and for a transaction, then the field will take the value of , that is, the timestamp of the most recent change of the status.\n• The field may be in certain exchange-specific cases.\n• The substructure may be missing, if not supplied within the reply coming from the exchange.\n• The field may be , otherwise it will contain a message or note defined by the user upon creating the transaction.\n• Be careful when handling the and the . The is NOT an arbitrary user-defined string of your choice! You cannot send user messages and comments in the . The purpose of the field is to address your wallet properly, so it must be correct. You should only use the received from the exchange you're working with, otherwise your transaction might never arrive to its destination.\n\nThe address for depositing can be either an already existing address that was created previously with the exchange or it can be created upon request. In order to see which of the two methods are supported, check the and properties.\n\nSome exchanges may also have a method for fetching multiple deposit addresses at once or all of them at once.\n• code ([String]) Array of unified CCXT currency codes. May or may not be required depending on the exchange (e.g. )\n\nThe address structures returned from , , and look like this:\n\nWith certain currencies, like AEON, BTS, GXS, NXT, SBD, STEEM, STR, XEM, XLM, XMR, XRP, an additional argument is usually required by exchanges. Other currencies will have the set to . The tag is a memo or a message or a payment id that is attached to a withdrawal transaction. The tag is mandatory for those currencies and it identifies the recipient user account.\n\nBe careful when specifying the and the . The is NOT an arbitrary user-defined string of your choice! You cannot send user messages and comments in the . The purpose of the field is to address your wallet properly, so it must be correct. You should only use the received from the exchange you're working with, otherwise your transaction might never arrive to its destination.\n\nThe field is relatively new, it may be or missing entirely in certain cases (with some exchanges), but will be added everywhere eventually. It is still in the process of unification.\n\nThe method makes internal transfers of funds between accounts on the same exchange. This can include subaccounts or accounts of different types ( , , , ...). If an exchange is separated on CCXT into a spot and futures class (e.g. , , ...), then the method may be available to transfer funds into the futures account, and the method may be available to transfer funds out of the futures account\n• amount (Float) The amount of currency to transfer (e.g. )\n• fromAccount (String) The account to transfer funds from.\n• toAccount (String) The account to transfer funds to.\n• params.symbol (String) Market symbol when transfering to or from a margin account (e.g. )\n\nand can accept the exchange account id or one of the following unified values:\n• for some exchanges and are the same account\n• for some exchanges that allow for subaccounts\n\nYou can retrieve all the account types by selecting the keys from `exchange.options['accountsByType']\n\nSome exchanges allow transfers to email addresses, phone numbers or to other users by user id.\n• amount (Float) The amount of currency to transfer (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve transfers for (e.g. )\n• limit (Integer) The number of transfer structures to retrieve (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve transfers for (e.g. )\n• limit (Integer) The number of transfer structures to retrieve (e.g. )\n\nThis section of the Unified CCXT API is under development.\n\nFees are often grouped into two categories:\n• Trading fees. Trading fee is the amount payable to the exchange, usually a percentage of volume traded (filled).\n• Transaction fees. The amount payable to the exchange upon depositing and withdrawing as well as the underlying crypto transaction fees (tx fees).\n\nBecause the fee structure can depend on the actual volume of currencies traded by the user, the fees can be account-specific. Methods to work with account-specific fees:\n\nThe fee methods will return a unified fee structure, which is often present with orders and trades as well. The fee structure is a common format for representing the fee info throughout the library. Fee structures are usually indexed by market or currency.\n\nBecause this is still a work in progress, some or all of methods and info described in this section may be missing with this or that exchange.\n\nDO NOT use the property of the exchange instance as most often it contains the predefined/hardcoded info. Actual fees should only be accessed from markets and currencies.\n\nNOTE: Previously we used fetchTransactionFee(s) to fetch the transaction fees, which are now DEPRECATED and these functions have been replace by fetchDepositWithdrawFee(s)\n\nYou call / to fetch the trading fees, / to fetch the deposit & withdraw fees.\n\nOrders, private trades, transactions and ledger entries may define the following info in their field:\n\nTrading fees are properties of markets. Most often trading fees are loaded into the markets by the call. Sometimes, however, the exchanges serve fees from different endpoints.\n\nThe method can be used to precalculate trading fees that will be paid. WARNING! This method is experimental, unstable and may produce incorrect results in certain cases. You should only use it with caution. Actual fees may be different from the values returned from , this is just for precalculation. Do not rely on precalculated values, because market conditions change frequently. It is difficult to know in advance whether your order will be a market taker or maker.\n\nThe method will return a unified fee structure with precalculated fees for an order with specified params.\n\nAccessing trading fee rates should be done via the property, like so:\n\nThe markets stored under the property may contain additional fee related information:\n\nWARNING! fee related information is experimental, unstable and may only be partial available or not at all.\n\nMaker fees are paid when you provide liquidity to the exchange i.e. you market-make an order and someone else fills it. Maker fees are usually lower than taker fees. Similarly, taker fees are paid when you take liquidity from the exchange and fill someone else's order.\n\nFees can be negative, this is very common amongst derivative exchanges. A negative fee means the exchange will pay a rebate (reward) to the user for the trading.\n\nAlso, some exchanges might not specify fees as percentage of volume, check the field of the market to be sure.\n\nSome exchanges have an endpoint for fetching the trading fee schedule, this is mapped to the unified methods , and\n\nAccessing transaction fee rates should be done via the property. This aspect is not unified yet and is subject to change.\n\nSome exchanges have an endpoint for fetching the transaction fee schedule, this is mapped to the unified methods\n\nTo trade with leverage in spot or margin markets, currency must be borrowed as a loan. This borrowed currency must be payed back with interest. To obtain the amount of interest that has accrued you can use the method\n• code (String) The unified currency code for the currency of the interest (e.g. )\n• symbol (String) The market symbol of an isolated margin market, if undefined, the interest for cross margin markets is returned (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to receive interest records for (e.g. )\n• limit (Integer) The number of borrow interest structures to retrieve (e.g. )\n\nTo borrow and repay currency as a margin loan use and .\n• code (String) required The unified currency code for the currency to be borrowed or repaid (e.g. )\n• amount (Float) required The amount of margin to borrow or repay (e.g. )\n• symbol (String) The unified CCXT market symbol of an isolated margin market (e.g. )\n\nTo increase, reduce or set your margin balance (collateral) in an open leveraged position, use , and respectively. This is kind of like adjusting the amount of leverage you're using with a position that's already open.\n\nSome scenarios to use these methods include\n• if the trade is going against you, you can add margin to, reducing the risk of liquidation\n• if your trade is going well you can reduce your position's margin balance and take profits\n• amount (String) required Amount of margin to add or reduce (e.g. )\n\nUpdates the type of margin used to be either\n• One account is used to share collateral between markets. Margin is taken from total account balance to avoid liquidation when needed.\n• Each market, keeps collateral in a separate account\n• marginMode (String) required the type of margin used Unified margin types:\n• symbol (String) Unified CCXT market symbol (e.g. ) required on most exchanges. Is not required when the margin mode is not specific to a market\n\nCommon reasons for why an exchange might have\n• the exchange does not offer leveraged trading\n• the exchange only offers one of or margin modes, but does not offer both\n• margin mode must be set using an exchange specific parameter within when using\n\nSome exchange apis return an error response when a request is sent to set the margin mode to the mode that it is already set to (e.g. Sending a request to set the margin mode to for the market when the account already has set to use cross margin). CCXT doesn't see this as an error because the end result is what the user wanted, so the error is suppressed and the error result is returned as an object.\n• symbol (String) Unified CCXT market symbol (e.g. ) required on most exchanges. Is not required when leverage is not specific to a market (e.g. If leverage is set for the account and not per market)\n\nThis can include futures with a set expiry date, perpetual swaps with funding payments, and inverse futures or swaps. Information about the positions can be served from different endpoints depending on the exchange. In the case that there are multiple endpoints serving different types of derivatives CCXT will default to just loading the \"linear\" (as oppose to the \"inverse\") contracts or the \"swap\" (as opposed to the \"future\") contracts.\n\nTo get information about positions currently held in contract markets, use\n• symbols ([String]) Unified CCXT market symbols, do not set to retrieve all positions (e.g. )\n\nPositions allow you to borrow money from an exchange to go long or short on an market. Some exchanges require you to pay a funding fee to keep the position open.\n\nWhen you go long on a position you are betting that the price will be higher in the future and that the price will never be less than the .\n\nAs the price of the underlying index changes so does the unrealisedPnl and as a consequence the amount of collateral you have left in the position (since you can only close it at market price or worse). At some price you will have zero collateral left, this is called the \"bust\" or \"zero\" price. Beyond this point, if the price goes in the opposite direction far enough, the collateral of the position will drop below the . The maintenanceMargin acts as a safety buffer between your position and negative collateral, a scenario where the exchange incurs losses on your behalf. To protect itself the exchange will swiftly liquidate your position if and when this happens. Even if the price returns back above the liquidationPrice you will not get your money back since the exchange sold all the you bought at market. In other words the maintenanceMargin is a hidden fee to borrow money.\n\nIt is recommended to use the and instead of the and since these tend to be more accurate. The maintenanceMargin might be calculated from other factors outside of the maintenanceMarginPercentage including the funding rate and taker fees, for example on kucoin.\n\nAn inverse contract will allow you to go long or short on BTC/USD by putting up BTC as collateral. Our API for inverse contracts is the same as for linear contracts. The amounts in an inverse contracts are quoted as if they were traded USD/BTC, however the price is still quoted terms of BTC/USD. The formula for the profit and loss of a inverse contract is . The profit and loss and collateral will now be quoted in BTC, and the number of contracts are quoted in USD.\n\nIt is the price at which the . The price has gone in the opposite direction of your position to the point where the is only maintenanceMargin collateral left and if it goes any further the position will have negative collateral.\n\nPerpetual swap (also known as perpetual future) contracts maintain a market price that mirrors the price of the asset they are based on because funding fees are exchanged between traders who hold positions in perpetual swap markets.\n\nIf the contract is being traded at a price that is higher than the price of the asset they represent, then traders in long positions pay a funding fee to traders in short positions at specific times of day, which encourages more traders to enter short positions prior to these times.\n\nIf the contract is being traded at a price that is lower than the price of the asset they represent, then traders in short positions pay a funding fee to traders in long positions at specific times of day, which encourages more traders to enter long positions prior to these times.\n\nThese fees are usually exchanged between traders with no commission going to the exchange\n\nThe method can be used to retrieve an accounts history of funding fees paid or received\n• since (Integer) Timestamp (ms) of the earliest time to retrieve funding history for (e.g. )\n• limit (Integer) The number of funding history structures to retrieve (e.g. )\n\nIn some specific cases you may want a proxy, when:\n• Exchange is not available in your location\n• Your IP is forbidden by exchange\n• You experience random restriction by exchange, like DDoS protection by Cloudflare\n\nHowever, beware that each added intermediary might add some latency to requests.\n\nThis property prepends an url to API requests. This can also be used to setup a CORS proxy.\n\nwhile 'YOUR_PROXY_URL' could be like (note the backslash):\n\nSo requests will be made to . You can test if that works by:\n\nYou can also have a small proxy script running on your device/webserver to use it in .proxyUrl`. See a sample script named \"sample-local-proxy-server\" in examples folder.\n\nIf you have an access to a remote http or https proxy, you can set:\n\nYou can also use socks proxy with the following format:\n\n**Note, in addition to above properties, you can also set callbacks instead of strings to any from . The callback signature should be like:\n\nIf you need for special cases, you can override property like:\n\nDepending your programming language, you can set custom proxy agents.\n• For JS, see this example\n• For Python, see the following examples: proxies-for-synchronous-python, proxy-asyncio-aiohttp-python-3, proxy-asyncio-aiohttp-socks, proxy-sync-python-requests-2-and-3\n\nCORS (known as Cross-Origin Resource Sharing) affects mostly browsers and is the cause of the well-know warning No 'Access-Control-Allow-Origin' header is present on the requested resource . It happens because a script (running in a browser) might be trying to make a request data from another domain but that domain does not allow such connection (by default that feature are disabled by domains, unless they specially enable it). So, in such cases you will need to communicate a \"CORS\" proxy, which would redirect requests (as opposed to direct browser-side request) to the target exchange. To set a CORS proxy, refer to paragraph to find out how to route requests through cors/proxy server.\n\nThe error handling with CCXT is done with the exception mechanism that is natively available with all languages.\n\nTo handle the errors you should add a block around the call to a unified method and catch the exceptions like you would normally do with your language:\n\nAll exceptions are derived from the base BaseError exception, which, in its turn, is defined in the ccxt library like so:\n\nBelow is an outline of exception inheritance hierarchy:\n\nThe class is a generic error class for all sorts of errors, including accessibility and request/response mismatch. Users should catch this exception at the very least, if no error differentiation is required.\n\nThere's two generic families of special cases or subtrees in the error hierarchy, both derived from :\n\nA is a non-critical non-breaking error, not really an error in a full sense, but more like a temporary unavailability situation, that could be caused by any condition or by any factor, including maintenance, DDoS protections, and temporary bans. The reason for having a big family of is to group all exceptions that can reappear or disappear upon a later retry or upon a retry from a different location, all the rest being equal (with the same user input, put simply, same order price and amount, same symbol, etc...).\n\nIn contrast, the is a critical error indeed, and it differs from the in a very specific way – if you get an with your input, then you should always get the same with that same input.\n\nThe distinction between the two families of exceptions is such that one family is recoverable and the other family is unrecoverable. means you can retry later and it can magically go away by itself, so a subsequent retry may succeed and the user may be able to recover from a just by waiting. An is a fatal error, so, it means, something went bad and it will go bad every time, unless you change the input.\n\nThis exception is thrown when an exchange server replies with an error in JSON. Possible reasons:\n• endpoint is switched off by the exchange\n• symbol not found on the exchange\n• the format of parameters is incorrect\n• an exchange replies with an unclear answer\n• : This exception is raised if the endpoint is not offered/not supported by the exchange API.\n• : Raised when an exchange requires one of the API credentials that you've missed to specify, or when there's a mistake in the keypair or an outdated nonce. Most of the time you need and , sometimes you also need and/or .\n• : Raised when there's no access for specified action or insufficient permissions on the specified .\n• : This exception is raised when you don't have enough currency on your account balance to place an order.\n• : This exception is raised upon encountering a bad funding address or a funding address shorter than (10 characters by default) in a call to , or .\n• : This exception is the base class for all exceptions related to the unified order API.\n• : Raised when you are trying to fetch or cancel a non-existent order.\n\nAll errors related to networking are usually recoverable, meaning that networking problems, traffic congestion, unavailability is usually time-dependent. Making a retry later is usually enough to recover from a NetworkError, but if it doesn't go away, then it may indicate some persistent problem with the exchange or with your connection.\n\nThis exception is thrown in either of two cases:\n• when Cloudflare or Incapsula rate limiter restrictions are enforced per user or region/location\n• when the exchange restricts user access for requesting the endpoints in question too frequently\n\nThis exception is raised when the connection with the exchange fails or data is not fully received in a specified amount of time. This is controlled by the option. When a is raised, the user doesn't know the outcome of a request (whether it was accepted by the exchange server or not).\n\nThus it's advised to handle this type of exception in the following manner:\n• for fetching requests it is safe to retry the call\n• for a request to a user is required to retry the same call the second time. A subsequent retry to will return one of the following possible results:\n• a request is completed successfully, meaning the order has been properly canceled now\n• an exception is raised, which means the order was either already canceled on the first attempt or has been executed (filled and closed) in the meantime between the two attempts.\n• if a request to fails with a the user should:\n• call , , to check if the request to place the order has succeeded and the order is now open\n• if the order is not the user should to check if the balance has changed since the order was created on the first run and then was filled and closed by the time of the second check.\n\nThis type of exception is thrown when the underlying exchange is unreachable.\n\nThe ccxt library also throws this error if it detects any of the following keywords in response:\n\nRaised when your nonce is less than the previous nonce used with your keypair, as described in the Authentication section. This type of exception is thrown in these cases (in order of precedence for checking):\n• You are not rate-limiting your requests or sending too many of them too often.\n• Your API keys are not fresh and new (have been used with some different software or script already, just always create a new keypair when you add this or that exchange).\n• The same keypair is shared across multiple instances of the exchange class (for example, in a multithreaded environment or in separate processes).\n• Your system clock is out of synch. System time should be synched with UTC in a non-DST timezone at a rate of once every ten minutes or even more frequently because of the clock drifting. Enabling time synch in Windows is usually not enough! You have to set it up with the OS Registry (Google \"time synch frequency\" for your OS).\n\nIn case you experience any difficulty connecting to a particular exchange, do the following in order of precedence:\n• Make sure that you have the most recent version of ccxt. Never trust your package installer (whether it is , or ), instead always check your actual (real) runtime version number by running this code in your environment:\n• Make sure you have rate-limiter enabled with (either the built-in rate-limiter or your own custom rate-limiter).\n• Turn to get more detail about it! Your code to reproduce the issue + verbose output is required in order to get help.\n• Python people can turn on DEBUG logging level with a standard pythonic logger, by adding these two lines to the beginning of their code:\n• Use verbose mode to make sure that the used API credentials correspond to the keys you intend to use. Make sure there's no confusion of keypairs.\n• Try a fresh new keypair if possible.\n• Check the permissions on the keypair with the exchange website!\n• Check your nonce. If you used your API keys with other software, you most likely should override your nonce function to match your previous nonce value. A nonce usually can be easily reset by generating a new unused keypair. If you are getting nonce errors with an existing key, try with a new API key that hasn't been used yet.\n• Check your request rate if you are getting nonce errors. Your private requests should not follow one another quickly. You should not send them one after another in a split second or in short time. The exchange will most likely ban you if you don't make a delay before sending each new request. In other words, you should not hit their rate limit by sending unlimited private requests too frequently. Add a delay to your subsequent requests or enable the built-in rate-limiter, like shown in the long-poller examples, also here.\n• Read the docs for your exchange and compare your verbose output to the docs.\n• Check your connectivity with the exchange by accessing it with your browser.\n• Check your connection with the exchange through a proxy.\n• Try accesing the exchange from a different computer or a remote server, to see if this is a local or global issue with the exchange.\n• Check if there were any news from the exchange recently regarding downtime for maintenance. Some exchanges go offline for updates regularly (like once a week).\n• Make sure that your system time in sync with the rest of the world's clocks since otherwise you may get invalid nonce errors.\n• Use the option or instantiate your troublesome exchange with to see the HTTP requests and responses in details. The verbose output will also be of use for us to debug it if you submit an issue on GitHub.\n• Some exchanges are not available in certain countries, using a proxy might be the solution in such cases.\n• If you are getting authentication errors or 'invalid keys' errors, those are most likely due to a nonce issue.\n• Some exchanges do not state it clearly if they fail to authenticate your request. In those circumstances they might respond with an exotic error code, like HTTP 502 Bad Gateway Error or something that's even less related to the actual cause of the error."
    },
    {
        "link": "https://stackoverflow.com/questions/59326406/how-to-make-a-binance-futures-order-with-ccxt-in-python",
        "document": "How can I place a market order in ccxt for binance futures? Trading on binance futures with ccxt is already implemented\n\nIn this post they suggest to use this line of code:\n\nThe above line was written in JavaScript. How would the equivalent line in python look like? Like this I get an error:"
    },
    {
        "link": "https://docs.ccxt.com",
        "document": ""
    },
    {
        "link": "https://github.com/ccxt/ccxt/wiki/manual",
        "document": "The ccxt library is a collection of available crypto exchanges or exchange classes. Each class implements the public and private API for a particular crypto exchange. All exchanges are derived from the base Exchange class and share a set of common methods. To access a particular exchange from ccxt library you need to create an instance of corresponding exchange class. Supported exchanges are updated frequently and new exchanges are added regularly.\n\nThe structure of the library can be outlined as follows:\n\nFull public and private HTTP REST APIs for all exchanges are implemented. WebSocket implementations in JavaScript, PHP, Python are available in CCXT Pro, which is a professional addon to CCXT with support for WebSocket streams.\n\nThe CCXT library currently supports the following 106 cryptocurrency exchange markets and trading APIs:\n\nBesides making basic market and limit orders, some exchanges offer margin trading (leverage), various derivatives (like futures contracts and options) and also have dark pools, OTC (over-the-counter trading), merchant APIs and much more.\n\nTo connect to an exchange and start trading you need to instantiate an exchange class from ccxt library.\n\nTo get the full list of ids of supported exchanges programmatically:\n\nAn exchange can be instantiated like shown in the examples below:\n\nThe ccxt library in PHP uses builtin UTC/GMT time functions, therefore you are required to set date.timezone in your php.ini or call date_default_timezone_set() function before using the PHP version of the library. The recommended timezone setting is .\n\nMajor exchanges have the property available, where you can see what methods and functionalities are supported for each market-type (if any method is set to it means method is \"not supported\" by the exchange)\n\nthis feature is currently a work in progress and might be incomplete, feel free to report any issues you find in it\n\nMost of exchange properties as well as specific options can be overrided upon exchange class instantiation or afterwards, like shown below:\n\nIn all CCXT-supported languages, you can override instance methods during runtime:\n\nSome exchanges also offer separate APIs for testing purposes that allows developers to trade virtual money for free and test out their ideas. Those APIs are called \"testnets\", \"sandboxes\" or \"staging environments\" (with virtual testing assets) as opposed to \"mainnets\" and \"production environments\" (with real assets). Most often a sandboxed API is a clone of a production API, so, it's literally the same API, except for the URL to the exchange server.\n\nCCXT unifies that aspect and allows the user to switch to the exchange's sandbox (if supported by the underlying exchange). To switch to the sandbox one has to call the or immediately after creating the exchange before any other call!\n• The has to be your first call immediately after creating the exchange (before any other calls)\n• To obtain the API keys to the sandbox the user has to register with the sandbox website of the exchange in question and create a sandbox keypair\n• Sandbox keys are not interchangeable with production keys!\n\nEvery exchange has a set of properties and methods, most of which you can override by passing an associative array of params to an exchange constructor. You can also make a subclass and override everything.\n\nHere's an overview of generic exchange properties with values added for example:\n\nBelow is a detailed description of each of the base exchange properties:\n• : Each exchange has a default id. The id is not used for anything, it's a string literal for user-land exchange instance identification purposes. You can have multiple links to the same exchange and differentiate them by ids. Default ids are all lowercase and correspond to exchange names.\n• : This is a string literal containing the human-readable exchange name.\n• : An array of string literals of 2-symbol ISO country codes, where the exchange is operating from.\n• : The single string literal base URL for API calls or an associative array of separate URLs for private and public APIs.\n• : A single string URL link to original documentation for exchange API on their website or an array of links to docs.\n• : A string literal containing version identifier for current exchange API. The ccxt library will append this version string to the API Base URL upon each request. You don't have to modify it, unless you are implementing a new exchange API. The version identifier is a usually a numeric string starting with a letter 'v' in some cases, like v1.1. Do not override it unless you are implementing your own new crypto exchange class.\n• : An associative array containing a definition of all API endpoints exposed by a crypto exchange. The API definition is used by ccxt to automatically construct callable instance methods for each available endpoint.\n• : This is an associative array of exchange capabilities (e.g , or ).\n• : An associative array of timeframes, supported by the fetchOHLCV method of the exchange. This is only populated when property is true.\n• : A timeout in milliseconds for a request-response roundtrip (default timeout is 10000 ms = 10 seconds). If the response is not received in that time, the library will throw an exception. You can leave the default timeout value or set it to a reasonable value. Hanging forever with no timeout is not your option, for sure. You don't have to override this option in general case.\n• : A request rate limit in milliseconds. Specifies the required minimal delay between two consequent HTTP requests to the same exchange. The built-in rate-limiter is enabled by default and can be turned off by setting the property to false.\n• : A boolean (true/false) value that enables the built-in rate limiter and throttles consecutive requests. This setting is (enabled) by default. The user is required to implement own rate limiting or leave the built-in rate limiter enabled to avoid being banned from the exchange.\n• : An object to set HTTP User-Agent header to. The ccxt library will set its User-Agent by default. Some exchanges may not like it. If you are having difficulties getting a reply from an exchange and want to turn User-Agent off or use the default one, set this value to false, undefined, or an empty string. The value of may be overrided by HTTP property below.\n• : An associative array of HTTP headers and their values. Default value is empty . All headers will be prepended to all requests. If the header is set within , it will override whatever value is set in the property above.\n• : A boolean flag indicating whether to log HTTP requests to stdout (verbose flag is false by default). Python people have an alternative way of DEBUG logging with a standard pythonic logger, which is enabled by adding these two lines to the beginning of their code:\n• : An associative array of markets indexed by common trading pairs or symbols. Markets should be loaded prior to accessing this property. Markets are unavailable until you call the method on exchange instance.\n• : A non-associative array (a list) of symbols available with an exchange, sorted in alphabetical order. These are the keys of the property. Symbols are loaded and reloaded from markets. This property is a convenient shorthand for all market keys.\n• : An associative array (a dict) of currencies by codes (usually 3 or 4 letters) available with an exchange. Currencies are loaded and reloaded from markets.\n• : An associative array of arrays of markets indexed by exchange-specific ids. Typically a length one array unless there are multiple markets with the same marketId. Markets should be loaded prior to accessing this property.\n• : This is your public API key string literal. Most exchanges require API keys setup.\n• : Your private secret API key string literal. Most exchanges require this as well together with the apiKey.\n• : A string literal with your password/phrase. Some exchanges require this parameter for trading, but most of them don't.\n• : A unique id of your account. This can be a string literal or a number. Some exchanges also require this for trading, but most of them don't.\n• : A unified associative dictionary that shows which of the above API credentials are required for sending private API calls to the underlying exchange (an exchange may require a specific set of keys).\n• : An exchange-specific associative dictionary containing special keys and options that are accepted by the underlying exchange and supported in CCXT.\n• : The exchange decimal precision counting mode, read more about Precision And Limits\n• For proxies - , , , , , , : An url of specific proxy. Read details in Proxy section.\n\nSee this section on Overriding exchange properties.\n• : An assoc-array containing flags for exchange capabilities, including the following: : : // has Cross-Origin Resource Sharing enabled (works from browser) or not // unified methods availability flags (can be true, false, or 'emulated'): : : : : : : : : : : : : : : : : : : : : : : : ... The meaning of each flag showing availability of this or that method is:\n• a value of / / means the method is not currently implemented in ccxt (either ccxt has not unified it yet or the method isn't natively available from the exchange API)\n• boolean specifically means that the endpoint isn't natively available from the exchange API\n• boolean means the endpoint is natively available from the exchange API and unified in the ccxt library\n• string means the endpoint isn't natively available from the exchange API but reconstructed (as much as possible) by the ccxt library from other available true-methods For a complete list of all exchages and their supported methods, please, refer to this example: https://github.com/ccxt/ccxt/blob/master/examples/js/exchange-capabilities.js\n\nExchanges usually impose what is called a rate limit. Exchanges will remember and track your user credentials and your IP address and will not allow you to query the API too frequently. They balance their load and control traffic congestion to protect API servers from (D)DoS and misuse.\n\nWARNING: Stay under the rate limit to avoid ban!\n\nMost exchanges allow up to 1 or 2 requests per second. Exchanges may temporarily restrict your access to their API or ban you for some period of time if you are too aggressive with your requests.\n\nThe property is set to a safe default which is sub-optimal. Some exchanges may have varying rate limits for different endpoints. It is up to the user to tweak according to application-specific purposes.\n\nThe CCXT library has a built-in experimental rate-limiter that will do the necessary throttling in background transparently to the user. WARNING: users are responsible for at least some type of rate-limiting: either by implementing a custom algorithm or by doing it with the built-in rate-limiter..\n\nYou can turn on/off the built-in rate-limiter with property, like so:\n\nIn case your calls hit a rate limit or get nonce errors, the ccxt library will throw an exception, or, in some cases, one of the following types:\n\nA later retry is usually enough to handle that.\n\nThe rate limiter is a property of the exchange instance, in other words, each exchange instance has its own rate limiter that is not aware of the other instances. In many cases the user should reuse the same exchange instance throughout the program. Do not use multiple instances of the same exchange with the same API keypair from the same IP address.\n\nReuse the exchange instance as much as possible as shown below:\n\nSince the rate limiter belongs to the exchange instance, destroying the exchange instance will destroy the rate limiter as well. Among the most common pitfalls with the rate limiting is creating and dropping the exchange instance over and over again. If in your program you are creating and destroying the exchange instance (say, inside a function that is called multiple times), then you are effectively resetting the rate limiter over and over and that will eventually break the rate limits. If you are recreating the exchange instance every time instead of reusing it, CCXT will try to load the markets every time. Therefore, you will force-load the markets over and over as explained in the Loading Markets section. Abusing the markets endpoint will eventually break the rate limiter as well.\n\nDo not break this rule unless you really understand the inner workings of the rate-limiter and you are 100% sure you know what you're doing. In order to stay safe always reuse the exchange instance throughout your functions and methods callchain like shown below:\n\nSome exchanges are DDoS-protected by Cloudflare or Incapsula. Your IP can get temporarily blocked during periods of high load. Sometimes they even restrict whole countries and regions. In that case their servers usually return a page that states a HTTP 40x error or runs an AJAX test of your browser / captcha test and delays the reload of the page for several seconds. Then your browser/fingerprint is granted access temporarily and gets added to a whitelist or receives a HTTP cookie for further use.\n\nThe most common symptoms for a DDoS protection problem, rate-limiting problem or for a location-based filtering issue:\n• Getting exceptions with all types of exchange methods\n• Catching or with HTTP error codes 400, 403, 404, 429, 500, 501, 503, etc..\n• Getting a template HTML page instead of JSON from the exchange\n\nIf you encounter DDoS protection errors and cannot reach a particular exchange then:\n• use a proxy (this is less responsive, though)\n• ask the exchange support to add you to a whitelist\n• try an alternative IP within a different geographic region\n• run your software in a distributed network of servers\n• run your software in close proximity to the exchange (same country, same city, same datacenter, same server rack, same server)\n\nEach exchange is a place for trading some kinds of valuables. The exchanges may use differing terms to call them: \"a currency\", \"an asset\", \"a coin\", \"a token\", \"stock\", \"commodity\", \"crypto\", \"fiat\", etc. A place for trading one asset for another is usually called \"a market\", \"a symbol\", \"a trading pair\", \"a contract\", etc.\n\nIn terms of the ccxt library, every exchange offers multiple markets within itself. Each market is defined by two or more currencies. The set of markets differs from exchange to exchange opening possibilities for cross-exchange and cross-market arbitrage.\n\nEach currency is an associative array (aka dictionary) with the following keys:\n• . The string or numeric ID of the currency within the exchange. Currency ids are used inside exchanges internally to identify coins during the request/response process.\n• . An uppercase string code representation of a particular currency. Currency codes are used to reference currencies within the ccxt library (explained below).\n• . A human-readable name of the currency (can be a mix of uppercase & lowercase characters).\n• . The withdrawal fee value as specified by the exchange. In most cases it means a flat fixed amount paid in the same currency. If the exchnange does not specify it via public endpoints, the can be or missing.\n• . A boolean indicating whether trading or funding (depositing or withdrawing) for this currency is currently possible, more about it here: status.\n• . An associative array of non-common market properties, including fees, rates, limits and other general market information. The internal info array is different for each particular market, its contents depend on the exchange.\n• . Precision accepted in values by exchanges upon referencing this currency. The value of this property depends on .\n• . The minimums and maximums for amounts (volumes), withdrawals and deposits.\n\nEach network is an associative array (aka dictionary) with the following keys:\n• . The string or numeric ID of the network within the exchange. Network ids are used inside exchanges internally to identify networks during the request/response process.\n• . An uppercase string representation of a particular network. Networks are used to reference networks within the ccxt library.\n• . A human-readable name of the network (can be a mix of uppercase & lowercase characters).\n• . The withdrawal fee value as specified by the exchange. In most cases it means a flat fixed amount paid in the same currency. If the exchnange does not specify it via public endpoints, the can be or missing.\n• . A boolean indicating whether trading or funding (depositing or withdrawing) for this currency is currently possible, more about it here: status.\n• . An associative array of non-common market properties, including fees, rates, limits and other general market information. The internal info array is different for each particular market, its contents depend on the exchange.\n• . Precision accepted in values by exchanges upon referencing this currency. The value of this property depends on .\n• . The minimums and maximums for amounts (volumes), withdrawals and deposits.\n\nEach market is an associative array (aka dictionary) with the following keys:\n• . The string or numeric ID of the market or trade instrument within the exchange. Market ids are used inside exchanges internally to identify trading pairs during the request/response process.\n• . An uppercase string code representation of a particular trading pair or instrument. This is usually written as with a slash as in , or , etc. Symbols are used to reference markets within the ccxt library (explained below).\n• . A unified uppercase string code of base fiat or crypto currency. This is the standardized currency code that is used to refer to that currency or token throughout CCXT and throughout the Unified CCXT API, it's the language that CCXT understands.\n• . An exchange-specific id of the base currency for this market, not unified. Can be any string, literally. This is communicated to the exchange using the language the exchange understands.\n• . An exchange-specific id of the quote currency, not unified.\n• . A boolean indicating whether or not trading this market is currently possible, more about it here: status.\n• . Float, 0.0015 = 0.15%. Maker fees are paid when you provide liquidity to the exchange i.e. you market-make an order and someone else fills it. Maker fees are usually lower than taker fees. Fees can be negative, this is very common amongst derivative exchanges. A negative fee means the exchange will pay a rebate (reward) to the user for trading this market (note, 'taker' and 'maker' publicly available fees, not taking into consideration your vip-level/volume/etc. Use to get the fees specific to your account).\n• . Float, 0.002 = 0.2%. Taker fees are paid when you take liquidity from the exchange and fill someone else's order.\n• . A boolean true/false value indicating whether and are multipliers or fixed flat amounts.\n• . A boolean true/false value indicating whether the fee depends on your trading tier (usually, your traded volume over a period of time).\n• . An associative array of non-common market properties, including fees, rates, limits and other general market information. The internal info array is different for each particular market, its contents depend on the exchange.\n• . Precision accepted in order values by exchanges upon order placement for price, amount and cost. (The value inside this property depend on the ).\n• . The minimums and maximums for prices, amounts (volumes) and costs (where cost = price * amount).\n• . The type of the option, option represents an option with the right to buy and an option with the right to sell.\n• . Price at which an option can be bought or sold when it is exercised.\n\nThe flag is typically used in and . The exchanges might put a slightly different meaning into it. If a currency is inactive, most of the time all corresponding tickers, orderbooks and other related endpoints return empty responses, all zeroes, no data or outdated information. The user should check if the currency is and reload markets periodically.\n\nNote: the value for the property doesn't always guarantee that all of the possible features like trading, withdrawing or depositing are disabled on the exchange. Likewise, neither the value guarantees that all those features are enabled on the exchange. Check the underlying exchanges' documentation and the code in CCXT for the exact meaning of the flag for this or that exchange. This flag is not yet supported or implemented by all markets and may be missing.\n\nWARNING! The information about the fee is experimental, unstable and may be partial or not available at all.\n\nDo not confuse with ! Precision has nothing to do with min limits. A precision of 8 digits does not necessarily mean a min limit of 0.00000001. The opposite is also true: a min limit of 0.0001 does not necessarily mean a precision of 4.\n\nIn this example the amount of any order placed on the market must satisfy both conditions:\n• The amount value should be >= 0.05:\n• Precision of the amount should be up to 4 decimal digits:\n\nIn this example the price of any order placed on the market must satisfy both conditions:\n• The price value should be >= 0.019:\n• Precision of price should be 5 decimal digits or less:\n\nIn this example both conditions must be satisfied:\n• The amount value should be greater than or equal to 50:\n• A negative amount precision means that the amount should be an integer multiple of 10 (to the absolute power specified):\n\nThe and params are currently under heavy development, some of these fields may be missing here and there until the unification process is complete. This does not influence most of the orders but can be significant in extreme cases of very large or very small orders.\n\nThe user is required to stay within all limits and precision! The values of the order should satisfy the following conditions:\n• Precision of must be <=\n• Precision of must be <=\n\nThe above values can be missing with some exchanges that don't provide info on limits from their API or don't have it implemented yet.\n\nEach exchange has its own rounding, counting and padding modes.\n• – will round the last decimal digits to precision\n• – will cut off the digits after certain precision\n\nThe decimal precision counting mode is available in the property.\n• – counts all digits, 99% of exchanges use this counting mode. With this mode of precision, the numbers in designate the number of decimal digits after the dot for further rounding or truncation.\n• – counts non-zero digits only, some exchanges ( and maybe a few other) implement this mode of counting decimals. With this mode of precision, the numbers in designate the Nth place of the last significant (non-zero) decimal digit after the dot.\n• – some exchanges only allow a multiple of a specific value ( uses this mode, for example). In this mode, the numbers in designate the minimal precision fractions (floats) for rounding or truncating.\n• – appends zero characters up to precision\n\nMost of the time the user does not have to take care of precision formatting, since CCXT will handle that for the user when the user places orders or sends withdrawal requests, if the user follows the rules as described on Precision And Limits. However, in some cases precision-formatting details may be important, so the following methods may be useful in the userland.\n\nThe exchange base class contains the method to help format values to the required decimal precision with support for different rounding, counting and padding modes.\n\nFor examples of how to use the to format strings and floats, please, see the following files:\n\nPython WARNING! The method is susceptible to\n\nFor users' convenience CCXT base exchange class also implements the following methods:\n\nEvery exchange has its own precision settings, the above methods will help format those values according to exchange-specific precision rules, in a way that is portable and agnostic of the underlying exchange. In order to make that possible, markets and currencies have to be loaded prior to formatting any values.\n\nMake sure to load the markets with before calling these methods!\n\nMore practical examples that describe the behavior of :\n\nIn most cases you are required to load the list of markets and trading symbols for a particular exchange prior to accessing other API methods. If you forget to load markets the ccxt library will do that automatically upon your first call to the unified API. It will send two HTTP requests, first for markets and then the second one for other data, sequentially. For that reason, your first call to a unified CCXT API method like fetchTicker, fetchBalance, etc will take more time, than the consequent calls, since it has to do more work loading the market information from the exchange API. See Notes On Rate Limiter for more details.\n\nIn order to load markets manually beforehand call the / method on an exchange instance. It returns an associative array of markets indexed by trading symbol. If you want more control over the execution of your logic, preloading markets by hand is recommended.\n\nApart from the market info, the call will also load the currencies from the exchange and will cache the info in the and the properties respectively.\n\nThe user can also bypass the cache and call unified methods for fetching that information from the exchange endpoints directly, and , though using these methods is not recommended for end-users. The recommended way to preload markets is by calling the unified method. However, new exchange integrations are required to implement these methods if the underlying exchange has the corresponding API endpoints.\n\nA currency code is a code of three to five letters, like , , , , , , , , , , , etc. Some exchanges have exotic currencies with longer codes.\n\nA symbol is usually an uppercase string literal name of a pair of traded currencies with a slash in between. The first currency before the slash is usually called base currency, and the one after the slash is called quote currency. Examples of a symbol are: , , , , , , .\n\nMarket ids are used during the REST request-response process to reference trading pairs within exchanges. The set of market ids is unique per exchange and cannot be used across exchanges. For example, the BTC/USD pair/market may have different ids on various popular exchanges, like , , , , (numeric id), , , , . You don't need to remember or use market ids, they are there for internal HTTP request-response purposes inside exchange implementations.\n\nThe ccxt library abstracts uncommon market ids to symbols, standardized to a common format. Symbols aren't the same as market ids. Every market is referenced by a corresponding symbol. Symbols are common across exchanges which makes them suitable for arbitrage and many other things.\n\nSometimes the user might notice a symbol like or or some other \"exotic/rare symbols\". The symbol is not required to have a slash or to be a pair of currencies. The string in the symbol really depends on the type of the market (whether it is a spot market or a futures market, a darkpool market or an expired market, etc). Attempting to parse the symbol string is highly discouraged, one should not rely on the symbol format, it is recommended to use market properties instead.\n\nMarket structures are indexed by symbols and ids. The base exchange class also has builtin methods for accessing markets by symbols. Most API methods require a symbol to be passed in their first argument. You are often required to specify a symbol when querying current prices, making orders, etc.\n\nMost of the time users will be working with market symbols. You will get a standard userland exception if you access non-existent keys in these dicts.\n\nThere is a bit of term ambiguity across various exchanges that may cause confusion among newcoming traders. Some exchanges call markets as pairs, whereas other exchanges call symbols as products. In terms of the ccxt library, each exchange contains one or more trading markets. Each market has an id and a symbol. Most symbols are pairs of base currency and quote currency.\n\nHistorically various symbolic names have been used to designate same trading pairs. Some cryptocurrencies (like Dash) even changed their names more than once during their ongoing lifetime. For consistency across exchanges the ccxt library will perform the following known substitutions for symbols and currencies:\n• : is newer but is more common among exchanges and sounds more like bitcoin (read more).\n• : The Bitcoin Cash fork is often called with two different symbolic names: and . The name is ambiguous for Bitcoin Cash, it is confused with BitConnect. The ccxt library will convert to where it is appropriate (some exchanges and aggregators confuse them).\n• : was Darkcoin then became Dash (read more).\n• : On November 15 2018 Bitcoin Cash forked the second time, so, now there is (for BCH ABC) and (for BCH SV).\n• : This is a common substitution mapping for the Bitcoin Cash SV fork (some exchanges call it , others call it , we use the former).\n• : Try not to confuse symbols and currencies. The (Dashcoin) is not the same as (Dash). Some exchanges have labelled inconsistently as , the ccxt library does a correction for that as well ( ), but only on certain exchanges that have these two currencies confused, whereas most exchanges have them both correct. Just remember that is not the same as .\n• → : is the newer code for RaiBlocks, thus, CCXT unified API uses will replace the older with where needed. https://hackernoon.com/nano-rebrand-announcement-9101528a7b76\n• → : Some exchanges, like Bitfinex, HitBTC and a few other name the currency as in their listings, but those markets are actually trading . The confusion can come from a 3-letter limitation on symbol names or may be due to other reasons. In cases where the traded currency is actually and is not – the CCXT library will perform → conversion. Note, however, that some exchanges have both and symbols, for example, Kraken has a trading pair.\n\nEach exchange has an associative array of substitutions for cryptocurrency symbolic codes in the property, like:\n\nwhere key represents actual name how exchange engine refers to that coin, and the value represents what you want to refer to it with through ccxt.\n\nSometimes the user may notice exotic symbol names with mixed-case words and spaces in the code. The logic behind having these names is explained by the rules for resolving conflicts in naming and currency-coding when one or more currencies have the same symbolic code with different exchanges:\n• First, we gather all info available from the exchanges themselves about the currency codes in question. They usually have a description of their coin listings somewhere in their API or their docs, knowledgebases or elsewhere on their websites.\n• When we identify each particular cryptocurrency standing behind the currency code, we look them up on CoinMarketCap.\n• The currency that has the greatest market capitalization of all wins the currency code and keeps it. For example, HOT often stand for either or . In this case retains the code , and will have its name as its code, literally, . So, there may be trading pairs with symbols like (for ) and – those are two different markets.\n• If market cap of a particular coin is unknown or is not enough to determine the winner, we also take trading volumes and other factors into consideration.\n• When the winner is determined all other competing currencies get their code names properly remapped and substituted within conflicting exchanges via . Note, it should be defined before '.loadMarkets()' happens!\n• Unfortunately this is a work in progress, because new currencies get listed daily and new exchanges are added from time to time, so, in general this is a never-ending process of self-correction in a quickly changing environment, practically, in \"live mode\". We are thankful for all reported conflicts and mismatches you may find.\n\nIs it possible for symbols to change?\n\nIn short, yes, sometimes, but rarely. Symbolic mappings can be changed if that is absolutely required and cannot be avoided. However, all previous symbolic changes were related to resolving conflicts or forks. So far, there was no precedent of a market cap of one coin overtaking another coin with the same symbolic code in CCXT.\n\nCan we rely on always listing the same crypto with the same symbol?\n\nMore or less ) First, this library is a work in progress, and it is trying to adapt to the everchanging reality, so there may be conflicts that we will fix by changing some mappings in the future. Ultimately, the license says \"no warranties, use at your own risk\". However, we don't change symbolic mappings randomly all over the place, because we understand the consequences and we'd want to rely on the library as well and we don't like to break the backward-compatibility at all.\n\nIf it so happens that a symbol of a major token is forked or has to be changed, then the control is still in the users' hands. The property can be overrided upon initialization or later, just like any other exchange property. If a significant token is involved, we usually post instructions on how to retain the old behavior by adding a couple of lines to the constructor params.\n\nIt depends on which exchange you are using, but some of them have a reversed (inconsistent) pairing of and . They actually have base and quote misplaced (switched/reversed sides). In that case you'll see a difference of parsed and currency values with the unparsed in the market substructure.\n\nFor those exchanges the ccxt will do a correction, switching and normalizing sides of base and quote currencies when parsing exchange replies. This logic is financially and terminologically correct. If you want less confusion, remember the following rule: base is always before the slash, quote is always after the slash in any symbol and with any market.\n\nWe currently load spot markets with the unified symbol schema into the mapping, indexed by symbol. This would cause a naming conflict for futures and other derivatives that have the same symbol as their spot market counterparts. To accomodate both types of markets in the we require the symbols between 'future' and 'spot' markets to be distinct, as well as the symbols between 'linear' and 'inverse' contracts to be distinct.\n\nCCXT supports the following types of derivative contracts:\n• – for expiring futures contracts that have a delivery/settlement date\n• – for perpetual swap futures that don't have a delivery date\n\nA future market symbol consists of the underlying currency, the quoting currency, the settlement currency and an arbitrary identifier. Most often the identifier is the settlement date of the future contract in format:\n\nThe is also a dirty method with a side effect of saving the array of markets on the exchange instance. You only need to call it once per exchange. All subsequent calls to the same method will return the locally saved (cached) array of markets.\n\nWhen exchange markets are loaded, you can then access market information any time via the property. This property contains an associative array of markets indexed by symbol. If you need to force reload the list of markets after you have them loaded already, pass the reload = true flag to the same method again.\n\nEach exchange offers a set of API methods. Each method of the API is called an endpoint. Endpoints are HTTP URLs for querying various types of information. All endpoints return JSON in response to client requests.\n\nUsually, there is an endpoint for getting a list of markets from an exchange, an endpoint for retrieving an order book for a particular market, an endpoint for retrieving trade history, endpoints for placing and canceling orders, for money deposit and withdrawal, etc... Basically every kind of action you could perform within a particular exchange has a separate endpoint URL offered by the API.\n\nBecause the set of methods differs from exchange to exchange, the ccxt library implements the following:\n• a public and private API for all possible URLs and methods\n\nThe endpoint URLs are predefined in the property for each exchange. You don't have to override it, unless you are implementing a new exchange API (at least you should know what you're doing).\n\nMost of exchange-specific API methods are implicit, meaning that they aren't defined explicitly anywhere in code. The library implements a declarative approach for defining implicit (non-unified) exchanges' API methods.\n\nEach method of the API usually has its own endpoint. The library defines all endpoints for each particular exchange in the property. Upon exchange construction an implicit magic method (aka partial function or closure) will be created inside on the exchange instance for each endpoint from the list of endpoints. This is performed for all exchanges universally. Each generated method will be accessible in both and notations.\n\nThe endpoints definition is a full list of ALL API URLs exposed by an exchange. This list gets converted to callable methods upon exchange instantiation. Each URL in the API endpoint list gets a corresponding callable method. This is done automatically for all exchanges, therefore the ccxt library supports all possible URLs offered by crypto exchanges.\n\nEach implicit method gets a unique name which is constructed from the definition. For example, a private HTTPS PUT endpoint will have a corresponding exchange method named / . A public HTTPS GET endpoint would result in the corresponding method named / , and so on.\n\nAn implicit method takes a dictionary of parameters, sends the request to the exchange and returns an exchange-specific JSON result from the API as is, unparsed. To pass a parameter, add it to the dictionary explicitly under a key equal to the parameter's name. For the examples above, this would look like and .\n\nThe recommended way of working with exchanges is not using exchange-specific implicit methods but using the unified ccxt methods instead. The exchange-specific methods should be used as a fallback in cases when a corresponding unified method isn't available (yet).\n\nTo get a list of all available methods with an exchange instance, including implicit methods and unified methods you can simply do the following:\n\nAPI URLs are often grouped into two sets of methods called a public API for market data and a private API for trading and account access. These groups of API methods are usually prefixed with a word 'public' or 'private'.\n\nA public API is used to access market data and does not require any authentication whatsoever. Most exchanges provide market data openly to all (under their rate limit). With the ccxt library anyone can access market data out of the box without having to register with the exchanges and without setting up account keys and passwords.\n\nThe private API is mostly used for trading and for accessing account-specific private data, therefore it requires authentication. You have to get the private API keys from the exchanges. It often means registering with an exchange website and creating the API keys for your account. Most exchanges require personal information or identification. Some exchanges will only allow trading after completing the KYC verification. Private APIs allow the following:\n\nSome exchanges offer the same logic under different names. For example, a public API is also often called market data, basic, market, mapi, api, price, etc... All of them mean a set of methods for accessing data available to public. A private API is also often called trading, trade, tapi, exchange, account, etc...\n\nA few exchanges also expose a merchant API which allows you to create invoices and accept crypto and fiat payments from your clients. This kind of API is often called merchant, wallet, payment, ecapi (for e-commerce).\n\nTo get a list of all available methods with an exchange instance, you can simply do the following:\n\ncontract only and margin only\n• methods in this documentation that are documented as contract only or margin only are only intended to be used for contract trading and margin trading respectively. They may work when trading in other types of markets but will most likely return irrelevant information.\n\nIn the JavaScript version of CCXT all methods are asynchronous and return Promises that resolve with a decoded JSON object. In CCXT we use the modern async/await syntax to work with Promises. If you're not familiar with that syntax, you can read more about it here.\n\nThe ccxt library supports asynchronous concurrency mode in Python 3.5+ with async/await syntax. The asynchronous Python version uses pure asyncio with aiohttp. In async mode you have all the same properties and methods, but most methods are decorated with an async keyword. If you want to use async mode, you should link against the subpackage, like in the following example:\n\nCCXT support PHP 8+ versions. The library has both synchronous and asynchronous versions. To use synchronous version, use namespace (i.e. ) and to use asynchronous version, use namespace (i.e. ). Asynchronous version uses ReactPHP library in the background. In async mode you have all the same properties and methods, but any networking API method should be decorated with the keyword and your script should be in a ReactPHP wrapper:\n\nSee further examples in the directory; look for filenames that include the word. Also, make sure you have installed the required dependencies using . Lastly, this article provides a good introduction to the methods used here. While syntactically the change is simple (i.e., just using a keyword before relevant methods), concurrency has significant implications for the overall design of your code.\n\nAll public and private API methods return raw decoded JSON objects in response from the exchanges, as is, untouched. The unified API returns JSON-decoded objects in a common format and structured uniformly across all exchanges.\n\nThe set of all possible API endpoints differs from exchange to exchange. Most of methods accept a single associative array (or a Python dict) of key-value parameters. The params are passed as follows:\n\nThe unified methods of exchanges might expect and will accept various which affect their functionality, like:\n\nAn exchange will not accept the params from a different exchange, they're not interchangeable. The list of accepted parameters is defined by each specific exchange.\n\nTo find which parameters can be passed to a unified method:\n• either open the exchange-specific implementation file and search for the desired function (i.e. ) to inspect and find out the details of usage\n• or go to the exchange's API docs and read the list of parameters for your specific function or endpoint (i.e. )\n\nFor a full list of accepted method parameters for each exchange, please consult API docs.\n\nAn exchange method name is a concatenated string consisting of type (public or private), HTTP method (GET, POST, PUT, DELETE) and endpoint URL path like in the following examples:\n\nThe ccxt library supports both camelcase notation (preferred in JavaScript) and underscore notation (preferred in Python and PHP), therefore all methods can be called in either notation or coding style in any language. Both of these notations work in JavaScript, Python and PHP:\n\nTo get a list of all available methods with an exchange instance, you can simply do the following:\n\nThe unified ccxt API is a subset of methods common among the exchanges. It currently contains the following methods:\n• : Fetches a list of all available markets from an exchange and returns an array of markets (objects with properties such as , , etc.). Some exchanges do not have means for obtaining a list of markets via their online API. For those, the list of markets is hardcoded.\n• : Fetches all available currencies an exchange and returns an associative dictionary of currencies (objects with properties such as , , etc.). Some exchanges do not have means for obtaining currencies via their online API. For those, the currencies will be extracted from market pairs or hardcoded.\n• : Returns the list of markets as an object indexed by symbol and caches it with the exchange instance. Returns cached markets if loaded already, unless the flag is forced.\n• : Returns information regarding the exchange status from either the info hardcoded in the exchange instance or the API, if available.\n\nNote, that most of methods of the unified API accept an optional argument. It is an associative array (a dictionary, empty by default) containing the params you want to override. The contents of are exchange-specific, consult the exchanges' API documentation for supported fields and values. Use the dictionary if you need to pass a custom setting or an optional parameter to your unified query.\n\nMost of unified methods will return either a single object or a plain array (a list) of objects (trades, orders, transactions and so on). However, very few exchanges (if any at all) will return all orders, all trades, all ohlcv candles or all transactions at once. Most often their APIs output to a certain number of most recent objects. YOU CANNOT GET ALL OBJECTS SINCE THE BEGINNING OF TIME TO THE PRESENT MOMENT IN JUST ONE CALL. Practically, very few exchanges will tolerate or allow that.\n\nTo fetch historical orders or trades, the user will need to traverse the data in portions or \"pages\" of objects. Pagination often implies \"fetching portions of data one by one\" in a loop.\n\nIn most cases users are required to use at least some type of pagination in order to get the expected results consistently. If the user does not apply any pagination, most methods will return the exchanges' default, which may start from the beginning of history or may be a subset of most recent objects. The default behaviour (without pagination) is exchange-specific! The means of pagination are often used with the following methods in particular:\n\nWith methods returning lists of objects, exchanges may offer one or more types of pagination. CCXT unifies date-based pagination by default, with timestamps in milliseconds throughout the entire library.\n\nWarning: this is an experimental feature and might produce unexpected/incorrect results in some instances.\n\nRecently, CCXT introduced a way to paginate through several results automatically by just providing the flag inside lifting this work from the userland. Most leading exchanges support it, and more will be added in the future, but the easiest way to check it is to look in the method's documentation and search for the pagination parameter. As always there are exceptions, and some endpoints might not provide a way to paginate either through a timestamp or a cursor, and in those cases, there's nothing CCXT can do about it.\n\nRight now, we have three different ways of paginating:\n• dynamic/time-based: uses the and parameters to paginate through dynamic results like (trades, orders, transactions, etc). Since we don't know a priori how many entries are available to be fetched, it will perform one request at a time until we reach the end of the data or the maximum amount of pagination calls (configurable through an option)\n• deterministic: when we can pre-compute the boundaries of each page, it will perform the requests concurrently for maximum performance. This applies to OHLCV, Funding Rates, and Open Interest and also respects the option.\n• cursor-based: when the exchange provides a cursor inside the response, we extract the cursor and perform the subsequent request until the end of the data or reach the maximum number of pagination calls.\n\nThe user cannot select the pagination method used, it will depend from implementation to implementation, considering the exchange API's features.\n\nWe can't perform an infinite amount of requests, and some of them might throw an error for different reasons, thus, we have some options that allow the user to control these variables and other pagination specificities.\n\nAll the options below, should be provided inside , you can check the examples below\n• paginate: (boolean) indicates that the user wants to paginate through different pages to get more data. Default is false.\n• paginationCalls: (integer) allows the user to control the maximum amount of requests to paginate the data. Due to the rate limits, this value should not be too high. Default is 10.\n• maxRetries: (integer) how many times should the pagination mechanism retry upon getting an error. Default is 3\n• paginationDirection: (string) Only applies to the dynamic pagination and it can be either forward (start the pagination from some time in the past and paginate forward) or backward (start from the most recent time and paginate backward). If forward is selected then a since parameter must also be provided. Default is backward.\n• maxEntriesPerRequest: (integer): The max amount of entries per request so that we can maximize the data retrieved per call. It varies from endpoint to endpoint and CCXT will populate this value for you, but you can override it if needed.\n\nAll unified timestamps throughout the CCXT library are integers in milliseconds unless explicitly stated otherwise.\n\nBelow is the set of methods for working with UTC dates and timestamps and for converting between them:\n\nThis is the type of pagination currently used throughout the CCXT Unified API. The user supplies a timestamp in milliseconds (!) and a number to results. To traverse the objects of interest page by page, the user runs the following (below is pseudocode, it may require overriding some exchange-specific params, depending on the exchange in question):\n\nThe user supplies a of the object, from where the query should continue returning results, and a number to results. This is the default with some exchanges, however, this type is not unified (yet). To paginate objects based on their ids, the user would run the following:\n\nThe user supplies a page number or an initial \"cursor\" value. The exchange returns a page of results and the next \"cursor\" value, to proceed from. Most of exchanges that implement this type of pagination will either return the next cursor within the response itself or will return the next cursor values within HTTP response headers.\n\nSee an example implementation here: https://github.com/ccxt/ccxt/blob/master/examples/py/coinbasepro-fetch-my-trades-pagination.py\n\nUpon each iteration of the loop the user has to take the next cursor and put it into the overrided params for the next query (on the following iteration):\n\nExchanges expose information on open orders with bid (buy) and ask (sell) prices, volumes and other data. Usually there is a separate endpoint for querying current state (stack frame) of the order book for a particular market. An order book is also often called market depth. The order book information is used in the trading decision making process.\n\nTo get data on order books, you can use\n• // for the order books of all markets\n• limit (Integer) The number of orders to return in the order book (e.g. )\n• limit (Integer) The number of orders to return in the order book (e.g. )\n\nThe timestamp and datetime may be missing ( ) if the exchange in question does not provide a corresponding value in the API response.\n\nPrices and amounts are floats. The bids array is sorted by price in descending order. The best (highest) bid price is the first element and the worst (lowest) bid price is the last element. The asks array is sorted by price in ascending order. The best (lowest) ask price is the first element and the worst (highest) ask price is the last element. Bid/ask arrays can be empty if there are no corresponding orders in the order book of an exchange.\n\nExchanges may return the stack of orders in various levels of details for analysis. It is either in full detail containing each and every order, or it is aggregated having slightly less detail where orders are grouped and merged by price and volume. Having greater detail requires more traffic and bandwidth and is slower in general but gives a benefit of higher precision. Having less detail is usually faster, but may not be enough in some very specific cases.\n• The is the time when the exchange generated this orderbook response (before replying it back to you). This may be missing ( ), as documented in the Manual, not all exchanges provide a timestamp there. If it is defined, then it is the UTC timestamp in milliseconds since 1 Jan 1970 00:00:00.\n• Some exchanges may index orders in the orderbook by order ids, in that case the order id may be returned as the third element of bids and asks: . This is often the case with L3 orderbooks without aggregation. The order , if shown in the orderbook, refers to the orderbook and does not necessarily correspond to the actual order id from the exchanges' database as seen by the owner or by the others. The order id is an of the row inside the orderbook, but not necessarily the true- of the order (though, they may be equal as well, depending on the exchange in question).\n• In some cases the exchanges may supply L2 aggregated orderbooks with order counts for each aggregated level, in that case the order count may be returned as the third element of bids and asks: . The tells how many orders are aggregated on each price level in bids and asks.\n• Also, some exchanges may return the order timestamp as the third element of bids and asks: . The tells when the order was placed on the orderbook.\n\nSome exchanges accept a dictionary of extra parameters to the function. All extra are exchange-specific (non-unified). You will need to consult exchanges docs if you want to override a particular param, like the depth of the order book. You can get a limited count of returned orders or a desired level of aggregation (aka market depth) by specifying an limit argument and exchange-specific extra like so:\n\nThe levels of detail or levels of order book aggregation are often number-labelled like L1, L2, L3...\n• L1: less detail for quickly obtaining very basic info, namely, the market price only. It appears to look like just one order in the order book.\n• L2: most common level of aggregation where order volumes are grouped by price. If two orders have the same price, they appear as one single order for a volume equal to their total sum. This is most likely the level of aggregation you need for the majority of purposes.\n• L3: most detailed level with no aggregation where each order is separate from other orders. This LOD naturally contains duplicates in the output. So, if two orders have equal prices they are not merged together and it's up to the exchange's matching engine to decide on their priority in the stack. You don't really need L3 detail for successful trading. In fact, you most probably don't need it at all. Therefore some exchanges don't support it and always return aggregated order books.\n\nIf you want to get an L2 order book, whatever the exchange returns, use the or unified method for that.\n\nThe argument does not guarantee that the number of bids or asks will always be equal to . It designates the upper boundary or the maximum, so at some moment in time there may be less than bids or asks. This is the case when the exchange does not have enough orders on the orderbook. However, if the underlying exchange API does not support a parameter for the orderbook endpoint at all, then the argument will be ignored. CCXT does not trim and if the exchange returns more than you request.\n\nIn order to get current best price (query market price) and calculate bidask spread take first elements from bid and ask, like so:\n\nA price ticker contains statistics for a particular market/symbol for some period of time in recent past, usually last 24 hours. The methods for fetching tickers are described below.\n\nCheck the and properties of the exchange instance to determine if the exchange in question does support these methods.\n\nPlease, note, that calling without a symbol is usually strictly rate-limited, an exchange may ban you if you poll that endpoint too frequently.\n\nA ticker is a statistical calculation with the information calculated over the past 24 hours for a specific market.\n\nThe structure of a ticker is as follows:\n• All fields in the ticker represent the past 24 hours prior to .\n• The is the volume (amount) of current best bid in the orderbook.\n• The is the volume (amount) of current best ask in the orderbook.\n• The is the amount of base currency traded (bought or sold) in last 24 hours.\n• The is the amount of quote currency traded (bought or sold) in last 24 hours.\n\nAll prices in ticker structure are in quote currency. Some fields in a returned ticker structure may be undefined/None/null.\n\nTimestamp and datetime are both Universal Time Coordinated (UTC) in milliseconds.\n• is the time when the exchange generated this response (before replying it back to you). It may be missing ( ), as documented in the Manual, not all exchanges provide a timestamp there. If it is defined, then it is a UTC timestamp in milliseconds since 1 Jan 1970 00:00:00.\n• is the date-time string of the last HTTP response received (from HTTP headers). The 'Date' parser should respect the timezone designated there. The precision of the date-time is 1 second, 1000 milliseconds. This date should be set by the exchange server when the message originated according to the following standards:\n\nAlthough some exchanges do mix-in orderbook's top bid/ask prices into their tickers (and some exchanges even serve top bid/ask volumes) you should not treat a ticker as a replacement. The main purpose of a ticker is to serve statistical data, as such, treat it as \"live 24h OHLCV\". It is known that exchanges discourage frequent requests by imposing stricter rate limits on these queries. If you need a unified way to access bids and asks you should use family instead.\n\nTo get historical prices and volumes use the unified method where available. To get historical mark, index, and premium index prices, add one of , , respectively to the params-overrides of . There are also convenience methods , , and that obtain the mark, index and premiumIndex historical prices and volumes.\n\nTo get the individual ticker data from an exchange for a particular trading pair or a specific symbol – call the :\n\nSome exchanges (not all of them) also support fetching all tickers at once. See their docs for details. You can fetch all tickers with a single call like so:\n\nFetching all tickers requires more traffic than fetching a single ticker. Also, note that some exchanges impose higher rate-limits on subsequent fetches of all tickers (see their docs on corresponding endpoints for details). The cost of the call in terms of rate limit is often higher than average. If you only need one ticker, fetching by a particular symbol is faster as well. You probably want to fetch all tickers only if you really need all of them and, most likely, you don't want to fetchTickers more frequently than once in a minute or so.\n\nAlso, some exchanges may impose additional requirements on the call, sometimes you can't fetch the tickers for all symbols because of the API limitations of the exchange in question. Some exchanges accept a list of symbols in HTTP URL query params, however, because URL length is limited, and in extreme cases exchanges can have thousands of markets – a list of all their symbols simply would not fit in the URL, so it has to be a limited subset of their symbols. Sometimes, there are other reasons for requiring a list of symbols, and there may be a limit on the number of symbols you can fetch at once, but whatever the limitation, please, blame the exchange. To pass the symbols of interest to the exchange, you can supply a list of strings as the first argument to fetchTickers:\n\nNote that the list of symbols is not required in most cases, but you must add additional logic if you want to handle all possible limitations that might be imposed on the exchanges' side.\n\nLike most methods of the Unified CCXT API, the last argument to fetchTickers is the argument for overriding request parameters that are sent towards the exchange.\n\nThe structure of the returned value is as follows:\n\nA general solution for fetching all tickers from all exchanges (even the ones that don't have a corresponding API endpoint) is on the way, this section will be updated soon.\n\nMost exchanges have endpoints for fetching OHLCV data, but some of them don't. The exchange boolean (true/false) property named indicates whether the exchange supports candlestick data series or not.\n\nTo fetch OHLCV candles/bars from an exchange, ccxt has the method, which is declared in the following way:\n\nYou can call the unified / method to get the list of OHLCV candles for a particular symbol like so:\n\nTo get the list of available timeframes for your exchange see the property. Note that it is only populated when is true as well.\n\nThe returned list of candles may have one or more missing periods, if the exchange did not have any trades for the specified timerange and symbol. To a user that would appear as gaps in a continuous list of candles. That is considered normal. If the exchange did not have any candles at that time, the CCXT library will show the results as returned from the exchange itself.\n\nThere's a limit on how far back in time your requests can go. Most of exchanges will not allow to query detailed candlestick history (like those for 1-minute and 5-minute timeframes) too far in the past. They usually keep a reasonable amount of most recent candles, like 1000 last candles for any timeframe is more than enough for most of needs. You can work around that limitation by continuously fetching (aka REST polling) latest OHLCVs and storing them in a CSV file or in a database.\n\nNote that the info from the last (current) candle may be incomplete until the candle is closed (until the next candle starts).\n\nLike with most other unified and implicit methods, the method accepts as its last argument an associative array (a dictionary) of extra , which is used to override default values that are sent in requests to the exchanges. The contents of are exchange-specific, consult the exchanges' API documentation for supported fields and values.\n\nThe argument is an integer UTC timestamp in milliseconds (everywhere throughout the library with all unified methods).\n\nIf is not specified the method will return the time range as is the default from the exchange itself. This is not a bug. Some exchanges will return candles from the beginning of time, others will return most recent candles only, the exchanges' default behaviour is expected. Thus, without specifying the range of returned candles will be exchange-specific. One should pass the argument to ensure getting precisely the history range needed.\n\nCurrently, the structure CCXT uses does not include the raw response from the exchange. However, users might be able to override the return value by doing:\n\nTrading strategies require fresh up-to-date information for technical analysis, indicators and signals. Building a speculative trading strategy based on the OHLCV candles received from the exchange may have critical drawbacks. Developers should account for the details explained in this section to build successful bots.\n\nFirst and foremost, when using CCXT you're talking to the exchanges directly. CCXT is not a server, nor a service, it's a software library. All data that you are getting with CCXT is received directly from the exchanges first-hand.\n\nThe exchanges usually provide two categories of public market data:\n• Fast primary first-order data that includes real time orderbooks and trades or fills\n• Slow second-order data that includes secondary tickers and kline OHLCV candles, that are calculated from the first-order data\n\nThe primary first-order data is updated by the exchanges APIs in pseudo real time, or as close to real time as possible, as fast as possible. The second-order data requires time for the exchange to calculate it. For example, a ticker is nothing more than a rolling 24-hour statistical cut of orderbooks and trades. OHLCV candles and volumes are also calculated from first-order trades and represent fixed statistical cuts of specific periods. The volume traded within an hour is just a sum of traded volumes of the corresponding trades that happened within that hour.\n\nObviously, it takes some time for the exchange to collect the first-order data and calculate the secondary statistical data from it. That literally means that tickers and OHLCVs are always slower than orderbooks and trades. In other words, there is always some latency in the exchange API between the moment when a trade happens and the moment when a corresponding OHLCV candle is updated or published by the exchange API.\n\nThe latency (or how much time is needed by the exchange API for calculating the secondary data) depends on how fast the exchange engine is, so it is exchange-specific. Top exchange engines will usually return and update fresh last-minute OHLCV candles and tickers at a very fast rate. Some exchanges might do it in regular intervals like once a second or once in a few seconds. Slow exchange engines might take minutes to update the secondary statistical information, their APIs might return the current most recent OHLCV candle a few minutes late.\n\nIf your strategy depends on the fresh last-minute most recent data you don't want to build it based on tickers or OHLCVs received from the exchange. Tickers and exchanges' OHLCVs are only suitable for display purposes, or for simple trading strategies for hour-timeframes or day-timeframes that are less susceptible to latency.\n\nThankfully, the developers of time-critical trading strategies don't have to rely on secondary data from the exchanges and can calculate the OHLCVs and tickers in the userland. That may be faster and more efficient than waiting for the exchanges to update the info on their end. One can aggregate the public trade history by polling it frequently and calculate candles by walking over the list of trades - please take a look into \"build-ohlcv-bars\" file inside examples folder\n\nDue to the differences in their internal implementations the exchanges may be faster to update their primary and secondary market data over WebSockets. The latency remains exchange-specific, cause the exchange engine still needs time to calculate the secondary data, regardless of whether you're polling it over the RESTful API with CCXT or getting updates via WebSockets with CCXT Pro. WebSockets can improve the networking latency, so a fast exchange will work even better, but adding the support for WS subscriptions will not make a slow exchange engine work much faster.\n\nIf you want to stay on top of the second-order data latency, then you will have to calculate it on your side and beat the exchange engine in speed of doing so. Depending on the needs of your application, it may be tricky, since you will need to handle redundancy, \"data holes\" in the history, exchange downtimes, and other aspects of data aggregation which is a whole universe in itself that is impossible to fully cover in this Manual.\n\nThe fetchOHLCV method shown above returns a list (a flat array) of OHLCV candles represented by the following structure:\n\nThe list of candles is returned sorted in ascending (historical/chronological) order, oldest candle first, most recent candle last.\n\nTo obtain historical Mark, Index Price and Premium Index candlesticks pass the params-override to . The parameter accepts one of the following values:\n\nThere are also convenience methods , and\n\nSome exchanges don't offer any OHLCV method, and for those, the ccxt library will emulate OHLCV candles from Public Trades. In that case you will see . However, because the trade history is usually very limited, the emulated fetchOHLCV methods cover most recent info only and should only be used as a fallback, when no other option is available.\n\nYou can call the unified / method to get the list of most recent trades for a particular symbol. The method is declared in the following way:\n\nFor example, if you want to print recent trades for all symbols one by one sequentially (mind the rateLimit!) you would do it like so:\n\nThe fetchTrades method shown above returns an ordered list of trades (a flat array, sorted by timestamp in ascending order, oldest trade first, most recent trade last). A list of trades is represented by the trade structure.\n\nMost exchanges return most of the above fields for each trade, though there are exchanges that don't return the type, the side, the trade id or the order id of the trade. Most of the time you are guaranteed to have the timestamp, the datetime, the symbol, the price and the amount of each trade.\n\nThe second optional argument reduces the array by timestamp, the third argument reduces by number (count) of returned items.\n\nIf the user does not specify , the method will return the default range of public trades from the exchange. The default set is exchange-specific, some exchanges will return trades starting from the date of listing a pair on the exchange, other exchanges will return a reduced set of trades (like, last 24 hours, last 100 trades, etc). If the user wants precise control over the timeframe, the user is responsible for specifying the argument.\n\nMost of unified methods will return either a single object or a plain array (a list) of objects (trades). However, very few exchanges (if any at all) will return all trades at once. Most often their APIs output to a certain number of most recent objects. YOU CANNOT GET ALL OBJECTS SINCE THE BEGINNING OF TIME TO THE PRESENT MOMENT IN JUST ONE CALL. Practically, very few exchanges will tolerate or allow that.\n\nTo fetch historical trades, the user will need to traverse the data in portions or \"pages\" of objects. Pagination often implies \"fetching portions of data one by one\" in a loop.\n\nIn most cases users are required to use at least some type of pagination in order to get the expected results consistently.\n\nOn the other hand, some exchanges don't support pagination for public trades at all. In general the exchanges will provide just the most recent trades.\n\nThe / method also accepts an optional (assoc-key array/dict, empty by default) as its fourth argument. You can use it to pass extra params to method calls or to override a particular default value (where supported by the exchange). See the API docs for your exchange for more details.\n\nThe method (if available) returns the current integer timestamp in milliseconds from the exchange server.\n\nThe exchange status describes the latest known information on the availability of the exchange API. This information is either hardcoded into the exchange class or fetched live directly from the exchange API. The method can be used to get this information. The status returned by is one of:\n• Hardcoded into the exchange class, e.g. if the API has been broken or shutdown.\n• Updated using the exchange ping or endpoint to see if its alive\n\nThe method will return a status structure like shown below:\n\nThe possible values in the field are:\n• ' means the exchange was closed, and the field should contain the datetime of the shutdown\n• means that either the exchange API is broken, or the implementation of the exchange in CCXT is broken\n• means regular maintenance, and the field should contain the datetime when the exchange is expected to be operational again\n\nWhen short trading or trading with leverage on a spot market, currency must be borrowed. Interest is accrued for the borrowed currency.\n\nData on the borrow rate for a currency can be retrieved using\n• for the borrow rates of currencies in individual markets\n• A dictionary of borrow rate structures with unified currency codes as keys\n• A dictionary of isolated borrow rate structures with unified market symbols as keys\n\nThe method retrieves a history of a currencies borrow interest rate at specific time slots\n• since (Integer) Timestamp for the earliest borrow rate (e.g. )\n• limit (Integer) The maximum number of borrow rate structures to retrieve (e.g. )\n\nThe method can be used to obtain the maximum leverage for a market at varying position sizes. It can also be used to obtain the maintenance margin rate, and the max tradeable amount for a market when that information is not available from the market object\n\nWhile you can obtain the absolute maximum leverage for a market by accessing , for many contract markets, the maximum leverage will depend on the size of your position.\n\nYou can access those limits by using\n\nIn the example above:\n\nNote for Huobi users: Huobi uses both leverage and amount to determine maintenance margin rates: https://www.huobi.com/support/en-us/detail/900000089903\n\nData on the current, most recent, and next funding rates can be obtained using the methods\n• An array of funding rate structures indexed by market symbols\n\nRetrieve the current funding interval using the following methods:\n• since (Integer) Timestamp for the earliest funding rate (e.g. )\n• limit (Integer) The maximum number of funding rates to retrieve (e.g. )\n\nUse the method to get the current open interest for a symbol from the exchange.\n\nUse the method to get a history of open interest for a symbol from the exchange.\n• since (Integer) Timestamp for the earliest open interest record (e.g. )\n• limit (Integer) The maximum number of open interest structures to retrieve (e.g. )\n\nNote for OKX users: instead of a unified symbol okx.fetchOpenInterestHistory expects a unified currency code in the symbol argument (e.g. ).\n\nUse the method to get the volatility history for the code of an options underlying asset from the exchange.\n\nUse the method to get the market id's of underlying assets for a contract market type from the exchange.\n\nUse the method to get the public settlement history for a contract market from the exchange.\n• since (Integer) Timestamp for the earliest settlement (e.g. )\n• limit (Integer) The maximum number of settlements to retrieve (e.g. )\n\nUse the method to get the public liquidations of a trading pair from the exchange.\n• since (Integer) Timestamp for the earliest liquidation (e.g. )\n• limit (Integer) The maximum number of liquidations to retrieve (e.g. )\n\nUse the method to get the public greeks and implied volatility of an options trading pair from the exchange. The greeks measure how factors like the underlying assets price, time to expiration, volatility, and interest rates, affect the price of an options contract.\n\nUse the method to get the public details of a single option contract from the exchange.\n\nUse the method to get the public option chain data of an underlying currency from the exchange.\n\nUse the method to fetch the current long short ratio of a symbol and use the to fetch the history of long short ratios for a symbol.\n• for the current ratio of a single market symbol\n• for the history of ratios of a single market symbol\n• period (String) The period to calculate the ratio from (e.g. )\n• period (String) The period to calculate the ratio from (e.g. )\n• since (Integer) Timestamp for the earliest ratio (e.g. )\n• limit (Integer) The maximum number of ratios to retrieve (e.g. )\n\nIn order to be able to access your user account, perform algorithmic trading by placing market and limit orders, query balances, deposit and withdraw funds and so on, you need to obtain your API keys for authentication from each exchange you want to trade with. They usually have it available on a separate tab or page within your user account settings. API keys are exchange-specific and cannnot be interchanged under any circumstances.\n\nThe exchanges' private APIs will usually allow the following types of interaction:\n• the current state of the user's account balance can be obtained with the method as described in the Account Balance section\n• the user can place and cancel orders with , , as well as fetch current open orders and the past order history with methods like , , , , , , , as described in the section on Orders\n• the user can query the history of past trades executed with their account using , as described in the My Trades section, also see How Orders Are Related To Trades\n• the user can query their positions with and as described in the Positions section\n• the user can fetch the history of their transactions (on-chain transactions which are either deposits to the exchange account or withdrawals from the exchange account) with , or with , , and separately, depending on what is available from the exchange API\n• if the exchange API provides a ledger endpoint, the user can fetch a history of all money movements that somehow affected the balance, with that will return all accounting ledger entries such as trades, deposits, withdrawals, internal transfers between accounts, rebates, bonuses, fees, staking profits and so on, as described in the Ledger section.\n\nAuthentication with all exchanges is handled automatically if provided with proper API keys. The process of authentication usually goes through the following pattern:\n• Generate new nonce. A nonce is an integer, often a Unix Timestamp in seconds or milliseconds (since epoch January 1, 1970). The nonce should be unique to a particular request and constantly increasing, so that no two requests share the same nonce. Each next request should have greater nonce than the previous request. The default nonce is a 32-bit Unix Timestamp in seconds.\n• Append public apiKey and nonce to other endpoint params, if any, then serialize the whole thing for signing.\n• Sign the serialized params using HMAC-SHA256/384/512 or MD5 with your secret key.\n• Append the signature in Hex or Base64 and nonce to HTTP headers or body.\n\nThis process may differ from exchange to exchange. Some exchanges may want the signature in a different encoding, some of them vary in header and body param names and formats, but the general pattern is the same for all of them.\n\nYou should not share the same API keypair across multiple instances of an exchange running simultaneously, in separate scripts or in multiple threads. Using the same keypair from different instances simultaneously may cause all sorts of unexpected behaviour.\n\nDO NOT REUSE API KEYS WITH DIFFERENT SOFTWARE! The other software will screw your nonce too high. If you get InvalidNonce errors – make sure to generate a fresh new keypair first and foremost.\n\nThe authentication is already handled for you, so you don't need to perform any of those steps manually unless you are implementing a new exchange class. The only thing you need for trading is the actual API key pair.\n\nThe API credentials usually include the following:\n• . This is your public API Key and/or Token. This part is non-secret, it is included in your request header or body and sent over HTTPS in open text to identify your request. It is often a string in Hex or Base64 encoding or an UUID identifier.\n• . This is your private key. Keep it secret, don't tell it to anybody. It is used to sign your requests locally before sending them to exchanges. The secret key does not get sent over the internet in the request-response process and should not be published or emailed. It is used together with the nonce to generate a cryptographically strong signature. That signature is sent with your public key to authenticate your identity. Each request has a unique nonce and therefore a unique cryptographic signature.\n• . Some exchanges (not all of them) also generate a user id or uid for short. It can be a string or numeric literal. You should set it, if that is explicitly required by your exchange. See their docs for details.\n• . Some exchanges (not all of them) also require your password/phrase for trading. You should set this string, if that is explicitly required by your exchange. See their docs for details.\n\nIn order to create API keys find the API tab or button in your user settings on the exchange website. Then create your keys and copy-paste them to your config file. Your config file permissions should be set appropriately, unreadable to anyone except the owner.\n\nRemember to keep your apiKey and secret key safe from unauthorized use, do not send or tell it to anybody. A leak of the secret key or a breach in security can cost you a fund loss.\n\nFor checking if the user has supplied all the required credentials the base class has a method called or . Calling that method will throw an , if some of the credentials are missing or empty. The base class also has property that allows a user to see which credentials are required for this or that exchange, as shown below:\n\nTo set up an exchange for trading just assign the API credentials to an existing exchange instance or pass them to exchange constructor upon instantiation, like so:\n\nNote that your private requests will fail with an exception or error if you don't set up your API credentials before you start trading. To avoid character escaping always write your credentials in single quotes, not double quotes ( , ).\n\nWhen you get errors like or , then, most likely, the problem is not within ccxt, please avoid opening a new issue unless you ensure that:\n• You don't have typos, empty spaces, or quotes in your keys\n• Your current IP address (check IPv4 or IPv6) is added into API-KEY's whitelist (if you use proxy, consider that too)\n• You have selected the correct options in permissions list for that api-key\n• You are not accidentally mixing \"testnet\" api-keys or \"testnet\" mode in your script\n• You have checked already reported issues about this error\n\nSome exchanges required you to sign in prior to calling private methods, which can be done using the method\n\nThe default nonce is defined by the underlying exchange. You can override it with a milliseconds-nonce if you want to make private requests more frequently than once per second! Most exchanges will throttle your requests if you hit their rate limits, read API docs for your exchange carefully!\n\nIn case you need to reset the nonce it is much easier to create another pair of keys for using with private APIs. Creating new keys and setting up a fresh unused keypair in your config is usually enough for that.\n\nIn some cases you are unable to create new keys due to lack of permissions or whatever. If that happens you can still override the nonce. Base market class has the following methods for convenience:\n• : same in milliseconds (ms = 1000 * s, thousandths of a second).\n• : same in microseconds (μs = 1000 * ms, millionths of a second).\n\nThere are exchanges that confuse milliseconds with microseconds in their API docs, let's all forgive them for that, folks. You can use methods listed above to override the nonce value. If you need to use the same keypair from multiple instances simultaneously use closures or a common function to avoid nonce conflicts. In Javascript you can override the nonce by providing a parameter to the exchange constructor or by setting it explicitly on exchange object:\n\nIn Python and PHP you can do the same by subclassing and overriding nonce function of a particular exchange class:\n\nYou can get all the accounts associated with a profile by using the method\n\nThe method will return a structure like shown below:\n\nTypes of account is one of the unified account types or\n\nTo query for balance and get the amount of funds available for trading or funds locked in orders, use the method:\n\nThe and values may be undefined or missing if the underlying exchange does not provide them.\n\nSome exchanges may not return full balance info. Many exchanges do not return balances for your empty or unused accounts. In that case some currencies may be missing in returned balance structure.\n\nMost of the time you can query orders by an id or by a symbol, though not all exchanges offer a full and flexible set of endpoints for querying orders. Some exchanges might not have a method for fetching recently closed orders, the other can lack a method for getting an order by id, etc. The ccxt library will target those cases by making workarounds where possible.\n\nThe list of methods for querying orders consists of the following:\n\nNote that the naming of those methods indicates if the method returns a single order or multiple orders (an array/list of orders). The method requires a mandatory order id argument (a string). Some exchanges also require a symbol to fetch an order by id, where order ids can intersect with various trading pairs. Also, note that all other methods above return an array (a list) of orders. Most of them will require a symbol argument as well, however, some exchanges allow querying with a symbol unspecified (meaning all symbols).\n\nThe library will throw a NotSupported exception if a user calls a method that is not available from the exchange or is not implemented in ccxt.\n\nTo check if any of the above methods are available, look into the property of the exchange:\n\nA typical structure of the property usually contains the following flags corresponding to order API methods for querying orders:\n\nThe meanings of boolean and are obvious. A string value of means that particular method is missing in the exchange API and ccxt will workaround that where possible on the client-side.\n\nThe exchanges' order management APIs differ by design. The user has to understand the purpose of each specific method and how they're combined together into a complete order API:\n• – though not a part of the orders' API, it is closely related, since it provides the history of settled trades.\n• – fetches a list of all orders (either open or closed/canceled).\n• – used for placing multiple orders within the same request\n• - used for canceling all orders\n• - used for canceling all orders after the given timeout\n\nThe majority of the exchanges will have a way of fetching currently-open orders. Thus, the . If that method is not available, then most likely the that will provide a list of all orders. The exchange will return a list of open orders either from or from . One of the two methods is usually available from any exchange.\n\nSome exchanges will provide the order history, other exchanges will not. If the underlying exchange provides the order history, then the or the . If the underlying exchange does not provide the order history, then and are not available. In the latter case, the user is required to build a local cache of orders and track the open orders using and for order statuses and for marking them as closed locally in the userland (when they're not open anymore).\n\nIf the underlying exchange does not have methods for order history ( and ), then it will provide + the trade history with (see How Orders Are Related To Trades). That set of information is in many cases enough for tracking in a live-trading robot. If there's no order history – you have to track your live orders and restore historical info from open orders and historical trades.\n\nIn general, the underlying exchanges will usually provide one or more of the following types of historical data:\n\nAny of the above three methods may be missing, but the exchanges APIs will usually provide at least one of the three methods.\n\nIf the underlying exchange does not provide historical orders, the CCXT library will not emulate the missing functionality – it has to be added on the user side where necessary.\n\nPlease, note, that a certain method may be missing either because the exchange does not have a corresponding API endpoint, or because CCXT has not implemented it yet (the library is also a work in progress). In the latter case, the missing method will be added as soon as possible.\n\nAll methods returning lists of trades and lists of orders, accept the second argument and the third argument:\n\nThe second argument reduces the array by timestamp, the third argument reduces by number (count) of returned items.\n\nIf the user does not specify , the methods will return the default set of results from the exchange. The default set is exchange-specific, some exchanges will return trades or recent orders starting from the date of listing a pair on the exchange, other exchanges will return a reduced set of trades or orders (like, last 24 hours, last 100 trades, first 100 orders, etc). If the user wants precise control over the timeframe, the user is responsible for specifying the argument.\n\nNOTE: not all exchanges provide means for filtering the lists of trades and orders by starting time, so, the support for and is exchange-specific. However, most exchanges do provide at least some alternative for \"pagination\" and \"scrolling\" which can be overrided with extra argument.\n\nSome exchanges do not have a method for fetching closed orders or all orders. They will offer just the endpoint, and sometimes also a endpoint as well. Those exchanges don't have any methods for fetching the order history. To maintain the order history for those exchanges the user has to store a dictionary or a database of orders in the userland and update the orders in the database after calling methods like , , , .\n\nTo get the details of a particular order by its id, use the / method. Some exchanges also require a symbol even when fetching a particular order by id.\n\nThe signature of the fetchOrder/fetch_order method is as follows:\n\nSome exchanges don't have an endpoint for fetching an order by id, ccxt will emulate it where possible. For now it may still be missing here and there, as this is a work in progress.\n\nYou can pass custom overrided key-values in the additional params argument to supply a specific order type, or some other setting if needed.\n\nBelow are examples of using the fetchOrder method to get order info from an authenticated exchange instance:\n\nSome exchanges don't have an endpoint for fetching all orders, ccxt will emulate it where possible. For now it may still be missing here and there, as this is a work in progress.\n\nDo not confuse closed orders with trades aka fills ! An order can be closed (filled) with multiple opposing trades! So, a closed order is not the same as a trade. In general, the order does not have a at all, but each particular user trade does have , and other properties. However, many exchanges propagate those properties to the orders as well.\n\nSome exchanges don't have an endpoint for fetching closed orders, ccxt will emulate it where possible. For now it may still be missing here and there, as this is a work in progress.\n\nMost of methods returning orders within ccxt unified API will yield an order structure as described below:\n• The of an order is usually either (not filled or partially filled), (fully filled), or (unfilled and canceled, or partially filled then canceled).\n• Some exchanges allow the user to specify an expiration timestamp upon placing a new order. If the order is not filled by that time, its becomes .\n• Use the value to determine if the order is filled, partially filled or fully filled, and by how much.\n• The work on info is still in progress, fee info may be missing partially or entirely, depending on the exchange capabilities.\n• The currency may be different from both traded currencies (for example, an ETH/BTC order with fees in USD).\n• The timestamp may have no value and may be where not supported by the exchange or in case of an open order (an order that has not been filled nor partially filled yet).\n• The , if any, designates the timestamp of the last trade, in case the order is filled fully or partially, otherwise is .\n• Order prevails or has precedence over the .\n• The of an order is:\n• The of an order means the total quote volume of the order (whereas the is the base volume). The value of should be as close to the actual most recent known order cost as possible. The field itself is there mostly for convenience and can be deduced from other fields.\n• The field can be set upon placing orders by the user with custom order params. Using the the user can later distinguish between own orders. This is only available for the exchanges that do support at this time.\n\nThe field may be if not specified by the exchange. The unification of is a work in progress.\n\nPossible values for the field:\n• = Good Till Cancel(ed), the order stays on the orderbook until it is matched or canceled.\n• = Immediate Or Cancel, the order has to be matched immediately and filled either partially or completely, the unfilled remainder is canceled (or the entire order is canceled).\n• = Fill Or Kill, the order has to get fully filled and closed immediately, otherwise the entire order is canceled.\n• = Post Only, the order is either placed as a maker order, or it is canceled. This means the order must be placed on orderbook for at at least time in an unfilled state. The unification of as a option is a work in progress with unified exchanges having .\n\nThere are different types of orders that a user can send to the exchange, regular orders eventually land in the orderbook of a corresponding symbol, others orders may be more advanced. Here is a list outlining various types of orders:\n• Limit Orders – regular orders having an in base currency (how much you want to buy or sell) and a in quote currency (for which price you want to buy or sell).\n• Market Orders – regular orders having an in base currency (how much you want to buy or sell)\n• Market Buys – some exchanges require market buy orders with an in quote currency (how much you want to spend for buying)\n• Trigger Orders aka conditional orders – an advanced type of order used to wait for a certain condition on a market and then react automatically: when a is reached, the trigger order gets triggered and then a regular limit or market price order is placed, that eventually results in entering a position or exiting a position\n• Stop Loss Orders – almost the same as trigger orders, but used to close a position to stop further losses on that position: when the price reaches then the stop loss order is triggered that results in placing another regular limit or market order to close a position at a specific limit or at market price (a position with a stop loss order attached to it).\n• Take Profit Orders – a counterpart to stop loss orders, this type of order is used to close a position to take existing profits on that position: when the price reaches then the take profit order is triggered that results in placing another regular limit or market order to close a position at a specific limit or at market price (a position with a take profit order attached to it).\n• StopLoss And TakeProfit Orders Attached To A Position – advanced orders, consisting of three orders of types listed above: a regular limit or market order placed to enter a position with stop loss and/or take profit orders that will be placed upon opening that position and will be used to close that position later (when a stop loss is reached, it will close the position and will cancel its take profit counterpart, and vice versa, when a take profit is reached, it will close the position and will cancel its stop loss counterpart, these two counterparts are also known as \"OCO orders – one cancels the other), apart from the (and for the limit order) to open a position it will also require a for a stop loss order (with a limit if it's a stop loss limit order) and/or a for a take profit order (with a limit if it's a take profit limit order).\n• Trailing Orders – an order that is automatically adjusted relative to an open position, can be set to trail a specified quote amount behind the open position or can be set to trail a specified percent behind the open position, when the market price of the position is equal to the trailing order this results in entering a new position or exiting a position depending on if the trailing order has the parameter set to true or not.\n\nPlacing an order always requires a that the user has to specify (which market you want to trade).\n\nTo place an order use the method. You can use the from the returned unified order structure to query the status and the state of the order later. If you need to place multiple orders simultaneously, you can check the availability of the method.\n• symbol (String) required Unified CCXT market symbol\n• Make sure the symbol in question exists with the target exchange and is available for trading.\n• side required a string literal for the direction of your order. Unified sides:\n• give quote currency and receive base currency; for example, buying means that you will receive bitcoins for your dollars.\n• give base currency and receive quote currency; for example, buying means that you will receive dollars for your bitcoins.\n• type a string literal type of order Unified types:\n• market not allowed by some exchanges, see their docs for details\n• see #custom-order-params and #other-order-types for non-unified types\n• amount, how much of currency you want to trade usually, but not always, in units of the base currency of the trading pair symbol (the units for some exchanges are dependent on the side of the order: see their API docs for details.)\n• price the price at which the order is to be fullfilled at in units of the quote currency (ignored in market orders)\n• Some exchanges will allow to trade with limit orders only.\n\nSome fields from the returned order structure may be if that information is not returned from the exchange API's response. The user is guaranteed that the method will return a unified order structure that will contain at least the order and the (a raw response from the exchange \"as is\"):\n• There is a common error that happens when creating orders for contract markets:\n\nThis error happens when the exchange is expecting a natural number of contracts (1,2,3, etc) in the argument of . The market structure has a key called . Each contract is worth a certain amount of the base asset that is determined by the . The number of contracts multiplied by the is equal to the base amount. so to derive the number of contracts you should enter in the argument you can solve for contracts: .\n\nHere is an example of finding the :\n\nLimit orders placed on the order book of the exchange for a price specified by the trader. They are fullfilled(closed) when there are no orders in the same market at a better price, and another trader creates a market order or an opposite order for a price that matches or exceeds the price of the limit order.\n\nLimit orders may not be fully filled. This happens when the filling order is for a smaller amount than the amount specified by the limit order.\n\nalso known as\n\nMarket orders are executed immediately by fulfilling one of more already existing orders from the ask side of the exchanges order book. The orders that your market order fulfills are chosen from th top of the order book stack, meaning your market order is fulfilled at the best price available. When placing a market order you don't need to specify the price of the order, and if the price is specified, it will be ignored.\n\nYou are not guaranteed that the order will be executed for the price you observe prior to placing your order. There are multiple reasons for this, including:\n• price slippage a slight change of the price for the traded market while your order is being executed. Reasons for price slippage include, but are not limited to\n• unequivocal order sizes if a market order is for an amount that is larger than the size of the top order on the order book, then after the top order is filled, the market order will proceed to fill the next order in the order book, which means the market order is filled at multiple prices\n\nNote, that some exchanges will not accept market orders (they allow limit orders only). In order to detect programmatically if the exchange in question does support market orders or not, you can use the exchange property:\n\nIn general, when placing a or order the user has to specify just the amount of the base currency to buy or sell. However, with some exchanges market buy orders implement a different approach to calculating the value of the order.\n\nSuppose you're trading BTC/USD and the current market price for BTC is over 9000 USD. For a market buy or market sell you could specify an of 2 BTC and that would result in plus or minus 18000 USD (more or less ;)) on your account, depending on the side of the order.\n\nWith market buys some exchanges require the total cost of the order in the quote currency! The logic behind it is simple, instead of taking the amount of base currency to buy or sell some exchanges operate with \"how much quote currency you want to spend on buying in total\".\n\nTo place a market buy order with those exchanges you would not specify an amount of 2 BTC, instead you should somehow specify the total cost of the order, that is, 18000 USD in this example. The exchanges that treat orders in this way have an exchange-specific option that allows specifying the total cost of a order in two ways.\n\nThe first is the default and if you specify the along with the the total cost of the order would be calculated inside the lib from those two values with a simple multiplication ( ). The resulting would be the amount in USD quote currency that will be spent on this particular market buy order.\n\nThe second alternative is useful in cases when the user wants to calculate and specify the resulting total cost of the order himself. That can be done by setting the option to to switch it off:\n\nMore about it:\n\nIt is also possible to emulate a order with a order.\n\nWARNING this method can be risky due to high volatility, use it at your own risk and only use it when you know really well what you're doing!\n\nMost of the time a can be emulated with a at a very low price – the exchange will automatically make it a taker order for market price (the price that is currently in your best interest from the ones that are available in the order book). When the exchange detects that you're selling for a very low price it will automatically offer you the best buyer price available from the order book. That is effectively the same as placing a market sell order. Thus market orders can be emulated with limit orders (where missing).\n\nThe opposite is also true – a can be emulated with a for a very high price. Most exchanges will again close your order for best available price, that is, the market price.\n\nHowever, you should never rely on that entirely, ALWAYS test it with a small amount first! You can try that in their web interface first to verify the logic. You can sell the minimal amount at a specified limit price (an affordable amount to lose, just in case) and then check the actual filling price in trade history.\n\nLimit price orders are also known as limit orders. Some exchanges accept limit orders only. Limit orders require a price (rate per unit) to be submitted with the order. The exchange will close limit orders if and only if market price reaches the desired level.\n\nComing from traditional trading, the term \"Stop order\" has been a bit ambigious, so instead of it, in CCXT we use term \"Trigger\" order. When symbol's price reaches your \"trigger\"(\"stop\") price, the order is activated as or order, depending which one you had chosen.\n\nWe have different classification of trigger orders:\n• standalone Stop Loss or Take Profit designed to close open positions.\n• a Stop Loss or Take Profit order attached to a primary order (Conditional Trigger Order).\n\nTraditional \"stop\" order (which you might see across exchanges' websites) is now called \"trigger\" order across CCXT library. Implemented by adding a parameter. They are independent basic trigger orders that can open or close a position.\n• Typically, it is activated when price of the underlying asset/contract crosses the from any direction. However, some exchanges' API require to set too, which triggers order depending whether price is above or below . For example, if you want to trigger limit order (buy 0.1 at limit price ) once pair price crosses :\n\nTypically, exchange automatically determines 's direction (whether it is \"above\" or \"below\" current price), however, some exchanges require that you provide with either or values:\n\nNote, you can also add param to the trigger order (with a possible param), so it would act as \"stop-loss\" or \"take-profit\" order. However, for some exchanges we support \"stop-loss\" and \"take-profit\" trigger order types, which automatically involve and handling (see them below).\n\nThe same as Trigger Orders, but the direction matters. Implemented by specifying a parameter (for the stop loss triggerPrice), and also automatically implemented on behalf of user, so instead of regular Trigger Order, you can use this as an alternative.\n\nSuppose you entered a long position (you bought) at 1000 and want to protect yourself from losses from a possible price drop below 700. You would place a stop loss order with triggerPrice at 700. For that stop loss order either you would specify a limit price or it will be executed at market price.\n\nSuppose you entered a short position (you sold) at 700 and want to protect yourself from losses from a possible price pump above 1300. You would place a stop loss order with triggerPrice at 1300. For that stop loss order either you would specify a limit price or it will be executed at market price.\n\nStop Loss orders are activated when the price of the underlying asset/contract:\n• drops below the from above, for sell orders. (eg: to close a long position, and avoid further losses)\n• rises above the from below, for buy orders (eg: to close a short position, and avoid further losses)\n\nThe same as Stop Loss Orders, but the direction matters. Implemented by specifying a parameter (for the take profit triggerPrice).\n\nSuppose you entered a long position (you bought) at 1000 and want to get your profits from a possible price pump above 1300. You would place a take profit order with triggerPrice at 1300. For that take profit order either you would specify a limit price or it will be executed at market price.\n\nSuppose you entered a short position (you sold) at 700 and want to get your profits from a possible price drop below 600. You would place a take profit order with triggerPrice at 600. For that take profit order either you would specify a limit price or it will be executed at market price.\n\nTake Profit orders are activated when the price of the underlying:\n• rises above the from below, for sell orders (eg: to close a long position, at a profit)\n• drops below the from above, for buy orders (eg: to close a short position, at a profit)\n\nTake Profit / Stop Loss Orders which are tied to a position-opening primary order. Implemented by supplying a dictionary parameters for and describing each respectively.\n• By default stopLoss and takeProfit orders will be the same magnitude as primary order but in the opposite direction.\n• Attached trigger orders are conditional on the primary order being executed.\n• Not supported by all exchanges.\n• Both and or either can be supplied, this depends on exchange.\n\nNote: This is still under unification and is work in progress\n\nFor exchanges, where it is not possible to use attached SL &TP, after submitting an entry order, you can immediatelly submit another order (even though position might not be open yet) with and params, so it can still act as a stoploss order for your upcoming position (note, this approach might not work for some exchanges).\n\nTrailing Orders trail behind an open position. Implemented by supplying float parameters for or .\n• A trailing order continually adjusts the order price at a fixed percent or fixed quote amount away from the current market price.\n• A trailing order trails behind a position as it moves in one direction, but not in the opposite direction.\n• If the position value rises, the trailing order changes, but if the position value drops the trailing order stays the same until the order is executed.\n• A trailing order can be placed independently after opening a position.\n• Implemented by filling in either the or parameter depending on the exchange.\n• The price argument can be used as the , and the type argument can be used to differentiate between limit and market trailing orders if needed.\n\nNot supported by all exchanges.\n\nNote: This is still under unification and is a work in progress\n\nSome exchanges allow you to specify optional parameters for your order. You can pass your optional parameters and override your query with an associative array using the argument to your unified API call. All custom params are exchange-specific, of course, and aren't interchangeable, do not expect those custom params for one exchange to work with another exchange.\n\nThe user can specify a custom field can be set upon placing orders with the . Using the one can later distinguish between own orders. This is only available for the exchanges that do support at this time. For the exchanges that don't support it will either throw an error upon supplying the or will ignore it setting the to .\n\nTo edit an order, you can use the method\n• side (String) required the direction of your order. Unified sides:\n• give quote currency and receive base currency; for example, buying means that you will receive bitcoins for your dollars.\n• give base currency and receive quote currency; for example, buying means that you will receive dollars for your bitcoins.\n• type (String) required type of order Unified types:\n• not allowed by some exchanges, see their docs for details\n• see #custom-order-params and #other-order-types for non-unified types\n• amount (Number) required how much of currency you want to trade usually, but not always, in units of the base currency of the trading pair symbol (the units for some exchanges are dependent on the side of the order: see their API docs for details.)\n• price (Float) the price at which the order is to be fullfilled at in units of the quote currency (ignored in market orders)\n\nTo cancel an existing order use\n• for all open orders after the given timeout\n• timeout (number) countdown time in milliseconds required on some exchanges, 0 represents cancel the timer (e.g. \\ )\n\nThe is usually used on open orders only. However, it may happen that your order gets executed (filled and closed) before your cancel-request comes in, so a cancel-request might hit an already-closed order.\n\nA cancel-request might also throw a indicating that the order might or might not have been canceled successfully and whether you need to retry or not. Consecutive calls to may hit an already canceled order as well.\n\nAs such, can throw an exception in these cases:\n\nA trade is also often called . Each trade is a result of order execution. Note, that orders and trades have a one-to-many relationship: an execution of one order may result in several trades. However, when one order matches another opposing order, the pair of two matching orders yields one trade. Thus, when an order matches multiple opposing orders, this yields multiple trades, one trade per each pair of matched orders.\n\nTo put it shortly, an order can contain one or more trades. Or, in other words, an order can be filled with one or more trades.\n\nFor example, an orderbook can have the following orders (whatever trading symbol or pair it is):\n\nAll specific numbers above aren't real, this is just to illustrate the way orders and trades are related in general.\n\nA seller decides to place a sell limit order on the ask side for a price of 0.700 and an amount of 150.\n\nAs the price and amount of the incoming sell (ask) order cover more than one bid order (orders and ), the following sequence of events usually happens within an exchange engine very quickly, but not immediately:\n• Order is matched against the incoming sell because their prices intersect. Their volumes \"mutually annihilate\" each other, so, the bidder gets 100 for a price of 0.800. The seller (asker) will have their sell order partially filled by bid volume 100 for a price of 0.800. Note that for the filled part of the order the seller gets a better price than he asked for initially. He asked for 0.7 at least but got 0.8 instead which is even better for the seller. Most conventional exchanges fill orders for the best price available.\n• A trade is generated for the order against the incoming sell order. That trade \"fills\" the entire order and most of the sell order. One trade is generated per each pair of matched orders, whether the amount was filled completely or partially. In this example the seller amount (100) fills order completely (closes the order ) and also fills the selling order partially (leaves it open in the orderbook).\n• Order now has a status of and a filled volume of 100. It contains one trade against the selling order. The selling order has an status and a filled volume of 100. It contains one trade against order . Thus each order has just one fill-trade so far.\n• The incoming sell order has a filled amount of 100 and has yet to fill the remaining amount of 50 from its initial amount of 150 in total.\n\nThe intermediate state of the orderbook is now (order is and is not in the orderbook anymore):\n• Order is matched against the remaining part of incoming sell, because their prices intersect. The amount of buying order which is 200 completely annihilates the remaining sell amount of 50. The order is filled partially by 50, but the rest of its volume, namely the remaining amount of 150 will stay in the orderbook. The selling order, however, is fulfilled completely by this second match.\n• A trade is generated for the order against the incoming sell order. That trade partially fills order . And completes the filling of the sell order. Again, this is just one trade for a pair of matched orders.\n• Order now has a status of , a filled amount of 50, and a remaining amount of 150. It contains one filling trade against the selling order. The selling order has a status now and it has completely filled its total initial amount of 150. However, it contains two trades, the first against order and the second against order . Thus each order can have one or more filling trades, depending on how their volumes were matched by the exchange engine.\n\nAfter the above sequence takes place, the updated orderbook will look like this.\n\nNotice that the order has disappeared, the selling order also isn't there. All closed and fully-filled orders disappear from the orderbook. The order which was filled partially and still has a remaining volume and an status, is still there.\n\nMost of unified methods will return either a single object or a plain array (a list) of objects (trades). However, very few exchanges (if any at all) will return all trades at once. Most often their APIs output to a certain number of most recent objects. YOU CANNOT GET ALL OBJECTS SINCE THE BEGINNING OF TIME TO THE PRESENT MOMENT IN JUST ONE CALL. Practically, very few exchanges will tolerate or allow that.\n\nAs with all other unified methods for fetching historical data, the method accepts a argument for date-based pagination. Just like with all other unified methods throughout the CCXT library, the argument for must be an integer timestamp in milliseconds.\n\nTo fetch historical trades, the user will need to traverse the data in portions or \"pages\" of objects. Pagination often implies \"fetching portions of data one by one\" in a loop.\n\nIn many cases a argument is required by the exchanges' APIs, therefore you have to loop over all symbols to get all your trades. If the is missing and the exchange requires it then CCXT will throw an exception to signal the requirement to the user. And then the has to be specified. One of the approaches is to filter the relevant symbols from the list of all symbols by looking at non-zero balances as well as transactions (withdrawals and deposits). Also, the exchanges will have a limit on how far back in time you can go.\n\nIn most cases users are required to use at least some type of pagination in order to get the expected results consistently.\n\nReturns ordered array of trades (most recent trade last).\n\nTrades denote the exchange of one currency for another, unlike transactions, which denote a transfer of a given coin.\n• The work on and info is still in progress, fee info may be missing partially or entirely, depending on the exchange capabilities.\n• The currency may be different from both traded currencies (for example, an ETH/BTC order with fees in USD).\n• The of the trade means . It is the total quote volume of the trade (whereas is the base volume). The cost field itself is there mostly for convenience and can be deduced from other fields.\n• The of the trade is a \"gross\" value. That is the value pre-fee, and the fee has to be applied afterwards.\n\nThe ledger is simply the history of changes, actions done by the user or operations that altered the user's balance in any way, that is, the history of movements of all funds from/to all accounts of the user which includes\n• amounts incoming and outcoming in result of a trade or an order\n• rebates, cashbacks and other types of events that are subject to accounting.\n\nData on ledger entries can be retrieved using\n• for multiple ledger entries of the same currency\n• code (String) Unified CCXT currency code; required if fetching all ledger entries for all assets at once is not supported (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve withdrawals for (e.g. )\n• limit (Integer) The number of ledger entry structures to retrieve (e.g. )\n\nThe type of the ledger entry is the type of the operation associated with it. If the amount comes due to a sell order, then it is associated with a corresponding trade type ledger entry, and the referenceId will contain associated trade id (if the exchange in question provides it). If the amount comes out due to a withdrawal, then is associated with a corresponding transaction.\n\nThe field holds the id of the corresponding event that was registered by adding a new item to the ledger.\n\nThe field is there to support for exchanges that include pending and canceled changes in the ledger. The ledger naturally represents the actual changes that have taken place, therefore the status is in most cases.\n\nThe ledger entry type can be associated with a regular trade or a funding transaction (deposit or withdrawal) or an internal between two accounts of the same user. If the ledger entry is associated with an internal transfer, the field will contain the id of the account that is being altered with the ledger entry in question. The field will contain the id of the opposite account the funds are transferred to/from, depending on the ( or ).\n\nIn order to deposit cryptocurrency funds to an exchange you must get an address from the exchange for the currency you want to deposit using . You can then call the method with the specified currency and address.\n\nTo deposit fiat currency on an exchange you can use the method with data retrieved from the method. this deposit feature is currently supported on coinbase only, feel free to report any issues you find\n\nThe deposit id structure returned from , look like this:\n\nData on deposits made to an account can be retrieved using\n• for multiple deposits of the same currency\n• for all deposits to an account\n• since (Integer) Timestamp (ms) of the earliest time to retrieve deposits for (e.g. )\n• limit (Integer) The number of transaction structures to retrieve (e.g. )\n\nThe method can be used to withdraw funds from an account\n\nSome exchanges require a manual approval of each withdrawal by means of 2FA (2-factor authentication). In order to approve your withdrawal you usually have to either click their secret link in your email inbox or enter a Google Authenticator code or an Authy code on their website to verify that withdrawal transaction was requested intentionally.\n\nIn some cases you can also use the withdrawal id to check withdrawal status later (whether it succeeded or not) and to submit 2FA confirmation codes, where this is supported by the exchange. See their docs for details.\n• amount (Float) required The amount of currency to withdraw (e.g. )\n• address (String) required The recipient address of the withdrawal (e.g. )\n\nData on withdrawals made to an account can be retrieved using\n• for multiple withdrawals of the same currency\n• for all withdrawals from an account\n• since (Integer) Timestamp (ms) of the earliest time to retrieve withdrawals for (e.g. )\n• limit (Integer) The number of transaction structures to retrieve (e.g. )\n\nIt is also possible to pass the parameters as the fourth argument with or without a specified tag\n\nThe following aliases of allow for withdrawing crypto on multiple chains\n\nYou may set the value of in order to withdraw USDT on the TRON chain, or 'BSC' to withdraw USDT on Binance Smart Chain. In the table above BSC and BEP20 are equivalent aliases, so it doesn't matter which one you use as they both will achieve the same effect.\n\nTransactions denote a transfer of a given coin, unlike trades, which denote the exchange of one currency for another.\n• or may be , if the exchange in question does not specify all sides of the transaction\n• The semantics of the field is exchange-specific. In some cases it can contain the address of the sender, in other cases it may contain the address of the receiver. The actual value depends on the exchange.\n• The field is the UTC timestamp in milliseconds of the most recent change of status of that funding operation, be it or . It is necessary if you want to track your changes in time, beyond a static snapshot. For example, if the exchange in question reports and for a transaction, then the field will take the value of , that is, the timestamp of the most recent change of the status.\n• The field may be in certain exchange-specific cases.\n• The substructure may be missing, if not supplied within the reply coming from the exchange.\n• The field may be , otherwise it will contain a message or note defined by the user upon creating the transaction.\n• Be careful when handling the and the . The is NOT an arbitrary user-defined string of your choice! You cannot send user messages and comments in the . The purpose of the field is to address your wallet properly, so it must be correct. You should only use the received from the exchange you're working with, otherwise your transaction might never arrive to its destination.\n• The field may be or, in some cases (when the exchange's endpoint returns both internal transfers and blockchain transactions, e.g. ), could be .\n\nThe address for depositing can be either an already existing address that was created previously with the exchange or it can be created upon request. In order to see which of the two methods are supported, check the and properties.\n\nSome exchanges may also have a method for fetching multiple deposit addresses at once or all of them at once.\n• code ([String]) Array of unified CCXT currency codes. May or may not be required depending on the exchange (e.g. )\n\nThe address structures returned from , , and look like this:\n\nWith certain currencies, like AEON, BTS, GXS, NXT, SBD, STEEM, STR, XEM, XLM, XMR, XRP, an additional argument is usually required by exchanges. Other currencies will have the set to . The tag is a memo or a message or a payment id that is attached to a withdrawal transaction. The tag is mandatory for those currencies and it identifies the recipient user account.\n\nBe careful when specifying the and the . The is NOT an arbitrary user-defined string of your choice! You cannot send user messages and comments in the . The purpose of the field is to address your wallet properly, so it must be correct. You should only use the received from the exchange you're working with, otherwise your transaction might never arrive to its destination.\n\nThe field is relatively new, it may be or missing entirely in certain cases (with some exchanges), but will be added everywhere eventually. It is still in the process of unification.\n\nThe method makes internal transfers of funds between accounts on the same exchange. This can include subaccounts or accounts of different types ( , , , ...). If an exchange is separated on CCXT into a spot and futures class (e.g. , , ...), then the method may be available to transfer funds into the futures account, and the method may be available to transfer funds out of the futures account\n• amount (Float) The amount of currency to transfer (e.g. )\n• fromAccount (String) The account to transfer funds from.\n• toAccount (String) The account to transfer funds to.\n• params.symbol (String) Market symbol when transfering to or from a margin account (e.g. )\n\nand can accept the exchange account id or one of the following unified values:\n• for some exchanges and are the same account\n• for some exchanges that allow for subaccounts\n\nYou can retrieve all the account types by selecting the keys from `exchange.options['accountsByType']\n\nSome exchanges allow transfers to email addresses, phone numbers or to other users by user id.\n• amount (Float) The amount of currency to transfer (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve transfers for (e.g. )\n• limit (Integer) The number of transfer structures to retrieve (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve transfers for (e.g. )\n• limit (Integer) The number of transfer structures to retrieve (e.g. )\n\nThis section of the Unified CCXT API is under development.\n\nFees are often grouped into two categories:\n• Trading fees. Trading fee is the amount payable to the exchange, usually a percentage of volume traded (filled).\n• Transaction fees. The amount payable to the exchange upon depositing and withdrawing as well as the underlying crypto transaction fees (tx fees).\n\nBecause the fee structure can depend on the actual volume of currencies traded by the user, the fees can be account-specific. Methods to work with account-specific fees:\n\nThe fee methods will return a unified fee structure, which is often present with orders and trades as well. The fee structure is a common format for representing the fee info throughout the library. Fee structures are usually indexed by market or currency.\n\nBecause this is still a work in progress, some or all of methods and info described in this section may be missing with this or that exchange.\n\nDO NOT use the property of the exchange instance as most often it contains the predefined/hardcoded info. Actual fees should only be accessed from markets and currencies.\n\nNOTE: Previously we used fetchTransactionFee(s) to fetch the transaction fees, which are now DEPRECATED and these functions have been replace by fetchDepositWithdrawFee(s)\n\nYou call / to fetch the trading fees, / to fetch the deposit & withdraw fees.\n\nOrders, private trades, transactions and ledger entries may define the following info in their field:\n\nTrading fees are properties of markets. Most often trading fees are loaded into the markets by the call. Sometimes, however, the exchanges serve fees from different endpoints.\n\nThe method can be used to precalculate trading fees that will be paid. WARNING! This method is experimental, unstable and may produce incorrect results in certain cases. You should only use it with caution. Actual fees may be different from the values returned from , this is just for precalculation. Do not rely on precalculated values, because market conditions change frequently. It is difficult to know in advance whether your order will be a market taker or maker.\n\nThe method will return a unified fee structure with precalculated fees for an order with specified params.\n\nAccessing trading fee rates should be done via which is the recommended approach. If that method is not supported by exchange, then via the property, like so:\n\nThe markets stored under the property may contain additional fee related information:\n\nWARNING! fee related information is experimental, unstable and may only be partial available or not at all.\n\nMaker fees are paid when you provide liquidity to the exchange i.e. you market-make an order and someone else fills it. Maker fees are usually lower than taker fees. Similarly, taker fees are paid when you take liquidity from the exchange and fill someone else's order.\n\nFees can be negative, this is very common amongst derivative exchanges. A negative fee means the exchange will pay a rebate (reward) to the user for the trading.\n\nAlso, some exchanges might not specify fees as percentage of volume, check the field of the market to be sure.\n\nSome exchanges have an endpoint for fetching the trading fee schedule, this is mapped to the unified methods , and\n\nAccessing transaction fee rates should be done via the property. This aspect is not unified yet and is subject to change.\n\nSome exchanges have an endpoint for fetching the transaction fee schedule, this is mapped to the unified methods\n\nTo trade with leverage in spot or margin markets, currency must be borrowed as a loan. This borrowed currency must be payed back with interest. To obtain the amount of interest that has accrued you can use the method\n• code (String) The unified currency code for the currency of the interest (e.g. )\n• symbol (String) The market symbol of an isolated margin market, if undefined, the interest for cross margin markets is returned (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to receive interest records for (e.g. )\n• limit (Integer) The number of borrow interest structures to retrieve (e.g. )\n\nTo borrow and repay currency as a margin loan use , , and .\n• code (String) required The unified currency code for the currency to be borrowed or repaid (e.g. )\n• amount (Float) required The amount of margin to borrow or repay (e.g. )\n• symbol (String) required The unified CCXT market symbol of an isolated margin market (e.g. )\n• code (String) required The unified currency code for the currency to be borrowed or repaid (e.g. )\n• amount (Float) required The amount of margin to borrow or repay (e.g. )\n\nNote: through the manual we use term \"collateral\" which means current margin balance, but do not confuse it with \"initial margin\" or \"maintenance margin\":\n\nFor example, when you had opened an isolated position with 50$ initial margin and the position has unrealized profit of -15$, then your position's collateral will be 35$. However, if we take that Maintenance Margin requirement (to keep the position open) by exchange hints $25 for that position, then your collateral should not drop below it, otherwise the position will be liquidated.\n\nTo increase, reduce or set your margin balance (collateral) in an open leveraged position, use , and respectively. This is kind of like adjusting the amount of leverage you're using with a position that's already open.\n\nSome scenarios to use these methods include\n• if the trade is going against you, you can add margin to, reducing the risk of liquidation\n• if your trade is going well you can reduce your position's margin balance and take profits\n• amount (String) required Amount of margin to add or reduce (e.g. )\n\nYou can fetch the history of margin adjustments made using the methods above or automatically by the exchange using the following method\n• since (Integer) Timestamp (ms) of the earliest time to retrieve margin adjustments for for (e.g. )\n• limit (Integer) The number of margin structures to retrieve (e.g. )\n\nUpdates the type of margin used to be either\n• One account is used to share collateral between markets. Margin is taken from total account balance to avoid liquidation when needed.\n• Each market, keeps collateral in a separate account\n• marginMode (String) required the type of margin used Unified margin types:\n• symbol (String) Unified CCXT market symbol (e.g. ) required on most exchanges. Is not required when the margin mode is not specific to a market\n\nCommon reasons for why an exchange might have\n• the exchange does not offer leveraged trading\n• the exchange only offers one of or margin modes, but does not offer both\n• margin mode must be set using an exchange specific parameter within when using\n\nSome exchange apis return an error response when a request is sent to set the margin mode to the mode that it is already set to (e.g. Sending a request to set the margin mode to for the market when the account already has set to use cross margin). CCXT doesn't see this as an error because the end result is what the user wanted, so the error is suppressed and the error result is returned as an object.\n\nSome methods allow the usage of a parameter that can be set to either or . This can be useful for specifying the directly within the methods params, for use with spot margin or contract markets. To specify a spot margin market, you need to use a unified spot symbol or set the market type to spot, while setting the marginMode parameter to or .\n\nUse a unified spot symbol, while setting the marginMode parameter.\n\nThe method can be used to obtain the set margin mode for a market. The method can be used to obtain the set margin mode for multiple markets at once.\n\nYou can access the set margin mode by using:\n• symbol (String) Unified CCXT market symbol (e.g. ) required on most exchanges. Is not required when leverage is not specific to a market (e.g. If leverage is set for the account and not per market)\n\nThe method can be used to obtain the set leverage for a market. The method can be used to obtain the set leverage for multiple markets at once.\n\nYou can access the set leverage by using:\n\nThis can include futures with a set expiry date, perpetual swaps with funding payments, and inverse futures or swaps. Information about the positions can be served from different endpoints depending on the exchange. In the case that there are multiple endpoints serving different types of derivatives CCXT will default to just loading the \"linear\" (as oppose to the \"inverse\") contracts or the \"swap\" (as opposed to the \"future\") contracts.\n\nTo get information about positions currently held in contract markets, use\n• symbols ([String]) Unified CCXT market symbols, do not set to retrieve all positions (e.g. )\n• symbol ([String]) Unified CCXT market symbols, do not set to retrieve all positions (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve positions for (e.g. )\n• limit (Integer) The number of position structures to retrieve (e.g. )\n\nPositions allow you to borrow money from an exchange to go long or short on an market. Some exchanges require you to pay a funding fee to keep the position open.\n\nWhen you go long on a position you are betting that the price will be higher in the future and that the price will never be less than the .\n\nAs the price of the underlying index changes so does the unrealisedPnl and as a consequence the amount of collateral you have left in the position (since you can only close it at market price or worse). At some price you will have zero collateral left, this is called the \"bust\" or \"zero\" price. Beyond this point, if the price goes in the opposite direction far enough, the collateral of the position will drop below the . The maintenanceMargin acts as a safety buffer between your position and negative collateral, a scenario where the exchange incurs losses on your behalf. To protect itself the exchange will swiftly liquidate your position if and when this happens. Even if the price returns back above the liquidationPrice you will not get your money back since the exchange sold all the you bought at market. In other words the maintenanceMargin is a hidden fee to borrow money.\n\nIt is recommended to use the and instead of the and since these tend to be more accurate. The maintenanceMargin might be calculated from other factors outside of the maintenanceMarginPercentage including the funding rate and taker fees, for example on kucoin.\n\nAn inverse contract will allow you to go long or short on BTC/USD by putting up BTC as collateral. Our API for inverse contracts is the same as for linear contracts. The amounts in an inverse contracts are quoted as if they were traded USD/BTC, however the price is still quoted terms of BTC/USD. The formula for the profit and loss of a inverse contract is . The profit and loss and collateral will now be quoted in BTC, and the number of contracts are quoted in USD.\n\nTo quickly close open positions with a market order, use\n• side optional a string literal for the direction of your order. Some exchanges require it. Unified sides:\n• give quote currency and receive base currency; for example, buying means that you will receive bitcoins for your dollars.\n• give base currency and receive quote currency; for example, buying means that you will receive dollars for your bitcoins.\n\nIt is the price at which the . The price has gone in the opposite direction of your position to the point where the is only maintenanceMargin collateral left and if it goes any further the position will have negative collateral.\n\nPerpetual swap (also known as perpetual future) contracts maintain a market price that mirrors the price of the asset they are based on because funding fees are exchanged between traders who hold positions in perpetual swap markets.\n\nIf the contract is being traded at a price that is higher than the price of the asset they represent, then traders in long positions pay a funding fee to traders in short positions at specific times of day, which encourages more traders to enter short positions prior to these times.\n\nIf the contract is being traded at a price that is lower than the price of the asset they represent, then traders in short positions pay a funding fee to traders in long positions at specific times of day, which encourages more traders to enter long positions prior to these times.\n\nThese fees are usually exchanged between traders with no commission going to the exchange\n\nThe method can be used to retrieve an accounts history of funding fees paid or received\n• since (Integer) Timestamp (ms) of the earliest time to retrieve funding history for (e.g. )\n• limit (Integer) The number of funding history structures to retrieve (e.g. )\n\nThe method can be used to retrieve a quote that can be used for a conversion trade. The quote usually needs to be used within a certain timeframe specified by the exchange for the convert trade to execute successfully.\n• fromCode (String) required The unified currency code for the currency to convert from (e.g. )\n• toCode (String) required The unified currency code for the currency to be converted into (e.g. )\n• amount (Float) Amount to convert in units of the from currency (e.g. )\n\nThe method can be used to create a conversion trade order using the id retrieved from fetchConvertQuote. The quote usually needs to be used within a certain timeframe specified by the exchange for the convert trade to execute successfully.\n• fromCode (String) required The unified currency code for the currency to convert from (e.g. )\n• toCode (String) required The unified currency code for the currency to be converted into (e.g. )\n• amount (Float) Amount to convert in units of the from currency (e.g. )\n\nThe method can be used to fetch a specific conversion trade using the trades id.\n• code (String) The unified currency code of the conversion trade (e.g. )\n\nThe method can be used to fetch the conversion history for a specified currency code.\n• code (String) The unified currency code to fetch conversion trade history for (e.g. )\n• since (Integer) Timestamp of the earliest conversion (e.g. )\n• limit (Integer) The maximum number of conversion structures to retrieve (e.g. )\n\nIn some specific cases you may want a proxy, when:\n• Exchange is not available in your location\n• Your IP is forbidden by exchange\n• You experience random restriction by exchange, like DDoS protection by Cloudflare\n\nHowever, beware that each added intermediary might add some latency to requests.\n\nNote for Go users: After setting any proxy property, you must call to apply the changes:\n\nHowever be aware that each added intermediary might add some latency to requests.\n\nCCXT supports the following proxy types (note, each of them also have callback support):\n\nThis property prepends an url to API requests. It might be useful for simple redirection or bypassing CORS browser restriction.\n\nwhile 'YOUR_PROXY_URL' could be like (use the slash accordingly):\n\nSo requests will be made to i.e. . ( You can also have a small proxy script running on your device/webserver to use it in - \"sample-local-proxy-server\" in examples folder).\n\nThis approach works only for REST requests, but not for websocket connections. ((How to test if your proxy works))[#test-if-your-proxy-works]\n\nTo set a real http(s) proxy for your scripts, you need to have an access to a remote http or https proxy, so calls will be made directly to the target exchange, tunneled through your proxy server:\n\nThis approach only affects non-websocket requests of ccxt. To route CCXT's WebSockets connections through proxy, you need to specifically set (or ) property, in addition to the (or ), so your script should be like:\n\nSo, both connections (HTTP & WS) would go through proxies. ((How to test if your proxy works))[#test-if-your-proxy-works]\n\nYou can also use socks proxy with the following format:\n\n((How to test if your proxy works))[#test-if-your-proxy-works]\n\nAfter setting any of the above listed proxy properties in your ccxt snippet, you can test whether it works by pinging some IP echoing websites - check a \"proxy-usage\" file in examples.\n\n**Instead of setting a property, you can also use callbacks :\n\nIf you need for special cases, you can override property like:\n\nDepending your programming language, you can set custom proxy agents.\n• For JS, see this example\n• For Python, see the following examples: proxies-for-synchronous-python, proxy-asyncio-aiohttp-python-3, proxy-asyncio-aiohttp-socks, proxy-sync-python-requests-2-and-3\n\nCORS (known as Cross-Origin Resource Sharing) affects mostly browsers and is the cause of the well-know warning No 'Access-Control-Allow-Origin' header is present on the requested resource . It happens when a script (running in a browser) makes a request to a 3rd party domain (by default such requests are blocked, unless the target domain explicitly allows it). So, in such cases you will need to communicate with a \"CORS\" proxy, which would redirect requests (as opposed to direct browser-side request) to the target exchange. To set a CORS proxy, you can run sample-local-proxy-server-with-cors example file and in ccxt set the property to route requests through cors/proxy server.\n\nSome users might want to control how CCXT handles arithmetic operations. Even though it uses numeric types by default, users can switch to fixed-point math using string types. This can be done by:\n\nThe error handling with CCXT is done with the exception mechanism that is natively available with all languages.\n\nTo handle the errors you should add a block around the call to a unified method and catch the exceptions like you would normally do with your language:\n\nWhen dealing with HTTP requests, it's important to understand that requests might fail for various reasons. Common causes of these failures include the server being unavailable, network instability, or temporary server issues. To handle such scenarios gracefully, CCXT provide an option to automatically retry failed requests. You can set the value of and to configure the number of retries and the delay between retries, example:\n\nIt's important to highlight that only server/network-related issues will be part of the retry mechanism; if the user gets an error due to or the request will not be repeated.\n\nAll exceptions are derived from the base BaseError exception, which, in its turn, is defined in the ccxt library like so:\n\nThe exception inheritance hierarchy lives in this file: https://github.com/ccxt/ccxt/blob/master/ts/src/base/errorHierarchy.ts , and visually can be outlined like shown below:\n\nThe class is a generic root error class for all sorts of errors, including accessibility and request/response mismatch. If you don't need to catch any specific subclass of exceptions, you can just use , where all exception types are being caught.\n\nFrom derives two different families of errors: and (they also have their specific sub-types, as explained below).\n\nAn might happen when user sends correctly constructed & valid request to exchange, but a non-deterministic problem occurred:\n\nSuch exceptions are temporary and re-trying the request again might be enough. However, if the error still happens, then it may indicate some persistent problem with the exchange or with your connection.\n\nhas the following sub-types: , (includes sub-type ), , .\n\nThis exception is thrown in cases when cloud/hosting services (Cloudflare, Incapsula or etc..) limits requests from user/region/location or when the exchange API restricts user because of making abnormal requests. This exception also contains specific sub-type exception , which directly means that user makes much frequent requests than tolerated by exchange API engine.\n\nThis exception is raised when the connection with the exchange fails or data is not fully received in a specified amount of time. This is controlled by the exchange's property. When a is raised, the user doesn't know the outcome of a request (whether it was accepted by the exchange server or not).\n\nThus it's advised to handle this type of exception in the following manner:\n• for fetching requests it is safe to retry the call\n• for a request to a user is required to retry the same call the second time. A subsequent retry to will return one of the following possible results:\n• a request is completed successfully, meaning the order has been properly canceled now\n• an exception is raised, which means the order was either already canceled on the first attempt or has been executed (filled and closed) in the meantime between the two attempts.\n• if a request to fails with a the user should:\n• call , , to check if the request to place the order has succeeded and the order is now open\n• if the order is not the user should to check if the balance has changed since the order was created on the first run and then was filled and closed by the time of the second check.\n\nThis type of exception is thrown when the underlying exchange is unreachable. The ccxt library also throws this error if it detects any of the following keywords in response:\n\nRaised when your nonce is less than the previous nonce used with your keypair, as described in the Authentication section. This type of exception is thrown in these cases (in order of precedence for checking):\n• You are not rate-limiting your requests or sending too many of them too often.\n• Your API keys are not fresh and new (have been used with some different software or script already, just always create a new keypair when you add this or that exchange).\n• The same keypair is shared across multiple instances of the exchange class (for example, in a multithreaded environment or in separate processes).\n• Your system clock is out of synch. System time should be synched with UTC in a non-DST timezone at a rate of once every ten minutes or even more frequently because of the clock drifting. Enabling time synch in Windows is usually not enough! You have to set it up with the OS Registry (Google \"time synch frequency\" for your OS).\n\nIn contrast to , the is mostly happening when the request is impossible to succeed (because of factors listed below), so even if you retry the same request hundreds of times, they will still fail, because the request is being made incorrectly.\n\nPossible reasons for this exception:\n• endpoint is switched off by the exchange\n• symbol not found on the exchange\n• the format of parameters is incorrect\n• some problem happening on user-side that needs to be fixed\n\nhas the following sub-type exceptions:\n• : when the endpoint/operation is not offered or supported by the exchange API.\n• : user sends an incorrectly constructed request/parameter/action that is invalid/unallowed (i.e.: \"invalid number\", \"forbidden symbol\", \"size beyond min/max limits\", \"incorrect precision\", etc). Retrying would not help in this case, the request needs to be fixed/adjusted first.\n• - user sends a correctly constructed request (that should be accepted by the exchange in a typical case), but some deterministic factor prevents your request to succeed. For example, your current account status might not allow it (i.e. \"please close existing positions before changing the leverage\", \"too many pending orders\", \"your account in wrong position/margin mode\") or at the give moment symbol is not tradable (i.e. \"MarketClosed\") or some explained factors, where you need to take a specific action (i.e. change some setting at first, or wait till specific moment). So, once again: OperationFailed can be blindly re-tried and should success, while is a failure that depends on specific exact factors that need to be considered, before request can be retried.\n• : when an exchange requires one of the API credentials that you've missed to specify, or when there's a mistake in the keypair or an outdated nonce. Most of the time you need and , sometimes you also need and/or if exchange API requires it.\n• : when there's no access for specified action or insufficient permissions on the specified .\n• : when you don't have enough currency on your account balance to place an order.\n• : when encountering a bad funding address or a funding address shorter than (10 characters by default) in a call to , or .\n• : the base class for all exceptions related to the unified order API.\n• : when you are trying to fetch or cancel a non-existent order.\n\nIn case you experience any difficulty connecting to a particular exchange, do the following in order of precedence:\n• Make sure that you have the most recent version of ccxt. Never trust your package installer (whether it is , or ), instead always check your actual (real) runtime version number by running this code in your environment:\n• Check the Issues or Announcements for recent updates.\n• Make sure you have not turned off rate-limiter with (If anyone has custom rate-limit solution built, ensure it does not misbehave).\n• If you use ccxt's proxy functionality, ensure it does not misbehave.\n• Turn to get more detail about it! exchange = ccxt.binance() exchange.load_markets() exchange.verbose = True # for less noise, you can set that after `load_markets`, but if the error happens during `load_markets` then place this line before it # ... your codes here ... Your code to reproduce the issue + verbose output is required in order to get help.\n• Python people can turn on DEBUG logging level with a standard pythonic logger, by adding these two lines to the beginning of their code:\n• Use verbose mode to make sure that the used API credentials correspond to the keys you intend to use. Make sure there's no confusion of keypairs.\n• Try a fresh new keypair if possible.\n• Check the permissions on the keypair with the exchange website!\n• Check your nonce. If you used your API keys with other software, you most likely should override your nonce function to match your previous nonce value. A nonce usually can be easily reset by generating a new unused keypair. If you are getting nonce errors with an existing key, try with a new API key that hasn't been used yet.\n• Check your request rate if you are getting nonce errors. Your private requests should not follow one another quickly. You should not send them one after another in a split second or in short time. The exchange will most likely ban you if you don't make a delay before sending each new request. In other words, you should not hit their rate limit by sending unlimited private requests too frequently. Add a delay to your subsequent requests or enable the built-in rate-limiter, like shown in the long-poller examples, also here.\n• Read the docs for your exchange and compare your verbose output to the docs.\n• Check your connectivity with the exchange by accessing it with your browser.\n• Check your connection with the exchange through a proxy.\n• Try accesing the exchange from a different computer or a remote server, to see if this is a local or global issue with the exchange.\n• Check if there were any news from the exchange recently regarding downtime for maintenance. Some exchanges go offline for updates regularly (like once a week).\n• Make sure that your system time in sync with the rest of the world's clocks since otherwise you may get invalid nonce errors.\n• Use the option or instantiate your troublesome exchange with to see the HTTP requests and responses in details. The verbose output will also be of use for us to debug it if you submit an issue on GitHub.\n• Some exchanges are not available in certain countries, using a proxy might be the solution in such cases.\n• If you are getting authentication errors or 'invalid keys' errors, those are most likely due to a nonce issue.\n• Some exchanges do not state it clearly if they fail to authenticate your request. In those circumstances they might respond with an exotic error code, like HTTP 502 Bad Gateway Error or something that's even less related to the actual cause of the error."
    },
    {
        "link": "https://github.com/ccxt/ccxt",
        "document": "A JavaScript / Python / PHP / C# / Go library for cryptocurrency trading and e-commerce with support for many bitcoin/ether/altcoin exchange markets and merchant APIs.\n\nThe CCXT library is used to connect and trade with cryptocurrency exchanges and payment processing services worldwide. It provides quick access to market data for storage, analysis, visualization, indicator development, algorithmic trading, strategy backtesting, bot programming, and related software engineering.\n\nIt is intended to be used by coders, developers, technically-skilled traders, data-scientists and financial analysts for building trading algorithms.\n• support for many cryptocurrency exchanges — more coming soon\n• an out of the box unified API that is extremely easy to integrate\n• works in Node 10.4+, Python 3, PHP 8.1+, netstandard2.0/2.1, Go 1.20+ and web browsers\n• TabTrader – trading on all exchanges in one app. Available on Android and iOS!\n• TokenBot – discover and copy the best algorithmic traders in the world.\n\nThe CCXT library currently supports the following 106 cryptocurrency exchange markets and trading APIs:\n\nThe list above is updated frequently, new crypto markets, exchanges, bug fixes, and API endpoints are introduced on a regular basis. See the Manual for more details. If you can't find a cryptocurrency exchange in the list above and want it to be added, post a link to it by opening an issue here on GitHub or send us an email.\n\nThe library is under MIT license, that means it's absolutely free for any developer to build commercial and opensource software on top of it, but use it at your own risk with no warranties, as is.\n\nThe easiest way to install the CCXT library is to use a package manager:\n\nThis library is shipped as an all-in-one module implementation with minimalistic dependencies and requirements:\n• cs/ in C# (generated from TS)\n• go/ in Go (generated from TS)\n\nYou can also clone it into your project directory from ccxt GitHub repository:\n\nJavaScript version of CCXT works in both Node and web browsers. Requires ES6 and syntax support (Node 7.6.0+). When compiling with Webpack and Babel, make sure it is not excluded in your config.\n\nAll-in-one browser bundle (dependencies included), served from a CDN of your choice:\n\nCDNs are not updated in real-time and may have delays. Defaulting to the most recent version without specifying the version number is not recommended. Please, keep in mind that we are not responsible for the correct operation of those CDN servers.\n\nThe library supports concurrent asynchronous mode with asyncio and async/await in Python 3.7.0+\n\nCCXT also supports for parsing JSON since it is much faster than the builtin library. This is especially important when using websockets because some exchanges return big messages that need to be parsed and dispatched as quickly as possible.\n\nHowever, is not enabled by default because it is not supported by every python interpreter. If you want to opt-in, you just need to install it ( ) on your local environment. CCXT will detect the installion and pick it up automatically.\n\nThe library supports concurrent asynchronous mode using tools from ReactPHP in PHP 8.1+. Read the Manual for more details.\n\nccxt in C# with Nuget (netstandard 2.0 and netstandard 2.1)\n\nccxt in GO with PKG\n\nYou can get CCXT installed in a container along with all the supported languages and dependencies. This may be useful if you want to contribute to CCXT (e.g. run the build scripts and tests — please see the Contributing document for the details on that).\n\nUsing (in the cloned CCXT repository):\n\nYou don't need the Docker image if you're not going to develop CCXT. If you just want to use CCXT – just install it as a regular package into your project.\n\nRead the Manual for more details.\n\nThe CCXT library consists of a public part and a private part. Anyone can use the public part immediately after installation. Public APIs provide unrestricted access to public information for all exchange markets without the need to register a user account or have an API key.\n\nIn order to trade with private APIs you need to obtain API keys from an exchange's website. It usually means signing up to the exchange and creating API keys for your account. Some exchanges require personal info or identification. Sometimes verification may be necessary as well. In this case you will need to register yourself, this library will not create accounts or API keys for you. Some exchanges expose API endpoints for registering an account, but most exchanges don't. You will have to sign up and create API keys on their websites.\n\nPrivate APIs allow the following:\n\nThis library implements full public and private REST and WebSocket APIs for all exchanges in TypeScript, JavaScript, PHP and Python.\n\nThe CCXT library supports both camelcase notation (preferred in TypeScript and JavaScript) and underscore notation (preferred in Python and PHP), therefore all methods can be called in either notation or coding style in any language.\n\nRead the Manual for more details.\n\nUnlike Javascript/Python/PHP/C# Go does not support \"traditional\" optional parameters like . However, the CCXT language and structure have some methods with optional params, and since the Go language is transpiled from the Typescript source, we had to find a way of representing them.\n\nWe have decided to \"go\" (pun intended) with Option structs and the methods.\n\nFor example, this function supports 4 different \"optional\" parameters, symbol, since, limit, and params.\n\nAnd we can provide them by doing\n\nLastly, just because the signature dictates that some argument like is optional, it will depend from exchange to exchange and you might need to provide it to avoid getting a error.\n\nYou can check different examples in the folder.\n\nPlease read the CONTRIBUTING document before making changes that you would like adopted in the code. Also, read the Manual for more details.\n\nWe are investing a significant amount of time into the development of this library. If CCXT made your life easier and you want to help us improve it further, or if you want to speed up development of new features and exchanges, please support us with a tip. We appreciate all contributions!\n\nSupport this project by becoming a sponsor.\n\nSupport this project by becoming a supporter. Your avatar will show up here with a link to your website.\n\nThank you to all our backers! [Become a backer]"
    },
    {
        "link": "https://stackoverflow.com/questions/59326406/how-to-make-a-binance-futures-order-with-ccxt-in-python",
        "document": "How can I place a market order in ccxt for binance futures? Trading on binance futures with ccxt is already implemented\n\nIn this post they suggest to use this line of code:\n\nThe above line was written in JavaScript. How would the equivalent line in python look like? Like this I get an error:"
    },
    {
        "link": "https://pypi.org/project/ccxt",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://github.com/ccxt/ccxt/wiki/manual",
        "document": "The ccxt library is a collection of available crypto exchanges or exchange classes. Each class implements the public and private API for a particular crypto exchange. All exchanges are derived from the base Exchange class and share a set of common methods. To access a particular exchange from ccxt library you need to create an instance of corresponding exchange class. Supported exchanges are updated frequently and new exchanges are added regularly.\n\nThe structure of the library can be outlined as follows:\n\nFull public and private HTTP REST APIs for all exchanges are implemented. WebSocket implementations in JavaScript, PHP, Python are available in CCXT Pro, which is a professional addon to CCXT with support for WebSocket streams.\n\nThe CCXT library currently supports the following 106 cryptocurrency exchange markets and trading APIs:\n\nBesides making basic market and limit orders, some exchanges offer margin trading (leverage), various derivatives (like futures contracts and options) and also have dark pools, OTC (over-the-counter trading), merchant APIs and much more.\n\nTo connect to an exchange and start trading you need to instantiate an exchange class from ccxt library.\n\nTo get the full list of ids of supported exchanges programmatically:\n\nAn exchange can be instantiated like shown in the examples below:\n\nThe ccxt library in PHP uses builtin UTC/GMT time functions, therefore you are required to set date.timezone in your php.ini or call date_default_timezone_set() function before using the PHP version of the library. The recommended timezone setting is .\n\nMajor exchanges have the property available, where you can see what methods and functionalities are supported for each market-type (if any method is set to it means method is \"not supported\" by the exchange)\n\nthis feature is currently a work in progress and might be incomplete, feel free to report any issues you find in it\n\nMost of exchange properties as well as specific options can be overrided upon exchange class instantiation or afterwards, like shown below:\n\nIn all CCXT-supported languages, you can override instance methods during runtime:\n\nSome exchanges also offer separate APIs for testing purposes that allows developers to trade virtual money for free and test out their ideas. Those APIs are called \"testnets\", \"sandboxes\" or \"staging environments\" (with virtual testing assets) as opposed to \"mainnets\" and \"production environments\" (with real assets). Most often a sandboxed API is a clone of a production API, so, it's literally the same API, except for the URL to the exchange server.\n\nCCXT unifies that aspect and allows the user to switch to the exchange's sandbox (if supported by the underlying exchange). To switch to the sandbox one has to call the or immediately after creating the exchange before any other call!\n• The has to be your first call immediately after creating the exchange (before any other calls)\n• To obtain the API keys to the sandbox the user has to register with the sandbox website of the exchange in question and create a sandbox keypair\n• Sandbox keys are not interchangeable with production keys!\n\nEvery exchange has a set of properties and methods, most of which you can override by passing an associative array of params to an exchange constructor. You can also make a subclass and override everything.\n\nHere's an overview of generic exchange properties with values added for example:\n\nBelow is a detailed description of each of the base exchange properties:\n• : Each exchange has a default id. The id is not used for anything, it's a string literal for user-land exchange instance identification purposes. You can have multiple links to the same exchange and differentiate them by ids. Default ids are all lowercase and correspond to exchange names.\n• : This is a string literal containing the human-readable exchange name.\n• : An array of string literals of 2-symbol ISO country codes, where the exchange is operating from.\n• : The single string literal base URL for API calls or an associative array of separate URLs for private and public APIs.\n• : A single string URL link to original documentation for exchange API on their website or an array of links to docs.\n• : A string literal containing version identifier for current exchange API. The ccxt library will append this version string to the API Base URL upon each request. You don't have to modify it, unless you are implementing a new exchange API. The version identifier is a usually a numeric string starting with a letter 'v' in some cases, like v1.1. Do not override it unless you are implementing your own new crypto exchange class.\n• : An associative array containing a definition of all API endpoints exposed by a crypto exchange. The API definition is used by ccxt to automatically construct callable instance methods for each available endpoint.\n• : This is an associative array of exchange capabilities (e.g , or ).\n• : An associative array of timeframes, supported by the fetchOHLCV method of the exchange. This is only populated when property is true.\n• : A timeout in milliseconds for a request-response roundtrip (default timeout is 10000 ms = 10 seconds). If the response is not received in that time, the library will throw an exception. You can leave the default timeout value or set it to a reasonable value. Hanging forever with no timeout is not your option, for sure. You don't have to override this option in general case.\n• : A request rate limit in milliseconds. Specifies the required minimal delay between two consequent HTTP requests to the same exchange. The built-in rate-limiter is enabled by default and can be turned off by setting the property to false.\n• : A boolean (true/false) value that enables the built-in rate limiter and throttles consecutive requests. This setting is (enabled) by default. The user is required to implement own rate limiting or leave the built-in rate limiter enabled to avoid being banned from the exchange.\n• : An object to set HTTP User-Agent header to. The ccxt library will set its User-Agent by default. Some exchanges may not like it. If you are having difficulties getting a reply from an exchange and want to turn User-Agent off or use the default one, set this value to false, undefined, or an empty string. The value of may be overrided by HTTP property below.\n• : An associative array of HTTP headers and their values. Default value is empty . All headers will be prepended to all requests. If the header is set within , it will override whatever value is set in the property above.\n• : A boolean flag indicating whether to log HTTP requests to stdout (verbose flag is false by default). Python people have an alternative way of DEBUG logging with a standard pythonic logger, which is enabled by adding these two lines to the beginning of their code:\n• : An associative array of markets indexed by common trading pairs or symbols. Markets should be loaded prior to accessing this property. Markets are unavailable until you call the method on exchange instance.\n• : A non-associative array (a list) of symbols available with an exchange, sorted in alphabetical order. These are the keys of the property. Symbols are loaded and reloaded from markets. This property is a convenient shorthand for all market keys.\n• : An associative array (a dict) of currencies by codes (usually 3 or 4 letters) available with an exchange. Currencies are loaded and reloaded from markets.\n• : An associative array of arrays of markets indexed by exchange-specific ids. Typically a length one array unless there are multiple markets with the same marketId. Markets should be loaded prior to accessing this property.\n• : This is your public API key string literal. Most exchanges require API keys setup.\n• : Your private secret API key string literal. Most exchanges require this as well together with the apiKey.\n• : A string literal with your password/phrase. Some exchanges require this parameter for trading, but most of them don't.\n• : A unique id of your account. This can be a string literal or a number. Some exchanges also require this for trading, but most of them don't.\n• : A unified associative dictionary that shows which of the above API credentials are required for sending private API calls to the underlying exchange (an exchange may require a specific set of keys).\n• : An exchange-specific associative dictionary containing special keys and options that are accepted by the underlying exchange and supported in CCXT.\n• : The exchange decimal precision counting mode, read more about Precision And Limits\n• For proxies - , , , , , , : An url of specific proxy. Read details in Proxy section.\n\nSee this section on Overriding exchange properties.\n• : An assoc-array containing flags for exchange capabilities, including the following: : : // has Cross-Origin Resource Sharing enabled (works from browser) or not // unified methods availability flags (can be true, false, or 'emulated'): : : : : : : : : : : : : : : : : : : : : : : : ... The meaning of each flag showing availability of this or that method is:\n• a value of / / means the method is not currently implemented in ccxt (either ccxt has not unified it yet or the method isn't natively available from the exchange API)\n• boolean specifically means that the endpoint isn't natively available from the exchange API\n• boolean means the endpoint is natively available from the exchange API and unified in the ccxt library\n• string means the endpoint isn't natively available from the exchange API but reconstructed (as much as possible) by the ccxt library from other available true-methods For a complete list of all exchages and their supported methods, please, refer to this example: https://github.com/ccxt/ccxt/blob/master/examples/js/exchange-capabilities.js\n\nExchanges usually impose what is called a rate limit. Exchanges will remember and track your user credentials and your IP address and will not allow you to query the API too frequently. They balance their load and control traffic congestion to protect API servers from (D)DoS and misuse.\n\nWARNING: Stay under the rate limit to avoid ban!\n\nMost exchanges allow up to 1 or 2 requests per second. Exchanges may temporarily restrict your access to their API or ban you for some period of time if you are too aggressive with your requests.\n\nThe property is set to a safe default which is sub-optimal. Some exchanges may have varying rate limits for different endpoints. It is up to the user to tweak according to application-specific purposes.\n\nThe CCXT library has a built-in experimental rate-limiter that will do the necessary throttling in background transparently to the user. WARNING: users are responsible for at least some type of rate-limiting: either by implementing a custom algorithm or by doing it with the built-in rate-limiter..\n\nYou can turn on/off the built-in rate-limiter with property, like so:\n\nIn case your calls hit a rate limit or get nonce errors, the ccxt library will throw an exception, or, in some cases, one of the following types:\n\nA later retry is usually enough to handle that.\n\nThe rate limiter is a property of the exchange instance, in other words, each exchange instance has its own rate limiter that is not aware of the other instances. In many cases the user should reuse the same exchange instance throughout the program. Do not use multiple instances of the same exchange with the same API keypair from the same IP address.\n\nReuse the exchange instance as much as possible as shown below:\n\nSince the rate limiter belongs to the exchange instance, destroying the exchange instance will destroy the rate limiter as well. Among the most common pitfalls with the rate limiting is creating and dropping the exchange instance over and over again. If in your program you are creating and destroying the exchange instance (say, inside a function that is called multiple times), then you are effectively resetting the rate limiter over and over and that will eventually break the rate limits. If you are recreating the exchange instance every time instead of reusing it, CCXT will try to load the markets every time. Therefore, you will force-load the markets over and over as explained in the Loading Markets section. Abusing the markets endpoint will eventually break the rate limiter as well.\n\nDo not break this rule unless you really understand the inner workings of the rate-limiter and you are 100% sure you know what you're doing. In order to stay safe always reuse the exchange instance throughout your functions and methods callchain like shown below:\n\nSome exchanges are DDoS-protected by Cloudflare or Incapsula. Your IP can get temporarily blocked during periods of high load. Sometimes they even restrict whole countries and regions. In that case their servers usually return a page that states a HTTP 40x error or runs an AJAX test of your browser / captcha test and delays the reload of the page for several seconds. Then your browser/fingerprint is granted access temporarily and gets added to a whitelist or receives a HTTP cookie for further use.\n\nThe most common symptoms for a DDoS protection problem, rate-limiting problem or for a location-based filtering issue:\n• Getting exceptions with all types of exchange methods\n• Catching or with HTTP error codes 400, 403, 404, 429, 500, 501, 503, etc..\n• Getting a template HTML page instead of JSON from the exchange\n\nIf you encounter DDoS protection errors and cannot reach a particular exchange then:\n• use a proxy (this is less responsive, though)\n• ask the exchange support to add you to a whitelist\n• try an alternative IP within a different geographic region\n• run your software in a distributed network of servers\n• run your software in close proximity to the exchange (same country, same city, same datacenter, same server rack, same server)\n\nEach exchange is a place for trading some kinds of valuables. The exchanges may use differing terms to call them: \"a currency\", \"an asset\", \"a coin\", \"a token\", \"stock\", \"commodity\", \"crypto\", \"fiat\", etc. A place for trading one asset for another is usually called \"a market\", \"a symbol\", \"a trading pair\", \"a contract\", etc.\n\nIn terms of the ccxt library, every exchange offers multiple markets within itself. Each market is defined by two or more currencies. The set of markets differs from exchange to exchange opening possibilities for cross-exchange and cross-market arbitrage.\n\nEach currency is an associative array (aka dictionary) with the following keys:\n• . The string or numeric ID of the currency within the exchange. Currency ids are used inside exchanges internally to identify coins during the request/response process.\n• . An uppercase string code representation of a particular currency. Currency codes are used to reference currencies within the ccxt library (explained below).\n• . A human-readable name of the currency (can be a mix of uppercase & lowercase characters).\n• . The withdrawal fee value as specified by the exchange. In most cases it means a flat fixed amount paid in the same currency. If the exchnange does not specify it via public endpoints, the can be or missing.\n• . A boolean indicating whether trading or funding (depositing or withdrawing) for this currency is currently possible, more about it here: status.\n• . An associative array of non-common market properties, including fees, rates, limits and other general market information. The internal info array is different for each particular market, its contents depend on the exchange.\n• . Precision accepted in values by exchanges upon referencing this currency. The value of this property depends on .\n• . The minimums and maximums for amounts (volumes), withdrawals and deposits.\n\nEach network is an associative array (aka dictionary) with the following keys:\n• . The string or numeric ID of the network within the exchange. Network ids are used inside exchanges internally to identify networks during the request/response process.\n• . An uppercase string representation of a particular network. Networks are used to reference networks within the ccxt library.\n• . A human-readable name of the network (can be a mix of uppercase & lowercase characters).\n• . The withdrawal fee value as specified by the exchange. In most cases it means a flat fixed amount paid in the same currency. If the exchnange does not specify it via public endpoints, the can be or missing.\n• . A boolean indicating whether trading or funding (depositing or withdrawing) for this currency is currently possible, more about it here: status.\n• . An associative array of non-common market properties, including fees, rates, limits and other general market information. The internal info array is different for each particular market, its contents depend on the exchange.\n• . Precision accepted in values by exchanges upon referencing this currency. The value of this property depends on .\n• . The minimums and maximums for amounts (volumes), withdrawals and deposits.\n\nEach market is an associative array (aka dictionary) with the following keys:\n• . The string or numeric ID of the market or trade instrument within the exchange. Market ids are used inside exchanges internally to identify trading pairs during the request/response process.\n• . An uppercase string code representation of a particular trading pair or instrument. This is usually written as with a slash as in , or , etc. Symbols are used to reference markets within the ccxt library (explained below).\n• . A unified uppercase string code of base fiat or crypto currency. This is the standardized currency code that is used to refer to that currency or token throughout CCXT and throughout the Unified CCXT API, it's the language that CCXT understands.\n• . An exchange-specific id of the base currency for this market, not unified. Can be any string, literally. This is communicated to the exchange using the language the exchange understands.\n• . An exchange-specific id of the quote currency, not unified.\n• . A boolean indicating whether or not trading this market is currently possible, more about it here: status.\n• . Float, 0.0015 = 0.15%. Maker fees are paid when you provide liquidity to the exchange i.e. you market-make an order and someone else fills it. Maker fees are usually lower than taker fees. Fees can be negative, this is very common amongst derivative exchanges. A negative fee means the exchange will pay a rebate (reward) to the user for trading this market (note, 'taker' and 'maker' publicly available fees, not taking into consideration your vip-level/volume/etc. Use to get the fees specific to your account).\n• . Float, 0.002 = 0.2%. Taker fees are paid when you take liquidity from the exchange and fill someone else's order.\n• . A boolean true/false value indicating whether and are multipliers or fixed flat amounts.\n• . A boolean true/false value indicating whether the fee depends on your trading tier (usually, your traded volume over a period of time).\n• . An associative array of non-common market properties, including fees, rates, limits and other general market information. The internal info array is different for each particular market, its contents depend on the exchange.\n• . Precision accepted in order values by exchanges upon order placement for price, amount and cost. (The value inside this property depend on the ).\n• . The minimums and maximums for prices, amounts (volumes) and costs (where cost = price * amount).\n• . The type of the option, option represents an option with the right to buy and an option with the right to sell.\n• . Price at which an option can be bought or sold when it is exercised.\n\nThe flag is typically used in and . The exchanges might put a slightly different meaning into it. If a currency is inactive, most of the time all corresponding tickers, orderbooks and other related endpoints return empty responses, all zeroes, no data or outdated information. The user should check if the currency is and reload markets periodically.\n\nNote: the value for the property doesn't always guarantee that all of the possible features like trading, withdrawing or depositing are disabled on the exchange. Likewise, neither the value guarantees that all those features are enabled on the exchange. Check the underlying exchanges' documentation and the code in CCXT for the exact meaning of the flag for this or that exchange. This flag is not yet supported or implemented by all markets and may be missing.\n\nWARNING! The information about the fee is experimental, unstable and may be partial or not available at all.\n\nDo not confuse with ! Precision has nothing to do with min limits. A precision of 8 digits does not necessarily mean a min limit of 0.00000001. The opposite is also true: a min limit of 0.0001 does not necessarily mean a precision of 4.\n\nIn this example the amount of any order placed on the market must satisfy both conditions:\n• The amount value should be >= 0.05:\n• Precision of the amount should be up to 4 decimal digits:\n\nIn this example the price of any order placed on the market must satisfy both conditions:\n• The price value should be >= 0.019:\n• Precision of price should be 5 decimal digits or less:\n\nIn this example both conditions must be satisfied:\n• The amount value should be greater than or equal to 50:\n• A negative amount precision means that the amount should be an integer multiple of 10 (to the absolute power specified):\n\nThe and params are currently under heavy development, some of these fields may be missing here and there until the unification process is complete. This does not influence most of the orders but can be significant in extreme cases of very large or very small orders.\n\nThe user is required to stay within all limits and precision! The values of the order should satisfy the following conditions:\n• Precision of must be <=\n• Precision of must be <=\n\nThe above values can be missing with some exchanges that don't provide info on limits from their API or don't have it implemented yet.\n\nEach exchange has its own rounding, counting and padding modes.\n• – will round the last decimal digits to precision\n• – will cut off the digits after certain precision\n\nThe decimal precision counting mode is available in the property.\n• – counts all digits, 99% of exchanges use this counting mode. With this mode of precision, the numbers in designate the number of decimal digits after the dot for further rounding or truncation.\n• – counts non-zero digits only, some exchanges ( and maybe a few other) implement this mode of counting decimals. With this mode of precision, the numbers in designate the Nth place of the last significant (non-zero) decimal digit after the dot.\n• – some exchanges only allow a multiple of a specific value ( uses this mode, for example). In this mode, the numbers in designate the minimal precision fractions (floats) for rounding or truncating.\n• – appends zero characters up to precision\n\nMost of the time the user does not have to take care of precision formatting, since CCXT will handle that for the user when the user places orders or sends withdrawal requests, if the user follows the rules as described on Precision And Limits. However, in some cases precision-formatting details may be important, so the following methods may be useful in the userland.\n\nThe exchange base class contains the method to help format values to the required decimal precision with support for different rounding, counting and padding modes.\n\nFor examples of how to use the to format strings and floats, please, see the following files:\n\nPython WARNING! The method is susceptible to\n\nFor users' convenience CCXT base exchange class also implements the following methods:\n\nEvery exchange has its own precision settings, the above methods will help format those values according to exchange-specific precision rules, in a way that is portable and agnostic of the underlying exchange. In order to make that possible, markets and currencies have to be loaded prior to formatting any values.\n\nMake sure to load the markets with before calling these methods!\n\nMore practical examples that describe the behavior of :\n\nIn most cases you are required to load the list of markets and trading symbols for a particular exchange prior to accessing other API methods. If you forget to load markets the ccxt library will do that automatically upon your first call to the unified API. It will send two HTTP requests, first for markets and then the second one for other data, sequentially. For that reason, your first call to a unified CCXT API method like fetchTicker, fetchBalance, etc will take more time, than the consequent calls, since it has to do more work loading the market information from the exchange API. See Notes On Rate Limiter for more details.\n\nIn order to load markets manually beforehand call the / method on an exchange instance. It returns an associative array of markets indexed by trading symbol. If you want more control over the execution of your logic, preloading markets by hand is recommended.\n\nApart from the market info, the call will also load the currencies from the exchange and will cache the info in the and the properties respectively.\n\nThe user can also bypass the cache and call unified methods for fetching that information from the exchange endpoints directly, and , though using these methods is not recommended for end-users. The recommended way to preload markets is by calling the unified method. However, new exchange integrations are required to implement these methods if the underlying exchange has the corresponding API endpoints.\n\nA currency code is a code of three to five letters, like , , , , , , , , , , , etc. Some exchanges have exotic currencies with longer codes.\n\nA symbol is usually an uppercase string literal name of a pair of traded currencies with a slash in between. The first currency before the slash is usually called base currency, and the one after the slash is called quote currency. Examples of a symbol are: , , , , , , .\n\nMarket ids are used during the REST request-response process to reference trading pairs within exchanges. The set of market ids is unique per exchange and cannot be used across exchanges. For example, the BTC/USD pair/market may have different ids on various popular exchanges, like , , , , (numeric id), , , , . You don't need to remember or use market ids, they are there for internal HTTP request-response purposes inside exchange implementations.\n\nThe ccxt library abstracts uncommon market ids to symbols, standardized to a common format. Symbols aren't the same as market ids. Every market is referenced by a corresponding symbol. Symbols are common across exchanges which makes them suitable for arbitrage and many other things.\n\nSometimes the user might notice a symbol like or or some other \"exotic/rare symbols\". The symbol is not required to have a slash or to be a pair of currencies. The string in the symbol really depends on the type of the market (whether it is a spot market or a futures market, a darkpool market or an expired market, etc). Attempting to parse the symbol string is highly discouraged, one should not rely on the symbol format, it is recommended to use market properties instead.\n\nMarket structures are indexed by symbols and ids. The base exchange class also has builtin methods for accessing markets by symbols. Most API methods require a symbol to be passed in their first argument. You are often required to specify a symbol when querying current prices, making orders, etc.\n\nMost of the time users will be working with market symbols. You will get a standard userland exception if you access non-existent keys in these dicts.\n\nThere is a bit of term ambiguity across various exchanges that may cause confusion among newcoming traders. Some exchanges call markets as pairs, whereas other exchanges call symbols as products. In terms of the ccxt library, each exchange contains one or more trading markets. Each market has an id and a symbol. Most symbols are pairs of base currency and quote currency.\n\nHistorically various symbolic names have been used to designate same trading pairs. Some cryptocurrencies (like Dash) even changed their names more than once during their ongoing lifetime. For consistency across exchanges the ccxt library will perform the following known substitutions for symbols and currencies:\n• : is newer but is more common among exchanges and sounds more like bitcoin (read more).\n• : The Bitcoin Cash fork is often called with two different symbolic names: and . The name is ambiguous for Bitcoin Cash, it is confused with BitConnect. The ccxt library will convert to where it is appropriate (some exchanges and aggregators confuse them).\n• : was Darkcoin then became Dash (read more).\n• : On November 15 2018 Bitcoin Cash forked the second time, so, now there is (for BCH ABC) and (for BCH SV).\n• : This is a common substitution mapping for the Bitcoin Cash SV fork (some exchanges call it , others call it , we use the former).\n• : Try not to confuse symbols and currencies. The (Dashcoin) is not the same as (Dash). Some exchanges have labelled inconsistently as , the ccxt library does a correction for that as well ( ), but only on certain exchanges that have these two currencies confused, whereas most exchanges have them both correct. Just remember that is not the same as .\n• → : is the newer code for RaiBlocks, thus, CCXT unified API uses will replace the older with where needed. https://hackernoon.com/nano-rebrand-announcement-9101528a7b76\n• → : Some exchanges, like Bitfinex, HitBTC and a few other name the currency as in their listings, but those markets are actually trading . The confusion can come from a 3-letter limitation on symbol names or may be due to other reasons. In cases where the traded currency is actually and is not – the CCXT library will perform → conversion. Note, however, that some exchanges have both and symbols, for example, Kraken has a trading pair.\n\nEach exchange has an associative array of substitutions for cryptocurrency symbolic codes in the property, like:\n\nwhere key represents actual name how exchange engine refers to that coin, and the value represents what you want to refer to it with through ccxt.\n\nSometimes the user may notice exotic symbol names with mixed-case words and spaces in the code. The logic behind having these names is explained by the rules for resolving conflicts in naming and currency-coding when one or more currencies have the same symbolic code with different exchanges:\n• First, we gather all info available from the exchanges themselves about the currency codes in question. They usually have a description of their coin listings somewhere in their API or their docs, knowledgebases or elsewhere on their websites.\n• When we identify each particular cryptocurrency standing behind the currency code, we look them up on CoinMarketCap.\n• The currency that has the greatest market capitalization of all wins the currency code and keeps it. For example, HOT often stand for either or . In this case retains the code , and will have its name as its code, literally, . So, there may be trading pairs with symbols like (for ) and – those are two different markets.\n• If market cap of a particular coin is unknown or is not enough to determine the winner, we also take trading volumes and other factors into consideration.\n• When the winner is determined all other competing currencies get their code names properly remapped and substituted within conflicting exchanges via . Note, it should be defined before '.loadMarkets()' happens!\n• Unfortunately this is a work in progress, because new currencies get listed daily and new exchanges are added from time to time, so, in general this is a never-ending process of self-correction in a quickly changing environment, practically, in \"live mode\". We are thankful for all reported conflicts and mismatches you may find.\n\nIs it possible for symbols to change?\n\nIn short, yes, sometimes, but rarely. Symbolic mappings can be changed if that is absolutely required and cannot be avoided. However, all previous symbolic changes were related to resolving conflicts or forks. So far, there was no precedent of a market cap of one coin overtaking another coin with the same symbolic code in CCXT.\n\nCan we rely on always listing the same crypto with the same symbol?\n\nMore or less ) First, this library is a work in progress, and it is trying to adapt to the everchanging reality, so there may be conflicts that we will fix by changing some mappings in the future. Ultimately, the license says \"no warranties, use at your own risk\". However, we don't change symbolic mappings randomly all over the place, because we understand the consequences and we'd want to rely on the library as well and we don't like to break the backward-compatibility at all.\n\nIf it so happens that a symbol of a major token is forked or has to be changed, then the control is still in the users' hands. The property can be overrided upon initialization or later, just like any other exchange property. If a significant token is involved, we usually post instructions on how to retain the old behavior by adding a couple of lines to the constructor params.\n\nIt depends on which exchange you are using, but some of them have a reversed (inconsistent) pairing of and . They actually have base and quote misplaced (switched/reversed sides). In that case you'll see a difference of parsed and currency values with the unparsed in the market substructure.\n\nFor those exchanges the ccxt will do a correction, switching and normalizing sides of base and quote currencies when parsing exchange replies. This logic is financially and terminologically correct. If you want less confusion, remember the following rule: base is always before the slash, quote is always after the slash in any symbol and with any market.\n\nWe currently load spot markets with the unified symbol schema into the mapping, indexed by symbol. This would cause a naming conflict for futures and other derivatives that have the same symbol as their spot market counterparts. To accomodate both types of markets in the we require the symbols between 'future' and 'spot' markets to be distinct, as well as the symbols between 'linear' and 'inverse' contracts to be distinct.\n\nCCXT supports the following types of derivative contracts:\n• – for expiring futures contracts that have a delivery/settlement date\n• – for perpetual swap futures that don't have a delivery date\n\nA future market symbol consists of the underlying currency, the quoting currency, the settlement currency and an arbitrary identifier. Most often the identifier is the settlement date of the future contract in format:\n\nThe is also a dirty method with a side effect of saving the array of markets on the exchange instance. You only need to call it once per exchange. All subsequent calls to the same method will return the locally saved (cached) array of markets.\n\nWhen exchange markets are loaded, you can then access market information any time via the property. This property contains an associative array of markets indexed by symbol. If you need to force reload the list of markets after you have them loaded already, pass the reload = true flag to the same method again.\n\nEach exchange offers a set of API methods. Each method of the API is called an endpoint. Endpoints are HTTP URLs for querying various types of information. All endpoints return JSON in response to client requests.\n\nUsually, there is an endpoint for getting a list of markets from an exchange, an endpoint for retrieving an order book for a particular market, an endpoint for retrieving trade history, endpoints for placing and canceling orders, for money deposit and withdrawal, etc... Basically every kind of action you could perform within a particular exchange has a separate endpoint URL offered by the API.\n\nBecause the set of methods differs from exchange to exchange, the ccxt library implements the following:\n• a public and private API for all possible URLs and methods\n\nThe endpoint URLs are predefined in the property for each exchange. You don't have to override it, unless you are implementing a new exchange API (at least you should know what you're doing).\n\nMost of exchange-specific API methods are implicit, meaning that they aren't defined explicitly anywhere in code. The library implements a declarative approach for defining implicit (non-unified) exchanges' API methods.\n\nEach method of the API usually has its own endpoint. The library defines all endpoints for each particular exchange in the property. Upon exchange construction an implicit magic method (aka partial function or closure) will be created inside on the exchange instance for each endpoint from the list of endpoints. This is performed for all exchanges universally. Each generated method will be accessible in both and notations.\n\nThe endpoints definition is a full list of ALL API URLs exposed by an exchange. This list gets converted to callable methods upon exchange instantiation. Each URL in the API endpoint list gets a corresponding callable method. This is done automatically for all exchanges, therefore the ccxt library supports all possible URLs offered by crypto exchanges.\n\nEach implicit method gets a unique name which is constructed from the definition. For example, a private HTTPS PUT endpoint will have a corresponding exchange method named / . A public HTTPS GET endpoint would result in the corresponding method named / , and so on.\n\nAn implicit method takes a dictionary of parameters, sends the request to the exchange and returns an exchange-specific JSON result from the API as is, unparsed. To pass a parameter, add it to the dictionary explicitly under a key equal to the parameter's name. For the examples above, this would look like and .\n\nThe recommended way of working with exchanges is not using exchange-specific implicit methods but using the unified ccxt methods instead. The exchange-specific methods should be used as a fallback in cases when a corresponding unified method isn't available (yet).\n\nTo get a list of all available methods with an exchange instance, including implicit methods and unified methods you can simply do the following:\n\nAPI URLs are often grouped into two sets of methods called a public API for market data and a private API for trading and account access. These groups of API methods are usually prefixed with a word 'public' or 'private'.\n\nA public API is used to access market data and does not require any authentication whatsoever. Most exchanges provide market data openly to all (under their rate limit). With the ccxt library anyone can access market data out of the box without having to register with the exchanges and without setting up account keys and passwords.\n\nThe private API is mostly used for trading and for accessing account-specific private data, therefore it requires authentication. You have to get the private API keys from the exchanges. It often means registering with an exchange website and creating the API keys for your account. Most exchanges require personal information or identification. Some exchanges will only allow trading after completing the KYC verification. Private APIs allow the following:\n\nSome exchanges offer the same logic under different names. For example, a public API is also often called market data, basic, market, mapi, api, price, etc... All of them mean a set of methods for accessing data available to public. A private API is also often called trading, trade, tapi, exchange, account, etc...\n\nA few exchanges also expose a merchant API which allows you to create invoices and accept crypto and fiat payments from your clients. This kind of API is often called merchant, wallet, payment, ecapi (for e-commerce).\n\nTo get a list of all available methods with an exchange instance, you can simply do the following:\n\ncontract only and margin only\n• methods in this documentation that are documented as contract only or margin only are only intended to be used for contract trading and margin trading respectively. They may work when trading in other types of markets but will most likely return irrelevant information.\n\nIn the JavaScript version of CCXT all methods are asynchronous and return Promises that resolve with a decoded JSON object. In CCXT we use the modern async/await syntax to work with Promises. If you're not familiar with that syntax, you can read more about it here.\n\nThe ccxt library supports asynchronous concurrency mode in Python 3.5+ with async/await syntax. The asynchronous Python version uses pure asyncio with aiohttp. In async mode you have all the same properties and methods, but most methods are decorated with an async keyword. If you want to use async mode, you should link against the subpackage, like in the following example:\n\nCCXT support PHP 8+ versions. The library has both synchronous and asynchronous versions. To use synchronous version, use namespace (i.e. ) and to use asynchronous version, use namespace (i.e. ). Asynchronous version uses ReactPHP library in the background. In async mode you have all the same properties and methods, but any networking API method should be decorated with the keyword and your script should be in a ReactPHP wrapper:\n\nSee further examples in the directory; look for filenames that include the word. Also, make sure you have installed the required dependencies using . Lastly, this article provides a good introduction to the methods used here. While syntactically the change is simple (i.e., just using a keyword before relevant methods), concurrency has significant implications for the overall design of your code.\n\nAll public and private API methods return raw decoded JSON objects in response from the exchanges, as is, untouched. The unified API returns JSON-decoded objects in a common format and structured uniformly across all exchanges.\n\nThe set of all possible API endpoints differs from exchange to exchange. Most of methods accept a single associative array (or a Python dict) of key-value parameters. The params are passed as follows:\n\nThe unified methods of exchanges might expect and will accept various which affect their functionality, like:\n\nAn exchange will not accept the params from a different exchange, they're not interchangeable. The list of accepted parameters is defined by each specific exchange.\n\nTo find which parameters can be passed to a unified method:\n• either open the exchange-specific implementation file and search for the desired function (i.e. ) to inspect and find out the details of usage\n• or go to the exchange's API docs and read the list of parameters for your specific function or endpoint (i.e. )\n\nFor a full list of accepted method parameters for each exchange, please consult API docs.\n\nAn exchange method name is a concatenated string consisting of type (public or private), HTTP method (GET, POST, PUT, DELETE) and endpoint URL path like in the following examples:\n\nThe ccxt library supports both camelcase notation (preferred in JavaScript) and underscore notation (preferred in Python and PHP), therefore all methods can be called in either notation or coding style in any language. Both of these notations work in JavaScript, Python and PHP:\n\nTo get a list of all available methods with an exchange instance, you can simply do the following:\n\nThe unified ccxt API is a subset of methods common among the exchanges. It currently contains the following methods:\n• : Fetches a list of all available markets from an exchange and returns an array of markets (objects with properties such as , , etc.). Some exchanges do not have means for obtaining a list of markets via their online API. For those, the list of markets is hardcoded.\n• : Fetches all available currencies an exchange and returns an associative dictionary of currencies (objects with properties such as , , etc.). Some exchanges do not have means for obtaining currencies via their online API. For those, the currencies will be extracted from market pairs or hardcoded.\n• : Returns the list of markets as an object indexed by symbol and caches it with the exchange instance. Returns cached markets if loaded already, unless the flag is forced.\n• : Returns information regarding the exchange status from either the info hardcoded in the exchange instance or the API, if available.\n\nNote, that most of methods of the unified API accept an optional argument. It is an associative array (a dictionary, empty by default) containing the params you want to override. The contents of are exchange-specific, consult the exchanges' API documentation for supported fields and values. Use the dictionary if you need to pass a custom setting or an optional parameter to your unified query.\n\nMost of unified methods will return either a single object or a plain array (a list) of objects (trades, orders, transactions and so on). However, very few exchanges (if any at all) will return all orders, all trades, all ohlcv candles or all transactions at once. Most often their APIs output to a certain number of most recent objects. YOU CANNOT GET ALL OBJECTS SINCE THE BEGINNING OF TIME TO THE PRESENT MOMENT IN JUST ONE CALL. Practically, very few exchanges will tolerate or allow that.\n\nTo fetch historical orders or trades, the user will need to traverse the data in portions or \"pages\" of objects. Pagination often implies \"fetching portions of data one by one\" in a loop.\n\nIn most cases users are required to use at least some type of pagination in order to get the expected results consistently. If the user does not apply any pagination, most methods will return the exchanges' default, which may start from the beginning of history or may be a subset of most recent objects. The default behaviour (without pagination) is exchange-specific! The means of pagination are often used with the following methods in particular:\n\nWith methods returning lists of objects, exchanges may offer one or more types of pagination. CCXT unifies date-based pagination by default, with timestamps in milliseconds throughout the entire library.\n\nWarning: this is an experimental feature and might produce unexpected/incorrect results in some instances.\n\nRecently, CCXT introduced a way to paginate through several results automatically by just providing the flag inside lifting this work from the userland. Most leading exchanges support it, and more will be added in the future, but the easiest way to check it is to look in the method's documentation and search for the pagination parameter. As always there are exceptions, and some endpoints might not provide a way to paginate either through a timestamp or a cursor, and in those cases, there's nothing CCXT can do about it.\n\nRight now, we have three different ways of paginating:\n• dynamic/time-based: uses the and parameters to paginate through dynamic results like (trades, orders, transactions, etc). Since we don't know a priori how many entries are available to be fetched, it will perform one request at a time until we reach the end of the data or the maximum amount of pagination calls (configurable through an option)\n• deterministic: when we can pre-compute the boundaries of each page, it will perform the requests concurrently for maximum performance. This applies to OHLCV, Funding Rates, and Open Interest and also respects the option.\n• cursor-based: when the exchange provides a cursor inside the response, we extract the cursor and perform the subsequent request until the end of the data or reach the maximum number of pagination calls.\n\nThe user cannot select the pagination method used, it will depend from implementation to implementation, considering the exchange API's features.\n\nWe can't perform an infinite amount of requests, and some of them might throw an error for different reasons, thus, we have some options that allow the user to control these variables and other pagination specificities.\n\nAll the options below, should be provided inside , you can check the examples below\n• paginate: (boolean) indicates that the user wants to paginate through different pages to get more data. Default is false.\n• paginationCalls: (integer) allows the user to control the maximum amount of requests to paginate the data. Due to the rate limits, this value should not be too high. Default is 10.\n• maxRetries: (integer) how many times should the pagination mechanism retry upon getting an error. Default is 3\n• paginationDirection: (string) Only applies to the dynamic pagination and it can be either forward (start the pagination from some time in the past and paginate forward) or backward (start from the most recent time and paginate backward). If forward is selected then a since parameter must also be provided. Default is backward.\n• maxEntriesPerRequest: (integer): The max amount of entries per request so that we can maximize the data retrieved per call. It varies from endpoint to endpoint and CCXT will populate this value for you, but you can override it if needed.\n\nAll unified timestamps throughout the CCXT library are integers in milliseconds unless explicitly stated otherwise.\n\nBelow is the set of methods for working with UTC dates and timestamps and for converting between them:\n\nThis is the type of pagination currently used throughout the CCXT Unified API. The user supplies a timestamp in milliseconds (!) and a number to results. To traverse the objects of interest page by page, the user runs the following (below is pseudocode, it may require overriding some exchange-specific params, depending on the exchange in question):\n\nThe user supplies a of the object, from where the query should continue returning results, and a number to results. This is the default with some exchanges, however, this type is not unified (yet). To paginate objects based on their ids, the user would run the following:\n\nThe user supplies a page number or an initial \"cursor\" value. The exchange returns a page of results and the next \"cursor\" value, to proceed from. Most of exchanges that implement this type of pagination will either return the next cursor within the response itself or will return the next cursor values within HTTP response headers.\n\nSee an example implementation here: https://github.com/ccxt/ccxt/blob/master/examples/py/coinbasepro-fetch-my-trades-pagination.py\n\nUpon each iteration of the loop the user has to take the next cursor and put it into the overrided params for the next query (on the following iteration):\n\nExchanges expose information on open orders with bid (buy) and ask (sell) prices, volumes and other data. Usually there is a separate endpoint for querying current state (stack frame) of the order book for a particular market. An order book is also often called market depth. The order book information is used in the trading decision making process.\n\nTo get data on order books, you can use\n• // for the order books of all markets\n• limit (Integer) The number of orders to return in the order book (e.g. )\n• limit (Integer) The number of orders to return in the order book (e.g. )\n\nThe timestamp and datetime may be missing ( ) if the exchange in question does not provide a corresponding value in the API response.\n\nPrices and amounts are floats. The bids array is sorted by price in descending order. The best (highest) bid price is the first element and the worst (lowest) bid price is the last element. The asks array is sorted by price in ascending order. The best (lowest) ask price is the first element and the worst (highest) ask price is the last element. Bid/ask arrays can be empty if there are no corresponding orders in the order book of an exchange.\n\nExchanges may return the stack of orders in various levels of details for analysis. It is either in full detail containing each and every order, or it is aggregated having slightly less detail where orders are grouped and merged by price and volume. Having greater detail requires more traffic and bandwidth and is slower in general but gives a benefit of higher precision. Having less detail is usually faster, but may not be enough in some very specific cases.\n• The is the time when the exchange generated this orderbook response (before replying it back to you). This may be missing ( ), as documented in the Manual, not all exchanges provide a timestamp there. If it is defined, then it is the UTC timestamp in milliseconds since 1 Jan 1970 00:00:00.\n• Some exchanges may index orders in the orderbook by order ids, in that case the order id may be returned as the third element of bids and asks: . This is often the case with L3 orderbooks without aggregation. The order , if shown in the orderbook, refers to the orderbook and does not necessarily correspond to the actual order id from the exchanges' database as seen by the owner or by the others. The order id is an of the row inside the orderbook, but not necessarily the true- of the order (though, they may be equal as well, depending on the exchange in question).\n• In some cases the exchanges may supply L2 aggregated orderbooks with order counts for each aggregated level, in that case the order count may be returned as the third element of bids and asks: . The tells how many orders are aggregated on each price level in bids and asks.\n• Also, some exchanges may return the order timestamp as the third element of bids and asks: . The tells when the order was placed on the orderbook.\n\nSome exchanges accept a dictionary of extra parameters to the function. All extra are exchange-specific (non-unified). You will need to consult exchanges docs if you want to override a particular param, like the depth of the order book. You can get a limited count of returned orders or a desired level of aggregation (aka market depth) by specifying an limit argument and exchange-specific extra like so:\n\nThe levels of detail or levels of order book aggregation are often number-labelled like L1, L2, L3...\n• L1: less detail for quickly obtaining very basic info, namely, the market price only. It appears to look like just one order in the order book.\n• L2: most common level of aggregation where order volumes are grouped by price. If two orders have the same price, they appear as one single order for a volume equal to their total sum. This is most likely the level of aggregation you need for the majority of purposes.\n• L3: most detailed level with no aggregation where each order is separate from other orders. This LOD naturally contains duplicates in the output. So, if two orders have equal prices they are not merged together and it's up to the exchange's matching engine to decide on their priority in the stack. You don't really need L3 detail for successful trading. In fact, you most probably don't need it at all. Therefore some exchanges don't support it and always return aggregated order books.\n\nIf you want to get an L2 order book, whatever the exchange returns, use the or unified method for that.\n\nThe argument does not guarantee that the number of bids or asks will always be equal to . It designates the upper boundary or the maximum, so at some moment in time there may be less than bids or asks. This is the case when the exchange does not have enough orders on the orderbook. However, if the underlying exchange API does not support a parameter for the orderbook endpoint at all, then the argument will be ignored. CCXT does not trim and if the exchange returns more than you request.\n\nIn order to get current best price (query market price) and calculate bidask spread take first elements from bid and ask, like so:\n\nA price ticker contains statistics for a particular market/symbol for some period of time in recent past, usually last 24 hours. The methods for fetching tickers are described below.\n\nCheck the and properties of the exchange instance to determine if the exchange in question does support these methods.\n\nPlease, note, that calling without a symbol is usually strictly rate-limited, an exchange may ban you if you poll that endpoint too frequently.\n\nA ticker is a statistical calculation with the information calculated over the past 24 hours for a specific market.\n\nThe structure of a ticker is as follows:\n• All fields in the ticker represent the past 24 hours prior to .\n• The is the volume (amount) of current best bid in the orderbook.\n• The is the volume (amount) of current best ask in the orderbook.\n• The is the amount of base currency traded (bought or sold) in last 24 hours.\n• The is the amount of quote currency traded (bought or sold) in last 24 hours.\n\nAll prices in ticker structure are in quote currency. Some fields in a returned ticker structure may be undefined/None/null.\n\nTimestamp and datetime are both Universal Time Coordinated (UTC) in milliseconds.\n• is the time when the exchange generated this response (before replying it back to you). It may be missing ( ), as documented in the Manual, not all exchanges provide a timestamp there. If it is defined, then it is a UTC timestamp in milliseconds since 1 Jan 1970 00:00:00.\n• is the date-time string of the last HTTP response received (from HTTP headers). The 'Date' parser should respect the timezone designated there. The precision of the date-time is 1 second, 1000 milliseconds. This date should be set by the exchange server when the message originated according to the following standards:\n\nAlthough some exchanges do mix-in orderbook's top bid/ask prices into their tickers (and some exchanges even serve top bid/ask volumes) you should not treat a ticker as a replacement. The main purpose of a ticker is to serve statistical data, as such, treat it as \"live 24h OHLCV\". It is known that exchanges discourage frequent requests by imposing stricter rate limits on these queries. If you need a unified way to access bids and asks you should use family instead.\n\nTo get historical prices and volumes use the unified method where available. To get historical mark, index, and premium index prices, add one of , , respectively to the params-overrides of . There are also convenience methods , , and that obtain the mark, index and premiumIndex historical prices and volumes.\n\nTo get the individual ticker data from an exchange for a particular trading pair or a specific symbol – call the :\n\nSome exchanges (not all of them) also support fetching all tickers at once. See their docs for details. You can fetch all tickers with a single call like so:\n\nFetching all tickers requires more traffic than fetching a single ticker. Also, note that some exchanges impose higher rate-limits on subsequent fetches of all tickers (see their docs on corresponding endpoints for details). The cost of the call in terms of rate limit is often higher than average. If you only need one ticker, fetching by a particular symbol is faster as well. You probably want to fetch all tickers only if you really need all of them and, most likely, you don't want to fetchTickers more frequently than once in a minute or so.\n\nAlso, some exchanges may impose additional requirements on the call, sometimes you can't fetch the tickers for all symbols because of the API limitations of the exchange in question. Some exchanges accept a list of symbols in HTTP URL query params, however, because URL length is limited, and in extreme cases exchanges can have thousands of markets – a list of all their symbols simply would not fit in the URL, so it has to be a limited subset of their symbols. Sometimes, there are other reasons for requiring a list of symbols, and there may be a limit on the number of symbols you can fetch at once, but whatever the limitation, please, blame the exchange. To pass the symbols of interest to the exchange, you can supply a list of strings as the first argument to fetchTickers:\n\nNote that the list of symbols is not required in most cases, but you must add additional logic if you want to handle all possible limitations that might be imposed on the exchanges' side.\n\nLike most methods of the Unified CCXT API, the last argument to fetchTickers is the argument for overriding request parameters that are sent towards the exchange.\n\nThe structure of the returned value is as follows:\n\nA general solution for fetching all tickers from all exchanges (even the ones that don't have a corresponding API endpoint) is on the way, this section will be updated soon.\n\nMost exchanges have endpoints for fetching OHLCV data, but some of them don't. The exchange boolean (true/false) property named indicates whether the exchange supports candlestick data series or not.\n\nTo fetch OHLCV candles/bars from an exchange, ccxt has the method, which is declared in the following way:\n\nYou can call the unified / method to get the list of OHLCV candles for a particular symbol like so:\n\nTo get the list of available timeframes for your exchange see the property. Note that it is only populated when is true as well.\n\nThe returned list of candles may have one or more missing periods, if the exchange did not have any trades for the specified timerange and symbol. To a user that would appear as gaps in a continuous list of candles. That is considered normal. If the exchange did not have any candles at that time, the CCXT library will show the results as returned from the exchange itself.\n\nThere's a limit on how far back in time your requests can go. Most of exchanges will not allow to query detailed candlestick history (like those for 1-minute and 5-minute timeframes) too far in the past. They usually keep a reasonable amount of most recent candles, like 1000 last candles for any timeframe is more than enough for most of needs. You can work around that limitation by continuously fetching (aka REST polling) latest OHLCVs and storing them in a CSV file or in a database.\n\nNote that the info from the last (current) candle may be incomplete until the candle is closed (until the next candle starts).\n\nLike with most other unified and implicit methods, the method accepts as its last argument an associative array (a dictionary) of extra , which is used to override default values that are sent in requests to the exchanges. The contents of are exchange-specific, consult the exchanges' API documentation for supported fields and values.\n\nThe argument is an integer UTC timestamp in milliseconds (everywhere throughout the library with all unified methods).\n\nIf is not specified the method will return the time range as is the default from the exchange itself. This is not a bug. Some exchanges will return candles from the beginning of time, others will return most recent candles only, the exchanges' default behaviour is expected. Thus, without specifying the range of returned candles will be exchange-specific. One should pass the argument to ensure getting precisely the history range needed.\n\nCurrently, the structure CCXT uses does not include the raw response from the exchange. However, users might be able to override the return value by doing:\n\nTrading strategies require fresh up-to-date information for technical analysis, indicators and signals. Building a speculative trading strategy based on the OHLCV candles received from the exchange may have critical drawbacks. Developers should account for the details explained in this section to build successful bots.\n\nFirst and foremost, when using CCXT you're talking to the exchanges directly. CCXT is not a server, nor a service, it's a software library. All data that you are getting with CCXT is received directly from the exchanges first-hand.\n\nThe exchanges usually provide two categories of public market data:\n• Fast primary first-order data that includes real time orderbooks and trades or fills\n• Slow second-order data that includes secondary tickers and kline OHLCV candles, that are calculated from the first-order data\n\nThe primary first-order data is updated by the exchanges APIs in pseudo real time, or as close to real time as possible, as fast as possible. The second-order data requires time for the exchange to calculate it. For example, a ticker is nothing more than a rolling 24-hour statistical cut of orderbooks and trades. OHLCV candles and volumes are also calculated from first-order trades and represent fixed statistical cuts of specific periods. The volume traded within an hour is just a sum of traded volumes of the corresponding trades that happened within that hour.\n\nObviously, it takes some time for the exchange to collect the first-order data and calculate the secondary statistical data from it. That literally means that tickers and OHLCVs are always slower than orderbooks and trades. In other words, there is always some latency in the exchange API between the moment when a trade happens and the moment when a corresponding OHLCV candle is updated or published by the exchange API.\n\nThe latency (or how much time is needed by the exchange API for calculating the secondary data) depends on how fast the exchange engine is, so it is exchange-specific. Top exchange engines will usually return and update fresh last-minute OHLCV candles and tickers at a very fast rate. Some exchanges might do it in regular intervals like once a second or once in a few seconds. Slow exchange engines might take minutes to update the secondary statistical information, their APIs might return the current most recent OHLCV candle a few minutes late.\n\nIf your strategy depends on the fresh last-minute most recent data you don't want to build it based on tickers or OHLCVs received from the exchange. Tickers and exchanges' OHLCVs are only suitable for display purposes, or for simple trading strategies for hour-timeframes or day-timeframes that are less susceptible to latency.\n\nThankfully, the developers of time-critical trading strategies don't have to rely on secondary data from the exchanges and can calculate the OHLCVs and tickers in the userland. That may be faster and more efficient than waiting for the exchanges to update the info on their end. One can aggregate the public trade history by polling it frequently and calculate candles by walking over the list of trades - please take a look into \"build-ohlcv-bars\" file inside examples folder\n\nDue to the differences in their internal implementations the exchanges may be faster to update their primary and secondary market data over WebSockets. The latency remains exchange-specific, cause the exchange engine still needs time to calculate the secondary data, regardless of whether you're polling it over the RESTful API with CCXT or getting updates via WebSockets with CCXT Pro. WebSockets can improve the networking latency, so a fast exchange will work even better, but adding the support for WS subscriptions will not make a slow exchange engine work much faster.\n\nIf you want to stay on top of the second-order data latency, then you will have to calculate it on your side and beat the exchange engine in speed of doing so. Depending on the needs of your application, it may be tricky, since you will need to handle redundancy, \"data holes\" in the history, exchange downtimes, and other aspects of data aggregation which is a whole universe in itself that is impossible to fully cover in this Manual.\n\nThe fetchOHLCV method shown above returns a list (a flat array) of OHLCV candles represented by the following structure:\n\nThe list of candles is returned sorted in ascending (historical/chronological) order, oldest candle first, most recent candle last.\n\nTo obtain historical Mark, Index Price and Premium Index candlesticks pass the params-override to . The parameter accepts one of the following values:\n\nThere are also convenience methods , and\n\nSome exchanges don't offer any OHLCV method, and for those, the ccxt library will emulate OHLCV candles from Public Trades. In that case you will see . However, because the trade history is usually very limited, the emulated fetchOHLCV methods cover most recent info only and should only be used as a fallback, when no other option is available.\n\nYou can call the unified / method to get the list of most recent trades for a particular symbol. The method is declared in the following way:\n\nFor example, if you want to print recent trades for all symbols one by one sequentially (mind the rateLimit!) you would do it like so:\n\nThe fetchTrades method shown above returns an ordered list of trades (a flat array, sorted by timestamp in ascending order, oldest trade first, most recent trade last). A list of trades is represented by the trade structure.\n\nMost exchanges return most of the above fields for each trade, though there are exchanges that don't return the type, the side, the trade id or the order id of the trade. Most of the time you are guaranteed to have the timestamp, the datetime, the symbol, the price and the amount of each trade.\n\nThe second optional argument reduces the array by timestamp, the third argument reduces by number (count) of returned items.\n\nIf the user does not specify , the method will return the default range of public trades from the exchange. The default set is exchange-specific, some exchanges will return trades starting from the date of listing a pair on the exchange, other exchanges will return a reduced set of trades (like, last 24 hours, last 100 trades, etc). If the user wants precise control over the timeframe, the user is responsible for specifying the argument.\n\nMost of unified methods will return either a single object or a plain array (a list) of objects (trades). However, very few exchanges (if any at all) will return all trades at once. Most often their APIs output to a certain number of most recent objects. YOU CANNOT GET ALL OBJECTS SINCE THE BEGINNING OF TIME TO THE PRESENT MOMENT IN JUST ONE CALL. Practically, very few exchanges will tolerate or allow that.\n\nTo fetch historical trades, the user will need to traverse the data in portions or \"pages\" of objects. Pagination often implies \"fetching portions of data one by one\" in a loop.\n\nIn most cases users are required to use at least some type of pagination in order to get the expected results consistently.\n\nOn the other hand, some exchanges don't support pagination for public trades at all. In general the exchanges will provide just the most recent trades.\n\nThe / method also accepts an optional (assoc-key array/dict, empty by default) as its fourth argument. You can use it to pass extra params to method calls or to override a particular default value (where supported by the exchange). See the API docs for your exchange for more details.\n\nThe method (if available) returns the current integer timestamp in milliseconds from the exchange server.\n\nThe exchange status describes the latest known information on the availability of the exchange API. This information is either hardcoded into the exchange class or fetched live directly from the exchange API. The method can be used to get this information. The status returned by is one of:\n• Hardcoded into the exchange class, e.g. if the API has been broken or shutdown.\n• Updated using the exchange ping or endpoint to see if its alive\n\nThe method will return a status structure like shown below:\n\nThe possible values in the field are:\n• ' means the exchange was closed, and the field should contain the datetime of the shutdown\n• means that either the exchange API is broken, or the implementation of the exchange in CCXT is broken\n• means regular maintenance, and the field should contain the datetime when the exchange is expected to be operational again\n\nWhen short trading or trading with leverage on a spot market, currency must be borrowed. Interest is accrued for the borrowed currency.\n\nData on the borrow rate for a currency can be retrieved using\n• for the borrow rates of currencies in individual markets\n• A dictionary of borrow rate structures with unified currency codes as keys\n• A dictionary of isolated borrow rate structures with unified market symbols as keys\n\nThe method retrieves a history of a currencies borrow interest rate at specific time slots\n• since (Integer) Timestamp for the earliest borrow rate (e.g. )\n• limit (Integer) The maximum number of borrow rate structures to retrieve (e.g. )\n\nThe method can be used to obtain the maximum leverage for a market at varying position sizes. It can also be used to obtain the maintenance margin rate, and the max tradeable amount for a market when that information is not available from the market object\n\nWhile you can obtain the absolute maximum leverage for a market by accessing , for many contract markets, the maximum leverage will depend on the size of your position.\n\nYou can access those limits by using\n\nIn the example above:\n\nNote for Huobi users: Huobi uses both leverage and amount to determine maintenance margin rates: https://www.huobi.com/support/en-us/detail/900000089903\n\nData on the current, most recent, and next funding rates can be obtained using the methods\n• An array of funding rate structures indexed by market symbols\n\nRetrieve the current funding interval using the following methods:\n• since (Integer) Timestamp for the earliest funding rate (e.g. )\n• limit (Integer) The maximum number of funding rates to retrieve (e.g. )\n\nUse the method to get the current open interest for a symbol from the exchange.\n\nUse the method to get a history of open interest for a symbol from the exchange.\n• since (Integer) Timestamp for the earliest open interest record (e.g. )\n• limit (Integer) The maximum number of open interest structures to retrieve (e.g. )\n\nNote for OKX users: instead of a unified symbol okx.fetchOpenInterestHistory expects a unified currency code in the symbol argument (e.g. ).\n\nUse the method to get the volatility history for the code of an options underlying asset from the exchange.\n\nUse the method to get the market id's of underlying assets for a contract market type from the exchange.\n\nUse the method to get the public settlement history for a contract market from the exchange.\n• since (Integer) Timestamp for the earliest settlement (e.g. )\n• limit (Integer) The maximum number of settlements to retrieve (e.g. )\n\nUse the method to get the public liquidations of a trading pair from the exchange.\n• since (Integer) Timestamp for the earliest liquidation (e.g. )\n• limit (Integer) The maximum number of liquidations to retrieve (e.g. )\n\nUse the method to get the public greeks and implied volatility of an options trading pair from the exchange. The greeks measure how factors like the underlying assets price, time to expiration, volatility, and interest rates, affect the price of an options contract.\n\nUse the method to get the public details of a single option contract from the exchange.\n\nUse the method to get the public option chain data of an underlying currency from the exchange.\n\nUse the method to fetch the current long short ratio of a symbol and use the to fetch the history of long short ratios for a symbol.\n• for the current ratio of a single market symbol\n• for the history of ratios of a single market symbol\n• period (String) The period to calculate the ratio from (e.g. )\n• period (String) The period to calculate the ratio from (e.g. )\n• since (Integer) Timestamp for the earliest ratio (e.g. )\n• limit (Integer) The maximum number of ratios to retrieve (e.g. )\n\nIn order to be able to access your user account, perform algorithmic trading by placing market and limit orders, query balances, deposit and withdraw funds and so on, you need to obtain your API keys for authentication from each exchange you want to trade with. They usually have it available on a separate tab or page within your user account settings. API keys are exchange-specific and cannnot be interchanged under any circumstances.\n\nThe exchanges' private APIs will usually allow the following types of interaction:\n• the current state of the user's account balance can be obtained with the method as described in the Account Balance section\n• the user can place and cancel orders with , , as well as fetch current open orders and the past order history with methods like , , , , , , , as described in the section on Orders\n• the user can query the history of past trades executed with their account using , as described in the My Trades section, also see How Orders Are Related To Trades\n• the user can query their positions with and as described in the Positions section\n• the user can fetch the history of their transactions (on-chain transactions which are either deposits to the exchange account or withdrawals from the exchange account) with , or with , , and separately, depending on what is available from the exchange API\n• if the exchange API provides a ledger endpoint, the user can fetch a history of all money movements that somehow affected the balance, with that will return all accounting ledger entries such as trades, deposits, withdrawals, internal transfers between accounts, rebates, bonuses, fees, staking profits and so on, as described in the Ledger section.\n\nAuthentication with all exchanges is handled automatically if provided with proper API keys. The process of authentication usually goes through the following pattern:\n• Generate new nonce. A nonce is an integer, often a Unix Timestamp in seconds or milliseconds (since epoch January 1, 1970). The nonce should be unique to a particular request and constantly increasing, so that no two requests share the same nonce. Each next request should have greater nonce than the previous request. The default nonce is a 32-bit Unix Timestamp in seconds.\n• Append public apiKey and nonce to other endpoint params, if any, then serialize the whole thing for signing.\n• Sign the serialized params using HMAC-SHA256/384/512 or MD5 with your secret key.\n• Append the signature in Hex or Base64 and nonce to HTTP headers or body.\n\nThis process may differ from exchange to exchange. Some exchanges may want the signature in a different encoding, some of them vary in header and body param names and formats, but the general pattern is the same for all of them.\n\nYou should not share the same API keypair across multiple instances of an exchange running simultaneously, in separate scripts or in multiple threads. Using the same keypair from different instances simultaneously may cause all sorts of unexpected behaviour.\n\nDO NOT REUSE API KEYS WITH DIFFERENT SOFTWARE! The other software will screw your nonce too high. If you get InvalidNonce errors – make sure to generate a fresh new keypair first and foremost.\n\nThe authentication is already handled for you, so you don't need to perform any of those steps manually unless you are implementing a new exchange class. The only thing you need for trading is the actual API key pair.\n\nThe API credentials usually include the following:\n• . This is your public API Key and/or Token. This part is non-secret, it is included in your request header or body and sent over HTTPS in open text to identify your request. It is often a string in Hex or Base64 encoding or an UUID identifier.\n• . This is your private key. Keep it secret, don't tell it to anybody. It is used to sign your requests locally before sending them to exchanges. The secret key does not get sent over the internet in the request-response process and should not be published or emailed. It is used together with the nonce to generate a cryptographically strong signature. That signature is sent with your public key to authenticate your identity. Each request has a unique nonce and therefore a unique cryptographic signature.\n• . Some exchanges (not all of them) also generate a user id or uid for short. It can be a string or numeric literal. You should set it, if that is explicitly required by your exchange. See their docs for details.\n• . Some exchanges (not all of them) also require your password/phrase for trading. You should set this string, if that is explicitly required by your exchange. See their docs for details.\n\nIn order to create API keys find the API tab or button in your user settings on the exchange website. Then create your keys and copy-paste them to your config file. Your config file permissions should be set appropriately, unreadable to anyone except the owner.\n\nRemember to keep your apiKey and secret key safe from unauthorized use, do not send or tell it to anybody. A leak of the secret key or a breach in security can cost you a fund loss.\n\nFor checking if the user has supplied all the required credentials the base class has a method called or . Calling that method will throw an , if some of the credentials are missing or empty. The base class also has property that allows a user to see which credentials are required for this or that exchange, as shown below:\n\nTo set up an exchange for trading just assign the API credentials to an existing exchange instance or pass them to exchange constructor upon instantiation, like so:\n\nNote that your private requests will fail with an exception or error if you don't set up your API credentials before you start trading. To avoid character escaping always write your credentials in single quotes, not double quotes ( , ).\n\nWhen you get errors like or , then, most likely, the problem is not within ccxt, please avoid opening a new issue unless you ensure that:\n• You don't have typos, empty spaces, or quotes in your keys\n• Your current IP address (check IPv4 or IPv6) is added into API-KEY's whitelist (if you use proxy, consider that too)\n• You have selected the correct options in permissions list for that api-key\n• You are not accidentally mixing \"testnet\" api-keys or \"testnet\" mode in your script\n• You have checked already reported issues about this error\n\nSome exchanges required you to sign in prior to calling private methods, which can be done using the method\n\nThe default nonce is defined by the underlying exchange. You can override it with a milliseconds-nonce if you want to make private requests more frequently than once per second! Most exchanges will throttle your requests if you hit their rate limits, read API docs for your exchange carefully!\n\nIn case you need to reset the nonce it is much easier to create another pair of keys for using with private APIs. Creating new keys and setting up a fresh unused keypair in your config is usually enough for that.\n\nIn some cases you are unable to create new keys due to lack of permissions or whatever. If that happens you can still override the nonce. Base market class has the following methods for convenience:\n• : same in milliseconds (ms = 1000 * s, thousandths of a second).\n• : same in microseconds (μs = 1000 * ms, millionths of a second).\n\nThere are exchanges that confuse milliseconds with microseconds in their API docs, let's all forgive them for that, folks. You can use methods listed above to override the nonce value. If you need to use the same keypair from multiple instances simultaneously use closures or a common function to avoid nonce conflicts. In Javascript you can override the nonce by providing a parameter to the exchange constructor or by setting it explicitly on exchange object:\n\nIn Python and PHP you can do the same by subclassing and overriding nonce function of a particular exchange class:\n\nYou can get all the accounts associated with a profile by using the method\n\nThe method will return a structure like shown below:\n\nTypes of account is one of the unified account types or\n\nTo query for balance and get the amount of funds available for trading or funds locked in orders, use the method:\n\nThe and values may be undefined or missing if the underlying exchange does not provide them.\n\nSome exchanges may not return full balance info. Many exchanges do not return balances for your empty or unused accounts. In that case some currencies may be missing in returned balance structure.\n\nMost of the time you can query orders by an id or by a symbol, though not all exchanges offer a full and flexible set of endpoints for querying orders. Some exchanges might not have a method for fetching recently closed orders, the other can lack a method for getting an order by id, etc. The ccxt library will target those cases by making workarounds where possible.\n\nThe list of methods for querying orders consists of the following:\n\nNote that the naming of those methods indicates if the method returns a single order or multiple orders (an array/list of orders). The method requires a mandatory order id argument (a string). Some exchanges also require a symbol to fetch an order by id, where order ids can intersect with various trading pairs. Also, note that all other methods above return an array (a list) of orders. Most of them will require a symbol argument as well, however, some exchanges allow querying with a symbol unspecified (meaning all symbols).\n\nThe library will throw a NotSupported exception if a user calls a method that is not available from the exchange or is not implemented in ccxt.\n\nTo check if any of the above methods are available, look into the property of the exchange:\n\nA typical structure of the property usually contains the following flags corresponding to order API methods for querying orders:\n\nThe meanings of boolean and are obvious. A string value of means that particular method is missing in the exchange API and ccxt will workaround that where possible on the client-side.\n\nThe exchanges' order management APIs differ by design. The user has to understand the purpose of each specific method and how they're combined together into a complete order API:\n• – though not a part of the orders' API, it is closely related, since it provides the history of settled trades.\n• – fetches a list of all orders (either open or closed/canceled).\n• – used for placing multiple orders within the same request\n• - used for canceling all orders\n• - used for canceling all orders after the given timeout\n\nThe majority of the exchanges will have a way of fetching currently-open orders. Thus, the . If that method is not available, then most likely the that will provide a list of all orders. The exchange will return a list of open orders either from or from . One of the two methods is usually available from any exchange.\n\nSome exchanges will provide the order history, other exchanges will not. If the underlying exchange provides the order history, then the or the . If the underlying exchange does not provide the order history, then and are not available. In the latter case, the user is required to build a local cache of orders and track the open orders using and for order statuses and for marking them as closed locally in the userland (when they're not open anymore).\n\nIf the underlying exchange does not have methods for order history ( and ), then it will provide + the trade history with (see How Orders Are Related To Trades). That set of information is in many cases enough for tracking in a live-trading robot. If there's no order history – you have to track your live orders and restore historical info from open orders and historical trades.\n\nIn general, the underlying exchanges will usually provide one or more of the following types of historical data:\n\nAny of the above three methods may be missing, but the exchanges APIs will usually provide at least one of the three methods.\n\nIf the underlying exchange does not provide historical orders, the CCXT library will not emulate the missing functionality – it has to be added on the user side where necessary.\n\nPlease, note, that a certain method may be missing either because the exchange does not have a corresponding API endpoint, or because CCXT has not implemented it yet (the library is also a work in progress). In the latter case, the missing method will be added as soon as possible.\n\nAll methods returning lists of trades and lists of orders, accept the second argument and the third argument:\n\nThe second argument reduces the array by timestamp, the third argument reduces by number (count) of returned items.\n\nIf the user does not specify , the methods will return the default set of results from the exchange. The default set is exchange-specific, some exchanges will return trades or recent orders starting from the date of listing a pair on the exchange, other exchanges will return a reduced set of trades or orders (like, last 24 hours, last 100 trades, first 100 orders, etc). If the user wants precise control over the timeframe, the user is responsible for specifying the argument.\n\nNOTE: not all exchanges provide means for filtering the lists of trades and orders by starting time, so, the support for and is exchange-specific. However, most exchanges do provide at least some alternative for \"pagination\" and \"scrolling\" which can be overrided with extra argument.\n\nSome exchanges do not have a method for fetching closed orders or all orders. They will offer just the endpoint, and sometimes also a endpoint as well. Those exchanges don't have any methods for fetching the order history. To maintain the order history for those exchanges the user has to store a dictionary or a database of orders in the userland and update the orders in the database after calling methods like , , , .\n\nTo get the details of a particular order by its id, use the / method. Some exchanges also require a symbol even when fetching a particular order by id.\n\nThe signature of the fetchOrder/fetch_order method is as follows:\n\nSome exchanges don't have an endpoint for fetching an order by id, ccxt will emulate it where possible. For now it may still be missing here and there, as this is a work in progress.\n\nYou can pass custom overrided key-values in the additional params argument to supply a specific order type, or some other setting if needed.\n\nBelow are examples of using the fetchOrder method to get order info from an authenticated exchange instance:\n\nSome exchanges don't have an endpoint for fetching all orders, ccxt will emulate it where possible. For now it may still be missing here and there, as this is a work in progress.\n\nDo not confuse closed orders with trades aka fills ! An order can be closed (filled) with multiple opposing trades! So, a closed order is not the same as a trade. In general, the order does not have a at all, but each particular user trade does have , and other properties. However, many exchanges propagate those properties to the orders as well.\n\nSome exchanges don't have an endpoint for fetching closed orders, ccxt will emulate it where possible. For now it may still be missing here and there, as this is a work in progress.\n\nMost of methods returning orders within ccxt unified API will yield an order structure as described below:\n• The of an order is usually either (not filled or partially filled), (fully filled), or (unfilled and canceled, or partially filled then canceled).\n• Some exchanges allow the user to specify an expiration timestamp upon placing a new order. If the order is not filled by that time, its becomes .\n• Use the value to determine if the order is filled, partially filled or fully filled, and by how much.\n• The work on info is still in progress, fee info may be missing partially or entirely, depending on the exchange capabilities.\n• The currency may be different from both traded currencies (for example, an ETH/BTC order with fees in USD).\n• The timestamp may have no value and may be where not supported by the exchange or in case of an open order (an order that has not been filled nor partially filled yet).\n• The , if any, designates the timestamp of the last trade, in case the order is filled fully or partially, otherwise is .\n• Order prevails or has precedence over the .\n• The of an order is:\n• The of an order means the total quote volume of the order (whereas the is the base volume). The value of should be as close to the actual most recent known order cost as possible. The field itself is there mostly for convenience and can be deduced from other fields.\n• The field can be set upon placing orders by the user with custom order params. Using the the user can later distinguish between own orders. This is only available for the exchanges that do support at this time.\n\nThe field may be if not specified by the exchange. The unification of is a work in progress.\n\nPossible values for the field:\n• = Good Till Cancel(ed), the order stays on the orderbook until it is matched or canceled.\n• = Immediate Or Cancel, the order has to be matched immediately and filled either partially or completely, the unfilled remainder is canceled (or the entire order is canceled).\n• = Fill Or Kill, the order has to get fully filled and closed immediately, otherwise the entire order is canceled.\n• = Post Only, the order is either placed as a maker order, or it is canceled. This means the order must be placed on orderbook for at at least time in an unfilled state. The unification of as a option is a work in progress with unified exchanges having .\n\nThere are different types of orders that a user can send to the exchange, regular orders eventually land in the orderbook of a corresponding symbol, others orders may be more advanced. Here is a list outlining various types of orders:\n• Limit Orders – regular orders having an in base currency (how much you want to buy or sell) and a in quote currency (for which price you want to buy or sell).\n• Market Orders – regular orders having an in base currency (how much you want to buy or sell)\n• Market Buys – some exchanges require market buy orders with an in quote currency (how much you want to spend for buying)\n• Trigger Orders aka conditional orders – an advanced type of order used to wait for a certain condition on a market and then react automatically: when a is reached, the trigger order gets triggered and then a regular limit or market price order is placed, that eventually results in entering a position or exiting a position\n• Stop Loss Orders – almost the same as trigger orders, but used to close a position to stop further losses on that position: when the price reaches then the stop loss order is triggered that results in placing another regular limit or market order to close a position at a specific limit or at market price (a position with a stop loss order attached to it).\n• Take Profit Orders – a counterpart to stop loss orders, this type of order is used to close a position to take existing profits on that position: when the price reaches then the take profit order is triggered that results in placing another regular limit or market order to close a position at a specific limit or at market price (a position with a take profit order attached to it).\n• StopLoss And TakeProfit Orders Attached To A Position – advanced orders, consisting of three orders of types listed above: a regular limit or market order placed to enter a position with stop loss and/or take profit orders that will be placed upon opening that position and will be used to close that position later (when a stop loss is reached, it will close the position and will cancel its take profit counterpart, and vice versa, when a take profit is reached, it will close the position and will cancel its stop loss counterpart, these two counterparts are also known as \"OCO orders – one cancels the other), apart from the (and for the limit order) to open a position it will also require a for a stop loss order (with a limit if it's a stop loss limit order) and/or a for a take profit order (with a limit if it's a take profit limit order).\n• Trailing Orders – an order that is automatically adjusted relative to an open position, can be set to trail a specified quote amount behind the open position or can be set to trail a specified percent behind the open position, when the market price of the position is equal to the trailing order this results in entering a new position or exiting a position depending on if the trailing order has the parameter set to true or not.\n\nPlacing an order always requires a that the user has to specify (which market you want to trade).\n\nTo place an order use the method. You can use the from the returned unified order structure to query the status and the state of the order later. If you need to place multiple orders simultaneously, you can check the availability of the method.\n• symbol (String) required Unified CCXT market symbol\n• Make sure the symbol in question exists with the target exchange and is available for trading.\n• side required a string literal for the direction of your order. Unified sides:\n• give quote currency and receive base currency; for example, buying means that you will receive bitcoins for your dollars.\n• give base currency and receive quote currency; for example, buying means that you will receive dollars for your bitcoins.\n• type a string literal type of order Unified types:\n• market not allowed by some exchanges, see their docs for details\n• see #custom-order-params and #other-order-types for non-unified types\n• amount, how much of currency you want to trade usually, but not always, in units of the base currency of the trading pair symbol (the units for some exchanges are dependent on the side of the order: see their API docs for details.)\n• price the price at which the order is to be fullfilled at in units of the quote currency (ignored in market orders)\n• Some exchanges will allow to trade with limit orders only.\n\nSome fields from the returned order structure may be if that information is not returned from the exchange API's response. The user is guaranteed that the method will return a unified order structure that will contain at least the order and the (a raw response from the exchange \"as is\"):\n• There is a common error that happens when creating orders for contract markets:\n\nThis error happens when the exchange is expecting a natural number of contracts (1,2,3, etc) in the argument of . The market structure has a key called . Each contract is worth a certain amount of the base asset that is determined by the . The number of contracts multiplied by the is equal to the base amount. so to derive the number of contracts you should enter in the argument you can solve for contracts: .\n\nHere is an example of finding the :\n\nLimit orders placed on the order book of the exchange for a price specified by the trader. They are fullfilled(closed) when there are no orders in the same market at a better price, and another trader creates a market order or an opposite order for a price that matches or exceeds the price of the limit order.\n\nLimit orders may not be fully filled. This happens when the filling order is for a smaller amount than the amount specified by the limit order.\n\nalso known as\n\nMarket orders are executed immediately by fulfilling one of more already existing orders from the ask side of the exchanges order book. The orders that your market order fulfills are chosen from th top of the order book stack, meaning your market order is fulfilled at the best price available. When placing a market order you don't need to specify the price of the order, and if the price is specified, it will be ignored.\n\nYou are not guaranteed that the order will be executed for the price you observe prior to placing your order. There are multiple reasons for this, including:\n• price slippage a slight change of the price for the traded market while your order is being executed. Reasons for price slippage include, but are not limited to\n• unequivocal order sizes if a market order is for an amount that is larger than the size of the top order on the order book, then after the top order is filled, the market order will proceed to fill the next order in the order book, which means the market order is filled at multiple prices\n\nNote, that some exchanges will not accept market orders (they allow limit orders only). In order to detect programmatically if the exchange in question does support market orders or not, you can use the exchange property:\n\nIn general, when placing a or order the user has to specify just the amount of the base currency to buy or sell. However, with some exchanges market buy orders implement a different approach to calculating the value of the order.\n\nSuppose you're trading BTC/USD and the current market price for BTC is over 9000 USD. For a market buy or market sell you could specify an of 2 BTC and that would result in plus or minus 18000 USD (more or less ;)) on your account, depending on the side of the order.\n\nWith market buys some exchanges require the total cost of the order in the quote currency! The logic behind it is simple, instead of taking the amount of base currency to buy or sell some exchanges operate with \"how much quote currency you want to spend on buying in total\".\n\nTo place a market buy order with those exchanges you would not specify an amount of 2 BTC, instead you should somehow specify the total cost of the order, that is, 18000 USD in this example. The exchanges that treat orders in this way have an exchange-specific option that allows specifying the total cost of a order in two ways.\n\nThe first is the default and if you specify the along with the the total cost of the order would be calculated inside the lib from those two values with a simple multiplication ( ). The resulting would be the amount in USD quote currency that will be spent on this particular market buy order.\n\nThe second alternative is useful in cases when the user wants to calculate and specify the resulting total cost of the order himself. That can be done by setting the option to to switch it off:\n\nMore about it:\n\nIt is also possible to emulate a order with a order.\n\nWARNING this method can be risky due to high volatility, use it at your own risk and only use it when you know really well what you're doing!\n\nMost of the time a can be emulated with a at a very low price – the exchange will automatically make it a taker order for market price (the price that is currently in your best interest from the ones that are available in the order book). When the exchange detects that you're selling for a very low price it will automatically offer you the best buyer price available from the order book. That is effectively the same as placing a market sell order. Thus market orders can be emulated with limit orders (where missing).\n\nThe opposite is also true – a can be emulated with a for a very high price. Most exchanges will again close your order for best available price, that is, the market price.\n\nHowever, you should never rely on that entirely, ALWAYS test it with a small amount first! You can try that in their web interface first to verify the logic. You can sell the minimal amount at a specified limit price (an affordable amount to lose, just in case) and then check the actual filling price in trade history.\n\nLimit price orders are also known as limit orders. Some exchanges accept limit orders only. Limit orders require a price (rate per unit) to be submitted with the order. The exchange will close limit orders if and only if market price reaches the desired level.\n\nComing from traditional trading, the term \"Stop order\" has been a bit ambigious, so instead of it, in CCXT we use term \"Trigger\" order. When symbol's price reaches your \"trigger\"(\"stop\") price, the order is activated as or order, depending which one you had chosen.\n\nWe have different classification of trigger orders:\n• standalone Stop Loss or Take Profit designed to close open positions.\n• a Stop Loss or Take Profit order attached to a primary order (Conditional Trigger Order).\n\nTraditional \"stop\" order (which you might see across exchanges' websites) is now called \"trigger\" order across CCXT library. Implemented by adding a parameter. They are independent basic trigger orders that can open or close a position.\n• Typically, it is activated when price of the underlying asset/contract crosses the from any direction. However, some exchanges' API require to set too, which triggers order depending whether price is above or below . For example, if you want to trigger limit order (buy 0.1 at limit price ) once pair price crosses :\n\nTypically, exchange automatically determines 's direction (whether it is \"above\" or \"below\" current price), however, some exchanges require that you provide with either or values:\n\nNote, you can also add param to the trigger order (with a possible param), so it would act as \"stop-loss\" or \"take-profit\" order. However, for some exchanges we support \"stop-loss\" and \"take-profit\" trigger order types, which automatically involve and handling (see them below).\n\nThe same as Trigger Orders, but the direction matters. Implemented by specifying a parameter (for the stop loss triggerPrice), and also automatically implemented on behalf of user, so instead of regular Trigger Order, you can use this as an alternative.\n\nSuppose you entered a long position (you bought) at 1000 and want to protect yourself from losses from a possible price drop below 700. You would place a stop loss order with triggerPrice at 700. For that stop loss order either you would specify a limit price or it will be executed at market price.\n\nSuppose you entered a short position (you sold) at 700 and want to protect yourself from losses from a possible price pump above 1300. You would place a stop loss order with triggerPrice at 1300. For that stop loss order either you would specify a limit price or it will be executed at market price.\n\nStop Loss orders are activated when the price of the underlying asset/contract:\n• drops below the from above, for sell orders. (eg: to close a long position, and avoid further losses)\n• rises above the from below, for buy orders (eg: to close a short position, and avoid further losses)\n\nThe same as Stop Loss Orders, but the direction matters. Implemented by specifying a parameter (for the take profit triggerPrice).\n\nSuppose you entered a long position (you bought) at 1000 and want to get your profits from a possible price pump above 1300. You would place a take profit order with triggerPrice at 1300. For that take profit order either you would specify a limit price or it will be executed at market price.\n\nSuppose you entered a short position (you sold) at 700 and want to get your profits from a possible price drop below 600. You would place a take profit order with triggerPrice at 600. For that take profit order either you would specify a limit price or it will be executed at market price.\n\nTake Profit orders are activated when the price of the underlying:\n• rises above the from below, for sell orders (eg: to close a long position, at a profit)\n• drops below the from above, for buy orders (eg: to close a short position, at a profit)\n\nTake Profit / Stop Loss Orders which are tied to a position-opening primary order. Implemented by supplying a dictionary parameters for and describing each respectively.\n• By default stopLoss and takeProfit orders will be the same magnitude as primary order but in the opposite direction.\n• Attached trigger orders are conditional on the primary order being executed.\n• Not supported by all exchanges.\n• Both and or either can be supplied, this depends on exchange.\n\nNote: This is still under unification and is work in progress\n\nFor exchanges, where it is not possible to use attached SL &TP, after submitting an entry order, you can immediatelly submit another order (even though position might not be open yet) with and params, so it can still act as a stoploss order for your upcoming position (note, this approach might not work for some exchanges).\n\nTrailing Orders trail behind an open position. Implemented by supplying float parameters for or .\n• A trailing order continually adjusts the order price at a fixed percent or fixed quote amount away from the current market price.\n• A trailing order trails behind a position as it moves in one direction, but not in the opposite direction.\n• If the position value rises, the trailing order changes, but if the position value drops the trailing order stays the same until the order is executed.\n• A trailing order can be placed independently after opening a position.\n• Implemented by filling in either the or parameter depending on the exchange.\n• The price argument can be used as the , and the type argument can be used to differentiate between limit and market trailing orders if needed.\n\nNot supported by all exchanges.\n\nNote: This is still under unification and is a work in progress\n\nSome exchanges allow you to specify optional parameters for your order. You can pass your optional parameters and override your query with an associative array using the argument to your unified API call. All custom params are exchange-specific, of course, and aren't interchangeable, do not expect those custom params for one exchange to work with another exchange.\n\nThe user can specify a custom field can be set upon placing orders with the . Using the one can later distinguish between own orders. This is only available for the exchanges that do support at this time. For the exchanges that don't support it will either throw an error upon supplying the or will ignore it setting the to .\n\nTo edit an order, you can use the method\n• side (String) required the direction of your order. Unified sides:\n• give quote currency and receive base currency; for example, buying means that you will receive bitcoins for your dollars.\n• give base currency and receive quote currency; for example, buying means that you will receive dollars for your bitcoins.\n• type (String) required type of order Unified types:\n• not allowed by some exchanges, see their docs for details\n• see #custom-order-params and #other-order-types for non-unified types\n• amount (Number) required how much of currency you want to trade usually, but not always, in units of the base currency of the trading pair symbol (the units for some exchanges are dependent on the side of the order: see their API docs for details.)\n• price (Float) the price at which the order is to be fullfilled at in units of the quote currency (ignored in market orders)\n\nTo cancel an existing order use\n• for all open orders after the given timeout\n• timeout (number) countdown time in milliseconds required on some exchanges, 0 represents cancel the timer (e.g. \\ )\n\nThe is usually used on open orders only. However, it may happen that your order gets executed (filled and closed) before your cancel-request comes in, so a cancel-request might hit an already-closed order.\n\nA cancel-request might also throw a indicating that the order might or might not have been canceled successfully and whether you need to retry or not. Consecutive calls to may hit an already canceled order as well.\n\nAs such, can throw an exception in these cases:\n\nA trade is also often called . Each trade is a result of order execution. Note, that orders and trades have a one-to-many relationship: an execution of one order may result in several trades. However, when one order matches another opposing order, the pair of two matching orders yields one trade. Thus, when an order matches multiple opposing orders, this yields multiple trades, one trade per each pair of matched orders.\n\nTo put it shortly, an order can contain one or more trades. Or, in other words, an order can be filled with one or more trades.\n\nFor example, an orderbook can have the following orders (whatever trading symbol or pair it is):\n\nAll specific numbers above aren't real, this is just to illustrate the way orders and trades are related in general.\n\nA seller decides to place a sell limit order on the ask side for a price of 0.700 and an amount of 150.\n\nAs the price and amount of the incoming sell (ask) order cover more than one bid order (orders and ), the following sequence of events usually happens within an exchange engine very quickly, but not immediately:\n• Order is matched against the incoming sell because their prices intersect. Their volumes \"mutually annihilate\" each other, so, the bidder gets 100 for a price of 0.800. The seller (asker) will have their sell order partially filled by bid volume 100 for a price of 0.800. Note that for the filled part of the order the seller gets a better price than he asked for initially. He asked for 0.7 at least but got 0.8 instead which is even better for the seller. Most conventional exchanges fill orders for the best price available.\n• A trade is generated for the order against the incoming sell order. That trade \"fills\" the entire order and most of the sell order. One trade is generated per each pair of matched orders, whether the amount was filled completely or partially. In this example the seller amount (100) fills order completely (closes the order ) and also fills the selling order partially (leaves it open in the orderbook).\n• Order now has a status of and a filled volume of 100. It contains one trade against the selling order. The selling order has an status and a filled volume of 100. It contains one trade against order . Thus each order has just one fill-trade so far.\n• The incoming sell order has a filled amount of 100 and has yet to fill the remaining amount of 50 from its initial amount of 150 in total.\n\nThe intermediate state of the orderbook is now (order is and is not in the orderbook anymore):\n• Order is matched against the remaining part of incoming sell, because their prices intersect. The amount of buying order which is 200 completely annihilates the remaining sell amount of 50. The order is filled partially by 50, but the rest of its volume, namely the remaining amount of 150 will stay in the orderbook. The selling order, however, is fulfilled completely by this second match.\n• A trade is generated for the order against the incoming sell order. That trade partially fills order . And completes the filling of the sell order. Again, this is just one trade for a pair of matched orders.\n• Order now has a status of , a filled amount of 50, and a remaining amount of 150. It contains one filling trade against the selling order. The selling order has a status now and it has completely filled its total initial amount of 150. However, it contains two trades, the first against order and the second against order . Thus each order can have one or more filling trades, depending on how their volumes were matched by the exchange engine.\n\nAfter the above sequence takes place, the updated orderbook will look like this.\n\nNotice that the order has disappeared, the selling order also isn't there. All closed and fully-filled orders disappear from the orderbook. The order which was filled partially and still has a remaining volume and an status, is still there.\n\nMost of unified methods will return either a single object or a plain array (a list) of objects (trades). However, very few exchanges (if any at all) will return all trades at once. Most often their APIs output to a certain number of most recent objects. YOU CANNOT GET ALL OBJECTS SINCE THE BEGINNING OF TIME TO THE PRESENT MOMENT IN JUST ONE CALL. Practically, very few exchanges will tolerate or allow that.\n\nAs with all other unified methods for fetching historical data, the method accepts a argument for date-based pagination. Just like with all other unified methods throughout the CCXT library, the argument for must be an integer timestamp in milliseconds.\n\nTo fetch historical trades, the user will need to traverse the data in portions or \"pages\" of objects. Pagination often implies \"fetching portions of data one by one\" in a loop.\n\nIn many cases a argument is required by the exchanges' APIs, therefore you have to loop over all symbols to get all your trades. If the is missing and the exchange requires it then CCXT will throw an exception to signal the requirement to the user. And then the has to be specified. One of the approaches is to filter the relevant symbols from the list of all symbols by looking at non-zero balances as well as transactions (withdrawals and deposits). Also, the exchanges will have a limit on how far back in time you can go.\n\nIn most cases users are required to use at least some type of pagination in order to get the expected results consistently.\n\nReturns ordered array of trades (most recent trade last).\n\nTrades denote the exchange of one currency for another, unlike transactions, which denote a transfer of a given coin.\n• The work on and info is still in progress, fee info may be missing partially or entirely, depending on the exchange capabilities.\n• The currency may be different from both traded currencies (for example, an ETH/BTC order with fees in USD).\n• The of the trade means . It is the total quote volume of the trade (whereas is the base volume). The cost field itself is there mostly for convenience and can be deduced from other fields.\n• The of the trade is a \"gross\" value. That is the value pre-fee, and the fee has to be applied afterwards.\n\nThe ledger is simply the history of changes, actions done by the user or operations that altered the user's balance in any way, that is, the history of movements of all funds from/to all accounts of the user which includes\n• amounts incoming and outcoming in result of a trade or an order\n• rebates, cashbacks and other types of events that are subject to accounting.\n\nData on ledger entries can be retrieved using\n• for multiple ledger entries of the same currency\n• code (String) Unified CCXT currency code; required if fetching all ledger entries for all assets at once is not supported (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve withdrawals for (e.g. )\n• limit (Integer) The number of ledger entry structures to retrieve (e.g. )\n\nThe type of the ledger entry is the type of the operation associated with it. If the amount comes due to a sell order, then it is associated with a corresponding trade type ledger entry, and the referenceId will contain associated trade id (if the exchange in question provides it). If the amount comes out due to a withdrawal, then is associated with a corresponding transaction.\n\nThe field holds the id of the corresponding event that was registered by adding a new item to the ledger.\n\nThe field is there to support for exchanges that include pending and canceled changes in the ledger. The ledger naturally represents the actual changes that have taken place, therefore the status is in most cases.\n\nThe ledger entry type can be associated with a regular trade or a funding transaction (deposit or withdrawal) or an internal between two accounts of the same user. If the ledger entry is associated with an internal transfer, the field will contain the id of the account that is being altered with the ledger entry in question. The field will contain the id of the opposite account the funds are transferred to/from, depending on the ( or ).\n\nIn order to deposit cryptocurrency funds to an exchange you must get an address from the exchange for the currency you want to deposit using . You can then call the method with the specified currency and address.\n\nTo deposit fiat currency on an exchange you can use the method with data retrieved from the method. this deposit feature is currently supported on coinbase only, feel free to report any issues you find\n\nThe deposit id structure returned from , look like this:\n\nData on deposits made to an account can be retrieved using\n• for multiple deposits of the same currency\n• for all deposits to an account\n• since (Integer) Timestamp (ms) of the earliest time to retrieve deposits for (e.g. )\n• limit (Integer) The number of transaction structures to retrieve (e.g. )\n\nThe method can be used to withdraw funds from an account\n\nSome exchanges require a manual approval of each withdrawal by means of 2FA (2-factor authentication). In order to approve your withdrawal you usually have to either click their secret link in your email inbox or enter a Google Authenticator code or an Authy code on their website to verify that withdrawal transaction was requested intentionally.\n\nIn some cases you can also use the withdrawal id to check withdrawal status later (whether it succeeded or not) and to submit 2FA confirmation codes, where this is supported by the exchange. See their docs for details.\n• amount (Float) required The amount of currency to withdraw (e.g. )\n• address (String) required The recipient address of the withdrawal (e.g. )\n\nData on withdrawals made to an account can be retrieved using\n• for multiple withdrawals of the same currency\n• for all withdrawals from an account\n• since (Integer) Timestamp (ms) of the earliest time to retrieve withdrawals for (e.g. )\n• limit (Integer) The number of transaction structures to retrieve (e.g. )\n\nIt is also possible to pass the parameters as the fourth argument with or without a specified tag\n\nThe following aliases of allow for withdrawing crypto on multiple chains\n\nYou may set the value of in order to withdraw USDT on the TRON chain, or 'BSC' to withdraw USDT on Binance Smart Chain. In the table above BSC and BEP20 are equivalent aliases, so it doesn't matter which one you use as they both will achieve the same effect.\n\nTransactions denote a transfer of a given coin, unlike trades, which denote the exchange of one currency for another.\n• or may be , if the exchange in question does not specify all sides of the transaction\n• The semantics of the field is exchange-specific. In some cases it can contain the address of the sender, in other cases it may contain the address of the receiver. The actual value depends on the exchange.\n• The field is the UTC timestamp in milliseconds of the most recent change of status of that funding operation, be it or . It is necessary if you want to track your changes in time, beyond a static snapshot. For example, if the exchange in question reports and for a transaction, then the field will take the value of , that is, the timestamp of the most recent change of the status.\n• The field may be in certain exchange-specific cases.\n• The substructure may be missing, if not supplied within the reply coming from the exchange.\n• The field may be , otherwise it will contain a message or note defined by the user upon creating the transaction.\n• Be careful when handling the and the . The is NOT an arbitrary user-defined string of your choice! You cannot send user messages and comments in the . The purpose of the field is to address your wallet properly, so it must be correct. You should only use the received from the exchange you're working with, otherwise your transaction might never arrive to its destination.\n• The field may be or, in some cases (when the exchange's endpoint returns both internal transfers and blockchain transactions, e.g. ), could be .\n\nThe address for depositing can be either an already existing address that was created previously with the exchange or it can be created upon request. In order to see which of the two methods are supported, check the and properties.\n\nSome exchanges may also have a method for fetching multiple deposit addresses at once or all of them at once.\n• code ([String]) Array of unified CCXT currency codes. May or may not be required depending on the exchange (e.g. )\n\nThe address structures returned from , , and look like this:\n\nWith certain currencies, like AEON, BTS, GXS, NXT, SBD, STEEM, STR, XEM, XLM, XMR, XRP, an additional argument is usually required by exchanges. Other currencies will have the set to . The tag is a memo or a message or a payment id that is attached to a withdrawal transaction. The tag is mandatory for those currencies and it identifies the recipient user account.\n\nBe careful when specifying the and the . The is NOT an arbitrary user-defined string of your choice! You cannot send user messages and comments in the . The purpose of the field is to address your wallet properly, so it must be correct. You should only use the received from the exchange you're working with, otherwise your transaction might never arrive to its destination.\n\nThe field is relatively new, it may be or missing entirely in certain cases (with some exchanges), but will be added everywhere eventually. It is still in the process of unification.\n\nThe method makes internal transfers of funds between accounts on the same exchange. This can include subaccounts or accounts of different types ( , , , ...). If an exchange is separated on CCXT into a spot and futures class (e.g. , , ...), then the method may be available to transfer funds into the futures account, and the method may be available to transfer funds out of the futures account\n• amount (Float) The amount of currency to transfer (e.g. )\n• fromAccount (String) The account to transfer funds from.\n• toAccount (String) The account to transfer funds to.\n• params.symbol (String) Market symbol when transfering to or from a margin account (e.g. )\n\nand can accept the exchange account id or one of the following unified values:\n• for some exchanges and are the same account\n• for some exchanges that allow for subaccounts\n\nYou can retrieve all the account types by selecting the keys from `exchange.options['accountsByType']\n\nSome exchanges allow transfers to email addresses, phone numbers or to other users by user id.\n• amount (Float) The amount of currency to transfer (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve transfers for (e.g. )\n• limit (Integer) The number of transfer structures to retrieve (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve transfers for (e.g. )\n• limit (Integer) The number of transfer structures to retrieve (e.g. )\n\nThis section of the Unified CCXT API is under development.\n\nFees are often grouped into two categories:\n• Trading fees. Trading fee is the amount payable to the exchange, usually a percentage of volume traded (filled).\n• Transaction fees. The amount payable to the exchange upon depositing and withdrawing as well as the underlying crypto transaction fees (tx fees).\n\nBecause the fee structure can depend on the actual volume of currencies traded by the user, the fees can be account-specific. Methods to work with account-specific fees:\n\nThe fee methods will return a unified fee structure, which is often present with orders and trades as well. The fee structure is a common format for representing the fee info throughout the library. Fee structures are usually indexed by market or currency.\n\nBecause this is still a work in progress, some or all of methods and info described in this section may be missing with this or that exchange.\n\nDO NOT use the property of the exchange instance as most often it contains the predefined/hardcoded info. Actual fees should only be accessed from markets and currencies.\n\nNOTE: Previously we used fetchTransactionFee(s) to fetch the transaction fees, which are now DEPRECATED and these functions have been replace by fetchDepositWithdrawFee(s)\n\nYou call / to fetch the trading fees, / to fetch the deposit & withdraw fees.\n\nOrders, private trades, transactions and ledger entries may define the following info in their field:\n\nTrading fees are properties of markets. Most often trading fees are loaded into the markets by the call. Sometimes, however, the exchanges serve fees from different endpoints.\n\nThe method can be used to precalculate trading fees that will be paid. WARNING! This method is experimental, unstable and may produce incorrect results in certain cases. You should only use it with caution. Actual fees may be different from the values returned from , this is just for precalculation. Do not rely on precalculated values, because market conditions change frequently. It is difficult to know in advance whether your order will be a market taker or maker.\n\nThe method will return a unified fee structure with precalculated fees for an order with specified params.\n\nAccessing trading fee rates should be done via which is the recommended approach. If that method is not supported by exchange, then via the property, like so:\n\nThe markets stored under the property may contain additional fee related information:\n\nWARNING! fee related information is experimental, unstable and may only be partial available or not at all.\n\nMaker fees are paid when you provide liquidity to the exchange i.e. you market-make an order and someone else fills it. Maker fees are usually lower than taker fees. Similarly, taker fees are paid when you take liquidity from the exchange and fill someone else's order.\n\nFees can be negative, this is very common amongst derivative exchanges. A negative fee means the exchange will pay a rebate (reward) to the user for the trading.\n\nAlso, some exchanges might not specify fees as percentage of volume, check the field of the market to be sure.\n\nSome exchanges have an endpoint for fetching the trading fee schedule, this is mapped to the unified methods , and\n\nAccessing transaction fee rates should be done via the property. This aspect is not unified yet and is subject to change.\n\nSome exchanges have an endpoint for fetching the transaction fee schedule, this is mapped to the unified methods\n\nTo trade with leverage in spot or margin markets, currency must be borrowed as a loan. This borrowed currency must be payed back with interest. To obtain the amount of interest that has accrued you can use the method\n• code (String) The unified currency code for the currency of the interest (e.g. )\n• symbol (String) The market symbol of an isolated margin market, if undefined, the interest for cross margin markets is returned (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to receive interest records for (e.g. )\n• limit (Integer) The number of borrow interest structures to retrieve (e.g. )\n\nTo borrow and repay currency as a margin loan use , , and .\n• code (String) required The unified currency code for the currency to be borrowed or repaid (e.g. )\n• amount (Float) required The amount of margin to borrow or repay (e.g. )\n• symbol (String) required The unified CCXT market symbol of an isolated margin market (e.g. )\n• code (String) required The unified currency code for the currency to be borrowed or repaid (e.g. )\n• amount (Float) required The amount of margin to borrow or repay (e.g. )\n\nNote: through the manual we use term \"collateral\" which means current margin balance, but do not confuse it with \"initial margin\" or \"maintenance margin\":\n\nFor example, when you had opened an isolated position with 50$ initial margin and the position has unrealized profit of -15$, then your position's collateral will be 35$. However, if we take that Maintenance Margin requirement (to keep the position open) by exchange hints $25 for that position, then your collateral should not drop below it, otherwise the position will be liquidated.\n\nTo increase, reduce or set your margin balance (collateral) in an open leveraged position, use , and respectively. This is kind of like adjusting the amount of leverage you're using with a position that's already open.\n\nSome scenarios to use these methods include\n• if the trade is going against you, you can add margin to, reducing the risk of liquidation\n• if your trade is going well you can reduce your position's margin balance and take profits\n• amount (String) required Amount of margin to add or reduce (e.g. )\n\nYou can fetch the history of margin adjustments made using the methods above or automatically by the exchange using the following method\n• since (Integer) Timestamp (ms) of the earliest time to retrieve margin adjustments for for (e.g. )\n• limit (Integer) The number of margin structures to retrieve (e.g. )\n\nUpdates the type of margin used to be either\n• One account is used to share collateral between markets. Margin is taken from total account balance to avoid liquidation when needed.\n• Each market, keeps collateral in a separate account\n• marginMode (String) required the type of margin used Unified margin types:\n• symbol (String) Unified CCXT market symbol (e.g. ) required on most exchanges. Is not required when the margin mode is not specific to a market\n\nCommon reasons for why an exchange might have\n• the exchange does not offer leveraged trading\n• the exchange only offers one of or margin modes, but does not offer both\n• margin mode must be set using an exchange specific parameter within when using\n\nSome exchange apis return an error response when a request is sent to set the margin mode to the mode that it is already set to (e.g. Sending a request to set the margin mode to for the market when the account already has set to use cross margin). CCXT doesn't see this as an error because the end result is what the user wanted, so the error is suppressed and the error result is returned as an object.\n\nSome methods allow the usage of a parameter that can be set to either or . This can be useful for specifying the directly within the methods params, for use with spot margin or contract markets. To specify a spot margin market, you need to use a unified spot symbol or set the market type to spot, while setting the marginMode parameter to or .\n\nUse a unified spot symbol, while setting the marginMode parameter.\n\nThe method can be used to obtain the set margin mode for a market. The method can be used to obtain the set margin mode for multiple markets at once.\n\nYou can access the set margin mode by using:\n• symbol (String) Unified CCXT market symbol (e.g. ) required on most exchanges. Is not required when leverage is not specific to a market (e.g. If leverage is set for the account and not per market)\n\nThe method can be used to obtain the set leverage for a market. The method can be used to obtain the set leverage for multiple markets at once.\n\nYou can access the set leverage by using:\n\nThis can include futures with a set expiry date, perpetual swaps with funding payments, and inverse futures or swaps. Information about the positions can be served from different endpoints depending on the exchange. In the case that there are multiple endpoints serving different types of derivatives CCXT will default to just loading the \"linear\" (as oppose to the \"inverse\") contracts or the \"swap\" (as opposed to the \"future\") contracts.\n\nTo get information about positions currently held in contract markets, use\n• symbols ([String]) Unified CCXT market symbols, do not set to retrieve all positions (e.g. )\n• symbol ([String]) Unified CCXT market symbols, do not set to retrieve all positions (e.g. )\n• since (Integer) Timestamp (ms) of the earliest time to retrieve positions for (e.g. )\n• limit (Integer) The number of position structures to retrieve (e.g. )\n\nPositions allow you to borrow money from an exchange to go long or short on an market. Some exchanges require you to pay a funding fee to keep the position open.\n\nWhen you go long on a position you are betting that the price will be higher in the future and that the price will never be less than the .\n\nAs the price of the underlying index changes so does the unrealisedPnl and as a consequence the amount of collateral you have left in the position (since you can only close it at market price or worse). At some price you will have zero collateral left, this is called the \"bust\" or \"zero\" price. Beyond this point, if the price goes in the opposite direction far enough, the collateral of the position will drop below the . The maintenanceMargin acts as a safety buffer between your position and negative collateral, a scenario where the exchange incurs losses on your behalf. To protect itself the exchange will swiftly liquidate your position if and when this happens. Even if the price returns back above the liquidationPrice you will not get your money back since the exchange sold all the you bought at market. In other words the maintenanceMargin is a hidden fee to borrow money.\n\nIt is recommended to use the and instead of the and since these tend to be more accurate. The maintenanceMargin might be calculated from other factors outside of the maintenanceMarginPercentage including the funding rate and taker fees, for example on kucoin.\n\nAn inverse contract will allow you to go long or short on BTC/USD by putting up BTC as collateral. Our API for inverse contracts is the same as for linear contracts. The amounts in an inverse contracts are quoted as if they were traded USD/BTC, however the price is still quoted terms of BTC/USD. The formula for the profit and loss of a inverse contract is . The profit and loss and collateral will now be quoted in BTC, and the number of contracts are quoted in USD.\n\nTo quickly close open positions with a market order, use\n• side optional a string literal for the direction of your order. Some exchanges require it. Unified sides:\n• give quote currency and receive base currency; for example, buying means that you will receive bitcoins for your dollars.\n• give base currency and receive quote currency; for example, buying means that you will receive dollars for your bitcoins.\n\nIt is the price at which the . The price has gone in the opposite direction of your position to the point where the is only maintenanceMargin collateral left and if it goes any further the position will have negative collateral.\n\nPerpetual swap (also known as perpetual future) contracts maintain a market price that mirrors the price of the asset they are based on because funding fees are exchanged between traders who hold positions in perpetual swap markets.\n\nIf the contract is being traded at a price that is higher than the price of the asset they represent, then traders in long positions pay a funding fee to traders in short positions at specific times of day, which encourages more traders to enter short positions prior to these times.\n\nIf the contract is being traded at a price that is lower than the price of the asset they represent, then traders in short positions pay a funding fee to traders in long positions at specific times of day, which encourages more traders to enter long positions prior to these times.\n\nThese fees are usually exchanged between traders with no commission going to the exchange\n\nThe method can be used to retrieve an accounts history of funding fees paid or received\n• since (Integer) Timestamp (ms) of the earliest time to retrieve funding history for (e.g. )\n• limit (Integer) The number of funding history structures to retrieve (e.g. )\n\nThe method can be used to retrieve a quote that can be used for a conversion trade. The quote usually needs to be used within a certain timeframe specified by the exchange for the convert trade to execute successfully.\n• fromCode (String) required The unified currency code for the currency to convert from (e.g. )\n• toCode (String) required The unified currency code for the currency to be converted into (e.g. )\n• amount (Float) Amount to convert in units of the from currency (e.g. )\n\nThe method can be used to create a conversion trade order using the id retrieved from fetchConvertQuote. The quote usually needs to be used within a certain timeframe specified by the exchange for the convert trade to execute successfully.\n• fromCode (String) required The unified currency code for the currency to convert from (e.g. )\n• toCode (String) required The unified currency code for the currency to be converted into (e.g. )\n• amount (Float) Amount to convert in units of the from currency (e.g. )\n\nThe method can be used to fetch a specific conversion trade using the trades id.\n• code (String) The unified currency code of the conversion trade (e.g. )\n\nThe method can be used to fetch the conversion history for a specified currency code.\n• code (String) The unified currency code to fetch conversion trade history for (e.g. )\n• since (Integer) Timestamp of the earliest conversion (e.g. )\n• limit (Integer) The maximum number of conversion structures to retrieve (e.g. )\n\nIn some specific cases you may want a proxy, when:\n• Exchange is not available in your location\n• Your IP is forbidden by exchange\n• You experience random restriction by exchange, like DDoS protection by Cloudflare\n\nHowever, beware that each added intermediary might add some latency to requests.\n\nNote for Go users: After setting any proxy property, you must call to apply the changes:\n\nHowever be aware that each added intermediary might add some latency to requests.\n\nCCXT supports the following proxy types (note, each of them also have callback support):\n\nThis property prepends an url to API requests. It might be useful for simple redirection or bypassing CORS browser restriction.\n\nwhile 'YOUR_PROXY_URL' could be like (use the slash accordingly):\n\nSo requests will be made to i.e. . ( You can also have a small proxy script running on your device/webserver to use it in - \"sample-local-proxy-server\" in examples folder).\n\nThis approach works only for REST requests, but not for websocket connections. ((How to test if your proxy works))[#test-if-your-proxy-works]\n\nTo set a real http(s) proxy for your scripts, you need to have an access to a remote http or https proxy, so calls will be made directly to the target exchange, tunneled through your proxy server:\n\nThis approach only affects non-websocket requests of ccxt. To route CCXT's WebSockets connections through proxy, you need to specifically set (or ) property, in addition to the (or ), so your script should be like:\n\nSo, both connections (HTTP & WS) would go through proxies. ((How to test if your proxy works))[#test-if-your-proxy-works]\n\nYou can also use socks proxy with the following format:\n\n((How to test if your proxy works))[#test-if-your-proxy-works]\n\nAfter setting any of the above listed proxy properties in your ccxt snippet, you can test whether it works by pinging some IP echoing websites - check a \"proxy-usage\" file in examples.\n\n**Instead of setting a property, you can also use callbacks :\n\nIf you need for special cases, you can override property like:\n\nDepending your programming language, you can set custom proxy agents.\n• For JS, see this example\n• For Python, see the following examples: proxies-for-synchronous-python, proxy-asyncio-aiohttp-python-3, proxy-asyncio-aiohttp-socks, proxy-sync-python-requests-2-and-3\n\nCORS (known as Cross-Origin Resource Sharing) affects mostly browsers and is the cause of the well-know warning No 'Access-Control-Allow-Origin' header is present on the requested resource . It happens when a script (running in a browser) makes a request to a 3rd party domain (by default such requests are blocked, unless the target domain explicitly allows it). So, in such cases you will need to communicate with a \"CORS\" proxy, which would redirect requests (as opposed to direct browser-side request) to the target exchange. To set a CORS proxy, you can run sample-local-proxy-server-with-cors example file and in ccxt set the property to route requests through cors/proxy server.\n\nSome users might want to control how CCXT handles arithmetic operations. Even though it uses numeric types by default, users can switch to fixed-point math using string types. This can be done by:\n\nThe error handling with CCXT is done with the exception mechanism that is natively available with all languages.\n\nTo handle the errors you should add a block around the call to a unified method and catch the exceptions like you would normally do with your language:\n\nWhen dealing with HTTP requests, it's important to understand that requests might fail for various reasons. Common causes of these failures include the server being unavailable, network instability, or temporary server issues. To handle such scenarios gracefully, CCXT provide an option to automatically retry failed requests. You can set the value of and to configure the number of retries and the delay between retries, example:\n\nIt's important to highlight that only server/network-related issues will be part of the retry mechanism; if the user gets an error due to or the request will not be repeated.\n\nAll exceptions are derived from the base BaseError exception, which, in its turn, is defined in the ccxt library like so:\n\nThe exception inheritance hierarchy lives in this file: https://github.com/ccxt/ccxt/blob/master/ts/src/base/errorHierarchy.ts , and visually can be outlined like shown below:\n\nThe class is a generic root error class for all sorts of errors, including accessibility and request/response mismatch. If you don't need to catch any specific subclass of exceptions, you can just use , where all exception types are being caught.\n\nFrom derives two different families of errors: and (they also have their specific sub-types, as explained below).\n\nAn might happen when user sends correctly constructed & valid request to exchange, but a non-deterministic problem occurred:\n\nSuch exceptions are temporary and re-trying the request again might be enough. However, if the error still happens, then it may indicate some persistent problem with the exchange or with your connection.\n\nhas the following sub-types: , (includes sub-type ), , .\n\nThis exception is thrown in cases when cloud/hosting services (Cloudflare, Incapsula or etc..) limits requests from user/region/location or when the exchange API restricts user because of making abnormal requests. This exception also contains specific sub-type exception , which directly means that user makes much frequent requests than tolerated by exchange API engine.\n\nThis exception is raised when the connection with the exchange fails or data is not fully received in a specified amount of time. This is controlled by the exchange's property. When a is raised, the user doesn't know the outcome of a request (whether it was accepted by the exchange server or not).\n\nThus it's advised to handle this type of exception in the following manner:\n• for fetching requests it is safe to retry the call\n• for a request to a user is required to retry the same call the second time. A subsequent retry to will return one of the following possible results:\n• a request is completed successfully, meaning the order has been properly canceled now\n• an exception is raised, which means the order was either already canceled on the first attempt or has been executed (filled and closed) in the meantime between the two attempts.\n• if a request to fails with a the user should:\n• call , , to check if the request to place the order has succeeded and the order is now open\n• if the order is not the user should to check if the balance has changed since the order was created on the first run and then was filled and closed by the time of the second check.\n\nThis type of exception is thrown when the underlying exchange is unreachable. The ccxt library also throws this error if it detects any of the following keywords in response:\n\nRaised when your nonce is less than the previous nonce used with your keypair, as described in the Authentication section. This type of exception is thrown in these cases (in order of precedence for checking):\n• You are not rate-limiting your requests or sending too many of them too often.\n• Your API keys are not fresh and new (have been used with some different software or script already, just always create a new keypair when you add this or that exchange).\n• The same keypair is shared across multiple instances of the exchange class (for example, in a multithreaded environment or in separate processes).\n• Your system clock is out of synch. System time should be synched with UTC in a non-DST timezone at a rate of once every ten minutes or even more frequently because of the clock drifting. Enabling time synch in Windows is usually not enough! You have to set it up with the OS Registry (Google \"time synch frequency\" for your OS).\n\nIn contrast to , the is mostly happening when the request is impossible to succeed (because of factors listed below), so even if you retry the same request hundreds of times, they will still fail, because the request is being made incorrectly.\n\nPossible reasons for this exception:\n• endpoint is switched off by the exchange\n• symbol not found on the exchange\n• the format of parameters is incorrect\n• some problem happening on user-side that needs to be fixed\n\nhas the following sub-type exceptions:\n• : when the endpoint/operation is not offered or supported by the exchange API.\n• : user sends an incorrectly constructed request/parameter/action that is invalid/unallowed (i.e.: \"invalid number\", \"forbidden symbol\", \"size beyond min/max limits\", \"incorrect precision\", etc). Retrying would not help in this case, the request needs to be fixed/adjusted first.\n• - user sends a correctly constructed request (that should be accepted by the exchange in a typical case), but some deterministic factor prevents your request to succeed. For example, your current account status might not allow it (i.e. \"please close existing positions before changing the leverage\", \"too many pending orders\", \"your account in wrong position/margin mode\") or at the give moment symbol is not tradable (i.e. \"MarketClosed\") or some explained factors, where you need to take a specific action (i.e. change some setting at first, or wait till specific moment). So, once again: OperationFailed can be blindly re-tried and should success, while is a failure that depends on specific exact factors that need to be considered, before request can be retried.\n• : when an exchange requires one of the API credentials that you've missed to specify, or when there's a mistake in the keypair or an outdated nonce. Most of the time you need and , sometimes you also need and/or if exchange API requires it.\n• : when there's no access for specified action or insufficient permissions on the specified .\n• : when you don't have enough currency on your account balance to place an order.\n• : when encountering a bad funding address or a funding address shorter than (10 characters by default) in a call to , or .\n• : the base class for all exceptions related to the unified order API.\n• : when you are trying to fetch or cancel a non-existent order.\n\nIn case you experience any difficulty connecting to a particular exchange, do the following in order of precedence:\n• Make sure that you have the most recent version of ccxt. Never trust your package installer (whether it is , or ), instead always check your actual (real) runtime version number by running this code in your environment:\n• Check the Issues or Announcements for recent updates.\n• Make sure you have not turned off rate-limiter with (If anyone has custom rate-limit solution built, ensure it does not misbehave).\n• If you use ccxt's proxy functionality, ensure it does not misbehave.\n• Turn to get more detail about it! exchange = ccxt.binance() exchange.load_markets() exchange.verbose = True # for less noise, you can set that after `load_markets`, but if the error happens during `load_markets` then place this line before it # ... your codes here ... Your code to reproduce the issue + verbose output is required in order to get help.\n• Python people can turn on DEBUG logging level with a standard pythonic logger, by adding these two lines to the beginning of their code:\n• Use verbose mode to make sure that the used API credentials correspond to the keys you intend to use. Make sure there's no confusion of keypairs.\n• Try a fresh new keypair if possible.\n• Check the permissions on the keypair with the exchange website!\n• Check your nonce. If you used your API keys with other software, you most likely should override your nonce function to match your previous nonce value. A nonce usually can be easily reset by generating a new unused keypair. If you are getting nonce errors with an existing key, try with a new API key that hasn't been used yet.\n• Check your request rate if you are getting nonce errors. Your private requests should not follow one another quickly. You should not send them one after another in a split second or in short time. The exchange will most likely ban you if you don't make a delay before sending each new request. In other words, you should not hit their rate limit by sending unlimited private requests too frequently. Add a delay to your subsequent requests or enable the built-in rate-limiter, like shown in the long-poller examples, also here.\n• Read the docs for your exchange and compare your verbose output to the docs.\n• Check your connectivity with the exchange by accessing it with your browser.\n• Check your connection with the exchange through a proxy.\n• Try accesing the exchange from a different computer or a remote server, to see if this is a local or global issue with the exchange.\n• Check if there were any news from the exchange recently regarding downtime for maintenance. Some exchanges go offline for updates regularly (like once a week).\n• Make sure that your system time in sync with the rest of the world's clocks since otherwise you may get invalid nonce errors.\n• Use the option or instantiate your troublesome exchange with to see the HTTP requests and responses in details. The verbose output will also be of use for us to debug it if you submit an issue on GitHub.\n• Some exchanges are not available in certain countries, using a proxy might be the solution in such cases.\n• If you are getting authentication errors or 'invalid keys' errors, those are most likely due to a nonce issue.\n• Some exchanges do not state it clearly if they fail to authenticate your request. In those circumstances they might respond with an exotic error code, like HTTP 502 Bad Gateway Error or something that's even less related to the actual cause of the error."
    },
    {
        "link": "https://docs.ccxt.com",
        "document": ""
    },
    {
        "link": "https://medium.com/@deepml1818/comprehensive-cryptocurrency-trading-analysis-script-using-ccxt-and-ta-libraries-952aeaf0f1d2",
        "document": "Let’s break down the script into parts, providing detailed explanations for each section.\n\nExplanation\n\n- ccxt: A library that provides a unified way to connect to many different cryptocurrency exchanges, fetch market data, and perform trading operations.\n\n- pandas: A powerful data manipulation and analysis library. It is used to handle and analyze the historical price data fetched from the exchange.\n\n- ta: A library for technical analysis that includes a wide range of indicators like SMA, RSI, MACD, Bollinger Bands, etc.\n\nUse Cases\n\n- ccxt: Connecting to exchanges such as Binance, Coinbase, Gate.io, etc., to fetch real-time or historical market data.\n\n- pandas: Managing and analyzing time-series data for financial analysis and trading strategies.\n\n- ta: Calculating various technical indicators to inform trading decisions.\n\nExplanation\n\n- This function dynamically initializes an exchange object based on the provided exchange ID. The `getattr` function retrieves the exchange class from the `ccxt` module.\n\nUse Cases\n\n- Dynamic Exchange Connection: Easily switch between different exchanges by changing the `exchange_id` parameter. Useful for backtesting strategies on different markets or deploying a trading bot that can operate across multiple exchanges.\n\nExplanation\n\n- fetch_ohlcv: Fetches historical OHLCV (Open, High, Low, Close, Volume) data from the exchange.\n\n- DataFrame: Converts the fetched data into a Pandas DataFrame for easier manipulation and analysis.\n\n- Timestamp Conversion: Converts the timestamp from milliseconds to a readable datetime format.\n\nUse Cases\n\n- Historical Data Analysis: Analyze past price movements to identify patterns and trends.\n\n- Backtesting: Use historical data to test trading strategies before deploying them in live markets.\n\n- Data Visualization: Plot historical price data for visual analysis.\n\nExplanation\n\n- SMA: Simple Moving Average calculated over a window of 14 periods.\n\n- RSI: Relative Strength Index, a momentum indicator calculated over 14 periods.\n\n- MACD: Moving Average Convergence Divergence with its signal line.\n\n- Bollinger Bands: Calculates the middle, upper, and lower bands for volatility analysis.\n\nUse Cases\n\n- Trend Analysis: SMA helps in identifying the direction of the trend.\n\n- Momentum Analysis: RSI indicates overbought or oversold conditions.\n\n- Trend Reversals: MACD helps in spotting changes in the strength, direction, momentum, and duration of a trend.\n\n- Volatility Analysis: Bollinger Bands highlight periods of high or low volatility.\n\nExplanation\n\n- Condition Columns: Creates new columns in the DataFrame representing specific conditions based on the indicators.\n\n — sma_above_close: Checks if the close price is above the SMA.\n\n — rsi_below_30: Checks if the RSI is below 30 (oversold condition).\n\n — macd_above_signal: Checks if the MACD is above its signal line (bullish indicator).\n\n — bollinger_breakout: Checks if the close price is outside the Bollinger Bands (indicating a breakout).\n\nUse Cases\n\n- Strategy Development: Define custom conditions for entry and exit points in a trading strategy.\n\n- Signal Generation: Generate buy or sell signals based on these conditions.\n\n- Risk Management: Use conditions to set stop-loss or take-profit levels.\n\nExplanation\n\n- Combines individual conditions to form more complex logic.\n\n — condition_1: Both `sma_above_close` and `rsi_below_30` must be True.\n\n — condition_2: Both `macd_above_signal` and `bollinger_breakout` must be True.\n\nUse Cases\n\n- Complex Strategies: Develop more sophisticated trading strategies that rely on multiple indicators.\n\n- Enhanced Filtering: Filter out noisy signals by combining multiple conditions to ensure stronger confirmation.\n\nExplanation\n\n- Filters the DataFrame to show only rows where either `condition_1` or `condition_2` is True.\n\n- Prints relevant columns of the filtered DataFrame.\n\nUse Cases\n\n- Signal Review: Manually review the signals generated by the conditions.\n\n- Backtesting: Check how often and under what conditions the strategy triggers signals.\n\n- Debugging: Validate the conditions and ensure they work as intended by examining the filtered results.\n\nExplanation\n\n- Orchestrates the entire workflow by calling each of the above functions in sequence.\n\n- Handles exceptions and prints any errors that occur.\n\nUse Cases\n\n- Script Execution: Provides a starting point for running the complete analysis workflow.\n\n- Error Handling: Ensures the script runs smoothly and handles any issues that arise during execution.\n\nExplanation\n\n- Executes the `main` function if the script is run as the main module.\n\nUse Cases\n\n- Standalone Execution: Allows the script to be run directly, executing the `main` function to perform the analysis and print results."
    },
    {
        "link": "https://github.com/ccxt/ccxt/issues/6969",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://stackoverflow.com/questions/57281737/how-to-place-percentage-orders-with-binance-api-and-python-ccxt",
        "document": "I'm playing with Binance API to make my trading bot with Python 3.6. and CCXT library (here you find the docs ).\n\nOne very useful thing they have in their site is the capability to place orders for a percentage of your current balance:\n\nfor example if I'm lookin at crypto coin pair, and I have on my account, I can choose between buying amount of or using of my account's for buying, consequently buying the maximum amount of I can.\n\nI read the docs many times, but I can't find the option to do these \"percentage of balance\" orders with the API in any way: the only thing I can do is passing a to the order function. This is how i place orders now:\n\nDo anyone know if there is a built-in capability to do a percentage order? If API gives no way to do so, would you suggest some workarounds?\n\nI want to be able to give to the API percentage of my current balance as an , so I can always use the full of it without having to update when fees are detracted"
    }
]