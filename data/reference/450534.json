[
    {
        "link": "https://forum.arduino.cc/t/how-to-create-and-free-dynamic-arrays-with-arduino/934662",
        "document": "WARNING: This is an attempt to clarify if there is any safe way to use dynamic arrays on Arduino Platform ! The recommended way often is to avoid dynamic memory allocation due to the missing memory manager who would clean up SRAM after the memory space is freed again. If you want to use dynamic arrays please read the discussion carefully and do NOT start before reading the end. However - despite of that - from time to time there seems to be some interest in dynamic arrays in Arduino applications. Therefore I looked up some old C code implementations from 1989 and compiled them into a sketch that I tested with IDE1.8.15 and an UNO. The sketch may be of assistance (at least for 2D arrays) and to demo the basic principle which can be adopted to multidimensional arrays. Experts in the field are welcome to correct and enhance the sketch which I publish here as a start for those who want to use dynamic arrays in their applications. There are only two functions in the example sketch which are required in an application to create/free 2D arrays that can be addressed like MyArray[irow][col]:: Take care to declare the array variable as int **MyArray. If you need byte or long instead of arrays of integer,you may adopt the idim2 routine. Be aware that dynamically allocating memory may lead to failures if your application falls short of free heap space ... // \"Old School\" creation of dynamic arrays // based on an example from a C language course // held in ... 1989 ... // written by ec2021 // // // The following routine is only used to check memory allocation in this example! // ......................... // Begin of Memory Routine // ......................... extern unsigned int __bss_end; extern unsigned int __heap_start; extern void *__brkval; int freeMemory() { int free_memory; if((int)__brkval == 0) free_memory = ((int)&free_memory) - ((int)&__bss_end); else free_memory = ((int)&free_memory) - ((int)__brkval); return free_memory; } // ......................... // End of Memory Routine // ......................... // ......................... // Begin of idim2() // This is where the \"real work\" is done // to create the 2D array // First the memory for all (row*col) data is allocated // if this does not fail, memory for the pointers to the beginning // of each row is allocated // If this is also done successfully (calloc returns NULL in case of // failure), the pointers are initialized with the address of their // specific row // The returned value points to the beginning of the pointer array // thus allowing the compiler to address rows and cols via \"a[rows][cols]\" // ......................... int **idim2(int row, int col) { // char *calloc(); int i; register int **prow, *pdata; pdata = (int *) calloc(row * col, sizeof(int)); if (pdata == (int *) NULL ){ Serial.println(\"No heap space for data\"); exit(1); }; prow = (int **)calloc(row, sizeof (int *)); if (prow == (int **) NULL) { Serial.println(\"No heap space for row pointers\"); exit(1); }; for (i = 0; i < row; i++) { prow[i] = pdata; pdata += col; }; return prow; } // ......................... // End of idim2() // ......................... void ifree2(int **pa) { free(*pa); free(pa); } void Create2D(int rowsc, int colsc) { int **a; int inum = 1; register int i, j; char out[256]; int memBefore = freeMemory(); Serial.println(\"\n\n..........................................................\"); Serial.println(\"Free memory before calloc: \"+String(memBefore)); a = idim2(rowsc, colsc); Serial.println(\"Free memory after calloc: \"+String(freeMemory())); Serial.println(\"Memory used : \"+String(memBefore-freeMemory())); for (i = 0; i < rowsc; i++) for (j = 0; j < colsc; j++) a[i][j] = inum++; char Tab = 9; for (i = 0; i < rowsc; i++) for (j = 0; j < colsc; j++) { sprintf(out,\"%3d%2c\",a[i][j],(j+1) % colsc ? ' ' : '\n\n'); Serial.print(out); } ifree2(a); } void setup() { // Runs once Serial.begin(115200); Create2D(2,3); Create2D(8,8); Create2D(7,12); Create2D(4,16); } void loop() { // Nothing to do ... }\n\n@6v6gt and @westfw : Maybe it is like with racing cars versus trucks Quick and lightweight but little load to carry or the other way around ... So best practice seems to be to avoid dynamic memory allocation due to the hazard of memory fragmentation and crash between heap and stack. If one still is keen to define arrays during runtime it might be a good idea to do this in a function with a local array but also check for available memory with some preserved space to avoid weird program behaviour. You may check the following sketch that I have tested empirically without encountering problems (maybe bad luck ...?!?) although I stressed it by recursive calls. It works of course ONLY with pod (plain old data like byte, int etc.). By using a while-loop instead of the standard main loop() you keep almost all variables in the local function thus utilizing the standard way of allocating and freeing data without the need to take care of that on your own: // A const value that preserves bytes // to (hopefully) avoid running out of memory between heap and stack // that might cause weird behaviour of the program const byte c_reserve = 200; // The depth of the recursive use of the function UseArray() // Recursive calls are only used in this example to definetely // stress memory allocation and see what happens ... int depth; // The main function to create arrays in runtime // Most lines are only useful for this example // The core lines required are // const byte c_reserved = 200; // void UseArray(byte Rows, byte Cols, byte reserve){ // if (Cols*Rows*sizeof(WhatEverTypeOfPOD) + reserve >= freeMemory()){ return }; // WhatEverTypeOfPOD MyA[Rows][Cols]; // while(YouWantToLoop) { // // do Something in here // } // } // With // \"WhatEverTypeOfPOD\" may be any type of **plain old data**, such as byte, int, long, float // do not use this with types/objects that require constructor/destructor calls! // Cols, Rows = 1 or more // c_reserved = 200 or more (no gurantee, but worked fine in this stress test ...) // forward declaration of getFreeMemory() int getFreeMemory(); void UseArray(byte Rows, byte Cols, byte reserve){ depth++; Serial.println(\"Depth = \"+String(depth)); if (Cols*Rows*sizeof(int) + reserve >= getFreeMemory()){ Serial.print (\"Use Array [\"+String(Rows)+\"][\"+String(Cols)+\"] requires \"+String(Cols*Rows*sizeof(int))+ \" Bytes \"); Serial.println(\"plus \"+String(reserve)+\" reserved bytes, but there are only \"+String(getFreeMemory())+\" Bytes available\"); return; } int MyA[Rows][Cols]; static int Test = 1; Serial.println(\"Test = \"+String(Test++)); Serial.println(\"Use Array [\"+String(Rows)+\"][\"+String(Cols)+\"] with Free Memory = \"+String(getFreeMemory())); for (int i= 0;i<Rows;i++) for (int j= 0;j<Cols;j++) MyA[i][j] = (i+1)*100+j; for (int i= 0;i<Rows;i++){ for (int j= 0;j<Cols;j++) Serial.print(String(MyA[i][j])+char(9)); Serial.println(); } // In this test example you start recursive // \"dynamic\" array creation with an 's' per Serial in the // following while-loop. // It will stop here again after all recursive function calls // have come back to the first call in the main loop() // where depth is reset to zero (see below) // boolean YouAreHappy = (depth == 1); if (YouAreHappy) Serial.println(\"\n\nStart recursive calls per Serial input with 's' \"); while (YouAreHappy) { // Put your loop() content here if (Serial.available()){ YouAreHappy = (Serial.read() != 's'); } // End of loop() example } UseArray(random(2,21),random(2,21),c_reserve); depth--; Serial.println(\"Returned to \"+String(depth)); } void setup() { Serial.begin(115200); Serial.println(\"\n\n-----------------------------\"); } void loop() { Serial.println(\"Free Memory in loop() = \"+String(getFreeMemory())); depth = 0; UseArray(random(2,21),random(2,21),c_reserve); } extern unsigned int __bss_end; extern void *__brkval; int getFreeMemory(){ int free_memory; if((int)__brkval == 0) free_memory = ((int)&free_memory) - ((int)&__bss_end); else free_memory = ((int)&free_memory) - ((int)__brkval); return free_memory; }\n\nWow! If I believed everything in this thread, I would never, never, EVER use dynamic allocation on any Arduino. Ever! Fortunately, I know better. To say \"there is not memory manager\" is nonsense. Of course there is a memory manager. What is missing is automatic GARBAGE COLLECTION, which is a \"feature\" of c and c++, regardless of platform. Does that mean using dynamic allocation is guaranteed to fragment memory and make your applcation unstable? No, it does not. The memory manager (Yes, there really is one!) manages heap allocation, using a linked list of allocated blocks. When a new allocation is performed, a link is added to the list, ot track the newly allocated block. When that block is freed, the newly freed block is combined with adjacent free blocks, creating the largest possible free blocks between/around any remaining allocated blocks. So, memory does not automatically become fragmented any more than absolutely necessary. If you allocate a bunch of blocks, and then de-allocate all of them, the free memory pool will look exactly as it did when you started. I have written programs that used malloc and free to allocate, print, and discard large numbers of debug messages. Those programs run for days with no errors. You just have to have reasonable expectations for how much memory you can use at any given time, and not assume you can run with 95% of RAM allocated at all times. Using Strings certainly makes things worse, as it can significantly increase the number of allocations, but, even then, if your expectations are reasonable, they will work just fine. Finally, 99.99% of dynamic allocation problems are self-inflicted. If you are going to use it, you MUST pay attention to return codes, and figure out how to gracefully handle failed allocations. Most people just do a malloc or new, and assume it succeeds. THAT is a recipe of disaster. Once an allocation fails, if it is not dealt with, things will go downhill in a big hurry. And if you want to see how it all works, there are numerous functions out there to display the heap and stack status, and you can even walk the heap linked list yourseld and see EXACTLY what malloc, free, new, etc. do, and HOW they do it. Or, simply look at the source code. It's really pretty simple. The detailed implementations ARE different on different platforms, so it's not exactly the same on AVR-based boards as it is on ARM-based boards. But the basic principles are the same on all platforms.\n\nI am glad you showed up here, because my feeling is that the issue with dynamic memory management on Arduino platform seems to split the community and many of the statements are based on partial knowledge or at least partial information given ... That's why I started this tread and came up with the \"old fashioned\" C calloc, others brought in the C++ way of new / delete[] and I finally wrote a sketch that works fine without all of the above (because it relies on the standard way of arranging heap/stack memory with local functions). I recon that it might help to get some more light into the dark when there is a definition of what we consider to be a \"memory manager\":\n• The minimum memory management might be to allocate memory and then free it in reverse sequence, whether it is heap or stack. If done in the right order it should normally not generate any fragmentation. (Or not?)\n• If freeing of memory is not done in exactly the reverse order you might get \"holes\" in the SRAM that could be reused by a simple memory management for the same data type (or something using less bytes leaving smaller \"holes\").\n• Finally, memory mangement of larger systems, especially an OS, would do some garbage collection invisible to the functions/procedures by copying memory content and rearranging pointers to those data. That seems to be a more demanding task as the memory manager has to know exactly who is using what part of the memory and must make sure that noone accesses data during the re-arrangement . Correct (in principle)? It would be nice if some experts could create a documentation of if ever and how you can safely use dynamic memory allocation with Arduino. I am surely not one of those experts, but highly interested in a sound description that allows to understand the background rather than just Do's and Donot's ... Any idea how to bring light into the dark and disenchant the mystery around dynamic memory allocation on Arduino platforms ... without leaving all the google work to thousands of curious people?\n• The minimum memory management might be to allocate memory and then free it in reverse sequence, whether it is heap or stack. If done in the right order it should normally not generate any fragmentation. (Or not?) The order of allocation/de-allocation is NEVER up to the memory manager. It is up to the user/application. The order of allocation/de-allocation is not, should not, be important. Once all allocated block have been freed, you will have a single block of free memory, exactly as when the system was first initialized. That is precisely how it works in Arduino world right now.\n• If freeing of memory is not done in exactly the reverse order you might get \"holes\" in the SRAM that could be reused by a simple memory management for the same data type (or something using less bytes leaving smaller \"holes\"). Yes, and that will always be true, UNLESS you add the considerable complexity of automatic background garbage collection, which c/c++ do not support. That would mean be able to move things around in memory at any time, without disrupting the running applications. In a language that uses pointers/references, that means the values of those pointers/references must be update on-the-fly, WITHOUT the application even knowing it is happening. Even with a full virtual memory system (which few, if any, Arduinos have, the overhead and complexity to do that is quite considerable. This is one of the reasons languages which DO support garbage collection, like Javascript, are so slow and resource-intensive.\n• Finally, memory mangement of larger systems, especially an OS, would do some garbage collection invisible to the functions/procedures by copying memory content and rearranging pointers to those data. That seems to be a more demanding task as the memory manager has to know exactly who is using what part of the memory and must make sure that noone accesses data during the re-arrangement . Correct (in principle)? Yes, but again, that approach is quite complex and resource intensive, and NOT supported by c/c++, regardless of the OS. And not remotely practical on a small microcontroller. It will require more memory, and the entire system will run considerably slower.\n\nYou can look at the avr implementation of malloc() and free() - it's all open source code, after all. \"new\" and \"delete\" on Arduino are just wrappers for malloc/free.\n\n avr-libc malloc and free It's not trivial code; probably on par with the original K&R implementations. It will even aggregate free()ed memory blocks into bigger blocks. It just doesn't have a lot to work with (for example, a \"better\" malloc() might keep separate free lists for different \"popular\" sizes of allocation. I think I even have in mind a \"rule\" that says malloc implementations will always grow in complexity until you also need to implement special purpose memory allocation functions that are simpler and faster.) But now you're talking about more overhead for each allocated or free block, and when you've only got 2k of memory, 10+ bytes of overhead per allocation is painful. C/C++ does not do \"garbage collection\" in the way the term is usually used - freeing up memory that is no longer in use, but was never explicitly free()ed, either. The AVR does not have other users who will use the memory that you've freed. It does not have \"protection\" against over-allocating memory from the heap, and I don't think it even it has checks for the stack overflowing INTO the heap. It does not have \"segmentation error\" capability if you accidentally access memory that doesn't exist. There is probably no want to indicate to a user that a memory allocation failure has occured, or that the board is \"running low.\" I feel vaguely comfortable using malloc() during setup() to make memory for alternative configurations. For example, I think the Adafruit neopixel library will malloc() the data for the actual pixels, and I'm basically OK with that. The Arduino String functions are a particularly poor example of using dynamic allocation, allocating tiny little chunks in random order in ways that make it difficult to re-aggregate the memory. I guess my general rule of thumb is something like:\n• You can use dynamic allocation in cases where it is immediately apparent if the allocation fails.\n\nI don't think it even it has checks for the stack overflowing INTO the heap On AVR board there is some protection against stack overflowing INTO the heap. The memory allocate always ensures there is at least 128bytes left available for stack use. (see the examples in Taming Arduino Strings ) This is one of the things that makes using Strings on AVR boards so safe. Strings also automatically protect against overallocation of the heap without causing your program to crash. The AVR (and others) memory manager also coalesces adjacent empty fragments to improve reuse.\n\n The managing arduino memory reference talks about memory corruption, but that is not possible on AVR boards UNLESS you try and allocate more then 128bytes of stack in method call. Memory corruption is possible (and happens) on ESP2866 and ESP23 boards which do not have the 128byte stack buffer. Allocating lots of small Strings when combined with returning Strings from functions does product memory fragmentation. ESP boards have a 12 char[ ] build into their String class which they use for 'small' Strings to avoid allocating memory on the heap for small Strings. So in summary, dynamic memory allocation on AVR boards is 'safe' if you ALWAYS check the return and handle out-of-memory AND don't use more then 128bytes of local stack in your methods (including arguments). Freeing memory after you are finished with it (and not before) will make your memory go further. The biggest problem (in my mind) using dynamic memory allocation is what to do if/when your program runs out of memory. How does your program recover? The Arduino String library just returns an empty String and keeps going. Your program won't crash but the logic may be screwy.\n\n Using your own dynamic memory, your program has to cope with null pointers in some 'safe' way. This tends to lead to a lot of is pointer null checks."
    },
    {
        "link": "https://forum.arduino.cc/t/dynamic-memory-allocation-how-is-it-supported/1216213",
        "document": "I just learned a bit about C++, and there seems to be the C++ commands New and Delete, that is used for dynamic memory allocation. When I read the reference for the Arduino IDE, I do not find these possibilities. Am I right? I read this link too about memory use of the Arduino microcontrollers:\n\n https://docs.arduino.cc/learn/programming/memory-guide/ I can understand the reason for not implement New and Delete. However, as a programmer you may like to use the heap RAM Area anyway to some dynamic allocation, when you are careful about what you do. Perhaps somebody else can explain what might be helpful in that regard. Can you get an idea about the size and position of the heap RAM area? Actually flash memory is used, and it could be possible to use that as well for some applications.\n\nThe Arduino toolchain uses a full C++ compiler (gcc), so for the most part everything is supported with some exceptions to save memory (No float support in sprintf for example). The Arduino reference is basic and more focussed on the Arduino specific functions in its library, with a helping of things C++ you will find handy in Arduino coding. Use an actual C++ reference if you need more than this.\n\nSo you got one of the secret Nanos with extra RAM. They were a reward for faithful who bought genuine Arduinos - probably a collector’s item one day. Don’t blab it around I’m surprised that Lady Ada hasn’t fixed it since it’s apparently been known for a while. Maybe reach out to her to see if one of her crew could do the needful.\n\nThank you for the advise regarding the Adafruit freeMemory function. You might be interested in seeing a recent discussion: Thanks for the link. Yes. I am still a beginner in C++ and Arduino, and the link with the three/five/zero rule is somewhat above my level yet. Yesterday I posted some debug recorder code, that I have used recently. It was a bit risky for me, because at my level of programming C++, it could easily make me look foolish: I would have liked the code to be placed in a library, so it could be used for more projects more easily, but then I realized, that it was not possible, because I need to transfer some constant definitions from the main code. I think the starter of your linked thread had realized the same problem. When you want to separate the code in a nice way for a problem like this debug recorder try to solve, then I guess, that you need to allocate the memory at run time. Actually it do also open up more possibilities to record more data types and a nicer user interface to such a library.\n\nAre you talking about the Arduino String class or the C++ std::string class? I am not sure, what I talk about. The concept of class is still somewhat blurry for me, but it helped a bit when you say, that String is a class. But the above video showed several member functions, that was not found in the arduino String class definitions. So I guess this confused me. This is some code for arduino: String str; String str2; int n; char ch; void setup() { Serial.begin(9600); str = \"ABC\"; Serial.println(str); n = str.length(); // length() is OK Serial.println( n ); str.clear(); // clear() is not part of the Arduino String class if (str.empty()) {Serial.println(\"string is empty\");}; //empty() is not part of the Arduino String class str.append('D'); // append() is not part of the Arduino String class Serial.println(str); ch = str.at(2); // at() is not part of the Arduino String class str2 = str.substring(0,1); // substring() is OK str.insert(1,\"X\"); // insert() is not part of the Arduino String class n = str.find('B'); // find() is not part of the Arduino String class str.erase(0,1); // erase() is not part of the Arduino String class } void loop() { delay(1); } The YouTuber referenced this webpage with a lot of member functions to a string. Perhaps the names of these member functions are not that agreed upon among C++ compilers."
    },
    {
        "link": "https://forum.arduino.cc/t/how-to-create-and-free-dynamic-arrays-with-arduino/934662/14",
        "document": "I am glad you showed up here, because my feeling is that the issue with dynamic memory management on Arduino platform seems to split the community and many of the statements are based on partial knowledge or at least partial information given ...\n\nThat's why I started this tread and came up with the \"old fashioned\" C calloc, others brought in the C++ way of new / delete[] and I finally wrote a sketch that works fine without all of the above (because it relies on the standard way of arranging heap/stack memory with local functions).\n\nI recon that it might help to get some more light into the dark when there is a definition of what we consider to be a \"memory manager\":\n• The minimum memory management might be to allocate memory and then free it in reverse sequence, whether it is heap or stack. If done in the right order it should normally not generate any fragmentation. (Or not?)\n• If freeing of memory is not done in exactly the reverse order you might get \"holes\" in the SRAM that could be reused by a simple memory management for the same data type (or something using less bytes leaving smaller \"holes\").\n• Finally, memory mangement of larger systems, especially an OS, would do some garbage collection invisible to the functions/procedures by copying memory content and rearranging pointers to those data. That seems to be a more demanding task as the memory manager has to know exactly who is using what part of the memory and must make sure that noone accesses data during the re-arrangement . Correct (in principle)?\n\nIt would be nice if some experts could create a documentation of if ever and how you can safely use dynamic memory allocation with Arduino. I am surely not one of those experts, but highly interested in a sound description that allows to understand the background rather than just Do's and Donot's ...\n\nAny idea how to bring light into the dark and disenchant the mystery around dynamic memory allocation on Arduino platforms ... without leaving all the google work to thousands of curious people?"
    },
    {
        "link": "https://forum.arduino.cc/t/dynamic-memory-allocation-malloc-and-free/408391",
        "document": "I've been looking into \"malloc\" and \"free\" thinking of using them in a project. I have found lots of information describing when and not to use them and the pros and cons of use as well. such as fragmentation (con) or dynamic memory allocation within a function (pro). But I have found no explanation of there syntax. I have the line of code below that I have scavenged from a sketch I know to work Does an one know of any links to good syntax explanation for these functions, or can anyone give me a straight up explanation of the syntax used.\n\nBut I have found no explanation of there syntax. You obviously did not look very far However, why do you think you need to use them ?\n\nThanks for the link, seems like a good site. All my search have the prefix Arduino. I'm not sure if I need to, all the reading I have done suggests it would be a possible option for what I want to do though. I have a large set of data, stored as a two dimensional array. 1929 Bytes in total. I load the data onto another MCU using i2c. I have written a function to complete the load which it does, but wanted to validate the data was loaded correctly. To do this I was thinking of reading the data from the second MPU in 16 byte chunks ( apart from the last 9 Bytes) and comparing it with the corresponding data in the two dimensional array. A Boolean is returned to indicate success or error, success, the routine loops to validate the next 16 Bytes, fail, I get a debug message returned. Originally I was thinking that if I initialise an array within the function to save the 16 byte chunk of data that is read from the MPU for validation it would be taken from the stack memory and then returned when the function closes. No problem. What concerns me is that I have an example sketch that was written by someone who is much better at coding then me.... OK admittedly that does not narrow the list of people down to much less then a few billion but.... The author Jeff Rowberg seems to use malloc to assign memory from the heap. I don't know why but assume there is a good reason. One which I'm not sure of Anyway I need to learn C so I thought it was a good opportunity to learn the use of malloc etc.\n\nFirst of all, malloc() is not Arduino specific; it's C. So don't put 'Arduino' in front of your search I could not find which Arduino you're using; if it's a board with 2k SRAM (e.g. Uno), malloc is not going to save you if you want to allocate 1929 bytes! Test it; even using the F macro for the serial print will not make a difference."
    },
    {
        "link": "https://stackoverflow.com/questions/78037491/how-should-i-dynamically-allocate-memory-inside-of-a-c-function",
        "document": "You might like to include the last token with the TOKEN_EOF indicator at the end of your array. Having an guard or end of array indicator can make loops a bit more intuitive.\n\nI'd also consider have two loops for filling the array with tokens, an inner loop that just pulls in tokens and puts them into the array and an outer loop that checks whether you're done or not and if not does the .\n\nI've also made changes so that the function will do as much as it is capable of doing and returning those results even if incomplete. No telling what kind of cleanup you might need to do in the case of a failure.\n\nFinally, I've become something of a fan of using a to return not only the data from a function but also any other management information needed such as an error indicator.\n\nThis is a complete example that I used to test out some ideas. I've tried to comment things to be helpful."
    },
    {
        "link": "https://forum.arduino.cc/t/how-to-create-and-free-dynamic-arrays-with-arduino/934662",
        "document": "WARNING: This is an attempt to clarify if there is any safe way to use dynamic arrays on Arduino Platform ! The recommended way often is to avoid dynamic memory allocation due to the missing memory manager who would clean up SRAM after the memory space is freed again. If you want to use dynamic arrays please read the discussion carefully and do NOT start before reading the end. However - despite of that - from time to time there seems to be some interest in dynamic arrays in Arduino applications. Therefore I looked up some old C code implementations from 1989 and compiled them into a sketch that I tested with IDE1.8.15 and an UNO. The sketch may be of assistance (at least for 2D arrays) and to demo the basic principle which can be adopted to multidimensional arrays. Experts in the field are welcome to correct and enhance the sketch which I publish here as a start for those who want to use dynamic arrays in their applications. There are only two functions in the example sketch which are required in an application to create/free 2D arrays that can be addressed like MyArray[irow][col]:: Take care to declare the array variable as int **MyArray. If you need byte or long instead of arrays of integer,you may adopt the idim2 routine. Be aware that dynamically allocating memory may lead to failures if your application falls short of free heap space ... // \"Old School\" creation of dynamic arrays // based on an example from a C language course // held in ... 1989 ... // written by ec2021 // // // The following routine is only used to check memory allocation in this example! // ......................... // Begin of Memory Routine // ......................... extern unsigned int __bss_end; extern unsigned int __heap_start; extern void *__brkval; int freeMemory() { int free_memory; if((int)__brkval == 0) free_memory = ((int)&free_memory) - ((int)&__bss_end); else free_memory = ((int)&free_memory) - ((int)__brkval); return free_memory; } // ......................... // End of Memory Routine // ......................... // ......................... // Begin of idim2() // This is where the \"real work\" is done // to create the 2D array // First the memory for all (row*col) data is allocated // if this does not fail, memory for the pointers to the beginning // of each row is allocated // If this is also done successfully (calloc returns NULL in case of // failure), the pointers are initialized with the address of their // specific row // The returned value points to the beginning of the pointer array // thus allowing the compiler to address rows and cols via \"a[rows][cols]\" // ......................... int **idim2(int row, int col) { // char *calloc(); int i; register int **prow, *pdata; pdata = (int *) calloc(row * col, sizeof(int)); if (pdata == (int *) NULL ){ Serial.println(\"No heap space for data\"); exit(1); }; prow = (int **)calloc(row, sizeof (int *)); if (prow == (int **) NULL) { Serial.println(\"No heap space for row pointers\"); exit(1); }; for (i = 0; i < row; i++) { prow[i] = pdata; pdata += col; }; return prow; } // ......................... // End of idim2() // ......................... void ifree2(int **pa) { free(*pa); free(pa); } void Create2D(int rowsc, int colsc) { int **a; int inum = 1; register int i, j; char out[256]; int memBefore = freeMemory(); Serial.println(\"\n\n..........................................................\"); Serial.println(\"Free memory before calloc: \"+String(memBefore)); a = idim2(rowsc, colsc); Serial.println(\"Free memory after calloc: \"+String(freeMemory())); Serial.println(\"Memory used : \"+String(memBefore-freeMemory())); for (i = 0; i < rowsc; i++) for (j = 0; j < colsc; j++) a[i][j] = inum++; char Tab = 9; for (i = 0; i < rowsc; i++) for (j = 0; j < colsc; j++) { sprintf(out,\"%3d%2c\",a[i][j],(j+1) % colsc ? ' ' : '\n\n'); Serial.print(out); } ifree2(a); } void setup() { // Runs once Serial.begin(115200); Create2D(2,3); Create2D(8,8); Create2D(7,12); Create2D(4,16); } void loop() { // Nothing to do ... }\n\n@6v6gt and @westfw : Maybe it is like with racing cars versus trucks Quick and lightweight but little load to carry or the other way around ... So best practice seems to be to avoid dynamic memory allocation due to the hazard of memory fragmentation and crash between heap and stack. If one still is keen to define arrays during runtime it might be a good idea to do this in a function with a local array but also check for available memory with some preserved space to avoid weird program behaviour. You may check the following sketch that I have tested empirically without encountering problems (maybe bad luck ...?!?) although I stressed it by recursive calls. It works of course ONLY with pod (plain old data like byte, int etc.). By using a while-loop instead of the standard main loop() you keep almost all variables in the local function thus utilizing the standard way of allocating and freeing data without the need to take care of that on your own: // A const value that preserves bytes // to (hopefully) avoid running out of memory between heap and stack // that might cause weird behaviour of the program const byte c_reserve = 200; // The depth of the recursive use of the function UseArray() // Recursive calls are only used in this example to definetely // stress memory allocation and see what happens ... int depth; // The main function to create arrays in runtime // Most lines are only useful for this example // The core lines required are // const byte c_reserved = 200; // void UseArray(byte Rows, byte Cols, byte reserve){ // if (Cols*Rows*sizeof(WhatEverTypeOfPOD) + reserve >= freeMemory()){ return }; // WhatEverTypeOfPOD MyA[Rows][Cols]; // while(YouWantToLoop) { // // do Something in here // } // } // With // \"WhatEverTypeOfPOD\" may be any type of **plain old data**, such as byte, int, long, float // do not use this with types/objects that require constructor/destructor calls! // Cols, Rows = 1 or more // c_reserved = 200 or more (no gurantee, but worked fine in this stress test ...) // forward declaration of getFreeMemory() int getFreeMemory(); void UseArray(byte Rows, byte Cols, byte reserve){ depth++; Serial.println(\"Depth = \"+String(depth)); if (Cols*Rows*sizeof(int) + reserve >= getFreeMemory()){ Serial.print (\"Use Array [\"+String(Rows)+\"][\"+String(Cols)+\"] requires \"+String(Cols*Rows*sizeof(int))+ \" Bytes \"); Serial.println(\"plus \"+String(reserve)+\" reserved bytes, but there are only \"+String(getFreeMemory())+\" Bytes available\"); return; } int MyA[Rows][Cols]; static int Test = 1; Serial.println(\"Test = \"+String(Test++)); Serial.println(\"Use Array [\"+String(Rows)+\"][\"+String(Cols)+\"] with Free Memory = \"+String(getFreeMemory())); for (int i= 0;i<Rows;i++) for (int j= 0;j<Cols;j++) MyA[i][j] = (i+1)*100+j; for (int i= 0;i<Rows;i++){ for (int j= 0;j<Cols;j++) Serial.print(String(MyA[i][j])+char(9)); Serial.println(); } // In this test example you start recursive // \"dynamic\" array creation with an 's' per Serial in the // following while-loop. // It will stop here again after all recursive function calls // have come back to the first call in the main loop() // where depth is reset to zero (see below) // boolean YouAreHappy = (depth == 1); if (YouAreHappy) Serial.println(\"\n\nStart recursive calls per Serial input with 's' \"); while (YouAreHappy) { // Put your loop() content here if (Serial.available()){ YouAreHappy = (Serial.read() != 's'); } // End of loop() example } UseArray(random(2,21),random(2,21),c_reserve); depth--; Serial.println(\"Returned to \"+String(depth)); } void setup() { Serial.begin(115200); Serial.println(\"\n\n-----------------------------\"); } void loop() { Serial.println(\"Free Memory in loop() = \"+String(getFreeMemory())); depth = 0; UseArray(random(2,21),random(2,21),c_reserve); } extern unsigned int __bss_end; extern void *__brkval; int getFreeMemory(){ int free_memory; if((int)__brkval == 0) free_memory = ((int)&free_memory) - ((int)&__bss_end); else free_memory = ((int)&free_memory) - ((int)__brkval); return free_memory; }\n\nWow! If I believed everything in this thread, I would never, never, EVER use dynamic allocation on any Arduino. Ever! Fortunately, I know better. To say \"there is not memory manager\" is nonsense. Of course there is a memory manager. What is missing is automatic GARBAGE COLLECTION, which is a \"feature\" of c and c++, regardless of platform. Does that mean using dynamic allocation is guaranteed to fragment memory and make your applcation unstable? No, it does not. The memory manager (Yes, there really is one!) manages heap allocation, using a linked list of allocated blocks. When a new allocation is performed, a link is added to the list, ot track the newly allocated block. When that block is freed, the newly freed block is combined with adjacent free blocks, creating the largest possible free blocks between/around any remaining allocated blocks. So, memory does not automatically become fragmented any more than absolutely necessary. If you allocate a bunch of blocks, and then de-allocate all of them, the free memory pool will look exactly as it did when you started. I have written programs that used malloc and free to allocate, print, and discard large numbers of debug messages. Those programs run for days with no errors. You just have to have reasonable expectations for how much memory you can use at any given time, and not assume you can run with 95% of RAM allocated at all times. Using Strings certainly makes things worse, as it can significantly increase the number of allocations, but, even then, if your expectations are reasonable, they will work just fine. Finally, 99.99% of dynamic allocation problems are self-inflicted. If you are going to use it, you MUST pay attention to return codes, and figure out how to gracefully handle failed allocations. Most people just do a malloc or new, and assume it succeeds. THAT is a recipe of disaster. Once an allocation fails, if it is not dealt with, things will go downhill in a big hurry. And if you want to see how it all works, there are numerous functions out there to display the heap and stack status, and you can even walk the heap linked list yourseld and see EXACTLY what malloc, free, new, etc. do, and HOW they do it. Or, simply look at the source code. It's really pretty simple. The detailed implementations ARE different on different platforms, so it's not exactly the same on AVR-based boards as it is on ARM-based boards. But the basic principles are the same on all platforms.\n\nI am glad you showed up here, because my feeling is that the issue with dynamic memory management on Arduino platform seems to split the community and many of the statements are based on partial knowledge or at least partial information given ... That's why I started this tread and came up with the \"old fashioned\" C calloc, others brought in the C++ way of new / delete[] and I finally wrote a sketch that works fine without all of the above (because it relies on the standard way of arranging heap/stack memory with local functions). I recon that it might help to get some more light into the dark when there is a definition of what we consider to be a \"memory manager\":\n• The minimum memory management might be to allocate memory and then free it in reverse sequence, whether it is heap or stack. If done in the right order it should normally not generate any fragmentation. (Or not?)\n• If freeing of memory is not done in exactly the reverse order you might get \"holes\" in the SRAM that could be reused by a simple memory management for the same data type (or something using less bytes leaving smaller \"holes\").\n• Finally, memory mangement of larger systems, especially an OS, would do some garbage collection invisible to the functions/procedures by copying memory content and rearranging pointers to those data. That seems to be a more demanding task as the memory manager has to know exactly who is using what part of the memory and must make sure that noone accesses data during the re-arrangement . Correct (in principle)? It would be nice if some experts could create a documentation of if ever and how you can safely use dynamic memory allocation with Arduino. I am surely not one of those experts, but highly interested in a sound description that allows to understand the background rather than just Do's and Donot's ... Any idea how to bring light into the dark and disenchant the mystery around dynamic memory allocation on Arduino platforms ... without leaving all the google work to thousands of curious people?\n• The minimum memory management might be to allocate memory and then free it in reverse sequence, whether it is heap or stack. If done in the right order it should normally not generate any fragmentation. (Or not?) The order of allocation/de-allocation is NEVER up to the memory manager. It is up to the user/application. The order of allocation/de-allocation is not, should not, be important. Once all allocated block have been freed, you will have a single block of free memory, exactly as when the system was first initialized. That is precisely how it works in Arduino world right now.\n• If freeing of memory is not done in exactly the reverse order you might get \"holes\" in the SRAM that could be reused by a simple memory management for the same data type (or something using less bytes leaving smaller \"holes\"). Yes, and that will always be true, UNLESS you add the considerable complexity of automatic background garbage collection, which c/c++ do not support. That would mean be able to move things around in memory at any time, without disrupting the running applications. In a language that uses pointers/references, that means the values of those pointers/references must be update on-the-fly, WITHOUT the application even knowing it is happening. Even with a full virtual memory system (which few, if any, Arduinos have, the overhead and complexity to do that is quite considerable. This is one of the reasons languages which DO support garbage collection, like Javascript, are so slow and resource-intensive.\n• Finally, memory mangement of larger systems, especially an OS, would do some garbage collection invisible to the functions/procedures by copying memory content and rearranging pointers to those data. That seems to be a more demanding task as the memory manager has to know exactly who is using what part of the memory and must make sure that noone accesses data during the re-arrangement . Correct (in principle)? Yes, but again, that approach is quite complex and resource intensive, and NOT supported by c/c++, regardless of the OS. And not remotely practical on a small microcontroller. It will require more memory, and the entire system will run considerably slower.\n\nYou can look at the avr implementation of malloc() and free() - it's all open source code, after all. \"new\" and \"delete\" on Arduino are just wrappers for malloc/free.\n\n avr-libc malloc and free It's not trivial code; probably on par with the original K&R implementations. It will even aggregate free()ed memory blocks into bigger blocks. It just doesn't have a lot to work with (for example, a \"better\" malloc() might keep separate free lists for different \"popular\" sizes of allocation. I think I even have in mind a \"rule\" that says malloc implementations will always grow in complexity until you also need to implement special purpose memory allocation functions that are simpler and faster.) But now you're talking about more overhead for each allocated or free block, and when you've only got 2k of memory, 10+ bytes of overhead per allocation is painful. C/C++ does not do \"garbage collection\" in the way the term is usually used - freeing up memory that is no longer in use, but was never explicitly free()ed, either. The AVR does not have other users who will use the memory that you've freed. It does not have \"protection\" against over-allocating memory from the heap, and I don't think it even it has checks for the stack overflowing INTO the heap. It does not have \"segmentation error\" capability if you accidentally access memory that doesn't exist. There is probably no want to indicate to a user that a memory allocation failure has occured, or that the board is \"running low.\" I feel vaguely comfortable using malloc() during setup() to make memory for alternative configurations. For example, I think the Adafruit neopixel library will malloc() the data for the actual pixels, and I'm basically OK with that. The Arduino String functions are a particularly poor example of using dynamic allocation, allocating tiny little chunks in random order in ways that make it difficult to re-aggregate the memory. I guess my general rule of thumb is something like:\n• You can use dynamic allocation in cases where it is immediately apparent if the allocation fails.\n\nI don't think it even it has checks for the stack overflowing INTO the heap On AVR board there is some protection against stack overflowing INTO the heap. The memory allocate always ensures there is at least 128bytes left available for stack use. (see the examples in Taming Arduino Strings ) This is one of the things that makes using Strings on AVR boards so safe. Strings also automatically protect against overallocation of the heap without causing your program to crash. The AVR (and others) memory manager also coalesces adjacent empty fragments to improve reuse.\n\n The managing arduino memory reference talks about memory corruption, but that is not possible on AVR boards UNLESS you try and allocate more then 128bytes of stack in method call. Memory corruption is possible (and happens) on ESP2866 and ESP23 boards which do not have the 128byte stack buffer. Allocating lots of small Strings when combined with returning Strings from functions does product memory fragmentation. ESP boards have a 12 char[ ] build into their String class which they use for 'small' Strings to avoid allocating memory on the heap for small Strings. So in summary, dynamic memory allocation on AVR boards is 'safe' if you ALWAYS check the return and handle out-of-memory AND don't use more then 128bytes of local stack in your methods (including arguments). Freeing memory after you are finished with it (and not before) will make your memory go further. The biggest problem (in my mind) using dynamic memory allocation is what to do if/when your program runs out of memory. How does your program recover? The Arduino String library just returns an empty String and keeps going. Your program won't crash but the logic may be screwy.\n\n Using your own dynamic memory, your program has to cope with null pointers in some 'safe' way. This tends to lead to a lot of is pointer null checks."
    },
    {
        "link": "https://forum.arduino.cc/t/using-pointers-with-arrays-resolved/607620",
        "document": "Ever since I learned C pointers have confused me. Here is a simplified version of a much more complex sketch to illustrate what I want to do. This works: In my real program, testdata is actually a char array containing data received over Wi_Fi, from which I want to extract an unsigned int and a float. In the example the float is 12.34567. If I compile the above for either an ESP8266 or a Mega 2560 it compiles and correctly prints 12.34567 to the serial monitor (although with the ESP8266 it also prints a few junk characters before the 12.34567, I am not to concerned about this as it is not core to my problem). If I instead use, for example: Then for an ESP8266 I get: If I compile for a Mega 2560 it compiles without error but prints 0.00000 I said 'for example' because I have tried many variations on using a pointer to tell atof where to get its data, none of them work. I'm hoping you won't ask me what variations I've tried, there are too many! Everything I could think of. I am hoping that someone here who understands pointer use can tell me the one thing I didn't try which will work.\n\nAnd note you can probably just write: \n\n The ‘\\0’ is added by the cString for you and the size of the array provided by the compiler. You don’t need the curly {} brackets as you are using a cString. You would if you had provided the various elements of the array one by one:\n\nAWOL, Delta_G,\n\n Thank you both. Works in the example but not in my original code. However, now I have something to aim for, now I know that is the correct way to do it I can look elsewhere for the problem, knowing that bit is OK. J-M-L,\n\n Thanks for the extra info, much appreciated. That's all for now, I have a beer waiting for me\n\nUpdate, partly so those of you that helped know what happened and partly so anyone else reading this with similar problems can learn from my mistakes. I was making 2 mistakes at the same time.\n\n First, the thing I asked about; pointers. I find pointers confusing. I still find them confusing, but maybe a little less so (why does this code need an &, but in other situations it works without a &, such as in my first example). So, I tried many variations of: Unfortunately, none of them worked, including the correct one, because of another thing I was doing wrong: I have always thought that char and uint8_t were interchangeable. Well, they are much of the time. Only much of the time. Although I used char in the sample code I used uint8_t in the original code. I now know one situation where they are not interchangeable. If you want to store characters, not numbers, use char, even if int8_t or uint8_t seem to work OK.\n\nI suspect your confusion is, in part, due to the somewhat inconsistent way c/c++ addresses data. For all simple, integral data types (char, int, long, bool, etc.), the variable name, when used by itself, evaluates to the VALUE of the data: int x = 10; // x has the value 10 Serial.print(x); // x has the value 10, so this prints \"10\"\n\n Serial.print(&x); // &x is the memory ADDRESS of x, Serial.print receives a pointer to x But for some complex types, arrays in particular, the variable name evaluates to a POINTER to the data, which is the memory ADDRESS of the first element of the array. char x[10] = \"abcd\"; // x is a 5-element array of char\n\n Serial.print(x); // x here evaluates to the ADDRESS of x[0]. i.e. - Serial.print receives a pointer\n\n Serial.print(&x[0]); // This is exactly equivalent to the previous line, as it explicitly gets the address of x[0] All c++ object names evaluate to pointers, just like for arrays. Then there's the confusion of references, which also use the \"&\" symbol, but for a slightly different purpose... So, in deciding whether or not you need an & (AddressOf operator), look at the type of the data. If it's a simple type, and you want the value, no ampersand. Otherwise, add the ampersand to get a pointer to the data instead. For complex types, you most often only need the & if you want to get a pointer to one element of an array, in which case you need to also specific WHICH element, by providing [n] indexing.\n\nRayLivingston:\n\n All c++ object names evaluate to pointers, just like for arrays. You were doing well, but went off the beam with that one. First, the name of an object that's an instance of a class can be defined to evaluate to just about anything using operator overloading, for example: Even if that's not the case, calling a function with an object name as an argument (without specifying it as a pointer or reference in the function's defintion) will use Call by Value. Meaning a copy of the object will be placed on the stack before the function is called. If the class has a defined Copy Constructor, it will be used for this. Otherwise the default copy constructor will be used, perhaps with unexpected results."
    },
    {
        "link": "https://digikey.com/en/maker/tutorials/2020/the-basics-of-c-on-an-arduino-part-3-pointers-and-arrays",
        "document": "This Basics of C++ on an Arduino series is covering many different elements necessary for all sorts of projects and ideas on an Arduino. In this entry, we cover Pointers and Arrays in C++.\n\nSo far, you’ve seen how you can store a single value in a variable. However, what if you want to save multiple values as a recognizable group? Arrays are one method you can use to accomplish that. While they aren’t able to store multiple values in a single variable, they allow you to save several related values in the Arduino’s memory as a coherent group.\n\nArrays are exactly what their name suggests: an arrangement of values with the same type. The elements of an array usually get placed in the memory one after the other.\n\nLet’s suppose you want to store 128 values that you received from a temperature sensor. With what you’ve learned so far, you could only create 128 individual variables like so:\n\nBesides being a pain to write and maintain, there’d also be no easy way of handling all these variables. If you wanted to print their values, for example, you’d have to make 128 individual calls to the print method.\n\nAs mentioned above, you can use arrays to create a coherent field of similar values. For that, you have to define the type and the name of the array, just like you’d do with any other variable. However, you then add square brackets to indicate that you want to create an array. Inside of the brackets, you define the size of the array:\n\nThis will create an empty array of 128 float variables. You can, however, also initialize an array by defining a list of values that you’d like to store:\n\nNote that arrays always have a fixed length that you can’t change later on.\n\nYou can access the elements stored in an array by writing its name followed by an index that’s enclosed by square brackets:\n\nArray indices always start with zero. If you request an index that’s too small or too large, you’ll produce a runtime error or non-deterministic behavior.\n\nAnother way of accessing array elements is to use a pointer. You can think of a pointer as a thing that, well, points at a specific location in the Arduino’s memory. Defining a new pointer works similar to creating a variable. You start with the type and the name. However, pointers get marked with an asterisk symbol that comes after the type:\n\nAs you can see, you can put an ampersand in front of a variable’s name to get its address, which can then, in turn, get stored in a pointer. One huge advantage of pointers is that you can use simple arithmetics to change the address that they reference:\n\nYou must note two things: Firstly, there’s another asterisk in front of the address that you want to read. This is called dereferencing, and it simply means that you aren’t interested in the address, but rather the value that’s stored at that address. Furthermore, the addition happens inside of parenthesis. This is important because otherwise, you’d first dereference the pointer value and then add a number to it, which would lead to a different value.\n• The Basics of C++ on an Arduino, Part 1: Variables\n• The Basics of C++ on an Arduino, Part 2: Functions and Methods\n• The Basics of C++ on an Arduino, Part 4 Control Statements and Loops\n• The Basics of C++ on an Arduino, Part 5: Software Libraries and Custom Classes You can use arrays to group similar related values. Note that you can only store values of the same type in a single array. Arrays have a fixed length, and you can access their items with an index. These indices start at zero. You can also use a pointer to access the elements of an array. Use the ampersand operator to obtain the address of a variable. Utilize the asterisk to dereference a pointer and read the value of the variable that it points at."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/1j7b3p1/so_what_is_the_correct_approach_to_dynamic_arrays",
        "document": "CONTEXT - I'm building an application (for arduino if it matters) that functions around a menu on a small 16x2 LCD display. At the moment, the way I've configured it is for a parent menu class, which holds everything all menu items will need, and then a child menuitem class, which contains specific methods pertaining to specific types of menu items. Because the system I'm working on has multiple menus and submenus etc, I'm essentially creating menu item instances and then adding them to a menu. To do this, I need to define an array (or similar) that I can store the address of each menu item, as it's added to the instance of the menu.\n\nMY QUESTION - I know dynamically allocated arrays are a dangerous space to get into, and I know I can just create an array that will be much much larger than any reasonable number of menu items a menu would be likely to have, but what actually is the correct way, in C++, to provide a user with the means of adding an unlimited number of menu items to a menu?\n\nAnything i google essentially either says 'this is how you create dynamic arrays, but you shouldn't do it', or 'don't do it', but when I think of any professional application I use, I've never seen limits on how many elements, gamesaves, items or whatever can be added to a basket, widget etc, so they must have some smart way of allowing the dynamic allocation of memory to lists of some sort.\n\nCan anyone point me in the right direction for how this should be achieved?"
    },
    {
        "link": "https://forum.arduino.cc/t/how-to-create-and-free-dynamic-arrays-with-arduino/934662/14",
        "document": "I am glad you showed up here, because my feeling is that the issue with dynamic memory management on Arduino platform seems to split the community and many of the statements are based on partial knowledge or at least partial information given ...\n\nThat's why I started this tread and came up with the \"old fashioned\" C calloc, others brought in the C++ way of new / delete[] and I finally wrote a sketch that works fine without all of the above (because it relies on the standard way of arranging heap/stack memory with local functions).\n\nI recon that it might help to get some more light into the dark when there is a definition of what we consider to be a \"memory manager\":\n• The minimum memory management might be to allocate memory and then free it in reverse sequence, whether it is heap or stack. If done in the right order it should normally not generate any fragmentation. (Or not?)\n• If freeing of memory is not done in exactly the reverse order you might get \"holes\" in the SRAM that could be reused by a simple memory management for the same data type (or something using less bytes leaving smaller \"holes\").\n• Finally, memory mangement of larger systems, especially an OS, would do some garbage collection invisible to the functions/procedures by copying memory content and rearranging pointers to those data. That seems to be a more demanding task as the memory manager has to know exactly who is using what part of the memory and must make sure that noone accesses data during the re-arrangement . Correct (in principle)?\n\nIt would be nice if some experts could create a documentation of if ever and how you can safely use dynamic memory allocation with Arduino. I am surely not one of those experts, but highly interested in a sound description that allows to understand the background rather than just Do's and Donot's ...\n\nAny idea how to bring light into the dark and disenchant the mystery around dynamic memory allocation on Arduino platforms ... without leaving all the google work to thousands of curious people?"
    }
]