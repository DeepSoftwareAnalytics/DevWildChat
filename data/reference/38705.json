[
    {
        "link": "https://geeksforgeeks.org/singleton-pattern-in-python-a-complete-guide",
        "document": "A Singleton pattern in python is a design pattern that allows you to create just one instance of a class, throughout the lifetime of a program. Using a singleton pattern has many benefits. A few of them are:\n• None To create a global point of access for a resource.\n• None To create just one instance of a class, throughout the lifetime of a program.\n\nA singleton pattern can be implemented in three different ways. They are as follows:\n\nAll modules are singleton, by definition. Let’s create a simple module-level singleton where the data is shared among other modules. Here we will create three python files – singleton.py, sample_module1.py, and sample_module2.py – in which the other sample modules share a variable from singleton.py.\n\nLet’s look into the output.\n\nHere, the value changed by samplemodule1 is also reflected in samplemodule2.\n\nClassic Singleton creates an instance only if there is no instance created so far; otherwise, it will return the instance that is already created. Let’s take a look at the below code.\n\nHere, in the __new__ method, we will check whether an instance is created or not. If created, it will return the instance; otherwise, it will create a new instance. You can notice that singleton and new_singleton return the same instance and have the same variable.\n\nLet’s check what happens when we subclass a singleton class.\n\nHere, you can see that SingletonChild has the same instance of SingletonClass and also shares the same state. But there are scenarios, where we need a different instance, but should share the same state. This state sharing can be achieved using Borg singleton.\n\nBorg singleton is a design pattern in Python that allows state sharing for different instances. Let’s look into the following code.\n\nAlong with the new instance creation process, a shared state is also defined in the __new__ method. Here the shared state is retained using the shared_borg_state attribute and it is stored in the __dict__ dictionary of each instance.\n\nIf you want a different state, then you can reset the shared_borg_state attribute. Let’s see how to reset a shared state.\n\nHere, we have reset the shared state and tried to access the shared_variable. Let’s see the error.\n\nLet’s list a few of the use cases of a singleton class. They are as follows:\n\nLet’s create a webcrawler that uses the benefit of a classic singleton. In this practical example, the crawler scans a webpage, fetch the links associated with the same website, and download all the images in it. Here, we have two main classes and two main functions.\n• None ParallelDownloader: This class provides thread functionality to download images\n• None navigate_site: This function crawls the website and fetches the links that belong to the same website. And, finally, it arranges the link to download images.\n• None download_images: This function crawls the page link and downloads the images.\n\nApart from the above classes and functions, we use two sets of libraries to parse the web page – BeautifulSoup and HTTP Client.\n\nHave a look at the below code.\n\nNote: Execute the code in your local machine\n\n\"\"\" creates a singleton object, if it is not created, or else returns the previous singleton object\"\"\" \"\"\" navigate the website using BFS algorithm, find links and # During the initial stage, url_queue has the main_url. # Upon parsing the main_url page, new links that belong to the # same website is added to the url_queue until # checks whether it reached the max. link # pop the url from the queue # add the link to download the images # crawl the web page and fetch the links within # skip the link, if it leads to an external page # skip, if the link is already added # so that the while loop continues with next iteration. \\ # Here we will fetch each URL and # download the images in it. # pop the url to download the images # parse the web page to find all images # adding the url to the queue for parsing # initializing a set to store path of the downloaded images # invoking the method to crawl the website\n\nLet’s look into the downloaded images and python shell output.\n\nSingleton pattern is a design pattern in Python that restricts the instantiation of a class to one object. It can limit concurrent access to a shared resource, and also it helps to create a global point of access for a resource.\n\nHow to Do Singleton Design Pattern in Python?\n\nWhat is the Attribute of Singleton in Python?\n\nWhat is the Factory Pattern in Python with Singleton?\n\nWhat is the Alternative to Singleton in Python?\n\nWhat is the Difference Between"
    },
    {
        "link": "https://refactoring.guru/design-patterns/singleton/python/example",
        "document": "Singleton is a creational design pattern, which ensures that only one object of its kind exists and provides a single point of access to it for any other code. Singleton has almost the same pros and cons as global variables. Although they’re super-handy, they break the modularity of your code. You can’t just use a class that depends on a Singleton in some other context, without carrying over the Singleton to the other context. Most of the time, this limitation comes up during the creation of unit tests.\n\nUsage examples: A lot of developers consider the Singleton pattern an antipattern. That’s why its usage is on the decline in Python code.\n\nIdentification: Singleton can be recognized by a static creation method, which returns the same cached object.\n\nIt’s pretty easy to implement a sloppy Singleton. You just need to hide the constructor and implement a static creation method. The same class behaves incorrectly in a multithreaded environment. Multiple threads can call the creation method simultaneously and get several instances of Singleton class. class SingletonMeta(type): \"\"\" The Singleton class can be implemented in different ways in Python. Some possible methods include: base class, decorator, metaclass. We will use the metaclass because it is best suited for this purpose. \"\"\" _instances = {} def __call__(cls, *args, **kwargs): \"\"\" Possible changes to the value of the `__init__` argument do not affect the returned instance. \"\"\" if cls not in cls._instances: instance = super().__call__(*args, **kwargs) cls._instances[cls] = instance return cls._instances[cls] class Singleton(metaclass=SingletonMeta): def some_business_logic(self): \"\"\" Finally, any singleton should define some business logic, which can be executed on its instance. \"\"\" # ... if __name__ == \"__main__\": # The client code. s1 = Singleton() s2 = Singleton() if id(s1) == id(s2): print(\"Singleton works, both variables contain the same instance.\") else: print(\"Singleton failed, variables contain different instances.\") Singleton works, both variables contain the same instance. To fix the problem, you have to synchronize threads during the first creation of the Singleton object. from threading import Lock, Thread class SingletonMeta(type): \"\"\" This is a thread-safe implementation of Singleton. \"\"\" _instances = {} _lock: Lock = Lock() \"\"\" We now have a lock object that will be used to synchronize threads during first access to the Singleton. \"\"\" def __call__(cls, *args, **kwargs): \"\"\" Possible changes to the value of the `__init__` argument do not affect the returned instance. \"\"\" # Now, imagine that the program has just been launched. Since there's no # Singleton instance yet, multiple threads can simultaneously pass the # previous conditional and reach this point almost at the same time. The # first of them will acquire lock and will proceed further, while the # rest will wait here. with cls._lock: # The first thread to acquire the lock, reaches this conditional, # goes inside and creates the Singleton instance. Once it leaves the # lock block, a thread that might have been waiting for the lock # release may then enter this section. But since the Singleton field # is already initialized, the thread won't create a new object. if cls not in cls._instances: instance = super().__call__(*args, **kwargs) cls._instances[cls] = instance return cls._instances[cls] class Singleton(metaclass=SingletonMeta): value: str = None \"\"\" We'll use this property to prove that our Singleton really works. \"\"\" def __init__(self, value: str) -> None: self.value = value def some_business_logic(self): \"\"\" Finally, any singleton should define some business logic, which can be executed on its instance. \"\"\" def test_singleton(value: str) -> None: singleton = Singleton(value) print(singleton.value) if __name__ == \"__main__\": # The client code. print(\"If you see the same value, then singleton was reused (yay!)\n\n\" \"If you see different values, \" \"then 2 singletons were created (booo!!)\n\n\n\n\" \"RESULT:\n\n\") process1 = Thread(target=test_singleton, args=(\"FOO\",)) process2 = Thread(target=test_singleton, args=(\"BAR\",)) process1.start() process2.start() If you see the same value, then singleton was reused (yay!) If you see different values, then 2 singletons were created (booo!!) RESULT: FOO FOO"
    },
    {
        "link": "https://python-patterns.guide/gang-of-four/singleton",
        "document": "A “Creational Pattern” from the Gang of Four book\n\nPython programmers almost never implement the Singleton Pattern as described in the Gang of Four book, whose Singleton class forbids normal instantiation and instead offers a class method that returns the singleton instance. Python is more elegant, and lets a class continue to support the normal syntax for instantiation while defining a custom method that returns the singleton instance. But an even more Pythonic approach, if your design forces you to offer global access to a singleton object, is to use The Global Object Pattern instead.\n\nPython was already using the term singleton before the “Singleton Pattern” was defined by the object oriented design pattern community. So we should start by distinguishing the several meanings of “singleton” in Python.\n• A tuple of length one is called a singleton. While this definition might surprise some programmers, it reflects the original definition of a singleton in mathematics: a set containing exactly one element. The Python Tutorial itself introduces newcomers to this definition when its chapter on Data Structures calls a one-element tuple a “singleton” and the word continues to be used in that sense through the rest of Python’s documentation. When the Extending and Embedding guide says, “To call the Python function … with one argument, pass a singleton tuple,” it means a tuple containing exactly one item.\n• Modules are “singletons” in Python because only creates a single copy of each module; subsequent imports of the same name keep returning the same module object. For example, when the Module Objects chapter of the Python/C API Reference Manual asserts that “Single-phase initialization creates singleton modules,” it means by a “singleton module” a module for which only one object is ever created.\n• A “singleton” is a class instance that has been assigned a global name through . For example, the official Python Programming FAQ answers the question “How do I share global variables across modules?” with the assertion that in Python “using a module is also the basis for implementing the Singleton design” — because not only can a module’s global namespace store constants (the FAQ’s example is shared between several modules), but mutable class instances as well.\n• Individual flyweight objects that are examples of are often called “singleton” objects by Python programmers. For example, a comment inside the Standard Library’s asserts that “CPython’s empty tuple is a singleton” — meaning that the Python interpreter only ever creates a single empty tuple object, which returns over and over again every time it’s passed a zero-length sequence. A comment in similarly refers to the “empty frozenset singleton.” But neither of these singleton objects is an example of the Gang of Four’s Singleton Pattern, because neither object is the sole instance of its class: lets you build other tuples besides the empty tuple, and lets you build other frozen sets. Similarly, the and objects are a pair of flyweights, not examples of the Singleton Pattern, because neither is the sole instance of .\n• Finally, Python programmers on a few rare occasions do actually mean “The Singleton Pattern” when they call an object a “singleton”: the lone object returned by its class every time the class is called. The Python 2 Standard Library included no examples of the Singleton Pattern. While it did feature singleton objects like and , the language provided access to them through the more Pythonic Global Object Pattern by giving them names in the module. But their classes were not callable: In Python 3, however, the classes were upgraded to use the Singleton Pattern: This makes life easier for programmers who need a quick callable that always returns , though such occasions are rare. In most Python projects these classes are never called and the benefit remains purely theoretical. When Python programmers need the object they use The Global Object Pattern and simply type its name.\n\nThe C++ language that the Gang of Four were targeting imposed a distinct syntax on object creation, that looked something like: A line of C++ that says always creates a new class instance — it never returns a singleton. In the presence of this special syntax, what were their options for offering singleton objects?\n• The Gang of Four did not take the easy way out and use because it did not work particularly well in early versions of the C++ language. There, global names all shared a single crowded global namespace, so elaborate naming conventions were necessary to prevent names from different libraries from colliding. The Gang judged that adding both a class and its singleton instance to the crowded global namespace would be excessive. And since C++ programmers couldn’t control the order in which global objects were initialized, no global object could depend on being able to call any other, so the responsibility of initializing globals often fell on client code.\n• There was no way to override the meaning of in C++, so an alternative syntax was necessary if all clients were to receive the same object. It was, though, at least possible to make it a compile-time error for client code to call by marking the class constructor as either or .\n• So the Gang of Four pivoted to a class method that would return the class’s singleton object. Unlike a global function, a class method avoided adding yet another name to the global namespace, and unlike a static method, it could support subclasses that were singletons as well. How could Python code illustrate their approach? Python lacks the complications of , , and . An alternative is to raise an exception in to make normal object instantiation impossible. The class method can then use a dunder method trick to create the object without triggering the exception: # What the Gang of Four’s original Singleton Pattern # might look like in Python. This successfully prevents clients from creating new instances by calling the class: Traceback (most recent call last): ... RuntimeError: Call instance() instead Instead, callers are instructed to use the class method, which creates and returns an object: Subsequent calls to return the singleton without repeating the initialization step (as we can see from the fact that “Creating new instance” isn’t printed again), exactly as the Gang of Four intended: 'Are they the same object?' <Logger object at 0x7f0ff5e7c080> Are they the same object? True There are more complicated schemes that I can imagine for implementing the original Gang of Four class method in Python, but I think the above example does the best job of illustrating the original scheme with the least magic possible. Since the Gang of Four’s pattern is not a good fit for Python anyway, I’ll resist the temptation to iterate on it further, and instead move on to how the pattern is best supported in Python.\n\nIn one sense, Python started out better prepared than C++ for the Singleton Pattern, because Python lacks a keyword that forces a new object to be created. Instead, objects are created by invoking a callable, which imposes no syntactic limitation on what operation the callable really performs: To let authors take control of calls to a class, Python 2.4 added the dunder method to support alternative creational patterns like the Singleton Pattern and The Flyweight Pattern. The Web is replete with Singleton Pattern recipes featuring that each propose a more or less complicated mechanism for working around the method’s biggest quirk: the fact that always gets called on the return value, whether the object that’s being returned is new or not. To make my own example simple, I will simply not define an method and thus avoid having to work around it: The object is created on the first call to the class: But the second call returns the same instance. The message “Creating the object” does not print, nor is a different object returned: 'Are they the same object?' <Logger object at 0x7fa8e9cf7f60> Are they the same object? True The example above opts for simplicity, at the expense of doing the attribute lookup twice in the common case. For programmers who cringe at such waste, the result can of course be assigned a name and re-used in the return statement. And various other improvements can be imagined that would result in faster bytecode. But however elaborately tweaked, the above pattern is the basis of every Python class that hides a singleton object behind what reads like normal class instantiation.\n\nWhile the Gang of Four’s original Singleton Pattern is a poor fit for a language like Python that lacks the concepts of , , and , it’s not as easy to dismiss the pattern when it’s built atop — after all, singletons were part of the reason the dunder method was introduced! But the Singleton Pattern in Python does suffer from several drawbacks. A first objection is that the Singleton Pattern’s implementation is difficult for many Python programmers to read. The alternative Global Object Pattern is easy to read: it’s simply the familiar assignment statement, placed up at a module’s top level. But a Python programmer reading a method for the first time is probably going to have to stop and look for documentation to understand what’s going on. A second objection is that the Singleton Pattern makes calls to the class, like , misleading for readers. Unless the designer has put “Singleton” or some other hint in the class name, and the reader knows design patterns well enough to understand the hint, the code will read as though a new instance is being created and returned. A third objection is that the Singleton Pattern forces a design commitment that The Global Object Pattern does not. Offering a global object still leaves a programmer free to create other instances of the class — which can be particularly helpful for tests, letting them each test a completely separate object without needing to reset a shared object back to a known good state. But the Singleton Pattern makes additional instances impossible. (Unless the caller is willing to stoop to monkey patching; or temporarily modifying to subvert the logic in ; or creating a subclass that replaces the method. But a pattern you have to work around is generally a pattern you should avoid.) Why, then, would you use the Singleton Pattern in Python? The one situation that would really demand the pattern would be an existing class that, because of a new requirement, will now operate best as a single instance. If it’s not possible to migrate all client code to stop calling the class directly and start using a global object, then the Singeton Pattern would be a natural approach to pivoting to a singleton while preserving the old syntax. But, otherwise, the pattern is best avoided in favor of following the advice of the official Python FAQ and using the The Global Object Pattern."
    },
    {
        "link": "https://geeksforgeeks.org/singleton-method-python-design-patterns",
        "document": "What is Singleton Method in Python\n\nSingleton Method is a type of Creational Design pattern and is one of the simplest design patterns available to us. It is a way to provide one and only one object of a particular type. It involves only one class to create methods and specify the objects. \n\nSingleton Design Pattern can be understood by a very simple example of Database connectivity. When each object creates a unique Database Connection to the Database, it will highly affect the cost and expenses of the project. So, it is always better to make a single connection rather than making extra irrelevant connections which can be easily done by Singleton Design Pattern.\n\nNow let’s have a look at the different implementations of the Singleton Design pattern.\n\nSingleton behavior can be implemented by Borg’s pattern but instead of having only one instance of the class, there are multiple instances that share the same state. Here we don’t focus on the sharing of the instance identity instead we focus on the sharing state.\n\nIt is easy to notice that once an object is created, the synchronization of the threading is no longer useful because now the object will never be equal to None and any sequence of operations will lead to consistent results. \n\nSo, when the object will be equal to None, then only we will acquire the Lock on the getInstance method.\n\nIn the classic implementation of the Singleton Design pattern, we simply use the static method for creating the getInstance method which has the ability to return the shared resource. We also make use of the so-called Virtual private Constructor to raise the exception against it although it is not much required.\n\nAdvantages of using the Singleton Method:\n• Initializations: An object created by the Singleton method is initialized only when it is requested for the first time.\n• Access to the object: We got global access to the instance of the object.\n• Count of instances: In singleton, method classes can’t have more than one instance\n\nDisadvantages of using the Singleton Method:\n• Multithread Environment: It’s not easy to use the singleton method in a multithread environment, because we have to take care that the multithread wouldn’t create a singleton object several times.\n• Single responsibility principle: As the Singleton method is solving two problems at a single time, it doesn’t follow the single responsibility principle.\n• Unit testing process: As they introduce the global state to the application, it makes the unit testing very hard.\n• Controlling over global variables: In the projects where we specifically need strong control over the global variables, it is highly recommended to use Singleton Method\n• Daily Developers use: Singleton patterns are generally used in providing the logging, caching, thread pools, and configuration settings and are often used in conjunction with Factory design patterns.\n\nFurther read: Singleton method in Java, Singleton Design Pattern Practices with Examples"
    },
    {
        "link": "https://pravash-techie.medium.com/python-singleton-pattern-for-effective-object-management-49d62ec3bd9b",
        "document": "Hi everyone, In this article I will talk about a pattern — pattern and exploring its purpose, benefits, and practical applications in Python. We’ll discover how Singleton promotes the creation of a single instance of a class, ensuring that this instance remains consistent throughout the application’s lifecycle.\n\nThrough illustrative examples and real-world use cases, we’ll unravel the power and versatility of the pattern, demonstrating its relevance in a wide range of scenarios.\n\nIts pretty simple one, it’s basically when we have a class for which we can only ever instantiate one object of that type and we might use it for all kinds of reasons.\n\nWhether you’re aiming to optimize resource usage, configuration data, or some kind of global read only data for our program, the pattern offers a clear and effective solution so that we can access a singleton to get that data.\n\nThe Design Pattern stands out as a versatile tool that addresses the need for a single, globally accessible instance of a particular class."
    },
    {
        "link": "https://stackoverflow.com/questions/6760685/what-is-the-best-way-of-implementing-singleton-in-python",
        "document": "I would recommend Method #2, but you're better off using a metaclass than a base class. Here is a sample implementation:\n\nIf you want to run every time the class is called, add\n\nto the statement in .\n\nA few words about metaclasses. A metaclass is the class of a class; that is, a class is an instance of its metaclass. You find the metaclass of an object in Python with . Normal new-style classes are of type . in the code above will be of type , just as the (only) instance of will be of type . When you call logger with , Python first asks the metaclass of , , what to do, allowing instance creation to be pre-empted. This process is the same as Python asking a class what to do by calling when you reference one of its attributes by doing .\n\nA metaclass essentially decides what the definition of a class means and how to implement that definition. See for example http://code.activestate.com/recipes/498149/, which essentially recreates C-style s in Python using metaclasses. The thread What are some (concrete) use-cases for metaclasses? also provides some examples, they generally seem to be related to declarative programming, especially as used in ORMs.\n\nIn this situation, if you use your Method #2, and a subclass defines a method, it will be executed every time you call -- because it is responsible for calling the method that returns the stored instance. With a metaclass, it will only be called once, when the only instance is created. You want to customize what it means to call the class, which is decided by its type.\n\nIn general, it makes sense to use a metaclass to implement a singleton. A singleton is special because its instance is created only once, and a metaclass is the way you customize the creation of a class, allowing it to behave differenly than a normal class. Using a metaclass gives you more control in case you need to customize the singleton class definitions in other ways.\n\nYour singletons won't need multiple inheritance (because the metaclass is not a base class), but for subclasses of the created class that use multiple inheritance, you need to make sure the singleton class is the first / leftmost one with a metaclass that redefines This is very unlikely to be an issue. The instance dict is not in the instance's namespace so it won't accidentally overwrite it.\n\nYou will also hear that the singleton pattern violates the \"Single Responsibility Principle\" -- each class should do only one thing. That way you don't have to worry about messing up one thing the code does if you need to change another, because they are separate and encapsulated. The metaclass implementation passes this test. The metaclass is responsible for enforcing the pattern and the created class and subclasses need not be aware that they are singletons. Method #1 fails this test, as you noted with \"MyClass itself is a a function, not a class, so you cannot call class methods from it.\"\n\nWriting something that works in both Python2 and 3 requires using a slightly more complicated scheme. Since metaclasses are usually subclasses of type , it's possible to use one to dynamically create an intermediary base class at run time with it as its metaclass and then use that as the baseclass of the public base class. It's harder to explain than to do, as illustrated next:\n\nAn ironic aspect of this approach is that it's using subclassing to implement a metaclass. One possible advantage is that, unlike with a pure metaclass, will return .\n\nOn another topic, you've probably already noticed this, but the base class implementation in your original post is wrong. needs to be referenced on the class, you need to use or you're recursing, and is actually a static method that you have to pass the class to, not a class method, as the actual class hasn't been created yet when it is called. All of these things will be true for a metaclass implementation as well.\n\nI originally was writing a comment but it was too long, so I'll add this here. Method #4 is better than the other decorator version, but it's more code than needed for a singleton, and it's not as clear what it does.\n\nThe main problems stem from the class being its own base class. First, isn't it weird to have a class be a subclass of a nearly identical class with the same name that exists only in its attribute? This also means that you can't define any methods that call the method of the same name on their base class with because they will recurse. This means your class can't customize , and can't derive from any classes that need called on them.\n\nWhen to use the singleton pattern\n\nYour use case is one of the better examples of wanting to use a singleton. You say in one of the comments \"To me logging has always seemed a natural candidate for Singletons.\" You're absolutely right.\n\nWhen people say singletons are bad, the most common reason is they are implicit shared state. While with global variables and top-level module imports are explicit shared state, other objects that are passed around are generally instantiated. This is a good point, with two exceptions.\n\nThe first, and one that gets mentioned in various places, is when the singletons are constant. Use of global constants, especially enums, is widely accepted, and considered sane because no matter what, none of the users can mess them up for any other user. This is equally true for a constant singleton.\n\nThe second exception, which get mentioned less, is the opposite -- when the singleton is only a data sink, not a data source (directly or indirectly). This is why loggers feel like a \"natural\" use for singletons. As the various users are not changing the loggers in ways other users will care about, there is not really shared state. This negates the primary argument against the singleton pattern, and makes them a reasonable choice because of their ease of use for the task.\n\nHere is a quote from http://googletesting.blogspot.com/2008/08/root-cause-of-singletons.html:\n\nNow, there is one kind of Singleton which is OK. That is a singleton where all of the reachable objects are immutable. If all objects are immutable than Singleton has no global state, as everything is constant. But it is so easy to turn this kind of singleton into mutable one, it is very slippery slope. Therefore, I am against these Singletons too, not because they are bad, but because it is very easy for them to go bad. (As a side note Java enumeration are just these kind of singletons. As long as you don't put state into your enumeration you are OK, so please don't.) The other kind of Singletons, which are semi-acceptable are those which don't effect the execution of your code, They have no \"side effects\". Logging is perfect example. It is loaded with Singletons and global state. It is acceptable (as in it will not hurt you) because your application does not behave any different whether or not a given logger is enabled. The information here flows one way: From your application into the logger. Even thought loggers are global state since no information flows from loggers into your application, loggers are acceptable. You should still inject your logger if you want your test to assert that something is getting logged, but in general Loggers are not harmful despite being full of state."
    },
    {
        "link": "https://geeksforgeeks.org/singleton-pattern-in-python-a-complete-guide",
        "document": "A Singleton pattern in python is a design pattern that allows you to create just one instance of a class, throughout the lifetime of a program. Using a singleton pattern has many benefits. A few of them are:\n• None To create a global point of access for a resource.\n• None To create just one instance of a class, throughout the lifetime of a program.\n\nA singleton pattern can be implemented in three different ways. They are as follows:\n\nAll modules are singleton, by definition. Let’s create a simple module-level singleton where the data is shared among other modules. Here we will create three python files – singleton.py, sample_module1.py, and sample_module2.py – in which the other sample modules share a variable from singleton.py.\n\nLet’s look into the output.\n\nHere, the value changed by samplemodule1 is also reflected in samplemodule2.\n\nClassic Singleton creates an instance only if there is no instance created so far; otherwise, it will return the instance that is already created. Let’s take a look at the below code.\n\nHere, in the __new__ method, we will check whether an instance is created or not. If created, it will return the instance; otherwise, it will create a new instance. You can notice that singleton and new_singleton return the same instance and have the same variable.\n\nLet’s check what happens when we subclass a singleton class.\n\nHere, you can see that SingletonChild has the same instance of SingletonClass and also shares the same state. But there are scenarios, where we need a different instance, but should share the same state. This state sharing can be achieved using Borg singleton.\n\nBorg singleton is a design pattern in Python that allows state sharing for different instances. Let’s look into the following code.\n\nAlong with the new instance creation process, a shared state is also defined in the __new__ method. Here the shared state is retained using the shared_borg_state attribute and it is stored in the __dict__ dictionary of each instance.\n\nIf you want a different state, then you can reset the shared_borg_state attribute. Let’s see how to reset a shared state.\n\nHere, we have reset the shared state and tried to access the shared_variable. Let’s see the error.\n\nLet’s list a few of the use cases of a singleton class. They are as follows:\n\nLet’s create a webcrawler that uses the benefit of a classic singleton. In this practical example, the crawler scans a webpage, fetch the links associated with the same website, and download all the images in it. Here, we have two main classes and two main functions.\n• None ParallelDownloader: This class provides thread functionality to download images\n• None navigate_site: This function crawls the website and fetches the links that belong to the same website. And, finally, it arranges the link to download images.\n• None download_images: This function crawls the page link and downloads the images.\n\nApart from the above classes and functions, we use two sets of libraries to parse the web page – BeautifulSoup and HTTP Client.\n\nHave a look at the below code.\n\nNote: Execute the code in your local machine\n\n\"\"\" creates a singleton object, if it is not created, or else returns the previous singleton object\"\"\" \"\"\" navigate the website using BFS algorithm, find links and # During the initial stage, url_queue has the main_url. # Upon parsing the main_url page, new links that belong to the # same website is added to the url_queue until # checks whether it reached the max. link # pop the url from the queue # add the link to download the images # crawl the web page and fetch the links within # skip the link, if it leads to an external page # skip, if the link is already added # so that the while loop continues with next iteration. \\ # Here we will fetch each URL and # download the images in it. # pop the url to download the images # parse the web page to find all images # adding the url to the queue for parsing # initializing a set to store path of the downloaded images # invoking the method to crawl the website\n\nLet’s look into the downloaded images and python shell output.\n\nSingleton pattern is a design pattern in Python that restricts the instantiation of a class to one object. It can limit concurrent access to a shared resource, and also it helps to create a global point of access for a resource.\n\nHow to Do Singleton Design Pattern in Python?\n\nWhat is the Attribute of Singleton in Python?\n\nWhat is the Factory Pattern in Python with Singleton?\n\nWhat is the Alternative to Singleton in Python?\n\nWhat is the Difference Between"
    },
    {
        "link": "https://pravash-techie.medium.com/python-singleton-pattern-for-effective-object-management-49d62ec3bd9b",
        "document": "Hi everyone, In this article I will talk about a pattern — pattern and exploring its purpose, benefits, and practical applications in Python. We’ll discover how Singleton promotes the creation of a single instance of a class, ensuring that this instance remains consistent throughout the application’s lifecycle.\n\nThrough illustrative examples and real-world use cases, we’ll unravel the power and versatility of the pattern, demonstrating its relevance in a wide range of scenarios.\n\nIts pretty simple one, it’s basically when we have a class for which we can only ever instantiate one object of that type and we might use it for all kinds of reasons.\n\nWhether you’re aiming to optimize resource usage, configuration data, or some kind of global read only data for our program, the pattern offers a clear and effective solution so that we can access a singleton to get that data.\n\nThe Design Pattern stands out as a versatile tool that addresses the need for a single, globally accessible instance of a particular class."
    },
    {
        "link": "https://refactoring.guru/design-patterns/singleton/python/example",
        "document": "Singleton is a creational design pattern, which ensures that only one object of its kind exists and provides a single point of access to it for any other code. Singleton has almost the same pros and cons as global variables. Although they’re super-handy, they break the modularity of your code. You can’t just use a class that depends on a Singleton in some other context, without carrying over the Singleton to the other context. Most of the time, this limitation comes up during the creation of unit tests.\n\nUsage examples: A lot of developers consider the Singleton pattern an antipattern. That’s why its usage is on the decline in Python code.\n\nIdentification: Singleton can be recognized by a static creation method, which returns the same cached object.\n\nIt’s pretty easy to implement a sloppy Singleton. You just need to hide the constructor and implement a static creation method. The same class behaves incorrectly in a multithreaded environment. Multiple threads can call the creation method simultaneously and get several instances of Singleton class. class SingletonMeta(type): \"\"\" The Singleton class can be implemented in different ways in Python. Some possible methods include: base class, decorator, metaclass. We will use the metaclass because it is best suited for this purpose. \"\"\" _instances = {} def __call__(cls, *args, **kwargs): \"\"\" Possible changes to the value of the `__init__` argument do not affect the returned instance. \"\"\" if cls not in cls._instances: instance = super().__call__(*args, **kwargs) cls._instances[cls] = instance return cls._instances[cls] class Singleton(metaclass=SingletonMeta): def some_business_logic(self): \"\"\" Finally, any singleton should define some business logic, which can be executed on its instance. \"\"\" # ... if __name__ == \"__main__\": # The client code. s1 = Singleton() s2 = Singleton() if id(s1) == id(s2): print(\"Singleton works, both variables contain the same instance.\") else: print(\"Singleton failed, variables contain different instances.\") Singleton works, both variables contain the same instance. To fix the problem, you have to synchronize threads during the first creation of the Singleton object. from threading import Lock, Thread class SingletonMeta(type): \"\"\" This is a thread-safe implementation of Singleton. \"\"\" _instances = {} _lock: Lock = Lock() \"\"\" We now have a lock object that will be used to synchronize threads during first access to the Singleton. \"\"\" def __call__(cls, *args, **kwargs): \"\"\" Possible changes to the value of the `__init__` argument do not affect the returned instance. \"\"\" # Now, imagine that the program has just been launched. Since there's no # Singleton instance yet, multiple threads can simultaneously pass the # previous conditional and reach this point almost at the same time. The # first of them will acquire lock and will proceed further, while the # rest will wait here. with cls._lock: # The first thread to acquire the lock, reaches this conditional, # goes inside and creates the Singleton instance. Once it leaves the # lock block, a thread that might have been waiting for the lock # release may then enter this section. But since the Singleton field # is already initialized, the thread won't create a new object. if cls not in cls._instances: instance = super().__call__(*args, **kwargs) cls._instances[cls] = instance return cls._instances[cls] class Singleton(metaclass=SingletonMeta): value: str = None \"\"\" We'll use this property to prove that our Singleton really works. \"\"\" def __init__(self, value: str) -> None: self.value = value def some_business_logic(self): \"\"\" Finally, any singleton should define some business logic, which can be executed on its instance. \"\"\" def test_singleton(value: str) -> None: singleton = Singleton(value) print(singleton.value) if __name__ == \"__main__\": # The client code. print(\"If you see the same value, then singleton was reused (yay!)\n\n\" \"If you see different values, \" \"then 2 singletons were created (booo!!)\n\n\n\n\" \"RESULT:\n\n\") process1 = Thread(target=test_singleton, args=(\"FOO\",)) process2 = Thread(target=test_singleton, args=(\"BAR\",)) process1.start() process2.start() If you see the same value, then singleton was reused (yay!) If you see different values, then 2 singletons were created (booo!!) RESULT: FOO FOO"
    },
    {
        "link": "https://stackoverflow.com/questions/31875/is-there-a-simple-elegant-way-to-define-singletons",
        "document": "There seem to be many ways to define singletons in Python. Is there a consensus opinion on Stack Overflow?\n\nThis question already has answers here :\n\nI don't really see the need, as a module with functions (and not a class) would serve well as a singleton. All its variables would be bound to the module, which could not be instantiated repeatedly anyway. If you do wish to use a class, there is no way of creating private classes or private constructors in Python, so you can't protect against multiple instantiations, other than just via convention in use of your API. I would still just put methods in a module, and consider the module as the singleton.\n\nHere's my own implementation of singletons. All you have to do is decorate the class; to get the singleton, you then have to use the method. Here's an example: @Singleton class Foo: def __init__(self): print 'Foo created' f = Foo() # Error, this isn't how you get the instance of a singleton f = Foo.instance() # Good. Being explicit is in line with the Python Zen g = Foo.instance() # Returns already created instance print f is g # True class Singleton: \"\"\" A non-thread-safe helper class to ease implementing singletons. This should be used as a decorator -- not a metaclass -- to the class that should be a singleton. The decorated class can define one `__init__` function that takes only the `self` argument. Also, the decorated class cannot be inherited from. Other than that, there are no restrictions that apply to the decorated class. To get the singleton instance, use the `instance` method. Trying to use `__call__` will result in a `TypeError` being raised. \"\"\" def __init__(self, decorated): self._decorated = decorated def instance(self): \"\"\" Returns the singleton instance. Upon its first call, it creates a new instance of the decorated class and calls its `__init__` method. On all subsequent calls, the already created instance is returned. \"\"\" try: return self._instance except AttributeError: self._instance = self._decorated() return self._instance def __call__(self): raise TypeError('Singletons must be accessed through `instance()`.') def __instancecheck__(self, inst): return isinstance(inst, self._decorated)\n\nI'm very unsure about this, but my project uses 'convention singletons' (not enforced singletons), that is, if I have a class called , I define this in the same module: _data_controller = None def GetDataController(): global _data_controller if _data_controller is None: _data_controller = DataController() return _data_controller It is not elegant, since it's a full six lines. But all my singletons use this pattern, and it's at least very explicit (which is pythonic).\n\nAs the accepted answer says, the most idiomatic way is to just use a module. With that in mind, here's a proof of concept: def singleton(cls): obj = cls() # Always return the same object cls.__new__ = staticmethod(lambda cls: obj) # Disable __init__ try: del cls.__init__ except AttributeError: pass return cls See the Python data model for more details on . @singleton class Duck(object): pass if Duck() is Duck(): print(\"It works!\") else: print(\"It doesn't work!\")\n• None You have to use new-style classes (derive from ) for this.\n• None The singleton is initialized when it is defined, rather than the first time it's used.\n• None This is just a toy example. I've never actually used this in production code, and don't plan to.\n\nI think that forcing a class or an instance to be a singleton is overkill. Personally, I like to define a normal instantiable class, a semi-private reference, and a simple factory function. class NothingSpecial: pass _the_one_and_only = None def TheOneAndOnly(): global _the_one_and_only if not _the_one_and_only: _the_one_and_only = NothingSpecial() return _the_one_and_only Or if there is no issue with instantiating when the module is first imported: That way you can write tests against fresh instances without side effects, and there is no need for sprinkling the module with global statements, and if needed you can derive variants in the future.\n\nOK, singleton could be good or evil, I know. This is my implementation, and I simply extend a classic approach to introduce a cache inside and produce many instances of a different type or, many instances of same type, but with different arguments. I called it Singleton_group, because it groups similar instances together and prevent that an object of the same class, with same arguments, could be created: # Peppelinux's cached singleton class Singleton_group(object): __instances_args_dict = {} def __new__(cls, *args, **kwargs): if not cls.__instances_args_dict.get((cls.__name__, args, str(kwargs))): cls.__instances_args_dict[(cls.__name__, args, str(kwargs))] = super(Singleton_group, cls).__new__(cls, *args, **kwargs) return cls.__instances_args_dict.get((cls.__name__, args, str(kwargs))) # It's a dummy real world use example: class test(Singleton_group): def __init__(self, salute): self.salute = salute a = test('bye') b = test('hi') c = test('bye') d = test('hi') e = test('goodbye') f = test('goodbye') id(a) 3070148780L id(b) 3070148908L id(c) 3070148780L b == d True b._Singleton_group__instances_args_dict {('test', ('bye',), '{}'): <__main__.test object at 0xb6fec0ac>, ('test', ('goodbye',), '{}'): <__main__.test object at 0xb6fec32c>, ('test', ('hi',), '{}'): <__main__.test object at 0xb6fec12c>} Every object carries the singleton cache... This could be evil, but it works great for some :)\n\nBeing relatively new to Python I'm not sure what the most common idiom is, but the simplest thing I can think of is just using a module instead of a class. What would have been instance methods on your class become just functions in the module and any data just becomes variables in the module instead of members of the class. I suspect this is the pythonic approach to solving the type of problem that people use singletons for. If you really want a singleton class, there's a reasonable implementation described on the first hit on Google for \"Python singleton\", specifically: class Singleton: __single = None def __init__( self ): if Singleton.__single: raise Singleton.__single Singleton.__single = self That seems to do the trick.\n\nI completely agree with staale and I leave here a sample of creating a singleton half brother: will report now as being of the same class as singleton even if it does not look like it. So singletons using complicated classes end up depending on we don't mess much with them. Being so, we can have the same effect and use simpler things like a variable or a module. Still, if we want use classes for clarity and because in Python a class is an object, so we already have the object (not and instance, but it will do just like). There we have a nice assertion error if we try to create an instance, and we can store on derivations static members and make changes to them at runtime (I love Python). This object is as good as other about half brothers (you still can create them if you wish), however it will tend to run faster due to simplicity."
    }
]