[
    {
        "link": "https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html",
        "document": "Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, gs, and file. For file URLs, a host is expected. A local file could be: file://localhost/path/to/table.csv. If you want to pass in a path object, pandas accepts any . By file-like object, we refer to objects with a method, such as a file handle (e.g. via builtin function) or .\n\nRow number(s) containing column labels and marking the start of the data (zero-indexed). Default behavior is to infer the column names: if no are passed the behavior is identical to and column names are inferred from the first line of the file, if column names are passed explicitly to then the behavior is identical to . Explicitly pass to be able to replace existing names. The header can be a list of integers that specify row locations for a on the columns e.g. . Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if , so denotes the first line of data rather than the first line of the file.\n\nColumn(s) to use as row label(s), denoted either by column labels or column indices. If a sequence of labels or indices is given, will be formed for the row labels. Note: can be used to force pandas to not use the first column as the index, e.g., when you have a malformed file with delimiters at the end of each line.\n\nSubset of columns to select, denoted either by column labels or column indices. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in or inferred from the document header row(s). If are given, the document header row(s) are not taken into account. For example, a valid list-like parameter would be or . Element order is ignored, so is the same as . To instantiate a from with element order preserved use for columns in order or for order. If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to . An example of a valid callable argument would be . Using this parameter results in much faster parsing time and lower memory usage.\n\nWhether or not to include the default values when parsing the data. Depending on whether is passed in, the behavior is as follows:\n• None If is , and are specified, is appended to the default values used for parsing.\n• None If is , and are not specified, only the default values are used for parsing.\n• None If is , and are specified, only the values specified are used for parsing.\n• None If is , and are not specified, no strings will be parsed as . Note that if is passed in as , the and parameters will be ignored.\n\nFunction to use for converting a sequence of string columns to an array of instances. The default uses to do the conversion. pandas will try to call in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by ) as arguments; 2) concatenate (row-wise) the string values from the columns defined by into a single array and pass that; and 3) call once for each row using one or more strings (corresponding to the columns defined by ) as arguments. Deprecated since version 2.0.0: Use instead, or read in as and then apply as-needed.\n\nFor on-the-fly decompression of on-disk data. If ‘infer’ and ‘filepath_or_buffer’ is path-like, then detect compression from the following extensions: ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, ‘.tar’, ‘.tar.gz’, ‘.tar.xz’ or ‘.tar.bz2’ (otherwise no compression). If using ‘zip’ or ‘tar’, the ZIP file must contain only one data file to be read in. Set to for no decompression. Can also be a dict with key set to one of { , , , , , } and other key-value pairs are forwarded to , , , , or , respectively. As an example, the following could be passed for Zstandard decompression using a custom compression dictionary: ."
    },
    {
        "link": "https://pandas.pydata.org/pandas-docs/version/1.3/reference/api/pandas.read_csv.html",
        "document": "Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, gs, and file. For file URLs, a host is expected. A local file could be: file://localhost/path/to/table.csv. If you want to pass in a path object, pandas accepts any . By file-like object, we refer to objects with a method, such as a file handle (e.g. via builtin function) or .\n\nRow number(s) to use as the column names, and the start of the data. Default behavior is to infer the column names: if no names are passed the behavior is identical to and column names are inferred from the first line of the file, if column names are passed explicitly then the behavior is identical to . Explicitly pass to be able to replace existing names. The header can be a list of integers that specify row locations for a multi-index on the columns e.g. [0,1,3]. Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if , so denotes the first line of data rather than the first line of the file.\n\nColumn(s) to use as the row labels of the , either given as string name or column index. If a sequence of int / str is given, a MultiIndex is used. Note: can be used to force pandas to not use the first column as the index, e.g. when you have a malformed file with delimiters at the end of each line.\n\nReturn a subset of the columns. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in or inferred from the document header row(s). For example, a valid list-like parameter would be or . Element order is ignored, so is the same as . To instantiate a DataFrame from with element order preserved use for columns in order or for order. If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True. An example of a valid callable argument would be . Using this parameter results in much faster parsing time and lower memory usage.\n\nWhether or not to include the default NaN values when parsing the data. Depending on whether is passed in, the behavior is as follows:\n• None If is True, and are specified, is appended to the default NaN values used for parsing.\n• None If is True, and are not specified, only the default NaN values are used for parsing.\n• None If is False, and are specified, only the NaN values specified are used for parsing.\n• None If is False, and are not specified, no strings will be parsed as NaN. Note that if is passed in as False, the and parameters will be ignored.\n\nFunction to use for converting a sequence of string columns to an array of datetime instances. The default uses to do the conversion. Pandas will try to call in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by ) as arguments; 2) concatenate (row-wise) the string values from the columns defined by into a single array and pass that; and 3) call once for each row using one or more strings (corresponding to the columns defined by ) as arguments."
    },
    {
        "link": "https://pandas.pydata.org/docs/dev/reference/api/pandas.read_csv.html",
        "document": "Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, gs, and file. For file URLs, a host is expected. A local file could be: file://localhost/path/to/table.csv. If you want to pass in a path object, pandas accepts any . By file-like object, we refer to objects with a method, such as a file handle (e.g. via builtin function) or .\n\nCharacter or regex pattern to treat as the delimiter. If , the C engine cannot automatically detect the separator, but the Python parsing engine can, meaning the latter will be used and automatically detect the separator from only the first valid row of the file by Python’s builtin sniffer tool, . In addition, separators longer than 1 character and different from will be interpreted as regular expressions and will also force the use of the Python parsing engine. Note that regex delimiters are prone to ignoring quoted data. Regex example: .\n\nRow number(s) containing column labels and marking the start of the data (zero-indexed). Default behavior is to infer the column names: if no are passed the behavior is identical to and column names are inferred from the first line of the file, if column names are passed explicitly to then the behavior is identical to . Explicitly pass to be able to replace existing names. The header can be a list of integers that specify row locations for a on the columns e.g. . Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if , so denotes the first line of data rather than the first line of the file. When inferred from the file contents, headers are kept distinct from each other by renaming duplicate names with a numeric suffix of the form starting from 1, e.g. and . Empty headers are named or in the case of MultiIndex columns.\n\nColumn(s) to use as row label(s), denoted either by column labels or column indices. If a sequence of labels or indices is given, will be formed for the row labels. Note: can be used to force pandas to not use the first column as the index, e.g., when you have a malformed file with delimiters at the end of each line.\n\nSubset of columns to select, denoted either by column labels or column indices. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in or inferred from the document header row(s). If are given, the document header row(s) are not taken into account. For example, a valid list-like parameter would be or . Element order is ignored, so is the same as . To instantiate a from with element order preserved use for columns in order or for order. If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to . An example of a valid callable argument would be . Using this parameter results in much faster parsing time and lower memory usage.\n\nWhether or not to include the default values when parsing the data. Depending on whether is passed in, the behavior is as follows:\n• None If is , and are specified, is appended to the default values used for parsing.\n• None If is , and are not specified, only the default values are used for parsing.\n• None If is , and are specified, only the values specified are used for parsing.\n• None If is , and are not specified, no strings will be parsed as . Note that if is passed in as , the and parameters will be ignored.\n\nFor on-the-fly decompression of on-disk data. If ‘infer’ and ‘filepath_or_buffer’ is path-like, then detect compression from the following extensions: ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, ‘.tar’, ‘.tar.gz’, ‘.tar.xz’ or ‘.tar.bz2’ (otherwise no compression). If using ‘zip’ or ‘tar’, the ZIP file must contain only one data file to be read in. Set to for no decompression. Can also be a dict with key set to one of { , , , , , } and other key-value pairs are forwarded to , , , , or , respectively. As an example, the following could be passed for Zstandard decompression using a custom compression dictionary: ."
    },
    {
        "link": "https://pandas.pydata.org/docs/user_guide/io.html",
        "document": "The pandas I/O API is a set of top level functions accessed like that generally return a pandas object. The corresponding functions are object methods that are accessed like . Below is a table containing available and .\n\nis an informal performance comparison for some of these IO methods.\n\nThe workhorse function for reading text files (a.k.a. flat files) is . See the for some advanced strategies. Either a path to a file (a , , or ), URL (including http, ftp, and S3 locations), or any object with a method (such as an open file or ). sep str, defaults to for , for Delimiter to use. If sep is , the C engine cannot automatically detect the separator, but the Python parsing engine can, meaning the latter will be used and automatically detect the separator by Python’s builtin sniffer tool, . In addition, separators longer than 1 character and different from will be interpreted as regular expressions and will also force the use of the Python parsing engine. Note that regex delimiters are prone to ignoring quoted data. Regex example: . Specifies whether or not whitespace (e.g. or ) will be used as the delimiter. Equivalent to setting . If this option is set to , nothing should be passed in for the parameter. Row number(s) to use as the column names, and the start of the data. Default behavior is to infer the column names: if no names are passed the behavior is identical to and column names are inferred from the first line of the file, if column names are passed explicitly then the behavior is identical to . Explicitly pass to be able to replace existing names. The header can be a list of ints that specify row locations for a MultiIndex on the columns e.g. . Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if , so header=0 denotes the first line of data rather than the first line of the file. List of column names to use. If file contains no header row, then you should explicitly pass . Duplicates in this list are not allowed. Column(s) to use as the row labels of the , either given as string name or column index. If a sequence of int / str is given, a MultiIndex is used. can be used to force pandas to use the first column as the index, e.g. when you have a malformed file with delimiters at the end of each line. The default value of instructs pandas to guess. If the number of fields in the column header row is equal to the number of fields in the body of the data file, then a default index is used. If it is larger, then the first columns are used as index so that the remaining number of fields in the body are equal to the number of fields in the header. The first row after the header is used to determine the number of columns, which will go into the index. If the subsequent rows contain less columns than the first row, they are filled with . This can be avoided through . This ensures that the columns are taken as is and the trailing data are ignored. Return a subset of the columns. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in or inferred from the document header row(s). If are given, the document header row(s) are not taken into account. For example, a valid list-like parameter would be or . Element order is ignored, so is the same as . To instantiate a DataFrame from with element order preserved use for columns in order or for order. If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True: Using this parameter results in much faster parsing time and lower memory usage when using the c engine. The Python engine loads the data first before deciding which columns to drop. dtype Type name or dict of column -> type, default Data type for data or columns. E.g. Use or together with suitable settings to preserve and not interpret dtype. If converters are specified, they will be applied INSTEAD of dtype conversion. Support for defaultdict was added. Specify a defaultdict as input where the default determines the dtype of the columns which are not explicitly listed. Which dtype_backend to use, e.g. whether a DataFrame should have NumPy arrays, nullable dtypes are used for all dtypes that have a nullable implementation when “numpy_nullable” is set, pyarrow is used for all dtypes if “pyarrow” is set. The dtype_backends are still experimential. Parser engine to use. The C and pyarrow engines are faster, while the python engine is currently more feature-complete. Multithreading is currently only supported by the pyarrow engine. The “pyarrow” engine was added as an engine, and some features are unsupported, or may not work correctly, with this engine. Dict of functions for converting values in certain columns. Keys can either be integers or column labels. Values to consider as . Values to consider as . Line numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file. If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise: Number of lines at bottom of file to skip (unsupported with engine=’c’). Number of rows of file to read. Useful for reading pieces of large files. Internally process the file in chunks, resulting in lower memory use while parsing, but possibly mixed type inference. To ensure no mixed types either set , or specify the type with the parameter. Note that the entire file is read into a single regardless, use the or parameter to return the data in chunks. (Only valid with C parser) If a filepath is provided for , map the file object directly onto memory and access the data directly from there. Using this option can improve performance because there is no longer any I/O overhead. Additional strings to recognize as NA/NaN. If dict passed, specific per-column NA values. See below for a list of the values interpreted as NaN by default. Whether or not to include the default NaN values when parsing the data. Depending on whether is passed in, the behavior is as follows:\n• None If is , and are specified, is appended to the default NaN values used for parsing.\n• None If is , and are not specified, only the default NaN values are used for parsing.\n• None If is , and are specified, only the NaN values specified are used for parsing.\n• None If is , and are not specified, no strings will be parsed as NaN. Note that if is passed in as , the and parameters will be ignored. Detect missing value markers (empty strings and the value of na_values). In data without any NAs, passing can improve the performance of reading a large file. Indicate number of NA values placed in non-numeric columns. If , skip over blank lines rather than interpreting as NaN values. parse_dates boolean or list of ints or names or list of lists or dict, default .\n• None If -> try parsing the index.\n• None If -> try parsing columns 1, 2, 3 each as a separate date column.\n• None If -> combine columns 1 and 3 and parse as a single date column.\n• None If -> parse columns 1, 3 as date and call result ‘foo’. If and parse_dates is enabled for a column, attempt to infer the datetime format to speed up the processing. A strict version of this argument is now the default, passing it has no effect. If and parse_dates specifies combining multiple columns then keep the original columns. Function to use for converting a sequence of string columns to an array of datetime instances. The default uses to do the conversion. pandas will try to call date_parser in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by parse_dates) as arguments; 2) concatenate (row-wise) the string values from the columns defined by parse_dates into a single array and pass that; and 3) call date_parser once for each row using one or more strings (corresponding to the columns defined by parse_dates) as arguments. Use instead, or read in as and then apply as-needed. If used in conjunction with , will parse dates according to this format. For anything more complex, please read in as and then apply as-needed. If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets. Return object for iteration or getting chunks with . Return object for iteration. See below. For on-the-fly decompression of on-disk data. If ‘infer’, then use gzip, bz2, zip, xz, or zstandard if is path-like ending in ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, respectively, and no decompression otherwise. If using ‘zip’, the ZIP file must contain only one data file to be read in. Set to for no decompression. Can also be a dict with key set to one of { , , , } and other key-value pairs are forwarded to , , , or . As an example, the following could be passed for faster compression and to create a reproducible gzip archive: . Character to recognize as decimal point. E.g. use for European data. Specifies which converter the C engine should use for floating-point values. The options are for the ordinary converter, for the high-precision converter, and for the round-trip converter. Character to break file into lines. Only valid with C parser. The character used to denote the start and end of a quoted item. Quoted items can include the delimiter and it will be ignored. Control field quoting behavior per constants. Use one of (0), (1), (2) or (3). When is specified and is not , indicate whether or not to interpret two consecutive elements inside a field as a single element. One-character string used to escape delimiter when quoting is . Indicates remainder of line should not be parsed. If found at the beginning of a line, the line will be ignored altogether. This parameter must be a single character. Like empty lines (as long as ), fully commented lines are ignored by the parameter but not by . For example, if , parsing ‘#empty\n\na,b,c\n\n1,2,3’ with will result in ‘a,b,c’ being treated as the header. Encoding to use for UTF when reading/writing (e.g. ). List of Python standard encodings. If provided, this parameter will override values (default or not) for the following parameters: , , , , , and . If it is necessary to override values, a ParserWarning will be issued. See documentation for more details. Specifies what to do upon encountering a bad line (a line with too many fields). Allowed values are :\n• None ‘error’, raise an ParserError when a bad line is encountered.\n• None ‘warn’, print a warning when a bad line is encountered and skip that line.\n• None ‘skip’, skip bad lines without raising or warning when they are encountered. You can indicate the data type for the whole or individual columns: Fortunately, pandas offers more than one way to ensure that your column(s) contain only one . If you’re unfamiliar with these concepts, you can see to learn more about dtypes, and to learn more about conversion in pandas. For instance, you can use the argument of : Or you can use the function to coerce the dtypes after reading in the data, which will convert all valid parsing to floats, leaving the invalid parsing as . Ultimately, how you deal with reading in columns containing mixed dtypes depends on your specific needs. In the case above, if you wanted to out the data anomalies, then is probably your best option. However, if you wanted for all the data to be coerced, no matter the type, then using the argument of would certainly be worth trying. In some cases, reading in abnormal data with columns containing mixed dtypes will result in an inconsistent dataset. If you rely on pandas to infer the dtypes of your columns, the parsing engine will go and infer the dtypes for different chunks of the data, rather than the whole dataset at once. Consequently, you can end up with column(s) with mixed dtypes. For example, will result with containing an dtype for certain chunks of the column, and for others due to the mixed dtypes from the data that was read in. It is important to note that the overall column will be marked with a of , which is used for columns with mixed dtypes. Setting will result in nullable dtypes for every column. columns can be parsed directly by specifying or . Individual columns can be parsed as a using a dict specification: Specifying will result in an unordered whose are the unique values observed in the data. For more control on the categories and order, create a ahead of time, and pass that for that column’s . When using , “unexpected” values outside of are treated as missing values. This matches the behavior of . With , the resulting categories will always be parsed as strings (object dtype). If the categories are numeric they can be converted using the function, or as appropriate, another converter such as . When is a with homogeneous ( all numeric, all datetimes, etc.), the conversion is done automatically. A file may or may not have a header row. pandas assumes the first row should be used as the column names: By specifying the argument in conjunction with you can indicate other names to use and whether or not to throw away the header row (if any): If the header is in a row other than the first, pass the row number to . This will skip the preceding rows: Default behavior is to infer the column names: if no names are passed the behavior is identical to and column names are inferred from the first non-blank line of the file, if column names are passed explicitly then the behavior is identical to . If the file or header contains duplicate names, pandas will by default distinguish between them so as to prevent overwriting data: There is no more duplicate data because duplicate columns ‘X’, …, ‘X’ become ‘X’, ‘X.1’, …, ‘X.N’. The argument allows you to select any subset of the columns in a file, either using the column names, position numbers or a callable: The argument can also be used to specify which columns not to use in the final result: In this case, the callable is specifying that we exclude the “a” and “c” columns from the output. If the parameter is specified, then completely commented lines will be ignored. By default, completely blank lines will be ignored as well. If , then will not ignore blank lines: The presence of ignored lines might create ambiguities involving line numbers; the parameter uses row numbers (ignoring commented/empty lines), while uses line numbers (including commented/empty lines): If both and are specified, will be relative to the end of . For example: Sometimes comments or meta data may be included in a file: By default, the parser includes the comments in the output: We can suppress the comments using the keyword: The argument should be used for encoded unicode data, which will result in byte strings being decoded to unicode in the result: Some formats which encode all characters as multiple bytes, like UTF-16, won’t parse correctly at all without specifying the encoding. Full list of Python standard encodings. If a file has one more column of data than the number of column names, the first column will be used as the ’s row names: Ordinarily, you can achieve this behavior using the option. There are some exception cases when a file has been prepared with delimiters at the end of each data line, confusing the parser. To explicitly disable the index column inference and discard the last column, pass : If a subset of data is being parsed using the option, the specification is based on that subset, not the original data. To better facilitate working with datetime data, uses the keyword arguments and to allow users to specify a variety of columns and date/time formats to turn the input text data into objects. The simplest case is to just pass in : # Use a column as an index, and parse it as dates. It is often the case that we may want to store date and time data separately, or store various date fields separately. the keyword can be used to specify a combination of columns to parse the dates and/or times from. You can specify a list of column lists to , the resulting date columns will be prepended to the output (so as to not affect the existing column order) and the new column names will be the concatenation of the component column names: By default the parser removes the component date columns, but you can choose to retain them via the keyword: Note that if you wish to combine multiple columns into a single date column, a nested list must be used. In other words, indicates that the second and third columns should each be parsed as separate date columns while means the two columns should be parsed into a single column. You can also use a dict to specify custom name columns: It is important to remember that if multiple text columns are to be parsed into a single date column, then a new column is prepended to the data. The specification is based off of this new set of columns rather than the original data columns: If a column or index contains an unparsable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use after . read_csv has a fast_path for parsing datetime strings in iso8601 format, e.g “2000-01-01T00:01:02+00:00” and similar variations. If you can arrange for your data to store datetimes in this format, load times will be significantly faster, ~20x has been observed. Combining date columns inside read_csv is deprecated. Use on the relevant result columns instead. Finally, the parser allows you to specify a custom . Performance-wise, you should try these methods of parsing dates in order:\n• None If you know the format, use , e.g.: or .\n• None If you different formats for different columns, or want to pass any extra options (such as ) to , then you should read in your data as dtype, and then use . pandas cannot natively represent a column or index with mixed timezones. If your CSV file contains columns with a mixture of timezones, the default result will be an object-dtype column with strings, even with . To parse the mixed-timezone values as a datetime column, read in as dtype and then call with . Here are some examples of datetime strings that can be guessed (all representing December 30th, 2011 at 00:00:00): Note that format inference is sensitive to . With , it will guess “01/12/2011” to be December 1st. With (default) it will guess “01/12/2011” to be January 12th. If you try to parse a column of date strings, pandas will attempt to guess the format from the first non-NaN element, and will then parse the rest of the column with that format. If pandas fails to guess the format (for example if your first string is ), then a warning will be raised and each row will be parsed individually by . The safest way to parse dates is to explicitly set . In the case that you have mixed datetime formats within the same column, you can pass or, if your datetime formats are all ISO8601 (possibly not identically-formatted): While US date formats tend to be MM/DD/YYYY, many international formats use DD/MM/YYYY instead. For convenience, a keyword is provided: allows writing a CSV to a file object opened binary mode. In most cases, it is not necessary to specify as Pandas will auto-detect whether the file object is opened in text or binary mode. The parameter can be specified in order to use a specific floating-point converter during parsing with the C engine. The options are the ordinary converter, the high-precision converter, and the round-trip converter (which is guaranteed to round-trip values after writing to a file). For example: For large numbers that have been written with a thousands separator, you can set the keyword to a string of length 1 so that integers will be parsed correctly: By default, numbers with a thousands separator will be parsed as strings: The keyword allows integers to be parsed correctly: To control which values are parsed as missing values (which are signified by ), specify a string in . If you specify a list of strings, then all values in it are considered to be missing values. If you specify a number (a , like or an like ), the corresponding equivalent values will also imply a missing value (in this case effectively are recognized as ). To completely override the default values that are recognized as missing, specify . Let us consider some examples: In the example above and will be recognized as , in addition to the defaults. A string will first be interpreted as a numerical , then as a . Above, only an empty field will be recognized as . Above, both and as strings are . The default values, in addition to the string are recognized as . like values will be parsed as (positive infinity), and as (negative infinity). These will ignore the case of the value, meaning , will also be parsed as . The common values , , , and are all recognized as boolean. Occasionally you might want to recognize other values as being boolean. To do this, use the and options as follows: Some files may have malformed lines with too few fields or too many. Lines with too few fields will have NA values filled in the trailing fields. Lines with too many fields will raise an error by default: Traceback (most recent call last) in in in in in in in in in : Error tokenizing data. C error: Expected 3 fields in line 3, saw 4 You can elect to skip bad lines: Or pass a callable function to handle the bad line if . The bad line will be a list of strings that was split by the : The callable function will handle only a line with too many fields. Bad lines caused by other errors will be silently skipped. name a,a is of type a 'name,type\n\nname a,a is of type a\n\nname b,\"b\" is of type b\"' 0 name a a is of type a The line was not processed in this case, as a “bad line” here is caused by an escape character. You can also use the parameter to eliminate extraneous column data that appear in some lines but not others: Traceback (most recent call last) in in in in in in \"Usecols do not match columns, columns expected but not found: \" : Usecols do not match columns, columns expected but not found: [0, 1, 2] In case you want to keep all data including the lines with too many fields, you can specify a sufficient number of . This ensures that lines with not enough fields are filled with . 1 name a a is of type a NaN NaN 2 name b b is of type b\" NaN NaN The keyword gives greater flexibility in specifying the file format. By default it uses the Excel dialect but you can specify either the dialect name or a instance. Suppose you had data with unenclosed quotes: By default, uses the Excel dialect and treats the double quote as the quote character, which causes it to fail when it finds a newline before it finds the closing double quote. We can get around this using : All of the dialect options can be specified separately by keyword arguments: Another common dialect option is , to skip any whitespace after a delimiter: The parsers make every attempt to “do the right thing” and not be fragile. Type inference is a pretty big deal. If a column can be coerced to integer dtype without altering the contents, the parser will do so. Any non-numeric columns will come through as object dtype as with the rest of pandas objects. Quotes (and other escape characters) in embedded fields can be handled in any number of ways. One way is to use backslashes; to properly parse this data, you should pass the option: \"hello, \\\"Bob\\\", nice to see you\",5 0 hello, \"Bob\", nice to see you 5 While reads delimited data, the function works with data files that have known and fixed column widths. The function parameters to are largely the same as with two extra parameters, and a different usage of the parameter:\n• None : A list of pairs (tuples) giving the extents of the fixed-width fields of each line as half-open intervals (i.e., [from, to[ ). String value ‘infer’ can be used to instruct the parser to try detecting the column specifications from the first 100 rows of the data. Default behavior, if not specified, is to infer.\n• None : A list of field widths which can be used instead of ‘colspecs’ if the intervals are contiguous.\n• None : Characters to consider as filler characters in the fixed-width file. Can be used to specify the filler character of the fields if it is not spaces (e.g., ‘~’). In order to parse this file into a , we simply need to supply the column specifications to the function along with the file name: Note how the parser automatically picks column names X.<column number> when argument is specified. Alternatively, you can supply just the column widths for contiguous columns: The parser will take care of extra white spaces around the columns so it’s ok to have extra separation between the columns in the file. By default, will try to infer the file’s by using the first 100 rows of the file. It can do it only in cases when the columns are aligned and correctly separated by the provided (default delimiter is whitespace). supports the parameter for specifying the types of parsed columns to be different from the inferred type. Consider a file with one less entry in the header than the number of data column: In this special case, assumes that the first column is to be used as the index of the : Note that the dates weren’t automatically parsed. In that case you would need to do as before: Suppose you have data indexed by two columns: The argument to can take a list of column numbers to turn multiple columns into a for the index of the returned object: By specifying list of row locations for the argument, you can read in a for the columns. Specifying non-consecutive rows will skip the intervening rows. is also able to interpret a more common format of multi-columns indices. If an is not specified (e.g. you don’t have an index, or wrote it with , then any on the columns index will be . is capable of inferring delimited (not necessarily comma-separated) files, as pandas uses the class of the csv module. For this, you have to specify . It’s best to use to combine multiple files. See the for an example. Suppose you wish to iterate through a (potentially very large) file lazily rather than reading the entire file into memory, such as the following: By specifying a to , the return value will be an iterable object of type : Specifying will also return the object: Pandas currently supports three engines, the C engine, the python engine, and an experimental pyarrow engine (requires the package). In general, the pyarrow engine is fastest on larger workloads and is equivalent in speed to the C engine on most other workloads. The python engine tends to be slower than the pyarrow and C engines on most workloads. However, the pyarrow engine is much less robust than the C engine, which lacks a few features compared to the Python engine. Where possible, pandas uses the C parser (specified as ), but it may fall back to Python if C-unsupported options are specified. Currently, options unsupported by the C and pyarrow engines include: Specifying any of the above options will produce a unless the python engine is selected explicitly using . Options that are unsupported by the pyarrow engine which are not covered by the list above include: Specifying these options with will raise a . You can pass in a URL to read or write remote files to many of pandas’ IO functions - the following example shows reading a CSV file: A custom header can be sent alongside HTTP(s) requests by passing a dictionary of header key value mappings to the keyword argument as shown below: All URLs which are not local files or HTTP(s) are handled by fsspec, if installed, and its various filesystem implementations (including Amazon S3, Google Cloud, SSH, FTP, webHDFS…). Some of these implementations will require additional packages to be installed, for example S3 URLs require the s3fs library: When dealing with remote storage systems, you might need extra configuration with environment variables or config files in special locations. For example, to access data in your S3 bucket, you will need to define credentials in one of the several ways listed in the S3Fs documentation. The same is true for several of the storage backends, and you should follow the links at fsimpl1 for implementations built into and fsimpl2 for those not included in the main distribution. You can also pass parameters directly to the backend driver. Since does not utilize the environment variable, we can directly define a dictionary containing the endpoint_url and pass the object into the storage option parameter: More sample configurations and documentation can be found at S3Fs documentation. If you do have S3 credentials, you can still access public data by specifying an anonymous connection, such as also allows complex URLs, for accessing data in compressed archives, local caching of files, and more. To locally cache the above example, you would modify the call to where we specify that the “anon” parameter is meant for the “s3” part of the implementation, not to the caching implementation. Note that this caches to a temporary directory for the duration of the session only, but you can also specify a permanent store. The and objects have an instance method which allows storing the contents of the object as a comma-separated-values file. The function takes a number of arguments. Only the first is required.\n• None : A string path to the file to write or a file object. If a file object it must be opened with\n• None : Whether to write out the column names (default True)\n• None : Column label(s) for index column(s) if desired. If None (default), and and are True, then the index names are used. (A sequence should be given if the uses MultiIndex).\n• None : a string representing the encoding to use if the contents are non-ASCII, for Python versions prior to 3\n• None : Set quoting rules as in csv module (default csv.QUOTE_MINIMAL). Note that if you have set a then floats are converted to strings and csv.QUOTE_NONNUMERIC will treat them as non-numeric\n• None : Character used to quote fields (default ‘”’)\n• None : Character used to escape and when appropriate (default None)\n• None : Number of rows to write at a time The object has an instance method which allows control over the string representation of the object. All arguments are optional:\n• None default None, for example a StringIO object\n• None default None, which columns to write\n• None default None, minimum width of each column.\n• None default None, a dictionary (by column) of functions each of which takes a single argument and returns a formatted string\n• None default None, a function which takes a single (float) argument and returns a formatted string; to be applied to floats in the .\n• None default True, set to False for a with a hierarchical index to print every MultiIndex key at each row.\n• None default True, will print the names of the indices The object also has a method, but with only the , , arguments. There is also a argument which, if set to , will additionally output the length of the Series.\n\nA or can be converted to a valid JSON string. Use with optional parameters:\n• None : the pathname or buffer to write the output. This can be in which case a JSON string is returned.\n• The format of the JSON string\n• None : string, type of date conversion, ‘epoch’ for timestamp, ‘iso’ for ISO8601.\n• None : The number of decimal places to use when encoding floating point values, default 10.\n• None : The time unit to encode to, governs timestamp and ISO8601 precision. One of ‘s’, ‘ms’, ‘us’ or ‘ns’ for seconds, milliseconds, microseconds and nanoseconds respectively. Default ‘ms’.\n• None : The handler to call if an object cannot otherwise be converted to a suitable format for JSON. Takes a single argument, which is the object to convert, and returns a serializable object.\n• None : If orient, then will write each record per line as json.\n• None : string, writer mode when writing to path. ‘w’ for write, ‘a’ for append. Default ‘w’ Note ’s, ’s and will be converted to and objects will be converted based on the and parameters. There are a number of different options for the format of the resulting JSON file / string. Consider the following and : Column oriented (the default for ) serializes the data as nested JSON objects with column labels acting as the primary index: # Not available for Series Index oriented (the default for ) similar to column oriented but the index labels are now primary: Record oriented serializes the data to a JSON array of column -> value records, index labels are not included. This is useful for passing data to plotting libraries, for example the JavaScript library : Value oriented is a bare-bones option which serializes to nested JSON arrays of values only, column and index labels are not included: # Not available for Series Split oriented serializes to a JSON object containing separate entries for values, index and columns. Name is also included for : Table oriented serializes to the JSON Table Schema, allowing for the preservation of metadata including but not limited to dtypes and index names. Any orient option that encodes to a JSON object will not preserve the ordering of index and column labels during round-trip serialization. If you wish to preserve label ordering use the option as it uses ordered containers. Writing to a file, with a date index and a date column: If the JSON serializer cannot handle the container contents directly it will fall back in the following manner:\n• None if the dtype is unsupported (e.g. ) then the , if provided, will be called for each value, otherwise an exception is raised.\n• None if an object is unsupported it will attempt the following:\n• None check if the object has defined a method and call it. A method should return a which will then be JSON serialized.\n• None invoke the if one was provided.\n• None convert the object to a by traversing its contents. However this will often fail with an or give unexpected results. In general the best approach for unsupported objects or dtypes is to provide a . For example: can be dealt with by specifying a simple : Reading a JSON string to pandas object can take a number of parameters. The parser will try to parse a if is not supplied or is . To explicitly force parsing, pass\n• None : a VALID JSON string or file handle / StringIO. The string could be a URL. Valid URL schemes include http, ftp, S3, and file. For file URLs, a host is expected. For instance, a local file could be file ://localhost/path/to/table.json\n• None : type of object to recover (series or frame), default ‘frame’\n• The format of the JSON string\n• None : if True, infer dtypes, if a dict of column to dtype, then use those, if , then don’t infer dtypes at all, default is True, apply only to the data.\n• None : boolean, try to convert the axes to the proper dtypes, default is\n• None : a list of columns to parse for dates; If , then try to parse date-like columns, default is .\n• None : boolean, default . If parsing dates, then parse the default date-like columns.\n• None : boolean, default . Set to enable usage of higher precision (strtod) function when decoding string to double values. Default ( ) is to use fast but less precise builtin functionality.\n• None : string, the timestamp unit to detect if converting dates. Default None. By default the timestamp precision will be detected, if this is not desired then pass one of ‘s’, ‘ms’, ‘us’ or ‘ns’ to force timestamp precision to seconds, milliseconds, microseconds or nanoseconds respectively.\n• None : reads file as one json object per line.\n• None : The encoding to use to decode py3 bytes.\n• None : when used in combination with , return a which reads in lines per iteration.\n• None : Either , the built-in JSON parser, or which dispatches to pyarrow’s . The is only available when The parser will raise one of if the JSON is not parseable. If a non-default was used when encoding to JSON be sure to pass the same option here so that decoding produces sensible results, see Orient Options for an overview. The default of , , and will try to parse the axes, and all of the data into appropriate types, including dates. If you need to override specific dtypes, pass a dict to . should only be set to if you need to preserve string-like numbers (e.g. ‘1’, ‘2’) in an axes. Large integer values may be converted to dates if and the data and / or column labels appear ‘date-like’. The exact threshold depends on the specified. ‘date-like’ means that the column label meets one of the following criteria: When reading JSON data, automatic coercing into dtypes has some quirks:\n• None an index can be reconstructed in a different order from serialization, that is, the returned order is not guaranteed to be the same as before serialization\n• None a column that was data will be converted to if it can be done safely, e.g. a column of\n• None bool columns will be converted to on reconstruction Thus there are times where you may want to specify specific dtypes via the keyword argument. Don’t convert any data (but still convert axes and dates): Dates written in nanoseconds need to be read back in nanoseconds: # Try to parse timestamps as milliseconds -> Won't Work # Or specify that all timestamps are in nanoseconds By setting the argument you can control the default dtypes used for the resulting DataFrame. pandas provides a utility function to take a dict or list of dicts and this semi-structured data into a flat table. The max_level parameter provides more control over which level to end normalization. With max_level=1 the following snippet normalizes until 1st nesting level of the provided dict. pandas is able to read and write line-delimited json files that are common in data processing pipelines using Hadoop or Spark. For line-delimited json files, pandas can also return an iterator which reads in lines at a time. This can be useful for large files or to read from a stream. # reader is an iterator that returns ``chunksize`` lines each iteration Line-limited json can also be read using the pyarrow reader by specifying . Table Schema is a spec for describing tabular datasets as a JSON object. The JSON includes information on the field names, types, and other attributes. You can use the orient to build a JSON string with two fields, and . The field contains the key, which itself contains a list of column name to type pairs, including the or (see below for a list of types). The field also contains a field if the (Multi)index is unique. The second field, , contains the serialized data with the orient. The index is included, and any datetimes are ISO 8601 formatted, as required by the Table Schema spec. The full list of types supported are described in the Table Schema spec. This table shows the mapping from pandas types: A few notes on the generated table schema:\n• None The object contains a field. This contains the version of pandas’ dialect of the schema, and will be incremented with each revision.\n• None All dates are converted to UTC when serializing. Even timezone naive values, which are treated as UTC with an offset of 0.\n• None datetimes with a timezone (before serializing), include an additional field with the time zone name (e.g. ).\n• None Periods are converted to timestamps before serialization, and so have the same behavior of being converted to UTC. In addition, periods will contain and additional field with the period’s frequency, e.g. .\n• None Categoricals use the type and an constraint listing the set of possible values. Additionally, an field is included:\n• None A field, containing an array of labels, is included if the index is unique :\n• None The behavior is the same with MultiIndexes, but in this case the is an array:\n• None The default naming roughly follows these rules:\n• None For series, the is used. If that’s none, then the name is\n• None For , the stringified version of the column name is used\n• None For (not ), is used, with a fallback to if that is None.\n• None For , is used. If any level has no name, then is used. also accepts as an argument. This allows for the preservation of metadata such as dtypes and index names in a round-trippable manner. Please note that the literal string ‘index’ as the name of an is not round-trippable, nor are any names beginning with within a . These are used by default in to indicate missing values and the subsequent read cannot distinguish the intent. When using along with user-defined , the generated schema will contain an additional key in the respective element. This extra key is not standard but does enable JSON roundtrips for extension types (e.g. ). The key carries the name of the extension, if you have properly registered the , pandas will use said name to perform a lookup into the registry and re-convert the serialized data into your custom dtype.\n\nThe method can read Excel 2007+ ( ) files using the Python module. Excel 2003 ( ) files can be read using . Binary Excel ( ) files can be read using . All formats can be read using engine. The instance method is used for saving a to Excel. Generally the semantics are similar to working with data. See the for some advanced strategies. When , the following logic will be used to determine the engine:\n• None If is an OpenDocument format (.odf, .ods, .odt), then odf will be used.\n• None Otherwise if is an xls format, will be used.\n• None Otherwise if is in xlsb format, will be used.\n• None Otherwise will be used. In the most basic use-case, takes a path to an Excel file, and the indicating which sheet to parse. When using the parameter, pandas will pass these arguments to the engine. For this, it is important to know which function pandas is using internally.\n• None For the engine openpyxl, pandas is using to read in ( ) and ( ) files.\n• None For the engine xlrd, pandas is using to read in ( ) files.\n• None For the engine pyxlsb, pandas is using to read in ( ) files.\n• None For the engine odf, pandas is using to read in ( ) files.\n• None For the engine calamine, pandas is using to read in ( ), ( ), ( ), ( ), ( ) files. To facilitate working with multiple sheets from the same file, the class can be used to wrap the file and can be passed into There will be a performance benefit for reading multiple sheets as the file is read into memory only once. The class can also be used as a context manager. The property will generate a list of the sheet names in the file. The primary use-case for an is parsing multiple sheets with different parameters: # For when Sheet1's format differs from Sheet2 Note that if the same parsing parameters are used for all sheets, a list of sheet names can simply be passed to with no loss in performance. can also be called with a object as a parameter. This allows the user to control how the excel file is read. For example, sheets can be loaded on demand by calling with . The second argument is , not to be confused with . An ExcelFile’s attribute provides access to a list of sheets.\n• None The arguments allows specifying the sheet or sheets to read.\n• None The default value for is 0, indicating to read the first sheet\n• None Pass a string to refer to the name of a particular sheet in the workbook.\n• None Pass an integer to refer to the index of a sheet. Indices follow Python convention, beginning at 0.\n• None Pass a list of either strings or integers, to return a dictionary of specified sheets.\n• None Pass a to return a dictionary of all available sheets. Using None to get all sheets: Using a list to get multiple sheets: # Returns the 1st and 4th sheet, as a dictionary of DataFrames. can read more than one sheet, by setting to either a list of sheet names, a list of sheet positions, or to read all sheets. Sheets can be specified by sheet index or sheet name, using an integer or string, respectively. can read a index, by passing a list of columns to and a column by passing a list of rows to . If either the or have serialized level names those will be read in as well by specifying the rows/columns that make up the levels. For example, to read in a index without names: If the index has level names, they will parsed as well, using the same parameters. If the source file has both index and columns, lists specifying each should be passed to and : Missing values in columns specified in will be forward filled to allow roundtripping with for . To avoid forward filling the missing values use after reading the data instead of . It is often the case that users will insert columns to do temporary computations in Excel and you may not want to read in those columns. takes a keyword to allow you to specify a subset of columns to parse. You can specify a comma-delimited set of Excel columns and ranges as a string: If is a list of integers, then it is assumed to be the file column indices to be parsed. Element order is ignored, so is the same as . If is a list of strings, it is assumed that each string corresponds to a column name provided either by the user in or inferred from the document header row(s). Those strings define which columns will be parsed: Element order is ignored, so is the same as . If is callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to . Datetime-like values are normally automatically converted to the appropriate dtype when reading the excel file. But if you have a column of strings that like dates (but are not actually formatted as dates in excel), you can use the keyword to parse those strings to datetimes: It is possible to transform the contents of Excel cells via the option. For instance, to convert a column to boolean: This options handles missing values and treats exceptions in the converters as missing data. Transformations are applied cell by cell rather than to the column as a whole, so the array dtype is not guaranteed. For instance, a column of integers with missing values cannot be transformed to an array with integer dtype, because NaN is strictly a float. You can manually mask missing data to recover integer dtype: As an alternative to converters, the type for an entire column can be specified using the keyword, which takes a dictionary mapping column names to types. To interpret data with no type inference, use the type or . To write a object to a sheet of an Excel file, you can use the instance method. The arguments are largely the same as described above, the first argument being the name of the excel file, and the optional second argument the name of the sheet to which the should be written. For example: Files with a extension will be written using (if available) or . The will be written in a way that tries to mimic the REPL output. The will be placed in the second row instead of the first. You can place it in the first row by setting the option in to : In order to write separate to separate sheets in a single Excel file, one can pass an . When using the parameter, pandas will pass these arguments to the engine. For this, it is important to know which function pandas is using internally.\n• None For the engine openpyxl, pandas is using to create a new sheet and to append data to an existing sheet. The openpyxl engine writes to ( ) and ( ) files.\n• None For the engine xlsxwriter, pandas is using to write to ( ) files.\n• None For the engine odf, pandas is using to write to ( ) files. pandas supports writing Excel files to buffer-like objects such as or using . # By setting the 'engine' in the ExcelWriter constructor. # Seek to the beginning and read to copy the workbook to a variable in memory is optional but recommended. Setting the engine determines the version of workbook produced. Setting will produce an Excel 2003-format workbook (xls). Using either or will produce an Excel 2007-format workbook (xlsx). If omitted, an Excel 2007-formatted workbook is produced. pandas chooses an Excel writer via two methods:\n• None the filename extension (via the default specified in config options) By default, pandas uses the XlsxWriter for , openpyxl for . If you have multiple engines installed, you can set the default engine through and . pandas will fall back on openpyxl for files if Xlsxwriter is not available. To specify which writer you want to use, you can pass an engine keyword argument to and to . The built-in engines are: # By setting the 'engine' in the DataFrame 'to_excel()' methods. # By setting the 'engine' in the ExcelWriter constructor. The look and feel of Excel worksheets created from pandas can be modified using the following parameters on the ’s method.\n• None : A tuple of two integers representing the bottommost row and rightmost column to freeze. Each of these parameters is one-based, so (1, 1) will freeze the first row and first column (default ). Using the Xlsxwriter engine provides many options for controlling the format of an Excel worksheet created with the method. Excellent examples can be found in the Xlsxwriter documentation here: https://xlsxwriter.readthedocs.io/working_with_pandas.html\n\nis a dict-like object which reads and writes pandas using the high performance HDF5 format using the excellent PyTables library. See the for some advanced strategies pandas uses PyTables for reading and writing HDF5 files, which allows serializing object-dtype data with pickle. Loading pickled data received from untrusted sources can be unsafe. See: https://docs.python.org/3/library/pickle.html for more. Objects can be written to the file just like adding key-value pairs to a dict: In a current or later Python session, you can retrieve stored objects: # dotted (attribute) access provides get as well Deletion of the object specified by the key: # Working with, and automatically closing the store using a context manager supports a top-level API using for reading and for writing, similar to how and work. HDFStore will by default not drop rows that are all missing. This behavior can be changed by setting . The examples above show storing using , which write the HDF5 to in a fixed array format, called the format. These types of stores are not appendable once written (though you can simply remove them and rewrite). Nor are they queryable; they must be retrieved in their entirety. They also do not support dataframes with non-unique column names. The format stores offer very fast writing and slightly faster reading than stores. This format is specified by default when using or or by or . A format will raise a if you try to retrieve using a : Traceback (most recent call last) in \"key must be provided when HDF5 \" # if there is an error, close the store if we opened it. in in in in # start, stop applied to rows, so 0th axis only in \"a Fixed format store. this store must be selected in its entirety\" \"cannot pass a where specification when reading \" \"from a Fixed format store. this store must be selected in its entirety\" : cannot pass a where specification when reading from a Fixed format store. this store must be selected in its entirety supports another format on disk, the format. Conceptually a is shaped very much like a DataFrame, with rows and columns. A may be appended to in the same or other sessions. In addition, delete and query type operations are supported. This format is specified by or to or or . This format can be set as an option as well to enable to by default store in the format. You can also create a by passing or to a operation. Keys to a store can be specified as a string. These can be in a hierarchical path-name like format (e.g. ), which will generate a hierarchy of sub-stores (or in PyTables parlance). Keys can be specified without the leading ‘/’ and are always absolute (e.g. ‘foo’ refers to ‘/foo’). Removal operations can remove everything in the sub-store and below, so be . # remove all nodes under this level You can walk through the group hierarchy using the method which will yield a tuple for each group key along with the relative keys of its contents. Hierarchical keys cannot be retrieved as dotted (attribute) access as described above for items stored under the root node. Traceback (most recent call last) in \"\"\"allow attribute access to get stores\"\"\" in in in \"cannot create a storer if the object is not existing \" \"nor a value are passed\" : cannot create a storer if the object is not existing nor a value are passed # you can directly access the actual PyTables node but using the root node Storing mixed-dtype data is supported. Strings are stored as a fixed-width using the maximum size of the appended column. Subsequent attempts at appending longer strings will raise a . Passing as a parameter to append will set a larger minimum for the string columns. Storing are currently supported. For string columns, passing to append will change the default nan representation on disk (which converts to/from ), this defaults to . Storing MultiIndex as tables is very similar to storing/selecting from homogeneous index . # the levels are automatically included as data columns The keyword is reserved and cannot be use as a level name. and operations have an optional criterion that can be specified to select/delete only a subset of the data. This allows one to have a very large on-disk table and retrieve only a portion of the data. A query is specified using the class under the hood, as a boolean expression.\n• None and are supported indexers of .\n• None if are specified, these can be used as additional indexers.\n• None level name in a MultiIndex, with default name , , … if not provided. These rules are similar to how boolean expressions are used in pandas for indexing.\n• None will be automatically expanded to the comparison operator\n• None is the not operator, but can only be used in very limited circumstances\n• None If a list/tuple of expressions is passed they will be combined via The following are valid expressions: The are on the left-hand side of the sub-expression: The right-hand side of the sub-expression (after a comparison operator) can be:\n• None functions that will be evaluated, e.g.\n• None variables that are defined in the local names space, e.g. Passing a string to a query by interpolating it into the query expression is not recommended. Simply assign the string of interest to a variable and use that variable in an expression. For example, do this The latter will not work and will raise a .Note that there’s a single quote followed by a double quote in the variable. If you interpolate, use the format specifier which will quote . The keyword can be supplied to select a list of columns to be returned, this is equivalent to passing a : and parameters can be specified to limit the total search space. These are in terms of the total number of rows in a table. will raise a if the query expression has an unknown variable reference. Usually this means that you are trying to select on a column that is not a data_column. will raise a if the query expression is not valid. You can store and query using the type. Terms can be specified in the format: , where float may be signed (and fractional), and unit can be for the timedelta. Here’s an example: Selecting from a can be achieved by using the name of the level. If the levels names are , the levels are automatically made available via the keyword with the level of the you want to select from. # the levels are automatically included as data columns with keyword level_n You can create/modify an index for a table with after data is already in the table (after and operation). Creating a table index is highly encouraged. This will speed your queries a great deal when you use a with the indexed dimension as the . Indexes are automagically created on the indexables and any data columns you specify. This behavior can be turned off by passing to . # we have automagically already created an index (in the first section) # change an index by passing new parameters Oftentimes when appending large amounts of data to a store, it is useful to turn off index creation for each append, then recreate at the end. Then create the index when finished appending. See here for how to create a completely-sorted-index (CSI) on an existing store. You can designate (and index) certain columns that you want to be able to perform queries (other than the columns, which you can always query). For instance say you want to perform this common operation, on-disk, and return just the frame that matches this query. You can specify to force all columns to be . # this is in-memory version of this type of selection # we have automagically created this index and the B/C/string/string2 There is some performance degradation by making lots of columns into , so it is up to the user to designate these. In addition, you cannot change data columns (nor indexables) after the first append/put operation (Of course you can simply read in the data and create a new table!). You can pass or to and to return an iterator on the results. The default is 50,000 rows returned in a chunk. You can also use the iterator with which will open, then automatically close the store when finished iterating. Note, that the chunksize keyword applies to the source rows. So if you are doing a query, then the chunksize will subdivide the total rows in the table and the query applied, returning an iterator on potentially unequal sized chunks. Here is a recipe for generating a query and using it to create equal sized return chunks. To retrieve a single indexable or data column, use the method . This will, for example, enable you to get the index very quickly. These return a of the result, indexed by the row number. These do not currently accept the selector. Sometimes you want to get the coordinates (a.k.a the index locations) of your query. This returns an of the resulting locations. These coordinates can also be passed to subsequent operations. Sometime your query can involve creating a list of rows to select. Usually this would be a resulting from an indexing operation. This example selects the months of a datetimeindex which are 5. If you want to inspect the stored object, retrieve via . You could use this programmatically to say get the number of rows in an object. The methods and can perform appending/selecting from multiple tables at once. The idea is to have one table (call it the selector table) that you index most/all of the columns, and perform your queries. The other table(s) are data tables with an index matching the selector table’s index. You can then perform a very fast query on the selector table, yet get lots of data back. This method is similar to having a very wide table, but enables more efficient queries. The method splits a given single DataFrame into multiple tables according to , a dictionary that maps the table names to a list of ‘columns’ you want in that table. If is used in place of a list, that table will have the remaining unspecified columns of the given DataFrame. The argument defines which table is the selector table (which you can make queries from). The argument will drop rows from the input to ensure tables are synchronized. This means that if a row for one of the tables being written to is entirely , that row will be dropped from all tables. If is False, THE USER IS RESPONSIBLE FOR SYNCHRONIZING THE TABLES. Remember that entirely rows are not written to the HDFStore, so if you choose to call , some tables may have more rows than others, and therefore may not work or it may return unexpected results. # you can also create the tables individually You can delete from a table selectively by specifying a . In deleting rows, it is important to understand the deletes rows by erasing the rows, then moving the following data. Thus deleting can potentially be a very expensive operation depending on the orientation of your data. To get optimal performance, it’s worthwhile to have the dimension you are deleting be the first of the . Data is ordered (on the disk) in terms of the . Here’s a simple use case. You store panel-type data, with dates in the and ids in the . The data is then interleaved like this: It should be clear that a delete operation on the will be fairly quick, as one chunk is removed, then the following data moved. On the other hand a delete operation on the will be very expensive. In this case it would almost certainly be faster to rewrite the table using a that selects all but the missing data. Please note that HDF5 DOES NOT RECLAIM SPACE in the h5 files automatically. Thus, repeatedly deleting (or removing nodes) and adding again, WILL TEND TO INCREASE THE FILE SIZE. To the file, use . allows the stored data to be compressed. This applies to all kinds of stores, not just tables. Two parameters are used to control compression: and .\n• None specifies if and how hard data is to be compressed. and disables compression and enables compression.\n• None specifies which compression library to use. If nothing is specified the default library is used. A compression library usually optimizes for either good compression rates or speed and the results will depend on the type of data. Which type of compression to choose depends on your specific needs and data. The list of supported compression libraries:\n• None zlib: The default compression library. A classic in terms of compression, achieves good compression rates but is somewhat slow.\n• \n• None blosc:blosclz This is the default compressor for\n• None blosc:lz4hc: A tweaked version of LZ4, produces better compression ratios at the expense of speed.\n• None blosc:snappy: A popular compressor used in many places.\n• None blosc:zlib: A classic; somewhat slower than the previous ones, but achieving better compression ratios.\n• None blosc:zstd: An extremely well balanced codec; it provides the best compression ratios among the others above, and at reasonably fast speed. If is defined as something other than the listed libraries a exception is issued. If the library specified with the option is missing on your platform, compression defaults to without further ado. Enable compression for all objects within the file: Or on-the-fly compression (this only applies to tables) in stores where compression is not enabled: offers better write performance when tables are compressed after they are written, as opposed to turning on compression at the very beginning. You can use the supplied utility . In addition, can change compression levels after the fact. Furthermore will the file to allow you to reuse previously deleted space. Alternatively, one can simply remove the file and write again, or use the method. is not-threadsafe for writing. The underlying only supports concurrent reads (via threading or processes). If you need reading and writing at the same time , you need to serialize these operations in a single thread in a single process. You will corrupt your data otherwise. See the (GH 2397) for more information.\n• None If you use locks to manage write access between multiple processes, you may want to use before releasing write locks. For convenience you can use to do this for you.\n• None Once a is created columns (DataFrame) are fixed; only exactly the same columns can be appended\n• None Be aware that timezones (e.g., ) are not necessarily equal across timezone versions. So if data is localized to a specific timezone in the HDFStore using one version of a timezone library and that data is updated with another version, the data will be converted to UTC since these timezones are not considered equal. Either use the same version of timezone library or use with the updated timezone definition. will show a if a column name cannot be used as an attribute selector. identifiers contain only letters, numbers, and underscores, and may not begin with a number. Other identifiers cannot be used in a clause and are generally a bad idea. will map an object dtype to the underlying dtype. This means the following types are known to work: categorical : see the section below columns are not supported, and WILL FAIL. You can write data that contains dtypes to a . Queries work the same as if it was an object array. However, the dtyped data is stored in a more efficient manner. The underlying implementation of uses a fixed column width (itemsize) for string columns. A string column itemsize is calculated as the maximum of the length of data (for that column) that is passed to the , in the first append. Subsequent appends, may introduce a string for a column larger than the column can hold, an Exception will be raised (otherwise you could have a silent truncation of these columns, leading to loss of information). In the future we may relax this and allow a user-specified truncation to occur. Pass on the first table creation to a-priori specify the minimum length of a particular string column. can be an integer, or a dict mapping a column name to an integer. You can pass as a key to allow all or to have this min_itemsize. Passing a dict will cause all passed columns to be created as automatically. If you are not passing any , then the will be the maximum of the length of any string passed # A and B have a size of 30 # A is created as a data_column with a size of 30 String columns will serialize a (a missing value) with the string representation. This defaults to the string value . You could inadvertently turn an actual value into a missing value. # here you need to specify a different nan rep\n• None format come with a writing performance penalty as compared to stores. The benefit is the ability to append/delete and query (potentially very large amounts of data). Write times are generally longer as compared with regular stores. Query times can be quite fast, especially on an indexed axis.\n• None You can pass to , specifying the write chunksize (default is 50000). This will significantly lower your memory usage on writing.\n• None You can pass to the first , to set the TOTAL number of rows that will expect. This will optimize read/write performance.\n• None Duplicate rows can be written to tables, but are filtered out in selection (with the last items being selected; thus a table is unique on major, minor pairs)\n• None A will be raised if you are attempting to store types that will be pickled by PyTables (rather than stored as endemic types). See Here for more information and some solutions.\n\nThe module provides a collection of query wrappers to both facilitate data retrieval and to reduce dependency on DB-specific API. Where available, users may first want to opt for Apache Arrow ADBC drivers. These drivers should provide the best performance, null handling, and type detection. For a full list of ADBC drivers and their development status, see the ADBC Driver Implementation Status documentation. Where an ADBC driver is not available or may be missing functionality, users should opt for installing SQLAlchemy alongside their database driver library. Examples of such drivers are psycopg2 for PostgreSQL or pymysql for MySQL. For SQLite this is included in Python’s standard library by default. You can find an overview of supported drivers for each SQL dialect in the SQLAlchemy docs. If SQLAlchemy is not installed, you can use a in place of a SQLAlchemy engine, connection, or URI string. See also some for some advanced strategies. The function is a convenience wrapper around and (and for backward compatibility) and will delegate to specific function depending on the provided input (database table name or sql query). Table names do not need to be quoted if they have special characters. In the following example, we use the SQlite SQL database engine. You can use a temporary SQLite database where data are stored in “memory”. To connect using an ADBC driver you will want to install the using your package manager. Once installed, you can use the DBAPI interface provided by the ADBC driver to connect to your database. To connect with SQLAlchemy you use the function to create an engine object from database URI. You only need to create the engine once per database you are connecting to. For more information on and the URI formatting, see the examples below and the SQLAlchemy documentation If you want to manage your own connections you can pass one of those instead. The example below opens a connection to the database using a Python context manager that automatically closes the connection after the block has completed. See the SQLAlchemy docs for an explanation of how the database connection is handled. When you open a connection to a database you are also responsible for closing it. Side effects of leaving a connection open may include locking the database or other breaking behaviour. Assuming the following data is in a , we can insert it into the database using . With some databases, writing large DataFrames can result in errors due to packet size limitations being exceeded. This can be avoided by setting the parameter when calling . For example, the following writes to the database in batches of 1000 rows at a time: Ensuring consistent data type management across SQL databases is challenging. Not every SQL database offers the same types, and even when they do the implementation of a given type can vary in ways that have subtle effects on how types can be preserved. For the best odds at preserving database types users are advised to use ADBC drivers when available. The Arrow type system offers a wider array of types that more closely match database types than the historical pandas/NumPy type system. To illustrate, note this (non-exhaustive) listing of types available in different databases and pandas backends: Not implemented as of writing, but theoretically possible If you are interested in preserving database types as best as possible throughout the lifecycle of your DataFrame, users are encouraged to leverage the argument of This will prevent your data from being converted to the traditional pandas/NumPy type system, which often converts SQL types in ways that make them impossible to round-trip. In case an ADBC driver is not available, will try to map your data to an appropriate SQL data type based on the dtype of the data. When you have columns of dtype , pandas will try to infer the data type. You can always override the default type by specifying the desired SQL type of any of the columns by using the argument. This argument needs a dictionary mapping column names to SQLAlchemy types (or strings for the sqlite3 fallback mode). For example, specifying to use the sqlalchemy type instead of the default type for string columns: Due to the limited support for timedelta’s in the different database flavors, columns with type will be written as integer values as nanoseconds to the database and a warning will be raised. The only exception to this is when using the ADBC PostgreSQL driver in which case a timedelta will be written to the database as an Columns of dtype will be converted to the dense representation as you would get with (e.g. for string categories this gives an array of strings). Because of this, reading the database table back in does not generate a categorical. Using ADBC or SQLAlchemy, is capable of writing datetime data that is timezone naive or timezone aware. However, the resulting data stored in the database ultimately depends on the supported data type for datetime data of the database system being used. The following table lists supported data types for datetime data for some common databases. Other database dialects may have different data types for datetime data. When writing timezone aware data to databases that do not support timezones, the data will be written as timezone naive timestamps that are in local time with respect to the timezone. is also capable of reading datetime data that is timezone aware or naive. When reading types, pandas will convert the data to UTC. The parameter controls the SQL insertion clause used. Possible values are:\n• None : Uses standard SQL clause (one per row).\n• None : Pass multiple values in a single clause. It uses a SQL syntax not supported by all backends. This usually provides better performance for analytic databases like and , but has worse performance for traditional SQL backend if the table contains many columns. For more information check the SQLAlchemy documentation.\n• None callable with signature : This can be used to implement a more performant insertion method based on specific backend dialect features. Example of a callable using PostgreSQL COPY clause: # Alternative to_sql() *method* for DBs that support COPY FROM data_iter : Iterable that iterates the values to be inserted # gets a DBAPI connection that can provide a cursor will read a database table given the table name and optionally a subset of columns to read. In order to use , you must have the ADBC driver or SQLAlchemy optional dependency installed. ADBC drivers will map database types directly back to arrow types. For other drivers note that pandas infers column dtypes from query outputs, and not by looking up data types in the physical database schema. For example, assume is an integer column in a table. Then, intuitively, will return integer-valued series, while will return object-valued (str) series. Accordingly, if the query output is empty, then all resulting columns will be returned as object-valued (since they are most general). If you foresee that your query will sometimes generate an empty result, you may want to explicitly typecast afterwards to ensure dtype integrity. You can also specify the name of the column as the index, and specify a subset of columns to be read. And you can explicitly force columns to be parsed as dates: If needed you can explicitly specify a format string, or a dict of arguments to pass to : You can check if a table exists using Reading from and writing to different schema’s is supported through the keyword in the and functions. Note however that this depends on the database flavor (sqlite does not have schema’s). For example: You can query using raw SQL in the function. In this case you must use the SQL variant appropriate for your database. When using SQLAlchemy, you can also pass SQLAlchemy Expression language constructs, which are database-agnostic. Of course, you can specify a more “complex” query. The function supports a argument. Specifying this will return an iterator through chunks of the query result: To connect with SQLAlchemy you use the function to create an engine object from database URI. You only need to create the engine once per database you are connecting to. For more information see the examples the SQLAlchemy documentation You can use SQLAlchemy constructs to describe your query. Use to specify query parameters in a backend-neutral way If you have an SQLAlchemy description of your database you can express where conditions using SQLAlchemy expressions You can combine SQLAlchemy expressions with parameters passed to using The use of sqlite is supported without using SQLAlchemy. This mode requires a Python database adapter which respect the Python DB-API. You can create connections like so: And then issue the following queries:"
    },
    {
        "link": "https://pandas.pydata.org/pandas-docs/version/1.3.0/reference/api/pandas.read_csv.html",
        "document": "Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, gs, and file. For file URLs, a host is expected. A local file could be: file://localhost/path/to/table.csv. If you want to pass in a path object, pandas accepts any . By file-like object, we refer to objects with a method, such as a file handle (e.g. via builtin function) or .\n\nRow number(s) to use as the column names, and the start of the data. Default behavior is to infer the column names: if no names are passed the behavior is identical to and column names are inferred from the first line of the file, if column names are passed explicitly then the behavior is identical to . Explicitly pass to be able to replace existing names. The header can be a list of integers that specify row locations for a multi-index on the columns e.g. [0,1,3]. Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if , so denotes the first line of data rather than the first line of the file.\n\nColumn(s) to use as the row labels of the , either given as string name or column index. If a sequence of int / str is given, a MultiIndex is used. Note: can be used to force pandas to not use the first column as the index, e.g. when you have a malformed file with delimiters at the end of each line.\n\nReturn a subset of the columns. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in or inferred from the document header row(s). For example, a valid list-like parameter would be or . Element order is ignored, so is the same as . To instantiate a DataFrame from with element order preserved use for columns in order or for order. If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True. An example of a valid callable argument would be . Using this parameter results in much faster parsing time and lower memory usage.\n\nWhether or not to include the default NaN values when parsing the data. Depending on whether is passed in, the behavior is as follows:\n• None If is True, and are specified, is appended to the default NaN values used for parsing.\n• None If is True, and are not specified, only the default NaN values are used for parsing.\n• None If is False, and are specified, only the NaN values specified are used for parsing.\n• None If is False, and are not specified, no strings will be parsed as NaN. Note that if is passed in as False, the and parameters will be ignored.\n\nFunction to use for converting a sequence of string columns to an array of datetime instances. The default uses to do the conversion. Pandas will try to call in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by ) as arguments; 2) concatenate (row-wise) the string values from the columns defined by into a single array and pass that; and 3) call once for each row using one or more strings (corresponding to the columns defined by ) as arguments."
    },
    {
        "link": "https://stackoverflow.com/questions/48376580/how-to-read-data-in-google-colab-from-my-google-drive",
        "document": "I have some data on gDrive, for example at . Also I have a simple notebook in gColab. So, I would like to do something like: Unfortunately, all examples (like this - https://colab.research.google.com/notebook#fileId=/v2/external/notebooks/io.ipynb, for example) suggests to only mainly load all necessary data to notebook. But, if I have a lot of pieces of data, it can be quite complicated. How to solve this issue?"
    },
    {
        "link": "https://medium.com/@wl8380/how-to-mount-google-drive-in-google-colab-c688ec8eccb7",
        "document": "Google Colab is a fantastic tool for data scientists and machine learning enthusiasts. It’s a free Jupyter notebook environment that runs entirely in the cloud, and it allows you to write and execute code in Python. One of the powerful features of Google Colab is its seamless integration with Google Drive, which lets you easily access and save files to your Drive.\n\nIn this article, I’ll walk you through the simple steps to mount your Google Drive in Google Colab, so you can effortlessly use your Drive files in your projects.\n\nMounting Google Drive in Google Colab allows you to:\n\n- Access large datasets stored in Google Drive without needing to upload them every time.\n\n- Save your work directly to Google Drive for easy access and sharing.\n\n- Load pre-trained models and other assets directly from Google Drive.\n\nThe first step is to import the `drive` module from the `google.colab` package. This module provides functions to interact with Google Drive.\n\nNext, use the `mount` function to mount your Google Drive. The `mount` function requires the path where you want to mount the drive, which is usually `/content/drive`.\n\nWhen you run the above code, you will see a prompt with a link to obtain an authorization code. Follow these steps:\n\n1. Click on the URL provided in the output.\n\n2. Select the Google account you want to use.\n\n3. Allow Google Colab to access your Google Drive.\n\nAfter mounting the drive, you can access your Google Drive files as if they were on your local file system. For example, to list the files in your Drive, you can use the `ls` command:\n\nHere is a complete example of how to mount Google Drive and list its contents:\n\nOnce you’ve mounted your Google Drive in Google Colab, you can easily read CSV files using the `pandas` library. Below is a step-by-step guide and a complete example.\n\n1. Mount Google Drive: Follow the steps to mount your Google Drive as described earlier.\n\n2. Locate the CSV File: Ensure you know the path to your CSV file in Google Drive.\n\n3. Read the CSV File: Use `pandas` to read the CSV file.\n\n3. Read the CSV file: Assume the CSV file is located at `My Drive/data/my_file.csv`.\n\n- Mount the Drive: This step mounts your Google Drive to `/content/drive` in your Colab environment.\n\n- Define the File Path: You need to specify the path to your CSV file in Google Drive. Adjust `file_path` according to your file’s location.\n\n- Read the CSV File: `pd.read_csv(file_path)` reads the CSV file into a pandas DataFrame. The `print(df.head())` command prints the first few rows of the DataFrame to verify that the file was read correctly.\n\nIf your CSV file looks like this:\n\nThis example demonstrates how to seamlessly access and read a CSV file stored in Google Drive using Google Colab and pandas. You can now manipulate and analyze your data using all the powerful tools provided by pandas and Python.\n\nMounting Google Drive in Google Colab is a straightforward process that greatly enhances your ability to manage data and projects. By following these simple steps, you can seamlessly integrate Google Drive into your Colab workflow, making it easier to access, share, and save your files.\n\nWhether you’re working on data science projects, machine learning models, or just want to leverage the cloud for your Python programming, Google Colab’s integration with Google Drive is a powerful feature that can save you time and effort.\n\nI hope you find this guide helpful! If you have any questions or need further assistance, feel free to leave a comment below."
    },
    {
        "link": "https://koshurai.medium.com/a-comprehensive-guide-to-connecting-google-drive-to-google-colab-e4cc9dcb239c",
        "document": "In the realm of data science and machine learning, access to vast datasets is paramount for experimentation, analysis, and model training. Google Colab, a cloud based Jupyter notebook environment, offers a powerful platform for these tasks, providing free access to GPU and TPU resources. However, one challenge many users face is seamlessly integrating their data stored on Google Drive with Colab. In this article, we present a step-by-step guide to connect Google Drive to Google Colab, enabling easy access to your files and datasets.\n\nGoogle Drive serves as a convenient and versatile storage solution for various file types, including datasets, images, videos, and documents. By connecting Google Drive to Google Colab, users can leverage the following benefits:\n• Seamless Data Access: Access files stored in Google Drive directly within your Colab notebook, eliminating the need for manual uploads or downloads.\n• Collaboration: Facilitate collaboration by sharing notebooks and datasets stored on Google Drive with team members, enabling real-time collaboration and version control.\n• Resource Utilization: Leverage Google Colab’s GPU and TPU resources for data processing and model training on datasets stored in Google Drive.\n• Open Google Colab: Navigate to https://colab.research.google.com/ and sign in with your Google account credentials.\n• Create or Open a Notebook: Start a new notebook or open an existing one stored on Google Drive or GitHub.\n• Mount Google Drive: Execute the following code cell in your Colab notebook to mount your Google Drive:\n• Authenticate Your Google Account: Click on the link displayed in the output of the code cell. Select the Google account containing your desired Google Drive files and grant permission to access your Google Drive.\n• Access Google Drive: Your Google Drive is now mounted, and you can access its contents under the directory within your Colab notebook.\n• Test Connection: Verify the connection by listing the contents of your Google Drive directory using the following command:\n\nStart Using Google Drive: You can now read, write, and manipulate files from your Google Drive directly within your Colab notebook, enabling seamless integration of your data with your code.\n\nUnmount Google Drive (Optional): To disconnect Google Drive from your Colab session, use the following command:\n\nConnecting Google Drive to Google Colab enhances the platform’s capabilities by providing easy access to your data for analysis, experimentation, and model training. By following the step-by-step guide outlined in this article, users can seamlessly integrate their Google Drive files with their Colab notebooks, unlocking new possibilities for data-driven exploration and research. Embrace the power of cloud-based collaboration and resource utilization by harnessing the synergy between Google Drive and Google Colab in your data science workflows."
    },
    {
        "link": "https://stackoverflow.com/questions/56679549/how-to-mount-google-drive-to-r-notebook-in-colab",
        "document": "I have an R notebook in colab where I want to read a file which is saved in my google drive.\n\nI only seem to find python code such as \"from google.colab import drive drive.mount('/content/drive')\" to mount the drive.\n\nHowever, is there code for R to do this or another alternative? I am really struggling and would very much appreciate the help!"
    },
    {
        "link": "https://saturncloud.io/blog/google-colab-how-to-read-data-from-my-google-drive",
        "document": "Google Colab How to read data from my Google Drive\n\nIn this blog post, we will delve into the significance of data in the development process for software engineers. Whether it is utilized for training machine learning models or testing new software, data serves as a fundamental element in any project. However, encountering challenges in accessing data is not uncommon, particularly when it is stored in a remote location such as Google Drive. The focus of this post is to investigate the process of reading data from your Google Drive using Google Colab.\n\nAs a software engineer, you are probably familiar with the importance of data in the development process. Whether it’s for training machine learning models or testing new software, data is an essential component of any project. However, accessing data can sometimes be tricky, especially when it’s stored in a remote location like Google Drive. In this blog post, we’ll explore how to read data from your Google Drive using Google Colab.\n• How to read data from Google Drive in Google Colab\n\nBefore we dive into the specifics of reading data from Google Drive, let’s take a moment to discuss what Google Colab is. Google Colab is a free, cloud-based platform for developing and running machine learning models. With Google Colab, you can write and execute Python code in a Jupyter notebook environment, without the need for any special hardware or software. Google Colab also provides access to powerful GPUs and TPUs, which can significantly speed up machine learning tasks.\n\nGoogle Drive is a popular cloud storage service that allows you to store and access files from anywhere, on any device. It’s an excellent option for storing data that you want to access from multiple locations or share with others. When working with machine learning models, you may need to access data stored in your Google Drive, such as image or text files. By reading data directly from your Google Drive, you can save time and avoid the hassle of manually transferring files between devices.\n\nHow to read data from Google Drive in Google Colab\n\nNow that we understand the importance of reading data from Google Drive let’s explore how to do it in Google Colab. Follow these simple steps:\n\nThe first step is to mount your Google Drive to your Google Colab notebook. This will allow you to access your Google Drive files directly from your notebook. To mount your Google Drive, run the following code snippet in a code cell:\n\nThis code will prompt you to authorize Google Colab to access your Google Drive. Follow the prompts to complete the authorization process.\n\nStep 2: Navigate to the file you want to read\n\nOnce you have mounted your Google Drive, you can navigate to the file you want to read. Google Colab provides a file browser that you can use to navigate your Google Drive. To open the file browser, run the following code snippet in a code cell:\n\nThis code will list the contents of your Google Drive’s root directory. You can replace with the path to the directory containing your file.\n\nStep 3: Read the file into your notebook\n\nNow that you have navigated to the file you want to read, you can read it into your notebook. The method you use to read the file will depend on the type of file you are working with. Here are a few examples:\n\nTo read a text file, you can use the built-in function in Python. For example, to read a file named located in the root directory of your Google Drive, run the following code:\n\nTo read a CSV file, you can use the library. For example, to read a file named located in a directory named in your Google Drive, run the following code:\n\nTo read an image file, you can use the library. For example, to read an image file named located in the root directory of your Google Drive, run the following code:\n\nWhile working with Google Colab and Google Drive, you may encounter some common errors. Here are a few troubleshooting tips:\n\nIf you encounter authorization errors when attempting to mount your Google Drive, ensure that you are following the prompts correctly. Make sure to click on the provided link, grant the necessary permissions, and copy the authorization code back to the notebook.\n\nIf you’re getting a “File not found” error when trying to access a file, double-check the file path. Ensure that the path is correct, including the folder structure and file name.\n\nEnsure that you have the correct versions of libraries installed. Google Colab and associated libraries may receive updates, and using outdated versions can lead to compatibility issues.\n\nIn some cases, you may encounter disk space issues, especially if you are working with large files. Monitor your available disk space and consider clearing unnecessary files or using alternative storage solutions.\n\nIn this blog post, we explored how to read data from your Google Drive using Google Colab. By following the simple steps outlined above, you can easily access and read data stored in your Google Drive directly from your Google Colab notebook. This can save you time and streamline your workflow, especially when working with machine learning models. Happy coding!\n\nSaturn Cloud is your all-in-one solution for data science & ML development, deployment, and data pipelines in the cloud. Spin up a notebook with 4TB of RAM, add a GPU, connect to a distributed cluster of workers, and more. Request a demo today to learn more."
    }
]