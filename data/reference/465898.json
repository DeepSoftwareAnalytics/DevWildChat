[
    {
        "link": "https://learn.microsoft.com/en-us/ef/core/change-tracking/relationship-changes",
        "document": "Relationships in an Entity Framework Core (EF Core) model are represented using foreign keys (FKs). An FK consists of one or more properties on the dependent or child entity in the relationship. This dependent/child entity is associated with a given principal/parent entity when the values of the foreign key properties on the dependent/child match the values of the alternate or primary key (PK) properties on the principal/parent.\n\nForeign keys are a good way to store and manipulate relationships in the database, but are not very friendly when working with multiple related entities in application code. Therefore, most EF Core models also layer \"navigations\" over the FK representation. Navigations form C#/.NET references between entity instances that reflect the associations found by matching foreign key values to primary or alternate key values.\n\nNavigations can be used on both sides of the relationship, on one side only, or not at all, leaving only the FK property. The FK property can be hidden by making it a shadow property. See Relationships for more information on modelling relationships.\n\nThe following model contains four entity types with relationships between them. The comments in the code indicate which properties are foreign keys, primary keys, and navigations.\n\nThe three relationships in this model are:\n• Each blog can have many posts (one-to-many):\n• is the dependent/child. It contains the FK property , the value of which must match the PK value of the related blog.\n• is a reference navigation from a post to the associated blog. is the inverse navigation for .\n• is a collection navigation from a blog to all the associated posts. is the inverse navigation for .\n• Each blog can have one assets (one-to-one):\n• is the dependent/child. It contains the FK property , the value of which must match the PK value of the related blog.\n• is a reference navigation from the assets to the associated blog. is the inverse navigation for .\n• is a reference navigation from the blog to the associated assets. is the inverse navigation for .\n• Each post can have many tags and each tag can have many posts (many-to-many):\n• Many-to-many relationships are a further layer over two one-to-many relationships. Many-to-many relationships are covered later in this document.\n• is a collection navigation from a post to all the associated tags. is the inverse navigation for .\n• is a collection navigation from a tag to all the associated posts. is the inverse navigation for .\n\nSee Relationships for more information on how to model and configure relationships.\n\nEF Core keeps navigations in alignment with foreign key values and vice versa. That is, if a foreign key value changes such that it now refers to a different principal/parent entity, then the navigations are updated to reflect this change. Likewise, if a navigation is changed, then the foreign key values of the entities involved are updated to reflect this change. This is called \"relationship fixup\".\n\nFixup first occurs when entities are queried from the database. The database has only foreign key values, so when EF Core creates an entity instance from the database it uses the foreign key values to set reference navigations and add entities to collection navigations as appropriate. For example, consider a query for blogs and its associated posts and assets:\n\nFor each blog, EF Core will first create a instance. Then, as each post is loaded from the database its reference navigation is set to point to the associated blog. Likewise, the post is added to the collection navigation. The same thing happens with , except in this case both navigations are references. The navigation is set to point to the assets instance, and the navigation is set to point to the blog instance.\n\nLooking at the change tracker debug view after this query shows two blogs, each with one assets and two posts being tracked:\n\nThe debug view shows both key values and navigations. Navigations are shown using the primary key values of the related entities. For example, in the output above indicates that the collection navigation contains two related posts with primary keys 1 and 2 respectively. Similarly, for each post associated with the first blog, the line indicates that the navigation references the Blog with primary key 1.\n\nRelationship fixup also happens between entities returned from a tracking query and entities already tracked by the DbContext. For example, consider executing three separate queries for blogs, posts, and assets:\n\nLooking again at the debug views, after the first query only the two blogs are tracked:\n\nThe reference navigations are null, and the collection navigations are empty because no associated entities are currently being tracked by the context.\n\nAfter the second query, the reference navigations have been fixed up to point to the newly tracked instances. Likewise, the reference navigations are set to point to the appropriate already tracked instance.\n\nFinally, after the third query, the collection navigations now contain all related posts, and the references point to the appropriate instance:\n\nThis is the same end-state as was achieved with the original single query, since EF Core fixed up navigations as entities were tracked, even when coming from multiple different queries.\n\nThe easiest way to change the relationship between two entities is by manipulating a navigation, while leaving EF Core to fixup the inverse navigation and FK values appropriately. This can be done by:\n• Adding or removing an entity from a collection navigation.\n• Changing a reference navigation to point to a different entity, or setting it to null.\n\nFor example, let's move one of the posts from the Visual Studio blog to the .NET blog. This requires first loading the blogs and posts, and then moving the post from the navigation collection on one blog to the navigation collection on the other blog:\n\nThis is the debug view printed after running the code above:\n\nThe navigation on the .NET Blog now has three posts ( ). Likewise, the navigation on the Visual Studio blog only has one post ( ). This is to be expected since the code explicitly changed these collections.\n\nMore interestingly, even though the code did not explicitly change the navigation, it has been fixed-up to point to the Visual Studio blog ( ). Also, the foreign key value has been updated to match the primary key value of the .NET blog. This change to the FK value in then persisted to the database when SaveChanges is called:\n\nIn the previous example, a post was moved from one blog to another by manipulating the collection navigation of posts on each blog. The same thing can be achieved by instead changing the reference navigation to point to the new blog. For example:\n\nThe debug view after this change is exactly the same as it was in the previous example. This is because EF Core detected the reference navigation change and then fixed up the collection navigations and FK value to match.\n\nIn the previous section, relationships were manipulated by navigations leaving foreign key values to be updated automatically. This is the recommended way to manipulate relationships in EF Core. However, it is also possible to manipulate FK values directly. For example, we can move a post from one blog to another by changing the foreign key value:\n\nNotice how this is very similar to changing the reference navigation, as shown in the previous example.\n\nThe debug view after this change is again exactly the same as was the case for the previous two examples. This is because EF Core detected the FK value change and then fixed up both the reference and collection navigations to match.\n\nEF Core performs the following actions when it detects that a new dependent/child entity has been added to a collection navigation:\n• If the entity is not tracked, then it is tracked. (The entity will usually be in the state. However, if the entity type is configured to use generated keys and the primary key value is set, then the entity is tracked in the state.)\n• If the entity is associated with a different principal/parent, then that relationship is severed.\n• The entity becomes associated with the principal/parent that owns the collection navigation.\n• Navigations and foreign key values are fixed up for all entities involved.\n\nBased on this we can see that to move a post from one blog to another we don't actually need to remove it from the old collection navigation before adding it to the new one. So the code from the example above can be changed from:\n\nEF Core sees that the post has been added to a new blog and automatically removes it from the collection on the first blog.\n\nRemoving a dependent/child entity from the collection navigation of the principal/parent causes severing of the relationship to that principal/parent. What happens next depends on whether the relationship is optional or required.\n\nBy default for optional relationships, the foreign key value is set to null. This means that the dependent/child is no longer associated with any principal/parent. For example, let's load a blog and posts and then remove one of the posts from the collection navigation:\n\nLooking at the change tracking debug view after this change shows that:\n• The FK has been set to null ( )\n• The reference navigation has been set to null ( )\n• The post has been removed from collection navigation ( )\n\nNotice that the post is not marked as . It is marked as so that the FK value in the database will be set to null when SaveChanges is called.\n\nSetting the FK value to null is not allowed (and is usually not possible) for required relationships. Therefore, severing a required relationship means that the dependent/child entity must be either re-parented to a new principal/parent, or removed from the database when SaveChanges is called to avoid a referential constraint violation. This is known as \"deleting orphans\", and is the default behavior in EF Core for required relationships.\n\nFor example, let's change the relationship between blog and posts to be required and then run the same code as in the previous example:\n\nLooking at the debug view after this change shows that:\n• The post has been marked as such that it will be deleted from the database when SaveChanges is called.\n• The reference navigation has been set to null ( ).\n• The post has been removed from collection navigation ( ).\n\nNotice that the remains unchanged since for a required relationship it cannot be set to null.\n\nCalling SaveChanges results in the orphaned post being deleted:\n\nBy default, marking orphans as happens as soon as the relationship change is detected. However, this process can be delayed until SaveChanges is actually called. This can be useful to avoid making orphans of entities that have been removed from one principal/parent, but will be re-parented with a new principal/parent before SaveChanges is called. ChangeTracker.DeleteOrphansTiming is used to set this timing. For example:\n\nAfter removing the post from the first collection the object is not marked as as it was in the previous example. Instead, EF Core is tracking that the relationship is severed even though this is a required relationship. (The FK value is considered null by EF Core even though it cannot really be null because the type is not nullable. This is known as a \"conceptual null\".)\n\nCalling SaveChanges at this time would result in the orphaned post being deleted. However, if as in the example above, post is associated with a new blog before SaveChanges is called, then it will be fixed up appropriately to that new blog and is no longer considered an orphan:\n\nSaveChanges called at this point will update the post in the database rather than deleting it.\n\nIt is also possible to turn off automatic deletion of orphans. This will result in an exception if SaveChanges is called while an orphan is being tracked. For example, this code:\n\nDeletion of orphans, as well as cascade deletes, can be forced at any time by calling ChangeTracker.CascadeChanges(). Combining this with setting the delete orphan timing to will ensure orphans are never deleted unless EF Core is explicitly instructed to do so.\n\nChanging the reference navigation of a one-to-many relationship has the same effect as changing the collection navigation on the other end of the relationship. Setting the reference navigation of dependent/child to null is equivalent to removing the entity from the collection navigation of the principal/parent. All fixup and database changes happen as described in the previous section, including making the entity an orphan if the relationship is required.\n\nFor one-to-one relationships, changing a reference navigation causes any previous relationship to be severed. For optional relationships, this means that the FK value on the previously related dependent/child is set to null. For example:\n\nThe debug view before calling SaveChanges shows that the new assets has replaced the existing assets, which is now marked as with a null FK value:\n\nThis results in an update and an insert when SaveChanges is called:\n\nRunning the same code as in the previous example, but this time with a required one-to-one relationship, shows that the previously associated is now marked as , since it becomes an orphan when the new takes its place:\n\nThis then results in a delete and an insert when SaveChanges is called:\n\nThe timing of marking orphans as deleted can be changed in the same way as shown for collection navigations and has the same effects.\n\nWhen an entity is marked as , for example by calling DbContext.Remove, then references to the deleted entity are removed from the navigations of other entities. For optional relationships, the FK values in dependent entities are set to null.\n\nFor example, let's mark the Visual Studio blog as :\n\nLooking at the change tracker debug view before calling SaveChanges shows:\n• The blog is marked as .\n• The assets related to the deleted blog has a null FK value ( ) and a null reference navigation ( )\n• Each post related to the deleted blog has a null FK value ( ) and a null reference navigation ( )\n\nThe fixup behavior for required relationships is the same as for optional relationships except that the dependent/child entities are marked as since they cannot exist without a principal/parent and must be removed from the database when SaveChanges is called to avoid a referential constraint exception. This is known as \"cascade delete\", and is the default behavior in EF Core for required relationships. For example, running the same code as in the previous example but with a required relationship results in the following debug view before SaveChanges is called:\n\nAs expected, the dependents/children are now marked as . However, notice that the navigations on the deleted entities have not changed. This may seem strange, but it avoids completely shredding a deleted graph of entities by clearing all navigations. That is, the blog, asset, and posts still form a graph of entities even after having been deleted. This makes it much easier to un-delete a graph of entities than was the case in EF6 where the graph was shredded.\n\nBy default, cascade delete happens as soon as the parent/principal is marked as . This is the same as for deleting orphans, as described previously. As with deleting orphans, this process can be delayed until SaveChanges is called, or even disabled entirely, by setting ChangeTracker.CascadeDeleteTiming appropriately. This is useful in the same way as it is for deleting orphans, including for re-parenting children/dependents after deletion of a principal/parent.\n\nCascade deletes, as well as deleting orphans, can be forced at any time by calling ChangeTracker.CascadeChanges(). Combining this with setting the cascade delete timing to will ensure cascade deletes never happen unless EF Core is explicitly instructed to do so.\n\nMany-to-many relationships in EF Core are implemented using a join entity. Each side of the many-to-many relationship is related to this join entity with a one-to-many relationship. This join entity can be explicitly defined and mapped, or it can be created implicitly and hidden. In both cases the underlying behavior is the same. We will look at this underlying behavior first to understand how tracking of many-to-many relationships works.\n\nConsider this EF Core model that creates a many-to-many relationship between posts and tags using an explicitly defined join entity type:\n\nNotice that the join entity type contains two foreign key properties. In this model, for a post to be related to a tag, there must be a PostTag join entity where the foreign key value matches the primary key value, and where the foreign key value matches the primary key value. For example:\n\nLooking at the change tracker debug view after running this code shows that the post and tag are related by the new join entity:\n\nNotice that the collection navigations on and have been fixed up, as have the reference navigations on . These relationships can be manipulated by navigations instead of FK values, just as in all the preceding examples. For example, the code above can be modified to add the relationship by setting the reference navigations on the join entity:\n\nThis results in exactly the same change to FKs and navigations as in the previous example.\n\nManipulating the join table manually can be cumbersome. Many-to-many relationships can be manipulated directly using special collection navigations that \"skip over\" the join entity. For example, two skip navigations can be added to the model above; one from Post to Tags, and the other from Tag to Posts:\n\nThis many-to-many relationship requires the following configuration to ensure the skip navigations and normal navigations are all used for the same many-to-many relationship:\n\nSee Relationships for more information on mapping many-to-many relationships.\n\nSkip navigations look and behave like normal collection navigations. However, the way they work with foreign key values is different. Let's associate a post with a tag, but this time using a skip navigation:\n\nNotice that this code doesn't use the join entity. It instead just adds an entity to a navigation collection in the same way as would be done if this were a one-to-many relationship. The resulting debug view is essentially the same as before:\n\nNotice that an instance of the join entity was created automatically with FK values set to the PK values of the tag and post that are now associated. All the normal reference and collection navigations have been fixed up to match these FK values. Also, since this model contains skip navigations, these have also been fixed up. Specifically, even though we added the tag to the skip navigation, the inverse skip navigation on the other side of this relationship has also been fixed up to contain the associated post.\n\nIt is worth noting that the underlying many-to-many relationships can still be manipulated directly even when skip navigations have been layered on top. For example, the tag and Post could be associated as we did before introducing skip navigations:\n\nThis will still result in the skip navigations being fixed up correctly, resulting in the same debug view output as in the previous example.\n\nIn the previous section we added skip navigations in addition to fully defining the two underlying one-to-many relationships. This is useful to illustrate what happens to FK values, but is often unnecessary. Instead, the many-to-many relationship can be defined using only skip navigations. This is how the many-to-many relationship is defined in the model at the very top of this document. Using this model, we can again associate a Post and a Tag by adding a post to the skip navigation (or, alternately, adding a tag to the skip navigation):\n\nLooking at the debug view after making this change reveals that EF Core has created an instance of to represent the join entity. This join entity contains both and foreign key properties which have been set to match the PK values of the post and tag that are associated.\n\nSee Relationships for more information about implicit join entities and the use of entity types.\n\nSo far all the examples have used a join entity type (whether explicit or implicit) that contains only the two foreign key properties needed for the many-to-many relationship. Neither of these FK values need to be explicitly set by the application when manipulating relationships because their values come from the primary key properties of the related entities. This allows EF Core to create instances of the join entity without missing data.\n\nEF Core supports adding additional properties to the join entity type. This is known as giving the join entity a \"payload\". For example, let's add property to the join entity:\n\nThis payload property will not be set when EF Core creates a join entity instance. The most common way to deal with this is to use payload properties with automatically generated values. For example, the property can be configured to use a store-generated timestamp when each new entity is inserted:\n\nA post can now be tagged in the same way as before:\n\nLooking at the change tracker debug view after calling SaveChanges shows that the payload property has been set appropriately:\n\nFollowing on from the previous example, let's add a payload property that does not use an automatically generated value:\n\nA post can now be tagged in the same way as before, and the join entity will still be created automatically. This entity can then be accessed using one of the mechanisms described in Accessing Tracked Entities. For example, the code below uses DbSet<TEntity>.Find to access the join entity instance:\n\nOnce the join entity has been located it can be manipulated in the normal way--in this example, to set the payload property before calling SaveChanges.\n\nAlternately, the join entity can be created explicitly to associate a post with a tag. For example:\n\nFinally, another way to set payload data is by either overriding SaveChanges or using the DbContext.SavingChanges event to process entities before updating the database. For example:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/ef/core/modeling/relationships",
        "document": "This document provides a simple introduction to the representation of relationships in object models and relational databases, including how EF Core maps between the two.\n\nA relationship defines how two entities relate to each other. For example, when modeling posts in a blog, each post is related to the blog it is published on, and the blog is related to all the posts published on that blog.\n\nIn an object-oriented language like C#, the blog and post are typically represented by two classes: and . For example:\n\nIn the classes above, there is nothing to indicate that and are related. This can be added to the object model by adding a reference from to the on which it is published:\n\nLikewise, the opposite direction of the same relationship can be represented as a collection of objects on each :\n\nThis connection from to and, inversely, from back to is known as a \"relationship\" in EF Core.\n\nRelational databases represent relationships using foreign keys. For example, using SQL Server or Azure SQL, the following tables can be used to represent our and classes:\n\nIn this relational model, the and tables are each given a \"primary key\" column. The value of the primary key uniquely identifies each post or blog. In addition, the table is given a \"foreign key\" column. The primary key column is referenced by the foreign key column of the table. This column is \"constrained\" such that any value in the column of must match a value in the column of . This match determines which blog every post is related to. For example, if the value in one row of the table is 7, then the post represented by that row is published in the blog with the primary key 7.\n\nEF Core relationship mapping is all about mapping the primary key/foreign key representation used in a relational database to the references between objects used in an object model.\n\nIn the most basic sense, this involves:\n• Associating the references between entity types with the primary and foreign keys to form a single relationship configuration.\n\nOnce this mapping is made, EF changes the foreign key values as needed when the references between objects change, and changes the references between objects as needed when the foreign key values change.\n\nFor example, the entity types shown above can be updated with primary and foreign key properties:\n\nThe primary key property of , , and the foreign key property of , , can then be associated with the references (\"navigations\") between the entity types ( and ). This is done automatically by EF when building a simple relationship like this, but can also be specified explicitly when overriding the method of your . For example:\n\nNow all these properties will behave coherently together as a representation of a single relationship between and .\n\nEF supports many different types of relationships, with many different ways these relationships can be represented and configured. To jump into examples for different kinds of relationships, see:\n• One-to-many relationships, in which a single entity is associated with any number of other entities.\n• One-to-one relationships, in which a single entity is associated with another single entity.\n• Many-to-many relationships, in which any number of entities are associated with any number of other entities.\n\nIf you are new to EF, then trying the examples linked in in the bullet points above is a good way to get a feel for how relationships work.\n\nTo dig deeper into the properties of entity types involved in relationship mapping, see:\n• Foreign and principal keys in relationships, which covers how foreign keys map to the database.\n• Relationship navigations, which describes how navigations are layered over a foreign key to provide an object-oriented view of the relationship.\n\nEF models are built using a combination of three mechanisms: conventions, mapping attributes, and the model builder API. Most of the examples show the model building API. To find out more about other options, see:\n• Relationship conventions, which discover entity types, their properties, and the relationships between the types.\n• Relationship mapping attributes, which can be used an alternative to the model building API for some aspects of relationship configuration.\n• Cascade deletes, which describe how related entities can be automatically deleted when or is called.\n• Owned entity types use a special type of \"owning\" relationship that implies a stronger connection between the two types than the \"normal\" relationships discussed here. Many of the concepts described here for normal relationships are carried over to owned relationships. However, owned relationships also have their own special behaviors.\n\nRelationships defined in the model can be used in various ways. For example:\n• Relationships can be used to query related data in any of three ways:\n• Eagerly as part of a LINQ query, using .\n• Lazily using lazy-loading proxies, or lazy-loading without proxies.\n• Explicitly using the or methods.\n• Relationships can be used in data seeding through matching of PK values to FK values.\n• Relationships can be used to track graphs of entities. Relationships are then used by the change tracker to:\n• Detect changes in relationships and perform fixup\n• Send foreign key updates to the database with or"
    },
    {
        "link": "https://stackoverflow.com/questions/51311008/entity-framework-core-assign-foreign-key-constraint-in-onmodelcreating",
        "document": "I'm trying to figure out how to programmatically generate my database using Entity Framework Core and I'm running into issues assigning a foreign key to a field in a table. I need the field Address to reference the Address object and load it when I go to retrieve a record from the database. If I create the database using , it creates the tables correctly except that the field AddressId is not a foreign key to the Address table. I have tried doing my research on this, and ran into this article, which uses a method called , however whatever is returning from Entity() doesn't know about . I get this error if I try manually typing it in I get:\n\nSo obviously that approach isn't valid. I tried following this documentation, but I don't really understand what it is doing and how to apply it to my situation. In their case they have a couple tables, blog and posts, where blog has many posts and post has a blog. I tried following along the best I could, but I don't really understand all the jargon and what it is accomplishing.\n\nHow can I go about simply assigning the value found in AddressId as a foreign key to a record in Addresses? This is the code I am using.\n• I am using the Microsoft.EntityFrameworkCore.SQLite & SQLite.Core libraries for my provider."
    },
    {
        "link": "https://github.com/dotnet/EntityFramework.Docs/blob/main/entity-framework/core/change-tracking/relationship-changes.md",
        "document": "Relationships in an Entity Framework Core (EF Core) model are represented using foreign keys (FKs). An FK consists of one or more properties on the dependent or child entity in the relationship. This dependent/child entity is associated with a given principal/parent entity when the values of the foreign key properties on the dependent/child match the values of the alternate or primary key (PK) properties on the principal/parent.\n\nForeign keys are a good way to store and manipulate relationships in the database, but are not very friendly when working with multiple related entities in application code. Therefore, most EF Core models also layer \"navigations\" over the FK representation. Navigations form C#/.NET references between entity instances that reflect the associations found by matching foreign key values to primary or alternate key values.\n\nNavigations can be used on both sides of the relationship, on one side only, or not at all, leaving only the FK property. The FK property can be hidden by making it a shadow property. See Relationships for more information on modelling relationships.\n\nThe following model contains four entity types with relationships between them. The comments in the code indicate which properties are foreign keys, primary keys, and navigations.\n\nThe three relationships in this model are:\n• Each blog can have many posts (one-to-many):\n• is the dependent/child. It contains the FK property , the value of which must match the PK value of the related blog.\n• is a reference navigation from a post to the associated blog. is the inverse navigation for .\n• is a collection navigation from a blog to all the associated posts. is the inverse navigation for .\n• Each blog can have one assets (one-to-one):\n• is the dependent/child. It contains the FK property , the value of which must match the PK value of the related blog.\n• is a reference navigation from the assets to the associated blog. is the inverse navigation for .\n• is a reference navigation from the blog to the associated assets. is the inverse navigation for .\n• Each post can have many tags and each tag can have many posts (many-to-many):\n• Many-to-many relationships are a further layer over two one-to-many relationships. Many-to-many relationships are covered later in this document.\n• is a collection navigation from a post to all the associated tags. is the inverse navigation for .\n• is a collection navigation from a tag to all the associated posts. is the inverse navigation for .\n\nSee Relationships for more information on how to model and configure relationships.\n\nEF Core keeps navigations in alignment with foreign key values and vice versa. That is, if a foreign key value changes such that it now refers to a different principal/parent entity, then the navigations are updated to reflect this change. Likewise, if a navigation is changed, then the foreign key values of the entities involved are updated to reflect this change. This is called \"relationship fixup\".\n\nFixup first occurs when entities are queried from the database. The database has only foreign key values, so when EF Core creates an entity instance from the database it uses the foreign key values to set reference navigations and add entities to collection navigations as appropriate. For example, consider a query for blogs and its associated posts and assets:\n\nFor each blog, EF Core will first create a instance. Then, as each post is loaded from the database its reference navigation is set to point to the associated blog. Likewise, the post is added to the collection navigation. The same thing happens with , except in this case both navigations are references. The navigation is set to point to the assets instance, and the navigation is set to point to the blog instance.\n\nLooking at the change tracker debug view after this query shows two blogs, each with one assets and two posts being tracked:\n\nThe debug view shows both key values and navigations. Navigations are shown using the primary key values of the related entities. For example, in the output above indicates that the collection navigation contains two related posts with primary keys 1 and 2 respectively. Similarly, for each post associated with the first blog, the line indicates that the navigation references the Blog with primary key 1.\n\nRelationship fixup also happens between entities returned from a tracking query and entities already tracked by the DbContext. For example, consider executing three separate queries for blogs, posts, and assets:\n\n[!code-csharpRelationship_fixup_2] Looking again at the debug views, after the first query only the two blogs are tracked:\n\nThe reference navigations are null, and the collection navigations are empty because no associated entities are currently being tracked by the context.\n\nAfter the second query, the reference navigations have been fixed up to point to the newly tracked instances. Likewise, the reference navigations are set to point to the appropriate already tracked instance.\n\nFinally, after the third query, the collection navigations now contain all related posts, and the references point to the appropriate instance:\n\nThis is the same end-state as was achieved with the original single query, since EF Core fixed up navigations as entities were tracked, even when coming from multiple different queries.\n\nThe easiest way to change the relationship between two entities is by manipulating a navigation, while leaving EF Core to fixup the inverse navigation and FK values appropriately. This can be done by:\n• Adding or removing an entity from a collection navigation.\n• Changing a reference navigation to point to a different entity, or setting it to null.\n\nFor example, let's move one of the posts from the Visual Studio blog to the .NET blog. This requires first loading the blogs and posts, and then moving the post from the navigation collection on one blog to the navigation collection on the other blog:\n\nThis is the debug view printed after running the code above:\n\nThe navigation on the .NET Blog now has three posts ( ). Likewise, the navigation on the Visual Studio blog only has one post ( ). This is to be expected since the code explicitly changed these collections.\n\nMore interestingly, even though the code did not explicitly change the navigation, it has been fixed-up to point to the Visual Studio blog ( ). Also, the foreign key value has been updated to match the primary key value of the .NET blog. This change to the FK value in then persisted to the database when SaveChanges is called:\n\nIn the previous example, a post was moved from one blog to another by manipulating the collection navigation of posts on each blog. The same thing can be achieved by instead changing the reference navigation to point to the new blog. For example:\n\nThe debug view after this change is exactly the same as it was in the previous example. This is because EF Core detected the reference navigation change and then fixed up the collection navigations and FK value to match.\n\nIn the previous section, relationships were manipulated by navigations leaving foreign key values to be updated automatically. This is the recommended way to manipulate relationships in EF Core. However, it is also possible to manipulate FK values directly. For example, we can move a post from one blog to another by changing the foreign key value:\n\nNotice how this is very similar to changing the reference navigation, as shown in the previous example.\n\nThe debug view after this change is again exactly the same as was the case for the previous two examples. This is because EF Core detected the FK value change and then fixed up both the reference and collection navigations to match.\n\nEF Core performs the following actions when it detects that a new dependent/child entity has been added to a collection navigation:\n• If the entity is not tracked, then it is tracked. (The entity will usually be in the state. However, if the entity type is configured to use generated keys and the primary key value is set, then the entity is tracked in the state.)\n• If the entity is associated with a different principal/parent, then that relationship is severed.\n• The entity becomes associated with the principal/parent that owns the collection navigation.\n• Navigations and foreign key values are fixed up for all entities involved.\n\nBased on this we can see that to move a post from one blog to another we don't actually need to remove it from the old collection navigation before adding it to the new one. So the code from the example above can be changed from:\n\nEF Core sees that the post has been added to a new blog and automatically removes it from the collection on the first blog.\n\nRemoving a dependent/child entity from the collection navigation of the principal/parent causes severing of the relationship to that principal/parent. What happens next depends on whether the relationship is optional or required.\n\nBy default for optional relationships, the foreign key value is set to null. This means that the dependent/child is no longer associated with any principal/parent. For example, let's load a blog and posts and then remove one of the posts from the collection navigation:\n\nLooking at the change tracking debug view after this change shows that:\n• The FK has been set to null ( )\n• The reference navigation has been set to null ( )\n• The post has been removed from collection navigation ( )\n\nNotice that the post is not marked as . It is marked as so that the FK value in the database will be set to null when SaveChanges is called.\n\nSetting the FK value to null is not allowed (and is usually not possible) for required relationships. Therefore, severing a required relationship means that the dependent/child entity must be either re-parented to a new principal/parent, or removed from the database when SaveChanges is called to avoid a referential constraint violation. This is known as \"deleting orphans\", and is the default behavior in EF Core for required relationships.\n\nFor example, let's change the relationship between blog and posts to be required and then run the same code as in the previous example:\n\nLooking at the debug view after this change shows that:\n• The post has been marked as such that it will be deleted from the database when SaveChanges is called.\n• The reference navigation has been set to null ( ).\n• The post has been removed from collection navigation ( ).\n\nNotice that the remains unchanged since for a required relationship it cannot be set to null.\n\nCalling SaveChanges results in the orphaned post being deleted:\n\nBy default, marking orphans as happens as soon as the relationship change is detected. However, this process can be delayed until SaveChanges is actually called. This can be useful to avoid making orphans of entities that have been removed from one principal/parent, but will be re-parented with a new principal/parent before SaveChanges is called. xref:Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker.DeleteOrphansTiming?displayProperty=nameWithType is used to set this timing. For example:\n\nAfter removing the post from the first collection the object is not marked as as it was in the previous example. Instead, EF Core is tracking that the relationship is severed even though this is a required relationship. (The FK value is considered null by EF Core even though it cannot really be null because the type is not nullable. This is known as a \"conceptual null\".)\n\nCalling SaveChanges at this time would result in the orphaned post being deleted. However, if as in the example above, post is associated with a new blog before SaveChanges is called, then it will be fixed up appropriately to that new blog and is no longer considered an orphan:\n\nSaveChanges called at this point will update the post in the database rather than deleting it.\n\nIt is also possible to turn off automatic deletion of orphans. This will result in an exception if SaveChanges is called while an orphan is being tracked. For example, this code:\n\nDeletion of orphans, as well as cascade deletes, can be forced at any time by calling xref:Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker.CascadeChanges?displayProperty=nameWithType. Combining this with setting the delete orphan timing to will ensure orphans are never deleted unless EF Core is explicitly instructed to do so.\n\nChanging the reference navigation of a one-to-many relationship has the same effect as changing the collection navigation on the other end of the relationship. Setting the reference navigation of dependent/child to null is equivalent to removing the entity from the collection navigation of the principal/parent. All fixup and database changes happen as described in the previous section, including making the entity an orphan if the relationship is required.\n\nFor one-to-one relationships, changing a reference navigation causes any previous relationship to be severed. For optional relationships, this means that the FK value on the previously related dependent/child is set to null. For example:\n\nThe debug view before calling SaveChanges shows that the new assets has replaced the existing assets, which is now marked as with a null FK value:\n\nThis results in an update and an insert when SaveChanges is called:\n\nRunning the same code as in the previous example, but this time with a required one-to-one relationship, shows that the previously associated is now marked as , since it becomes an orphan when the new takes its place:\n\nThis then results in a delete and an insert when SaveChanges is called:\n\nThe timing of marking orphans as deleted can be changed in the same way as shown for collection navigations and has the same effects.\n\nWhen an entity is marked as , for example by calling xref:Microsoft.EntityFrameworkCore.DbContext.Remove*?displayProperty=nameWithType, then references to the deleted entity are removed from the navigations of other entities. For optional relationships, the FK values in dependent entities are set to null.\n\nFor example, let's mark the Visual Studio blog as :\n\nLooking at the change tracker debug view before calling SaveChanges shows:\n• The blog is marked as .\n• The assets related to the deleted blog has a null FK value ( ) and a null reference navigation ( )\n• Each post related to the deleted blog has a null FK value ( ) and a null reference navigation ( )\n\nThe fixup behavior for required relationships is the same as for optional relationships except that the dependent/child entities are marked as since they cannot exist without a principal/parent and must be removed from the database when SaveChanges is called to avoid a referential constraint exception. This is known as \"cascade delete\", and is the default behavior in EF Core for required relationships. For example, running the same code as in the previous example but with a required relationship results in the following debug view before SaveChanges is called:\n\nAs expected, the dependents/children are now marked as . However, notice that the navigations on the deleted entities have not changed. This may seem strange, but it avoids completely shredding a deleted graph of entities by clearing all navigations. That is, the blog, asset, and posts still form a graph of entities even after having been deleted. This makes it much easier to un-delete a graph of entities than was the case in EF6 where the graph was shredded.\n\nBy default, cascade delete happens as soon as the parent/principal is marked as . This is the same as for deleting orphans, as described previously. As with deleting orphans, this process can be delayed until SaveChanges is called, or even disabled entirely, by setting xref:Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker.CascadeDeleteTiming?displayProperty=nameWithType appropriately. This is useful in the same way as it is for deleting orphans, including for re-parenting children/dependents after deletion of a principal/parent.\n\nCascade deletes, as well as deleting orphans, can be forced at any time by calling xref:Microsoft.EntityFrameworkCore.ChangeTracking.ChangeTracker.CascadeChanges?displayProperty=nameWithType. Combining this with setting the cascade delete timing to will ensure cascade deletes never happen unless EF Core is explicitly instructed to do so.\n\nMany-to-many relationships in EF Core are implemented using a join entity. Each side of the many-to-many relationship is related to this join entity with a one-to-many relationship. This join entity can be explicitly defined and mapped, or it can be created implicitly and hidden. In both cases the underlying behavior is the same. We will look at this underlying behavior first to understand how tracking of many-to-many relationships works.\n\nConsider this EF Core model that creates a many-to-many relationship between posts and tags using an explicitly defined join entity type:\n\nNotice that the join entity type contains two foreign key properties. In this model, for a post to be related to a tag, there must be a PostTag join entity where the foreign key value matches the primary key value, and where the foreign key value matches the primary key value. For example:\n\nLooking at the change tracker debug view after running this code shows that the post and tag are related by the new join entity:\n\nNotice that the collection navigations on and have been fixed up, as have the reference navigations on . These relationships can be manipulated by navigations instead of FK values, just as in all the preceding examples. For example, the code above can be modified to add the relationship by setting the reference navigations on the join entity:\n\nThis results in exactly the same change to FKs and navigations as in the previous example.\n\nManipulating the join table manually can be cumbersome. Many-to-many relationships can be manipulated directly using special collection navigations that \"skip over\" the join entity. For example, two skip navigations can be added to the model above; one from Post to Tags, and the other from Tag to Posts:\n\nThis many-to-many relationship requires the following configuration to ensure the skip navigations and normal navigations are all used for the same many-to-many relationship:\n\nSee Relationships for more information on mapping many-to-many relationships.\n\nSkip navigations look and behave like normal collection navigations. However, the way they work with foreign key values is different. Let's associate a post with a tag, but this time using a skip navigation:\n\nNotice that this code doesn't use the join entity. It instead just adds an entity to a navigation collection in the same way as would be done if this were a one-to-many relationship. The resulting debug view is essentially the same as before:\n\nNotice that an instance of the join entity was created automatically with FK values set to the PK values of the tag and post that are now associated. All the normal reference and collection navigations have been fixed up to match these FK values. Also, since this model contains skip navigations, these have also been fixed up. Specifically, even though we added the tag to the skip navigation, the inverse skip navigation on the other side of this relationship has also been fixed up to contain the associated post.\n\nIt is worth noting that the underlying many-to-many relationships can still be manipulated directly even when skip navigations have been layered on top. For example, the tag and Post could be associated as we did before introducing skip navigations:\n\nThis will still result in the skip navigations being fixed up correctly, resulting in the same debug view output as in the previous example.\n\nIn the previous section we added skip navigations in addition to fully defining the two underlying one-to-many relationships. This is useful to illustrate what happens to FK values, but is often unnecessary. Instead, the many-to-many relationship can be defined using only skip navigations. This is how the many-to-many relationship is defined in the model at the very top of this document. Using this model, we can again associate a Post and a Tag by adding a post to the skip navigation (or, alternately, adding a tag to the skip navigation):\n\nLooking at the debug view after making this change reveals that EF Core has created an instance of to represent the join entity. This join entity contains both and foreign key properties which have been set to match the PK values of the post and tag that are associated.\n\nSee Relationships for more information about implicit join entities and the use of entity types.\n\nSo far all the examples have used a join entity type (whether explicit or implicit) that contains only the two foreign key properties needed for the many-to-many relationship. Neither of these FK values need to be explicitly set by the application when manipulating relationships because their values come from the primary key properties of the related entities. This allows EF Core to create instances of the join entity without missing data.\n\nEF Core supports adding additional properties to the join entity type. This is known as giving the join entity a \"payload\". For example, let's add property to the join entity:\n\nThis payload property will not be set when EF Core creates a join entity instance. The most common way to deal with this is to use payload properties with automatically generated values. For example, the property can be configured to use a store-generated timestamp when each new entity is inserted:\n\nA post can now be tagged in the same way as before:\n\nLooking at the change tracker debug view after calling SaveChanges shows that the payload property has been set appropriately:\n\nFollowing on from the previous example, let's add a payload property that does not use an automatically generated value:\n\nA post can now be tagged in the same way as before, and the join entity will still be created automatically. This entity can then be accessed using one of the mechanisms described in Accessing Tracked Entities. For example, the code below uses xref:Microsoft.EntityFrameworkCore.DbSet`1.Find*?displayProperty=nameWithType to access the join entity instance:\n\nOnce the join entity has been located it can be manipulated in the normal way--in this example, to set the payload property before calling SaveChanges.\n\nAlternately, the join entity can be created explicitly to associate a post with a tag. For example:\n\nFinally, another way to set payload data is by either overriding xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges* or using the xref:Microsoft.EntityFrameworkCore.DbContext.SavingChanges?displayProperty=nameWithType event to process entities before updating the database. For example:"
    },
    {
        "link": "https://stackoverflow.com/questions/64465211/how-to-name-a-foreign-key-in-entity-framework-core",
        "document": "It seems that Entity Framework Core doesn't respect the custom name of the foreign key I specified as property attribute. I'm a bit concerned because I thought it initially worked..\n\n1-to-many relation between and (over-simplified example):\n\nBasically, it corresponds to this example (Entity Framework 6 though). I've already came across some stackoverflow threads which some Fluent API use, but would prefer avoiding them (ie I got some other issues..) When I migrate the domain (which is in a separate project from the Entity Framework one) I get the following name which is a bit too long.\n\nThanks for any insights."
    },
    {
        "link": "https://learn.microsoft.com/en-us/ef/core/saving",
        "document": "While querying allows you to read data from the database, saving data means adding new entities to the database, removing entities, or modifying the properties of existing entities in some way. Entity Framework Core (EF Core) supports two fundamental approaches for saving data to the database.\n\nIn many scenarios, your program needs to query some data from the database, perform some modification on it, and save those modifications back; this is sometimes referred to as a \"unit of work\". For example, let's assume that you have a set of Blogs, and you'd like to change the property of one of them. In EF, this is typically done as follows:\n\nThe code above performs the following steps:\n• It uses a regular LINQ query to load an entity from the database (see Query data). EF's queries are tracking by default, meaning that EF tracks the loaded entities in its internal change tracker.\n• The loaded entity instance is manipulated as usual, by assigning a .NET property. EF isn't involved in this step.\n• Finally, DbContext.SaveChanges() is called. At this point, EF automatically detects any changes by comparing the entities with a snapshot from the moment they were loaded. Any detected changes are persisted to the database; when using a relational database, this typically involves sending e.g. a SQL to update the relevant rows.\n\nNote that the above described a typical update operation for existing data, but similar principles hold for adding and removing entities. You interact with EF's change tracker by calling DbSet<TEntity>.Add and Remove, causing the changes to be tracked. EF then applies all tracked changes to the database when SaveChanges() is called (e.g. via SQL and when using a relational database).\n• You don't need to write code to track which entities and properties changed - EF does this automatically for you, and only updates those properties in the database, improving performance. Imagine if your loaded entities are bound to a UI component, allowing users to change any property they wish; EF takes away the burden of figuring out which entities and properties were actually changed.\n• Saving changes to the database can sometimes be complicated! For example, if you want to add a Blog and some Posts for that blog, you may need to fetch the database-generated key for the inserted Blog before you can insert the Posts (since they need to refer to the Blog). EF does all this for you, taking away the complexity.\n• EF can detect concurrency issues, such as when a database row has been modified by someone else between your query and SaveChanges(). More details are available in Concurrency conflicts.\n• On databases which support it, SaveChanges() automatically wraps multiple changes in a transaction, ensuring your data stays consistent if a failure occurs. More details are available in Transactions.\n• SaveChanges() also batches together multiple changes in many cases, significantly reducing the number of database roundtrips and greatly improving performance. More details are available in Efficient updating.\n\nFor more information and code samples on basic SaveChanges() usage, see Basic SaveChanges. For more information on EF's change tracking, see the Change tracking overview.\n\nWhile change tracking and SaveChanges() are a powerful way to save changes, they do have certain disadvantages.\n\nFirst, SaveChanges() requires that you query and track all the entities you will be modifying or deleting. If you need to, say, delete all Blogs with a rating below a certain threshold, you must query, materialize and track a potentially huge number of rows, and have SaveChanges() generate a statement for each and every one of them. Relational databases provide a far more efficient alternative: a single command can be sent, specifying which rows to delete via a clause, but the SaveChanges() model doesn't allow for generating that.\n\nTo support this \"bulk update\" scenario, you can use ExecuteDelete as follows:\n\nThis allows you to express a SQL statement via regular LINQ operators - similar to a regular LINQ query - causing the following SQL to be executed against the database:\n\nThis executes very efficiently in the database, without loading any data from the database or involving EF's change tracker. Similarly, ExecuteUpdate allows you to express a SQL statement.\n\nEven if you aren't changing entities in bulk, you may know exactly which properties of which entity you want to change. Using the change tracking API to perform the change can be overly complex, requiring creating an entity instance, tracking it via Attach, making your changes and finally calling SaveChanges(). For such scenarios, and can be a considerably simpler way to express the same operation.\n\nFinally, both change tracking and SaveChanges() itself impose a certain runtime overhead. If you're writing a high performance application, and allow you to avoid both these components and efficiently generate the statement you want.\n\nHowever, note that and also have certain limitations:\n• These methods execute immediately, and currently cannot be batched with other operations. On the other hand, SaveChanges(), can batch multiple operations together.\n• Since change tracking isn't involved, it's your responsibility to know exactly which entities and properties need to be changed. This may mean more manual, low-level code tracking what needs to change and what doesn't.\n• In addition, since change tracking isn't involved, these methods do not automatically apply Concurrency Control when persisting changes. However, you can still explicitly add a clause to implement concurrency control yourself.\n• Only updating and deleting is currently supported; insertion must be done via DbSet<TEntity>.Add and SaveChanges().\n\nFor more information and code samples, see and .\n\nFollowing are a few guidelines for when to use which approach. Note that these aren't absolute rules, but provide a useful rules of thumb:\n• If you don't know in advance which changes will take place, use ; it will automatically detect which changes need to be applied. Example scenarios:\n• \"I want to load a Blog from the database and display a form allowing the user to change it\"\n• If you need to manipulate a graph of objects (i.e. multiple interconnected objects), use ; it will figure out the proper ordering of the changes and how to link everything together.\n• \"I want to update a blog, changing some of its posts and deleting others\"\n• If you wish to change a potentially large number of entities based on some criterion, use and . Example scenarios:\n• \"I want to give all employees a raise\"\n• \"I want to delete all blogs whose name starts with X\"\n• If you already know exactly which entities you wish to modify and how you wish to change them, use and . Example scenarios:\n• \"I want to delete the blog whose name is 'Foo'\"\n• \"I want to change the name of the blog with Id 5 to 'Bar'\""
    },
    {
        "link": "https://learn.microsoft.com/en-us/ef/core/modeling/relationships",
        "document": "This document provides a simple introduction to the representation of relationships in object models and relational databases, including how EF Core maps between the two.\n\nA relationship defines how two entities relate to each other. For example, when modeling posts in a blog, each post is related to the blog it is published on, and the blog is related to all the posts published on that blog.\n\nIn an object-oriented language like C#, the blog and post are typically represented by two classes: and . For example:\n\nIn the classes above, there is nothing to indicate that and are related. This can be added to the object model by adding a reference from to the on which it is published:\n\nLikewise, the opposite direction of the same relationship can be represented as a collection of objects on each :\n\nThis connection from to and, inversely, from back to is known as a \"relationship\" in EF Core.\n\nRelational databases represent relationships using foreign keys. For example, using SQL Server or Azure SQL, the following tables can be used to represent our and classes:\n\nIn this relational model, the and tables are each given a \"primary key\" column. The value of the primary key uniquely identifies each post or blog. In addition, the table is given a \"foreign key\" column. The primary key column is referenced by the foreign key column of the table. This column is \"constrained\" such that any value in the column of must match a value in the column of . This match determines which blog every post is related to. For example, if the value in one row of the table is 7, then the post represented by that row is published in the blog with the primary key 7.\n\nEF Core relationship mapping is all about mapping the primary key/foreign key representation used in a relational database to the references between objects used in an object model.\n\nIn the most basic sense, this involves:\n• Associating the references between entity types with the primary and foreign keys to form a single relationship configuration.\n\nOnce this mapping is made, EF changes the foreign key values as needed when the references between objects change, and changes the references between objects as needed when the foreign key values change.\n\nFor example, the entity types shown above can be updated with primary and foreign key properties:\n\nThe primary key property of , , and the foreign key property of , , can then be associated with the references (\"navigations\") between the entity types ( and ). This is done automatically by EF when building a simple relationship like this, but can also be specified explicitly when overriding the method of your . For example:\n\nNow all these properties will behave coherently together as a representation of a single relationship between and .\n\nEF supports many different types of relationships, with many different ways these relationships can be represented and configured. To jump into examples for different kinds of relationships, see:\n• One-to-many relationships, in which a single entity is associated with any number of other entities.\n• One-to-one relationships, in which a single entity is associated with another single entity.\n• Many-to-many relationships, in which any number of entities are associated with any number of other entities.\n\nIf you are new to EF, then trying the examples linked in in the bullet points above is a good way to get a feel for how relationships work.\n\nTo dig deeper into the properties of entity types involved in relationship mapping, see:\n• Foreign and principal keys in relationships, which covers how foreign keys map to the database.\n• Relationship navigations, which describes how navigations are layered over a foreign key to provide an object-oriented view of the relationship.\n\nEF models are built using a combination of three mechanisms: conventions, mapping attributes, and the model builder API. Most of the examples show the model building API. To find out more about other options, see:\n• Relationship conventions, which discover entity types, their properties, and the relationships between the types.\n• Relationship mapping attributes, which can be used an alternative to the model building API for some aspects of relationship configuration.\n• Cascade deletes, which describe how related entities can be automatically deleted when or is called.\n• Owned entity types use a special type of \"owning\" relationship that implies a stronger connection between the two types than the \"normal\" relationships discussed here. Many of the concepts described here for normal relationships are carried over to owned relationships. However, owned relationships also have their own special behaviors.\n\nRelationships defined in the model can be used in various ways. For example:\n• Relationships can be used to query related data in any of three ways:\n• Eagerly as part of a LINQ query, using .\n• Lazily using lazy-loading proxies, or lazy-loading without proxies.\n• Explicitly using the or methods.\n• Relationships can be used in data seeding through matching of PK values to FK values.\n• Relationships can be used to track graphs of entities. Relationships are then used by the change tracker to:\n• Detect changes in relationships and perform fixup\n• Send foreign key updates to the database with or"
    },
    {
        "link": "https://medium.com/@walid.mougharbel/10-best-practices-for-entity-framework-core-d44d340b2046",
        "document": "EF Core can serve as an object-relational mapper (ORM), enabling.NET developers to work with a database using .NET objects, and eliminating the need for most of the data-access code they usually need to do CRUD operations.\n\nOnly data layer projects should have a dependency on EF. You need to keep the DbContext class internal to the DataLayer project and create an extension method to add DbContext which should be found in Data Access Layer and Called from Bussiness Layer.\n\nStore connection strings in a KeyVault, instead of Environment variables and configuration files such as Appsettings.json, Web.config, and App.config\n\nOne of EF tuning options is .AsNoTracking(). \n\nEF performs no additional processing or storage of the entities which are returned by the query. However, it also means that you can’t update these entities without reattaching them\n\nThree ways to perform updates in EF Core \n\nRanking EFCore Update > Attached Update > Usual Update\n\nEFCore Update is the fastest\n\n3 ways to load data in EF Core (Select Loading is the fastest)\n\nSelect Loading> Eager Loading> Lazy Loading\n\nRaw SQL should generally be used as a last resort. After making sure that EF can’t generate the SQL you want, and when performance is important enough for the given query to justify it. Using raw SQL brings considerable maintenance disadvantages.\n\nAs implied by the name, it has something to do with a cartesian product, i.e. with JOINs. When performing a JOIN on the one-to-many relationship, the rows of the one-side are replicated N times, whereby N is the number of matching records on the many-side.\n\nit’s important to always use asynchronous APIs rather than synchronous ones (e.g. SaveChangesAsync rather than SaveChanges).\n\nSynchronous APIs block the thread for the duration of database I/O, increasing the need for threads and the number of thread context switches that must occur.\n\nC# code does not get converted to t-SQL. Make sure you write lambda expressions or else your C# code will be executed after data is retrieved and this is not efficient\n\nWe need to provide data annotation attributes to let EF Core build efficient tables or else EF Core will build tables with fields that always allow null and with a maximum size of a given data type like nvarchar(max) for string."
    },
    {
        "link": "https://stackoverflow.com/questions/61142071/how-to-save-changes-in-ef-core-3-1-3-in-a-many-to-many-relationship",
        "document": "I'm trying to save changes on a database using EF Core 3.1.3, .net core 3.1 with blazor pages. The model contains multiple children, and each child has another child that may be the same entity. This is a sample code:\n\nAs you can see, I have multiple children that will use the same currency and the parent may also use the same currency, so when I try to save the changes I get an error that there is an entity with the same currencyID already being tracked.\n\nI know one solution is to nullify all navigation properties before trying to save changes, that works for saving data into the database but that breaks my blazor page since I'm displaying some of the properties to the user.\n\nI have tried using State.Unchanged instead of nullify the navigation property but when I iterate through all the children and there is a second child that uses the same currency then I have the error that the entity is already being tracked.\n\nI have also used .AsNoTracking() in my queries to get the currency, but it is also being tracked, i guess it happens when I use dbcontext.Add(Payment).\n\nIs there another solution? Perhaps a way to check if the entity is already in unchanged state so I can skip it during iteration?\n\nThanks for your help"
    },
    {
        "link": "https://code-maze.com/entity-framework-core-best-practices",
        "document": "Entity Framework Core (EF Core) is an object-relational mapper (ORM), enabling us to work with a database using .NET objects, eliminating much of the data-access code we usually need to write. EF Core supports many databases, including SQL Server, SQLite, PostgreSQL, MySQL, and more, making it highly versatile. While EF Core provides many conveniences, following best practices to ensure our application remains robust, maintainable, and performant is crucial.\n\nCheck out our comprehensive Entity Framework Core Series for a deeper dive into EF Core.\n\nIn the upcoming sections, we’ll explore the best practices of the EF Core. Let’s start!\n\nModeling data effectively in EF Core is crucial for building scalable, maintainable, efficient applications. In this section, we’ll outline best practices for defining entity classes and handling relationships to ensure our data models are clear, descriptive, and optimized for performance.\n\nUsing clear and descriptive class names is key to maintaining readability in the codebase. Each class name should accurately represent the entity it holds, making its purpose clear. For example, instead of naming a class , we name it if it holds product data.\n\nMoreover, EF Core provides two main ways to configure our data model: Data Annotations and Fluent API. Specifically, data annotations are attributes we apply directly to our classes and properties. They are simple to use and work well for straightforward configurations.\n\nLet’s take a look at how to use Data Annotations:\n\nHere, we create a class with a clear name, , and use Data Annotations to make the property required with a maximum length of 100 characters. Additionally, we specify the data type for the property. Misusing Data Annotations can result in issues like incorrect database schemas or validation errors.\n\nOn the other hand, Fluent API is more powerful and flexible, allowing for complex configurations and overrides. It is defined in the method of our class. Using Fluent API, we can configure entity properties and relationships with greater precision and control.\n\nNow, let’s let’s configure the same using the Fluent API:\n\nWe use Fluent API to configure the primary key and set property constraints. Improper use can lead to missing constraints in the database schema, so reviewing the generated SQL scripts to ensure they align with the expected design is important.\n\nAs a best practice, instead of placing all the configurations inside the method, we can extract them into separate classes that implement the interface. This approach helps keep the method clean and improves maintainability, especially when the number of entities grows.\n\nOptimizing the data model is essential to ensure performance and maintainability in an EF Core application. We can design models that minimize resource usage and improve query efficiency by following key practices.\n\nIt is crucial to choose the correct data types for entity properties. For example, we should avoid using or for string fields unless necessary. Instead, we must specify precise lengths to limit storage size and increase query speed.\n\nWe must index frequently queried columns like foreign keys or fields in clauses. Indexes significantly improve lookup performance, especially in large datasets. We should leverage data annotations or use Fluent API to fine-tune column definitions. For instance, we must use and annotations to enforce constraints that prevent null or excessively large data from being stored.\n\nWe should avoid overusing nullable fields unless truly required. Defining fields as can optimize storage and prevent unnecessary database operations.\n\nLet’s take a look at an optimized entity model:\n\nHere, we limit the and properties to 100 and 150 characters respectively, instead of , optimizing storage. Then, we use the annotation to ensure that essential fields like , , , and cannot be , promoting better data integrity.\n\nNext, we set the and to non-nullable, optimizing storage and preventing unnecessary null checks. Finally, we specify for , avoiding unnecessary large data types and reducing storage overhead.\n\nEffective migration management is essential for maintaining a consistent and up-to-date database schema. Migrations allow us to evolve our database schema over time while preserving the existing data.\n\nBest Practices for Versioning and Deploying Migrations\n\nMaintaining migrations in version control is crucial for collaboration and consistency across development environments. By including migration files in our version control system, we ensure all team members work with the same database schema and can track changes over time.\n\nTherefore, we must always commit the generated migration files to the version control system. This includes the migration class, designer file, and any snapshot files. Otherwise, ignoring migration files can lead to inconsistent database schemas across different environments, making troubleshooting difficult.\n\nWe should use clear and descriptive names for migrations to indicate their purpose. This will help us understand the changes introduced by each migration:\n\nHere, we use a descriptive name, “AddCustomerTable,” for the migration.\n\nBefore committing, we must review the generated migration code to ensure it accurately represents the intended schema changes. We should refactor the code if necessary to maintain clarity and consistency. Failing to review migrations can result in unexpected schema changes or data loss, especially if the generated code does not match the intended design.\n\nDeploying migrations across different environments (development, staging, production, etc.) requires careful planning and execution to avoid disruptions and ensure data integrity. For this reason, we should use environment-specific configuration files to manage connection strings and database settings. This ensures that we apply migrations to the correct database for each environment.\n\nHere, we create configuration files for different environments. Incorrect configuration can cause us to apply migrations to the wrong database, potentially leading to data corruption or loss.\n\nQuerying data efficiently in EF Core is essential for building high-performance applications. EF Core allows us to use Language Integrated Query (LINQ) to query databases in a strongly typed manner. For more detailed information on querying data with EF Core, visit our article Database Queries in Entity Framework Core.\n\nInstead of retrieving entire entities, we must select only the necessary fields. This reduces the amount of data transferred from the database to the application. Now, let’s use projection to select the field:\n\nHere, we use the extension method to project the and properties of the entity. This reduces the amount of data retrieved from the database, improving performance.\n\nWe should apply filtering conditions ( clause) as early as possible in the query to minimize the data processed. Now, let’s apply filtering early in the query:\n\nHere, we filter products with a price greater than 10 before projecting the and properties. This ensures that we process and retrieve only the relevant data, enhancing query performance\n\nFor bulk operations, consider using EF Core’s method for inserts:\n\nHere, we use the method to add multiple entities in a single batch. This reduces the number of database operations, making the insert process more efficient.\n\nThe method in EF Core instructs the context not to track the entities returned by the query. This reduces memory usage and improves query performance, especially for large result sets or frequently executed read-only queries.\n\nWe should use when we do not need to update the retrieved entities. For example, when performing read-only operations, such as displaying data in a UI or generating reports, can be beneficial. Additionally, using helps improve performance by reducing the overhead of change tracking, making it ideal for scenarios where data modifications are unnecessary.\n\nUsing method inappropriately can lead to issues if we later try to update the entities, as the context will not track them.\n\nLet’s see how to use method in a repository method:\n\nHere, we use the method to fetch products by category without tracking the entities, which makes the query more efficient for read-only purposes. This reduces the overhead of change tracking and improves performance.\n\nUse Skip() and Take() Methods\n\nHandling large data sets is crucial to maintaining application performance and user experience. Pagination is a common strategy to manage large data sets by retrieving data in smaller chunks. We commonly use and methods in LINQ for pagination. method specifies the number of records to bypass while methods specifies the number of records to retrieve.\n\nNow, let’s use and methods for pagination:\n\nHere, we implement pagination by skipping a specified number of records and taking the next set of records. This allows us to retrieve data in smaller, manageable chunks, improving performance and user experience. Fetching large data sets without pagination can lead to performance issues, high memory usage, and slow response times. We should always use pagination strategies to manage large data sets efficiently.\n\nOptimizing performance in EF Core is crucial for building responsive and efficient applications. This involves using techniques such as eager loading to minimize the number of database queries, lazy loading to delay data retrieval until it’s needed, and compiled queries to reduce the overhead of query compilation.\n\nLazy and Eager Loading are two strategies for loading related data in EF Core. Choosing the right strategy can significantly impact performance and resource utilization. Lazy loading delays the loading of associated data until we explicitly access it. This approach can help reduce the initial load time and memory usage if we don’t always need the related data.\n\nNow, let’s see how to configure lazy loading:\n\nHere, we the method of the class inside the class. Then, we enable lazy loading by configuring EF Core to use lazy loading proxies.\n\nAt the same time, we modify the class to add the navigation property as . This setup allows related entity to be loaded only when they are accessed.\n\nEager Loading loads related data as part of the initial query. We can improve performance by reducing the number of database round-trips, especially when we always need the related data\n\nNow, let’s see how to configure Eager Loading:\n\nHere, we use the method to eagerly load the entities along with entities in a single query. This ensures the related data is available immediately, reducing the need for additional database queries.\n\nUsing Eager Loading with large datasets or complex relationships can result in a Cartesian explosion, leading to performance issues. EF Core allows for Split Queries, which splits the loading of related entities into separate queries, reducing this risk.\n\nHere, we use the method to load related in separate SQL queries, reducing the potential performance issues caused by large joins. Both Lazy Loading and Eager Loading have their use cases. Using split queries where necessary can help optimize performance, especially when dealing with large or complex relationships.\n\nPre-compiled versions of LINQ queries, known as compiled queries, improve performance by reducing the overhead of query compilation and allowing reuse for frequently executed queries. We can reuse compiled queries across different parts of the application, ensuring consistency and performance benefits.\n\nNow, let’s create and use a compiled query:\n\nWe define a compiled query to retrieve products with a price greater than a specified value. We then use the compiled query to fetch the data efficiently. Compiled queries particularly benefit complex queries or scenarios where we execute the same query multiple times with different parameters.\n\nAsynchronous programming is essential for building responsive and scalable applications. EF Core provides asynchronous methods for database operations to avoid blocking the main thread during I/O operations.\n\nAsynchronous APIs improve application responsiveness by preventing us from blocking the main thread during database operations. Asynchronous operations allow the application to handle more concurrent requests by freeing up threads for other tasks.\n\nNow, let’s use the method:\n\nHere, we add a new entity to the database and saves the changes asynchronously. This approach ensures that the main thread remains unblocked during database operations, enhancing application performance and scalability.\n\nSecurity is a paramount concern when developing applications that interact with databases. EF Core provides several mechanisms to help protect our application from common security threats such as SQL injection and insecure handling of connection strings.\n\nSQL injection is a common and severe security vulnerability where an attacker can execute arbitrary SQL code by injecting malicious input into a query. EF Core helps mitigate this risk by using parameterized queries, but we must still follow best practices to ensure their applications are secure.\n\nWe must always use parameterized queries because they automatically handle escaping special characters and prevent the execution of injected SQL code. Moreover, we should never concatenate user input directly into SQL queries. Otherwise, dynamic SQL that includes user input can easily lead to SQL injection vulnerabilities.\n\nWhenever possible, use LINQ to construct queries in EF Core. EF Core translates LINQ queries into parameterized SQL queries, providing additional protection against SQL injection. We must always validate and sanitize user input before using it in our queries. This reduces the likelihood of malicious input making its way into our queries.\n\nNow, let’s see an example that incorporates all these best practices:\n\nHere, before executing any queries, we validate the and inputs to ensure they are valid. This prevents the application from processing harmful or unexpected inputs.\n\nNext, we use LINQ to construct a query that safely filters products by and searches for the property that contains the . LINQ automatically parameterizes the inputs, protecting against SQL injection. Finally, we show how to use raw SQL queries with parameterized input safely. This allows us to safely include user inputs in the SQL query by automatically parameterizing them.\n\nWe must always prefer using LINQ for queries in EF Core, as it provides built-in protection against SQL injection. If we need to use raw SQL queries, ensure that we use parameterized queries to maintain security.\n\nIn conclusion, adhering to best practices in EF Core ensures our applications’ reliability and maintainability and significantly boosts performance and scalability.\n\nWe can create robust applications that handle data efficiently by effectively managing relationships, optimizing queries, and utilizing asynchronous operations. Moreover, understanding when to apply techniques like lazy loading, eager loading, and compiled queries can substantially affect application responsiveness.\n\nRemember that best practices may evolve, so stay engaged with the C# community to stay up-to-date with the latest recommendations.\n\nIf you have something to add to the list, we invite you to contribute by sharing it in the comment section."
    }
]