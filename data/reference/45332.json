[
    {
        "link": "https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html",
        "document": "Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, gs, and file. For file URLs, a host is expected. A local file could be: file://localhost/path/to/table.csv. If you want to pass in a path object, pandas accepts any . By file-like object, we refer to objects with a method, such as a file handle (e.g. via builtin function) or .\n\nRow number(s) containing column labels and marking the start of the data (zero-indexed). Default behavior is to infer the column names: if no are passed the behavior is identical to and column names are inferred from the first line of the file, if column names are passed explicitly to then the behavior is identical to . Explicitly pass to be able to replace existing names. The header can be a list of integers that specify row locations for a on the columns e.g. . Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if , so denotes the first line of data rather than the first line of the file.\n\nColumn(s) to use as row label(s), denoted either by column labels or column indices. If a sequence of labels or indices is given, will be formed for the row labels. Note: can be used to force pandas to not use the first column as the index, e.g., when you have a malformed file with delimiters at the end of each line.\n\nSubset of columns to select, denoted either by column labels or column indices. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in or inferred from the document header row(s). If are given, the document header row(s) are not taken into account. For example, a valid list-like parameter would be or . Element order is ignored, so is the same as . To instantiate a from with element order preserved use for columns in order or for order. If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to . An example of a valid callable argument would be . Using this parameter results in much faster parsing time and lower memory usage.\n\nWhether or not to include the default values when parsing the data. Depending on whether is passed in, the behavior is as follows:\n• None If is , and are specified, is appended to the default values used for parsing.\n• None If is , and are not specified, only the default values are used for parsing.\n• None If is , and are specified, only the values specified are used for parsing.\n• None If is , and are not specified, no strings will be parsed as . Note that if is passed in as , the and parameters will be ignored.\n\nFunction to use for converting a sequence of string columns to an array of instances. The default uses to do the conversion. pandas will try to call in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by ) as arguments; 2) concatenate (row-wise) the string values from the columns defined by into a single array and pass that; and 3) call once for each row using one or more strings (corresponding to the columns defined by ) as arguments. Deprecated since version 2.0.0: Use instead, or read in as and then apply as-needed.\n\nFor on-the-fly decompression of on-disk data. If ‘infer’ and ‘filepath_or_buffer’ is path-like, then detect compression from the following extensions: ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, ‘.tar’, ‘.tar.gz’, ‘.tar.xz’ or ‘.tar.bz2’ (otherwise no compression). If using ‘zip’ or ‘tar’, the ZIP file must contain only one data file to be read in. Set to for no decompression. Can also be a dict with key set to one of { , , , , , } and other key-value pairs are forwarded to , , , , or , respectively. As an example, the following could be passed for Zstandard decompression using a custom compression dictionary: ."
    },
    {
        "link": "https://pandas.pydata.org/docs/user_guide/io.html",
        "document": "The pandas I/O API is a set of top level functions accessed like that generally return a pandas object. The corresponding functions are object methods that are accessed like . Below is a table containing available and .\n\nis an informal performance comparison for some of these IO methods.\n\nThe workhorse function for reading text files (a.k.a. flat files) is . See the for some advanced strategies. Either a path to a file (a , , or ), URL (including http, ftp, and S3 locations), or any object with a method (such as an open file or ). sep str, defaults to for , for Delimiter to use. If sep is , the C engine cannot automatically detect the separator, but the Python parsing engine can, meaning the latter will be used and automatically detect the separator by Python’s builtin sniffer tool, . In addition, separators longer than 1 character and different from will be interpreted as regular expressions and will also force the use of the Python parsing engine. Note that regex delimiters are prone to ignoring quoted data. Regex example: . Specifies whether or not whitespace (e.g. or ) will be used as the delimiter. Equivalent to setting . If this option is set to , nothing should be passed in for the parameter. Row number(s) to use as the column names, and the start of the data. Default behavior is to infer the column names: if no names are passed the behavior is identical to and column names are inferred from the first line of the file, if column names are passed explicitly then the behavior is identical to . Explicitly pass to be able to replace existing names. The header can be a list of ints that specify row locations for a MultiIndex on the columns e.g. . Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if , so header=0 denotes the first line of data rather than the first line of the file. List of column names to use. If file contains no header row, then you should explicitly pass . Duplicates in this list are not allowed. Column(s) to use as the row labels of the , either given as string name or column index. If a sequence of int / str is given, a MultiIndex is used. can be used to force pandas to use the first column as the index, e.g. when you have a malformed file with delimiters at the end of each line. The default value of instructs pandas to guess. If the number of fields in the column header row is equal to the number of fields in the body of the data file, then a default index is used. If it is larger, then the first columns are used as index so that the remaining number of fields in the body are equal to the number of fields in the header. The first row after the header is used to determine the number of columns, which will go into the index. If the subsequent rows contain less columns than the first row, they are filled with . This can be avoided through . This ensures that the columns are taken as is and the trailing data are ignored. Return a subset of the columns. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in or inferred from the document header row(s). If are given, the document header row(s) are not taken into account. For example, a valid list-like parameter would be or . Element order is ignored, so is the same as . To instantiate a DataFrame from with element order preserved use for columns in order or for order. If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True: Using this parameter results in much faster parsing time and lower memory usage when using the c engine. The Python engine loads the data first before deciding which columns to drop. dtype Type name or dict of column -> type, default Data type for data or columns. E.g. Use or together with suitable settings to preserve and not interpret dtype. If converters are specified, they will be applied INSTEAD of dtype conversion. Support for defaultdict was added. Specify a defaultdict as input where the default determines the dtype of the columns which are not explicitly listed. Which dtype_backend to use, e.g. whether a DataFrame should have NumPy arrays, nullable dtypes are used for all dtypes that have a nullable implementation when “numpy_nullable” is set, pyarrow is used for all dtypes if “pyarrow” is set. The dtype_backends are still experimential. Parser engine to use. The C and pyarrow engines are faster, while the python engine is currently more feature-complete. Multithreading is currently only supported by the pyarrow engine. The “pyarrow” engine was added as an engine, and some features are unsupported, or may not work correctly, with this engine. Dict of functions for converting values in certain columns. Keys can either be integers or column labels. Values to consider as . Values to consider as . Line numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file. If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise: Number of lines at bottom of file to skip (unsupported with engine=’c’). Number of rows of file to read. Useful for reading pieces of large files. Internally process the file in chunks, resulting in lower memory use while parsing, but possibly mixed type inference. To ensure no mixed types either set , or specify the type with the parameter. Note that the entire file is read into a single regardless, use the or parameter to return the data in chunks. (Only valid with C parser) If a filepath is provided for , map the file object directly onto memory and access the data directly from there. Using this option can improve performance because there is no longer any I/O overhead. Additional strings to recognize as NA/NaN. If dict passed, specific per-column NA values. See below for a list of the values interpreted as NaN by default. Whether or not to include the default NaN values when parsing the data. Depending on whether is passed in, the behavior is as follows:\n• None If is , and are specified, is appended to the default NaN values used for parsing.\n• None If is , and are not specified, only the default NaN values are used for parsing.\n• None If is , and are specified, only the NaN values specified are used for parsing.\n• None If is , and are not specified, no strings will be parsed as NaN. Note that if is passed in as , the and parameters will be ignored. Detect missing value markers (empty strings and the value of na_values). In data without any NAs, passing can improve the performance of reading a large file. Indicate number of NA values placed in non-numeric columns. If , skip over blank lines rather than interpreting as NaN values. parse_dates boolean or list of ints or names or list of lists or dict, default .\n• None If -> try parsing the index.\n• None If -> try parsing columns 1, 2, 3 each as a separate date column.\n• None If -> combine columns 1 and 3 and parse as a single date column.\n• None If -> parse columns 1, 3 as date and call result ‘foo’. If and parse_dates is enabled for a column, attempt to infer the datetime format to speed up the processing. A strict version of this argument is now the default, passing it has no effect. If and parse_dates specifies combining multiple columns then keep the original columns. Function to use for converting a sequence of string columns to an array of datetime instances. The default uses to do the conversion. pandas will try to call date_parser in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by parse_dates) as arguments; 2) concatenate (row-wise) the string values from the columns defined by parse_dates into a single array and pass that; and 3) call date_parser once for each row using one or more strings (corresponding to the columns defined by parse_dates) as arguments. Use instead, or read in as and then apply as-needed. If used in conjunction with , will parse dates according to this format. For anything more complex, please read in as and then apply as-needed. If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets. Return object for iteration or getting chunks with . Return object for iteration. See below. For on-the-fly decompression of on-disk data. If ‘infer’, then use gzip, bz2, zip, xz, or zstandard if is path-like ending in ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, respectively, and no decompression otherwise. If using ‘zip’, the ZIP file must contain only one data file to be read in. Set to for no decompression. Can also be a dict with key set to one of { , , , } and other key-value pairs are forwarded to , , , or . As an example, the following could be passed for faster compression and to create a reproducible gzip archive: . Character to recognize as decimal point. E.g. use for European data. Specifies which converter the C engine should use for floating-point values. The options are for the ordinary converter, for the high-precision converter, and for the round-trip converter. Character to break file into lines. Only valid with C parser. The character used to denote the start and end of a quoted item. Quoted items can include the delimiter and it will be ignored. Control field quoting behavior per constants. Use one of (0), (1), (2) or (3). When is specified and is not , indicate whether or not to interpret two consecutive elements inside a field as a single element. One-character string used to escape delimiter when quoting is . Indicates remainder of line should not be parsed. If found at the beginning of a line, the line will be ignored altogether. This parameter must be a single character. Like empty lines (as long as ), fully commented lines are ignored by the parameter but not by . For example, if , parsing ‘#empty\n\na,b,c\n\n1,2,3’ with will result in ‘a,b,c’ being treated as the header. Encoding to use for UTF when reading/writing (e.g. ). List of Python standard encodings. If provided, this parameter will override values (default or not) for the following parameters: , , , , , and . If it is necessary to override values, a ParserWarning will be issued. See documentation for more details. Specifies what to do upon encountering a bad line (a line with too many fields). Allowed values are :\n• None ‘error’, raise an ParserError when a bad line is encountered.\n• None ‘warn’, print a warning when a bad line is encountered and skip that line.\n• None ‘skip’, skip bad lines without raising or warning when they are encountered. You can indicate the data type for the whole or individual columns: Fortunately, pandas offers more than one way to ensure that your column(s) contain only one . If you’re unfamiliar with these concepts, you can see to learn more about dtypes, and to learn more about conversion in pandas. For instance, you can use the argument of : Or you can use the function to coerce the dtypes after reading in the data, which will convert all valid parsing to floats, leaving the invalid parsing as . Ultimately, how you deal with reading in columns containing mixed dtypes depends on your specific needs. In the case above, if you wanted to out the data anomalies, then is probably your best option. However, if you wanted for all the data to be coerced, no matter the type, then using the argument of would certainly be worth trying. In some cases, reading in abnormal data with columns containing mixed dtypes will result in an inconsistent dataset. If you rely on pandas to infer the dtypes of your columns, the parsing engine will go and infer the dtypes for different chunks of the data, rather than the whole dataset at once. Consequently, you can end up with column(s) with mixed dtypes. For example, will result with containing an dtype for certain chunks of the column, and for others due to the mixed dtypes from the data that was read in. It is important to note that the overall column will be marked with a of , which is used for columns with mixed dtypes. Setting will result in nullable dtypes for every column. columns can be parsed directly by specifying or . Individual columns can be parsed as a using a dict specification: Specifying will result in an unordered whose are the unique values observed in the data. For more control on the categories and order, create a ahead of time, and pass that for that column’s . When using , “unexpected” values outside of are treated as missing values. This matches the behavior of . With , the resulting categories will always be parsed as strings (object dtype). If the categories are numeric they can be converted using the function, or as appropriate, another converter such as . When is a with homogeneous ( all numeric, all datetimes, etc.), the conversion is done automatically. A file may or may not have a header row. pandas assumes the first row should be used as the column names: By specifying the argument in conjunction with you can indicate other names to use and whether or not to throw away the header row (if any): If the header is in a row other than the first, pass the row number to . This will skip the preceding rows: Default behavior is to infer the column names: if no names are passed the behavior is identical to and column names are inferred from the first non-blank line of the file, if column names are passed explicitly then the behavior is identical to . If the file or header contains duplicate names, pandas will by default distinguish between them so as to prevent overwriting data: There is no more duplicate data because duplicate columns ‘X’, …, ‘X’ become ‘X’, ‘X.1’, …, ‘X.N’. The argument allows you to select any subset of the columns in a file, either using the column names, position numbers or a callable: The argument can also be used to specify which columns not to use in the final result: In this case, the callable is specifying that we exclude the “a” and “c” columns from the output. If the parameter is specified, then completely commented lines will be ignored. By default, completely blank lines will be ignored as well. If , then will not ignore blank lines: The presence of ignored lines might create ambiguities involving line numbers; the parameter uses row numbers (ignoring commented/empty lines), while uses line numbers (including commented/empty lines): If both and are specified, will be relative to the end of . For example: Sometimes comments or meta data may be included in a file: By default, the parser includes the comments in the output: We can suppress the comments using the keyword: The argument should be used for encoded unicode data, which will result in byte strings being decoded to unicode in the result: Some formats which encode all characters as multiple bytes, like UTF-16, won’t parse correctly at all without specifying the encoding. Full list of Python standard encodings. If a file has one more column of data than the number of column names, the first column will be used as the ’s row names: Ordinarily, you can achieve this behavior using the option. There are some exception cases when a file has been prepared with delimiters at the end of each data line, confusing the parser. To explicitly disable the index column inference and discard the last column, pass : If a subset of data is being parsed using the option, the specification is based on that subset, not the original data. To better facilitate working with datetime data, uses the keyword arguments and to allow users to specify a variety of columns and date/time formats to turn the input text data into objects. The simplest case is to just pass in : # Use a column as an index, and parse it as dates. It is often the case that we may want to store date and time data separately, or store various date fields separately. the keyword can be used to specify a combination of columns to parse the dates and/or times from. You can specify a list of column lists to , the resulting date columns will be prepended to the output (so as to not affect the existing column order) and the new column names will be the concatenation of the component column names: By default the parser removes the component date columns, but you can choose to retain them via the keyword: Note that if you wish to combine multiple columns into a single date column, a nested list must be used. In other words, indicates that the second and third columns should each be parsed as separate date columns while means the two columns should be parsed into a single column. You can also use a dict to specify custom name columns: It is important to remember that if multiple text columns are to be parsed into a single date column, then a new column is prepended to the data. The specification is based off of this new set of columns rather than the original data columns: If a column or index contains an unparsable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use after . read_csv has a fast_path for parsing datetime strings in iso8601 format, e.g “2000-01-01T00:01:02+00:00” and similar variations. If you can arrange for your data to store datetimes in this format, load times will be significantly faster, ~20x has been observed. Combining date columns inside read_csv is deprecated. Use on the relevant result columns instead. Finally, the parser allows you to specify a custom . Performance-wise, you should try these methods of parsing dates in order:\n• None If you know the format, use , e.g.: or .\n• None If you different formats for different columns, or want to pass any extra options (such as ) to , then you should read in your data as dtype, and then use . pandas cannot natively represent a column or index with mixed timezones. If your CSV file contains columns with a mixture of timezones, the default result will be an object-dtype column with strings, even with . To parse the mixed-timezone values as a datetime column, read in as dtype and then call with . Here are some examples of datetime strings that can be guessed (all representing December 30th, 2011 at 00:00:00): Note that format inference is sensitive to . With , it will guess “01/12/2011” to be December 1st. With (default) it will guess “01/12/2011” to be January 12th. If you try to parse a column of date strings, pandas will attempt to guess the format from the first non-NaN element, and will then parse the rest of the column with that format. If pandas fails to guess the format (for example if your first string is ), then a warning will be raised and each row will be parsed individually by . The safest way to parse dates is to explicitly set . In the case that you have mixed datetime formats within the same column, you can pass or, if your datetime formats are all ISO8601 (possibly not identically-formatted): While US date formats tend to be MM/DD/YYYY, many international formats use DD/MM/YYYY instead. For convenience, a keyword is provided: allows writing a CSV to a file object opened binary mode. In most cases, it is not necessary to specify as Pandas will auto-detect whether the file object is opened in text or binary mode. The parameter can be specified in order to use a specific floating-point converter during parsing with the C engine. The options are the ordinary converter, the high-precision converter, and the round-trip converter (which is guaranteed to round-trip values after writing to a file). For example: For large numbers that have been written with a thousands separator, you can set the keyword to a string of length 1 so that integers will be parsed correctly: By default, numbers with a thousands separator will be parsed as strings: The keyword allows integers to be parsed correctly: To control which values are parsed as missing values (which are signified by ), specify a string in . If you specify a list of strings, then all values in it are considered to be missing values. If you specify a number (a , like or an like ), the corresponding equivalent values will also imply a missing value (in this case effectively are recognized as ). To completely override the default values that are recognized as missing, specify . Let us consider some examples: In the example above and will be recognized as , in addition to the defaults. A string will first be interpreted as a numerical , then as a . Above, only an empty field will be recognized as . Above, both and as strings are . The default values, in addition to the string are recognized as . like values will be parsed as (positive infinity), and as (negative infinity). These will ignore the case of the value, meaning , will also be parsed as . The common values , , , and are all recognized as boolean. Occasionally you might want to recognize other values as being boolean. To do this, use the and options as follows: Some files may have malformed lines with too few fields or too many. Lines with too few fields will have NA values filled in the trailing fields. Lines with too many fields will raise an error by default: Traceback (most recent call last) in in in in in in in in in : Error tokenizing data. C error: Expected 3 fields in line 3, saw 4 You can elect to skip bad lines: Or pass a callable function to handle the bad line if . The bad line will be a list of strings that was split by the : The callable function will handle only a line with too many fields. Bad lines caused by other errors will be silently skipped. name a,a is of type a 'name,type\n\nname a,a is of type a\n\nname b,\"b\" is of type b\"' 0 name a a is of type a The line was not processed in this case, as a “bad line” here is caused by an escape character. You can also use the parameter to eliminate extraneous column data that appear in some lines but not others: Traceback (most recent call last) in in in in in in \"Usecols do not match columns, columns expected but not found: \" : Usecols do not match columns, columns expected but not found: [0, 1, 2] In case you want to keep all data including the lines with too many fields, you can specify a sufficient number of . This ensures that lines with not enough fields are filled with . 1 name a a is of type a NaN NaN 2 name b b is of type b\" NaN NaN The keyword gives greater flexibility in specifying the file format. By default it uses the Excel dialect but you can specify either the dialect name or a instance. Suppose you had data with unenclosed quotes: By default, uses the Excel dialect and treats the double quote as the quote character, which causes it to fail when it finds a newline before it finds the closing double quote. We can get around this using : All of the dialect options can be specified separately by keyword arguments: Another common dialect option is , to skip any whitespace after a delimiter: The parsers make every attempt to “do the right thing” and not be fragile. Type inference is a pretty big deal. If a column can be coerced to integer dtype without altering the contents, the parser will do so. Any non-numeric columns will come through as object dtype as with the rest of pandas objects. Quotes (and other escape characters) in embedded fields can be handled in any number of ways. One way is to use backslashes; to properly parse this data, you should pass the option: \"hello, \\\"Bob\\\", nice to see you\",5 0 hello, \"Bob\", nice to see you 5 While reads delimited data, the function works with data files that have known and fixed column widths. The function parameters to are largely the same as with two extra parameters, and a different usage of the parameter:\n• None : A list of pairs (tuples) giving the extents of the fixed-width fields of each line as half-open intervals (i.e., [from, to[ ). String value ‘infer’ can be used to instruct the parser to try detecting the column specifications from the first 100 rows of the data. Default behavior, if not specified, is to infer.\n• None : A list of field widths which can be used instead of ‘colspecs’ if the intervals are contiguous.\n• None : Characters to consider as filler characters in the fixed-width file. Can be used to specify the filler character of the fields if it is not spaces (e.g., ‘~’). In order to parse this file into a , we simply need to supply the column specifications to the function along with the file name: Note how the parser automatically picks column names X.<column number> when argument is specified. Alternatively, you can supply just the column widths for contiguous columns: The parser will take care of extra white spaces around the columns so it’s ok to have extra separation between the columns in the file. By default, will try to infer the file’s by using the first 100 rows of the file. It can do it only in cases when the columns are aligned and correctly separated by the provided (default delimiter is whitespace). supports the parameter for specifying the types of parsed columns to be different from the inferred type. Consider a file with one less entry in the header than the number of data column: In this special case, assumes that the first column is to be used as the index of the : Note that the dates weren’t automatically parsed. In that case you would need to do as before: Suppose you have data indexed by two columns: The argument to can take a list of column numbers to turn multiple columns into a for the index of the returned object: By specifying list of row locations for the argument, you can read in a for the columns. Specifying non-consecutive rows will skip the intervening rows. is also able to interpret a more common format of multi-columns indices. If an is not specified (e.g. you don’t have an index, or wrote it with , then any on the columns index will be . is capable of inferring delimited (not necessarily comma-separated) files, as pandas uses the class of the csv module. For this, you have to specify . It’s best to use to combine multiple files. See the for an example. Suppose you wish to iterate through a (potentially very large) file lazily rather than reading the entire file into memory, such as the following: By specifying a to , the return value will be an iterable object of type : Specifying will also return the object: Pandas currently supports three engines, the C engine, the python engine, and an experimental pyarrow engine (requires the package). In general, the pyarrow engine is fastest on larger workloads and is equivalent in speed to the C engine on most other workloads. The python engine tends to be slower than the pyarrow and C engines on most workloads. However, the pyarrow engine is much less robust than the C engine, which lacks a few features compared to the Python engine. Where possible, pandas uses the C parser (specified as ), but it may fall back to Python if C-unsupported options are specified. Currently, options unsupported by the C and pyarrow engines include: Specifying any of the above options will produce a unless the python engine is selected explicitly using . Options that are unsupported by the pyarrow engine which are not covered by the list above include: Specifying these options with will raise a . You can pass in a URL to read or write remote files to many of pandas’ IO functions - the following example shows reading a CSV file: A custom header can be sent alongside HTTP(s) requests by passing a dictionary of header key value mappings to the keyword argument as shown below: All URLs which are not local files or HTTP(s) are handled by fsspec, if installed, and its various filesystem implementations (including Amazon S3, Google Cloud, SSH, FTP, webHDFS…). Some of these implementations will require additional packages to be installed, for example S3 URLs require the s3fs library: When dealing with remote storage systems, you might need extra configuration with environment variables or config files in special locations. For example, to access data in your S3 bucket, you will need to define credentials in one of the several ways listed in the S3Fs documentation. The same is true for several of the storage backends, and you should follow the links at fsimpl1 for implementations built into and fsimpl2 for those not included in the main distribution. You can also pass parameters directly to the backend driver. Since does not utilize the environment variable, we can directly define a dictionary containing the endpoint_url and pass the object into the storage option parameter: More sample configurations and documentation can be found at S3Fs documentation. If you do have S3 credentials, you can still access public data by specifying an anonymous connection, such as also allows complex URLs, for accessing data in compressed archives, local caching of files, and more. To locally cache the above example, you would modify the call to where we specify that the “anon” parameter is meant for the “s3” part of the implementation, not to the caching implementation. Note that this caches to a temporary directory for the duration of the session only, but you can also specify a permanent store. The and objects have an instance method which allows storing the contents of the object as a comma-separated-values file. The function takes a number of arguments. Only the first is required.\n• None : A string path to the file to write or a file object. If a file object it must be opened with\n• None : Whether to write out the column names (default True)\n• None : Column label(s) for index column(s) if desired. If None (default), and and are True, then the index names are used. (A sequence should be given if the uses MultiIndex).\n• None : a string representing the encoding to use if the contents are non-ASCII, for Python versions prior to 3\n• None : Set quoting rules as in csv module (default csv.QUOTE_MINIMAL). Note that if you have set a then floats are converted to strings and csv.QUOTE_NONNUMERIC will treat them as non-numeric\n• None : Character used to quote fields (default ‘”’)\n• None : Character used to escape and when appropriate (default None)\n• None : Number of rows to write at a time The object has an instance method which allows control over the string representation of the object. All arguments are optional:\n• None default None, for example a StringIO object\n• None default None, which columns to write\n• None default None, minimum width of each column.\n• None default None, a dictionary (by column) of functions each of which takes a single argument and returns a formatted string\n• None default None, a function which takes a single (float) argument and returns a formatted string; to be applied to floats in the .\n• None default True, set to False for a with a hierarchical index to print every MultiIndex key at each row.\n• None default True, will print the names of the indices The object also has a method, but with only the , , arguments. There is also a argument which, if set to , will additionally output the length of the Series.\n\nA or can be converted to a valid JSON string. Use with optional parameters:\n• None : the pathname or buffer to write the output. This can be in which case a JSON string is returned.\n• The format of the JSON string\n• None : string, type of date conversion, ‘epoch’ for timestamp, ‘iso’ for ISO8601.\n• None : The number of decimal places to use when encoding floating point values, default 10.\n• None : The time unit to encode to, governs timestamp and ISO8601 precision. One of ‘s’, ‘ms’, ‘us’ or ‘ns’ for seconds, milliseconds, microseconds and nanoseconds respectively. Default ‘ms’.\n• None : The handler to call if an object cannot otherwise be converted to a suitable format for JSON. Takes a single argument, which is the object to convert, and returns a serializable object.\n• None : If orient, then will write each record per line as json.\n• None : string, writer mode when writing to path. ‘w’ for write, ‘a’ for append. Default ‘w’ Note ’s, ’s and will be converted to and objects will be converted based on the and parameters. There are a number of different options for the format of the resulting JSON file / string. Consider the following and : Column oriented (the default for ) serializes the data as nested JSON objects with column labels acting as the primary index: # Not available for Series Index oriented (the default for ) similar to column oriented but the index labels are now primary: Record oriented serializes the data to a JSON array of column -> value records, index labels are not included. This is useful for passing data to plotting libraries, for example the JavaScript library : Value oriented is a bare-bones option which serializes to nested JSON arrays of values only, column and index labels are not included: # Not available for Series Split oriented serializes to a JSON object containing separate entries for values, index and columns. Name is also included for : Table oriented serializes to the JSON Table Schema, allowing for the preservation of metadata including but not limited to dtypes and index names. Any orient option that encodes to a JSON object will not preserve the ordering of index and column labels during round-trip serialization. If you wish to preserve label ordering use the option as it uses ordered containers. Writing to a file, with a date index and a date column: If the JSON serializer cannot handle the container contents directly it will fall back in the following manner:\n• None if the dtype is unsupported (e.g. ) then the , if provided, will be called for each value, otherwise an exception is raised.\n• None if an object is unsupported it will attempt the following:\n• None check if the object has defined a method and call it. A method should return a which will then be JSON serialized.\n• None invoke the if one was provided.\n• None convert the object to a by traversing its contents. However this will often fail with an or give unexpected results. In general the best approach for unsupported objects or dtypes is to provide a . For example: can be dealt with by specifying a simple : Reading a JSON string to pandas object can take a number of parameters. The parser will try to parse a if is not supplied or is . To explicitly force parsing, pass\n• None : a VALID JSON string or file handle / StringIO. The string could be a URL. Valid URL schemes include http, ftp, S3, and file. For file URLs, a host is expected. For instance, a local file could be file ://localhost/path/to/table.json\n• None : type of object to recover (series or frame), default ‘frame’\n• The format of the JSON string\n• None : if True, infer dtypes, if a dict of column to dtype, then use those, if , then don’t infer dtypes at all, default is True, apply only to the data.\n• None : boolean, try to convert the axes to the proper dtypes, default is\n• None : a list of columns to parse for dates; If , then try to parse date-like columns, default is .\n• None : boolean, default . If parsing dates, then parse the default date-like columns.\n• None : boolean, default . Set to enable usage of higher precision (strtod) function when decoding string to double values. Default ( ) is to use fast but less precise builtin functionality.\n• None : string, the timestamp unit to detect if converting dates. Default None. By default the timestamp precision will be detected, if this is not desired then pass one of ‘s’, ‘ms’, ‘us’ or ‘ns’ to force timestamp precision to seconds, milliseconds, microseconds or nanoseconds respectively.\n• None : reads file as one json object per line.\n• None : The encoding to use to decode py3 bytes.\n• None : when used in combination with , return a which reads in lines per iteration.\n• None : Either , the built-in JSON parser, or which dispatches to pyarrow’s . The is only available when The parser will raise one of if the JSON is not parseable. If a non-default was used when encoding to JSON be sure to pass the same option here so that decoding produces sensible results, see Orient Options for an overview. The default of , , and will try to parse the axes, and all of the data into appropriate types, including dates. If you need to override specific dtypes, pass a dict to . should only be set to if you need to preserve string-like numbers (e.g. ‘1’, ‘2’) in an axes. Large integer values may be converted to dates if and the data and / or column labels appear ‘date-like’. The exact threshold depends on the specified. ‘date-like’ means that the column label meets one of the following criteria: When reading JSON data, automatic coercing into dtypes has some quirks:\n• None an index can be reconstructed in a different order from serialization, that is, the returned order is not guaranteed to be the same as before serialization\n• None a column that was data will be converted to if it can be done safely, e.g. a column of\n• None bool columns will be converted to on reconstruction Thus there are times where you may want to specify specific dtypes via the keyword argument. Don’t convert any data (but still convert axes and dates): Dates written in nanoseconds need to be read back in nanoseconds: # Try to parse timestamps as milliseconds -> Won't Work # Or specify that all timestamps are in nanoseconds By setting the argument you can control the default dtypes used for the resulting DataFrame. pandas provides a utility function to take a dict or list of dicts and this semi-structured data into a flat table. The max_level parameter provides more control over which level to end normalization. With max_level=1 the following snippet normalizes until 1st nesting level of the provided dict. pandas is able to read and write line-delimited json files that are common in data processing pipelines using Hadoop or Spark. For line-delimited json files, pandas can also return an iterator which reads in lines at a time. This can be useful for large files or to read from a stream. # reader is an iterator that returns ``chunksize`` lines each iteration Line-limited json can also be read using the pyarrow reader by specifying . Table Schema is a spec for describing tabular datasets as a JSON object. The JSON includes information on the field names, types, and other attributes. You can use the orient to build a JSON string with two fields, and . The field contains the key, which itself contains a list of column name to type pairs, including the or (see below for a list of types). The field also contains a field if the (Multi)index is unique. The second field, , contains the serialized data with the orient. The index is included, and any datetimes are ISO 8601 formatted, as required by the Table Schema spec. The full list of types supported are described in the Table Schema spec. This table shows the mapping from pandas types: A few notes on the generated table schema:\n• None The object contains a field. This contains the version of pandas’ dialect of the schema, and will be incremented with each revision.\n• None All dates are converted to UTC when serializing. Even timezone naive values, which are treated as UTC with an offset of 0.\n• None datetimes with a timezone (before serializing), include an additional field with the time zone name (e.g. ).\n• None Periods are converted to timestamps before serialization, and so have the same behavior of being converted to UTC. In addition, periods will contain and additional field with the period’s frequency, e.g. .\n• None Categoricals use the type and an constraint listing the set of possible values. Additionally, an field is included:\n• None A field, containing an array of labels, is included if the index is unique :\n• None The behavior is the same with MultiIndexes, but in this case the is an array:\n• None The default naming roughly follows these rules:\n• None For series, the is used. If that’s none, then the name is\n• None For , the stringified version of the column name is used\n• None For (not ), is used, with a fallback to if that is None.\n• None For , is used. If any level has no name, then is used. also accepts as an argument. This allows for the preservation of metadata such as dtypes and index names in a round-trippable manner. Please note that the literal string ‘index’ as the name of an is not round-trippable, nor are any names beginning with within a . These are used by default in to indicate missing values and the subsequent read cannot distinguish the intent. When using along with user-defined , the generated schema will contain an additional key in the respective element. This extra key is not standard but does enable JSON roundtrips for extension types (e.g. ). The key carries the name of the extension, if you have properly registered the , pandas will use said name to perform a lookup into the registry and re-convert the serialized data into your custom dtype.\n\nThe method can read Excel 2007+ ( ) files using the Python module. Excel 2003 ( ) files can be read using . Binary Excel ( ) files can be read using . All formats can be read using engine. The instance method is used for saving a to Excel. Generally the semantics are similar to working with data. See the for some advanced strategies. When , the following logic will be used to determine the engine:\n• None If is an OpenDocument format (.odf, .ods, .odt), then odf will be used.\n• None Otherwise if is an xls format, will be used.\n• None Otherwise if is in xlsb format, will be used.\n• None Otherwise will be used. In the most basic use-case, takes a path to an Excel file, and the indicating which sheet to parse. When using the parameter, pandas will pass these arguments to the engine. For this, it is important to know which function pandas is using internally.\n• None For the engine openpyxl, pandas is using to read in ( ) and ( ) files.\n• None For the engine xlrd, pandas is using to read in ( ) files.\n• None For the engine pyxlsb, pandas is using to read in ( ) files.\n• None For the engine odf, pandas is using to read in ( ) files.\n• None For the engine calamine, pandas is using to read in ( ), ( ), ( ), ( ), ( ) files. To facilitate working with multiple sheets from the same file, the class can be used to wrap the file and can be passed into There will be a performance benefit for reading multiple sheets as the file is read into memory only once. The class can also be used as a context manager. The property will generate a list of the sheet names in the file. The primary use-case for an is parsing multiple sheets with different parameters: # For when Sheet1's format differs from Sheet2 Note that if the same parsing parameters are used for all sheets, a list of sheet names can simply be passed to with no loss in performance. can also be called with a object as a parameter. This allows the user to control how the excel file is read. For example, sheets can be loaded on demand by calling with . The second argument is , not to be confused with . An ExcelFile’s attribute provides access to a list of sheets.\n• None The arguments allows specifying the sheet or sheets to read.\n• None The default value for is 0, indicating to read the first sheet\n• None Pass a string to refer to the name of a particular sheet in the workbook.\n• None Pass an integer to refer to the index of a sheet. Indices follow Python convention, beginning at 0.\n• None Pass a list of either strings or integers, to return a dictionary of specified sheets.\n• None Pass a to return a dictionary of all available sheets. Using None to get all sheets: Using a list to get multiple sheets: # Returns the 1st and 4th sheet, as a dictionary of DataFrames. can read more than one sheet, by setting to either a list of sheet names, a list of sheet positions, or to read all sheets. Sheets can be specified by sheet index or sheet name, using an integer or string, respectively. can read a index, by passing a list of columns to and a column by passing a list of rows to . If either the or have serialized level names those will be read in as well by specifying the rows/columns that make up the levels. For example, to read in a index without names: If the index has level names, they will parsed as well, using the same parameters. If the source file has both index and columns, lists specifying each should be passed to and : Missing values in columns specified in will be forward filled to allow roundtripping with for . To avoid forward filling the missing values use after reading the data instead of . It is often the case that users will insert columns to do temporary computations in Excel and you may not want to read in those columns. takes a keyword to allow you to specify a subset of columns to parse. You can specify a comma-delimited set of Excel columns and ranges as a string: If is a list of integers, then it is assumed to be the file column indices to be parsed. Element order is ignored, so is the same as . If is a list of strings, it is assumed that each string corresponds to a column name provided either by the user in or inferred from the document header row(s). Those strings define which columns will be parsed: Element order is ignored, so is the same as . If is callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to . Datetime-like values are normally automatically converted to the appropriate dtype when reading the excel file. But if you have a column of strings that like dates (but are not actually formatted as dates in excel), you can use the keyword to parse those strings to datetimes: It is possible to transform the contents of Excel cells via the option. For instance, to convert a column to boolean: This options handles missing values and treats exceptions in the converters as missing data. Transformations are applied cell by cell rather than to the column as a whole, so the array dtype is not guaranteed. For instance, a column of integers with missing values cannot be transformed to an array with integer dtype, because NaN is strictly a float. You can manually mask missing data to recover integer dtype: As an alternative to converters, the type for an entire column can be specified using the keyword, which takes a dictionary mapping column names to types. To interpret data with no type inference, use the type or . To write a object to a sheet of an Excel file, you can use the instance method. The arguments are largely the same as described above, the first argument being the name of the excel file, and the optional second argument the name of the sheet to which the should be written. For example: Files with a extension will be written using (if available) or . The will be written in a way that tries to mimic the REPL output. The will be placed in the second row instead of the first. You can place it in the first row by setting the option in to : In order to write separate to separate sheets in a single Excel file, one can pass an . When using the parameter, pandas will pass these arguments to the engine. For this, it is important to know which function pandas is using internally.\n• None For the engine openpyxl, pandas is using to create a new sheet and to append data to an existing sheet. The openpyxl engine writes to ( ) and ( ) files.\n• None For the engine xlsxwriter, pandas is using to write to ( ) files.\n• None For the engine odf, pandas is using to write to ( ) files. pandas supports writing Excel files to buffer-like objects such as or using . # By setting the 'engine' in the ExcelWriter constructor. # Seek to the beginning and read to copy the workbook to a variable in memory is optional but recommended. Setting the engine determines the version of workbook produced. Setting will produce an Excel 2003-format workbook (xls). Using either or will produce an Excel 2007-format workbook (xlsx). If omitted, an Excel 2007-formatted workbook is produced. pandas chooses an Excel writer via two methods:\n• None the filename extension (via the default specified in config options) By default, pandas uses the XlsxWriter for , openpyxl for . If you have multiple engines installed, you can set the default engine through and . pandas will fall back on openpyxl for files if Xlsxwriter is not available. To specify which writer you want to use, you can pass an engine keyword argument to and to . The built-in engines are: # By setting the 'engine' in the DataFrame 'to_excel()' methods. # By setting the 'engine' in the ExcelWriter constructor. The look and feel of Excel worksheets created from pandas can be modified using the following parameters on the ’s method.\n• None : A tuple of two integers representing the bottommost row and rightmost column to freeze. Each of these parameters is one-based, so (1, 1) will freeze the first row and first column (default ). Using the Xlsxwriter engine provides many options for controlling the format of an Excel worksheet created with the method. Excellent examples can be found in the Xlsxwriter documentation here: https://xlsxwriter.readthedocs.io/working_with_pandas.html\n\nis a dict-like object which reads and writes pandas using the high performance HDF5 format using the excellent PyTables library. See the for some advanced strategies pandas uses PyTables for reading and writing HDF5 files, which allows serializing object-dtype data with pickle. Loading pickled data received from untrusted sources can be unsafe. See: https://docs.python.org/3/library/pickle.html for more. Objects can be written to the file just like adding key-value pairs to a dict: In a current or later Python session, you can retrieve stored objects: # dotted (attribute) access provides get as well Deletion of the object specified by the key: # Working with, and automatically closing the store using a context manager supports a top-level API using for reading and for writing, similar to how and work. HDFStore will by default not drop rows that are all missing. This behavior can be changed by setting . The examples above show storing using , which write the HDF5 to in a fixed array format, called the format. These types of stores are not appendable once written (though you can simply remove them and rewrite). Nor are they queryable; they must be retrieved in their entirety. They also do not support dataframes with non-unique column names. The format stores offer very fast writing and slightly faster reading than stores. This format is specified by default when using or or by or . A format will raise a if you try to retrieve using a : Traceback (most recent call last) in \"key must be provided when HDF5 \" # if there is an error, close the store if we opened it. in in in in # start, stop applied to rows, so 0th axis only in \"a Fixed format store. this store must be selected in its entirety\" \"cannot pass a where specification when reading \" \"from a Fixed format store. this store must be selected in its entirety\" : cannot pass a where specification when reading from a Fixed format store. this store must be selected in its entirety supports another format on disk, the format. Conceptually a is shaped very much like a DataFrame, with rows and columns. A may be appended to in the same or other sessions. In addition, delete and query type operations are supported. This format is specified by or to or or . This format can be set as an option as well to enable to by default store in the format. You can also create a by passing or to a operation. Keys to a store can be specified as a string. These can be in a hierarchical path-name like format (e.g. ), which will generate a hierarchy of sub-stores (or in PyTables parlance). Keys can be specified without the leading ‘/’ and are always absolute (e.g. ‘foo’ refers to ‘/foo’). Removal operations can remove everything in the sub-store and below, so be . # remove all nodes under this level You can walk through the group hierarchy using the method which will yield a tuple for each group key along with the relative keys of its contents. Hierarchical keys cannot be retrieved as dotted (attribute) access as described above for items stored under the root node. Traceback (most recent call last) in \"\"\"allow attribute access to get stores\"\"\" in in in \"cannot create a storer if the object is not existing \" \"nor a value are passed\" : cannot create a storer if the object is not existing nor a value are passed # you can directly access the actual PyTables node but using the root node Storing mixed-dtype data is supported. Strings are stored as a fixed-width using the maximum size of the appended column. Subsequent attempts at appending longer strings will raise a . Passing as a parameter to append will set a larger minimum for the string columns. Storing are currently supported. For string columns, passing to append will change the default nan representation on disk (which converts to/from ), this defaults to . Storing MultiIndex as tables is very similar to storing/selecting from homogeneous index . # the levels are automatically included as data columns The keyword is reserved and cannot be use as a level name. and operations have an optional criterion that can be specified to select/delete only a subset of the data. This allows one to have a very large on-disk table and retrieve only a portion of the data. A query is specified using the class under the hood, as a boolean expression.\n• None and are supported indexers of .\n• None if are specified, these can be used as additional indexers.\n• None level name in a MultiIndex, with default name , , … if not provided. These rules are similar to how boolean expressions are used in pandas for indexing.\n• None will be automatically expanded to the comparison operator\n• None is the not operator, but can only be used in very limited circumstances\n• None If a list/tuple of expressions is passed they will be combined via The following are valid expressions: The are on the left-hand side of the sub-expression: The right-hand side of the sub-expression (after a comparison operator) can be:\n• None functions that will be evaluated, e.g.\n• None variables that are defined in the local names space, e.g. Passing a string to a query by interpolating it into the query expression is not recommended. Simply assign the string of interest to a variable and use that variable in an expression. For example, do this The latter will not work and will raise a .Note that there’s a single quote followed by a double quote in the variable. If you interpolate, use the format specifier which will quote . The keyword can be supplied to select a list of columns to be returned, this is equivalent to passing a : and parameters can be specified to limit the total search space. These are in terms of the total number of rows in a table. will raise a if the query expression has an unknown variable reference. Usually this means that you are trying to select on a column that is not a data_column. will raise a if the query expression is not valid. You can store and query using the type. Terms can be specified in the format: , where float may be signed (and fractional), and unit can be for the timedelta. Here’s an example: Selecting from a can be achieved by using the name of the level. If the levels names are , the levels are automatically made available via the keyword with the level of the you want to select from. # the levels are automatically included as data columns with keyword level_n You can create/modify an index for a table with after data is already in the table (after and operation). Creating a table index is highly encouraged. This will speed your queries a great deal when you use a with the indexed dimension as the . Indexes are automagically created on the indexables and any data columns you specify. This behavior can be turned off by passing to . # we have automagically already created an index (in the first section) # change an index by passing new parameters Oftentimes when appending large amounts of data to a store, it is useful to turn off index creation for each append, then recreate at the end. Then create the index when finished appending. See here for how to create a completely-sorted-index (CSI) on an existing store. You can designate (and index) certain columns that you want to be able to perform queries (other than the columns, which you can always query). For instance say you want to perform this common operation, on-disk, and return just the frame that matches this query. You can specify to force all columns to be . # this is in-memory version of this type of selection # we have automagically created this index and the B/C/string/string2 There is some performance degradation by making lots of columns into , so it is up to the user to designate these. In addition, you cannot change data columns (nor indexables) after the first append/put operation (Of course you can simply read in the data and create a new table!). You can pass or to and to return an iterator on the results. The default is 50,000 rows returned in a chunk. You can also use the iterator with which will open, then automatically close the store when finished iterating. Note, that the chunksize keyword applies to the source rows. So if you are doing a query, then the chunksize will subdivide the total rows in the table and the query applied, returning an iterator on potentially unequal sized chunks. Here is a recipe for generating a query and using it to create equal sized return chunks. To retrieve a single indexable or data column, use the method . This will, for example, enable you to get the index very quickly. These return a of the result, indexed by the row number. These do not currently accept the selector. Sometimes you want to get the coordinates (a.k.a the index locations) of your query. This returns an of the resulting locations. These coordinates can also be passed to subsequent operations. Sometime your query can involve creating a list of rows to select. Usually this would be a resulting from an indexing operation. This example selects the months of a datetimeindex which are 5. If you want to inspect the stored object, retrieve via . You could use this programmatically to say get the number of rows in an object. The methods and can perform appending/selecting from multiple tables at once. The idea is to have one table (call it the selector table) that you index most/all of the columns, and perform your queries. The other table(s) are data tables with an index matching the selector table’s index. You can then perform a very fast query on the selector table, yet get lots of data back. This method is similar to having a very wide table, but enables more efficient queries. The method splits a given single DataFrame into multiple tables according to , a dictionary that maps the table names to a list of ‘columns’ you want in that table. If is used in place of a list, that table will have the remaining unspecified columns of the given DataFrame. The argument defines which table is the selector table (which you can make queries from). The argument will drop rows from the input to ensure tables are synchronized. This means that if a row for one of the tables being written to is entirely , that row will be dropped from all tables. If is False, THE USER IS RESPONSIBLE FOR SYNCHRONIZING THE TABLES. Remember that entirely rows are not written to the HDFStore, so if you choose to call , some tables may have more rows than others, and therefore may not work or it may return unexpected results. # you can also create the tables individually You can delete from a table selectively by specifying a . In deleting rows, it is important to understand the deletes rows by erasing the rows, then moving the following data. Thus deleting can potentially be a very expensive operation depending on the orientation of your data. To get optimal performance, it’s worthwhile to have the dimension you are deleting be the first of the . Data is ordered (on the disk) in terms of the . Here’s a simple use case. You store panel-type data, with dates in the and ids in the . The data is then interleaved like this: It should be clear that a delete operation on the will be fairly quick, as one chunk is removed, then the following data moved. On the other hand a delete operation on the will be very expensive. In this case it would almost certainly be faster to rewrite the table using a that selects all but the missing data. Please note that HDF5 DOES NOT RECLAIM SPACE in the h5 files automatically. Thus, repeatedly deleting (or removing nodes) and adding again, WILL TEND TO INCREASE THE FILE SIZE. To the file, use . allows the stored data to be compressed. This applies to all kinds of stores, not just tables. Two parameters are used to control compression: and .\n• None specifies if and how hard data is to be compressed. and disables compression and enables compression.\n• None specifies which compression library to use. If nothing is specified the default library is used. A compression library usually optimizes for either good compression rates or speed and the results will depend on the type of data. Which type of compression to choose depends on your specific needs and data. The list of supported compression libraries:\n• None zlib: The default compression library. A classic in terms of compression, achieves good compression rates but is somewhat slow.\n• \n• None blosc:blosclz This is the default compressor for\n• None blosc:lz4hc: A tweaked version of LZ4, produces better compression ratios at the expense of speed.\n• None blosc:snappy: A popular compressor used in many places.\n• None blosc:zlib: A classic; somewhat slower than the previous ones, but achieving better compression ratios.\n• None blosc:zstd: An extremely well balanced codec; it provides the best compression ratios among the others above, and at reasonably fast speed. If is defined as something other than the listed libraries a exception is issued. If the library specified with the option is missing on your platform, compression defaults to without further ado. Enable compression for all objects within the file: Or on-the-fly compression (this only applies to tables) in stores where compression is not enabled: offers better write performance when tables are compressed after they are written, as opposed to turning on compression at the very beginning. You can use the supplied utility . In addition, can change compression levels after the fact. Furthermore will the file to allow you to reuse previously deleted space. Alternatively, one can simply remove the file and write again, or use the method. is not-threadsafe for writing. The underlying only supports concurrent reads (via threading or processes). If you need reading and writing at the same time , you need to serialize these operations in a single thread in a single process. You will corrupt your data otherwise. See the (GH 2397) for more information.\n• None If you use locks to manage write access between multiple processes, you may want to use before releasing write locks. For convenience you can use to do this for you.\n• None Once a is created columns (DataFrame) are fixed; only exactly the same columns can be appended\n• None Be aware that timezones (e.g., ) are not necessarily equal across timezone versions. So if data is localized to a specific timezone in the HDFStore using one version of a timezone library and that data is updated with another version, the data will be converted to UTC since these timezones are not considered equal. Either use the same version of timezone library or use with the updated timezone definition. will show a if a column name cannot be used as an attribute selector. identifiers contain only letters, numbers, and underscores, and may not begin with a number. Other identifiers cannot be used in a clause and are generally a bad idea. will map an object dtype to the underlying dtype. This means the following types are known to work: categorical : see the section below columns are not supported, and WILL FAIL. You can write data that contains dtypes to a . Queries work the same as if it was an object array. However, the dtyped data is stored in a more efficient manner. The underlying implementation of uses a fixed column width (itemsize) for string columns. A string column itemsize is calculated as the maximum of the length of data (for that column) that is passed to the , in the first append. Subsequent appends, may introduce a string for a column larger than the column can hold, an Exception will be raised (otherwise you could have a silent truncation of these columns, leading to loss of information). In the future we may relax this and allow a user-specified truncation to occur. Pass on the first table creation to a-priori specify the minimum length of a particular string column. can be an integer, or a dict mapping a column name to an integer. You can pass as a key to allow all or to have this min_itemsize. Passing a dict will cause all passed columns to be created as automatically. If you are not passing any , then the will be the maximum of the length of any string passed # A and B have a size of 30 # A is created as a data_column with a size of 30 String columns will serialize a (a missing value) with the string representation. This defaults to the string value . You could inadvertently turn an actual value into a missing value. # here you need to specify a different nan rep\n• None format come with a writing performance penalty as compared to stores. The benefit is the ability to append/delete and query (potentially very large amounts of data). Write times are generally longer as compared with regular stores. Query times can be quite fast, especially on an indexed axis.\n• None You can pass to , specifying the write chunksize (default is 50000). This will significantly lower your memory usage on writing.\n• None You can pass to the first , to set the TOTAL number of rows that will expect. This will optimize read/write performance.\n• None Duplicate rows can be written to tables, but are filtered out in selection (with the last items being selected; thus a table is unique on major, minor pairs)\n• None A will be raised if you are attempting to store types that will be pickled by PyTables (rather than stored as endemic types). See Here for more information and some solutions.\n\nThe module provides a collection of query wrappers to both facilitate data retrieval and to reduce dependency on DB-specific API. Where available, users may first want to opt for Apache Arrow ADBC drivers. These drivers should provide the best performance, null handling, and type detection. For a full list of ADBC drivers and their development status, see the ADBC Driver Implementation Status documentation. Where an ADBC driver is not available or may be missing functionality, users should opt for installing SQLAlchemy alongside their database driver library. Examples of such drivers are psycopg2 for PostgreSQL or pymysql for MySQL. For SQLite this is included in Python’s standard library by default. You can find an overview of supported drivers for each SQL dialect in the SQLAlchemy docs. If SQLAlchemy is not installed, you can use a in place of a SQLAlchemy engine, connection, or URI string. See also some for some advanced strategies. The function is a convenience wrapper around and (and for backward compatibility) and will delegate to specific function depending on the provided input (database table name or sql query). Table names do not need to be quoted if they have special characters. In the following example, we use the SQlite SQL database engine. You can use a temporary SQLite database where data are stored in “memory”. To connect using an ADBC driver you will want to install the using your package manager. Once installed, you can use the DBAPI interface provided by the ADBC driver to connect to your database. To connect with SQLAlchemy you use the function to create an engine object from database URI. You only need to create the engine once per database you are connecting to. For more information on and the URI formatting, see the examples below and the SQLAlchemy documentation If you want to manage your own connections you can pass one of those instead. The example below opens a connection to the database using a Python context manager that automatically closes the connection after the block has completed. See the SQLAlchemy docs for an explanation of how the database connection is handled. When you open a connection to a database you are also responsible for closing it. Side effects of leaving a connection open may include locking the database or other breaking behaviour. Assuming the following data is in a , we can insert it into the database using . With some databases, writing large DataFrames can result in errors due to packet size limitations being exceeded. This can be avoided by setting the parameter when calling . For example, the following writes to the database in batches of 1000 rows at a time: Ensuring consistent data type management across SQL databases is challenging. Not every SQL database offers the same types, and even when they do the implementation of a given type can vary in ways that have subtle effects on how types can be preserved. For the best odds at preserving database types users are advised to use ADBC drivers when available. The Arrow type system offers a wider array of types that more closely match database types than the historical pandas/NumPy type system. To illustrate, note this (non-exhaustive) listing of types available in different databases and pandas backends: Not implemented as of writing, but theoretically possible If you are interested in preserving database types as best as possible throughout the lifecycle of your DataFrame, users are encouraged to leverage the argument of This will prevent your data from being converted to the traditional pandas/NumPy type system, which often converts SQL types in ways that make them impossible to round-trip. In case an ADBC driver is not available, will try to map your data to an appropriate SQL data type based on the dtype of the data. When you have columns of dtype , pandas will try to infer the data type. You can always override the default type by specifying the desired SQL type of any of the columns by using the argument. This argument needs a dictionary mapping column names to SQLAlchemy types (or strings for the sqlite3 fallback mode). For example, specifying to use the sqlalchemy type instead of the default type for string columns: Due to the limited support for timedelta’s in the different database flavors, columns with type will be written as integer values as nanoseconds to the database and a warning will be raised. The only exception to this is when using the ADBC PostgreSQL driver in which case a timedelta will be written to the database as an Columns of dtype will be converted to the dense representation as you would get with (e.g. for string categories this gives an array of strings). Because of this, reading the database table back in does not generate a categorical. Using ADBC or SQLAlchemy, is capable of writing datetime data that is timezone naive or timezone aware. However, the resulting data stored in the database ultimately depends on the supported data type for datetime data of the database system being used. The following table lists supported data types for datetime data for some common databases. Other database dialects may have different data types for datetime data. When writing timezone aware data to databases that do not support timezones, the data will be written as timezone naive timestamps that are in local time with respect to the timezone. is also capable of reading datetime data that is timezone aware or naive. When reading types, pandas will convert the data to UTC. The parameter controls the SQL insertion clause used. Possible values are:\n• None : Uses standard SQL clause (one per row).\n• None : Pass multiple values in a single clause. It uses a SQL syntax not supported by all backends. This usually provides better performance for analytic databases like and , but has worse performance for traditional SQL backend if the table contains many columns. For more information check the SQLAlchemy documentation.\n• None callable with signature : This can be used to implement a more performant insertion method based on specific backend dialect features. Example of a callable using PostgreSQL COPY clause: # Alternative to_sql() *method* for DBs that support COPY FROM data_iter : Iterable that iterates the values to be inserted # gets a DBAPI connection that can provide a cursor will read a database table given the table name and optionally a subset of columns to read. In order to use , you must have the ADBC driver or SQLAlchemy optional dependency installed. ADBC drivers will map database types directly back to arrow types. For other drivers note that pandas infers column dtypes from query outputs, and not by looking up data types in the physical database schema. For example, assume is an integer column in a table. Then, intuitively, will return integer-valued series, while will return object-valued (str) series. Accordingly, if the query output is empty, then all resulting columns will be returned as object-valued (since they are most general). If you foresee that your query will sometimes generate an empty result, you may want to explicitly typecast afterwards to ensure dtype integrity. You can also specify the name of the column as the index, and specify a subset of columns to be read. And you can explicitly force columns to be parsed as dates: If needed you can explicitly specify a format string, or a dict of arguments to pass to : You can check if a table exists using Reading from and writing to different schema’s is supported through the keyword in the and functions. Note however that this depends on the database flavor (sqlite does not have schema’s). For example: You can query using raw SQL in the function. In this case you must use the SQL variant appropriate for your database. When using SQLAlchemy, you can also pass SQLAlchemy Expression language constructs, which are database-agnostic. Of course, you can specify a more “complex” query. The function supports a argument. Specifying this will return an iterator through chunks of the query result: To connect with SQLAlchemy you use the function to create an engine object from database URI. You only need to create the engine once per database you are connecting to. For more information see the examples the SQLAlchemy documentation You can use SQLAlchemy constructs to describe your query. Use to specify query parameters in a backend-neutral way If you have an SQLAlchemy description of your database you can express where conditions using SQLAlchemy expressions You can combine SQLAlchemy expressions with parameters passed to using The use of sqlite is supported without using SQLAlchemy. This mode requires a Python database adapter which respect the Python DB-API. You can create connections like so: And then issue the following queries:"
    },
    {
        "link": "https://pandas.pydata.org/docs/dev/reference/api/pandas.read_csv.html",
        "document": "Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, gs, and file. For file URLs, a host is expected. A local file could be: file://localhost/path/to/table.csv. If you want to pass in a path object, pandas accepts any . By file-like object, we refer to objects with a method, such as a file handle (e.g. via builtin function) or .\n\nCharacter or regex pattern to treat as the delimiter. If , the C engine cannot automatically detect the separator, but the Python parsing engine can, meaning the latter will be used and automatically detect the separator from only the first valid row of the file by Python’s builtin sniffer tool, . In addition, separators longer than 1 character and different from will be interpreted as regular expressions and will also force the use of the Python parsing engine. Note that regex delimiters are prone to ignoring quoted data. Regex example: .\n\nRow number(s) containing column labels and marking the start of the data (zero-indexed). Default behavior is to infer the column names: if no are passed the behavior is identical to and column names are inferred from the first line of the file, if column names are passed explicitly to then the behavior is identical to . Explicitly pass to be able to replace existing names. The header can be a list of integers that specify row locations for a on the columns e.g. . Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if , so denotes the first line of data rather than the first line of the file. When inferred from the file contents, headers are kept distinct from each other by renaming duplicate names with a numeric suffix of the form starting from 1, e.g. and . Empty headers are named or in the case of MultiIndex columns.\n\nColumn(s) to use as row label(s), denoted either by column labels or column indices. If a sequence of labels or indices is given, will be formed for the row labels. Note: can be used to force pandas to not use the first column as the index, e.g., when you have a malformed file with delimiters at the end of each line.\n\nSubset of columns to select, denoted either by column labels or column indices. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in or inferred from the document header row(s). If are given, the document header row(s) are not taken into account. For example, a valid list-like parameter would be or . Element order is ignored, so is the same as . To instantiate a from with element order preserved use for columns in order or for order. If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to . An example of a valid callable argument would be . Using this parameter results in much faster parsing time and lower memory usage.\n\nWhether or not to include the default values when parsing the data. Depending on whether is passed in, the behavior is as follows:\n• None If is , and are specified, is appended to the default values used for parsing.\n• None If is , and are not specified, only the default values are used for parsing.\n• None If is , and are specified, only the values specified are used for parsing.\n• None If is , and are not specified, no strings will be parsed as . Note that if is passed in as , the and parameters will be ignored.\n\nFor on-the-fly decompression of on-disk data. If ‘infer’ and ‘filepath_or_buffer’ is path-like, then detect compression from the following extensions: ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, ‘.tar’, ‘.tar.gz’, ‘.tar.xz’ or ‘.tar.bz2’ (otherwise no compression). If using ‘zip’ or ‘tar’, the ZIP file must contain only one data file to be read in. Set to for no decompression. Can also be a dict with key set to one of { , , , , , } and other key-value pairs are forwarded to , , , , or , respectively. As an example, the following could be passed for Zstandard decompression using a custom compression dictionary: ."
    },
    {
        "link": "https://stackoverflow.com/questions/20906474/import-multiple-csv-files-into-pandas-and-concatenate-into-one-dataframe",
        "document": "I guess I need some help within the for loop?\n\nI would like to read several CSV files from a directory into pandas and concatenate them into one big DataFrame. I have not been able to figure it out though. Here is what I have so far:\n\nSee pandas: IO tools for all of the available methods. Try the following code if all of the CSV files have the same columns. I have added , so that after reading the CSV file's first row, it can be assigned as the column names. import pandas as pd import glob import os path = r'C:\\DRO\\DCL_rawdata_files' # use your path all_files = glob.glob(os.path.join(path , \"/*.csv\")) li = [] for filename in all_files: df = pd.read_csv(filename, index_col=None, header=0) li.append(df) frame = pd.concat(li, axis=0, ignore_index=True) Or, with attribution to a comment from Sid.\n• It's often necessary to identify each sample of data, which can be accomplished by adding a new column to the dataframe.\n• from the standard library will be used for this example. It treats paths as objects with methods, instead of strings to be sliced. from pathlib import Path import pandas as pd import numpy as np path = r'C:\\DRO\\DCL_rawdata_files' # or unix / linux / mac path # Get the files from the path provided in the OP files = Path(path).glob('*.csv') # .rglob to get subdirectories\n• Add a new column with the file name dfs = list() for f in files: data = pd.read_csv(f) # .stem is method for pathlib objects to get the filename w/o the extension data['file'] = f.stem dfs.append(data) df = pd.concat(dfs, ignore_index=True)\n• Add a new column with a generic name using\n• Create the dataframes with a list comprehension, and then use to add a new column.\n• creates a list of strings to name each dataframe.\n• Attribution for this option goes to this plotting answer. # Read the files into dataframes dfs = [pd.read_csv(f) for f in files] # Combine the list of dataframes df = pd.concat(dfs, ignore_index=True) # Add a new column df['Source'] = np.repeat([f'S{i}' for i in range(len(dfs))], [len(df) for df in dfs])\n• One liners using to create the new column, with attribution to a comment from C8H10N4O2\n\nAlmost all of the answers here are either unnecessarily complex (glob pattern matching) or rely on additional third-party libraries. You can do this in two lines using everything Pandas and Python (all versions) already have built in. import os filepaths = [f for f in os.listdir(\".\") if f.endswith('.csv')] df = pd.concat(map(pd.read_csv, filepaths)) If you have specific things you want to change with pd.read_csv (i.e., no headers) you can make a separate function and call that with your map: This pandas line, which sets the df, utilizes three things:\n• Python's map (function, iterable) sends to the function (the ) the iterable (our list) which is every CSV element in filepaths).\n• Panda's read_csv() function reads in each CSV file as normal.\n• Panda's concat() brings all these under one df variable.\n\nI googled my way into Gaurav Singh's answer. However, as of late, I am finding it faster to do any manipulation using NumPy and then assigning it once to a dataframe rather than manipulating the dataframe itself on an iterative basis and it seems to work in this solution too. I do sincerely want anyone hitting this page to consider this approach, but I don't want to attach this huge piece of code as a comment and making it less readable. You can leverage NumPy to really speed up the dataframe concatenation. import os import glob import pandas as pd import numpy as np path = \"my_dir_full_path\" allFiles = glob.glob(os.path.join(path,\"*.csv\")) np_array_list = [] for file_ in allFiles: df = pd.read_csv(file_,index_col=None, header=0) np_array_list.append(df.as_matrix()) comb_np_array = np.vstack(np_array_list) big_frame = pd.DataFrame(comb_np_array) big_frame.columns = [\"col1\", \"col2\"....] total files :192 avg lines per file :8492 --approach 1 without NumPy -- 8.248656988143921 seconds --- total records old :1630571 --approach 2 with NumPy -- 2.289292573928833 seconds ---\n\nIf you want to search recursively (Python 3.5 or above), you can do the following: from glob import iglob import pandas as pd path = r'C:\\user\\your\\path\\**\\*.csv' all_rec = iglob(path, recursive=True) dataframes = (pd.read_csv(f) for f in all_rec) big_dataframe = pd.concat(dataframes, ignore_index=True) Note that the three last lines can be expressed in one single line: You can find the documentation of here. Also, I used instead of , as it returns an iterator instead of a list. You can wrap the above into a multiplatform function (Linux, Windows, Mac), so you can do: from glob import iglob from os.path import join import pandas as pd def read_df_rec(path, fn_regex=r'*.csv'): return pd.concat((pd.read_csv(f) for f in iglob( join(path, '**', fn_regex), recursive=True)), ignore_index=True)\n• None By default, the list of files generated through is not sorted. On the other hand, in many scenarios, it's required to be sorted e.g. one may want to analyze number of sensor-frame-drops v/s timestamp.\n• None In command, if is not specified then it reserves the original indices from each dataframes (i.e. each individual CSV file in the list) and the main dataframe looks like With , it looks like: IMO, this is helpful when one may want to manually create a histogram of number of frame drops v/s one minutes (or any other duration) bins and want to base the calculation on very first timestamp e.g. Without, , generates the series containing very first timestamp from all the individual dataframes, it does not give just a value.\n\nTo identify issues of missing or unaligned columns Before concatenating, you can load CSV files into an intermediate dictionary which gives access to each data set based on the file name (in the form ). Such a dictionary can help you identify issues with heterogeneous data formats, when column names are not aligned for example. Note: is not necessary, but it'll keep the order of files which might be useful for analysis. Keys are file names and values are the data frame content of CSV files. Instead of using as a dictionary key, you can also use or other os.path methods to reduce the size of the key in the dictionary to only the smaller part that is relevant.\n\nConsider using convtools library, which provides lots of data processing primitives and generates simple ad hoc code under the hood. It is not supposed to be faster than pandas/polars, but sometimes it can be. e.g. you could concat csv files into one for further reuse - here's the code: import glob from convtools import conversion as c from convtools.contrib.tables import Table import pandas as pd def test_pandas(): df = pd.concat( ( pd.read_csv(filename, index_col=None, header=0) for filename in glob.glob(\"tmp/*.csv\") ), axis=0, ignore_index=True, ) df.to_csv(\"out.csv\", index=False) # took 20.9 s def test_convtools(): table = None for filename in glob.glob(\"tmp/*.csv\"): table_ = Table.from_csv(filename, header=False) if table is None: table = table_ else: table = table.chain(table_) table.into_csv(\"out_convtools.csv\", include_header=False) # took 15.8 s Of course if you just want to obtain a dataframe without writing a concatenated file, it will take and correspondingly (pandas is faster here because it doesn't need to zip columns for writing it back)."
    },
    {
        "link": "https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_csv.html",
        "document": "String, path object (implementing os.PathLike[str]), or file-like object implementing a write() function. If None, the result is returned as a string. If a non-binary file object is passed, it should be opened with , disabling universal newlines. If a binary file object is passed, might need to contain a .\n\nWrite out the column names. If a list of strings is given it is assumed to be aliases for the column names.\n\nColumn label for index column(s) if desired. If None is given, and and are True, then the index names are used. A sequence should be given if the object uses MultiIndex. If False do not print fields for index names. Use index_label=False for easier importing in R.\n\nFor on-the-fly compression of the output data. If ‘infer’ and ‘path_or_buf’ is path-like, then detect compression from the following extensions: ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, ‘.tar’, ‘.tar.gz’, ‘.tar.xz’ or ‘.tar.bz2’ (otherwise no compression). Set to for no compression. Can also be a dict with key set to one of { , , , , , } and other key-value pairs are forwarded to , , , , or , respectively. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: . May be a dict with key ‘method’ as compression mode and other entries as additional compression options if compression mode is ‘zip’. Passing compression options as keys in dict is supported for compression modes ‘gzip’, ‘bz2’, ‘zstd’, and ‘zip’.\n\nDefaults to csv.QUOTE_MINIMAL. If you have set a then floats are converted to strings and thus csv.QUOTE_NONNUMERIC will treat them as non-numeric.\n\nThe newline character or character sequence to use in the output file. Defaults to , which depends on the OS in which this method is called (’\n\n’ for linux, ‘\\r\n\n’ for Windows, i.e.). Changed in version 1.5.0: Previously was line_terminator, changed for consistency with read_csv and the standard library ‘csv’ module.\n\nExtra options that make sense for a particular storage connection, e.g. host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to as header options. For other URLs (e.g. starting with “s3://”, and “gcs://”) the key-value pairs are forwarded to . Please see and for more details, and for more examples on storage options refer here."
    },
    {
        "link": "https://pandas.pydata.org/docs/user_guide/merging.html",
        "document": "pandas provides various methods for combining and comparing or .\n• None : Merge multiple or objects along a shared index or column\n• None : Update missing values with non-missing values in the same location\n• None : Combine two or objects with SQL-style joining\n• None : Combine two or objects along an ordered axis\n• None : Combine two or objects by near instead of exact matching keys\n• None and : Show differences in values between two or objects\n\nThe function concatenates an arbitrary amount of or objects along an axis while performing optional set logic (union or intersection) of the indexes on the other axes. Like , takes a list or dict of homogeneously-typed objects and concatenates them. makes a full copy of the data, and iteratively reusing can create unnecessary copies. Collect all or objects in a list before using . When concatenating with named axes, pandas will attempt to preserve these index/column names whenever possible. In the case where all inputs share a common name, this name will be assigned to the result. When the input names do not all agree, the result will be unnamed. The same is true for , but the logic is applied separately on a level-by-level basis. The keyword specifies how to handle axis values that don’t exist in the first . takes the union of all axis values takes the intersection of the axis values To perform an effective “left” join using the exact index from the original , result can be reindexed. For objects which don’t have a meaningful index, the ignores overlapping indexes. You can concatenate a mix of and objects. The will be transformed to with the column name as the name of the . will drop all name references. The argument adds another axis level to the resulting index or column (creating a ) associate specific keys with each original . The argument cane override the column names when creating a new based on existing . You can also pass a dict to in which case the dict keys will be used for the argument unless other argument is specified: The created has levels that are constructed from the passed keys and the index of the pieces: argument allows specifying resulting levels associated with the If you have a that you want to append as a single row to a , you can convert the row into a and use\n\nperforms join operations similar to relational databases like SQL. Users who are familiar with SQL but new to pandas can reference a comparison with SQL.\n• None one-to-one: joining two objects on their indexes which must contain unique values.\n• None many-to-one: joining a unique index to one or more columns in a different . When joining columns on columns, potentially a many-to-many join, any indexes on the passed objects will be discarded. For a many-to-many join, if a key combination appears more than once in both tables, the will have the Cartesian product of the associated data. The argument to specifies which keys are included in the resulting table. If a key combination does not appear in either the left or right tables, the values in the joined table will be . Here is a summary of the options and their SQL equivalent names: Use keys from left frame only Use keys from right frame only Use union of keys from both frames Use intersection of keys from both frames Create the cartesian product of rows of both frames You can and a with a if the names of the correspond to the columns from the . Transform the to a using before merging Performing an outer join with duplicate join keys in Merging on duplicate keys significantly increase the dimensions of the result and can cause a memory overflow. The argument checks whether the uniqueness of merge keys. Key uniqueness is checked before merge operations and can protect against memory overflows and unexpected key duplication. Traceback (most recent call last) in in # check if columns specified as unique in \"Merge keys are not unique in left dataset; not a one-to-one merge\" \"Merge keys are not unique in right dataset; not a one-to-one merge\" : Merge keys are not unique in right dataset; not a one-to-one merge If the user is aware of the duplicates in the right but wants to ensure there are no duplicates in the left , one can use the argument instead, which will not raise an exception. accepts the argument . If , a Categorical-type column called will be added to the output object that takes on values: A string argument to will use the value as the name for the indicator column. The merge argument takes a tuple of list of strings to append to overlapping column names in the input to disambiguate the result columns:\n\ncombines the columns of multiple, potentially differently-indexed into a single result . takes an optional argument which may be a column or multiple column names that the passed is to be aligned. To join on multiple keys, the passed must have a : The default for is to perform a left join which uses only the keys found in the calling . Other join types can be specified with . You can join a with a to a with a on a level. The of the with match the level name of the . The of the input argument must be completely used in the join and is a subset of the indices in the left argument. Merging on a combination of columns and index levels# Strings passed as the , , and parameters may refer to either column names or index level names. This enables merging instances on a combination of index levels and columns without resetting indexes. When are joined on a string that matches an index level in both arguments, the index level is preserved as an index level in the resulting . When are joined using only some of the levels of a , the extra levels will be dropped from the resulting join. To preserve those levels, use on those level names to move those levels to columns prior to the join. A list or tuple of can also be passed to to join them together on their indexes. update missing values from one with the non-missing values in another in the corresponding location.\n\nis similar to an ordered left-join except that mactches are on the nearest key rather than equal keys. For each row in the , the last row in the are selected where the key is less than the left’s key. Both must be sorted by the key. Optionally an can perform a group-wise merge by matching the key in addition to the nearest match on the key. within between the quote time and the trade time. within between the quote time and the trade time and exclude exact matches on time. Note that though we exclude the exact matches (of the quotes), prior quotes do propagate to that point in time.\n\nThe and methods allow you to compare two or , respectively, and summarize their differences. By default, if two corresponding values are equal, they will be shown as . Furthermore, if all values in an entire row / column, the row / column will be omitted from the result. The remaining differences will be aligned on columns. Keep all original rows and columns with self other self other self other Keep all the original values even if they are equal. self other self other self other"
    },
    {
        "link": "https://stackoverflow.com/questions/71888127/how-to-merge-pandas-dataframes-with-different-column-names",
        "document": "Can someone please tell me how I can achieve results like the image above, but with the following differences:\n\nEvery kind of merge I do results in this:\n\nHere's what I'm trying to accomplish:\n• I'm doing my Capstone Project, and the use case uses the data set. I've web-scraped the tables found here: SpaceX Falcon 9 Wikipedia,\n• None Now I'm trying to combine them into one large table. However, there are slight differences in the column names, between each table, and so I have to do more logic to merge properly. There are 10 tables in total, I've checked 5. 3 have unique column names, so the simple merging doesn't work.\n• None I've searched around at the other questions, but the use case is different than mine, so I haven't found an answer that works for me.\n\nI'd really appreciate someone's help, or pointing me where I can find more info on the subject. So far I've had no luck in my searches."
    },
    {
        "link": "https://pandas.pydata.org/pandas-docs/version/1.5/user_guide/merging.html",
        "document": "pandas provides various facilities for easily combining together Series or DataFrame with various kinds of set logic for the indexes and relational algebra functionality in the case of join / merge-type operations.\n\nIn addition, pandas also provides utilities to compare two Series or DataFrame and summarize their differences.\n\nThe function (in the main pandas namespace) does all of the heavy lifting of performing concatenation operations along an axis while performing optional set logic (union or intersection) of the indexes (if any) on the other axes. Note that I say “if any” because there is only a single possible axis of concatenation for Series. Before diving into all of the details of and what it can do, here is a simple example: Like its sibling function on ndarrays, , takes a list or dict of homogeneously-typed objects and concatenates them with some configurable handling of “what to do with the other axes”:\n• None : a sequence or mapping of Series or DataFrame objects. If a dict is passed, the sorted keys will be used as the argument, unless it is passed, in which case the values will be selected (see below). Any None objects will be dropped silently unless they are all None in which case a ValueError will be raised.\n• None : {0, 1, …}, default 0. The axis to concatenate along.\n• None : {‘inner’, ‘outer’}, default ‘outer’. How to handle indexes on other axis(es). Outer for union and inner for intersection.\n• None : boolean, default False. If True, do not use the index values on the concatenation axis. The resulting axis will be labeled 0, …, n - 1. This is useful if you are concatenating objects where the concatenation axis does not have meaningful indexing information. Note the index values on the other axes are still respected in the join.\n• None : sequence, default None. Construct hierarchical index using the passed keys as the outermost level. If multiple levels passed, should contain tuples.\n• None : list of sequences, default None. Specific levels (unique values) to use for constructing a MultiIndex. Otherwise they will be inferred from the keys.\n• None : list, default None. Names for the levels in the resulting hierarchical index.\n• None : boolean, default False. Check whether the new concatenated axis contains duplicates. This can be very expensive relative to the actual data concatenation.\n• None : boolean, default True. If False, do not copy data unnecessarily. Without a little bit of context many of these arguments don’t make much sense. Let’s revisit the above example. Suppose we wanted to associate specific keys with each of the pieces of the chopped up DataFrame. We can do this using the argument: As you can see (if you’ve read the rest of the documentation), the resulting object’s index has a hierarchical index. This means that we can now select out each chunk by key: It’s not a stretch to see how this can be very useful. More detail on this functionality below. It is worth noting that (and therefore ) makes a full copy of the data, and that constantly reusing this function can create a significant performance hit. If you need to use the operation over several datasets, use a list comprehension. When concatenating DataFrames with named axes, pandas will attempt to preserve these index/column names whenever possible. In the case where all inputs share a common name, this name will be assigned to the result. When the input names do not all agree, the result will be unnamed. The same is true for , but the logic is applied separately on a level-by-level basis. Set logic on the other axes# When gluing together multiple DataFrames, you have a choice of how to handle the other axes (other than the one being concatenated). This can be done in the following two ways:\n• None Take the union of them all, . This is the default option as it results in zero information loss. Here is an example of each of these methods. First, the default behavior: Here is the same thing with : Lastly, suppose we just wanted to reuse the exact index from the original DataFrame: Similarly, we could index before the concatenation: For objects which don’t have a meaningful index, you may wish to append them and ignore the fact that they may have overlapping indexes. To do this, use the argument: You can concatenate a mix of and objects. The will be transformed to with the column name as the name of the . Since we’re concatenating a to a , we could have achieved the same result with . To concatenate an arbitrary number of pandas objects ( or ), use . If unnamed are passed they will be numbered consecutively. Passing will drop all name references. A fairly common use of the argument is to override the column names when creating a new based on existing . Notice how the default behaviour consists on letting the resulting inherit the parent ’ name, when these existed. Through the argument we can override the existing column names. Let’s consider a variation of the very first example presented: You can also pass a dict to in which case the dict keys will be used for the argument (unless other keys are specified): The MultiIndex created has levels that are constructed from the passed keys and the index of the pieces: If you wish to specify other levels (as will occasionally be the case), you can do so using the argument: This is fairly esoteric, but it is actually necessary for implementing things like GroupBy where the order of a categorical variable is meaningful. If you have a series that you want to append as a single row to a , you can convert the row into a and use You should use with this method to instruct DataFrame to discard its index. If you wish to preserve the index, you should construct an appropriately-indexed DataFrame and append or concatenate those objects.\n\npandas has full-featured, high performance in-memory join operations idiomatically very similar to relational databases like SQL. These methods perform significantly better (in some cases well over an order of magnitude better) than other open source implementations (like in R). The reason for this is careful algorithmic design and the internal layout of the data in . See the cookbook for some advanced strategies. Users who are familiar with SQL but new to pandas might be interested in a comparison with SQL. pandas provides a single function, , as the entry point for all standard database join operations between or named objects:\n• None : Column or index level names to join on. Must be found in both the left and right DataFrame and/or Series objects. If not passed and and are , the intersection of the columns in the DataFrames and/or Series will be inferred to be the join keys.\n• None : Columns or index levels from the left DataFrame or Series to use as keys. Can either be column names, index level names, or arrays with length equal to the length of the DataFrame or Series.\n• None : Columns or index levels from the right DataFrame or Series to use as keys. Can either be column names, index level names, or arrays with length equal to the length of the DataFrame or Series.\n• None : If , use the index (row labels) from the left DataFrame or Series as its join key(s). In the case of a DataFrame or Series with a MultiIndex (hierarchical), the number of levels must match the number of join keys from the right DataFrame or Series.\n• None : Same usage as for the right DataFrame or Series\n• None : One of , , , , . Defaults to . See below for more detailed description of each method.\n• None : Sort the result DataFrame by the join keys in lexicographical order. Defaults to , setting to will improve performance substantially in many cases.\n• None : A tuple of string suffixes to apply to overlapping columns. Defaults to .\n• None : Always copy data (default ) from the passed DataFrame or named Series objects, even when reindexing is not necessary. Cannot be avoided in many cases but may improve performance / memory usage. The cases where copying can be avoided are somewhat pathological but this option is provided nonetheless.\n• None : Add a column to the output DataFrame called with information on the source of each row. is Categorical-type and takes on a value of for observations whose merge key only appears in DataFrame or Series, for observations whose merge key only appears in DataFrame or Series, and if the observation’s merge key is found in both.\n• None : string, default None. If specified, checks if merge is of specified type.\n• None “one_to_one” or “1:1”: checks if merge keys are unique in both left and right datasets.\n• None “one_to_many” or “1:m”: checks if merge keys are unique in left dataset.\n• None “many_to_one” or “m:1”: checks if merge keys are unique in right dataset.\n• None “many_to_many” or “m:m”: allowed, but does not result in checks. Support for specifying index levels as the , , and parameters was added in version 0.23.0. Support for merging named objects was added in version 0.24.0. The return type will be the same as . If is a or named and is a subclass of , the return type will still be . is a function in the pandas namespace, and it is also available as a instance method , with the calling being implicitly considered the left object in the join. The related method, uses internally for the index-on-index (by default) and column(s)-on-index join. If you are joining on index only, you may wish to use to save yourself some typing. Experienced users of relational databases like SQL will be familiar with the terminology used to describe join operations between two SQL-table like structures ( objects). There are several cases to consider which are very important to understand:\n• None one-to-one joins: for example when joining two objects on their indexes (which must contain unique values).\n• None many-to-one joins: for example when joining an index (unique) to one or more columns in a different . When joining columns on columns (potentially a many-to-many join), any indexes on the passed objects will be discarded. It is worth spending some time understanding the result of the many-to-many join case. In SQL / standard relational algebra, if a key combination appears more than once in both tables, the resulting table will have the Cartesian product of the associated data. Here is a very basic example with one unique key combination: Here is a more complicated example with multiple join keys. Only the keys appearing in and are present (the intersection), since by default. The argument to specifies how to determine which keys are to be included in the resulting table. If a key combination does not appear in either the left or right tables, the values in the joined table will be . Here is a summary of the options and their SQL equivalent names: Use keys from left frame only Use keys from right frame only Use union of keys from both frames Use intersection of keys from both frames Create the cartesian product of rows of both frames You can merge a mult-indexed Series and a DataFrame, if the names of the MultiIndex correspond to the columns from the DataFrame. Transform the Series to a DataFrame using before merging, as shown in the following example. Here is another example with duplicate join keys in DataFrames: Joining / merging on duplicate keys can cause a returned frame that is the multiplication of the row dimensions, which may result in memory overflow. It is the user’ s responsibility to manage duplicate values in keys before joining large DataFrames. Users can use the argument to automatically check whether there are unexpected duplicates in their merge keys. Key uniqueness is checked before merge operations and so should protect against memory overflows. Checking key uniqueness is also a good way to ensure user data structures are as expected. In the following example, there are duplicate values of in the right . As this is not a one-to-one merge – as specified in the argument – an exception will be raised. MergeError: Merge keys are not unique in right dataset; not a one-to-one merge If the user is aware of the duplicates in the right but wants to ensure there are no duplicates in the left DataFrame, one can use the argument instead, which will not raise an exception. accepts the argument . If , a Categorical-type column called will be added to the output object that takes on values: The argument will also accept string arguments, in which case the indicator function will use the value of the passed string as the name for the indicator column. Merging will preserve the dtype of the join keys. We are able to preserve the join keys: Of course if you have missing values that are introduced, then the resulting dtype will be upcast. Merging will preserve dtypes of the mergands. See also the section on categoricals. The category dtypes must be exactly the same, meaning the same categories and the ordered attribute. Otherwise the result will coerce to the categories’ dtype. Merging on dtypes that are the same can be quite performant compared to dtype merging. is a convenient method for combining the columns of two potentially differently-indexed into a single result . Here is a very basic example: The same as above, but with . The data alignment here is on the indexes (row labels). This same behavior can be achieved using plus additional arguments instructing it to use the indexes: takes an optional argument which may be a column or multiple column names, which specifies that the passed is to be aligned on that column in the . These two function calls are completely equivalent: Obviously you can choose whichever form you find more convenient. For many-to-one joins (where one of the ’s is already indexed by the join key), using may be more convenient. Here is a simple example: To join on multiple keys, the passed DataFrame must have a : Now this can be joined by passing the two key column names: The default for is to perform a left join (essentially a “VLOOKUP” operation, for Excel users), which uses only the keys found in the calling DataFrame. Other join types, for example inner join, can be just as easily performed: As you can see, this drops any rows where there was no match. You can join a singly-indexed with a level of a MultiIndexed . The level will match on the name of the index of the singly-indexed frame against a level name of the MultiIndexed frame. This is equivalent but less verbose and more memory efficient / faster than this. This is supported in a limited way, provided that the index for the right argument is completely used in the join, and is a subset of the indices in the left argument, as in this example: If that condition is not satisfied, a join with two multi-indexes can be done using the following code. Merging on a combination of columns and index levels# Strings passed as the , , and parameters may refer to either column names or index level names. This enables merging instances on a combination of index levels and columns without resetting indexes. When DataFrames are merged on a string that matches an index level in both frames, the index level is preserved as an index level in the resulting DataFrame. When DataFrames are merged using only some of the levels of a , the extra levels will be dropped from the resulting merge. In order to preserve those levels, use on those level names to move those levels to columns prior to doing the merge. If a string matches both a column name and an index level name, then a warning is issued and the column takes precedence. This will result in an ambiguity error in a future version. The merge argument takes a tuple of list of strings to append to overlapping column names in the input s to disambiguate the result columns: has and arguments which behave similarly. A list or tuple of can also be passed to to join them together on their indexes. Merging together values within Series or DataFrame columns# Another fairly common situation is to have two like-indexed (or similarly indexed) or objects and wanting to “patch” values in one object from values for matching indices in the other. Here is an example: For this, use the method: Note that this method only takes values from the right if they are missing in the left . A related method, , alters non-NA values in place:\n\nA function allows combining time series and other ordered data. In particular it has an optional keyword to fill/interpolate missing data: A is similar to an ordered left-join except that we match on nearest key rather than equal keys. For each row in the , we select the last row in the whose key is less than the left’s key. Both DataFrames must be sorted by the key. Optionally an asof merge can perform a group-wise merge. This matches the key equally, in addition to the nearest match on the key. For example; we might have and and we want to merge them. By default we are taking the asof of the quotes. We only asof within between the quote time and the trade time. We only asof within between the quote time and the trade time and we exclude exact matches on time. Note that though we exclude the exact matches (of the quotes), prior quotes do propagate to that point in time.\n\nThe and methods allow you to compare two DataFrame or Series, respectively, and summarize their differences. This feature was added in V1.1.0. For example, you might want to compare two and stack their differences side by side. By default, if two corresponding values are equal, they will be shown as . Furthermore, if all values in an entire row / column, the row / column will be omitted from the result. The remaining differences will be aligned on columns. If you wish, you may choose to stack the differences on rows. If you wish to keep all original rows and columns, set argument to . self other self other self other You may also keep all the original values even if they are equal. self other self other self other"
    },
    {
        "link": "https://pandas.pydata.org/pandas-docs/version/1.5.0/user_guide/merging.html",
        "document": "pandas provides various facilities for easily combining together Series or DataFrame with various kinds of set logic for the indexes and relational algebra functionality in the case of join / merge-type operations.\n\nIn addition, pandas also provides utilities to compare two Series or DataFrame and summarize their differences.\n\nThe function (in the main pandas namespace) does all of the heavy lifting of performing concatenation operations along an axis while performing optional set logic (union or intersection) of the indexes (if any) on the other axes. Note that I say “if any” because there is only a single possible axis of concatenation for Series. Before diving into all of the details of and what it can do, here is a simple example: Like its sibling function on ndarrays, , takes a list or dict of homogeneously-typed objects and concatenates them with some configurable handling of “what to do with the other axes”:\n• None : a sequence or mapping of Series or DataFrame objects. If a dict is passed, the sorted keys will be used as the argument, unless it is passed, in which case the values will be selected (see below). Any None objects will be dropped silently unless they are all None in which case a ValueError will be raised.\n• None : {0, 1, …}, default 0. The axis to concatenate along.\n• None : {‘inner’, ‘outer’}, default ‘outer’. How to handle indexes on other axis(es). Outer for union and inner for intersection.\n• None : boolean, default False. If True, do not use the index values on the concatenation axis. The resulting axis will be labeled 0, …, n - 1. This is useful if you are concatenating objects where the concatenation axis does not have meaningful indexing information. Note the index values on the other axes are still respected in the join.\n• None : sequence, default None. Construct hierarchical index using the passed keys as the outermost level. If multiple levels passed, should contain tuples.\n• None : list of sequences, default None. Specific levels (unique values) to use for constructing a MultiIndex. Otherwise they will be inferred from the keys.\n• None : list, default None. Names for the levels in the resulting hierarchical index.\n• None : boolean, default False. Check whether the new concatenated axis contains duplicates. This can be very expensive relative to the actual data concatenation.\n• None : boolean, default True. If False, do not copy data unnecessarily. Without a little bit of context many of these arguments don’t make much sense. Let’s revisit the above example. Suppose we wanted to associate specific keys with each of the pieces of the chopped up DataFrame. We can do this using the argument: As you can see (if you’ve read the rest of the documentation), the resulting object’s index has a hierarchical index. This means that we can now select out each chunk by key: It’s not a stretch to see how this can be very useful. More detail on this functionality below. It is worth noting that (and therefore ) makes a full copy of the data, and that constantly reusing this function can create a significant performance hit. If you need to use the operation over several datasets, use a list comprehension. When concatenating DataFrames with named axes, pandas will attempt to preserve these index/column names whenever possible. In the case where all inputs share a common name, this name will be assigned to the result. When the input names do not all agree, the result will be unnamed. The same is true for , but the logic is applied separately on a level-by-level basis. Set logic on the other axes# When gluing together multiple DataFrames, you have a choice of how to handle the other axes (other than the one being concatenated). This can be done in the following two ways:\n• None Take the union of them all, . This is the default option as it results in zero information loss. Here is an example of each of these methods. First, the default behavior: Here is the same thing with : Lastly, suppose we just wanted to reuse the exact index from the original DataFrame: Similarly, we could index before the concatenation: For objects which don’t have a meaningful index, you may wish to append them and ignore the fact that they may have overlapping indexes. To do this, use the argument: You can concatenate a mix of and objects. The will be transformed to with the column name as the name of the . Since we’re concatenating a to a , we could have achieved the same result with . To concatenate an arbitrary number of pandas objects ( or ), use . If unnamed are passed they will be numbered consecutively. Passing will drop all name references. A fairly common use of the argument is to override the column names when creating a new based on existing . Notice how the default behaviour consists on letting the resulting inherit the parent ’ name, when these existed. Through the argument we can override the existing column names. Let’s consider a variation of the very first example presented: You can also pass a dict to in which case the dict keys will be used for the argument (unless other keys are specified): The MultiIndex created has levels that are constructed from the passed keys and the index of the pieces: If you wish to specify other levels (as will occasionally be the case), you can do so using the argument: This is fairly esoteric, but it is actually necessary for implementing things like GroupBy where the order of a categorical variable is meaningful. If you have a series that you want to append as a single row to a , you can convert the row into a and use You should use with this method to instruct DataFrame to discard its index. If you wish to preserve the index, you should construct an appropriately-indexed DataFrame and append or concatenate those objects.\n\npandas has full-featured, high performance in-memory join operations idiomatically very similar to relational databases like SQL. These methods perform significantly better (in some cases well over an order of magnitude better) than other open source implementations (like in R). The reason for this is careful algorithmic design and the internal layout of the data in . See the cookbook for some advanced strategies. Users who are familiar with SQL but new to pandas might be interested in a comparison with SQL. pandas provides a single function, , as the entry point for all standard database join operations between or named objects:\n• None : Column or index level names to join on. Must be found in both the left and right DataFrame and/or Series objects. If not passed and and are , the intersection of the columns in the DataFrames and/or Series will be inferred to be the join keys.\n• None : Columns or index levels from the left DataFrame or Series to use as keys. Can either be column names, index level names, or arrays with length equal to the length of the DataFrame or Series.\n• None : Columns or index levels from the right DataFrame or Series to use as keys. Can either be column names, index level names, or arrays with length equal to the length of the DataFrame or Series.\n• None : If , use the index (row labels) from the left DataFrame or Series as its join key(s). In the case of a DataFrame or Series with a MultiIndex (hierarchical), the number of levels must match the number of join keys from the right DataFrame or Series.\n• None : Same usage as for the right DataFrame or Series\n• None : One of , , , , . Defaults to . See below for more detailed description of each method.\n• None : Sort the result DataFrame by the join keys in lexicographical order. Defaults to , setting to will improve performance substantially in many cases.\n• None : A tuple of string suffixes to apply to overlapping columns. Defaults to .\n• None : Always copy data (default ) from the passed DataFrame or named Series objects, even when reindexing is not necessary. Cannot be avoided in many cases but may improve performance / memory usage. The cases where copying can be avoided are somewhat pathological but this option is provided nonetheless.\n• None : Add a column to the output DataFrame called with information on the source of each row. is Categorical-type and takes on a value of for observations whose merge key only appears in DataFrame or Series, for observations whose merge key only appears in DataFrame or Series, and if the observation’s merge key is found in both.\n• None : string, default None. If specified, checks if merge is of specified type.\n• None “one_to_one” or “1:1”: checks if merge keys are unique in both left and right datasets.\n• None “one_to_many” or “1:m”: checks if merge keys are unique in left dataset.\n• None “many_to_one” or “m:1”: checks if merge keys are unique in right dataset.\n• None “many_to_many” or “m:m”: allowed, but does not result in checks. Support for specifying index levels as the , , and parameters was added in version 0.23.0. Support for merging named objects was added in version 0.24.0. The return type will be the same as . If is a or named and is a subclass of , the return type will still be . is a function in the pandas namespace, and it is also available as a instance method , with the calling being implicitly considered the left object in the join. The related method, uses internally for the index-on-index (by default) and column(s)-on-index join. If you are joining on index only, you may wish to use to save yourself some typing. Experienced users of relational databases like SQL will be familiar with the terminology used to describe join operations between two SQL-table like structures ( objects). There are several cases to consider which are very important to understand:\n• None one-to-one joins: for example when joining two objects on their indexes (which must contain unique values).\n• None many-to-one joins: for example when joining an index (unique) to one or more columns in a different . When joining columns on columns (potentially a many-to-many join), any indexes on the passed objects will be discarded. It is worth spending some time understanding the result of the many-to-many join case. In SQL / standard relational algebra, if a key combination appears more than once in both tables, the resulting table will have the Cartesian product of the associated data. Here is a very basic example with one unique key combination: Here is a more complicated example with multiple join keys. Only the keys appearing in and are present (the intersection), since by default. The argument to specifies how to determine which keys are to be included in the resulting table. If a key combination does not appear in either the left or right tables, the values in the joined table will be . Here is a summary of the options and their SQL equivalent names: Use keys from left frame only Use keys from right frame only Use union of keys from both frames Use intersection of keys from both frames Create the cartesian product of rows of both frames You can merge a mult-indexed Series and a DataFrame, if the names of the MultiIndex correspond to the columns from the DataFrame. Transform the Series to a DataFrame using before merging, as shown in the following example. Here is another example with duplicate join keys in DataFrames: Joining / merging on duplicate keys can cause a returned frame that is the multiplication of the row dimensions, which may result in memory overflow. It is the user’ s responsibility to manage duplicate values in keys before joining large DataFrames. Users can use the argument to automatically check whether there are unexpected duplicates in their merge keys. Key uniqueness is checked before merge operations and so should protect against memory overflows. Checking key uniqueness is also a good way to ensure user data structures are as expected. In the following example, there are duplicate values of in the right . As this is not a one-to-one merge – as specified in the argument – an exception will be raised. MergeError: Merge keys are not unique in right dataset; not a one-to-one merge If the user is aware of the duplicates in the right but wants to ensure there are no duplicates in the left DataFrame, one can use the argument instead, which will not raise an exception. accepts the argument . If , a Categorical-type column called will be added to the output object that takes on values: The argument will also accept string arguments, in which case the indicator function will use the value of the passed string as the name for the indicator column. Merging will preserve the dtype of the join keys. We are able to preserve the join keys: Of course if you have missing values that are introduced, then the resulting dtype will be upcast. Merging will preserve dtypes of the mergands. See also the section on categoricals. The category dtypes must be exactly the same, meaning the same categories and the ordered attribute. Otherwise the result will coerce to the categories’ dtype. Merging on dtypes that are the same can be quite performant compared to dtype merging. is a convenient method for combining the columns of two potentially differently-indexed into a single result . Here is a very basic example: The same as above, but with . The data alignment here is on the indexes (row labels). This same behavior can be achieved using plus additional arguments instructing it to use the indexes: takes an optional argument which may be a column or multiple column names, which specifies that the passed is to be aligned on that column in the . These two function calls are completely equivalent: Obviously you can choose whichever form you find more convenient. For many-to-one joins (where one of the ’s is already indexed by the join key), using may be more convenient. Here is a simple example: To join on multiple keys, the passed DataFrame must have a : Now this can be joined by passing the two key column names: The default for is to perform a left join (essentially a “VLOOKUP” operation, for Excel users), which uses only the keys found in the calling DataFrame. Other join types, for example inner join, can be just as easily performed: As you can see, this drops any rows where there was no match. You can join a singly-indexed with a level of a MultiIndexed . The level will match on the name of the index of the singly-indexed frame against a level name of the MultiIndexed frame. This is equivalent but less verbose and more memory efficient / faster than this. This is supported in a limited way, provided that the index for the right argument is completely used in the join, and is a subset of the indices in the left argument, as in this example: If that condition is not satisfied, a join with two multi-indexes can be done using the following code. Merging on a combination of columns and index levels# Strings passed as the , , and parameters may refer to either column names or index level names. This enables merging instances on a combination of index levels and columns without resetting indexes. When DataFrames are merged on a string that matches an index level in both frames, the index level is preserved as an index level in the resulting DataFrame. When DataFrames are merged using only some of the levels of a , the extra levels will be dropped from the resulting merge. In order to preserve those levels, use on those level names to move those levels to columns prior to doing the merge. If a string matches both a column name and an index level name, then a warning is issued and the column takes precedence. This will result in an ambiguity error in a future version. The merge argument takes a tuple of list of strings to append to overlapping column names in the input s to disambiguate the result columns: has and arguments which behave similarly. A list or tuple of can also be passed to to join them together on their indexes. Merging together values within Series or DataFrame columns# Another fairly common situation is to have two like-indexed (or similarly indexed) or objects and wanting to “patch” values in one object from values for matching indices in the other. Here is an example: For this, use the method: Note that this method only takes values from the right if they are missing in the left . A related method, , alters non-NA values in place:\n\nA function allows combining time series and other ordered data. In particular it has an optional keyword to fill/interpolate missing data: A is similar to an ordered left-join except that we match on nearest key rather than equal keys. For each row in the , we select the last row in the whose key is less than the left’s key. Both DataFrames must be sorted by the key. Optionally an asof merge can perform a group-wise merge. This matches the key equally, in addition to the nearest match on the key. For example; we might have and and we want to merge them. By default we are taking the asof of the quotes. We only asof within between the quote time and the trade time. We only asof within between the quote time and the trade time and we exclude exact matches on time. Note that though we exclude the exact matches (of the quotes), prior quotes do propagate to that point in time.\n\nThe and methods allow you to compare two DataFrame or Series, respectively, and summarize their differences. This feature was added in V1.1.0. For example, you might want to compare two and stack their differences side by side. By default, if two corresponding values are equal, they will be shown as . Furthermore, if all values in an entire row / column, the row / column will be omitted from the result. The remaining differences will be aligned on columns. If you wish, you may choose to stack the differences on rows. If you wish to keep all original rows and columns, set argument to . self other self other self other You may also keep all the original values even if they are equal. self other self other self other"
    },
    {
        "link": "https://realpython.com/pandas-merge-join-and-concat",
        "document": "The and objects in pandas are powerful tools for exploring and analyzing data. Part of their power comes from a multifaceted approach to combining separate datasets. With pandas, you can merge, join, and concatenate your datasets, allowing you to unify and better understand your data as you analyze it.\n\nIn this tutorial, you’ll learn how and when to combine your data in pandas with:\n• for combining data on common columns or indices\n• for combining data on a key column or an index\n• for combining DataFrames across rows or columns\n\nIf you have some experience using and objects in pandas and you’re ready to learn how to combine them, then this tutorial will help you do exactly that. If you’re feeling a bit rusty, then you can watch a quick refresher on DataFrames before proceeding.\n\nYou can follow along with the examples in this tutorial using the interactive Jupyter Notebook and data files available at the link below:\n\nThe first technique that you’ll learn is . You can use anytime you want functionality similar to a database’s join operations. It’s the most flexible of the three operations that you’ll learn. When you want to combine data objects based on one or more keys, similar to what you’d do in a relational database, is the tool you need. More specifically, is most useful when you want to combine rows that share data. You can achieve both many-to-one and many-to-many joins with . In a many-to-one join, one of your datasets will have many rows in the merge column that repeat the same values. For example, the values could be 1, 1, 3, 5, and 5. At the same time, the merge column in the other dataset won’t have repeated values. Take 1, 3, and 5 as an example. As you might have guessed, in a many-to-many join, both of your merge columns will have repeated values. These merges are more complex and result in the Cartesian product of the joined rows. This means that, after the merge, you’ll have every combination of rows that share the same value in the key column. You’ll see this in action in the examples below. What makes so flexible is the sheer number of options for defining the behavior of your merge. While the list can seem daunting, with practice you’ll be able to expertly merge datasets of all kinds. When you use , you’ll provide two required arguments: After that, you can provide a number of optional arguments to define how your datasets are merged:\n• defines what kind of merge to make. It defaults to , but other possible options include , , and .\n• tells which columns or indices, also called key columns or key indices, you want to join on. This is optional. If it isn’t specified, and and (covered below) are , then columns from the two DataFrames that share names will be used as join keys. If you use , then the column or index that you specify must be present in both objects.\n• and specify a column or index that’s present only in the or object that you’re merging. Both default to .\n• and both default to , but if you want to use the index of the left or right object to be merged, then you can set the relevant argument to .\n• is a tuple of strings to append to identical column names that aren’t merge keys. This allows you to keep track of the origins of columns with the same name. These are some of the most important parameters to pass to . For the full list, see the pandas documentation. Note: In this tutorial, you’ll see that examples always use to specify which column(s) to join on. This is the safest way to merge your data because you and anyone reading your code will know exactly what to expect when calling . If you don’t specify the merge column(s) with , then pandas will use any columns with the same name as the merge keys. How to Use Before getting into the details of how to use , you should first understand the various forms of joins: Note: Even though you’re learning about merging, you’ll see , , , and also referred to as join operations. For this tutorial, you can consider the terms merge and join equivalent. You’ll learn about these different joins in detail below, but first take a look at this visual representation of them: In this image, the two circles are your two datasets, and the labels point to which part or parts of the datasets you can expect to see. While this diagram doesn’t cover all the nuance, it can be a handy guide for visual learners. If you have an SQL background, then you may recognize the merge operation names from the syntax. Except for , all of these techniques are types of outer joins. With outer joins, you’ll merge your data based on all the keys in the left object, the right object, or both. For keys that only exist in one object, unmatched columns in the other object will be filled in with , which stands for Not a Number. You can also see a visual explanation of the various joins in an SQL context on Coding Horror. Now take a look at the different joins in action. Many pandas tutorials provide very simple DataFrames to illustrate the concepts that they are trying to explain. This approach can be confusing since you can’t relate the data to anything concrete. So, for this tutorial, you’ll use two real-world datasets as the DataFrames to be merged: You can explore these datasets and follow along with the examples below using the interactive Jupyter Notebook and climate data CSVs: Download the notebook and data set: Click here to get the Jupyter Notebook and CSV data set you’ll use to learn about Pandas merge(), .join(), and concat() in this tutorial. If you’d like to learn how to use Jupyter Notebooks, then check out Jupyter Notebook: An Introduction. These two datasets are from the National Oceanic and Atmospheric Administration (NOAA) and were derived from the NOAA public data repository. First, load the datasets into separate DataFrames: In the code above, you used pandas’ to conveniently load your source CSV files into objects. You can then look at the headers and first few rows of the loaded DataFrames with : Here, you used to get the first five rows of each DataFrame. Make sure to try this on your own, either with the interactive Jupyter Notebook or in your console, so that you can explore the data in greater depth. Next, take a quick look at the dimensions of the two DataFrames: Note that is a property of objects that tells you the dimensions of the DataFrame. For , the output of says that the DataFrame has 127,020 rows and 21 columns. In this example, you’ll use with its default arguments, which will result in an inner join. Remember that in an inner join, you’ll lose rows that don’t have a match in the other DataFrame’s key column. With the two datasets loaded into objects, you’ll select a small slice of the precipitation dataset and then use a plain call to do an inner join. This will result in a smaller, more focused dataset: Here you’ve created a new DataFrame called from the DataFrame, selecting only rows in which the field is . If you check the attribute, then you’ll see that it has 365 rows. When you do the merge, how many rows do you think you’ll get in the merged DataFrame? Remember that you’ll be doing an inner join: If you guessed 365 rows, then you were correct! This is because defaults to an inner join, and an inner join will discard only those rows that don’t match. Because all of your rows had a match, none were lost. You should also notice that there are many more columns now: 47 to be exact. With , you also have control over which column(s) to join on. Let’s say that you want to merge both entire datasets, but only on and since the combination of the two will yield a unique value for each row. To do so, you can use the parameter: You can specify a single key column with a string or multiple key columns with a list. This results in a DataFrame with 123,005 rows and 48 columns. Why 48 columns instead of 47? Because you specified the key columns to join on, pandas doesn’t try to merge all mergeable columns. This can result in “duplicate” column names, which may or may not have different values. “Duplicate” is in quotation marks because the column names will not be an exact match. By default, they are appended with and . You can also use the parameter to control what’s appended to the column names. To prevent surprises, all the following examples will use the parameter to specify the column or columns on which to join. Here, you’ll specify an outer join with the parameter. Remember from the diagrams above that in an outer join—also known as a full outer join—all rows from both DataFrames will be present in the new DataFrame. If a row doesn’t have a match in the other DataFrame based on the key column(s), then you won’t lose the row like you would with an inner join. Instead, the row will be in the merged DataFrame, with values filled in where appropriate. This is best illustrated in an example: If you remember from when you checked the attribute of , then you’ll see that the number of rows in is the same. With an outer join, you can expect to have the same number of rows as the larger DataFrame. That’s because no rows are lost in an outer join, even when they don’t have a match in the other DataFrame. In this example, you’ll specify a left join—also known as a left outer join—with the parameter. Using a left outer join will leave your new merged DataFrame with all rows from the left DataFrame, while discarding rows from the right DataFrame that don’t have a match in the key column of the left DataFrame. You can think of this as a half-outer, half-inner merge. The example below shows you this in action: has 127,020 rows, matching the number of rows in the left DataFrame, . To prove that this only holds for the left DataFrame, run the same code, but change the position of and : This results in a DataFrame with 365 rows, matching the number of rows in . The right join, or right outer join, is the mirror-image version of the left join. With this join, all rows from the right DataFrame will be retained, while rows in the left DataFrame without a match in the key column of the right DataFrame will be discarded. To demonstrate how right and left joins are mirror images of each other, in the example below you’ll recreate the DataFrame from above, only this time using a right join: Here, you simply flipped the positions of the input DataFrames and specified a right join. When you inspect , you might notice that it’s not exactly the same as . The only difference between the two is the order of the columns: the first input’s columns will always be the first in the newly formed DataFrame. is the most complex of the pandas data combination tools. It’s also the foundation on which the other tools are built. Its complexity is its greatest strength, allowing you to combine datasets in every which way and to generate new insights into your data. On the other hand, this complexity makes difficult to use without an intuitive grasp of set theory and database operations. In this section, you’ve learned about the various data merging techniques, as well as many-to-one and many-to-many merges, which ultimately come from set theory. For more information on set theory, check out Sets in Python. Now, you’ll look at , a simplified version of .\n\nWhile is a module function, is an instance method that lives on your DataFrame. This enables you to specify only one DataFrame, which will join the DataFrame you call on. Under the hood, uses , but it provides a more efficient way to join DataFrames than a fully specified call. Before diving into the options available to you, take a look at this short example: With the indices visible, you can see a left join happening here, with being the left DataFrame. You might notice that this example provides the parameters and . Because joins on indices and doesn’t directly merge DataFrames, all columns—even those with matching names—are retained in the resulting DataFrame. Now flip the previous example around and instead call on the larger DataFrame: Notice that the DataFrame is larger, but data that doesn’t exist in the smaller DataFrame, , is filled in with values. How to Use By default, will attempt to do a left join on indices. If you want to join on columns like you would with , then you’ll need to set the columns as indices. Like , has a few parameters that give you more flexibility in your joins. However, with , the list of parameters is relatively short:\n• is the only required parameter. It defines the other DataFrame to join. You can also specify a list of DataFrames here, allowing you to combine a number of datasets in a single call.\n• specifies an optional column or index name for the left DataFrame ( in the previous example) to join the DataFrame’s index. If it’s set to , which is the default, then you’ll get an index-on-index join.\n• has the same options as from . The difference is that it’s index-based unless you also specify columns with .\n• and are similar to in . They specify a suffix to add to any overlapping columns but have no effect when passing a list of DataFrames.\n• can be enabled to sort the resulting DataFrame by the join key. In this section, you’ll see examples showing a few different use cases for . Some will be simplifications of calls. Others will be features that set apart from the more verbose calls. Since you already saw a short call, in this first example you’ll attempt to recreate a call with . What will this require? Take a second to think about a possible solution, and then look at the proposed solution below: Because works on indices, if you want to recreate from before, then you must set indices on the join columns that you specify. In this example, you used to set your indices to the key columns within the join. Note that does a left join by default so you need to explictly use to do an inner join. With this, the connection between and should be clearer. Below you’ll see a call that’s almost bare. Because there are overlapping columns, you’ll need to specify a suffix with , , or both, but this example will demonstrate the more typical behavior of : This example should be reminiscent of what you saw in the introduction to earlier. The call is the same, resulting in a left join that produces a DataFrame with the same number of rows as . In this section, you’ve learned about and its parameters and uses. You’ve also learned about how works under the hood, and you’ve recreated a call with to better understand the connection between the two techniques.\n\nConcatenation is a bit different from the merging techniques that you saw above. With merging, you can expect the resulting dataset to have rows from the parent datasets mixed in together, often based on some commonality. Depending on the type of merge, you might also lose rows that don’t have matches in the other dataset. With concatenation, your datasets are just stitched together along an axis — either the row axis or column axis. Visually, a concatenation with no parameters along rows would look like this: To implement this in code, you’ll use and pass it a list of DataFrames that you want to concatenate. Code for this task would look like this: Note: This example assumes that your column names are the same. If your column names are different while concatenating along rows (axis 0), then by default the columns will also be added, and values will be filled in as applicable. What if you wanted to perform a concatenation along columns instead? First, take a look at a visual representation of this operation: To accomplish this, you’ll use a call like you did above, but you’ll also need to pass the parameter with a value of or : Note: This example assumes that your indices are the same between datasets. If they’re different while concatenating along columns (axis 1), then by default the extra indices (rows) will also be added, and values will be filled in as applicable. You’ll learn more about the parameters for in the section below. How to Use As you can see, concatenation is a simpler way to combine datasets. It’s often used to form a single, larger set to do additional operations on. Note: When you call , a copy of all the data that you’re concatenating is made. You should be careful with multiple calls, as the many copies that are made may negatively affect performance. Alternatively, you can set the optional parameter to When you concatenate datasets, you can specify the axis along which you’ll concatenate. But what happens with the other axis? Nothing. By default, a concatenation results in a set union, where all data is preserved. You’ve seen this with and as an outer join, and you can specify this with the parameter. If you use this parameter, then the default is , but you also have the option, which will perform an inner join, or set intersection. As with the other inner joins you saw earlier, some data loss can occur when you do an inner join with . Only where the axis labels match will you preserve rows or columns. Note: Remember, the parameter only specifies how to handle the axes that you’re not concatenating along. Since you learned about the parameter, here are some of the other parameters that takes:\n• takes any sequence—typically a list—of or objects to be concatenated. You can also provide a dictionary. In this case, the keys will be used to construct a hierarchical index.\n• represents the axis that you’ll concatenate along. The default value is , which concatenates along the index, or row axis. Alternatively, a value of will concatenate vertically, along columns. You can also use the string values or .\n• is similar to the parameter in the other techniques, but it only accepts the values or . The default value is , which preserves data, while would eliminate data that doesn’t have a match in the other dataset.\n• takes a Boolean or value. It defaults to . If , then the new combined dataset won’t preserve the original index values in the axis specified in the parameter. This lets you have entirely new index values.\n• allows you to construct a hierarchical index. One common use case is to have a new index while preserving the original indices so that you can tell which rows, for example, come from which original dataset.\n• specifies whether you want to copy the source data. The default value is . If the value is set to , then pandas won’t make copies of the source data. This list isn’t exhaustive. You can find the complete, up-to-date list of parameters in the pandas documentation. First, you’ll do a basic concatenation along the default axis using the DataFrames that you’ve been playing with throughout this tutorial: This one is very simple by design. Here, you created a DataFrame that is a double of a small DataFrame that was made earlier. One thing to notice is that the indices repeat. If you want a fresh, 0-based index, then you can use the parameter: As noted before, if you concatenate along axis 0 (rows) but have labels in axis 1 (columns) that don’t match, then those columns will be added and filled in with values. This results in an outer join: With these two DataFrames, since you’re just concatenating along rows, very few columns have the same name. That means you’ll see a lot of columns with values. To instead drop columns that have any missing data, use the parameter with the value to do an inner join: Using the inner join, you’ll be left with only those columns that the original DataFrames have in common: , , and . You can also flip this by setting the parameter: Now you have only the rows that have data for all columns in both DataFrames. It’s no coincidence that the number of rows corresponds with that of the smaller DataFrame. Another useful trick for concatenation is using the parameter to create hierarchical axis labels. This is useful if you want to preserve the indices or column names of the original datasets but also want to add new ones: If you check on the original DataFrames, then you can verify whether the higher-level axis labels and were added to the appropriate rows.\n\nYou’ve now learned the three most important techniques for combining data in pandas:\n• for combining data on common columns or indices\n• for combining data on a key column or an index\n• for combining DataFrames across rows or columns In addition to learning how to use these techniques, you also learned about set logic by experimenting with the different ways to join your datasets. Additionally, you learned about the most common parameters to each of the above techniques, and what arguments you can pass to customize their output. You saw these techniques in action on a real dataset obtained from the NOAA, which showed you not only how to combine your data but also the benefits of doing so with pandas’ built-in techniques. If you haven’t downloaded the project files yet, you can get them here: Download the notebook and data set: Click here to get the Jupyter Notebook and CSV data set you’ll use to learn about Pandas merge(), .join(), and concat() in this tutorial. Did you learn something new? Figure out a creative way to solve a problem by combining complex datasets? Let us know in the comments below!"
    }
]