[
    {
        "link": "https://stackoverflow.com/questions/35158546/taskcompletionsource-in-async-function",
        "document": "The whole thing will come out a lot more elegantly if you separate out the logic of turning the event firing into a into its own method.\n\nThis allows you to write the business logic separately, without mixing in all of the logic of translating the event into a :"
    },
    {
        "link": "https://learn.microsoft.com/en-us/answers/questions/1371771/what-are-your-thoughts-on-using-taskcompletionsour",
        "document": "A Microsoft open-source app platform for building Android and iOS apps with .NET and C#."
    },
    {
        "link": "https://stackoverflow.com/questions/52376586/asynchronous-web-service-request-in-xamarin-forms-using-a-corporate-library-that",
        "document": "\n• I'm developing a Xamarin Forms application and I´m using PRISM(obviously MVVM too).\n• I have certain restrictions about requesting a web service. One of them is: I have to use a corporate(and internal) library because of security and politics in my work .\n• None This corporate library exposes the methods for requesting web services using callbacks. One of them looks like this:\n• None I mean, this library doesn´t expose async methods, as HttpClient, for example. Instead of that, this library uses a callback aproach.\n• None The corporate library have different implementations for android and ios(one library for each one platform). And because of this, I need to use dependency injection to use the platform specific code\n\nWhich is the best way to implement this library(talking about performance and best practices) and why? The main question is about to explain why one solution could be the better vs others, and give an example(code).\n\nI was thinking in the examples below but I don´t know which one could be the better or if the combination of one of them could be better, or ... none of them.\n• Calling the library directly from the ViewModel and using the callbacks: Using callbacks example\n• Using the System.Threading.Tasks.Task.Run as the wrapper from the UI thread(directly from the ViewModel) Using Task.Run example\n• Create a separate class that only contains the web service request and also use the callbacks as an asynchronus method. Separate business + callbacks example"
    },
    {
        "link": "https://pluralsight.com/resources/blog/guides/task-taskcompletion-source-csharp",
        "document": "When working with async/await in C# you end up using the Task class quite a bit. Aside from void, which has specific use cases, Task is the primary return type used with async methods, along with the lesser used ValueTask. It might be surprising, though, to learn that the similarly named TaskCompletionSource is not an acceptable return type for async methods. What is the purpose of TaskCompletionSource, and how does it fit into the picture of C# asynchronous programming?\n\nIn short, the TaskCompletionSource class is used for asyncification. Ok, admittedly that's not actually a real word, but you might intuit that we're talking about making something asynchronous. Good question! While Task.Run turns something synchronous into a Task (by running it on a separate thread), TaskCompletionSource turns something that is already asynchronous into a Task. \"If it is already asynchronous, why does it need to be turned into a Task?\" Well, keep in mind that the Task class is required to enable C#'s async/await language support, and Task did not exist when .NET was first released. There are therefore other (some might say \"legacy\") ways to achieve asynchrony in C# that do not involve the Task class, and are therefore not compatible with async/await. For example, there is the Asynchronous Programming Model, where you pass an AsyncCallback into a BeginInvoke method. There is also the Event-based Asynchronous Pattern, where you subscribe to an event that is raised upon completion. Both of these are forms of callbacks, where a method you provide is invoked after an operation is completed. Regardless of the exact pattern used, you are likely to encounter a callback at some point in your C# career. When you do, you might find yourself wishing there was a way to convert callback code into a Task that you can await. Thankfully, the TaskCompletionSource class lets you do exactly that! It follows, then, that TaskCompletionSource is not itself awaitable, nor is it a valid async method return type. Once the TaskCompletionSource gives you a Task, you can simply return that Task as you do any other in your async methods.\n\nThis works fine, but you would really prefer to use async/await instead of the callback approach, especially if you plan on using that library a lot in your application. You can do that by making a helper method that uses TaskCompletionSource to hide the callback from callers of the helper method. First, define an instance of TaskCompletionSource. It accepts a generic parameter representing the type of whatever-it-is you want to return. In this case, we want to return the value of the success variable, which is a boolean, so use bool as the generic parameter.\n\nThat's it! Now, whenever MyBox.UploadFile calls the callback or throws an exception, the Task generated by the TaskCompletionSource will be completed to reflect that. The important thing is that every possible outcome should be handled by your logic; if there were additional callbacks indicating finality (e.g. onCanceled, onTimeout) you would want to call a Set* method of TaskCompletionSource in each of those as well. Once you have your helper method in place, you can now await it anywhere in your code without having to use callbacks. Let's update our button click event handler:\n\nOne useful aspect of Task is that it has no built-in timeout mechanism, so it can be active any amount of time. That being the case, you can represent a user interface interaction (which is naturally asynchronous) as a Task, and it can be awaited as long as the user needs. With TaskCompletionSource, mapping a user interface interaction to a Task can be just as easy as what we did for callbacks above. Doing that for a modal confirmation dialog, for example, would give us something like the following:\n\nNot only is this less code, but it is also now easier to read and the intent is clear. Just be sure to handle all possible ways that the dialog can be dismissed so that the Task is not \"orphaned\". For example, is the modal dialog dismissed if the user clicks behind it, or taps the Esc key on their keyboard? If so, you'll need to call a Set* method on the TaskCompletionSource in those situations as well. If you call more than one Set* method on a TaskCompletionSource, by default an exception is thrown. This is so you can discover problems in your code since the fact that your code is setting multiple outcomes for the TaskCompletionSource might indicate a bug. If that is undesirable, you can instead use the corresponding TrySet* methods (e.g. TrySetResult) which do not throw exceptions. This is particularly useful for user interactions since a button can sometimes get clicked multiple times in quick succession, for example."
    },
    {
        "link": "https://damirscorner.com/blog/posts/20210416-AwaitingGooglePlayServicesTasks.html",
        "document": "Thanks to Xamarin, C# developers can use a lot of their existing knowledge even when interacting with native Android (and iOS) APIs. However, some APIs still break the idioms we're used to in .NET.\n\nFor example, we're used to the and keywords when writing asynchronous code:\n\nWhen I recently had to integrate Firebase Cloud Messaging into a Xamarin application, I encountered an asynchronous call that didn't allow that. The method even returned a . It just wasn't the right .\n\nThe official sample code showed that I should add a listener (i.e. a handler) to be called when the task completes. Unfortunately, the listener has to implement an interface, which makes it inconvenient in terms of C# code.\n\nI decided to hide the necessary plumbing in an extension method to make the actual application code more similar to idiomatic C#. My final goal was o await the Android just like I'm used to with the .NET .\n\nThe key to my solution was the class, which is also a great tool for converting older .NET asynchronous patterns to tasks. I embedded it in the private listener helper class:\n\nIn the extension method, I could then simply instantiate this helper class and pass it as the listener to the Android class:\n\nThat was it. After using this extension method, the final code looked very .NET-like:\n\nYou can find a working sample with full code in my GitHub repository.\n\nThe class from the Google Play services library that's used in Firebase APIs isn't awaitable. I created an extension method that converts it to a regular .NET class that can be awaited in an asynchronous method."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/android.app.alertdialog.builder?view=net-android-35.0",
        "document": "Set a list of items, which are supplied by the given IListAdapter, to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener.\n\nSet a list of items, which are supplied by the given ICursor, to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener."
    },
    {
        "link": "https://stackoverflow.com/questions/37430636/setting-dialog-button-clicklistener-in-android-xamarin",
        "document": "I want to display a dialog alert in my Xamarin Android app (C#), and I want to do stuff to the dialog when I click on the buttons.\n\nFrom before, I use this code:\n\nTo make a random example, lets say I want to keep the dialog box open until the item is deleted, but I want to disable the Yes button and change the message text while Android is working. Is this possible from the code I have to access the dialog and change it? Neither senderAlert nor args have any useful properties or methods.\n\nI have been looking for other ways to build my dialog, and I have seen these two:\n\n1) This guy is using the way bellow, but my DialogInterface does not have a .OnClickListener()\n\n2) This guy is using IDialogInterfaceOnClickListener, and I have been trying to find an example of how to do it this way, but I havent found any. Seems like he is using null instead of the code I would want."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/components/dialogs",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nA dialog is a small window that prompts the user to make a decision or enter additional information. A dialog doesn't fill the screen and is normally used for modal events that require users to take an action before they can proceed.\n\nThe class is the base class for dialogs, but don't instantiate directly. Instead, use one of the following subclasses:\n\nThese classes define the style and structure for your dialog. You also need a as a container for your dialog. The class provides all the controls you need to create your dialog and manage its appearance, instead of calling methods on the object.\n\nUsing to manage the dialog makes it correctly handle lifecycle events such as when the user taps the Back button or rotates the screen. The class also lets you reuse the dialog's UI as an embeddable component in a larger UI—just like a traditional —such as when you want the dialog UI to appear differently on large and small screens.\n\nThe following sections in this document describe how to use a in combination with an object. If you want to create a date or time picker, read Add pickers to your app.\n\nYou can accomplish a wide variety of dialog designs—including custom layouts and those described in Material Design Dialogs—by extending and creating an in the callback method.\n\nFor example, here's a basic that's managed within a :\n\nWhen you create an instance of this class and call on that object, the dialog appears as shown in the following figure.\n\nThe next section provides more detail about using the APIs to create the dialog.\n\nDepending on how complex your dialog is, you can implement a variety of other callback methods in the , including all the basic fragment lifecycle methods.\n\nThe class lets you build a variety of dialog designs and is often the only dialog class you need. As shown in the following figure, there are three regions of an alert dialog:\n• Title: this is optional and only used when the content area is occupied by a detailed message, list, or custom layout. If you need to state a simple message or question, you don't need a title.\n• Content area: this can display a message, list, or other custom layout.\n• Action buttons: there can be up to three action buttons in a dialog.\n\nThe class provides APIs that let you create an with these kinds of content, including a custom layout.\n\nTo build an , do the following:\n\nTo add action buttons like those in figure 2, call the and methods:\n\nThe methods require a title for the button—supplied by a string resource—and a that defines the action to take when the user taps the button.\n\nThere are three action buttons you can add:\n• Positive: use this to accept and continue with the action (the \"OK\" action).\n• Negative: use this to cancel the action.\n• Neutral: use this when the user might not want to proceed with the action but doesn't necessarily want to cancel. It appears between the positive and negative buttons. For example, the action might be \"Remind me later.\"\n\nYou can add only one of each button type to an . For example, you can't have more than one \"positive\" button.\n\nThe previous code snippet gives you an alert dialog like the following:\n\nThere are three kinds of lists available with the APIs:\n\nTo create a single-choice list like the one in figure 5, use the method:\n\nThis code snippet generates a dialog like the following:\n\nBecause the list appears in the dialog's content area, the dialog can't show both a message and a list. Set a title for the dialog with . To specify the items for the list, call , passing an array. Alternatively, you can specify a list using . This lets you back the list with dynamic data—such as from a database—using a .\n\nIf you back your list with a , always use a so that the content loads asynchronously. This is described further in Build layouts with an adapter and Loaders.\n\nTo add a list of multiple-choice items (checkboxes) or single-choice items (radio buttons), use the or methods, respectively.\n\nFor example, here's how you can create a multiple-choice list like the one shown in figure 6 that saves the selected items in an :\n\nA single-choice alert dialog can be obtained like this:\n\nThis results in the following example:\n\nIf you want a custom layout in a dialog, create a layout and add it to an by calling on your object.\n\nBy default, the custom layout fills the dialog window, but you can still use methods to add buttons and a title.\n\nFor example, here's the layout file for the preceding custom dialog layout:\n\nTo inflate the layout in your , get a with and call . The first parameter is the layout resource ID, and the second parameter is a parent view for the layout. You can then call to place the layout in the dialog. This is shown in the following example.\n\nIf you want a custom dialog, you can instead display an as a dialog instead of using the APIs. Create an activity and set its theme to in the manifest element:\n\nThe activity now displays in a dialog window instead of fullscreen.\n\nWhen the user taps one of the dialog's action buttons or selects an item from its list, your might perform the necessary action itself, but often you want to deliver the event to the activity or fragment that opens the dialog. To do this, define an interface with a method for each type of click event. Then, implement that interface in the host component that receives the action events from the dialog.\n\nFor example, here's a that defines an interface through which it delivers the events back to the host activity:\n\nThe activity hosting the dialog creates an instance of the dialog with the dialog fragment's constructor and receives the dialog's events through an implementation of the interface:\n\nBecause the host activity implements the —which is enforced by the callback method shown in the preceding example—the dialog fragment can use the interface callback methods to deliver click events to the activity:\n\nWhen you want to show your dialog, create an instance of your and call , passing the and a tag name for the dialog fragment.\n\nYou can get the by calling from the or by calling from a . See the following for an example:\n\nThe second argument, , is a unique tag name that the system uses to save and restore the fragment state when necessary. The tag also lets you get a handle to the fragment by calling .\n\nShow a dialog fullscreen or as an embedded fragment\n\nYou might want a piece of your UI design to appear as a dialog in some situations and as a fullscreen or embedded fragment in others. You might also want it to appear differently depending on the device's screen size. The class offers flexibility to accomplish this, because it can behave as an embeddable .\n\nHowever, you can't use or other objects to build the dialog in this case. If you want the to be embeddable, define the dialog's UI in a layout, then load the layout in the callback.\n\nHere's an example that can appear as a dialog or an embeddable fragment, using a layout named :\n\nThe following example determines whether to show the fragment as a dialog or a fullscreen UI, based on the screen size:\n\nFor more information about performing fragment transactions, see Fragments.\n\nIn this example, the boolean specifies whether the current device must use the app's large layout design and thus show this fragment as a dialog rather than fullscreen. The best way to set this kind of boolean is to declare a bool resource value with an alternative resource value for different screen sizes. For example, here are two versions of the bool resource for different screen sizes:\n\nThen you can initialize the value during the activity's method, as shown in the following example:\n\nShow an activity as a dialog on large screens\n\nInstead of showing a dialog as a fullscreen UI on small screens, you can get the same result by showing an as a dialog on large screens. The approach you choose depends on your app design, but showing an activity as a dialog is often useful when your app is designed for small screens and you want to improve the experience on tablets by showing a short-lived activity as a dialog.\n\nTo show an activity as a dialog only on large screens, apply the theme to the manifest element:\n\nFor more information about styling your activities with themes, see Styles and themes.\n\nWhen the user taps an action button created with an , the system dismisses the dialog for you.\n\nThe system also dismisses the dialog when the user taps an item in a dialog list, except when the list uses radio buttons or checkboxes. Otherwise, you can manually dismiss your dialog by calling on your .\n\nIf you need to perform certain actions when the dialog goes away, you can implement the method in your .\n\nYou can also cancel a dialog. This is a special event that indicates that the user is leaving the dialog without completing the task. This occurs if the user taps the Back button or taps the screen outside the dialog area or if you explicitly call on the , such as in response to a \"Cancel\" button in the dialog.\n\nAs shown in the preceding example, you can respond to the cancel event by implementing in your class."
    },
    {
        "link": "https://dzone.com/articles/alertdialog-and-dialogfragment-example-in-xamarin",
        "document": "Dialog is like any other window that pops up in front of current window, used to show some short message, taking user input or to ask user decisions. Unlike , a dialog is generally used where user attention is mandate. Android supports several different ways to create a dialog such as and . In this example we will cover all the aspect of AlertDialog and DialogFragment.\n\nis the subclass of that can display one, two or three buttons. If you only want to display a String in this dialog box, use the method.\n\nThe following code snippet can be used to create a simple AlertDialog with two buttons Delete and Cancel.\n\nThe above code snippet will produce the output as shown in the following screenshot.\n\nSince the release of Android 3.0 (API level 11), fragments can show as a dialogue and call as . If you’re supporting older Android versions, you can make use of the fragment-compatibility support library.\n\nTo create a dialogue fragment, we will be using DialogFragment class. This class is derived from the Fragment and behaves much like a fragment with all available fragment life cycle methods. Android recommends using DialogFragment over AlerDialog.\n\nYou need to perform the following steps to create a DialogFragment\n• Create a new class that extends from DialogFragment class.\n• Like regular Fragments, override callback to attach the dialog layout.\n• Alternatively, you can override the method and return a Dialog instance. This method is used to port your old AlertDialog code without much modification.\n\nIn this example, we will see both OnCreateView() and OnCreateDialog() callback.\n\nThe following code snippet shows how to create dialog by overriding OnCreateDialog() method.\n\nDialogFragment is like any other fragment, the same lifecycle rules are applied. Now we have to override onCreateView method to attach the layout to view the hierarchy and construct the dialogue fragment.\n\nLet us first define the layout for your fragment. In this example, I have used two TextViews and Button. My layout looks as follows:\n\nNow let us inflate the layout from OnCreateView() method. My DialogFragment class looks as follows:\n\nThe above code snippet will produce the output as shown in the following screenshot.\n\nWe are pretty much done! Add the following code snippet in your Activity to instantiate and display the dialog;"
    },
    {
        "link": "https://developer.android.com/reference/android/app/AlertDialog.Builder",
        "document": "Creates an with the arguments supplied to this builder. Returns a with the appropriate theme for dialogs created by this Builder. Set a list of items, which are supplied by the given , to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener. Sets whether the dialog is cancelable or not. Set a list of items, which are supplied by the given , to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener. Set the title using the custom view . Set the to be used in the title. Set the resource id of the to be used in the title. Set an icon as supplied by a theme attribute. This method was deprecated in API level 23. This flag is only used for pre-Material themes. Instead, specify the window background using on the alert dialog theme. Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener. Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener. Set the message to display using the given resource id. Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener. Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener. Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener. Set a listener to be invoked when the negative button of the dialog is pressed. Set a listener to be invoked when the negative button of the dialog is pressed. Set a listener to be invoked when the neutral button of the dialog is pressed. Set a listener to be invoked when the neutral button of the dialog is pressed. Sets the callback that will be called if the dialog is canceled. Sets the callback that will be called when the dialog is dismissed for any reason. Sets a listener to be invoked when an item in the list is selected. Sets the callback that will be called if a key is dispatched to the dialog. Set a listener to be invoked when the positive button of the dialog is pressed. Set a listener to be invoked when the positive button of the dialog is pressed. Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener. Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener. Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener. Set a list of items to be displayed in the dialog as the content, you will be notified of the selected item via the supplied listener. Set the title displayed in the . Set the title using the given resource id. Set a custom view resource to be the contents of the Dialog. Sets a custom view to be the contents of the alert dialog. Creates an with the arguments supplied to this builder and immediately displays the dialog.\n\nCreates a builder for an alert dialog that uses an explicit theme resource. The specified theme resource ( ) is applied on top of the parent 's theme. It may be specified as a style resource containing a fully-populated theme, such as , to replace all attributes in the parent 's theme including primary and accent colors. To preserve attributes such as primary and accent colors, the may instead be specified as an overlay theme such as . This will override only the window attributes necessary to style the alert window as a dialog. Alternatively, the may be specified as to use the parent 's resolved value for . : the resource ID of the theme against which to inflate this dialog, or to use the parent 's default alert dialog theme"
    }
]