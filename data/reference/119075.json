[
    {
        "link": "https://pubs.opengroup.org/onlinepubs/009696799/functions/popen.html",
        "document": "The popen() function shall execute the command specified by the string command. It shall create a pipe between the calling program and the executed command, and shall return a pointer to a stream that can be used to either read from or write to the pipe. The environment of the executed command shall be as if a child process were created within the popen() call using the fork() function, and the child invoked the sh utility using the call: where shell path is an unspecified pathname for the sh utility. The popen() function shall ensure that any streams from previous popen() calls that remain open in the parent process are closed in the new child process. The mode argument to popen() is a string that specifies I/O mode:\n• If mode is r, when the child process is started, its file descriptor STDOUT_FILENO shall be the writable end of the pipe, and the file descriptor fileno(stream) in the calling process, where stream is the stream pointer returned by popen(), shall be the readable end of the pipe.\n• If mode is w, when the child process is started its file descriptor STDIN_FILENO shall be the readable end of the pipe, and the file descriptor fileno(stream) in the calling process, where stream is the stream pointer returned by popen(), shall be the writable end of the pipe.\n• If mode is any other value, the result is undefined. After popen(), both the parent and the child process shall be capable of executing independently before either terminates.\n\nUpon successful completion, popen() shall return a pointer to an open stream that can be used to read or write to the pipe. Otherwise, it shall return a null pointer and may set errno to indicate the error.\n\nThe following sections are informative.\n\nSince open files are shared, a mode r command can be used as an input filter and a mode w command as an output filter. Buffered reading before opening an input filter may leave the standard input of that filter mispositioned. Similar problems with an output filter may be prevented by careful buffer flushing; for example, with fflush(). A stream opened by popen() should be closed by pclose(). The behavior of popen() is specified for values of mode of r and w. Other modes such as rb and wb might be supported by specific implementations, but these would not be portable features. Note that historical implementations of popen() only check to see if the first character of mode is r. Thus, a mode of robert the robot would be treated as mode r, and a mode of anything else would be treated as mode w. If the application calls waitpid() or waitid() with a pid argument greater than 0, and it still has a stream that was called with popen() open, it must ensure that pid does not refer to the process started by popen(). To determine whether or not the environment specified in the Shell and Utilities volume of IEEE Std 1003.1-2001 is present, use the function call:\n\nThe popen() function should not be used by programs that have set user (or group) ID privileges. The fork() and exec family of functions (except execlp() and execvp()), should be used instead. This prevents any unforeseen manipulation of the environment of the user that could cause execution of commands not anticipated by the calling program. If the original and popen()ed processes both intend to read or write or read and write a common file, and either will be using FILE-type C functions ( fread(), fwrite(), and so on), the rules for sharing file handles must be observed (see Interaction of File Descriptors and Standard I/O Streams)."
    },
    {
        "link": "https://stackoverflow.com/questions/52211756/is-output-read-from-popened-file-complete-before-pclose",
        "document": "I feel like this means if the associated created by was opened with type in order to read the 's output, then you're not really sure the output has completed until after the call to . But after , the closed must surely be invalid, so how can you ever be certain you've read the entire output of ?\n\nTo illustrate my question by example, consider the following code:\n\nMy questions, as inline above: if we're only certain the output-producing child process has terminated after the , how do we know the content retrieved with the is complete? But if we wait until after the , is invalid, so there's nowhere from which we could retrieve the command's output anymore, right?\n\nThis feels like a chicken-and-egg problem, but I've seen code similar to the above all over, so I'm probably misunderstanding something. I'm grateful for an explanation on this."
    },
    {
        "link": "https://stackoverflow.com/questions/45202379/how-does-popen-work-and-how-to-implement-it-into-c-code-on-linux",
        "document": "Are you familiar with the UNIX philosophy? You might read the beginning of the Wikipedia article \"UNIX Philosophy\". Here is a snippet:\n\nI prefer popen to access many of the Linux tools I find useful. Examples include sort, unique, and sha256sum, and several others. But you may notice the many equivalents are moving into the C++ libraries (std::sort etc) and, with effort, I have found, for example, the code of sha256sum, suitable for compiling within my c++ app.\n\n1) When launched, popen is given a string, which can be in one part identifying an app to run, or in multiple parts, the first is an app, and additions strings are parameters to hand to that app just as if a command line input. Just as in the shell (hint)\n\n2) When launched in 'r' mode, the stdout pipe of sha256sum is directed into the FILE* handle opened by your invocation of popen. Thus the output is 'fed back' to your program.\n\nNot really a useful comment, and not a question. Your snippet of code looks straight forward to me (though substantially c code). Perhaps you should pick a line of code and ask something specific about it?\n\nBut, before you work too hard on your code, let me perform some initial investigation where we will manually run the code we wish to use with popen, and capture results for review against your app's output.\n\nIn your snippet, you are trying the command, \"which driftnet\". An unfortunate choice when the program driftnet does not exist on your PATH.\n\nBecause the command does not exist,, the command 'which' simply returns an empty result.\n\nHard to tell if we did something wrong or not. Without driftnet, I can't help you much either.\n\nsha256sum requires a file for input ... Here I provide my 'C++ Hello World' program, which you might capture to file \"HelloWorld.cc\" (or any where you want), or use any of your own files.\n\nA total of 10 lines of code, starts with a comment, has 1 blank line after the single include. I have my editor set to auto-magically remove trailing spaces. If yours leaves a space in, your result may be different.\n\nSo, what happens when you calculate the sha256sum of the file \"HelloWorld.cc\" from the command line? No need to speculate ... just TRY IT!\n\nOn the command line, invoke the command and see its response on the next line:\n\nPerhaps you might try your popen code with sha256sum and a known file?\n\nNow you can see what the output (of your popen code) might contain. For this investigation, **the command sha256sum result is 1 long string with a space in it.\n\nFYI - I broke my C++ popen code a few months back during an overhaul of my library. When I get it fixed, I plan to revisit your effort to see how you are progressing.\n\nIf your code starts working ... I encourage you to submit your own answer!\n\nIf you can identify more more specific question, refine the question.\n\nI recommend you move to C++ code ... if you are going to learn something, and you want to learn C++, no use studying what you've found.\n\nMy code is working again. (update 2017/8/2)\n\nBut, first let me share a couple of consequences of UNIX Philosophy, in no particular order:\n\nFilters are programs that do one thing well. They accept an input stream, and produce an output stream, typically 'removing' something.\n\nIn the field of code metrics, management can review line counts to get a sense of progress (line count growth slowing), and problems (not slowing).\n\nEvery one has an opinion on code metrics ... not every line in a file should be counted. For example, I think white space is important, but a line of white space should not be counted as code. Similarly, a full line of comment is not code. IMHO.\n\nIn the following command\n\nf1..fn are filters, all submitted as one command to the shell. In my code metrics tool, I created\n\nis a single string submittal to the shell that ultimately cout's 3 numbers.\n\nThe UNIX like command 'wc' probably exists on your system. On Ubuntu 15.10:\n\nA command list is a list of shell commands that each do one thing well. The list identifies a time sequence of execution. A more general idea than pipe and filter.\n\nAs an example, I have set up my editor (emacs) with an assigned key (F8) to provide the following compile command:\n\nThe specific file pfn's are perhaps entered once, but kept in a history buffer inside of emacs and thus no need to reenter them.\n\nNote the 3 semi-colons. They delimit the multiple commands in one string submitted to the Linux command shell. A 3 element command list: set an environment variable to override the default option; export the new flag to make it available to the compiler; and launch a make.\n\nSo? popen() accepts command lists. A 'command list' like shell might accept.\n\nYour command given to popen, runs in a shell.\n\nThis 'stuff' should start to make sense, now. We are accessing the shell to process a command / command list / pipe filters. This starts the 'other' process, and interacts with the first process using the PIPE.\n\nSo how does the output of a command processed in the shell delivered to my code? some clues to understanding follow. Some unit test demo's are included, where you can easily change a popen cmd, and then compile and run the new cmd.\n\nThe following provides code to use popen in one of two modes. Yes they are in 3 class, a base and two derived. The hope is that this allows you to have more than one of these running at a time. (Not terribly useful on my 2 core machine.) Feel free to refactor the code, keeping just what you need. The rest will be here for your continued guidance.\n\nI think it will be easier for copy/paste to split these into 3 sections. But remember, I have all the code in one file. Not a single header file, but it works for me. You can refactor into .h and .cc files, if you wish.\n\nNext I have what I call T514_t, a class which defines my unit test or demo efforts. Entry is in 'exec()'.\n\nIt turns out that the shell used in popen might be different than the shell you experience in a terminal. During the start up of a session, part of shell decides if it is in an interactive (terminal) or non-interactive (no terminal) mode. On my system, the terminal / interactive shell is 'bash', and the popen / non-interactive shell is 'sh'. Remember this when developing shell commands for popen.\n\nAn interesting use of POpenRead_t is in the method \"std::string shellCheck(std::stringstream& rsltSS)\".\n\nAnd finally, my main ... There are only a few things I care to do here.\n\nSo, build, and play with the std::string cmd; in the mode you are interested in. Good luck."
    },
    {
        "link": "https://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html",
        "document": "The popen() function shall execute the command specified by the string command. It shall create a pipe between the calling program and the executed command, and shall return a pointer to a stream that can be used to either read from or write to the pipe. The environment of the executed command shall be as if a child process were created within the popen() call using the fork() function, and the child invoked the sh utility using the call: where shell path is an unspecified pathname for the sh utility. The popen() function shall ensure that any streams from previous popen() calls that remain open in the parent process are closed in the new child process. The mode argument to popen() is a string that specifies I/O mode:\n• If mode is r, when the child process is started, its file descriptor STDOUT_FILENO shall be the writable end of the pipe, and the file descriptor fileno(stream) in the calling process, where stream is the stream pointer returned by popen(), shall be the readable end of the pipe.\n• If mode is w, when the child process is started its file descriptor STDIN_FILENO shall be the readable end of the pipe, and the file descriptor fileno(stream) in the calling process, where stream is the stream pointer returned by popen(), shall be the writable end of the pipe.\n• If mode is any other value, the result is unspecified. After popen(), both the parent and the child process shall be capable of executing independently before either terminates.\n\nThe following sections are informative.\n\nUsing popen() to Obtain a List of Files from the ls Utility The following example demonstrates the use of popen() and pclose() to execute the command ls* in order to obtain a list of files in the current directory: #include <stdio.h> ... \n\n FILE *fp; int status; char path[PATH_MAX]; \n\n fp = popen(\"ls *\", \"r\"); if (fp == NULL) /* Handle error */; \n\n while (fgets(path, PATH_MAX, fp) != NULL) printf(\"%s\", path); \n\n status = pclose(fp); if (status == -1) { /* Error reported by pclose() */ ... } else { /* Use macros described under wait() to inspect `status' in order to determine success/failure of command executed by popen() */ ... }\n\nSince open files are shared, a mode r command can be used as an input filter and a mode w command as an output filter. Buffered reading before opening an input filter may leave the standard input of that filter mispositioned. Similar problems with an output filter may be prevented by careful buffer flushing; for example, with fflush. A stream opened by popen() should be closed by pclose(). The behavior of popen() is specified for values of mode of r and w. Other modes such as rb and wb might be supported by specific implementations, but these would not be portable features. Note that historical implementations of popen() only check to see if the first character of mode is r. Thus, a mode of robert the robot would be treated as mode r, and a mode of anything else would be treated as mode w. If the application calls waitpid() or waitid() with a pid argument greater than 0, and it still has a stream that was called with popen() open, it must ensure that pid does not refer to the process started by popen(). To determine whether or not the environment specified in the Shell and Utilities volume of POSIX.1-2017 is present, use the function call:\n\nThe popen() function should not be used by programs that have set user (or group) ID privileges. The fork() and exec family of functions (except execlp() and execvp()), should be used instead. This prevents any unforeseen manipulation of the environment of the user that could cause execution of commands not anticipated by the calling program. If the original and popen()ed processes both intend to read or write or read and write a common file, and either will be using FILE-type C functions (fread(), fwrite(), and so on), the rules for sharing file handles must be observed (see Interaction of File Descriptors and Standard I/O Streams)."
    },
    {
        "link": "https://ibm.com/docs/en/zos/2.4.0?topic=functions-pclose-close-pipe-stream-from-process",
        "document": "\n• waitpid() with a argument less than or equal to the process ID of the shell command\n• any other function that could do one of the above The pclose() function closes a stream that was opened by popen(), waits for the command specified as an argument in popen() to terminate, and returns the status of the process that was running the shell command. However, if a call caused the termination status to be unavailable to pclose(), then pclose() returns -1 with errno set to ECHILD to report this situation; this can happen if the application calls one of the following functions:\n\nIn any case, pclose() will not return before the child process created by popen() has terminated.\n\nIf the shell command cannot be executed, the child termination status returned by pclose() will be as if the shell command terminated using exit(127) or _exit(127).\n\nThe pclose() function will not affect the termination status of any child of the calling process other than the one created by popen() for the associated stream.\n\nIf the argument stream to pclose() is not a pointer to a stream created by popen(), the termination status returned will be -1.\n\nThreading Behavior: The pclose() function can be executed from any thread within the parent process."
    },
    {
        "link": "https://stackoverflow.com/questions/1120140/how-can-i-read-and-parse-csv-files-in-c",
        "document": "I've never used Boost's Spirit, but am willing to try it. But only if there isn't a more straightforward solution I'm overlooking.\n\nI found this article which looks quite promising: http://www.boost.org/doc/libs/1_35_0/libs/spirit/example/fundamental/list_parser.cpp\n\nI need to load and use CSV file data in C++. At this point it can really just be a comma-delimited parser (ie don't worry about escaping new lines and commas). The main need is a line-by-line parser that will return a vector for the next line each time the method is called.\n\nAs all the CSV questions seem to get redirected here, I thought I'd post my answer here. This answer does not directly address the asker's question. I wanted to be able to read in a stream that is known to be in CSV format, and also the types of each field was already known. Of course, the method below could be used to treat every field to be a string type. As an example of how I wanted to be able to use a CSV input stream, consider the following input (taken from wikipedia's page on CSV): Then, I wanted to be able to read in the data like this: std::istringstream ss(input); std::string title[5]; int year; std::string make, model, desc; float price; csv_istream(ss) >> title[0] >> title[1] >> title[2] >> title[3] >> title[4]; while (csv_istream(ss) >> year >> make >> model >> desc >> price) { //...do something with the record... } This was the solution I ended up with. struct csv_istream { std::istream &is_; csv_istream (std::istream &is) : is_(is) {} void scan_ws () const { while (is_.good()) { int c = is_.peek(); if (c != ' ' && c != '\\t') break; is_.get(); } } void scan (std::string *s = 0) const { std::string ws; int c = is_.get(); if (is_.good()) { do { if (c == ',' || c == '\n\n') break; if (s) { ws += c; if (c != ' ' && c != '\\t') { *s += ws; ws.clear(); } } c = is_.get(); } while (is_.good()); if (is_.eof()) is_.clear(); } } template <typename T, bool> struct set_value { void operator () (std::string in, T &v) const { std::istringstream(in) >> v; } }; template <typename T> struct set_value<T, true> { template <bool SIGNED> void convert (std::string in, T &v) const { if (SIGNED) v = ::strtoll(in.c_str(), 0, 0); else v = ::strtoull(in.c_str(), 0, 0); } void operator () (std::string in, T &v) const { convert<is_signed_int<T>::val>(in, v); } }; template <typename T> const csv_istream & operator >> (T &v) const { std::string tmp; scan(&tmp); set_value<T, is_int<T>::val>()(tmp, v); return *this; } const csv_istream & operator >> (std::string &v) const { v.clear(); scan_ws(); if (is_.peek() != '\"') scan(&v); else { std::string tmp; is_.get(); std::getline(is_, tmp, '\"'); while (is_.peek() == '\"') { v += tmp; v += is_.get(); std::getline(is_, tmp, '\"'); } v += tmp; scan(); } return *this; } template <typename T> const csv_istream & operator >> (T &(*manip)(T &)) const { is_ >> manip; return *this; } operator bool () const { return !is_.fail(); } }; With the following helpers that may be simplified by the new integral traits templates in C++11:\n\nAnother solution similar to Loki Astari's answer, in C++11. Rows here are s of a given type. The code scans one line, then scans until each delimiter, and then converts and dumps the value directly into the tuple (with a bit of template code).\n• quite clean and simple to use, only C++11.\n• no error handling in case of malformed CSV. #include <iterator> #include <sstream> #include <string> namespace csvtools { /// Read the last element of the tuple without calling recursively template <std::size_t idx, class... fields> typename std::enable_if<idx >= std::tuple_size<std::tuple<fields...>>::value - 1>::type read_tuple(std::istream &in, std::tuple<fields...> &out, const char delimiter) { std::string cell; std::getline(in, cell, delimiter); std::stringstream cell_stream(cell); cell_stream >> std::get<idx>(out); } /// Read the @p idx-th element of the tuple and then calls itself with @p idx + 1 to /// read the next element of the tuple. Automatically falls in the previous case when /// reaches the last element of the tuple thanks to enable_if template <std::size_t idx, class... fields> typename std::enable_if<idx < std::tuple_size<std::tuple<fields...>>::value - 1>::type read_tuple(std::istream &in, std::tuple<fields...> &out, const char delimiter) { std::string cell; std::getline(in, cell, delimiter); std::stringstream cell_stream(cell); cell_stream >> std::get<idx>(out); read_tuple<idx + 1, fields...>(in, out, delimiter); } } /// Iterable csv wrapper around a stream. @p fields the list of types that form up a row. template <class... fields> class csv { std::istream &_in; const char _delim; public: typedef std::tuple<fields...> value_type; class iterator; /// Construct from a stream. inline csv(std::istream &in, const char delim) : _in(in), _delim(delim) {} /// Status of the underlying stream /// @{ inline bool good() const { return _in.good(); } inline const std::istream &underlying_stream() const { return _in; } /// @} inline iterator begin(); inline iterator end(); private: /// Reads a line into a stringstream, and then reads the line into a tuple, that is returned inline value_type read_row() { std::string line; std::getline(_in, line); std::stringstream line_stream(line); std::tuple<fields...> retval; csvtools::read_tuple<0, fields...>(line_stream, retval, _delim); return retval; } }; /// Iterator; just calls recursively @ref csv::read_row and stores the result. template <class... fields> class csv<fields...>::iterator { csv::value_type _row; csv *_parent; public: typedef std::input_iterator_tag iterator_category; typedef csv::value_type value_type; typedef std::size_t difference_type; typedef csv::value_type * pointer; typedef csv::value_type & reference; /// Construct an empty/end iterator inline iterator() : _parent(nullptr) {} /// Construct an iterator at the beginning of the @p parent csv object. inline iterator(csv &parent) : _parent(parent.good() ? &parent : nullptr) { ++(*this); } /// Read one row, if possible. Set to end if parent is not good anymore. inline iterator &operator++() { if (_parent != nullptr) { _row = _parent->read_row(); if (!_parent->good()) { _parent = nullptr; } } return *this; } inline iterator operator++(int) { iterator copy = *this; ++(*this); return copy; } inline csv::value_type const &operator*() const { return _row; } inline csv::value_type const *operator->() const { return &_row; } bool operator==(iterator const &other) { return (this == &other) or (_parent == nullptr and other._parent == nullptr); } bool operator!=(iterator const &other) { return not (*this == other); } }; template <class... fields> typename csv<fields...>::iterator csv<fields...>::begin() { return iterator(*this); } template <class... fields> typename csv<fields...>::iterator csv<fields...>::end() { return iterator(); } I put a tiny working example on GitHub; I've been using it for parsing some numerical data and it served its purpose.\n\nHere is another implementation of a Unicode CSV parser (works with wchar_t). I wrote part of it, while Jonathan Leffler wrote the rest. Note: This parser is aimed at replicating Excel's behavior as closely as possible, specifically when importing broken or malformed CSV files. This is the original question - Parsing CSV file with multiline fields and escaped double quotes This is the code as a SSCCE (Short, Self-Contained, Correct Example). #include <stdbool.h> #include <wchar.h> #include <wctype.h> extern const wchar_t *nextCsvField(const wchar_t *p, wchar_t sep, bool *newline); // Returns a pointer to the start of the next field, // or zero if this is the last field in the CSV // p is the start position of the field // sep is the separator used, i.e. comma or semicolon // newline says whether the field ends with a newline or with a comma const wchar_t *nextCsvField(const wchar_t *p, wchar_t sep, bool *newline) { // Parse quoted sequences if ('\"' == p[0]) { p++; while (1) { // Find next double-quote p = wcschr(p, L'\"'); // If we don't find it or it's the last symbol // then this is the last field if (!p || !p[1]) return 0; // Check for \"\", it is an escaped double-quote if (p[1] != '\"') break; // Skip the escaped double-quote p += 2; } } // Find next newline or comma. wchar_t newline_or_sep[4] = L\"\n\n\\r \"; newline_or_sep[2] = sep; p = wcspbrk(p, newline_or_sep); // If no newline or separator, this is the last field. if (!p) return 0; // Check if we had newline. *newline = (p[0] == '\\r' || p[0] == '\n\n'); // Handle \"\\r\n\n\", otherwise just increment if (p[0] == '\\r' && p[1] == '\n\n') p += 2; else p++; return p; } static wchar_t *csvFieldData(const wchar_t *fld_s, const wchar_t *fld_e, wchar_t *buffer, size_t buflen) { wchar_t *dst = buffer; wchar_t *end = buffer + buflen - 1; const wchar_t *src = fld_s; if (*src == L'\"') { const wchar_t *p = src + 1; while (p < fld_e && dst < end) { if (p[0] == L'\"' && p+1 < fld_s && p[1] == L'\"') { *dst++ = p[0]; p += 2; } else if (p[0] == L'\"') { p++; break; } else *dst++ = *p++; } src = p; } while (src < fld_e && dst < end) *dst++ = *src++; if (dst >= end) return 0; *dst = L'\\0'; return(buffer); } static void dissect(const wchar_t *line) { const wchar_t *start = line; const wchar_t *next; bool eol; wprintf(L\"Input %3zd: [%.*ls]\n\n\", wcslen(line), wcslen(line)-1, line); while ((next = nextCsvField(start, L',', &eol)) != 0) { wchar_t buffer[1024]; wprintf(L\"Raw Field: [%.*ls] (eol = %d)\n\n\", (next - start - eol), start, eol); if (csvFieldData(start, next-1, buffer, sizeof(buffer)/sizeof(buffer[0])) != 0) wprintf(L\"Field %3zd: [%ls]\n\n\", wcslen(buffer), buffer); start = next; } } static const wchar_t multiline[] = L\"First field of first row,\\\"This field is multiline\n\n\" \"\n\n\" \"but that's OK because it's enclosed in double quotes, and this\n\n\" \"is an escaped \\\"\\\" double quote\\\" but this one \\\"\\\" is not\n\n\" \" \\\"This is second field of second row, but it is not multiline\n\n\" \" because it doesn't start \n\n\" \" with an immediate double quote\\\"\n\n\" ; int main(void) { wchar_t line[1024]; while (fgetws(line, sizeof(line)/sizeof(line[0]), stdin)) dissect(line); dissect(multiline); return 0; }\n\nThe first thing you need to do is make sure the file exists. To accomplish this you just need to try and open the file stream at the path. After you have opened the file stream use stream.fail() to see if it worked as expected, or not. You must also verify that the file provided is the correct type of file. To accomplish this you need to look through the file path provided until you find the file extension. Once you have the file extension make sure that it is a .csv file. bool verifyExtension(string filename) { int period = 0; for (unsigned int i = 0; i < filename.length(); i++) { if (filename[i] == '.') period = i; } string extension; for (unsigned int i = period; i < filename.length(); i++) extension += filename[i]; if (extension == \".csv\") return true; else return false; } This function will return the file extension which is used later in an error message. string getExtension(string filename) { int period = 0; for (unsigned int i = 0; i < filename.length(); i++) { if (filename[i] == '.') period = i; } string extension; if (period != 0) { for (unsigned int i = period; i < filename.length(); i++) extension += filename[i]; } else extension = \"NO FILE\"; return extension; } This function will actually call the error checks created above and then parse through the file. void parseFile(string fileName) { if (fileExists(fileName) && verifyExtension(fileName)) { ifstream fs; fs.open(fileName.c_str()); string fileCommand; while (fs.good()) { string temp; getline(fs, fileCommand, '\n\n'); for (unsigned int i = 0; i < fileCommand.length(); i++) { if (fileCommand[i] != ',') temp += fileCommand[i]; else temp += \" \"; } if (temp != \"\\0\") { // Place your code here to run the file. } } fs.close(); } else if (!fileExists(fileName)) { cout << \"Error: The provided file does not exist: \" << fileName << endl; if (!verifyExtension(fileName)) { if (getExtension(fileName) != \"NO FILE\") cout << \"\\tCheck the file extension.\" << endl; else cout << \"\\tThere is no file in the provided path.\" << endl; } } else if (!verifyExtension(fileName)) { if (getExtension(fileName) != \"NO FILE\") cout << \"Incorrect file extension provided: \" << getExtension(fileName) << endl; else cout << \"There is no file in the following path: \" << fileName << endl; } }"
    },
    {
        "link": "https://stackoverflow.com/questions/59595581/parsing-a-csv-file-c",
        "document": "You do not need anything special to parse files, the STL containers from C++11 on provide all the tools necessary to parse virtually any file. You do not need to know the number of values per-row you are parsing before hand, though you will need to know the type of value you are reading from the in order to apply the proper conversion of values. You do not need any third-party library like Boost either.\n\nThere are many ways to store the values parsed from a file. The basic \"handle any type\" approach is to store the values in a (which essentially provides a vector of vectors holding the values parsed from each line). You can specialize the storage as needed depending on the type you are reading and how you need to convert and store the values. Your base storage can be , , , or just a basic type like . Whatever fits your data.\n\nIn your case you have basic values in your file. The only caveat to a basic parse is the fact you may have blank lines in between the lines of values. That's easily handled by any number of tests. For instance you can check if the of the line read is zero, or for a bit more flexibility (in handling lines with containing multiple whitespace or other non-value characters), you can use to find the first wanted value in the line to determine if it is a line to parse.\n\nFor example, in your case, your read loop for your lines of value can simply read each line and check whether the line contains a . It can be as simple as:\n\nAbove, each line is read into and then is checked on whether or not it contains digits. If so, parse it. If not, go get the next line and try again.\n\nIf it is a line containing values, then you can create a from the line and read integer values from the stringstream into a temporary value and add the value to a temporary vector of , consume the comma with and the delimiter , and when you run out of values to read from the line, add the temporary vector of to your final storage. (Repeat until all lines are read).\n\nYour complete read loop could be:\n\nThere is no limit on the number of values read per-line, or the number of lines of values read per-file (up to the limits of your virtual memory for storage)\n\nPutting the above together in a short example, you could do something similar to the following which just reads your input file and then outputs the collected integers when done:\n\nUsing an input file with miscellaneous blank lines and two-integers per-line on the lines containing values as you describe in your question:\n\nExample Input Unknown/Uneven No. of Columns\n\nYou don't need to know the number of values per-line in the or the number of lines of values in the file. The STL containers handle the memory allocation needs automatically allowing you to parse whatever you need. Now you may want to enforce some fixed number of values per-row, or rows per-file, but that is simply up to you to add simple counters and checks to your read/parse routine to limit the values stored as needed.\n\nWithout any changes to the code above, it will handle any number of comma-separated-values per-line. For example, changing your data file to:\n\nResults in the expected parse of each value from each line, e.g.:\n\nLet me know if you have questions that I didn't cover or if you have additional questions about something I did and I'm happy to help further."
    },
    {
        "link": "https://geeksforgeeks.org/csv-file-management-using-c",
        "document": "CSV is a simple file format used to store tabular data such as a spreadsheet or a database. CSV stands for Comma Separated Values. The data fields in a CSV file are separated/delimited by a comma (‘, ‘) and the individual rows are separated by a newline (‘\n\n’). CSV File management in C++ is similar to text-type file management, except for a few modifications.\n\nThis article discusses about how to create, update and delete records in a CSV file:\n\nNote: Here, a reportcard.csv file has been created to store the student’s roll number, name and marks in math, physics, chemistry and biology.\n• Create operation: \n\n The create operation is similar to creating a text file, i.e. input data from the user and write it to the csv file using the file pointer and appropriate delimiters(‘,’) between different columns and ‘\n\n’ after the end of each row. // opens an existing csv file or creates a new file. Output:\n• Read a particular record: \n\n In reading a CSV file, the following approach is implemented:-\n• None Using getline(), file pointer and ‘\n\n’ as the delimiter, read an entire row and store it in a string variable.\n• None Using stringstream, separate the row into words.\n• None Now using getline(), the stringstream pointer and ‘, ‘ as the delimiter, read every word in the row, store it in a string variable and push that variable to a string vector.\n• None Retrieve a required column data through row[index]. Here, row[0] always stores the roll number of a student, so compare row[0] with the roll number input by the user, and if it matches, display the details of the student and break from the loop. Note: Here, since whatever data reading from the file, is stored in string format, so always convert string to the required datatype before comparing or calculating, etc. // of which the data is required \"of the student to display details: \" // Read the Data from the file // read every column data of a row and Output:\n• Update a record: \n\n The following approach is implemented while updating a record:-\n• None Read data from a file and compare it with the user input, as explained under read operation.\n• None Ask the user to enter new values for the record to be updated.\n• None update row[index] with the new data. Here, index refers to the required column field that is to be updated.\n• None Write the updated record and all other records into a new file(‘reportcardnew.csv’).\n• None At the end of operation, remove the old file and rename the new file, with the old file name, i.e. remove ‘reportcard.csv’ and rename ‘reportcardnew.csv’ with ‘reportcard.csv’ // Get the roll number from the user \"of the record to be updated: \" // Get the data to be updated // Determine the index of the subject // Physics has index 3, and so on // Get the new marks // into the new file using fout. // the last column data ends with a '\n\n' // renaming the updated file with the existing file name Output:\n• Delete a record: \n\n The following approach is implemented while deleting a record\n• None Read data from a file and compare it with the user input, as explained under read and update operation.\n• None Write all the updated records, except the data to be deleted, onto a new file(reportcardnew.csv).\n• None Remove the old file, and rename the new file, with the old file’s name. // Create a new file to store the non-deleted data // to decide the data to be deleted \"of the record to be deleted: \" // If exists, leave it and // add all other data to the new file // except the record to be deleted, // into the new file 'reportcardnew.csv' // renaming the new file with the existing file name Output:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/openfiles",
        "document": "Enables an administrator to query, display, or disconnect files and directories that have been opened on a system. This command also enables or disables the system Maintain Objects List global flag.\n\nEnables an administrator to disconnect files and folders that have been opened remotely through a shared folder.\n\nSpecifies the remote system to connect to (by name or IP address). Don't use backslashes. If you don't use the /s option, the command is run on the local computer by default. This parameter applies to all files and folders that are specified in the command. Runs the command using the permissions of the specified user account. If you don't use the /u option, system permissions are used by default. Specifies the password of the user account that is specified in the /u option. If you don't use the /p option, a password prompt appears when the command is run. Disconnects open files by the specified file ID. You can use the wildcard character (*) with this parameter. Note: You can use the openfiles /query command to find the file ID. Disconnects all open files associated with the user name specified in the accessedby parameter. You can use the wildcard character (*) with this parameter. Disconnects all open files with the specified open mode value. Valid values are Read, Write, or Read/Write. You can use the wildcard character (*) with this parameter. Disconnects all open file connections that are created by a specific open file name. You can use the wildcard character (*) with this parameter. Displays help at the command prompt.\n\nTo disconnect all open files with the file ID 26843578, type:\n\nTo disconnect all open files and directories accessed by the user hiropln, type:\n\nTo disconnect all open files and directories with read/write mode, type:\n\nTo disconnect the directory with the open file name *C:\\testshare*, regardless of who is accessing it, type:\n\nTo disconnect all open files on the remote computer srvmain that are being accessed by the user hiropln, regardless of their ID, type:\n\nTo query and display all open files, type:\n\nTo query and display all open files in table format without headers, type:\n\nTo query and display all open files in list format with detailed information, type:\n\nTo query and display all open files on the remote system srvmain by using the credentials for the user hiropln on the maindom domain, type:\n\nEnables or disables the system Maintain Objects List global flag. If used without parameters, openfiles /local displays the current status of the Maintain Objects List global flag.\n\nTo check the current status of the Maintain Objects List global flag, type:\n\nBy default, the Maintain Objects List global flag is disabled, and the following message appears, INFO: The system global flag 'maintain objects list' is currently disabled.\n\nThe following message appears when the global flag is enabled, SUCCESS: The system global flag 'maintain objects list' is enabled. This will take effect after the system is restarted."
    },
    {
        "link": "https://gormanalysis.com/blog/reading-and-writing-csv-files-with-cpp",
        "document": "As a data scientist, reading and writing data from/to CSV is one of the most common tasks I do on the daily. R, my language of choice, makes this easy with and (although I tend to use and from the data.table package).\n\nHot Take. C++ is not R.\n\nAs far as I know, there is no CSV reader/writer built into the C++ STL. That’s not a knock against C++; it’s just a lower level language. If we want to read and write CSV files with C++, we’ll have to deal with File I/O, data types, and some low level logic on how to read, parse, and write data. For me, this is a necessary step in order to build and test more fun programs like machine learning models.\n\nWe’ll start by creating a simple CSV file with one column of integer data. And we’ll give it the header Foo.\n\nHere, ofstream is an “output file stream”. Since it’s derived from ostream, we can treat it just like cout (which is also derived from ostream). The result of executing this program is that we get a file called foo.csv in the same directory as our executable. Let’s wrap this into a function that’s a little more dynamic.\n\nCool. Now we can use to write a vector of integers to a CSV file with ease. Let’s expand on this to support multiple vectors of integers and corresponding column names.\n\n// Make a CSV file with one or more columns of integer values // Each column of data is represented by the pair <column name, column data> // The dataset is represented as a vector of these columns // Note that all columns should be the same size // No comma at end of line // No comma at end of line // Make three vectors, each of length 100 filled with 1s, 2s, and 3s\n\nHere we’ve represented each column of data as a of , and the whole dataset as a of such columns. Now we can write a variable number of integer columns to a CSV file.\n\nNow that we’ve written some CSV files, let’s attempt to read them. For now let’s correctly assume that our file contains integer data plus one row of column names at the top.\n\n// Reads a CSV file into a vector of <string, vector<int>> pairs where // Create a vector of <string, int vector> pairs to store the result // Make sure the file is open // Extract the first line in the file // Keep track of the current column index // Add the current integer to the 'colIdx' column's values vector // If the next token is a comma, ignore it and move on // Write to another file to check that this was successful\n\nThis program reads our previously created CSV files and writes each dataset to a new file, essentially creating copies of our original files.\n\nSo far we’ve seen how to read and write datasets with integer values only. Extending this to read/write a dataset of only doubles or only strings should be fairly straight-forward. Reading a dataset with unknown, mixed data types is another beast and beyond the scope of this article, but see this code review for possible solutions.\n\nSpecial thanks to papagaga and Incomputable for helping me with this topic via codereview.stackexchange.com."
    },
    {
        "link": "https://stackoverflow.com/questions/671461/how-can-i-execute-external-commands-in-c-linux",
        "document": "I just want to know which is the best way to execute an external command in C++ and how can I grab the output if there is any?\n\nEdit: I Guess I had to tell that I'm a newbie here in this world, so I think I'm gonna need a working example. For example I want to execute a command like:\n\nhow do I do that?"
    },
    {
        "link": "https://raymii.org/s/articles/Execute_a_command_and_get_both_output_and_exit_code.html",
        "document": "Published: 07-06-2021 | Author: Remy van Elst | Text only version of this article\n\n❗ This post is over three years old. It may no longer be up to date. Opinions may have changed.\n\nRecently I had to parse some command line output inside a C++ program. Executing a command and getting just the exit status is easy using , but also getting output is a bit harder and OS specific. By using , a POSIX function we can get both the exit status as well as the output of a given command. On Windows I'm using , so the code should be cross platform, except for the exit status on Windows is alway 0, that concept does not exist there. This article starts off with a stack overflow example to get just the output of a command and builds on that to a safer version (null-byte handling) that returns both the exit status as well as the command output. It also involves a lot of detail on vs and how to handle binary data.\n\nRecently I removed all Google Ads from this site due to their invasive tracking, as well as Google Analytics. Please, if you found this content useful, consider a small donation using any of the options below. It means the world to me if you show your appreciation and you'll help pay the server costs:\n\n\n\n GitHub Sponsorship\n\n\n\n PCBWay referral link (You get $5, I get $20 after you've placed an order)\n\n\n\n Digital Ocea referral link ($200 credit for 60 days. Spend $25 after your credit expires and I'll get $25!)\n\n\n\n\n\nThe complete code example with usage examples can be found on github here or at the bottom of this page. A working example is compiled on github actions for different platforms (windows & linux).\n\nNormally I would advise against parsing command line output. It is error-prone, you're dependent on the language selected by the user, different versions might have different flags ( vs ) and much more. If you have the option to use a native library, you should use that. An example could be parsing output to get some data from an API. There are probably a metric ton of libraries available for your favorite programming language to use instead of parsing the or or output.\n\nIn my case I have to use an old program to parse a closed-source file to get some binary output. This is a temporary situation, a native parsing library is also under development. The binary is under my control as well as the system settings, language, other tools and such, so for this specific use case the solution to parse command line output was acceptable for the time being.\n\nDo note that in this post I'll interchange the term nullbyte, null character, null termination and null-terminated. They all mean the same, the null-byte character used to end a C string ( , or , or , you get the gist).\n\nIf you need more features, more cross-platform or async execution, boost.Process is a great alternative. I however can't use boost on the environment this code is going to run due to compiler and size constraints.\n\nThe stackoverflow example using fgets\n\nOn stackoverflow the example given is a good base to build on, however, to get the exit code and the output, it must be modified. Because we want to also grab the exit code, we cannot use the example which uses the . Which in itself is a great example of using a with a custom deleter ( is a with the command to execute:\n\nThe code is copied below:\n\nThis example does what it states, but with a few gotchas. It uses a (pointer), buffer allocation and manually closing the when something goes wrong ( ). The example is more modern, due to not having to handle the exception and using a instead of a C-style buffer. Exception throwing is a whole other issue, but let's not get into that today. What we are going to get into today is C style code to read from and how binary data is handled.\n\nThe stackoverflow example is probably just fine if you only need textual output into a . My usecase however was a bit more complex, as you'll find out while reading the rest of this artice.\n\nCode style aside, my biggest issue was that using in this way combined with adding a to a stops when it encounters a ( ). For regular string output that often is not an issue, most commands just output a few strings and call it a day. My output returns a binary blob, which might include nullbytes. reads an amount of bytes and returns how much it has read successfully, which we can use when adding the output to our including the nullbytes.\n\nThe example above does , adding a to a , in this case according to cppreference on operator+= on std::string: Appends the null-terminated character string pointed to by s.\n\nThe problem therein lies that the characters after the nullbyte should be added as well in my case. does not give back the amount of data it read. Using and a buffer of 128, if I have a nullbyte at 10 and a newline at 40, then the first 10 bytes plus what is after 40 bytes will be returned. Effectively we're loosing everything in between the nullbyte and the newline, or until the end of the buffer (128) if there is no newline in between.\n\ndoes return the amount of bytes it has read. Combining that with a constructor of that takes a and a we can force the entire contents inside the string. This is safe, since a knows its size, it does not rely on a null-termination character. However, other code that uses will not be able to work with these nullbytes, keep that in mind.\n\nThis stackoverflow post was very helpful for me to understand , as well as help from a co-worker that dreams in , he explained a lot of the inner workings.\n\nAnd if, after all of this, you're wondering why I'm shoehorning binary data inside a , great question. I'll probably go into that another time since that would require a longer post than this entire article.\n\nMy code checks the exit status of the executed binary (for error handling) and uses the data returned for further processing. To keep this all in one handy dandy place, lets start with defining a struct to hold that data. It will hold the result of a , so the name sounds descriptive enough.\n\nBelow you'll find the struct code, including an equality operator as well as a stream output operator.\n\nThe meat and potatoes of the struct are of course the and . I'm using an for the exit status because of reasons.\n\nThe next part is the class itself, here is that code:\n\nThe command will run until there are no more bytes returned from the command output. I know the kind of output I'm working with so my buffer is 1 MiB, which is probably too large for your data. In my case I benchmarked it and between 10KiB and 1 MiB was the fastest on the target architecture. 128 or 8192 is just fine as well probably, but you should benchmark that for yourself. A rather simple test is to output some enormous file with and take the execution time plus cpu and memory usage. Don't print the result, just look at those three things and choose what ratio is acceptable for you.\n\nWhy not also initialize the with 1 MiB of characters? cannot be allocated for a given size at construction, other than by filling them or afterwards calling , my benchmarks did not show any meaningful speed or performance boost by doing either.\n\nUsing the above code is easy. Since it's a static function, you don't need a class instance to use it. Here is an example:\n\nSince we're going through a shell, redirection works as well. Redirecting to results in no output, just an exit status:\n\nThe output is on in my shell however, which is expected:\n\nIf you do need to capture then you redirect output the other way around, like so:\n\nPipes work as well as in your shell, but do note that this is all using and you have no control over environment variables or the default shell. Read more on the POSIX page on to find out why that is.\n\nHere is an example for Windows, where we must use and :\n\nThe exit code will always be zero since that concept does not translate to windows. There is , but that is only an environment variable for console applications, not the actual exit status.\n\nThe microsoft page also notes that will not work with GUI applications, just console programs. If you need that, use Boost.process or .\n\nIn the example code on github you'll also see a function, I've left that in there to show the difference in nullbyte handling. For reference I'll show an example here as well. The relevant part of command using :\n\nThe nullbyte character is substituted with in the above output. Here is a screenshot showing how it looks in my terminal:\n\nOnce again do note that this is safe to use with , methods that take a or a probably will not react very well to nullbytes. For my use case this is safe, your milage may vary.\n\nTry playing with the size and then looking at the output. If you set it to 4, the output with is . Funny right? I like such things.\n\nBelow you can find the header file . It is also on my github. If you want usage examples you can find them in the github project file."
    },
    {
        "link": "https://mayhem.security/blog/best-practices-for-secure-programming-in-c",
        "document": "Despite the introduction of multiple programming languages over the past few years, C++ still remains one of the most powerful and widely used programming languages among developers. It’s widely known for its efficiency and performance, which allows developers to create reliable and high-performing applications.\n\nHowever, like any other programming language, C++ faces security vulnerabilities. As a developer, secure programming should be among your top priorities during development. Secure programming ensures that you follow all the best practices available to maintain the integrity of the applications you’re developing. Whether you are developing small utility applications or working on complex systems, ensuring the security of your code is really important, as this will help protect user data while preventing issues like unauthorized access.\n\nAs a C++ developer, being aware of the possible security threats you are bound to encounter will come in handy. With the correct understanding of the potential threats, you can easily address them while cleaning your code and ensuring its efficiency. Some of the most common threats include:\n• Buffer overflow: This is the most common security concern associated with C++ applications. It occurs when a program writes data beyond the set bound of a buffer. This leads to the adjacent memory becoming corrupt. This threat can be exploited, leading to arbitrary code, overwriting critical data, or crashing the application.\n• Integer overflow and underflow: This mostly occurs when the value you’re trying to store in an integer exceeds the maximum value that can be represented. Underflow occurs when the value is less than the minimum value that can be represented. This may lead to unexpected memory behavior, including corruption and potential breach. This includes use-after-free, double-free, and uninitialized memory access, which may lead to the exploitation of the program (by injecting malicious code or gaining unauthorized access).\n• Injection attacks: This involves the insertion of malicious code into a program, which may lead to unintended execution. Some common types of injection associated with C++ include code injection and command injection.\n• Pointer initialization: Using a pointer that is not correctly initialized may lead to the exposure of a lot of sensitive data. Additionally, if the uninitialized pointer is used, it may lead to the program reading or writing to an unexpected memory location.\n• Incorrect type conversion: This is also known as type punning. It occurs when a program treats one data type as if it were a different one. This may cause data to be lost.\n\nBest Practices for Secure Coding in C++\n\nFollowing best practices when developing applications using C++ will help you minimize vulnerabilities and also protect your applications against security threats.\n• Input validation and sanitization: It’s always a good practice to validate and sanitize the user input. This will help prevent attacks such as SQL injection and command injections. Validation techniques such as regular expressions, input length checks, and input format validation can be used to enforce the expected input format. Additionally, make sure that you always validate and sanitize input from external sources.\n• Memory management: Make use of memory management techniques such as dynamic memory allocation to prevent memory leaks and corruption. You should also consider utilizing smart pointers and “Resource Acquisition Is Initialization” (RAII) to automatically manage memory and resources, which will reduce the risks related to memory.\n• Secure coding techniques: Be sure that you always use the secure standard libraries, functions, and containers such as std::vector, std::string, and std::unordered_map when writing code in C++. This helps handle memory management as well as prevent issues like buffer overflows and memory corruption.\n• Error handling and logging: Implement proper error handling mechanisms to prevent information leakage in case of failures. Be sure to follow secure logging practices, which will help you maintain an audit trail and facilitate incident response.\n• Access control and privileges: By enforcing proper access control, you will be able to limit user privileges and prevent unauthorized access to sensitive data by restricting permissions based on user roles and responsibilities. This can be achieved using techniques such as role-based access control (RBAC) or discretionary access control (DAC).\n\nExamples of Secure Coding Techniques in C++\n\nThe techniques below will help you enhance the security of your C++ applications and thereby mitigate some common security threats.\n\nTo protect your application from potential attacks, it’s a good practice to always validate user input. Below is an example of validating and filtering user input in which we validate the username against a set of allowed characters and lengths.\n\nSmart pointers provide automatic memory management and help prevent memory leaks. Meanwhile, the RAII ensures timely resource deallocation. Below, you’ll see an example of acquiring and releasing resources along with automatic deallocation when it goes out of scope to prevent memory leaks.\n\nProper error handling prevents information leakage. In the example below, the function throws an exception when the input value is negative. The exception is then handled in the main function, thus avoiding potential vulnerabilities.\n\nIn addition to best practices and secure coding techniques, there are still several considerations that C++ developers can implement to further enhance their application’s security. These include:\n\nIt’s important to note that secure programming is an ongoing process. Developers should stay up to date with the latest security practices and regularly update their code and libraries to address any known threats. By prioritizing security in the development process, developers can strengthen the security of their applications.\n\nInvesting time and effort in secure programming will not only help protect user data but also help strengthen trust among users and maintain the integrity of the system. Remember that writing secure C++ code should be your responsibility as a developer."
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/cpp/errors-and-exception-handling-modern-cpp?view=msvc-170",
        "document": "Modern C++ best practices for exceptions and error handling\n\nIn modern C++, in most scenarios, the preferred way to report and handle both logic errors and runtime errors is to use exceptions. It's especially true when the stack might contain several function calls between the function that detects the error, and the function that has the context to handle the error. Exceptions provide a formal, well-defined way for code that detects errors to pass the information up the call stack.\n\nProgram errors are often divided into two categories:\n• Logic errors caused by programming mistakes. For example, an \"index out of range\" error.\n• Runtime errors that are beyond the control of programmer. For example, a \"network service unavailable\" error.\n\nIn C-style programming and in COM, error reporting is managed either by returning a value that represents an error code or a status code for a particular function, or by setting a global variable that the caller may optionally retrieve after every function call to see whether errors were reported. For example, COM programming uses the return value to communicate errors to the caller. And the Win32 API has the function to retrieve the last error reported by the call stack. In both of these cases, it's up to the caller to recognize the code and respond to it appropriately. If the caller doesn't explicitly handle the error code, the program might crash without warning. Or, it might continue to execute using bad data and produce incorrect results.\n\nExceptions are preferred in modern C++ for the following reasons:\n• An exception forces calling code to recognize an error condition and handle it. Unhandled exceptions stop program execution.\n• An exception jumps to the point in the call stack that can handle the error. Intermediate functions can let the exception propagate. They don't have to coordinate with other layers.\n• The exception stack-unwinding mechanism destroys all objects in scope after an exception is thrown, according to well-defined rules.\n• An exception enables a clean separation between the code that detects the error and the code that handles the error.\n\nThe following simplified example shows the necessary syntax for throwing and catching exceptions in C++:\n\nExceptions in C++ resemble ones in languages such as C# and Java. In the block, if an exception is thrown it is caught by the first associated block whose type matches that of the exception. In other words, execution jumps from the statement to the statement. If no usable catch block is found, is invoked and the program exits. In C++, any type may be thrown; however, we recommend that you throw a type that derives directly or indirectly from . In the previous example, the exception type, , is defined in the standard library in the header file. C++ doesn't provide or require a block to make sure all resources are released if an exception is thrown. The resource acquisition is initialization (RAII) idiom, which uses smart pointers, provides the required functionality for resource cleanup. For more information, see How to: Design for exception safety. For information about the C++ stack-unwinding mechanism, see Exceptions and stack unwinding.\n\nRobust error handling is challenging in any programming language. Although exceptions provide several features that support good error handling, they can't do all the work for you. To realize the benefits of the exception mechanism, keep exceptions in mind as you design your code.\n• Use asserts to check for conditions that should always be true or always be false. Use exceptions to check for errors that might occur, for example, errors in input validation on parameters of public functions. For more information, see the Exceptions versus assertions section.\n• Use exceptions when the code that handles the error is separated from the code that detects the error by one or more intervening function calls. Consider whether to use error codes instead in performance-critical loops, when code that handles the error is tightly coupled to the code that detects it.\n• For every function that might throw or propagate an exception, provide one of the three exception guarantees: the strong guarantee, the basic guarantee, or the nothrow ( ) guarantee. For more information, see How to: Design for exception safety.\n• Throw exceptions by value, catch them by reference. Don't catch what you can't handle.\n• Don't use exception specifications, which are deprecated in C++11. For more information, see the Exception specifications and section.\n• Use standard library exception types when they apply. Derive custom exception types from the Class hierarchy.\n• Don't allow exceptions to escape from destructors or memory-deallocation functions.\n\nThe exception mechanism has a minimal performance cost if no exception is thrown. If an exception is thrown, the cost of the stack traversal and unwinding is roughly comparable to the cost of a function call. Other data structures are required to track the call stack after a block is entered, and more instructions are required to unwind the stack if an exception is thrown. However, in most scenarios, the cost in performance and memory footprint isn't significant. The adverse effect of exceptions on performance is likely to be significant only on memory-constrained systems. Or, in performance-critical loops, where an error is likely to occur regularly and there's tight coupling between the code to handle it and the code that reports it. In any case, it's impossible to know the actual cost of exceptions without profiling and measuring. Even in those rare cases when the cost is significant, you can weigh it against the increased correctness, easier maintainability, and other advantages that are provided by a well-designed exception policy.\n\nExceptions and asserts are two distinct mechanisms for detecting run-time errors in a program. Use statements to test for conditions during development that should always be true or always be false if all your code is correct. There's no point in handling such an error by using an exception, because the error indicates that something in the code has to be fixed. It doesn't represent a condition that the program has to recover from at run time. An stops execution at the statement so that you can inspect the program state in the debugger. An exception continues execution from the first appropriate catch handler. Use exceptions to check error conditions that might occur at run time even if your code is correct, for example, \"file not found\" or \"out of memory.\" Exceptions can handle these conditions, even if the recovery just outputs a message to a log and ends the program. Always check arguments to public functions by using exceptions. Even if your function is error-free, you might not have complete control over arguments that a user might pass to it.\n\nBoth C and C++ programs can use the structured exception handling (SEH) mechanism in the Windows operating system. The concepts in SEH resemble the ones in C++ exceptions, except that SEH uses the , , and constructs instead of and . In the Microsoft C++ compiler (MSVC), C++ exceptions are implemented for SEH. However, when you write C++ code, use the C++ exception syntax.\n\nFor more information about SEH, see Structured Exception Handling (C/C++).\n\nException specifications were introduced in C++ as a way to specify the exceptions that a function might throw. However, exception specifications proved problematic in practice, and are deprecated in the C++11 draft standard. We recommend that you don't use exception specifications except for , which indicates that the function allows no exceptions to escape. If you must use exception specifications of the deprecated form , MSVC support is limited. For more information, see Exception Specifications (throw). The specifier is introduced in C++11 as the preferred alternative to .\n\nHow to: Interface between exceptional and non-exceptional code\n\n C++ language reference\n\n C++ Standard Library"
    },
    {
        "link": "https://labex.io/tutorials/cpp-how-to-manage-system-command-variations-419004",
        "document": "System commands are essential tools for interacting with the operating system, allowing developers to execute various tasks programmatically. In C++, managing system commands requires understanding different execution methods and potential challenges.\n\nThere are several ways to execute system commands in C++:\n\nThe most straightforward method is using the standard function:\n\nWhen executing system commands, developers must consider:"
    }
]