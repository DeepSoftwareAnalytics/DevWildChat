[
    {
        "link": "https://tortoisesvn.net/docs/release/TortoiseSVN_en/tsvn-dug-locking.html",
        "document": "Subversion generally works best without locking, using the “Copy-Modify-Merge” methods described earlier in the section called “The Copy-Modify-Merge Solution”. However there are a few instances when you may need to implement some form of locking policy.\n\nFirstly you need to ensure that your Subversion server is upgraded to at least version 1.2. Earlier versions do not support locking at all. If you are using access, then of course only your client needs to be updated.\n\nThe Three Meanings of In this section, and almost everywhere in this book, the words “lock” and “locking” describe a mechanism for mutual exclusion between users to avoid clashing commits. Unfortunately, there are two other sorts of “lock” with which Subversion, and therefore this book, sometimes needs to be concerned. The second is , used internally by Subversion to prevent clashes between multiple Subversion clients operating on the same working copy. Usually you get these locks whenever a command like update/commit/... is interrupted due to an error. These locks can be removed by running the cleanup command on the working copy, as described in the section called “Cleanup”. And third, files and folders can get locked if they're in use by another process, for example if you have a word document opened in Word, that file is locked and can not be accessed by TortoiseSVN. You can generally forget about these other kinds of locks until something goes wrong that requires you to care about them. In this book, “lock” means the first sort unless the contrary is either clear from context or explicitly stated.\n\nBy default, nothing is locked and anyone who has commit access can commit changes to any file at any time. Others will update their working copies periodically and changes in the repository will be merged with local changes. If you Get a Lock on a file, then only you can commit that file. Commits by all other users will be blocked until you release the lock. A locked file cannot be modified in any way in the repository, so it cannot be deleted or renamed either, except by the lock owner. A lock is not assigned to a specific user, but to a specific user and a working copy. Having a lock in one working copy also prevents the same user from committing the locked file from another working copy. As an example, imagine that user Jon has a working copy on his office PC. There he starts working on an image, and therefore acquires a lock on that file. When he leaves his office he's not finished yet with that file, so he doesn't release that lock. Back at home Jon also has a working copy and decides to work a little more on the project. But he can't modify or commit that same image file, because the lock for that file resides in his working copy in the office. However, other users will not necessarily know that you have taken out a lock. Unless they check the lock status regularly, the first they will know about it is when their commit fails, which in most cases is not very useful. To make it easier to manage locks, there is a new Subversion property . When this property is set (to any value) on a file, whenever the file is checked out or updated, the local copy is made read-only unless that working copy holds a lock for the file. This acts as a warning that you should not edit that file unless you have first acquired a lock. Files which are versioned and read-only are marked with a special overlay in TortoiseSVN to indicate that you need to acquire a lock before editing. Locks are recorded by working copy location as well as by owner. If you have several working copies (at home, at work) then you can only hold a lock in one of those working copies. If one of your co-workers acquires a lock and then goes on holiday without releasing it, what do you do? Subversion provides a means to force locks. Releasing a lock held by someone else is referred to as Breaking the lock, and forcibly acquiring a lock which someone else already holds is referred to as Stealing the lock. Naturally these are not things you should do lightly if you want to remain friends with your co-workers. Locks are recorded in the repository, and a lock token is created in your local working copy. If there is a discrepancy, for example if someone else has broken the lock, the local lock token becomes invalid. The repository is always the definitive reference.\n\nSelect the file(s) in your working copy for which you want to acquire a lock, then select the command TortoiseSVN → Get Lock.... \n\n A dialog appears, allowing you to enter a comment, so others can see why you have locked the file. The comment is optional and currently only used with Svnserve based repositories. If (and only if) you need to steal the lock from someone else, check the Steal lock box, then click on OK. You can set the project property to provide a message template for users to fill in as the lock message. Refer to the section called “Project Settings” for instructions on how to set properties. If you select a folder and then use TortoiseSVN → Get Lock... the lock dialog will open with every file in every sub-folder selected for locking. If you really want to lock an entire hierarchy, that is the way to do it, but you could become very unpopular with your co-workers if you lock them out of the whole project. Use with care ...\n\nTo make sure you don't forget to release a lock you don't need any more, locked files are shown in the commit dialog and selected by default. If you continue with the commit, locks you hold on the selected files are removed, even if the files haven't been modified. If you don't want to release a lock on certain files, you can uncheck them (if they're not modified). If you want to keep a lock on a file you've modified, you have to enable the Keep locks checkbox before you commit your changes. To release a lock manually, select the file(s) in your working copy for which you want to release the lock, then select the command TortoiseSVN → Release Lock There is nothing further to enter so TortoiseSVN will contact the repository and release the locks. You can also use this command on a folder to release all locks recursively.\n\n\n\n To see what locks you and others hold, you can use TortoiseSVN → Check for Modifications.... Locally held lock tokens show up immediately. To check for locks held by others (and to see if any of your locks are broken or stolen) you need to click on Check Repository. From the context menu here, you can also get and release locks, as well as breaking and stealing locks held by others. If you break or steal someone else's lock without telling them, you could potentially cause loss of work. If you are working with unmergeable file types and you steal someone else's lock, once you release the lock they are free to check in their changes and overwrite yours. Subversion doesn't lose data, but you have lost the team-working protection that locking gave you."
    },
    {
        "link": "https://svnbook.red-bean.com/en/1.7/svn.advanced.locking.html",
        "document": "This documentation was written to describe the 1.7.x series of Apache™ Subversion®. If you are running a different version of Subversion, you are strongly encouraged to visit http://www.svnbook.com/ and instead consult the version of this documentation appropriate for your version of Subversion.\n\nSubversion's copy-modify-merge version control model lives and dies on its data merging algorithms—specifically on how well those algorithms perform when trying to resolve conflicts caused by multiple users modifying the same file concurrently. Subversion itself provides only one such algorithm: a three-way differencing algorithm that is smart enough to handle data at a granularity of a single line of text. Subversion also allows you to supplement its content merge processing with external differencing utilities (as described in the section called “External diff3” and the section called “External merge”), some of which may do an even better job, perhaps providing granularity of a word or a single character of text. But common among those algorithms is that they generally work only on text files. The landscape starts to look pretty grim when you start talking about content merges of nontextual file formats. And when you can't find a tool that can handle that type of merging, you begin to run into problems with the copy-modify-merge model.\n\nLet's look at a real-life example of where this model runs aground. Harry and Sally are both graphic designers working on the same project, a bit of marketing collateral for an automobile mechanic. Central to the design of a particular poster is an image of a car in need of some bodywork, stored in a file using the PNG image format. The poster's layout is almost finished, and both Harry and Sally are pleased with the particular photo they chose for their damaged car—a baby blue 1967 Ford Mustang with an unfortunate bit of crumpling on the left front fender.\n\nNow, as is common in graphic design work, there's a change in plans, which causes the car's color to be a concern. So Sally updates her working copy to , fires up her photo-editing software, and sets about tweaking the image so that the car is now cherry red. Meanwhile, Harry, feeling particularly inspired that day, decides that the image would have greater impact if the car also appears to have suffered greater impact. He, too, updates to , and then draws some cracks on the vehicle's windshield. He manages to finish his work before Sally finishes hers, and after admiring the fruits of his undeniable talent, he commits the modified image. Shortly thereafter, Sally is finished with the car's new finish and tries to commit her changes. But, as expected, Subversion fails the commit, informing Sally that her version of the image is now out of date.\n\nHere's where the difficulty sets in. If Harry and Sally were making changes to a text file, Sally would simply update her working copy, receiving Harry's changes in the process. In the worst possible case, they would have modified the same region of the file, and Sally would have to work out by hand the proper resolution to the conflict. But these aren't text files—they are binary images. And while it's a simple matter to describe what one would expect the results of this content merge to be, there is precious little chance that any software exists that is smart enough to examine the common baseline image that each of these graphic artists worked against, the changes that Harry made, and the changes that Sally made, and then spit out an image of a busted-up red Mustang with a cracked windshield!\n\nOf course, things would have gone more smoothly if Harry and Sally had serialized their modifications to the image—if, say, Harry had waited to draw his windshield cracks on Sally's now-red car, or if Sally had tweaked the color of a car whose windshield was already cracked. As is discussed in the section called “The copy-modify-merge solution”, most of these types of problems go away entirely where perfect communication between Harry and Sally exists. But as one's version control system is, in fact, one form of communication, it follows that having that software facilitate the serialization of nonparallelizable editing efforts is no bad thing. This is where Subversion's implementation of the lock-modify-unlock model steps into the spotlight. This is where we talk about Subversion's locking feature, which is similar to the “reserved checkouts” mechanisms of other version control systems.\n\nSubversion's locking feature exists ultimately to minimize wasted time and effort. By allowing a user to programmatically claim the exclusive right to change a file in the repository, that user can be reasonably confident that any energy he invests on unmergeable changes won't be wasted—his commit of those changes will succeed. Also, because Subversion communicates to other users that serialization is in effect for a particular versioned object, those users can reasonably expect that the object is about to be changed by someone else. They, too, can then avoid wasting their time and energy on unmergeable changes that won't be committable due to eventual out-of-dateness.\n\nWhen referring to Subversion's locking feature, one is actually talking about a fairly diverse collection of behaviors, which include the ability to lock a versioned file (claiming the exclusive right to modify the file), to unlock that file (yielding that exclusive right to modify), to see reports about which files are locked and by whom, to annotate files for which locking before editing is strongly advised, and so on. In this section, we'll cover all of these facets of the larger locking feature.\n\nThe Three Meanings of “Lock” In this section, and almost everywhere in this book, the words “lock” and “locking” describe a mechanism for mutual exclusion between users to avoid clashing commits. Unfortunately, there are two other sorts of “lock” with which Subversion, and therefore this book, sometimes needs to be concerned. The second is working copy locks, used internally by Subversion to prevent clashes between multiple Subversion clients operating on the same working copy. This is the sort of lock indicated by an in the third column of svn status output, and removed by the svn cleanup command, as described in the section called “Sometimes You Just Need to Clean Up”. Third, there are database locks, used internally by the Berkeley DB backend to prevent clashes between multiple programs trying to access the database. This is the sort of lock whose unwanted persistence after an error can cause a repository to be “wedged,” as described in the section called “Berkeley DB Recovery”. You can generally forget about these other kinds of locks until something goes wrong that requires you to care about them. In this book, “lock” means the first sort unless the contrary is either clear from context or explicitly stated.\n\nIn the Subversion repository, a lock is a piece of metadata that grants exclusive access to one user to change a file. This user is said to be the lock owner. Each lock also has a unique identifier, typically a long string of characters, known as the lock token. The repository manages locks, ultimately handling their creation, enforcement, and removal. If any commit transaction attempts to modify or delete a locked file (or delete one of the parent directories of the file), the repository will demand two pieces of information—that the client performing the commit be authenticated as the lock owner, and that the lock token has been provided as part of the commit process as a form of proof that the client knows which lock it is using. To demonstrate lock creation, let's refer back to our example of multiple graphic designers working on the same binary image files. Harry has decided to change a JPEG image. To prevent other people from committing changes to the file while he is modifying it (as well as alerting them that he is about to change it), he locks the file in the repository using the svn lock command. The preceding example demonstrates a number of new things. First, notice that Harry passed the ( ) option to svn lock. Similar to svn commit, the svn lock command can take comments—via either ( ) or ( )—to describe the reason for locking the file. Unlike svn commit, however, svn lock will not demand a message by launching your preferred text editor. Lock comments are optional, but still recommended to aid communication. Second, the lock attempt succeeded. This means that the file wasn't already locked, and that Harry had the latest version of the file. If Harry's working copy of the file had been out of date, the repository would have rejected the request, forcing Harry to svn update and reattempt the locking command. The locking command would also have failed if the file had already been locked by someone else. As you can see, the svn lock command prints confirmation of the successful lock. At this point, the fact that the file is locked becomes apparent in the output of the svn status and svn info reporting subcommands. $ svn status K banana.jpg $ svn info banana.jpg Path: banana.jpg Name: banana.jpg Working Copy Root Path: /home/harry/project URL: http://svn.example.com/repos/project/banana.jpg Repository Root: http://svn.example.com/repos/project Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec Revision: 2198 Node Kind: file Schedule: normal Last Changed Author: frank Last Changed Rev: 1950 Last Changed Date: 2006-03-15 12:43:04 -0600 (Wed, 15 Mar 2006) Text Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006) Properties Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006) Checksum: 3b110d3b10638f5d1f4fe0f436a5a2a5 Lock Token: opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e Lock Owner: harry Lock Created: 2006-06-14 17:20:31 -0500 (Wed, 14 Jun 2006) Lock Comment (1 line): Editing file for tomorrow's release. $ The fact that the svn info command, which does not contact the repository when run against working copy paths, can display the lock token reveals an important piece of information about those tokens: they are cached in the working copy. The presence of the lock token is critical. It gives the working copy authorization to make use of the lock later on. Also, the svn status command shows a next to the file (short for locKed), indicating that the lock token is present. A lock token isn't an authentication token, so much as an authorization token. The token isn't a protected secret. In fact, a lock's unique token is discoverable by anyone who runs . A lock token is special only when it lives inside a working copy. It's proof that the lock was created in that particular working copy, and not somewhere else by some other client. Merely authenticating as the lock owner isn't enough to prevent accidents. For example, suppose you lock a file using a computer at your office, but leave work for the day before you finish your changes to that file. It should not be possible to accidentally commit changes to that same file from your home computer later that evening simply because you've authenticated as the lock's owner. In other words, the lock token prevents one piece of Subversion-related software from undermining the work of another. (In our example, if you really need to change the file from an alternative working copy, you would need to break the lock and relock the file.) Now that Harry has locked , Sally is unable to change or delete that file: $ svn delete banana.jpg D banana.jpg $ svn commit -m \"Delete useless file.\" Deleting banana.jpg svn: E175002: Commit failed (details follow): svn: E175002: Server sent unexpected return value (423 Locked) in response to DELETE request for '/repos/project/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc 35d/banana.jpg' $ But Harry, after touching up the banana's shade of yellow, is able to commit his changes to the file. That's because he authenticates as the lock owner and also because his working copy holds the correct lock token: Notice that after the commit is finished, svn status shows that the lock token is no longer present in the working copy. This is the standard behavior of svn commit—it searches the working copy (or list of targets, if you provide such a list) for local modifications and sends all the lock tokens it encounters during this walk to the server as part of the commit transaction. After the commit completes successfully, all of the repository locks that were mentioned are released—even on files that weren't committed. This is meant to discourage users from being sloppy about locking or from holding locks for too long. If Harry haphazardly locks 30 files in a directory named because he's unsure of which files he needs to change, yet changes only four of those files, when he runs , the process will still release all 30 locks. This behavior of automatically releasing locks can be overridden with the option to svn commit. This is best used for those times when you want to commit changes, but still plan to make more changes and thus need to retain existing locks. You can also make this your default behavior by setting the runtime configuration option (see the section called “Runtime Configuration Area”). Of course, locking a file doesn't oblige one to commit a change to it. The lock can be released at any time with a simple svn unlock command:\n\nWhen a commit fails due to someone else's locks, it's fairly easy to learn about them. The easiest way is to run : In this example, Sally can see not only that her copy of is out of date, but also that one of the two modified files she plans to commit is locked in the repository. The symbol stands for “Other,” meaning that a lock exists on the file and was created by somebody else. If she were to attempt a commit, the lock on would prevent it. Sally is left wondering who made the lock, when, and why. Once again, svn info has the answers: $ svn info ^/raisin.jpg Path: raisin.jpg Name: raisin.jpg URL: http://svn.example.com/repos/project/raisin.jpg Repository Root: http://svn.example.com/repos/project Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec Revision: 105 Node Kind: file Last Changed Author: sally Last Changed Rev: 32 Last Changed Date: 2006-01-25 12:43:04 -0600 (Sun, 25 Jan 2006) Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b Lock Owner: harry Lock Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006) Lock Comment (1 line): Need to make a quick tweak to this image. $ Just as you can use svn info to examine objects in the working copy, you can also use it to examine objects in the repository. If the main argument to svn info is a working copy path, then all of the working copy's cached information is displayed; any mention of a lock means that the working copy is holding a lock token (if a file is locked by another user or in another working copy, svn info on a working copy path will show no lock information at all). If the main argument to svn info is a URL, the information reflects the latest version of an object in the repository, and any mention of a lock describes the current lock on the object. So in this particular example, Sally can see that Harry locked the file on February 16 to “make a quick tweak.” It being June, she suspects that he probably forgot all about the lock. She might phone Harry to complain and ask him to release the lock. If he's unavailable, she might try to forcibly break the lock herself or ask an administrator to do so.\n\nA repository lock isn't sacred—in Subversion's default configuration state, locks can be released not only by the person who created them, but by anyone. When somebody other than the original lock creator destroys a lock, we refer to this as breaking the lock. From the administrator's chair, it's simple to break locks. The svnlook and svnadmin programs have the ability to display and remove locks directly from the repository. (For more information about these tools, see the section called “An Administrator's Toolkit”.) $ svnadmin lslocks /var/svn/repos Path: /project2/images/banana.jpg UUID Token: opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923 Owner: frank Created: 2006-06-15 13:29:18 -0500 (Thu, 15 Jun 2006) Expires: Comment (1 line): Still improving the yellow color. Path: /project/raisin.jpg UUID Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b Owner: harry Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006) Expires: Comment (1 line): Need to make a quick tweak to this image. $ svnadmin rmlocks /var/svn/repos /project/raisin.jpg Removed lock on '/project/raisin.jpg'. $ The more interesting option is to allow users to break each other's locks over the network. To do this, Sally simply needs to pass the to the svn unlock command: $ svn status -u M 23 bar.c M O 32 raisin.jpg * 72 foo.h Status against revision: 105 $ svn unlock raisin.jpg svn: E195013: 'raisin.jpg' is not locked in this working copy $ svn info raisin.jpg | grep URL URL: http://svn.example.com/repos/project/raisin.jpg $ svn unlock http://svn.example.com/repos/project/raisin.jpg svn: warning: W160039: Unlock failed on 'raisin.jpg' (403 Forbidden) $ svn unlock --force http://svn.example.com/repos/project/raisin.jpg 'raisin.jpg' unlocked. $ Now, Sally's initial attempt to unlock failed because she ran svn unlock directly on her working copy of the file, and no lock token was present. To remove the lock directly from the repository, she needs to pass a URL to svn unlock. Her first attempt to unlock the URL fails, because she can't authenticate as the lock owner (nor does she have the lock token). But when she passes , the authentication and authorization requirements are ignored, and the remote lock is broken. Simply breaking a lock may not be enough. In the running example, Sally may not only want to break Harry's long-forgotten lock, but relock the file for her own use. She can accomplish this by using svn unlock with and then svn lock back-to-back, but there's a small chance that somebody else might lock the file between the two commands. The simpler thing to do is to steal the lock, which involves breaking and relocking the file all in one atomic step. To do this, Sally passes the option to svn lock: $ svn lock raisin.jpg svn: warning: W160035: Path '/project/raisin.jpg' is already locked by user 'h arry' in filesystem '/var/svn/repos/db' $ svn lock --force raisin.jpg 'raisin.jpg' locked by user 'sally'. $ In any case, whether the lock is broken or stolen, Harry may be in for a surprise. Harry's working copy still contains the original lock token, but that lock no longer exists. The lock token is said to be defunct. The lock represented by the lock token has either been broken (no longer in the repository) or stolen (replaced with a different lock). Either way, Harry can see this by asking svn status to contact the repository: If the repository lock was broken, then ( ) displays a (Broken) symbol next to the file. If a new lock exists in place of the old one, then a (sTolen) symbol is shown. Finally, svn update notices any defunct lock tokens and removes them from the working copy. Different systems have different notions of how strict a lock should be. Some folks argue that locks must be strictly enforced at all costs, releasable only by the original creator or administrator. They argue that if anyone can break a lock, chaos runs rampant and the whole point of locking is defeated. The other side argues that locks are first and foremost a communication tool. If users are constantly breaking each other's locks, it represents a cultural failure within the team and the problem falls outside the scope of software enforcement. Subversion defaults to the “softer” approach, but still allows administrators to create stricter enforcement policies through the use of hook scripts. In particular, the pre-lock and pre-unlock hooks allow administrators to decide when lock creation and lock releases are allowed to happen. Depending on whether a lock already exists, these two hooks can decide whether to allow a certain user to break or steal a lock. The post-lock and post-unlock hooks are also available, and can be used to send email after locking actions. To learn more about repository hooks, see the section called “Implementing Repository Hooks”.\n\nWe've seen how svn lock and svn unlock can be used to create, release, break, and steal locks. This satisfies the goal of serializing commit access to a file. But what about the larger problem of preventing wasted time? For example, suppose Harry locks an image file and then begins editing it. Meanwhile, miles away, Sally wants to do the same thing. She doesn't think to run , so she has no idea that Harry has already locked the file. She spends hours editing the file, and when she tries to commit her change, she discovers that either the file is locked or that she's out of date. Regardless, her changes aren't mergeable with Harry's. One of these two people has to throw away his or her work, and a lot of time has been wasted. Subversion's solution to this problem is to provide a mechanism to remind users that a file ought to be locked before the editing begins. The mechanism is a special property: . If that property is attached to a file (regardless of its value, which is irrelevant), Subversion will try to use filesystem-level permissions to make the file read-only—unless, of course, the user has explicitly locked the file. When a lock token is present (as a result of using svn lock), the file becomes read/write. When the lock is released, the file becomes read-only again. The theory, then, is that if the image file has this property attached, Sally would immediately notice something is strange when she opens the file for editing: many applications alert users immediately when a read-only file is opened for editing, and nearly all would prevent her from saving changes to the file. This reminds her to lock the file before editing, whereby she discovers the preexisting lock: $ /usr/local/bin/gimp raisin.jpg gimp: error: file is read-only! $ ls -l raisin.jpg -r--r--r-- 1 sally sally 215589 Jun 8 19:23 raisin.jpg $ svn lock raisin.jpg svn: warning: W160035: Path '/project/raisin.jpg' is already locked by user 'h arry' in filesystem '/var/svn/repos/db' $ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b Lock Owner: harry Lock Created: 2006-06-08 07:29:18 -0500 (Thu, 08 June 2006) Lock Comment (1 line): Making some tweaks. Locking for the next two hours. $ Users and administrators alike are encouraged to attach the property to any file that cannot be contextually merged. This is the primary technique for encouraging good locking habits and preventing wasted effort. Note that this property is a communication tool that works independently from the locking system. In other words, any file can be locked, whether or not this property is present. And conversely, the presence of this property doesn't make the repository require a lock when committing. Unfortunately, the system isn't flawless. It's possible that even when a file has the property, the read-only reminder won't always work. Sometimes applications misbehave and “hijack” the read-only file, silently allowing users to edit and save the file anyway. There's not much that Subversion can do in this situation—at the end of the day, there's simply no substitution for good interpersonal communication."
    },
    {
        "link": "https://stackoverflow.com/questions/242744/using-svn-to-lock-documents-for-editing-and-update-notifications",
        "document": "Recently developers highlighted that it is bit hard for them to keep track of which document has been updated. And they thus suggested that using SVN to keep track of document changes will be better as they will be able to know if document if being updated when doing checking out of the project.\n\nBut i also highlighted the several cons that may occur\n• Binary file using up alot of diskspace everytime word, excel document is commited\n• Checkout a project will take much more time although we can separate the documents into another project in the repository\n• It will take time to teach personnel on how to use SVN.\n\nAnother feature is that for these kind of functional documents, it should be locked while editing.\n\nAnyone have any idea on how to go about it? Or what are the pros and cons to it. Please feel free to share with me."
    },
    {
        "link": "https://stackoverflow.com/questions/569948/force-user-to-lock-file-in-svn-before-editing",
        "document": "We have some files in our project that can't be merged and hence the files must be locked by the users before editing them. Is there a way to force the user to lock a file before editing?\n\nWe are using Subversion and TortoiseSVN / VisualSVN."
    },
    {
        "link": "https://svnbook.red-bean.com/en/1.6/svn.advanced.locking.html",
        "document": "This documentation was written to describe the 1.6.x series of Subversion. If you are running a different version of Subversion, you are strongly encouraged to visit http://www.svnbook.com/ and instead consult the version of this documentation appropriate for your version of Subversion.\n\nSubversion's copy-modify-merge version control model lives and dies on its data merging algorithms—specifically on how well those algorithms perform when trying to resolve conflicts caused by multiple users modifying the same file concurrently. Subversion itself provides only one such algorithm: a three-way differencing algorithm that is smart enough to handle data at a granularity of a single line of text. Subversion also allows you to supplement its content merge processing with external differencing utilities (as described in the section called “External diff3” and the section called “External merge”), some of which may do an even better job, perhaps providing granularity of a word or a single character of text. But common among those algorithms is that they generally work only on text files. The landscape starts to look pretty grim when you start talking about content merges of nontextual file formats. And when you can't find a tool that can handle that type of merging, you begin to run into problems with the copy-modify-merge model.\n\nLet's look at a real-life example of where this model runs aground. Harry and Sally are both graphic designers working on the same project, a bit of marketing collateral for an automobile mechanic. Central to the design of a particular poster is an image of a car in need of some bodywork, stored in a file using the PNG image format. The poster's layout is almost finished, and both Harry and Sally are pleased with the particular photo they chose for their damaged car—a baby blue 1967 Ford Mustang with an unfortunate bit of crumpling on the left front fender.\n\nNow, as is common in graphic design work, there's a change in plans, which causes the car's color to be a concern. So Sally updates her working copy to , fires up her photo-editing software, and sets about tweaking the image so that the car is now cherry red. Meanwhile, Harry, feeling particularly inspired that day, decides that the image would have greater impact if the car also appears to have suffered greater impact. He, too, updates to , and then draws some cracks on the vehicle's windshield. He manages to finish his work before Sally finishes hers, and after admiring the fruits of his undeniable talent, he commits the modified image. Shortly thereafter, Sally is finished with the car's new finish and tries to commit her changes. But, as expected, Subversion fails the commit, informing Sally that her version of the image is now out of date.\n\nHere's where the difficulty sets in. If Harry and Sally were making changes to a text file, Sally would simply update her working copy, receiving Harry's changes in the process. In the worst possible case, they would have modified the same region of the file, and Sally would have to work out by hand the proper resolution to the conflict. But these aren't text files—they are binary images. And while it's a simple matter to describe what one would expect the results of this content merge to be, there is precious little chance that any software exists that is smart enough to examine the common baseline image that each of these graphic artists worked against, the changes that Harry made, and the changes that Sally made, and then spit out an image of a busted-up red Mustang with a cracked windshield!\n\nOf course, things would have gone more smoothly if Harry and Sally had serialized their modifications to the image—if, say, Harry had waited to draw his windshield cracks on Sally's now-red car, or if Sally had tweaked the color of a car whose windshield was already cracked. As is discussed in the section called “The copy-modify-merge solution”, most of these types of problems go away entirely where perfect communication between Harry and Sally exists. But as one's version control system is, in fact, one form of communication, it follows that having that software facilitate the serialization of nonparallelizable editing efforts is no bad thing. This is where Subversion's implementation of the lock-modify-unlock model steps into the spotlight. This is where we talk about Subversion's locking feature, which is similar to the “reserved checkouts” mechanisms of other version control systems.\n\nSubversion's locking feature exists ultimately to minimize wasted time and effort. By allowing a user to programmatically claim the exclusive right to change a file in the repository, that user can be reasonably confident that any energy he invests on unmergeable changes won't be wasted—his commit of those changes will succeed. Also, because Subversion communicates to other users that serialization is in effect for a particular versioned object, those users can reasonably expect that the object is about to be changed by someone else. They, too, can then avoid wasting their time and energy on unmergeable changes that won't be committable due to eventual out-of-dateness.\n\nWhen referring to Subversion's locking feature, one is actually talking about a fairly diverse collection of behaviors, which include the ability to lock a versioned file (claiming the exclusive right to modify the file), to unlock that file (yielding that exclusive right to modify), to see reports about which files are locked and by whom, to annotate files for which locking before editing is strongly advised, and so on. In this section, we'll cover all of these facets of the larger locking feature.\n\nThe Three Meanings of “Lock” In this section, and almost everywhere in this book, the words “lock” and “locking” describe a mechanism for mutual exclusion between users to avoid clashing commits. Unfortunately, there are two other sorts of “lock” with which Subversion, and therefore this book, sometimes needs to be concerned. The second is working copy locks, used internally by Subversion to prevent clashes between multiple Subversion clients operating on the same working copy. This is the sort of lock indicated by an in the third column of svn status output, and removed by the svn cleanup command, as described in the section called “Sometimes You Just Need to Clean Up”. Third, there are database locks, used internally by the Berkeley DB backend to prevent clashes between multiple programs trying to access the database. This is the sort of lock whose unwanted persistence after an error can cause a repository to be “wedged,” as described in the section called “Berkeley DB Recovery”. You can generally forget about these other kinds of locks until something goes wrong that requires you to care about them. In this book, “lock” means the first sort unless the contrary is either clear from context or explicitly stated.\n\nIn the Subversion repository, a lock is a piece of metadata that grants exclusive access to one user to change a file. This user is said to be the lock owner. Each lock also has a unique identifier, typically a long string of characters, known as the lock token. The repository manages locks, ultimately handling their creation, enforcement, and removal. If any commit transaction attempts to modify or delete a locked file (or delete one of the parent directories of the file), the repository will demand two pieces of information—that the client performing the commit be authenticated as the lock owner, and that the lock token has been provided as part of the commit process as a form of proof that the client knows which lock it is using. To demonstrate lock creation, let's refer back to our example of multiple graphic designers working on the same binary image files. Harry has decided to change a JPEG image. To prevent other people from committing changes to the file while he is modifying it (as well as alerting them that he is about to change it), he locks the file in the repository using the svn lock command. The preceding example demonstrates a number of new things. First, notice that Harry passed the ( ) option to svn lock. Similar to svn commit, the svn lock command can take comments—via either ( ) or ( )—to describe the reason for locking the file. Unlike svn commit, however, svn lock will not demand a message by launching your preferred text editor. Lock comments are optional, but still recommended to aid communication. Second, the lock attempt succeeded. This means that the file wasn't already locked, and that Harry had the latest version of the file. If Harry's working copy of the file had been out of date, the repository would have rejected the request, forcing Harry to svn update and reattempt the locking command. The locking command would also have failed if the file had already been locked by someone else. As you can see, the svn lock command prints confirmation of the successful lock. At this point, the fact that the file is locked becomes apparent in the output of the svn status and svn info reporting subcommands. $ svn status K banana.jpg $ svn info banana.jpg Path: banana.jpg Name: banana.jpg URL: http://svn.example.com/repos/project/banana.jpg Repository Root: http://svn.example.com/repos/project Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec Revision: 2198 Node Kind: file Schedule: normal Last Changed Author: frank Last Changed Rev: 1950 Last Changed Date: 2006-03-15 12:43:04 -0600 (Wed, 15 Mar 2006) Text Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006) Properties Last Updated: 2006-06-08 19:23:07 -0500 (Thu, 08 Jun 2006) Checksum: 3b110d3b10638f5d1f4fe0f436a5a2a5 Lock Token: opaquelocktoken:0c0f600b-88f9-0310-9e48-355b44d4a58e Lock Owner: harry Lock Created: 2006-06-14 17:20:31 -0500 (Wed, 14 Jun 2006) Lock Comment (1 line): Editing file for tomorrow's release. $ The fact that the svn info command, which does not contact the repository when run against working copy paths, can display the lock token reveals an important piece of information about those tokens: they are cached in the working copy. The presence of the lock token is critical. It gives the working copy authorization to make use of the lock later on. Also, the svn status command shows a next to the file (short for locKed), indicating that the lock token is present. A lock token isn't an authentication token, so much as an authorization token. The token isn't a protected secret. In fact, a lock's unique token is discoverable by anyone who runs . A lock token is special only when it lives inside a working copy. It's proof that the lock was created in that particular working copy, and not somewhere else by some other client. Merely authenticating as the lock owner isn't enough to prevent accidents. For example, suppose you lock a file using a computer at your office, but leave work for the day before you finish your changes to that file. It should not be possible to accidentally commit changes to that same file from your home computer later that evening simply because you've authenticated as the lock's owner. In other words, the lock token prevents one piece of Subversion-related software from undermining the work of another. (In our example, if you really need to change the file from an alternative working copy, you would need to break the lock and relock the file.) Now that Harry has locked , Sally is unable to change or delete that file: $ svn delete banana.jpg D banana.jpg $ svn commit -m \"Delete useless file.\" Deleting banana.jpg svn: Commit failed (details follow): svn: Server sent unexpected return value (423 Locked) in response to DELETE\\ request for '/repos/project/!svn/wrk/64bad3a9-96f9-0310-818a-df4224ddc35d/\\ banana.jpg' $ But Harry, after touching up the banana's shade of yellow, is able to commit his changes to the file. That's because he authenticates as the lock owner and also because his working copy holds the correct lock token: Notice that after the commit is finished, svn status shows that the lock token is no longer present in the working copy. This is the standard behavior of svn commit—it searches the working copy (or list of targets, if you provide such a list) for local modifications and sends all the lock tokens it encounters during this walk to the server as part of the commit transaction. After the commit completes successfully, all of the repository locks that were mentioned are released—even on files that weren't committed. This is meant to discourage users from being sloppy about locking or from holding locks for too long. If Harry haphazardly locks 30 files in a directory named because he's unsure of which files he needs to change, yet changes only four of those files, when he runs , the process will still release all 30 locks. This behavior of automatically releasing locks can be overridden with the option to svn commit. This is best used for those times when you want to commit changes, but still plan to make more changes and thus need to retain existing locks. You can also make this your default behavior by setting the runtime configuration option (see the section called “Runtime Configuration Area”). Of course, locking a file doesn't oblige one to commit a change to it. The lock can be released at any time with a simple svn unlock command:\n\nWhen a commit fails due to someone else's locks, it's fairly easy to learn about them. The easiest way is to run : In this example, Sally can see not only that her copy of is out of date, but also that one of the two modified files she plans to commit is locked in the repository. The symbol stands for “Other,” meaning that a lock exists on the file and was created by somebody else. If she were to attempt a commit, the lock on would prevent it. Sally is left wondering who made the lock, when, and why. Once again, svn info has the answers: $ svn info ^/raisin.jpg Path: raisin.jpg Name: raisin.jpg URL: http://svn.example.com/repos/project/raisin.jpg Repository Root: http://svn.example.com/repos/project Repository UUID: edb2f264-5ef2-0310-a47a-87b0ce17a8ec Revision: 105 Node Kind: file Last Changed Author: sally Last Changed Rev: 32 Last Changed Date: 2006-01-25 12:43:04 -0600 (Sun, 25 Jan 2006) Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b Lock Owner: harry Lock Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006) Lock Comment (1 line): Need to make a quick tweak to this image. $ Just as you can use svn info to examine objects in the working copy, you can also use it to examine objects in the repository. If the main argument to svn info is a working copy path, then all of the working copy's cached information is displayed; any mention of a lock means that the working copy is holding a lock token (if a file is locked by another user or in another working copy, svn info on a working copy path will show no lock information at all). If the main argument to svn info is a URL, the information reflects the latest version of an object in the repository, and any mention of a lock describes the current lock on the object. So in this particular example, Sally can see that Harry locked the file on February 16 to “make a quick tweak.” It being June, she suspects that he probably forgot all about the lock. She might phone Harry to complain and ask him to release the lock. If he's unavailable, she might try to forcibly break the lock herself or ask an administrator to do so.\n\nA repository lock isn't sacred—in Subversion's default configuration state, locks can be released not only by the person who created them, but by anyone. When somebody other than the original lock creator destroys a lock, we refer to this as breaking the lock. From the administrator's chair, it's simple to break locks. The svnlook and svnadmin programs have the ability to display and remove locks directly from the repository. (For more information about these tools, see the section called “An Administrator's Toolkit”.) $ svnadmin lslocks /var/svn/repos Path: /project2/images/banana.jpg UUID Token: opaquelocktoken:c32b4d88-e8fb-2310-abb3-153ff1236923 Owner: frank Created: 2006-06-15 13:29:18 -0500 (Thu, 15 Jun 2006) Expires: Comment (1 line): Still improving the yellow color. Path: /project/raisin.jpg UUID Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b Owner: harry Created: 2006-02-16 13:29:18 -0500 (Thu, 16 Feb 2006) Expires: Comment (1 line): Need to make a quick tweak to this image. $ svnadmin rmlocks /var/svn/repos /project/raisin.jpg Removed lock on '/project/raisin.jpg'. $ The more interesting option is to allow users to break each other's locks over the network. To do this, Sally simply needs to pass the to the svn unlock command: $ svn status -u M 23 bar.c M O 32 raisin.jpg * 72 foo.h Status against revision: 105 $ svn unlock raisin.jpg svn: 'raisin.jpg' is not locked in this working copy $ svn info raisin.jpg | grep URL URL: http://svn.example.com/repos/project/raisin.jpg $ svn unlock http://svn.example.com/repos/project/raisin.jpg svn: Unlock request failed: 403 Forbidden (http://svn.example.com) $ svn unlock --force http://svn.example.com/repos/project/raisin.jpg 'raisin.jpg' unlocked. $ Now, Sally's initial attempt to unlock failed because she ran svn unlock directly on her working copy of the file, and no lock token was present. To remove the lock directly from the repository, she needs to pass a URL to svn unlock. Her first attempt to unlock the URL fails, because she can't authenticate as the lock owner (nor does she have the lock token). But when she passes , the authentication and authorization requirements are ignored, and the remote lock is broken. Simply breaking a lock may not be enough. In the running example, Sally may not only want to break Harry's long-forgotten lock, but relock the file for her own use. She can accomplish this by using svn unlock with and then svn lock back-to-back, but there's a small chance that somebody else might lock the file between the two commands. The simpler thing to do is to steal the lock, which involves breaking and relocking the file all in one atomic step. To do this, Sally passes the option to svn lock: In any case, whether the lock is broken or stolen, Harry may be in for a surprise. Harry's working copy still contains the original lock token, but that lock no longer exists. The lock token is said to be defunct. The lock represented by the lock token has either been broken (no longer in the repository) or stolen (replaced with a different lock). Either way, Harry can see this by asking svn status to contact the repository: If the repository lock was broken, then ( ) displays a (Broken) symbol next to the file. If a new lock exists in place of the old one, then a (sTolen) symbol is shown. Finally, svn update notices any defunct lock tokens and removes them from the working copy. Different systems have different notions of how strict a lock should be. Some folks argue that locks must be strictly enforced at all costs, releasable only by the original creator or administrator. They argue that if anyone can break a lock, chaos runs rampant and the whole point of locking is defeated. The other side argues that locks are first and foremost a communication tool. If users are constantly breaking each other's locks, it represents a cultural failure within the team and the problem falls outside the scope of software enforcement. Subversion defaults to the “softer” approach, but still allows administrators to create stricter enforcement policies through the use of hook scripts. In particular, the and hooks allow administrators to decide when lock creation and lock releases are allowed to happen. Depending on whether a lock already exists, these two hooks can decide whether to allow a certain user to break or steal a lock. The and hooks are also available, and can be used to send email after locking actions. To learn more about repository hooks, see the section called “Implementing Repository Hooks”.\n\nWe've seen how svn lock and svn unlock can be used to create, release, break, and steal locks. This satisfies the goal of serializing commit access to a file. But what about the larger problem of preventing wasted time? For example, suppose Harry locks an image file and then begins editing it. Meanwhile, miles away, Sally wants to do the same thing. She doesn't think to run , so she has no idea that Harry has already locked the file. She spends hours editing the file, and when she tries to commit her change, she discovers that either the file is locked or that she's out of date. Regardless, her changes aren't mergeable with Harry's. One of these two people has to throw away his or her work, and a lot of time has been wasted. Subversion's solution to this problem is to provide a mechanism to remind users that a file ought to be locked before the editing begins. The mechanism is a special property: . If that property is attached to a file (regardless of its value, which is irrelevant), Subversion will try to use filesystem-level permissions to make the file read-only—unless, of course, the user has explicitly locked the file. When a lock token is present (as a result of using svn lock), the file becomes read/write. When the lock is released, the file becomes read-only again. The theory, then, is that if the image file has this property attached, Sally would immediately notice something is strange when she opens the file for editing: many applications alert users immediately when a read-only file is opened for editing, and nearly all would prevent her from saving changes to the file. This reminds her to lock the file before editing, whereby she discovers the preexisting lock: $ /usr/local/bin/gimp raisin.jpg gimp: error: file is read-only! $ ls -l raisin.jpg -r--r--r-- 1 sally sally 215589 Jun 8 19:23 raisin.jpg $ svn lock raisin.jpg svn: Lock request failed: 423 Locked (http://svn.example.com) $ svn info http://svn.example.com/repos/project/raisin.jpg | grep Lock Lock Token: opaquelocktoken:fc2b4dee-98f9-0310-abf3-653ff3226e6b Lock Owner: harry Lock Created: 2006-06-08 07:29:18 -0500 (Thu, 08 June 2006) Lock Comment (1 line): Making some tweaks. Locking for the next two hours. $ Users and administrators alike are encouraged to attach the property to any file that cannot be contextually merged. This is the primary technique for encouraging good locking habits and preventing wasted effort. Note that this property is a communication tool that works independently from the locking system. In other words, any file can be locked, whether or not this property is present. And conversely, the presence of this property doesn't make the repository require a lock when committing. Unfortunately, the system isn't flawless. It's possible that even when a file has the property, the read-only reminder won't always work. Sometimes applications misbehave and “hijack” the read-only file, silently allowing users to edit and save the file anyway. There's not much that Subversion can do in this situation—at the end of the day, there's simply no substitution for good interpersonal communication."
    },
    {
        "link": "https://stackoverflow.com/questions/51657636/conflicts-prevention-while-merging-branches-in-subversion",
        "document": "I have recently observed a very weird merge conflict in Subversion. I am using tortoise SVN as the client. Please find the below information of the Trunk and branch details:\n• \\trunk\\ . Two users are working on this.\n• \\QA\\ is the branch where the merges from the trunk will happen.\n• For simplicity sake, There is a visual studio solution in \\trunk\\ClassLibrary1.sln\n• There is currently a sample project in the solution. \\trunk\\ClassLibrary1\n• Both users are fully updated and dont have any working copy changes.\n• Below sequence of events will take place.\n• User 1 will first add a new project in the Solution and commit the entire directory. ( ClassLibrary11 )\n• User 2 will take the update and add a new project in the solution and commit the entire directory structure ( ClassLibrary12 )\n• Context: In the above additions, ClassLibrary11 is our feature X and ClassLibrary12 is our feature Y. Now feature Y is stable, completely independent of the feature X and can be moved to the QA branch.\n• Merging process : We go to the QA branch and merge the feature Y from the trunk to the QA branch. It merges successfully without any conflict.\n• After 3 weeks of dev, the feature X becomes stable and now we try to move feature X to the QA branch. But as we merge, it gives us merge conflicts in the ClassLibrary.sln file\n\nThe Intent : We want to automate the entire process as part of our Devops pipelines where features(which are completely independent) can be promoted to different branches from a dashboard which would merge revisions linked to features. In the above case feature X and feature Y are completely independent (functionally and code file wise as well). The only common point is that solution file ClassLibrary.sln file in which references to both the projects were added.\n\nTortoise SVN should have automatically figured it out that the revision was a just a reordering of 2 different commits. So I just want to know a way (redesign/preventive commit) so that such conflicts dont happen. And if they should happen then I need to know that while merging the Feature Y i.e. ClassLibrary12 that this would cause conflicts in future"
    },
    {
        "link": "https://stackoverflow.com/questions/15546751/svn-strategy-using-branches-and-merging-changes-from-trunk-into-branch",
        "document": "So long time user of SVN, but fairly inexperienced in branching / tagging, and when I have I suspect I'm not really using it correctly or to its full potential.\n\nI have my trunk which I work on adding new features etc. This code base is used in multiple websites, where we create a branch off the trunk on a per project basis.\n\nEach branch usually has modifications specific to that project, and anything we think will be re-usable is added to the trunk, and made so that feature can be toggled on and off on the various projects.\n\nCurrently when we make changes to the trunk, and want those modifications in a pre-dated branch, I have to go through and manually merge certain revisions into the branch and recommit them. Not ideal, and easy to miss stuff.\n\nSo, my question... is there any way to update my branch with ALL of the changes from the trunk, and deal with them as if it was a standard trunk update with conflicts?\n\nI have seen about reintegrating the branch to the trunk, but due to the way I am using branches in this instance, thats not really something I want to do."
    },
    {
        "link": "https://perforce.com/blog/vcs/svn-branching-and-merging",
        "document": ""
    },
    {
        "link": "http://restart.be/subversion",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/vgh0lt/why_is_subversion_not_more_mainstream_compared_to",
        "document": "TL;DR - I tried using subversion for a project, really appreciated the advantages it has over git in the context of game dev. Just wondering why it isn't more main stream & accessible, thought it could be an interesting discussion.\n\nObviously it's not like no one uses subversion, but it sure doesn't have the popularity or accessibility of git. There's no GitHub equivalent of Subversion hosting, for example. Obviously outside of game dev, git is a fantastic tool for projects that are primarily code based. Within game dev though, so many of the files being used are binary assets - which git is NOT great at handling (even with LFS).\n\nAnecdotally, I started a hobby project with a group of coworkers a couple of months ago and we were initially collaborating with git. Since we are using Unreal, we have been using their Blueprint system for scripting/coding. The downside of this is that the blueprints are stored as binary files. We quickly hit a wall with git - two people would have local changes on the same file because we had no awareness of who was working on what. Merge conflicts for days! Since the blueprint files are binary, merging both copies was not an option.\n\nEnter Subversion. Subversion has file locking - honestly the selling point for me. This means accidentally working on a file someone else has checked out immediately became a thing of the past once we switched over. Some additional bonuses:\n• Because you can self host it, your project size is essentially unrestricted (our project is currently at around 14GB - I think GitHub would not be happy with us if we were still using them).\n• Sub-benefit of this is being able to version working files (.psd, etc) in our depot, made collaborating/sharing these very easy since everything was in one place.\n• Unreal has an OK subversion integration (it could be better, but it's convenient).\n• People with little experience with source control got on board with subversion much quicker than git. This has also led to less support/trouble shooting requests (not everyone can be an expert at this kind of stuff).\n\nThere's various other benefits, but long story short, switching to subversion was a game changer. Honestly for our purposes, there have been no downsides offsetting the mentioned benefits of ditching git outside of the trouble of getting it set up & configured. I don't see myself using git in my future game dev projects after this experience. I've been left wondering the question in title: why isn't subversion more popular in game dev, especially for smaller teams?\n• I know Perforce and PlasticSCM exist, and are essentially more modern, more efficient, more featured centralized VCS options when compared to Subversion. There's a huge difference here though - Subversion is completely free and open source, like git. Without paying out the ass for licensing, these two options are not accessible. The free tiers are too limited to be useful teams bigger than 5, or with project sizes larger than 5GB. I wish these softwares were more accessible.\n• I will admit that I am a bit more savy in terms of sys-admin knowledge than your average game dev. For our project I spun up a $5 instance on linode & deployed subversion using a docker image from docker hub. I know doing this is not in the realm of possibilities for most small/hobby teams. I think the difficulties of running a subversion server highlight my initial question - if it was more popular, it would be easier to get up and running. As I said at the start, there is no \"GitHub of Subversion hosting.\"\n• Of course we could have coordinated better while using git to make sure to avoid merge conflicts, but I don't feel like that is too realistic. I've heard of people using spreadsheets to avoid binary file merge conflicts, but you can never depend on a manual process like that (not to mention the laborious upkeep)."
    },
    {
        "link": "https://stackoverflow.com/questions/28035602/resolving-a-merge-conflict-when-i-do-svn-update",
        "document": "I am trying to learn basics of version control by Eric Sink - http://ericsink.com/vcbe/vcbe_usletter_lo.pdf\n\nI am on page 22 now. I'll describe the scenario for you. Two users on the same computer, harry and sally are working on a file called lottery.c which is stored in a repo called lottery.\n\n1 - Harry commits the first/initial code. 2 - Sally changes it and commits. 3 - While 2 is happening, harry has made changes, but not committed. 4 - Harry commits and gets an error.\n\n5 - To fix this, harry will update his local copy using .\n\nThis is where I have a problem ! The author says the output is:\n\nBut, my output is :\n\nI am new and I don't know how to respond to this message. Is my book wrong ? Please help me. Thanks."
    },
    {
        "link": "https://svnbook.red-bean.com/en/1.6/svn.tour.treeconflicts.html",
        "document": "This documentation was written to describe the 1.6.x series of Subversion. If you are running a different version of Subversion, you are strongly encouraged to visit http://www.svnbook.com/ and instead consult the version of this documentation appropriate for your version of Subversion.\n\nSo far, we have only talked about conflicts at the level of file content. When you and your collaborators make overlapping changes within the same file, Subversion forces you to merge those changes before you can commit.\n\nBut what happens if your collaborators move or delete a file that you are still working on? Maybe there was a miscommunication, and one person thinks the file should be deleted, while another person still wants to commit changes to the file. Or maybe your collaborators did some refactoring, renaming files and moving around directories in the process. If you were still working on these files, those modifications may need to be applied to the files at their new location. Such conflicts manifest themselves at the directory tree structure level rather than at the file content level, and are known as tree conflicts.\n\nPrior to Subversion 1.6, tree conflicts could yield rather unexpected results. For example, if a file was locally modified, but had been renamed in the repository, running svn update would make Subversion carry out the following steps:\n• Check the file to be renamed for local modifications.\n• Delete the file at its old location, and if it had local modifications, keep an on-disk copy of the file at the old location. This on-disk copy now appears as an unversioned file in the working copy.\n• Add the file, as it exists in the repository, at its new location. When this situation arises, there is the possibility that the user makes a commit without realizing that local modifications have been left in a now-unversioned file in the working copy, and have not reached the repository. This gets more and more likely (and tedious) if the number of files affected by this problem is large. Since Subversion 1.6, this and other similar situations are flagged as conflicts in the working copy.\n\nAs with textual conflicts, tree conflicts prevent a commit from being made from the conflicted state, giving the user the opportunity to examine the state of the working copy for potential problems arising from the tree conflict, and resolving any such problems before committing.\n\nSuppose a software project you were working on currently looked like this: Your collaborator Harry has renamed the file to . You are still working on in your working copy, but you don't know yet that the file has been renamed in the repository. The log message to Harry's commit looked like this: $ svn log -r5 svn://svn.example.com/trunk ------------------------------------------------------------------------ r5 | harry | 2009-02-06 14:42:59 +0000 (Fri, 06 Feb 2009) | 2 lines Changed paths: M /trunk/Makefile D /trunk/code/bar.c A /trunk/code/baz.c (from /trunk/code/bar.c:4) Rename bar.c to baz.c, and adjust Makefile accordingly. The local changes you have made look like this: $ svn diff Index: code/foo.c =================================================================== --- code/foo.c (revision 4) +++ code/foo.c (working copy) @@ -3,5 +3,5 @@ int main(int argc, char *argv[]) { printf(\"I don't like being moved around!\n\n%s\", bar()); - return 0; + return 1; } Index: code/bar.c =================================================================== --- code/bar.c (revision 4) +++ code/bar.c (working copy) @@ -1,4 +1,4 @@ const char *bar(void) { - return \"Me neither!\n\n\"; + return \"Well, I do like being moved around!\n\n\"; } Your changes are all based on revision 4. They cannot be committed because Harry has already checked in revision 5: At this point, you need to run svn update. Besides bringing our working copy up to date so that you can see Harry's changes, this also flags a tree conflict so you have the opportunity to evaluate and properly resolve it. $ svn update C code/bar.c A code/baz.c U Makefile Updated to revision 5. Summary of conflicts: Tree conflicts: 1 In its output, svn update signifies tree conflicts using a capital C in the fourth output column. svn status reveals additional details of the conflict: Note how bar.c is automatically scheduled for re-addition in your working copy, which simplifies things in case you want to keep the file. Because a move in Subversion is implemented as a copy operation followed by a delete operation, and these two operations cannot be easily related to one another during an update, all Subversion can warn you about is an incoming delete operation on a locally modified file. This delete operation may be part of a move, or it could be a genuine delete operation. Talking to your collaborators, or, as a last resort, svn log, is a good way to find out what has actually happened. Both and are reported as locally modified in the output of svn status. You made the changes to yourself, so this should not be surprising. But why is reported as locally modified? The answer is that despite the limitations of the move implementation, Subversion was smart enough to transfer your local edits in into : $ svn diff code/baz.c Index: code/baz.c =================================================================== --- code/baz.c (revision 5) +++ code/baz.c (working copy) @@ -1,4 +1,4 @@ const char *bar(void) { - return \"Me neither!\n\n\"; + return \"Well, I do like being moved around!\n\n\"; } Local edits to the file , which is renamed during an update to , will only be applied to if your working copy of is based on the revision in which it was last modified before being moved in the repository. Otherwise, Subversion will resort to retreiving from the repository, and will not try to transfer your local modifications to it. You will have to do so manually. svn info shows the URLs of the items involved in the conflict. The left URL shows the source of the local side of the conflict, while the right URL shows the source of the incoming side of the conflict. These URLs indicate where you should start searching the repository's history for the change which conflicts with your local change. $ svn info code/bar.c | tail -n 4 Tree conflict: local edit, incoming delete upon update Source left: (file) ^/trunk/code/bar.c@4 Source right: (none) ^/trunk/code/bar.c@5 is now said to be the victim of a tree conflict. It cannot be committed until the conflict is resolved: So how can this conflict be resolved? You can either agree or disagree with the move Harry made. In case you agree, you can delete and mark the tree conflict as resolved: $ svn delete --force code/bar.c D code/bar.c $ svn resolve --accept=working code/bar.c Resolved conflicted state of 'code/bar.c' $ svn status M code/foo.c M code/baz.c $ svn diff Index: code/foo.c =================================================================== --- code/foo.c (revision 5) +++ code/foo.c (working copy) @@ -3,5 +3,5 @@ int main(int argc, char *argv[]) { printf(\"I don't like being moved around!\n\n%s\", bar()); - return 0; + return 1; } Index: code/baz.c =================================================================== --- code/baz.c (revision 5) +++ code/baz.c (working copy) @@ -1,4 +1,4 @@ const char *bar(void) { - return \"Me neither!\n\n\"; + return \"Well, I do like being moved around!\n\n\"; } If you do not agree with the move, you can delete instead, after making sure any changes made to it after it was renamed are either preserved or not worth keeping. Do not forget to revert the changes Harry made to the . Since is already scheduled for re-addition, there is nothing else left to do, and the conflict can be marked resolved: $ svn delete --force code/baz.c D code/baz.c $ svn resolve --accept=working code/bar.c Resolved conflicted state of 'code/bar.c' $ svn status M code/foo.c A + code/bar.c D code/baz.c M Makefile $ svn diff Index: code/foo.c =================================================================== --- code/foo.c (revision 5) +++ code/foo.c (working copy) @@ -3,5 +3,5 @@ int main(int argc, char *argv[]) { printf(\"I don't like being moved around!\n\n%s\", bar()); - return 0; + return 1; } Index: code/bar.c =================================================================== --- code/bar.c (revision 5) +++ code/bar.c (working copy) @@ -1,4 +1,4 @@ const char *bar(void) { - return \"Me neither!\n\n\"; + return \"Well, I do like being moved around!\n\n\"; } Index: code/baz.c =================================================================== --- code/baz.c (revision 5) +++ code/baz.c (working copy) @@ -1,4 +0,0 @@ -const char *bar(void) -{ - return \"Me neither!\n\n\"; -} Index: Makefile =================================================================== --- Makefile (revision 5) +++ Makefile (working copy) @@ -1,2 +1,2 @@ foo: - $(CC) -o $@ code/foo.c code/baz.c + $(CC) -o $@ code/foo.c code/bar.c In either case, you have now resolved your first tree conflict! You can commit your changes and tell Harry during tea break about all the extra work he caused for you."
    },
    {
        "link": "https://rose-hulman.edu/class/csse/csse221/current/Resources/ResolvingSubversionConflicts.htm",
        "document": "Subversion is quite good about merging changes when two team members simultaneously edit a file. But occassionally two team members will edit the same section of the same file. Subversion isn’t “smart” enough to decide which person wrote the best code (or text, or whatever). Rather than throw out one of the changes, Subversion will report a conflict and store enough information in your working directory to allow you to resolve the problem in one of several ways.\n\nThis document describes what Subversion does when it detects a conflict and gives four different strategies for resolving the conflict.\n\nSuppose Sally and Joe are teammates and they are both working independently on their tasks from their last team meeting. Sally and Joe both update their working copy of the team project. Sally adds a new method to a class. At the same time Joe updates the javadoc comment for a different method in the same class.\n\nNow suppose Joe finishes his task first and commits his changes to the repository. Now the base version that Sally is working with doesn’t include Joe’s changes. When Sally finishes her task and attempts to commit her changes, she’ll receive an error message that her version is probably out-of-date. Sally then will do a Subversion update on the file to get Joe’s changes.\n\nIn our example, Sally’s and Joe’s changes are independent, so Subversion will merge Joe’s changes with Sally’s. Now the file in Sally’s working directory contains both of their changes. Sally can commit her version to the repository. If Joe does a Subversion update, now he’ll also have his changes and Sally’s.\n\nBut suppose Sally and Joe both edited the same method. When Sally first tried to commit her changes she would receive the probably out-of-date error message. When she then ran a Subversion update, Subversion would be unable to merge the changes, since it wouldn't know whose change was the “correct” one. In this case, Subversion would report that one or more files are in a conflicted state. In this case, Subversion will place four files in the directory where the conflicted file was. Suppose the conflicted file was called . The four files would be:\n• – this file would include Joe’s changes and Sally’s changes. For each place where they both made changes Subversion will insert text like , followed by Sally’s changes, followed by the text , followed by the changes that Joe committed to the repository, followed by .\n• – this file would include just Sally’s changes\n• N, where N is some number – this file would be the version that Sally started with, without her or Joe’s changes\n• M, where M is some number greater than N – this file would include just Joe’s changes\n\nSally would change to incorporate the changes in whatever way seems best. This might involve consultation with Joe to see what he thinks or to clarify what changes he made and why. Sally could edit directly to combine the marked changes and delete the , , and markers. Sally and Joe might agree that they were both trying to make the same changes and that Sally’s version is better. In that cases, Sally could copy over the top of , throwing out Joe’s changes. On the other hand, if they agree to just use Joe’s version, Sally could copy M over the top of . Finally, if they decided to throw out all the changes, Sally could copy N over the top of .\n\nAfter resolving the conflicted files using the above techniques, Sally must right-click on and tell Subversion that the conflict is resolved. Subversion will delete the extra files that it created when the conflict was detected. Finally, Sally must commit the file to the repository so that Joe and her other teammates can get the current version.\n• When you try to commit a file and Subversion reports that the file is probably out-of-date, the first step is to do a Subversion update on that file.\n• After updating, there are two possibilities. If Subversion does not report an error, then commit your merged files. Otherwise continue to the next step.\n• If Subversion reported a conflict, then there should be four different files in the directory where the conflicted file was. See the previous section for a description of these four files.\n• Change the conflicted file to either combine the changes, to select one set of changes or the other, or to throw out all changes. This process is described in the previous section. Be sure to consult with your teammates if necessary!\n• Right-click on the conflicted file and choose Resolved from the TortoiseSVN menu (or the Team menu in Eclipse). Note: This does not actually fix the conflict. You must do that manually. Marking the file as Resolved just tells Subversion to clean up after itself by deleting the extra files.\n• Finally, commit to file to the repository."
    },
    {
        "link": "https://tortoisesvn.net/docs/release/TortoiseSVN_en/tsvn-dug-conflicts.html",
        "document": "Once in a while, you will get a conflict when you update/merge your files from the repository or when you switch your working copy to a different URL. There are two kinds of conflicts:\n\nA file conflict occurs when two or more developers have changed the same few lines of a file. As Subversion knows nothing of your project, it leaves resolving the conflicts to the developers. The conflicting area in a text file is marked like this: <<<<<<< filename your changes ======= code merged from repository >>>>>>> revision Also, for every conflicted file Subversion places three additional files in your directory: This is your file as it existed in your working copy before you updated your working copy - that is, without conflict markers. This file has your latest changes in it and nothing else. This is the file that was the BASE revision before you updated your working copy. That is, it the file that you checked out before you made your latest edits. This is the file that your Subversion client just received from the server when you updated your working copy. This file corresponds to the HEAD revision of the repository. You can either launch an external merge tool / conflict editor with TortoiseSVN → Edit Conflicts or you can use any text editor to resolve the conflict manually. You should decide what the code should look like, do the necessary changes and save the file. Using a merge tool such as TortoiseMerge or one of the other popular tools is generally the easier option as they generally present the files involved in a 3-pane view and you don't have to worry about the conflict markers. If you do use a text editor then you should search for lines starting with the string . Afterwards execute the command TortoiseSVN → Resolved and commit your modifications to the repository. Please note that the Resolve command does not really resolve the conflict. It just removes the and files, to allow you to commit your changes. If you have conflicts with binary files, Subversion does not attempt to merge the files itself. The local file remains unchanged (exactly as you last changed it) and you have files. If you want to discard your changes and keep the repository version, just use the Revert command. If you want to keep your version and overwrite the repository version, use the Resolved command, then commit your version. You can use the Resolved command for multiple files if you right click on the parent folder and select TortoiseSVN → Resolved... This will bring up a dialog listing all conflicted files in that folder, and you can select which ones to mark as resolved.\n\nA property conflict occurs when two or more developers have changed the same property. As with file content, resolving the conflict can only be done by the developers. If one of the changes must override the other then choose the option to Resolve using local property or Resolve using remote property. If the changes must be merged then select Manually edit property, sort out what the property value should be and mark as resolved.\n\nA tree conflict occurs when a developer moved/renamed/deleted a file or folder, which another developer either also has moved/renamed/deleted or just modified. There are many different situations that can result in a tree conflict, and all of them require different steps to resolve the conflict. When a file is deleted locally in Subversion, the file is also deleted from the local file system, so even if it is part of a tree conflict it cannot show a conflicted overlay and you cannot right click on it to resolve the conflict. Use the Check for Modifications dialog instead to access the Edit conflicts option. TortoiseSVN can help find the right place to merge changes, but there may be additional work required to sort out the conflicts. Remember that after an update the working BASE will always contain the revision of each item as it was in the repository at the time of update. If you revert a change after updating it goes back to the repository state, not to the way it was when you started making your own local changes.\n• None Developer A modifies and commits it to the repository.\n• None Developer B has simultaneously moved to in his working copy, or simply deleted or its parent folder. An update of developer B's working copy results in a tree conflict:\n• None has been deleted from working copy, but is marked with a tree conflict.\n• None If the conflict results from a rename rather than a delete then is marked as added, but does not contain developer A's modifications. Developer B now has to choose whether to keep Developer A's changes. In the case of a file rename, he can merge the changes to into the renamed file . For simple file or directory deletions he can choose to keep the item with Developer A's changes and discard the deletion. Or, by marking the conflict as resolved without doing anything he effectively discards Developer A's changes. The conflict edit dialog offers to merge changes if it can find the original file of the renamed . If there are multiple files that are possible move sources, then a button for each of these files is shown which allow you to chose the correct file.\n• None Developer A moves to and commits it to the repository. Or in the case of a folder move ...\n• None Developer A moves parent folder to and commits it to the repository. An update of developer B's working copy results in a tree conflict. For a simple file conflict:\n• None is added to the working copy as a normal file.\n• None is marked as added (with history) and has a tree conflict.\n• None is added to the working copy as a normal folder.\n• None is marked as added (with history) and has a tree conflict. Developer B now has to decide whether to go with developer A's reorganisation and merge her changes into the corresponding file in the new structure, or simply revert A's changes and keep the local file. To merge her local changes with the reshuffle, Developer B must first find out to what filename the conflicted file was renamed/moved in the repository. This can be done by using the log dialog. Then use the button which shows the correct source file to resolve the conflict. If Developer B decides that A's changes were wrong then she must choose the Mark as resolved button in the conflict editor dialog. This marks the conflicted file/folder as resolved, but Developer A's changes need to be removed by hand. Again the log dialog helps to track down what was moved.\n• None Developer A moves to and commits it to the repository. An update of developer B's working copy results in a tree conflict:\n• None is marked as added with history.\n• None is added to the working copy with status 'normal'.\n• None is marked as deleted and has a tree conflict. To resolve this conflict, Developer B has to find out to what filename the conflicted file was renamed/moved in the repository. This can be done by using the log dialog. Then developer B has to decide which new filename of to keep - the one done by developer A or the rename done by himself. After developer B has manually resolved the conflict, the tree conflict has to be marked as resolved with the button in the conflict editor dialog.\n• None Developer A working on trunk modifies and commits it to the repository\n• None Developer B working on a branch moves to and commits it to the repository A merge of developer A's trunk changes to developer B's branch working copy results in a tree conflict:\n• None is already in the working copy with status 'normal'.\n• None is marked as missing with a tree conflict. To resolve this conflict, Developer B has to mark the file as resolved in the conflict editor dialog, which will remove it from the conflict list. She then has to decide whether to copy the missing file from the repository to the working copy, whether to merge Developer A's changes to into the renamed or whether to ignore the changes by marking the conflict as resolved and doing nothing else. Note that if you copy the missing file from the repository and then mark as resolved, your copy will be removed again. You have to resolve the conflict first.\n• None Developer A working on trunk moves to and commits it to the repository.\n• None Developer B working on a branch modifies and commits it to the repository.\n• None Developer A working on trunk moves parent folder to and commits it to the repository.\n• None Developer B working on a branch modifies in her working copy. A merge of developer A's trunk changes to developer B's branch working copy results in a tree conflict:\n• None is marked as modified with a tree conflict. Developer B now has to decide whether to go with developer A's reorganisation and merge her changes into the corresponding file in the new structure, or simply revert A's changes and keep the local file. To merge her local changes with the reshuffle, Developer B must first find out to what filename the conflicted file was renamed/moved in the repository. This can be done by using the log dialog for the merge source. The conflict editor only shows the log for the working copy as it does not know which path was used in the merge, so you will have to find that yourself. The changes must then be merged by hand as there is currently no way to automate or even simplify this process. Once the changes have been ported across, the conflicted path is redundant and can be deleted. If Developer B decides that A's changes were wrong then she must choose the Mark as resolved button in the conflict editor dialog. This marks the conflicted file/folder as resolved, but Developer A's changes need to be removed by hand. Again the log dialog for the merge source helps to track down what was moved.\n• None Developer A working on trunk moves to and commits it to the repository.\n• None Developer B working on a branch moves to and commits it to the repository. A merge of developer A's trunk changes to developer B's branch working copy results in a tree conflict:\n• None is marked as added with history.\n• None is marked as missing and has a tree conflict. To resolve this conflict, Developer B has to find out to what filename the conflicted file was renamed/moved in the repository. This can be done by using the log dialog for the merge source. Then developer B has to decide which new filename of to keep - the one done by developer A or the rename done by himself. After developer B has manually resolved the conflict, the tree conflict has to be marked as resolved with the button in the conflict editor dialog. There are other cases which are labelled as tree conflicts simply because the conflict involves a folder rather than a file. For example if you add a folder with the same name to both trunk and branch and then try to merge you will get a tree conflict. If you want to keep the folder from the merge target, just mark the conflict as resolved. If you want to use the one in the merge source then you need to SVN delete the one in the target first and run the merge again. If you need anything more complicated then you have to resolve manually."
    },
    {
        "link": "https://stackoverflow.com/questions/5479962/handling-svn-conflict",
        "document": "If you are working in the command line instead of using a UI, svn will ask you when you do \"svn update\" something like:\n\nWhat you want is mine-full (mf). Of course this will overwrite any changes that the other person made, so you may instead want to (e)dit.\n\nIf you choose to (p)ostpone this, you will need to change the file later and mark it as resolved (svn resolved ), followed by a svn commit."
    }
]