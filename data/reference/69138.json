[
    {
        "link": "https://medium.com/@eveciana21/c-survival-guide-virtual-methods-and-overriding-0dd63a5df0aa",
        "document": "Objective: Explaining how to create Virtual Methods to override methods in inherited classes\n\nIn my previous articles, I discussed inheriting classes that are not MonoBehaviour. Now, I want to review how we can inherit MonoBehaviour classes.\n\nIn this article, I want to use the example of an MMO game where you might encounter a pet system where you can capture animals to be your pets and override methods from the inherited classes.\n\nLet’s start by creating a C# script called Pet. We are going to keep our MonoBehaviour while defining the traits of a pet.\n\nI’ve made sure to use the protected members so that only classes that inherit the Pet class can access these. For more info, read my previous article.\n\nIt is important to note that if our virtual method is using a protected member, our overriding methods need to be protected as well. We cannot use public or private methods, they need to be protected.\n\nNext, I will add a cube into my scene which will be our first animal. Let’s name this cube “Duck” and create a new C# script called Duck. Let’s inherit the Pet class from this Duck script. Drag the Duck script onto the Duck object.\n\nNow, as of right now, we have the method that is calling the pet to Speak. Although, we don’t want the duck to simply speak, we want it to “Quack!” So, to do this we need to create a virtual method so that our Duck method can override this “Speak” method.\n\nNow, we can go into our Duck script and override this script to do what we want for the specific pet.\n\nIt will automatically give us the base method for Speak, but since we don’t want it to Speak, and we want it to Quack, I will just remove the base.Speak and add it’s own function.\n\nNow, to complete the example. I am going to create a new C# script for a Dog as well as a gameobject for Dog. I am going to do the same thing and inherit the Pet class while overriding the Speak function.\n\nNow that I have my two pets with their unique sounds, I will go back into my Pet script and add the Speak to Start.\n\nSince the method is virtual, it will check all of the children who inherit this class and see if any of them are overriding this method; if they are, it is going to call the overriding method.\n\nYou can see that by putting the Speak method within Start on my Pet script, it still calls only the two inherited overridden methods.\n\nThat is all for this article. I hope this helps :)"
    },
    {
        "link": "https://stackoverflow.com/questions/8503448/c-sharp-inheritance-best-practice",
        "document": "I have a normal class called with a virtual method . This method calls and virtual methods to get contents for the page. I would then create a class that inherits from and override the methods that needs to display content differently than the way the base class does it.\n\nMy issue is that, although this works great, when running a code analysis I'm warned not to call the virtual functions directly.\n\nShould I create another class layer on top of the base class that override the virtual functions and only inherit from that?\n\nWhat are the disadvantages of using the virtual methods directly?"
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/367245/should-a-base-class-implement-a-virtual-method-for-the-most-common-type-or-deriv",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://benbowen.blog/post/simulating_multiple_inheritance_in_csharp",
        "document": "Foreword: Why MI At All? I'm assuming that most of you reading this will know what \"standard\" inheritance means in C#. It's the classic parent -> child class-extension mechanism that looks something like this:\n\n \n\n \n\n Anyway, this kind of \"classical OO\" inheritance is (rightly) frowned upon these days. Heavy use of inheritance has been shunned by many in the C# world in favour of things like \n\n \n\n There are multiple good reasons as to why this form of inheritance-based API-design is a bad idea, but one of the reasons is that however you attempt to model your target domain, certain types just tend to cross over the 'branches' of your inheritance hierarchy. Taking our musical instrument example, at some point someone might want you to add a class that represents \n\n \n\n What's worse is that in the past, people tried to solve these problems by throwing more bad inheritance at it, and multiple inheritance was no exception. \"For the hybrid-instrument, we can make our type inherit from StringInstrument and WindInstrument!\" they would say. This, naturally, led to even more problems such as \n\n \n\n Ultimately, the problem was with trying to model objects in the world as a series of progressive alterations and enhancements. It's easy to think of reality as being \"Instrument -> Stringed -> Piano\" but in actuality may be the only valid 'base class' of all instruments, and everything else is simply a property of tangible types. For example, is a property of a piano. It is also , and is a instrument.\n\n \n\n What's weird though, is that instead of throwing out the broken tool (single inheritance) we kept that and threw out the one that allows us to apply multiple properties to objects. It seems that people looked at the entire mess caused by trying to force everything through inheritance and noticed that MI tended to make things even worse. But that was a result of doubling down on a bad decision in the first place: Namely, encouraging all objects to stem from a single root and fit somewhere on a big 'tree' of inheritance.\n\n \n\n Thankfully, we didn't completely throw out the multiple-inheritance paradigm; and it came back in the form of interfaces, which allow us to label our types as having multiple properties, leaving the actual implementation down to the type itself.\n\n \n\n For example, a more modern/idiomatic approach to our musical instruments application might look as follows:\n\n \n\n \n\n Notice how we're no longer bound by the strict rules of inheritance. Our instruments are simply inheriting from (which is fair enough) and then they declare all their properties with ease. For the (that hybrid instrument in the video I linked above) we can change the strings and the reed. For the piano we can ask what the maximum number of notes playable at once is (which would be 10, ignoring smashing the keys with your head as an optional technique) as well as change the strings should we need to.\n\n \n\n And this kind of design works just fine for a lot of applications. But what about when we want to declare multiple properties of a type and provide a default implementation for those properties? If you think there's no need for this ever, please consider every time you've manually implemented \n\n \n\n C# doesn't really have a formal answer to this. You can write a class and then delegate most implementations of interfaces on your types to a , but doesn't that seem a bit messy? For every type that implements the interface which has a default implementation, you have to implement the methods manually, simply passing the real implementation off to your private composition object. If you're not sure what I mean, check the second 'approach' below, it shows off this inferior style.\n\n \n\n Alternatively, there is the option of using \n\n \n\n Of course, when we're talking about supplying 'default' implementations for interfaces, we should still be very careful. Although we're not talking about the \"classical-OOP\" forms of MI anymore, we're still talking about the very strong code-coupling that comes with automatically-inherited implementations. Trying to do too much with this paradigm will eventually bring us back to the original problems- and the reason why so many people still have disdain for MI as a concept.\n\n \n\n But I'm not talking about trying to go back to the old days. I'm talking about single, atomic, 'micro-properties': Very small building blocks of implementation that can be combined with other building blocks to compose actual types. Ones that add absolutely nothing more than they need to, and represent a single facet of an object. This concept isn't even new to the programming world; in fact, they have a name: \n\n \n\n Finally, if you're still unconvinced, it might interest you to know that \n\n \n\n Unfortunately C# offers no inbuilt mechanism for mixins or any other form of MI other than pure-virtual base-class inheritance (i.e. interfaces). That means that whatever approach or methodology we come up below isn't going to ever be as neat as a language-supported one. Please try to bear that in mind as we go down the rabbit-hole. ;)\n\n \n\n I'm going to present this section as a series of examples, each with their own advantages and disadvantages: No one approach is perfect.\n\n \n\n Finally, throughout the rest of the post I will be using a game-engine entity system as the example material; however, you don't need to be a gamer or engine programmer to understand what's going on.\n\n \n\n Let's build an example to elucidate the problem we're actually trying to solve. As I mentioned, I'm going to build the beginning of an entity system. If you're not familiar with such a system; it's basically a programming pattern/model that's used often in game development. In a typical entity system, an object represents a single 'thing' in the game world (such as a player, or a powerup, or a projectile, or a tank... Etc.). Each is then composed of various properties that are relevant to its type, such as \"represented visually with a 3D model\" and \"can be collided with in the physics system\", etc.\n\n \n\n To start, let's write out our first attempt at modelling an entity system with a couple of real-world entities (at the moment I'm ignoring thread-safety concerns; let's just keep things simple and assume a single thread).\n\n \n\n First of all, the type, the base class of all entities:\n\n \n\n \n\n And now let's make some component types:\n\n \n\n \n\n Alright, so we have a that represents any entity with a 3D model and an that represents any entity that makes a sound. Both have a custom method that can be used to determine whether or not the player can see or hear the given entity. If you're absolutely new to game programming don't worry too much about the example implementations I've given, they're just there for the demonstration, what's important is the object graph we're trying to model.\n\n \n\n So, now let's write some entities:\n\n \n\n \n\n Alright then! We've got two very important entities representable in our game: An armour powerup and a rocket projectile. Job done!\n\n \n\n But now, management says that they want to be able to hear the rocket hissing as it flies past the player's ear on a near-miss. And now we're kind of stuck, because C# doesn't allow this kind of multiple inheritance (where we could write something akin to ).\n\n \n\n But we do want this behaviour, really, so that we can do things like use a as a when writing code concerned with its and what it looks like, and use it as an when we care about whether or not the player can hear it. And this is just the tip of the iceberg, in reality entity systems have many intertwined component types and needs!\n\n \n\n Of course, as I mentioned above, interfaces would allow us that strongly-typed multi-use ability. We could mark as and ... But then we have to re-implement methods like CameraCanHearThis()/CameraCanSeeThis() and even properties like Scale on every type that implemented those interfaces!\n\n \n\n So... What now? Let's investigate some options. ;)\n\n \n\n The first idea we're going to explore here is one where we add, remove, and use components of entities at rumtime, typically with methods like \"AddComponent\", \"RemoveComponent\", etc.\n\n \n\n Here's our example using this approach:\n\n \n\n // ENTITY BASE CLASS public class Entity { private readonly List<Component> addedComponents = new List<Component>(); public void AddComponent<TComponent>(TComponent component) where TComponent : Component { if (HasComponent<TComponent>()) throw new ComponentAlreadyAddedException(); addedComponents.Add(component); } public bool HasComponent<TComponent>() where TComponent : Component { return addedComponents.OfType<TComponent>().Any(); } public void RemoveComponent<TComponent>() where TComponent : Component { if (!HasComponent<TComponent>()) throw new ComponentNotAddedException(); TComponent componentToRemove = GetComponent<TComponent>(); addedComponents.Remove(componentToRemove); } public TComponent GetComponent<Component>() where TComponent : Component { if (!HasComponent<TComponent>()) throw new ComponentNotAddedException(); return addedComponents.OfType<TComponent>().Single(); } } // COMPONENTS public abstract class Component { } public abstract class TangibleComponent : Component { public Vector3 Position; public Vector3 Velocity; } public class ModelledComponent : TangibleComponent { public ModelReference Model; public float Scaling; public bool CameraCanSeeThis(Camera camera) { return !PhysicsSystem.RayTest(camera.Position, Position).IsObscured; } } public class AudibleComponent : TangibleComponent { public SoundReference Sound; public float SoundRadius; public bool CameraCanHearThis(Camera camera) { return SoundRadius > Vector3.Distance(camera.Position, Position); } } // ENTITIES public class ArmourPowerupEntity : Entity { private const float DEFAULT_ARMOUR_SCALING = 1f; public ArmourPowerupEntity(Vector3 powerupPosition) : this(powerupPosition, DEFAULT_ARMOUR_SCALING) { } public ArmourPowerupEntity(Vector3 powerupPosition, float customScaling) { ModelledComponent modelledComponent = new ModelledComponent(); modelledComponent.Model = ModelDatabase.ArmourModel; modelledComponent.Position = powerupPosition; modelledComponent.Scaling = customScaling; AddComponent(modelledComponent); } } public class RocketProjectileEntity : Entity { public RocketProjectileEntity(Vector3 firingPoint, Vector3 firingVelocity, bool isBigRocket) { ModelledComponent modelledComponent = new ModelledComponent(); AudibleComponent audibleComponent = new AudibleComponent(); modelledComponent.Model = ModelDatabase.RocketModel; modelledComponent.Position = firingPoint; modelledComponent.Velocity = firingVelocity; modelledComponent.Scaling = isBigRocket ? 2f : 1f; audibleComponent.Sound = SoundDatabase.RocketSound; audibleComponent.Position = firingPoint; audibleComponent.Velocity = firingVelocity; audibleComponent.SoundRadius = 1000f; AddComponent(modelledComponent); AddComponent(audibleComponent); } } \n\n This is basically to see whether the entity makes a sound at all, then we use to retrieve the , on which we can subsequently call . Sorted!\n\n \n\n ...Well, this approach is well known and certainly the most popular. In fact, the widely used C#-based \n\n \n\n However, the way I see it, this design has three flaws (and one advantage!):\n\n \n\n Advantage: We can add and remove components dynamically, on the fly, at runtime. This can be useful occasionally, especially when you don't want to map classes to entities 1-to-1. Disadvantage: We're pushing what could, in theory, be static/compile-time information to runtime. It's possible to make a mistake somewhere and forget to check whether an entity is \"audible\" before treating it as such (i.e. by forgetting to call before ). We're using a type-safe, static language; we shouldn't have to do this. It also means that if we refactor the code to remove from something later on, the code still compiles (which is bad). If we were using inheritance, and removed AudibleEntity as a child class, we'd get lovely compile-time errors showing us everywhere in the code we tried to use our entity as an audible one. Disadvantage: Even if we never forget these checks, this approach can require us to write a lot of boiler-plate when working with components. For example, instead of just being able to write \" \" we need to check for and obtain the first, and then call on that instead. If you omit the check, someone might remove the component later (either by design or as a side effect of another running section of code), and you end up with exceptions. Disadvantage: I know I said to ignore multithreaded scenarios for now, but I just want to point out that adding, checking for, getting, and using components can not be combined as an atomic operation so easily. That's not to say it's not possible, but a multithreaded entity system built like this may well become complex (e.g. what if one thread removes a component as another is using it?). \n\n Now, personally, I'm of the opinion that the disadvantages outweigh the advantages here. The multithreading thing isn't so bad, but the pushing of what could/should be compile-time information to runtime is what sets off my unease. Also, the fact that common properties have to be set/modified simultaneously is quite nasty, and although I can think of a couple of ways around that, of varying degrees of convolution, it starts to add even more hackery and hidden magic.\n\n \n\n That's not to say that this approach is useless, and it's certainly more idiomatic than where we'll be going from here, but let's explore some more options.\n\n \n\n This second approach is the other way to implement the composition over inheritance paradigm. In contrast to approach number one, we're going to get back compile-time information but at the cost of developer-annoyance-level. ;) Basically, we will add interfaces to our entities and then delegate their implementations to private implementation objects. Let's jump straight to the example:\n\n \n\n // ENTITY BASE CLASS public class Entity { } // COMPONENTS (INTERFACES) public interface ITangibleEntity { Vector3 Position { get; set; } Vector3 Velocity { get; set; } } public interface IModelledEntity : ITangibleEntity { ModelReference Model { get; set; } float Scaling { get; set; } bool CameraCanSeeThis(Camera camera); } public interface IAudibleEntity : ITangibleEntity { SoundReference Sound { get; set; } float SoundRadius { get; set; } bool CameraCanHearThis(Camera camera); } // COMPONENTS (DEFAULT IMPLEMENTATIONS) public class DefaultTangibleEntityImpl : ITangibleEntity { public Vector3 Position { get; set; } public Vector3 Velocity { get; set; } } public class DefaultModelledEntityImpl : IModelledEntity { private readonly DefaultTangibleEntityImpl tangibleImpl; public Vector3 Position { get { return tangibleImpl.Position; } set { tangibleImpl.Position = value; } } public Vector3 Velocity { get { return tangibleImpl.Position; } set { tangibleImpl.Velocity = value; } } public DefaultModelledEntityImpl(DefaultTangibleEntityImpl tangibleImpl) { this.tangibleImpl = tangibleImpl; } public ModelReference Model { get; set; } public float Scaling { get; set; } public bool CameraCanSeeThis(Camera camera) { return !PhysicsSystem.RayTest(camera.Position, Position).IsObscured; } } public class DefaultAudibleEntityImpl : IAudibleEntity { private readonly DefaultTangibleEntityImpl tangibleImpl; public Vector3 Position { get { return tangibleImpl.Position; } set { tangibleImpl.Position = value; } } public Vector3 Velocity { get { return tangibleImpl.Position; } set { tangibleImpl.Velocity = value; } } public DefaultAudibleEntityImpl(DefaultTangibleEntityImpl tangibleImpl) { this.tangibleImpl = tangibleImpl; } public SoundReference Sound { get; set; } public float SoundRadius { get; set; } public bool CameraCanHearThis(Camera camera) { return SoundRadius > Vector3.Distance(camera.Position, Position); } } // ENTITIES public class ArmourPowerupEntity : Entity, IModelledEntity { private const float DEFAULT_ARMOUR_SCALING = 1f; private readonly DefaultTangibleEntityImpl tangibleImpl; private readonly DefaultModelledEntityImpl modelledImpl; public ModelReference Model { get { return modelledImpl.Model; } set { modelledImpl.Model = value; } } public float Scaling { get { return modelledImpl.Scaling; } set { modelledImpl.Scaling = value; } } public Vector3 Position { get { return tangibleImpl.Position; } set { tangibleImpl.Position = value; } } public Vector3 Velocity { get { return tangibleImpl.Velocity; } set { tangibleImpl.Velocity = value; } } public ArmourPowerupEntity(Vector3 powerupPosition) : this(powerupPosition, DEFAULT_ARMOUR_SCALING) { } public ArmourPowerupEntity(Vector3 powerupPosition, float customScaling) { tangibleImpl = new DefaultTangibleEntityImpl(); modelledImpl = new DefaultModelledEntityImpl(tangibleImpl); Model = ModelDatabase.ArmourModel; Position = powerupPosition; Scaling = customScaling; } public bool CameraCanSeeThis(Camera camera) { return modelledImpl.CameraCanSeeThis(camera); } } public class RocketProjectileEntity : Entity, IModelledEntity, IAudibleEntity { private readonly DefaultTangibleEntityImpl tangibleImpl; private readonly DefaultModelledEntityImpl modelledImpl; private readonly DefaultAudibleEntityImpl audibleImpl; public ModelReference Model { get { return modelledImpl.Model; } set { modelledImpl.Model = value; } } public float Scaling { get { return modelledImpl.Scaling; } set { modelledImpl.Scaling = value; } } public SoundReference Sound { get { return audibleImpl.Sound; } set { audibleImpl.Sound = value; } } public float SoundRadius { get { return audibleImpl.SoundRadius; } set { audibleImpl.SoundRadius = value; } } public Vector3 Position { get { return tangibleImpl.Position; } set { tangibleImpl.Position = value; } } public Vector3 Velocity { get { return tangibleImpl.Velocity; } set { tangibleImpl.Velocity = value; } } public RocketProjectileEntity(Vector3 firingPoint, Vector3 firingVelocity, bool isBigRocket) { tangibleImpl = new DefaultTangibleEntityImpl(); modelledImpl = new DefaultModelledEntityImpl(tangibleImpl); audibleImpl = new DefaultAudibleEntityImpl(tangibleImpl); Model = ModelDatabase.RocketModel; Position = firingPoint; Velocity = firingVelocity; Scaling = isBigRocket ? 2f : 1f; Sound = SoundDatabase.RocketSound; SoundRadius = 1000f; } public bool CameraCanSeeThis(Camera camera) { return modelledImpl.CameraCanSeeThis(camera); } public bool CameraCanHearThis(Camera camera) { return audibleImpl.CameraCanHearThis(camera); } } \n\n In essence, we're now declaring the interfaces properly on the types and implementing them by deferring the real implementation to private composition objects. In the constructor for our entities we create the implementation objects and then use them in the methods and properties that we're required to implement as part of the interface contract. The advantages and disadvantages of this approach can be summed up as follows:\n\n \n\n Advantage: We now see type information at compile-time. We can use a in a list of and detecting whether the camera can see the entity is as simple as \" \". If later on the rockets don't make a sound any more and we remove the interface, all the places where it was used as an audible entity will become compile-time errors. Disadvantage: We're still writing a lot of boilerplate. Every class we write that uses this paradigm will have to have its interface implementation written manually, even when that implementation is just deferring to a field. \n\n So we've solved some of the more egregious problems in the first approach; but still require a lot of boilerplate. The good thing, however is that the boilerplate is now in the 'private implementation' area of the code, and no longer in the areas where the entities are actually used from the outside.\n\n \n\n This approach is more popular in the Java and enterprise worlds (and our naming convention here is very Java-esque). It is also a nascent form of objects. Unfortunately, I don't see (or know of) any way to really reduce boilerplate in this approach. In fact, adding a DI framework would probably just increase the noise (as DI frameworks tend to do) at this point.\n\n \n\n So... We're closer, but there's got to be a better way. I think this idea would quickly become tedious when writing more than a handful of entity types. And although we're not repeating the actual implementation code (good) we're repeating a lot of \"setup\" code (bad).\n\n \n\n Let's try something else.\n\n \n\n Now I expect that some readers will already have seen this approach inevitably coming somewhere down the line- it's not like I'm the first person to 'discover' that extension methods can be used to kludge in a form of multiple inheritance. They're also the first approach that starts to really look like automatic, compile-time multiple inheritance.\n\n \n\n In essence, the idea behind this approach is is to create empty interfaces and then have extension methods declared externally that actually add the functionality and methods you need.\n\n \n\n However, extension methods as a form of MI also have a couple of fundamental flaws that neither of our previous approaches had. To demonstrate this, let's first rewrite our ongoing example, leaving some implementation details out:\n\n \n\n // ENTITY BASE CLASS public class Entity { } // COMPONENTS (INTERFACES) public interface ITangibleEntity { } public interface IModelledEntity : ITangibleEntity { } public interface IAudibleEntity : ITangibleEntity { } // COMPONENTS (EXTENSION METHOD IMPLEMENTATIONS) public static class ComponentExtensions { // ITangibleEntity public static Vector3 GetPosition(this ITangibleEntity @this) { // TODO implement this } public static void SetPosition(this ITangibleEntity @this, Vector3 newPosition) { // TODO implement this } public static Vector3 GetVelocity(this ITangibleEntity @this) { // TODO implement this } public static void SetVelocity(this ITangibleEntity @this, Vector3 newVelocity) { // TODO implement this } // IModelledEntity public static ModelReference GetModel(this IModelledEntity @this) { // TODO implement this } public static void SetModel(this IModelledEntity @this, ModelReference newModel) { // TODO implement this } public static float GetScaling(this IModelledEntity @this) { // TODO implement this } public static void SetScaling(this IModelledEntity @this, float newScaling) { // TODO implement this } public static bool CameraCanSeeThis(this IModelledEntity @this, Camera camera) { return !PhysicsSystem.RayTest(camera.Position, GetPosition(@this)).IsObscured; } // IAudibleEntity public static SoundReference GetSound(this IModelledEntity @this) { // TODO implement this } public static void SetSound(this IModelledEntity @this, SoundReference newSound) { // TODO implement this } public static float GetSoundRadius(this IModelledEntity @this) { // TODO implement this } public static void SetSoundRadius(this IModelledEntity @this, float newSoundRadius) { // TODO implement this } public static bool CameraCanHearThis(this IModelledEntity @this, Camera camera) { return GetSoundRadius(@this) > Vector3.Distance(camera.Position, GetPosition(@this)); } } \n\n So, first of all, in case it's not obvious, this set up now theoretically allows us to use our entities like so:\n\n \n\n // ENTITIES public class ArmourPowerupEntity : Entity, IModelledEntity { private const float DEFAULT_ARMOUR_SCALING = 1f; public ArmourPowerupEntity(Vector3 powerupPosition) : this(powerupPosition, DEFAULT_ARMOUR_SCALING) { } public ArmourPowerupEntity(Vector3 powerupPosition, float customScaling) { this.SetModel(ModelDatabase.ArmourModel); this.SetPosition(powerupPosition); this.SetScaling(customScaling); } } public class RocketProjectileEntity : Entity, IModelledEntity, IAudibleEntity { public RocketProjectileEntity(Vector3 firingPoint, Vector3 firingVelocity, bool isBigRocket) { this.SetModel(ModelDatabase.RocketModel); this.SetPosition(firingPoint); this.SetVelocity(firingVelocity); this.SetScaling(isBigRocket ? 2f : 1f); this.SetSound(SoundDatabase.RocketSound); this.SetSoundRadius(1000f); } } // ELSEWHERE ... public void FireRocket(Vector3 playerPosition, Vector3 playerAimDirection, bool isHyperspeedRocket) { float rocketSpeed = isHyperspeedRocket ? 10f : 100f; RocketProjectileEntity rocketProjectile = new RocketProjectileEntity(playerPosition, playerAimDirection.WithLength(rocketSpeed), false); if (isHyperspeedRocket) { rocketProjectile.SetSound(SoundDatabase.HyperspeedRocketSound); rocketProjectile.SetSoundRadius(2000f); } } \n\n Already we're seeing some big payoffs from this approach. Ignore for a moment the fact that we haven't yet written an implementation for the / methods (we'll get to that), here's some of the advantages of using extension methods like this:\n\n \n\n Advantage: We still see type information at compile-time. Just like with approach #2, we can use a in a list of and detecting whether the camera can see the entity is as simple as \" \". Advantage: Not only is the information there at compile/code-writing-time; it's automatically all added for us, including the implementation! This is the true power of MI; and you can see the benefits immediately in the sheer reduction of boilerplate in our entity implementations. In fact... There's no boilerplate or implementation writing necessary at all! For example, we simply declared our rocket as and now all rockets have the state and method associated with audible entities, for free, with a sensible default implementation. \n\n But what about the disadvantages? I mentioned above that this paradigm has some serious flaws:\n\n \n\n Disadvantage: Because C# doesn't support extension properties (yet) we have to add fields in components in a kind of outmoded \"Java\" style using / methods. This is undoubtedly reason enough to discard this approach for some of you, but I promise that once you get over the initial shock it's not that bad. Disadvantage: Polymorphism has gone out the window. We can no longer override the default implementations in our entities in any way (e.g. can not override and can not add validation logic to etc.). Disadvantage: As pointed to by the fact that I've had to leave some parts above unimplemented (with just comments), there's no way to add fields that make up the adjunct, inherited state to entities using this approach. \n\n Now, the first disadvantage is one I can think of no workaround for at the time- we'll just have to hope that Microsoft sees fit to include extension properties in an update to the language sometime in the near future. If using getters and setters in lieu of real properties irks you too much, I should warn you that I'm not about to pull something out of the bag: We're stuck here.\n\n \n\n If you're willing to overlook that, however, let's move on to the latter two \"disadvantages\" (\"disadvantage\" is really an understatement here, let's call them what they are: Fundamental flaws). In my opinion, as long as either of these flaws exists this approach is untenable. So... Let's see if we can fix them, starting with the last one (no way to inherit fields).\n\n \n\n So we need a way to make it so that when an entity declares itself as implementing, say, , that the and properties are added automatically (albeit through the facade of getter and setter methods).\n\n \n\n The first idea one might have is to use our common base class, , as somewhere to 'put' all the inherited state information. I'm going to call this state \"adjunct state\" as it's added to the entities by the components. Here's a simple implementation using a hash map:\n\n \n\n // ENTITY BASE CLASS public class Entity { private readonly Dictionary<string, object> adjunctDataSpace = new Dictionary<string, object>(); internal T GetAdjunctField<T>(string name) { return (T) adjunctDataSpace[name]; } internal void SetAdjunctField<T>(string name, T value) { adjunctDataSpace[name] = value; } internal T GetAdjunctField<T>(string name, Func<T> defaultValueGenerator) { if (!adjunctDataSpace.ContainsKey(name)) adjunctDataSpace[name] = defaultValueGenerator(); return GetAdjunctField<T>(name); } } // COMPONENTS (INTERFACES) public interface ITangibleEntity { } // COMPONENTS (EXTENSION METHOD IMPLEMENTATIONS) public static class ComponentExtensions { // ITangibleEntity public static Vector3 GetPosition<T>(this T @this) where T : Entity, ITangibleEntity { return @this.GetAdjunctField(\"ITangibleEntity.Position\", () => Vector3.Zero); } public static void SetPosition<T>(this T @this, Vector3 newPosition) where T : Entity { @this.SetAdjunctField(\"ITangibleEntity.Position\", newPosition); } public static Vector3 GetVelocity<T>(this T @this) where T : Entity { return @this.GetAdjunctField(\"ITangibleEntity.Velocity\", () => Vector3.Zero); } public static void SetVelocity<T>(this T @this, Vector3 newVelocity) where T : Entity { @this.SetAdjunctField(\"ITangibleEntity.Velocity\", newVelocity); } } \n\n So this works fairly well; by using generic constraints on the extension methods we've essentially allowed ourselves to use some new methods on . Those methods store and retrieve adjunct data by way of a lookup/dictionary. Data is \"pseudo-initialized\" by way of the getter methods creating the value when it's first accessed.\n\n \n\n But, this approach still has a problem. Imagine we have a and we want to do something with the value on each of them. It's as simple as right? Wrong... Because we just have a list of tangible somethings that don't necessarily inherit from , we can't use the extension methods anymore. So either we have to start leaking generic constraints everywhere... Or we need to find a better way.\n\n \n\n In fact, we could do something like add the adjunct field stuff to a 'root mixin interface' that all our components inherit from... But frankly all of this is a bit of an exercise in futility. This approach could work for our specific example, but the whole point of mixins is that they can be, well, mixed in. We shouldn't have to require a root base class or for all types that want to use our mixins to have to implement some weird hash map stuff.\n\n \n\n So, perhaps we need to store the adjunct data elsewhere... Let's try something else:\n\n \n\n // ENTITY BASE CLASS public class Entity { } // COMPONENTS (INTERFACES) public interface ITangibleEntity { } // COMPONENTS (EXTENSION METHOD IMPLEMENTATIONS) public static class ComponentExtensions { private static readonly Dictionary<object, Dictionary<string, object>> adjunctData = new Dictionary<object, Dictionary<string, object>>(); private static T GetAdjunctField<T>(object owningObject, string name) { return (T) GetDataForObject(owningObject)[name]; } private static void SetAdjunctField<T>(object owningObject, string name, T value) { GetDataForObject(owningObject)[name] = value; } private static T GetAdjunctField<T>(object owningObject, string name, Func<T> defaultValueGenerator) { var objectData = GetDataForObject(owningObject); if (!objectData.ContainsKey(name)) objectData[name] = defaultValueGenerator(); return (T) objectData[name]; } private static Dictionary<string, object> GetDataForObject(object obj) { if (!adjunctData.ContainsKey(obj)) adjunctData[obj] = new Dictionary<string, object>(); return adjunctData[obj]; } // ITangibleEntity public static Vector3 GetPosition(this ITangibleEntity @this) { return GetAdjunctField(@this, \"ITangibleEntity.Position\", () => Vector3.Zero); } public static void SetPosition(this ITangibleEntity @this, Vector3 newPosition) { SetAdjunctField(@this, \"ITangibleEntity.Position\", newPosition); } public static Vector3 GetVelocity(this ITangibleEntity @this) { return GetAdjunctField(@this, \"ITangibleEntity.Velocity\", () => Vector3.Zero); } public static void SetVelocity(this ITangibleEntity @this, Vector3 newVelocity) { SetAdjunctField(@this, \"ITangibleEntity.Velocity\", newVelocity); } } \n\n So now we've moved the data somewhere off on its own. This works better, but the eagle eyed of you will have spotted that we just also created the mother of all memory leaks. When before an entity object was no longer accessible from any object root (i.e. it became garbage) the adjunct data stored in the dictionary would have been reclaimed along with it. Now however, every time an object is saved to the global dictionary, the key becomes a permanent reference in our global dictionary of objects.\n\n \n\n Damn, so close! But don't worry, there is an answer, and an easy one at that. We can replace the top-level dictionary with a with a . However, I will use the in the final implementation example at the bottom.\n\n \n\n So now that we've solved that issue, let's look at how we can get back our polymorphism.\n\n \n\n So, in case you're not sure even what the problem is here, take a look at the following example. Here the needs to implement a custom override that returns false when the armour has already been picked up:\n\n \n\n // ENTITIES public class ArmourPowerupEntity : Entity, IModelledEntity { private const float DEFAULT_ARMOUR_SCALING = 1f; private bool pickedUp = false; public ArmourPowerupEntity(Vector3 powerupPosition) : this(powerupPosition, DEFAULT_ARMOUR_SCALING) { } public ArmourPowerupEntity(Vector3 powerupPosition, float customScaling) { this.SetModel(ModelDatabase.ArmourModel); this.SetPosition(powerupPosition); this.SetScaling(customScaling); } public void PickUpArmour() { pickedUp = true; } public bool CameraCanSeeThis(Camera camera) { return !pickedUp && ComponentExtensions.CameraCanSeeThis(this, camera); // Powerup only visible if not already taken } } \n\n So, what's the problem? Well, let's see what happens when we try to call our override. Assume for now that the default implementation of for our powerup instance returns , i.e. the powerup's in view of the camera:\n\n \n\n \n\n Why is this happening? Basically, it's because our 'override' didn't really override anything, it just hid the extension method in certain use cases. So, what now?\n\n \n\n Well, here's where I think I'm gonna earn the most contempt; but I'm gonna go ahead and advocate a reflection-based solution. Firstly, let's look at modifying our class. I'm going to only show what we're adding below, to keep things brief:\n\n \n\n public static class ComponentExtensions { private static readonly Dictionary<string, Dictionary<Type, MethodInfo>> overrides = new Dictionary<string, Dictionary<Type, MethodInfo>>(); private static bool HasOverride(object targetObj, [CallerMemberName] string callerName = null) { if (!vtable.ContainsKey(callerName)) return false; var overridesForMember = overrides[callerName]; var targetType = targetObj.GetType(); return overridesForMember.ContainsKey(targetType); } private static T InvokeOverride<T>(object targetObj, object[] parameters, [CallerMemberName] string callerName = null) { var overridesForMember = overrides[callerName]; var targetType = targetObj.GetType(); return (T) overridesForMember[targetType].Invoke(targetObj, parameters); } private static void InvokeOverride(object targetObj, object[] parameters, [CallerMemberName] string callerName = null) { var overridesForMember = overrides[callerName]; var targetType = targetObj.GetType(); overridesForMember[targetType].Invoke(targetObj, parameters); } // ITangibleEntity public static Vector3 GetPosition(this ITangibleEntity @this) { if (HasOverride(@this)) { return InvokeOverride<Vector3>(@this, new object[] { }); } return GetAdjunctField(@this, \"ITangibleEntity.Position\", () => Vector3.Zero); } public static void SetPosition(this ITangibleEntity @this, Vector3 newPosition) { if (HasOverride(@this)) { InvokeOverride(@this, new object[] { newPosition }); return; } SetAdjunctField(@this, \"ITangibleEntity.Position\", newPosition); } public static Vector3 GetVelocity(this ITangibleEntity @this) { if (HasOverride(@this)) { return InvokeOverride<Vector3>(@this, new object[] { }); } return GetAdjunctField(@this, \"ITangibleEntity.Velocity\", () => Vector3.Zero); } public static void SetVelocity(this ITangibleEntity @this, Vector3 newVelocity) { if (HasOverride(@this)) { InvokeOverride(@this, new object[] { newVelocity }); return; } SetAdjunctField(@this, \"ITangibleEntity.Velocity\", newVelocity); } } \n\n Hopefully you're beginning to see what we're aiming for here. The default implementations will check to see if there's a more specific implementation stored in the map, and if there is, the override is executed and the default implementation returns. So the only that question remains now, is how do we populate ?\n\n \n\n Side-note: If you're concerned about creating too much garbage with respect to the paramter, simply follow . You can also then use generics to avoid boxing (see \n\n \n\n Also, there are some neater ways using generics and other magic to condense the boilerplate a little, but I wanted to keep things simple for now.\n\n \n\n Anyway, here's how to get the global list of overrides at application start up. Firstly, you need to make sure that all relevant types are loaded already when this code executes. That will be dependent on your application, but it usually boils down to ensuring that the runtime has had to load every immediately dependent assembly by the point this logic runs. Your scenario may be more complex, however: If it's actually not possible to ensure this in your case, you can still implement this approach but you'll need to run the 'initialization' logic as-and-when for each new assembly that gets loaded.\n\n \n\n For now, though, this is the code that will work for the majority of cases:\n\n \n\n public static class ComponentExtensions { private static readonly Dictionary<string, Dictionary<Type, MethodInfo>> overrides = new Dictionary<string, Dictionary<Type, MethodInfo>>(); internal static void PopulateOverrideTable() { var allLoadedTypes = AppDomain.CurrentDomain.GetAssemblies() .SelectMany(ass => ass.GetReferencedAssemblies().Select(Assembly.Load).Concat(new[] { ass })) .Distinct() .SelectMany(ass => ass.GetTypes()); var allComponentExtensions = typeof(ComponentExtensions).GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static) .Where(mi => mi.GetCustomAttributes(typeof(ExtensionAttribute), false).Length > 0); foreach (Type t in allLoadedTypes) { foreach (MethodInfo extMethod in allComponentExtensions) { string callerMemberName = extMethod.Name; var matchingOverride = t.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance) .FirstOrDefault(mi => mi.Name == callerMemberName); if (matchingOverride != null) { if (!overrides.ContainsKey(callerMemberName)) overrides[callerMemberName] = new Dictionary<Type, MethodInfo>(); overrides[callerMemberName][t] = matchingOverride; } } } } } \n\n The code above is basically searching all loaded types for methods which match the name of our extension methods, and adding them to the dictionary.\n\n \n\n The code as it is will take a long time to finish (which is why it's best done at init-time). However, if you use some way to mark your \"mixin\" interfaces (e.g. with a \"[Mixin]\" attribute) or similar, you could easily filter out all types that don't implement any of those interfaces. There are other such optimisations available, but all of these will depend on your exact application, so I'll leave that up to you. You could also compile the method info invocations to expressions for further speed, if this is a requirement.\n\n \n\n Also if you're worried about 'false positives' (e.g. types being added to the overrides database who just happen to have a method that shares the same name), the [Mixin] attribute will stop this. It's not necessary though, as false positives will just sit in the overrides dictionary and never be called.\n\n \n\n Additionally, the code is in a basic form right now. You might want to add more stringent criteria, such as checking that the parameters of the matching override and the extension method are the same.\n\n \n\n And lastly, if you run obfuscation on your application, this approach may very well break down. In that case, you can try using something other than the method's name to identify it as an override, such as another custom attribute.\n\n \n\n So, here's the final implementation; my preferred kludge to get multiple inheritance in C# (now doing away with the 'game engine' theme in lieu of a more general example):\n\n \n\n public interface IMixinAlpha { } public interface IMixinBeta { } public static class ComponentExtensions { #region MI Impl private static readonly ConditionalWeakTable<IMixinAlpha, MixinAlphaProperties> alphaEphemerons = new ConditionalWeakTable<IMixinAlpha, MixinAlphaProperties>(); private static readonly ConditionalWeakTable<IMixinBeta, MixinBetaProperties> betaEphemerons = new ConditionalWeakTable<IMixinBeta, MixinBetaProperties>(); private static readonly Dictionary<string, Dictionary<Type, MethodInfo>> vtable = new Dictionary<string, Dictionary<Type, MethodInfo>>(); internal static void PopulateVirtualTable() { var allLoadedTypes = AppDomain.CurrentDomain.GetAssemblies() .SelectMany(ass => ass.GetReferencedAssemblies().Select(Assembly.Load).Concat(new[] { ass })) .Distinct() .SelectMany(ass => ass.GetTypes()); var allComponentExtensions = typeof(ComponentExtensions).GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static) .Where(mi => mi.GetCustomAttributes(typeof(ExtensionAttribute), false).Length > 0); foreach (Type t in allLoadedTypes) { foreach (MethodInfo extMethod in allComponentExtensions) { string callerMemberName = extMethod.Name; var matchingOverride = t.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance) .FirstOrDefault(mi => mi.Name == callerMemberName); if (matchingOverride != null) { if (!vtable.ContainsKey(callerMemberName)) vtable[callerMemberName] = new Dictionary<Type, MethodInfo>(); vtable[callerMemberName][t] = matchingOverride; } } } } private static bool HasOverride(object targetObj, [CallerMemberName] string callerName = null) { if (!vtable.ContainsKey(callerName)) return false; var overridesForMember = vtable[callerName]; var targetType = targetObj.GetType(); return overridesForMember.ContainsKey(targetType); } private static T InvokeOverride<T>(object targetObj, object[] parameters, [CallerMemberName] string callerName = null) { var overridesForMember = vtable[callerName]; var targetType = targetObj.GetType(); return (T) overridesForMember[targetType].Invoke(targetObj, parameters); } private static void InvokeOverride(object targetObj, object[] parameters, [CallerMemberName] string callerName = null) { var overridesForMember = vtable[callerName]; var targetType = targetObj.GetType(); overridesForMember[targetType].Invoke(targetObj, parameters); } private static MixinAlphaProperties GetAdjunctProperties(IMixinAlpha target) { MixinAlphaProperties result; if (alphaEphemerons.TryGetValue(target, out result)) return result; MixinAlphaProperties defaultProps = new MixinAlphaProperties(); alphaEphemerons.Add(target, defaultProps); return defaultProps; } private static MixinBetaProperties GetAdjunctProperties(IMixinBeta target) { MixinBetaProperties result; if (betaEphemerons.TryGetValue(target, out result)) return result; MixinBetaProperties defaultProps = new MixinBetaProperties(); betaEphemerons.Add(target, defaultProps); return defaultProps; } #endregion #region Alpha Impl private class MixinAlphaProperties { public int AlphaInt = 10; public string AlphaString = \"Hello!\"; } public static int GetAlphaInt(this IMixinAlpha @this) { if (HasOverride(@this)) { return InvokeOverride<int>(@this, new object[] { }); } return GetAdjunctProperties(@this).AlphaInt; } public static void SetAlphaInt(this IMixinAlpha @this, int newValue) { if (HasOverride(@this)) { InvokeOverride(@this, new object[] { newValue }); return; } GetAdjunctProperties(@this).AlphaInt = newValue; } public static string GetAlphaString(this IMixinAlpha @this) { if (HasOverride(@this)) { return InvokeOverride<string>(@this, new object[] { }); } return GetAdjunctProperties(@this).AlphaString; } public static void SetAlphaString(this IMixinAlpha @this, string newValue) { if (HasOverride(@this)) { InvokeOverride(@this, new object[] { newValue }); return; } GetAdjunctProperties(@this).AlphaString = newValue; } #endregion #region Beta Impl private class MixinBetaProperties { public int BetaInt = 0; public float BetaFloat = 0f; } public static int GetBetaInt(this IMixinBeta @this) { if (HasOverride(@this)) { return InvokeOverride<int>(@this, new object[] { }); } return GetAdjunctProperties(@this).BetaInt; } public static void SetBetaInt(this IMixinBeta @this, int newValue) { if (HasOverride(@this)) { InvokeOverride(@this, new object[] { newValue }); return; } GetAdjunctProperties(@this).BetaInt = newValue; } public static float GetBetaFloat(this IMixinBeta @this) { if (HasOverride(@this)) { return InvokeOverride<float>(@this, new object[] { }); } return GetAdjunctProperties(@this).BetaFloat; } public static void SetBetaFloat(this IMixinBeta @this, float newValue) { if (HasOverride(@this)) { InvokeOverride(@this, new object[] { newValue }); return; } GetAdjunctProperties(@this).BetaFloat = newValue; } public static bool BetaFoobar(this IMixinBeta @this) { if (HasOverride(@this)) { return InvokeOverride<bool>(@this, new object[] { }); } var adjunctData = GetAdjunctProperties(@this); return adjunctData.BetaFloat >= adjunctData.BetaInt * 2; } #endregion } \n\n And then the all-important example usage:\n\n \n\n public class ExampleTypeOne : IMixinAlpha, IMixinBeta { public ExampleTypeOne(int alphaInt, string alphaString) { this.SetAlphaInt(alphaInt); this.SetAlphaString(alphaString); } public virtual bool BetaFoobar() { return this.GetBetaFloat() >= this.GetBetaInt() * 3; } } public class ExampleTypeTwo : ExampleTypeOne { public ExampleTypeTwo(int alphaInt, string alphaString) : base(alphaInt, alphaString) { } public override bool BetaFoobar() { return this.GetBetaFloat() >= this.GetBetaInt() * 4; } } static void Main(string[] args) { ComponentExtensions.PopulateVirtualTable(); ExampleTypeOne one = new ExampleTypeOne(2, \"Cool\"); one.SetBetaFloat(30f); one.SetBetaInt(10); Console.WriteLine(one.GetAlphaInt() + one.GetAlphaString()); // \"2Cool\" Console.WriteLine(one.BetaFoobar()); // \"True\" ExampleTypeTwo two = new ExampleTypeTwo(3, \"Spooky\"); two.SetBetaFloat(30f); two.SetBetaInt(10); Console.WriteLine(two.GetAlphaInt() + two.GetAlphaString()); // \"3Spooky\" Console.WriteLine(two.BetaFoobar()); // \"False\" Console.WriteLine((one as IMixinBeta).BetaFoobar()); // \"True\" Console.WriteLine((two as IMixinBeta).BetaFoobar()); // \"False\" Console.ReadKey(); } \n\n Some final notes:\n\n \n\n Firstly, I decided to be a bit more specific with the way the adjunct data is kept track of than in the game engine examples. I think this way, if you can do it (i.e. you have a known, limited set of mixin types), it's much nicer, as it eliminates the amount of boxing and string keying going on.\n\n \n\n Secondly, the whole \"using dictionaries\" approach can (and should) be replaced with something a bit more substantial; a double-nested dictionary is usually a sign that you need to create a new type or similar somewhere, and this is no exception- but I'll leave that as an improvement to be completed at will.\n\n \n\n Thirdly, although my preference is to use the third approach (i.e. with the extension methods), that's not to say the first two approaches above aren't also perfectly viable. The ugly reality is that until C# supports some form of mixin/MI natively, everything we do here is going to be a bit of a hack. The reason I prefer the third approach is that it allows the consumer of your API to continue using your types with no knowledge of the underlying mechanism, as well as making the job of the maintainer of the API the easiest. The tradeoff, of course, is the nasty innards (with reflection) of the implementation; but apart from the unfortunate transition from properties to getters and setters, the code looks identical to the manually implemented alternative from the outside.\n\n \n\n And finally, there are undoubtedly more implementation approaches than what I've shown here, so if you have any corrections, suggestions, criticisms, or additions, please do leave a comment! By the way, I do realise that this has been a very long post; so I should say that I expect my next one to be a lot shorter, for my own sake. ;) Peace!\n\n \n\n Before I begin, I need to point out that this post is lengthy, and is written as a kind of \"journey through examples\". This is for those who want to understand the reasoning behind the eventual final implementation and perhaps learn about C# along the way. If you, like me, prefer to jump straight to some source code, you can skip to the final implementation first (use the table-of-contents on the right), and perhaps come back after. :)I'm assuming that most of you reading this will know what \"standard\" inheritance means in C#. It's the classic parent -> child class-extension mechanism that looks something like this:Anyway, this kind of \"classical OO\" inheritance is (rightly) frowned upon these days. Heavy use of inheritance has been shunned by many in the C# world in favour of things like composition . Accordingly, inheritance has become a \"dirty word\" among most OOP programmers- just saying the word alone can get you booted from design meetings. ;)There are multiple good reasons as to why this form of inheritance-based API-design is a bad idea, but one of the reasons is that however you attempt to model your target domain, certain types just tend to cross over the 'branches' of your inheritance hierarchy. Taking our musical instrument example, at some point someone might want you to add a class that represents some weird hybrid-instrument , or perhaps you'll find out later on that drums require tuning too . Essentially, unless the problem domain is 100% known at design-time, classical inheritance just ends up sending you down a very restrictive and binding path.What's worse is that in the past, people tried to solve these problems by throwing more bad inheritance at it, and multiple inheritance was no exception. \"For the hybrid-instrument, we can make our type inherit from StringInstrument and WindInstrument!\" they would say. This, naturally, led to even more problems such as The Diamond of Death and didn't really solve the underlying issue at all. In fact, it made it worse.Ultimately, the problem was with trying to model objects in the world as a series of progressive alterations and enhancements. It's easy to think of reality as being \"Instrument -> Stringed -> Piano\" but in actualitymay be the only valid 'base class' of all instruments, and everything else is simply a property of tangible types. For example,is a property of a piano. It is also, and is ainstrument.What's weird though, is that instead of throwing out the broken tool (single inheritance) we kept that and threw out the one that allows us to apply multiple properties to objects. It seems that people looked at the entire mess caused by trying to force everything through inheritance and noticed that MI tended to make things even worse. But that was a result of doubling down on a bad decision in the first place: Namely, encouraging all objects to stem from a single root and fit somewhere on a big 'tree' of inheritance.Thankfully, we didn't completely throw out the multiple-inheritance paradigm; and it came back in the form of, which allow us to label our types as having multiple properties, leaving the actual implementation down to the type itself.For example, a more modern/idiomatic approach to our musical instruments application might look as follows:Notice how we're no longer bound by the strict rules of inheritance. Our instruments are simply inheriting from(which is fair enough) and then they declare all their properties with ease. For the(that hybrid instrument in the video I linked above) we can change the strings and the reed. For the piano we can ask what the maximum number of notes playable at once is (which would be 10, ignoring smashing the keys with your head as an optional technique) as well as change the strings should we need to.And this kind of design works just fine for a lot of applications. But what about when we want to declare multiple properties of a typeprovide a default implementation for those properties? If you think there's no need for this ever, please consider every time you've manually implemented INotifyPropertyChanged , or told a DI container to use the same implementation for an injected property, or had to write the same tedious and error prone code for every implementation of every class that implements IXmlSerializable C# doesn't really have a formal answer to this. You can write aclass and then delegate most implementations of interfaces on your types to a, but doesn't that seem a bit messy? For every type that implements the interface which has a default implementation, you have to implement the methods manually, simply passing the real implementation off to your private composition object. If you're not sure what I mean, check the second 'approach' below, it shows off this inferior style.Alternatively, there is the option of using Dependency Injection frameworks to provide implementations of interfaces declared on types at runtime, often (though not always) through constructor-parameter-injection. This has its own drawbacks of course; the biggest being that they usually need to use reflection or compile-time IL rewriting to achieve this. The fact that this is required should be indicative that perhaps we need more language-level support for supplying default implementations on interfaces.Of course, when we're talking about supplying 'default' implementations for interfaces, we should still be very careful. Although we're not talking about the \"classical-OOP\" forms of MI anymore, we're still talking about the very strong code-coupling that comes with automatically-inherited implementations. Trying to do too much with this paradigm will eventually bring us back to the original problems- and the reason why so many people still have disdain for MI as a concept.But I'm not talking about trying to go back to the old days. I'm talking about single, atomic, 'micro-properties': Very small building blocks of implementation that can be combined with other building blocks to compose actual types. Ones that add absolutely nothing more than they need to, and represent a single facet of an object. This concept isn't even new to the programming world; in fact, they have a name: Mixins . Mixins, like all programming concepts, can of course be overused and abused and used in the wrong places. But used well they can actually reduce code duplication, thereby upholding the DRY principle . And that is why I'm an advocate for multiple inheritance (at least, in this form).Finally, if you're still unconvinced, it might interest you to know that Java added MI functionality via 'default implementations' on interfaces not that long ago. Admittedly, it was more as a way of hacking in their new functional APIs without losing backward-compatibility, but nonetheless, if Java, the world's slowest moving language, thinks it's a good idea... Perhaps it is. Or not. Up to you. ;)Unfortunately C# offers no inbuilt mechanism for mixins or any other form of MI other than pure-virtual base-class inheritance (i.e. interfaces). That means that whatever approach or methodology we come up below isn't going to ever be as neat as a language-supported one. Please try to bear that in mind as we go down the rabbit-hole. ;)I'm going to present this section as a series of examples, each with their own advantages and disadvantages: No one approach is perfect.Finally, throughout the rest of the post I will be using a game-engine entity system as the example material; however, you don't need to be a gamer or engine programmer to understand what's going on.Let's build an example to elucidate the problem we're actually trying to solve. As I mentioned, I'm going to build the beginning of an entity system. If you're not familiar with such a system; it's basically a programming pattern/model that's used often in game development. In a typical entity system, anobject represents a single 'thing' in the game world (such as a player, or a powerup, or a projectile, or a tank... Etc.). Eachis then composed of various properties that are relevant to its type, such as \"represented visually with a 3D model\" and \"can be collided with in the physics system\", etc.To start, let's write out our first attempt at modelling an entity system with a couple of real-world entities (at the moment I'm ignoring thread-safety concerns; let's just keep things simple and assume a single thread).First of all, thetype, the base class of all entities:And now let's make some component types:Alright, so we have athat represents any entity with a 3D model and anthat represents any entity that makes a sound. Both have a custom method that can be used to determine whether or not the player can see or hear the given entity. If you're absolutely new to game programming don't worry too much about the example implementations I've given, they're just there for the demonstration, what's important is the object graph we're trying to model.So, now let's write some entities:Alright then! We've got two very important entities representable in our game: An armour powerup and a rocket projectile. Job done!But now, management says that they want to be able to hear the rocket hissing as it flies past the player's ear on a near-miss. And now we're kind of stuck, because C# doesn't allow this kind of multiple inheritance (where we could write something akin to).But we do want this behaviour, really, so that we can do things like use aas awhen writing code concerned with itsand what it looks like, and use it as anwhen we care about whether or not the player can hear it. And this is just the tip of the iceberg, in reality entity systems have many intertwined component types and needs!Of course, as I mentioned above, interfaces would allow us that strongly-typed multi-use ability. We could markasand... But then we have to re-implement methods like CameraCanHearThis()/CameraCanSeeThis() and even properties like Scale on every type that implemented those interfaces!So... What now? Let's investigate some options. ;)The first idea we're going to explore here is one where we add, remove, and use components of entities at rumtime, typically with methods like \"AddComponent\", \"RemoveComponent\", etc.Here's our example using this approach:This is basically composition over inheritance being put to very good use. If we want to determine whether a given entity can be heard from a given camera, we first useto see whether the entity makes a sound at all, then we useto retrieve the, on which we can subsequently call. Sorted!...Well, this approach is well known and certainly the most popular. In fact, the widely used C#-based Unity game engine uses a similar idea.However, the way I see it, this design has three flaws (and one advantage!):Now, personally, I'm of the opinion that the disadvantages outweigh the advantages here. The multithreading thing isn't so bad, but the pushing of what could/should be compile-time information to runtime is what sets off my unease. Also, the fact that common properties have to be set/modified simultaneously is quite nasty, and although I can think of a couple of ways around that, of varying degrees of convolution, it starts to add even more hackery and hidden magic.That's not to say that this approach is useless, and it's certainly more idiomatic than where we'll be going from here, but let's explore some more options.This second approach is the other way to implement the composition over inheritance paradigm. In contrast to approach number one, we're going to get back compile-time information but at the cost of developer-annoyance-level. ;) Basically, we will add interfaces to our entities and then delegate their implementations to private implementation objects. Let's jump straight to the example:In essence, we're now declaring the interfaces properly on the types and implementing them by deferring the real implementation to private composition objects. In the constructor for our entities we create the implementation objects and then use them in the methods and properties that we're required to implement as part of the interface contract. The advantages and disadvantages of this approach can be summed up as follows:So we've solved some of the more egregious problems in the first approach; but still require a lot of boilerplate. The good thing, however is that the boilerplate is now in the 'private implementation' area of the code, and no longer in the areas where the entities are actually used from the outside.This approach is more popular in the Java and enterprise worlds (and our naming convention here is very Java-esque). It is also a nascent form of Dependency Injection ; which is generally considered a good practice. In fact, writing code in this way can allow us to use a DI framework to inject those dependencies for us automatically- though this doesn't really solve the problem of having to defer interface implementations to the privateobjects. Unfortunately, I don't see (or know of) any way to really reduce boilerplate in this approach. In fact, adding a DI framework would probably just increase the noise (as DI frameworks tend to do) at this point.So... We're closer, but there's got to be a better way. I think this idea would quickly become tedious when writing more than a handful of entity types. And although we're not repeating the actual implementation code (good) we're repeating a lot of \"setup\" code (bad).Let's try something else.Now I expect that some readers will already have seen this approach inevitably coming somewhere down the line- it's not like I'm the first person to 'discover' that extension methods can be used to kludge in a form of multiple inheritance. They're also the first approach that starts to really look like automatic, compile-time multiple inheritance.In essence, the idea behind this approach is is to create empty interfaces and then have extension methods declared externally that actually add the functionality and methods you need.However, extension methods as a form of MI also have a couple of fundamental flaws that neither of our previous approaches had. To demonstrate this, let's first rewrite our ongoing example, leaving some implementation details out:So, first of all, in case it's not obvious, this set up now theoretically allows us to use our entities like so:Already we're seeing some big payoffs from this approach. Ignore for a moment the fact that we haven't yet written an implementation for themethods (we'll get to that), here's some of the advantages of using extension methods like this:But what about the disadvantages? I mentioned above that this paradigm has some serious flaws:Now, the first disadvantage is one I can think of no workaround for at the time- we'll just have to hope that Microsoft sees fit to include extension properties in an update to the language sometime in the near future. If using getters and setters in lieu of real properties irks you too much, I should warn you that I'm not about to pull something out of the bag: We're stuck here.If you're willing to overlook that, however, let's move on to the latter two \"disadvantages\" (\"disadvantage\" is really an understatement here, let's call them what they are: Fundamental flaws). In my opinion, as long as either of these flaws exists this approach is untenable. So... Let's see if we can fix them, starting with the last one (no way to inherit fields).So we need a way to make it so that when an entity declares itself as implementing, say,, that theandproperties are added automatically (albeit through the facade of getter and setter methods).The first idea one might have is to use our common base class,, as somewhere to 'put' all the inherited state information. I'm going to call this state \"adjunct state\" as it's added to the entities by the components. Here's a simple implementation using a hash map:So this works fairly well; by using generic constraints on the extension methods we've essentially allowed ourselves to use some new methods on. Those methods store and retrieve adjunct data by way of a lookup/dictionary. Data is \"pseudo-initialized\" by way of the getter methods creating the value when it's first accessed.But, this approach still has a problem. Imagine we have aand we want to do something with thevalue on each of them. It's as simple asright? Wrong... Because we just have a list of tangible somethings that don't necessarily inherit from, we can't use the extension methods anymore. So either we have to start leaking generic constraints everywhere... Or we need to find a better way.In fact, we could do something like add the adjunct field stuff to a 'root mixin interface' that all our components inherit from... But frankly all of this is a bit of an exercise in futility. This approach could work for our specific example, but the whole point of mixins is that they can be, well, mixed in. We shouldn't have to require a root base class or for all types that want to use our mixins to have to implement some weird hash map stuff.So, perhaps we need to store the adjunct data elsewhere... Let's try something else:So now we've moved the data somewhere off on its own. This works better, but the eagle eyed of you will have spotted that we just also created the mother of all memory leaks. When before an entity object was no longer accessible from any object root (i.e. it became garbage) the adjunct data stored in the dictionary would have been reclaimed along with it. Now however, every time an object is saved to the global dictionary, the key becomes a permanent reference in our global dictionary of objects.Damn, so close! But don't worry, there is an answer, and an easy one at that. We can replace the top-level dictionary with a ConditionalWeakTable . This special compiler-supported type only keeps a key as long as the key is being strongly referenced elsewhere in the application. I'm not going to write another example to demonstrate this right here, just replace the firstwith a. However, I will use thein the final implementation example at the bottom.So now that we've solved that issue, let's look at how we can get back our polymorphism.So, in case you're not sure even what the problem is here, take a look at the following example. Here theneeds to implement a customoverride that returns false when the armour has already been picked up:So, what's the problem? Well, let's see what happens when we try to call our override. Assume for now that the default implementation offor our powerup instance returns, i.e. the powerup's in view of the camera:Why is this happening? Basically, it's because our 'override' didn't really override anything, it just hid the extension method in certain use cases. So, what now?Well, here's where I think I'm gonna earn the most contempt; but I'm gonna go ahead and advocate a reflection-based solution. Firstly, let's look at modifying ourclass. I'm going to only show what we're adding below, to keep things brief:Hopefully you're beginning to see what we're aiming for here. The default implementations will check to see if there's a more specific implementation stored in themap, and if there is, the override is executed and the default implementation returns. So the only that question remains now, is how do we populateSide-note: If you're concerned about creating too much garbage with respect to theparamter, simply follow String.Format 's lead and provide a few overrides with a specific number of parameters; using an object-array pool to construct the calls to. You can also then use generics to avoid boxing (see here for more info if you're unaware of this technique).Also, there are some neater ways using generics and other magic to condense the boilerplate a little, but I wanted to keep things simple for now.Anyway, here's how to get the global list of overrides at application start up. Firstly, you need to make sure that all relevant types are loaded already when this code executes. That will be dependent on your application, but it usually boils down to ensuring that the runtime has had to load every immediately dependent assembly by the point this logic runs. Your scenario may be more complex, however: If it's actually not possible to ensure this in your case, you can still implement this approach but you'll need to run the 'initialization' logic as-and-when for each new assembly that gets loaded.For now, though, this is the code that will work for the majority of cases:The code above is basically searching all loaded types for methods which match the name of our extension methods, and adding them to thedictionary.The code as it is will take a long time to finish (which is why it's best done at init-time). However, if you use some way to mark your \"mixin\" interfaces (e.g. with a \"[Mixin]\" attribute) or similar, you could easily filter out all types that don't implement any of those interfaces. There are other such optimisations available, but all of these will depend on your exact application, so I'll leave that up to you. You could also compile the method info invocations to expressions for further speed, if this is a requirement.Also if you're worried about 'false positives' (e.g. types being added to the overrides database who just happen to have a method that shares the same name), the [Mixin] attribute will stop this. It's not necessary though, as false positives will just sit in the overrides dictionary and never be called.Additionally, the code is in a basic form right now. You might want to add more stringent criteria, such as checking that the parameters of the matching override and the extension method are the same.And lastly, if you run obfuscation on your application, this approach may very well break down. In that case, you can try using something other than the method's name to identify it as an override, such as another custom attribute.So, here's the final implementation; my preferred kludge to get multiple inheritance in C# (now doing away with the 'game engine' theme in lieu of a more general example):And then the all-important example usage:Some final notes:Firstly, I decided to be a bit more specific with the way the adjunct data is kept track of than in the game engine examples. I think this way, if you can do it (i.e. you have a known, limited set of mixin types), it's much nicer, as it eliminates the amount of boxing and string keying going on.Secondly, the whole \"using dictionaries\" approach can (and should) be replaced with something a bit more substantial; a double-nested dictionary is usually a sign that you need to create a new type or similar somewhere, and this is no exception- but I'll leave that as an improvement to be completed at will.Thirdly, although my preference is to use the third approach (i.e. with the extension methods), that's not to say the first two approaches above aren't also perfectly viable. The ugly reality is that until C# supports some form of mixin/MI natively, everything we do here is going to be a bit of a hack. The reason I prefer the third approach is that it allows the consumer of your API to continue using your types with no knowledge of the underlying mechanism, as well as making the job of the maintainer of the API the easiest. The tradeoff, of course, is the nasty innards (with reflection) of the implementation; but apart from the unfortunate transition from properties to getters and setters, the code looks identical to the manually implemented alternative from the outside.And finally, there are undoubtedly more implementation approaches than what I've shown here, so if you have any corrections, suggestions, criticisms, or additions, please do leave a comment! By the way, I do realise that this has been a very long post; so I should say that I expect my next one to be a lot shorter, for my own sake. ;) Peace! Please enable JavaScript to view the comments powered by Disqus."
    },
    {
        "link": "https://stackoverflow.com/questions/75052445/is-it-possible-to-require-a-derived-class-to-implement-a-virtual-method-from-bas",
        "document": "I want a method to do a consistent thing in base class while derived classes can have it do something different (hence it being virtual), while requiring it be implemented in derived classes as if it were abstract. It being required would prevent forgetfulness of implementing it among myself and others working on it.\n\nTo break it down (this code is for a Unity project):\n\nIn this case, I want or any other child classes to require implementing without it being abstract.\n\nTl;dr: Essentially I want which isn't possible as far as I know, but I hope to learn of a way to do it.\n\nGiven that I haven't found this question posted here or anywhere else, I'm expecting the answer to be \"don't be silly, it's impossible\" but thought I'd ask, since a friend of mine has had the same question."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/events",
        "document": "Events in .NET are based on the delegate model. The delegate model follows the observer design pattern, which enables a subscriber to register with and receive notifications from a provider. An event sender pushes a notification when an event occurs. An event receiver defines the response. This article describes the major components of the delegate model, how to consume events in applications, and how to implement events in your code.\n\nAn event is a message sent by an object to signal the occurrence of an action. The action might be user interaction, such as a button press, or it might result from other program logic, such as a property value change. The object that raises the event is called the event sender. The event sender doesn't know the object or method that receives (handles) the events it raises. The event is typically a member of the event sender. For example, the Click event is a member of the Button class, and the PropertyChanged event is a member of the class that implements the INotifyPropertyChanged interface.\n\nTo define an event, you use the C# event or the Visual Basic Event keyword in the signature of your event class, and specify the type of delegate for the event. Delegates are described in the next section.\n\nTypically, to raise an event, you add a method that is marked as and (in C#) or and (in Visual Basic). The naming convention for the method is , such as . The method should take one parameter that specifies an event data object, which is an object of type EventArgs or a derived type. You provide this method to enable derived classes to override the logic for raising the event. A derived class should always call the method of the base class to ensure registered delegates receive the event.\n\nThe following example shows how to declare an event named . The event is associated with the EventHandler delegate and raised in a method named :\n\nA delegate is a type that holds a reference to a method. A delegate is declared with a signature that shows the return type and parameters for the methods it references. It can hold references only to methods that match its signature. A delegate is equivalent to a type-safe function pointer or a callback. A delegate declaration is sufficient to define a delegate class.\n\nDelegates have many uses in .NET. In the context of events, a delegate is an intermediary (or pointer-like mechanism) between the event source and the code that handles the event. You associate a delegate with an event by including the delegate type in the event declaration, as shown in the example in the previous section. For more information about delegates, see the Delegate class.\n\n.NET provides the EventHandler and EventHandler<TEventArgs> delegates to support most event scenarios. Use the EventHandler delegate for all events that don't include event data. Use the EventHandler<TEventArgs> delegate for events that include data about the event. These delegates have no return type value and take two parameters (an object for the source of the event and an object for event data).\n\nDelegates are multicast class objects, which means they can hold references to more than one event-handling method. For more information, see the Delegate reference page. Delegates provide flexibility and fine-grained control in event handling. A delegate acts as an event dispatcher for the class that raises the event by maintaining a list of registered event handlers for the event.\n\nUse the EventHandler and EventHandler<TEventArgs> delegate types to define the needed delegate. You mark a delegate with the type in [C#]](../../csharp/language-reference/builtin-types/reference-types.md#the-delegate-type) or the type in Visual Basic in the declaration. The following example shows how to declare a delegate named :\n\nData associated with an event can be provided through an event data class. .NET provides many event data classes that you can use in your applications. For example, the SerialDataReceivedEventArgs class is the event data class for the SerialPort.DataReceived event. .NET follows a naming pattern where all event data classes end with the suffix. You determine which event data class is associated with an event by looking at the delegate for the event. For example, the SerialDataReceivedEventHandler delegate includes the SerialDataReceivedEventArgs class as a parameter.\n\nThe EventArgs class is typically the base type for event data classes. You also use this class if an event doesn't have any data associated with it. When you create an event that notifies subscribers that something happened without any additional data, include the EventArgs class as the second parameter in the delegate. You can pass the EventArgs.Empty value when no data is provided. The EventHandler delegate includes the EventArgs class as a parameter.\n\nYou can create a class that derives from the EventArgs class to provide any members needed to pass data related to the event. Typically, you should use the same naming pattern as .NET and end your event data class name with the suffix.\n\nThe following example shows an event data class named that contains properties that are specific to the event being raised:\n\nTo respond to an event, you define an event handler method in the event receiver. This method must match the signature of the delegate for the event you're handling. In the event handler, you perform the actions that are required when the event is raised, such as collecting user input after the user presses a button. To receive notifications when the event occurs, your event handler method must subscribe to the event.\n\nThe following example shows an event handler method named that matches the signature for the EventHandler delegate. The method subscribes to the event:\n\n.NET allows subscribers to register for event notifications either statically or dynamically. Static event handlers are in effect for the entire life of the class whose events they handle. Dynamic event handlers are explicitly activated and deactivated during program execution, usually in response to some conditional program logic. You can use dynamic handlers when event notifications are needed only under certain conditions, or when run-time conditions determine the specific handler to call. The example in the previous section shows how to dynamically add an event handler. For more information, see Events (in Visual Basic) and Events (in C#).\n\nIf your class raises multiple events, the compiler generates one field per event delegate instance. If the number of events is large, the storage cost of one field per delegate might not be acceptable. For these scenarios, .NET provides event properties that you can use with another data structure of your choice to store event delegates.\n\nEvent properties consist of event declarations accompanied by event accessors. Event accessors are methods that you define to add or remove event delegate instances from the storage data structure.\n\nThe trade-off is between memory and speed. If your class defines many events that are infrequently raised, you should implement event properties. For more information, see Handle multiple events by using event properties.\n\nThe following resources describe other tasks and concepts related to working with events:\n• Raise and consume events: Find examples for raising and consuming events.\n• Handle multiple events with event properties: Discover how to use event properties to handle multiple events.\n• Explore the observer design pattern: Review a design pattern that enables a subscriber to register with and receive notifications from a provider.\n\nSpecification reference documentation is available for the APIs that support event handling:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/events",
        "document": "Events enable a class or object to notify other classes or objects when something of interest occurs. The class that sends (or raises) the event is called the publisher and the classes that receive (or handle) the event are called subscribers.\n\nIn a typical C# Windows Forms or Web application, you subscribe to events raised by controls such as buttons and list boxes. You can use the Visual C# integrated development environment (IDE) to browse the events that a control publishes and select the ones that you want to handle. The IDE provides an easy way to automatically add an empty event handler method and the code to subscribe to the event. For more information, see How to subscribe to and unsubscribe from events.\n\nEvents have the following properties:\n• The publisher determines when an event is raised; the subscribers determine what action is taken in response to the event.\n• An event can have multiple subscribers. A subscriber can handle multiple events from multiple publishers.\n• Events that have no subscribers are never raised.\n• Events are typically used to signal user actions such as button clicks or menu selections in graphical user interfaces.\n• When an event has multiple subscribers, the event handlers are invoked synchronously when an event is raised. To invoke events asynchronously, see Calling Synchronous Methods Asynchronously.\n• In the .NET class library, events are based on the EventHandler delegate and the EventArgs base class.\n\nFor more information, see:\n• How to subscribe to and unsubscribe from events\n• How to publish events that conform to .NET Guidelines\n• How to raise base class events in derived classes\n\nFor more information, see Events in the C# Language Specification. The language specification is the definitive source for C# syntax and usage."
    },
    {
        "link": "https://medium.com/@estheremeka026/events-and-delegates-in-c-a-comprehensive-guide-90edaf1c08dc",
        "document": "In the world of C# programming, Events and Delegates play a significant role. They allow you to create flexible and extensible code by enabling communication between different parts of your application. In this article, we’ll dive deep into what events and delegates are, how they work, and why they are essential in the .NET Framework.\n\nWhat Are Events and Why Do We Need Them?\n\nAn event is a notification that something has happened within your application. For example, when a user clicks a button, an event is raised to indicate that the button was clicked. Events are essential because they allow different components of your application to communicate without tightly coupling them. Imagine building an e-commerce system where you need to notify other parts of the system when a customer places an order. Events make this communication seamless.\n\nNow, let’s talk about delegates. Think of a delegate as a pipeline that connects the event raiser (like the button click) to the event handler (the code that responds to the event). Without delegates, raising an event and handling it would be impossible. Delegates act as intermediaries, ensuring that the event reaches the right place.\n\nIn the example above, we define a custom class with a event. When the button is clicked, the event handler is invoked.\n\nHere, we use the built-in class with its event to execute code at regular intervals.\n\nTo illustrate this concept, imagine an old tin can telephone with a string connecting two ends. On one side, we have a little girl talking (the event raiser), and on the other side, her dad is listening (the event handler). The string connecting them represents the delegate. When the girl talks into the tin can, her message travels across the string to her dad. Similarly, delegates facilitate the flow of events from raiser to handler.\n\nWhen the girl talks into the tin can, her dad needs to know what she’s saying. In the .NET world, we use EventArgs for this purpose. EventArgs are containers that allow us to pass data from the event raiser to the event handler. They carry relevant information about the event, such as which button was clicked or what data changed.\n\nIn the example above, we create a custom event args class ( ) to pass additional data when the temperature changes.\n\nIn summary, Events and Delegates are fundamental building blocks in C# development. They enable decoupling, extensibility and efficient communication between different parts of an application. So, next time you handle a button click or any other event, remember the little girl and her tin can telephone. It’s all about events, delegates, and the magic of communication in C#.\n\nRemember the .NET Framework relies heavily on events and delegates, making them essential tools for any C# developer."
    },
    {
        "link": "https://stackoverflow.com/questions/6644247/simple-custom-event",
        "document": "Events are pretty easy in C#, but the MSDN docs in my opinion make them pretty confusing. Normally, most documentation you see discusses making a class inherit from the base class and there's a reason for that. However, it's not the simplest way to make events, and for someone wanting something quick and easy, and in a time crunch, using the type is your ticket.\n\n1. Create your event in your class right after your declaration.\n\n2. Create your event handler class method in your class.\n\n3. Now when your class is invoked, tell it to connect the event to your new event handler. The reason the operator is used is because you are appending your particular event handler to the event. You can actually do this with multiple separate event handlers, and when an event is raised, each event handler will operate in the sequence in which you added them.\n\n4. Now, when you're ready, trigger (aka raise) the event somewhere in your class code like so:\n\nThe end result when you run this is that the console will emit \"wow this is cool\". And if you changed \"cool\" with a date or a sequence, and ran this event trigger multiple times, you'd see the result come out in a FIFO sequence like events should normally operate.\n\nIn this example, I passed 4 strings. But you could change those to any kind of acceptable type, or used more or less types, or even remove the out and pass nothing to your event handler.\n\nAnd, again, if you had multiple custom event handlers, and subscribed them all to your event with the operator, then your event trigger would have called them all in sequence.\n\nBut what if you want to identify the caller to this event in your event handler? This is useful if you want an event handler that reacts with conditions based on who's raised/triggered the event. There are a few ways to do this. Below are examples that are shown in order by how fast they operate:\n\nOption 1. (Fastest) If you already know it, then pass the name as a literal string to the event handler when you trigger it.\n\nOption 2. (Somewhat Fast) Add this into your class and call it from the calling method, and then pass that string to the event handler when you trigger it:\n\nOption 3. (Least Fast But Still Fast) In your event handler when you trigger it, get the calling method name string with this:\n\nYou may have a scenario where your custom event has multiple event handlers, but you want to remove one special one out of the list of event handlers. To do so, use the operator like so:\n\nA word of minor caution with this, however. If you do this and that event no longer has any event handlers, and you trigger that event again, it will throw an exception. (Exceptions, of course, you can trap with try/catch blocks.)\n\nOkay, let's say you're through with events and you don't want to process any more. Just set it to null like so:\n\nThe same caution for Unsubscribing events is here, as well. If your custom event handler no longer has any events, and you trigger it again, your program will throw an exception."
    },
    {
        "link": "https://csharpindepth.com/articles/Events",
        "document": "People often find it difficult to see the difference between events and delegates. C# doesn't help matters by allowing you to declare field-like events which are automatically backed by a delegate variable of the same name. This article aims to clarify the matter for you. Another source of confusion is the overloading of the term \"delegate\". Sometimes it is used to mean a delegate type, and at other times it can be used to mean an instance of a delegate type. I'll use \"delegate type\" and \"delegate instance\" to distinguish between them, and \"delegate\" when talking about the whole topic in a general sense.\n\nIn some ways, you can think of a delegate type as being a bit like an interface with a single method. It specifies the signature of a method, and when you have a delegate instance, you can make a call to it as if it were a method with the same signature. Delegates provide other features, but the ability to make calls with a particular signature is the reason for the existence of the delegate concept. Delegates hold a reference to a method, and (for instance methods) a reference to the target object the method should be called on.\n\nDelegates types are declared with the keyword. They can appear either on their own or nested within a class, as shown below.\n\nThis code declares two delegate types. The first is which has a single parameter of type and returns a . The second is which has two parameters, and doesn't return anything (because the return type is specified as ).\n\nNote that the keyword doesn't always mean that a delegate type is being declared. The same keyword is used when creating instances of the delegate type using anonymous methods.\n\nThe types declared here derive from , which in turn derives from . In practice, you'll only see delegate types deriving from . The difference between and is largely historical; in betas of .NET 1.0 the difference was significant (and annoying) - Microsoft considered merging the two types together, but decided it was too late in the release cycle to make such a major change. You can pretty much pretend that they're only one type.\n\nAny delegate type you create has the members inherited from its parent types, one constructor with parameters of and and three extra methods: , and . We'll come back to the constructor in a minute. The methods can't be inherited from anything, because the signatures vary according to the signature the delegate is declared with. Using the sample code above, the first delegate has the following methods:\n\nAs you can see, the return type of and matches that of the declaration signature, as are the parameters of and the first parameters of . We'll see the purpose of in the next section, and cover and in the section on advanced usage. It's a bit premature to talk about calling methods when we don't know how to create an instance, however. We'll cover that (and more) in the next section.\n\nNow we know how a delegate type is declared and what it contains, let's look at how to create an instance of such a type, and what we can do with it.\n\nNote: this article doesn't cover the features of C# 2.0 and 3.0 for creating delegate instances, nor generic delegate variance introduced in C# 4.0. My article on closures talks about the features of C# 2.0 and 3.0 - alternatively, read chapters 5, 9 and 13 of C# in Depth for a lot more detail. By concentrating on the explicit manner of creating instances in C# 1.0/1.1, I believe it will be easier to understand what's going on under the hood. When you understand the basics, it's clearly worth knowing the features these later versions provide - but if you try to use them without having a firm grasp on the basics, you may well get confused.\n\nAs mentioned earlier, the key points of data in any particular delegate instance are the method the delegate refers to, and a reference to call the method on (the target). For static methods, no target is required. The CLR itself supports other slightly different forms of delegate, where either the first argument passed to a static method is held within the delegate, or the target of an instance method is provided as an argument when the method is called. See the documentation for for more information on this if you're interested, but don't worry too much about it.\n\nSo, now that we know the two pieces of data required to create an instance (along with the type itself, of course), how do we tell the compiler what they are? We use what the C# specification calls a delegate-creation-expression which is of the form . The expression must either be another delegate of the same type (or a compatible delegate type in C# 2.0) or a method group - the name of a method and optionally a target, specified as if you were calling the method, but without the arguments or brackets. Creating copies of a delegate is fairly rare, so we will concentrate on the more common form. A few examples are listed below:\n\nThe constructor we mentioned earlier has two parameters - an and an . The is a reference to the target (or for static methods) and the is a pointer to the method itself.\n\nOne point to note is that delegate instances can refer to methods and targets which wouldn't normally be visible at the point the call is actually made. For instance, a private method can be used to create a delegate instance, and then the delegate instance can be returned from a public member. Alternatively, the target of an instance may be an object which the eventual caller knows nothing about. However, both the target and the method must be accessible to the creating code. In other words, if (and only if) you can call a particular method on a particular object, you can use that method and target for delegate creation. Access rights are effectively ignored at call time. Speaking of which...\n\nDelegate instances are called just as if they were the methods themselves. For instance, to call the delegate referred to by variable above, we could write:\n\nThe method referred to by the delegate instance is called on the target object (if there is one), and the result is returned. Producing a complete program to demonstrate this without including a lot of seemingly irrelevant code is tricky. However, here's a program which gives one example of a static method and one of an instance method. could be written as just in the same way that (within an instance method) you could write instead of - I've included the class name just to make it clear how you would reference methods from other classes.\n\nThe C# syntax is just a short-hand for calling the method provided by each delegate type. Delegates can also be run asynchronously if they provide / methods. These are explained later.\n\nDelegates can be combined such that when you call the delegate, a whole list of methods are called - potentially with different targets. When I said before that a delegate contained a target and a method, that was a slight simplification. That's what a delegate instance representing one method contains. For the sake of clarity, I'll refer to such delegate instances as simple delegates. The alternative is a delegate instance which is effectively a list of simple delegates, all of the same type (i.e. having the same signature). I'll call these combined delegates. Combined delegates can themselves be combined together, effectively creating one big list of simple delegates in the obvious fashion.\n\nIt's important to understand that delegate instances are always immutable. Anything which combines them together (or takes one away from the other) creates a new delegate instance to represent the new list of targets/methods to call. This is just like strings: if you call for instance, it doesn't actually change the string you call it on - it just returns a new string with the appropriate padding.\n\nCombining two delegate instances is usually done using the addition operator, as if the delegate instances were strings or numbers. Subtracting one from another is usually done with the subtraction operator. Note that when you subtract one combined delegate from another, the subtraction works in terms of lists. If the list to subtract is not found in the original list, the result is just the original list. Otherwise, the last occurrence of the list is removed. This is best shown with some examples. Instead of actual code, the following uses lists of simple delegates , etc. For instance, is a combined delegate which, when executed, would call then then . An empty list is represented by rather than an actual delegate instance.\n\nDelegate instances can also be combined with the static method, and one can be subtracted from another with the static method. The C# compiler converts the addition and subtraction operators into calls to these methods. Because they are static methods, they work easily with references.\n\nThe addition and subtraction operators always work as part of assignment: is exactly equivalent to , and likewise for subtraction. Again, the original delegate instance remains unchanged; the value of just changes to be a reference to the appropriate new combined delegate.\n\nNote that because extra delegates are both added to and removed from the end of the list, is always a no-op.\n\nIf a delegate type is declared to return a value (i.e. it's not declared with a return type) and a combined delegate instance is called, the value returned from that call is the one returned by the last simple delegate in the list.\n\nFirst things first: events aren't delegate instances. Let's try that again.\n\nIt's unfortunate in some ways that C# lets you use them in the same way in certain situations, but it's very important that you understand the difference.\n\nI find the easiest way to understand events is to think of them a bit like properties. While properties look like they're fields, they're definitely not - and you can write properties which don't use fields at all. Similarly, while events look like delegate instances in terms of the way you express the add and remove operations, they're not.\n\nEvents are pairs of methods, appropriately decorated in IL to tie them together and let languages know that the methods represent events. The methods correspond to add and remove operations, each of which take a delegate instance parameter of the same type (the type of the event). What you do with those operations is pretty much up to you, but the typical use is to add or remove the delegate from a list of handlers for the event. When the event is triggered (whatever that trigger might be - a button click, a timeout, an unhandled exception) the handlers are called in turn. Note that in C#, the calling of the event handlers is not part of the event itself. (CIL defines an association with a method, and indeed \"other\" methods, but these are not used in C#.)\n\nThe add and remove methods are called in C# using and respectively, where may be qualified with a reference (e.g. ) or a type name (e.g. ). Static events are relatively rare.\n\nEvents themselves can be declared in two ways. The first is with explicit add and remove methods, declared in a very similar way to properties, but with the keyword. Here's an example of an event for the delegate type. Note how it doesn't actually do anything with the delegate instances which are passed to the add and remove methods - it just prints out which operation has been called. Note that the remove operation is called even though we've told it to remove .\n\nAlthough it would be very rare to ignore the value in this way, there are times when you don't want to back an event with a simple delegate variable. For instance, in situations where there are lots of events but only a few are likely to be subscribed to, you could have a map from some key describing the event to the delegate currently handling it. This is what Windows Forms does - it means that you can have a huge number of events without wasting a lot of memory with variables which will usually just have values.\n\nC# provides a simple way of declaring both a delegate variable and an event at the same time. This is called a field-like event, and is declared very simply - it's the same as the \"longhand\" event declaration, but without the \"body\" part:\n\nThis creates a delegate variable and an event, both with the same type. The access to the event is determined by the event declaration (so the example above creates a public event, for instance) but the delegate variable is always private. The implicit body of the event is the obvious one to add/remove delegate instances to the delegate variable, but the changes are made within a lock. For C# 1.1, the event is equivalent to:\n\nThat's for an instance member. For an event declared as static, the variable is also static and a lock is taken out on where is the name of the class declaring the event. In C# 2.0 there is little guarantee about what is used for locking - only that a single object associated with the instance is used for locking with instance events, and a single object associated with the class is used for locking static events. (Note that this only holds for class events, not struct events - there are issues in terms of locking with struct events; in practice I don't remember ever seeing a struct with any events.) None of this is actually as useful as you might think - see the threading section for more details.\n\nSo, what happens when you refer to in code? Well, within the text of type itself (including nested types) the compiler generates code which refers to the delegate variable ( in my sample above). In all other contexts, the compiler generates code which refers to the event.\n\nNow we know what they are, what's the point of having both delegates and events? The answer is encapsulation. Suppose events didn't exist as a concept in C#/.NET. How would another class subscribe to an event? Three options:\n\nOption 1 is clearly horrible, for all the normal reasons we abhor public variables. Option 2 is slightly better, but allows subscribers to effectively override each other - it would be all too easy to write which would replace any existing event handlers rather than adding a new one. In addition, you still need to write the properties.\n\nOption 3 is basically what events give you, but with a guaranteed convention (generated by the compiler and backed by extra flags in the IL) and a \"free\" implementation if you're happy with the semantics that field-like events give you. Subscribing to and unsubscribing from events is encapsulated without allowing arbitrary access to the list of event handlers, and languages can make things simpler by providing syntax for both declaration and subscription.\n\nEarlier we touched on field-like events locking during the add/remove operations. This is to provide a certain amount of thread safety. Unfortunately, it's not terribly useful. Firstly, even with 2.0, the spec allows for the lock to be the reference to object, or the type itself for static events. That goes against the principle of locking on privately held references to avoid accidental deadlocks.\n\nIronically, the second problem is the exact reverse of the first - because in C# 2.0 you can't guarantee which lock is going to be used, you can't use it yourself when raising an event to ensure that you see the most recent value in the thread doing the raising. You can lock on something else or call one of the memory barrier methods, but it leaves something of a nasty taste in the mouth.\n\nIf you want to be truly thread-safe, such that when you raise an event you always use the most recent value of the delegate variable, along with making sure that the add/remove operations don't interfere with each other, you need to write the body of the add/remove operations yourself. Here's an example:\n\nYou could use a single lock for all your events, or even for other things as well - it depends on your situation. Note that you need to assign the current value to a local variable inside the lock (to get the most recent value) and then test it for nullity and execute it outside the lock: holding the lock whilst raising the event is a very bad idea, as you could easily deadlock. (Event handlers may well need to wait for another thread to do something, and if that other thread were to call the add or remove operation on your event, you'd get deadlock.)\n\nThis all works because once has been assigned the value of , the value of won't change even if does. So if all the handlers are unsubscribed from the event, will become but will still have whatever value it had when it was assigned. In fact, as delegate instances are immutable, whatever handlers were subscribed when the line was executed will be called, even if others have subscribed between then and the line.\n\nNow, it's important to consider whether or not you even need thread safety. Are event handlers going to be added or removed from other threads? Do you need to raise the event from another thread? If you're in complete control of your application, the answer may very well be \"no\". (If you're writing a class library, it's more likely that being thread-safe is important.) If you don't need thread safety, you may want to implement the add/remove operations to get round the problem of the externally visible lock that C# uses (or may use in the case of 2.0). At that point, the operations become pretty trivial. Here's the equivalent of the earlier code, but without thread safety.\n\nThe check for nullity is due to delegate variables being when there aren't any delegate instances to call. One way to make things simpler is to use a no-op delegate instance as the \"default\" one, which is never removed. At that point, you can just obtain the value of the delegate variable (inside a lock if you're being thread-safe) and then execute the delegate instance. If there are no \"real\" delegate targets to call, the no-op target will execute and that's all that will happen.\n\nEarlier we saw how a call to is actually a short-hand for . Delegates types may also allow asynchronous behaviour using the / pair. These are optional as far as the CLI specification is concerned, but C# delegate types always provide them. They follow the same model for asynchronous execution as the rest of .NET, allowing a callback handler to be provided, along with an object to store state information. The delegates are executed on threads created by the system thread-pool.\n\nThe first example below operates without a callback, simply using and from the same thread. This is occasionally useful when a single thread is used for an operation which is synchronous in general, but which contains elements which may be performed in parallel. The methods involved are all static for the sake of simplicity, but delegate instances with specific target objects can also be used, and often are. returns whatever value was returned by the delegate call. If the call threw an exception, the same exception is thrown by .\n\nThe calls to are just to demonstrate that the execution really does occur in parallel. The sleep in is as large as it is to force the system thread-pool to run the tasks on two different threads - the thread-pool serializes requests which don't take long in order to avoid creating more threads than it needs to. By sleeping for a long time, we're simulating a long-running request. Here's the output from a sample run:\n\nThe calls to block until the delegate has completed in much the same way as calls to block until the threads involved have terminated. The values returned by the calls to allows access to the state passed as the last parameter to , but this isn't typically used in the style of asynchronous invocation shown above.\n\nThe code above is fairly simple, but often not as powerful as a model which uses callbacks after the delegate has completed. Typically, the callback will call to obtain the result of the delegate. Although it is still a theoretically blocking call, it will never actually block because the callback only executes when the delegate has completed anyway. The callback may well use the state provided to as extra context information. The sample code below uses the same counting and parsing delegates as the previous example, but with a callback displaying the results. The state is used to determine how to format each result, so a single callback can be used for both asynchronous calls. Note the cast from to : the value provided to the callback is always an instance of , and this can be used to obtain the original delegate instance, so that the callback can call . It is somewhat anomalous that lives in the namespace when all the other classes involved are in either or , but such is life.\n\nThis time almost all the work is done on thread-pool threads. The main thread just kicks off the asynchronous tasks and then sleeps for long enough to let all the work finish. (Thread-pool threads are background threads - without the extra call, the application would terminate before the delegate calls finished executing.) Some sample output is below - notice how this time, because there is no guaranteed ordering to the calls to , the parser result is displayed before the counter result. In the previous example, the parser almost certainly completed before the counter did, but the main thread waited to obtain the result of the counter first.\n\nNote that you must call when you use asynchronous execution in order to guarantee not to leak memory or handles. Some implementations may not leak, but you shouldn't rely on this. See my thread-pool article for some sample code to allow \"fire and forget\" style asynchronous behaviour if this is inconvenient.\n\nDelegates provide a simple way of representing a method call, potentially with a target object, as a piece of data which can be passed around. They are the basis for events, which are effectively conventions for adding and removing handler code to be invoked at appropriate times."
    }
]