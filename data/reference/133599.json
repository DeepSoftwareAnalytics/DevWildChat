[
    {
        "link": "https://vuejs.org/guide/essentials/lifecycle",
        "document": "Each Vue component instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called lifecycle hooks, giving users the opportunity to add their own code at specific stages.\n\nFor example, the hook can be used to run code after the component has finished the initial rendering and created the DOM nodes:\n\nThere are also other hooks which will be called at different stages of the instance's lifecycle, with the most commonly used being , , and . , , and .\n\nAll lifecycle hooks are called with their context pointing to the current active instance invoking it. Note this means you should avoid using arrow functions when declaring lifecycle hooks, as you won't be able to access the component instance via if you do so.\n\nWhen calling , Vue automatically associates the registered callback function with the current active component instance. This requires these hooks to be registered synchronously during component setup. For example, do not do this: Do note this doesn't mean that the call must be placed lexically inside or . can be called in an external function as long as the call stack is synchronous and originates from within .\n\nBelow is a diagram for the instance lifecycle. You don't need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.\n\nConsult the Lifecycle Hooks API referenceLifecycle Hooks API reference for details on all lifecycle hooks and their respective use cases."
    },
    {
        "link": "https://vuejs.org/guide/essentials/component-basics",
        "document": "Components allow us to split the UI into independent and reusable pieces, and think about each piece in isolation. It's common for an app to be organized into a tree of nested components:\n\nThis is very similar to how we nest native HTML elements, but Vue implements its own component model that allows us to encapsulate custom content and logic in each component. Vue also plays nicely with native Web Components. If you are curious about the relationship between Vue Components and native Web Components, read more here.\n\nWhen using a build step, we typically define each Vue component in a dedicated file using the extension - known as a Single-File Component (SFC for short):\n\nWhen not using a build step, a Vue component can be defined as a plain JavaScript object containing Vue-specific options:\n\nThe template is inlined as a JavaScript string here, which Vue will compile on the fly. You can also use an ID selector pointing to an element (usually native elements) - Vue will use its content as the template source.\n\nThe example above defines a single component and exports it as the default export of a file, but you can use named exports to export multiple components from the same file.\n\nTo use a child component, we need to import it in the parent component. Assuming we placed our counter component inside a file called , the component will be exposed as the file's default export:\n\nIt's also possible to globally register a component, making it available to all components in a given app without having to import it. The pros and cons of global vs. local registration is discussed in the dedicated Component Registration section.\n\nComponents can be reused as many times as you want:\n\nNotice that when clicking on the buttons, each one maintains its own, separate . That's because each time you use a component, a new instance of it is created.\n\nIn SFCs, it's recommended to use tag names for child components to differentiate from native HTML elements. Although native HTML tag names are case-insensitive, Vue SFC is a compiled format so we are able to use case-sensitive tag names in it. We are also able to use to close a tag.\n\nIf you are authoring your templates directly in a DOM (e.g. as the content of a native element), the template will be subject to the browser's native HTML parsing behavior. In such cases, you will need to use and explicit closing tags for components:\n\nSee in-DOM template parsing caveats for more details.\n\nIf we are building a blog, we will likely need a component representing a blog post. We want all the blog posts to share the same visual layout, but with different content. Such a component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.\n\nProps are custom attributes you can register on a component. To pass a title to our blog post component, we must declare it in the list of props this component accepts, using the option macro:\n\nA component can have as many props as you like and, by default, any value can be passed to any prop.\n\nOnce a prop is registered, you can pass data to it as a custom attribute, like this:\n\nIn a typical app, however, you'll likely have an array of posts in your parent component:\n\nThen want to render a component for each one, using :\n\nNotice how syntax ( ) is used to pass dynamic prop values. This is especially useful when you don't know the exact content you're going to render ahead of time.\n\nThat's all you need to know about props for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Props.\n\nAs we develop our component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page at its default size.\n\nIn the parent, we can support this feature by adding a data propertyref:\n\nWhich can be used in the template to control the font size of all blog posts:\n\nNow let's add a button to the component's template:\n\nThe button doesn't do anything yet - we want clicking the button to communicate to the parent that it should enlarge the text of all posts. To solve this problem, components provide a custom events system. The parent can choose to listen to any event on the child component instance with or , just as we would with a native DOM event:\n\nThen the child component can emit an event on itself by calling the built-in method, passing the name of the event:\n\nThanks to the listener, the parent will receive the event and update the value of .\n\nWe can optionally declare emitted events using the option macro:\n\nThis documents all the events that a component emits and optionally validates them. It also allows Vue to avoid implicitly applying them as native listeners to the child component's root element.\n\nThat's all you need to know about custom component events for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Custom Events.\n\nJust like with HTML elements, it's often useful to be able to pass content to a component, like this:\n\nWhich might render something like:\n\nThis can be achieved using Vue's custom element:\n\nAs you'll see above, we use the as a placeholder where we want the content to go – and that's it. We're done!\n\nThat's all you need to know about slots for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Slots.\n\nSometimes, it's useful to dynamically switch between components, like in a tabbed interface:\n\nThe above is made possible by Vue's element with the special attribute:\n\nIn the example above, the value passed to can contain either:\n• the name string of a registered component, OR\n\nYou can also use the attribute to create regular HTML elements.\n\nWhen switching between multiple components with , a component will be unmounted when it is switched away from. We can force the inactive components to stay \"alive\" with the built-in component.\n\nIf you are writing your Vue templates directly in the DOM, Vue will have to retrieve the template string from the DOM. This leads to some caveats due to browsers' native HTML parsing behavior.\n\nHTML tags and attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you’re using in-DOM templates, PascalCase component names and camelCased prop names or event names all need to use their kebab-cased (hyphen-delimited) equivalents:\n\nWe have been using self-closing tags for components in previous code samples:\n\nThis is because Vue's template parser respects as an indication to end any tag, regardless of its type.\n\nIn in-DOM templates, however, we must always include explicit closing tags:\n\nThis is because the HTML spec only allows a few specific elements to omit closing tags, the most common being and . For all other elements, if you omit the closing tag, the native HTML parser will think you never terminated the opening tag. For example, the following snippet:\n\nwill be parsed as:\n\nSome HTML elements, such as , , and have restrictions on what elements can appear inside them, and some elements such as , , and can only appear inside certain other elements.\n\nThis will lead to issues when using components with elements that have such restrictions. For example:\n\nThe custom component will be hoisted out as invalid content, causing errors in the eventual rendered output. We can use the special attribute as a workaround:\n\nThat's all you need to know about in-DOM template parsing caveats for now - and actually, the end of Vue's Essentials. Congratulations! There's still more to learn, but first, we recommend taking a break to play with Vue yourself - build something fun, or check out some of the Examples if you haven't already.\n\nOnce you feel comfortable with the knowledge you've just digested, move on with the guide to learn more about components in depth."
    },
    {
        "link": "https://vuejs.org/guide/components/props.html",
        "document": "Vue components require explicit props declaration so that Vue knows what external props passed to the component should be treated as fallthrough attributes (which will be discussed in its dedicated section).\n\nIn SFCs using , props can be declared using the macro: In non- components, props are declared using the option: // setup() receives props as the first argument. Notice the argument passed to is the same as the value provided to the options: the same props options API is shared between the two declaration styles.\n\nIn addition to declaring props using an array of strings, we can also use the object syntax:\n\nFor each property in the object declaration syntax, the key is the name of the prop, while the value should be the constructor function of the expected type.\n\nThis not only documents your component, but will also warn other developers using your component in the browser console if they pass the wrong type. We will discuss more details about prop validation further down this page.\n\nVue's reactivity system tracks state usage based on property access. E.g. when you access in a computed getter or a watcher, the prop gets tracked as a dependency. So, given the following code: // runs only once before 3.5 // re-runs when the \"foo\" prop changes in 3.5+ In version 3.4 and below, is an actual constant and will never change. In version 3.5 and above, Vue's compiler automatically prepends when code in the same block accesses variables destructured from . Therefore the code above becomes equivalent to the following: // `foo` transformed to `props.foo` by the compiler In addition, you can use JavaScript's native default value syntax to declare default values for the props. This is particularly useful when using the type-based props declaration: If you prefer to have more visual distinction between destructured props and normal variables in your IDE, Vue's VSCode extension provides a setting to enable inlay-hints for destructured props. When we pass a destructured prop into a function, e.g.: This will not work as expected because it is equivalent to - we are passing a value instead of a reactive data source to . In fact, Vue's compiler will catch such cases and throw a warning. Similar to how we can watch a normal prop with , we can watch a destructured prop also by wrapping it in a getter: In addition, this is the recommended approach when we need to pass a destructured prop into an external function while retaining reactivity: The external function can call the getter (or normalize it with toValue) when it needs to track changes of the provided prop, e.g. in a computed or watcher getter.\n\nWe declare long prop names using camelCase because this avoids having to use quotes when using them as property keys, and allows us to reference them directly in template expressions because they are valid JavaScript identifiers:\n\nTechnically, you can also use camelCase when passing props to a child component (except in in-DOM templates). However, the convention is using kebab-case in all cases to align with HTML attributes:\n\nWe use PascalCase for component tags when possible because it improves template readability by differentiating Vue components from native elements. However, there isn't as much practical benefit in using camelCase when passing props, so we choose to follow each language's conventions.\n\nSo far, you've seen props passed as static values, like in:\n\nYou've also seen props assigned dynamically with or its shortcut, such as in:\n\nIn the two examples above, we happen to pass string values, but any type of value can be passed to a prop.\n\nIf you want to pass all the properties of an object as props, you can use without an argument ( instead of ). For example, given a object:\n\nWill be equivalent to:\n\nAll props form a one-way-down binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.\n\nIn addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console:\n\nThere are usually two cases where it's tempting to mutate a prop:\n• None The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards. In this case, it's best to define a local data property that uses the prop as its initial value: // counter only uses props.initialCounter as the initial value; // it is disconnected from future prop updates. // counter only uses this.initialCounter as the initial value; // it is disconnected from future prop updates.\n• None The prop is passed in as a raw value that needs to be transformed. In this case, it's best to define a computed property using the prop's value: // computed property that auto-updates when the prop changes // computed property that auto-updates when the prop changes\n\nWhen objects and arrays are passed as props, while the child component cannot mutate the prop binding, it will be able to mutate the object or array's nested properties. This is because in JavaScript objects and arrays are passed by reference, and it is unreasonably expensive for Vue to prevent such mutations.\n\nThe main drawback of such mutations is that it allows the child component to affect parent state in a way that isn't obvious to the parent component, potentially making it more difficult to reason about the data flow in the future. As a best practice, you should avoid such mutations unless the parent and child are tightly coupled by design. In most cases, the child should emit an event to let the parent perform the mutation.\n\nComponents can specify requirements for their props, such as the types you've already seen. If a requirement is not met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that is intended to be used by others.\n\nTo specify prop validations, you can provide an object with validation requirements to the macro option, instead of an array of strings. For example:\n• None All props are optional by default, unless is specified.\n• None An absent optional prop other than will have value.\n• None The absent props will be cast to . You can change this by setting a for it — i.e.: to behave as a non-Boolean prop.\n• None If a value is specified, it will be used if the resolved prop value is - this includes both when the prop is absent, or an explicit value is passed.\n\nWhen prop validation fails, Vue will produce a console warning (if using the development build).\n\nThe can be one of the following native constructors:\n\nIn addition, can also be a custom class or constructor function and the assertion will be made with an check. For example, given the following class:\n\nYou could use it as a prop's type:\n\nVue will use to validate whether the value of the prop is indeed an instance of the class.\n\nIf the type is required but nullable, you can use the array syntax that includes :\n\nNote that if is just without using the array syntax, it will allow any type.\n\nProps with type have special casting rules to mimic the behavior of native boolean attributes. Given a with the following declaration:\n\nThe component can be used like this:\n\nWhen a prop is declared to allow multiple types, the casting rules for will also be applied. However, there is an edge when both and are allowed - the Boolean casting rule only applies if Boolean appears before String:"
    },
    {
        "link": "https://vuejs.org/api/options-lifecycle.html",
        "document": "Called when the instance is initialized.\n• None Called immediately when the instance is initialized and props are resolved. Then the props will be defined as reactive properties and the state such as or will be set up. Note that the hook of Composition API is called before any Options API hooks, even .\n\nCalled after the instance has finished processing all state-related options.\n• None When this hook is called, the following have been set up: reactive data, computed properties, methods, and watchers. However, the mounting phase has not been started, and the property will not be available yet.\n\nCalled right before the component is to be mounted.\n• None When this hook is called, the component has finished setting up its reactive state, but no DOM nodes have been created yet. It is about to execute its DOM render effect for the first time. This hook is not called during server-side rendering.\n\nCalled after the component has been mounted.\n• None\n• None All of its synchronous child components have been mounted (does not include async components or components inside trees).\n• None Its own DOM tree has been created and inserted into the parent container. Note it only guarantees that the component's DOM tree is in-document if the application's root container is also in-document. This hook is typically used for performing side effects that need access to the component's rendered DOM, or for limiting DOM-related code to the client in a server-rendered application. This hook is not called during server-side rendering.\n\nCalled right before the component is about to update its DOM tree due to a reactive state change.\n• None This hook can be used to access the DOM state before Vue updates the DOM. It is also safe to modify component state inside this hook. This hook is not called during server-side rendering.\n\nCalled after the component has updated its DOM tree due to a reactive state change.\n• None A parent component's updated hook is called after that of its child components. This hook is called after any DOM update of the component, which can be caused by different state changes. If you need to access the updated DOM after a specific state change, use nextTick() instead. This hook is not called during server-side rendering. Do not mutate component state in the updated hook - this will likely lead to an infinite update loop!\n\nCalled right before a component instance is to be unmounted.\n• None When this hook is called, the component instance is still fully functional. This hook is not called during server-side rendering.\n\nCalled after the component has been unmounted.\n• None\n• None All of its child components have been unmounted.\n• None All of its associated reactive effects (render effect and computed / watchers created during ) have been stopped. Use this hook to clean up manually created side effects such as timers, DOM event listeners or server connections. This hook is not called during server-side rendering.\n\nCalled when an error propagating from a descendant component has been captured.\n• None Errors can be captured from the following sources: The hook receives three arguments: the error, the component instance that triggered the error, and an information string specifying the error source type. In production, the 3rd argument ( ) will be a shortened code instead of the full information string. You can find the code to string mapping in the Production Error Code Reference. You can modify component state in to display an error state to the user. However, it is important that the error state should not render the original content that caused the error; otherwise the component will be thrown into an infinite render loop. The hook can return to stop the error from propagating further. See error propagation details below.\n• None By default, all errors are still sent to the application-level if it is defined, so that these errors can still be reported to an analytics service in a single place.\n• None If multiple hooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error, in the order of bottom to top. This is similar to the bubbling mechanism of native DOM events.\n• None If the hook itself throws an error, both this error and the original captured error are sent to .\n• None An hook can return to prevent the error from propagating further. This is essentially saying \"this error has been handled and should be ignored.\" It will prevent any additional hooks or from being invoked for this error.\n• None In components with async function (with top-level ) Vue will always try to render component template, even if throwed error. This will likely cause more errors because during render component's template might try to access non-existing properties of failed context. When capturing errors in such components, be ready to handle errors from both failed async (they will always come first) and failed render process.\n• None Replacing errored child component in parent component deep inside will cause hydration mismatches in SSR. Instead, try to separate logic that can possibly throw from child into separate function and execute it in the parent component's , where you can safely the execution process and make replacement if needed before rendering the actual child component.\n\nCalled when a reactive dependency has been tracked by the component's render effect.\n\nThis hook is development-mode-only and not called during server-side rendering.\n• None See also Reactivity in Depth\n\nCalled when a reactive dependency triggers the component's render effect to be re-run.\n\nThis hook is development-mode-only and not called during server-side rendering.\n• None See also Reactivity in Depth\n\nCalled after the component instance is inserted into the DOM as part of a tree cached by .\n\nThis hook is not called during server-side rendering.\n• None See also Guide - Lifecycle of Cached Instance\n\nCalled after the component instance is removed from the DOM as part of a tree cached by .\n\nThis hook is not called during server-side rendering.\n• None See also Guide - Lifecycle of Cached Instance\n\nAsync function to be resolved before the component instance is to be rendered on the server.\n• None If the hook returns a Promise, the server renderer will wait until the Promise is resolved before rendering the component. This hook is only called during server-side rendering can be used to perform server-only data fetching.\n• None // component is rendered as part of the initial request // pre-fetch data on server as it is faster than on the client // if data is null on mount, it means the component // is dynamically rendered on the client. Perform a"
    },
    {
        "link": "https://stackoverflow.com/questions/66978035/how-to-get-the-props-value-and-use-in-lifehooks-cycle-of-vue-js",
        "document": "I'm searching a way to get the value through some lifehooks like or and trying to save the value with my with some string. But I can't get it.\n\nThough I tried on the input element with the value and some string and I was able to get it, but it seems like I can't access it without , as I researched and can't be together.\n\nThe purpose is to get the (with from props and some string) of a tags."
    },
    {
        "link": "https://medium.com/walmartglobaltech/lazy-loading-using-intersection-observer-6764ab32e776",
        "document": "What is Lazy Loading?\n\nLazy loading is a technique for waiting to load certain parts of a webpage like images until they are needed. Instead of loading everything all at once, known as “eager” loading, the browser does not request certain resources until the user interacts in such a way that the resources are needed. When implemented properly, lazy loading can speed up page load times. Advantages of Lazy Loading:\n\n1. Speeds up page load time: Since we are only requesting for content we require on a webpage on first load, we are reducing time taken to load the page. Which results in better performance like better SEO, higher conversion rate, improved user experience.\n\n2. Saving in bandwidth: We are not loading “below the fold” images, so we are saving bandwidth required to deliver these images and time required to request and render these images. What is Intersection Observer?\n\nThe Intersection Observer API lets code register a callback function that is executed whenever a particular element enters or exits an intersection with another element (or the viewport), or when the intersection between two elements changes by a specified amount.\n\nThe Intersection Observer API allows you to configure a callback that is called when either of these circumstances occur:\n• A target element intersects either the device’s viewport or a specified element. That specified element is called the root element or root for the purposes of the Intersection Observer API.\n• The first time the observer is initially asked to watch a target element.\n\nroot: Element that is taken as reference for intersection with the target element. Defaults to browser viewport when not specified or provided as null.\n\nrootMargin: Margin surrounding the root element. Can be given as CSS e.g. “ (top, right, bottom, left).\n\nthreshold: Either a single number or an array of numbers which indicate at what percentage of the target’s visibility the observer’s callback should be executed\n\nLet’s take the observer we created above and apply it to images\n\nOne of the most interesting property of Intersection observer is isIntersecting.\n\nIt can be used to find out whether the element being observed is entering the frame or leaving it. Based on this boolean value we can code our callback function to follow instructions.\n\nisIntersecting : false — ->true Element is entering the frame.\n\nisIntersecting : true — ->false Element is exiting the frame.\n\nAs you can see, the images should come without tags: once a browser sees attribute, it will start downloading that image right away that is opposite to our intentions. Hence we should not put that attribute on our images in HTML, and instead, we might rely on some attribute like here.\n\nLet’s write a code block to load the images as you scroll and when they intersect with the viewport. In this case our code will look something like:\n\nNote. Instead of we could also call : it completely disconnects our and would not observe images anymore. This is useful if the only thing you care about is the first ever hit for your Observer.\n\nWe were able to note significant gains on loading itemstack from search page:\n\n1. Observed ~200KB reduction in initial HTML size.\n\n2. Reduction of time taken to download initial content by ~250–300ms\n\n3.Improvement in 75P LCP was also observed.\n\nLazy loading with Intersection Observer has several advantages in terms of metrics: \n\n1. Improved page load performance: Lazy loading allows you to load only the necessary content or images when they become visible on the screen. This reduces the initial load time of the page, resulting in faster performance and improved user experience. It also helps reduce initial HTML size.\n\n2. Reduced data usage: By loading content only when it is needed, lazy loading can significantly reduce data consumption. This is particularly beneficial for users with limited data plans or slower internet connections.\n\n3. Increased conversion rates: Faster loading times and improved user experience can lead to higher conversion rates.\n\n4. Lower bounce rates: Lazy loading can help reduce bounce rates, which is the percentage of users who leave a website after viewing only a single page. When users experience a faster loading time and can immediately see the content they are interested in, they are less likely to leave the site without exploring further.\n\n5. Improved SEO performance: Lazy loading can also benefit SEO (Search Engine Optimization) efforts. Search engines prioritize websites that provide a good user experience, including fast loading times. By implementing lazy loading, you can improve your website’s loading speed, which can positively impact your search engine rankings and organic traffic.\n\nWhile lazy loading with Intersection Observer provides many benefits, there are also a few drawbacks to consider: \n\n1. Compatibility: One of the main drawbacks is that Intersection Observer is not supported in all browsers. It is a relatively new API and older browsers may not have built-in support for it.\n\n2. Performance impact: While lazy loading can improve initial page load performance by deferring the loading of off-screen content, it can also have a negative impact on subsequent interactions. When the user scrolls or interacts with the page, there may be a delay as the unloaded content is fetched and rendered. This delay can negatively affect user experience, especially if there is a large amount of content to load. \n\n3. Increased complexity: Implementing lazy loading with Intersection Observer requires additional code and logic compared to simply loading all content upfront. This can make the codebase more complex and harder to maintain. Additionally, if not implemented properly, it can lead to issues like content not loading when it should or unnecessary content loading when it shouldn’t. \n\n4. SEO considerations: Lazy loading can have implications for search engine optimization (SEO). If search engine crawlers are unable to load and index lazy loaded content, it may impact the visibility and ranking of that content in search engine results. Considerations should be made to ensure that important content is accessible and crawlable by search engines.\n\n5. Accessibility concerns: Lazy loading can also present accessibility challenges. Users with disabilities who rely on assistive technologies may have difficulty accessing and interacting with lazy loaded content if it is not properly implemented and signaled to assistive technologies.\n\nOverall, while lazy loading with Intersection Observer can improve performance and user experience, it is important to carefully consider these drawbacks and address them appropriately in order to avoid any negative impact on your website or application."
    },
    {
        "link": "https://blog.logrocket.com/lazy-loading-using-the-intersection-observer-api",
        "document": "Lazy loading is a technique that allows us to delay loading nonessential content in our application until after the initial page load. By loading only the most essential content at first and loading the remaining content when it is needed by the user, we can reduce the bundle size of our application, saving valuable seconds when a user first deploys our application.\n\nThere are many different ways to add lazy loading in modern applications, but one of the most frequently used is infinite scroll. The content of the page is already rendered, and more content is loaded as the user scrolls down the page.\n\nWe can also utilize lazy loading through a technique called code splitting. Often used in React applications, it helps us to reduce our bundle size by splitting the code of our application into lazily loaded parts.\n\nIn this tutorial, we’ll apply the lazy loading technique in our vanilla JavaScript applications using the Intersection Observer API.\n\nAs the web has evolved throughout the years, browsers have gained more support, newer features, and newer APIs. Something that used to be a pain point for web developers was creating any kind of functionality dependent on a specific DOM element’s position visibility.\n\nPreviously, browsers didn’t have any API for checking the visibility of an element, and we had to rely on solutions like JavaScript and jQuery. It was very difficult to implement a solution to this problem. Modern browsers are making our lives easier by implementing new APIs that update on a daily basis. The Intersection Observer API is one of them.\n\nThe Intersection Observer API provides a way to observe changes in the intersection of a specific element. We can use this API to check the visibility of specific elements in our applications without having to create messy codes and work-around functionalities.\n\nThe Intersection Observer API can be used in a variety ways:\n• Lazy loading images or other content when the page is scrolled\n• Telling the browser to only execute the code once the element is visible at the viewport\n\nNow, we’ll use the interface to create a new observer and keep track of changes in the intersection of a target element:\n\nThe first argument of the is a callback function that is called when our target element intersects our device viewport or a specific element. The second argument is an object that we call . This object is responsible for controlling the circumstances of how your callback is invoked and has the following fields:\n• : the element that was set as the viewport for checking the visibility of the target. This element should be an ancestor of the element\n• : the defined margin around the element. This element can receive CSS values such as pixels or percentages\n• : a number or an array of numbers that indicates what percentage of the target’s visibility the observer’s callback function should invoke\n\nLet’s create our first observer using the Intersection Observer API.\n\nWe’ll have an object called where we’ll pass the options for our observer. Then we’ll create our first observer by creating a new and passing a callback function:\n\nNow, we need to get our target element, which we will observe:\n\nAfter that, we use the method to observe changes in the intersection of a target element:\n\nThis is what our final code looks like:\n\nThere are a couple of things that we need to remember when using the Intersection Observer API:\n• When the target meets a threshold, the callback function will be invoked and receive a list of objects\n• In the second argument of the interface, if you don’t set the root element, it will default to the browser viewport or\n• The target element should be within the DOM tree of the root element\n• The interfaces do not allow you to observe more than one element at a time. To observe multiple, you will have to iterate and observe them one by one\n\nHow you use the Intersection Observer API can vary depending on which technology you are using in your application. If you’re using vanilla JavaScript, you can easily go with the browser API itself. If you’re using some JavaScript framework, there are a few libraries that can help you use the Intersection Observer API.\n\nWe’re going to create an example using the Intersection Observer API with React because it’s a popular and frequently used JavaScript UI library. However, you can easily use the Intersection Observer API with any framework or library you want.\n\nLet’s create a new Create React App project using the following command:\n\nWe’re going to write all the code inside our component. First, we need to style our app a little bit using CSS, starting with our section and our target element. Inside the target element, when the element is visible, we’ll add the class.\n\nInside the default file, paste the following code:\n\nWe’ll create a simple example using the Intersection Observer API that changes the content inside our header component when our target element becomes visible to us.\n\nInside our component, we’re going to create a few HTML elements:\n\nNow, we’ll create a ref called , which we passed to our target element. After that, we’re going to create a state called to check whether the target element is visible on our page:\n\nNext, we’ll use the Hook to create our observer. Inside the hook, we’ll create our object:\n\nRemember that when our callback function is invoked, it receives a list of objects. These objects have many properties, and one of them is called . The property is a Boolean value that is true if the target element is intersecting with the observer’s root element.\n\nNow let’s create our observer. For our callback function, we’re going to get the value of the property and set the state:\n\nNow, we’re going to use the function and the method to do the cleanup:\n\nAll we need to do is pass our as a dependency to our hook, and we have a full example of the Intersection Observer API working smoothly. You can notice that the content changes when the target element is visible on the page.\n\nIn case you don’t want to use the browser API and want to work with a library to speed up the development, there’s a very good library called react-intersection-observer.\n\nTo use this library, you need to import the hook and pass an object as an argument:\n\nFinally, all you have to do is assign the to the DOM element you want to observe, and the hook will report the status:\n\nThere are infinite possibilities using the Intersection Observer API. With a few extra lines of code, you can vastly improve the user experience on your application by reducing load time. You can lazy load images, implement link pre-fetching when they’re visible on the page, and more.\n\nSupport for the Intersection Observer API is strong. At the time of writing, the majority of modern browsers are supporting it. This API is worth taking into consideration to help observe changes on our web pages."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API",
        "document": "The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's viewport. Historically, detecting visibility of an element, or the relative visibility of two elements in relation to each other, has been a difficult task for which solutions have been unreliable and prone to causing the browser and the sites the user is accessing to become sluggish. As the web has matured, the need for this kind of information has grown. Intersection information is needed for many reasons, such as:\n• Lazy-loading of images or other content as a page is scrolled.\n• Implementing \"infinite scrolling\" websites, where more and more content is loaded and rendered as you scroll, so that the user doesn't have to flip through pages.\n• Reporting of visibility of advertisements in order to calculate ad revenues.\n• Deciding whether or not to perform tasks or animation processes based on whether or not the user will see the result. Implementing intersection detection in the past involved event handlers and loops calling methods like to build up the needed information for every element affected. Since all this code runs on the main thread, even one of these can cause performance problems. When a site is loaded with these tests, things can get downright ugly. Consider a web page that uses infinite scrolling. It uses a vendor-provided library to manage the advertisements placed periodically throughout the page, has animated graphics here and there, and uses a custom library that draws notification boxes and the like. Each of these has its own intersection detection routines, all running on the main thread. The author of the website may not even realize this is happening, since they may know very little about the inner workings of the two libraries they are using. As the user scrolls the page, these intersection detection routines are firing constantly during the scroll handling code, resulting in an experience that leaves the user frustrated with the browser, the website, and their computer. The Intersection Observer API lets code register a callback function that is executed whenever a particular element enters or exits an intersection with another element (or the viewport), or when the intersection between two elements changes by a specified amount. This way, sites no longer need to do anything on the main thread to watch for this kind of element intersection, and the browser is free to optimize the management of intersections as it sees fit. One thing the Intersection Observer API can't do: trigger logic based on the exact number of pixels that overlap, or specifically on which ones they are. It only solves the common use case of \"If they intersect by somewhere around N%, I need to do something.\"\n\nCreate the intersection observer by calling its constructor and passing it a callback function to be run whenever a threshold is crossed in one direction or the other: A threshold of 1.0 means that when 100% of the target is visible within the element specified by the option, the callback is invoked. The object passed into the constructor let you control the circumstances under which the observer's callback is invoked. It has the following fields: The element that is used as the viewport for checking visibility of the target. Must be the ancestor of the target. Defaults to the browser viewport if not specified or if . Margin around the root. A string of one to four values similar to the CSS property, e.g. (top, right, bottom, left). The values can only be absolute lengths or percentages. This set of values serves to grow or shrink each side of the root element's bounding box before computing intersections. Negative values will shrink the bounding box of the root element and positive values will expand it. The default value, if not specified, is . Either a single number or an array of numbers which indicate at what percentage of the target's visibility the observer's callback should be executed. If you only want to detect when visibility passes the 50% mark, you can use a value of 0.5. If you want the callback to run every time visibility passes another 25%, you would specify the array [0, 0.25, 0.5, 0.75, 1]. The default is 0 (meaning as soon as even one pixel is visible, the callback will be run). A value of 1.0 means that the threshold isn't considered passed until every pixel is visible. The callback passed to the constructor receives a list of objects and the observer: const callback = (entries, observer) => { entries.forEach((entry) => { // Each entry describes an intersection change for one observed // target element: // entry.boundingClientRect // entry.intersectionRatio // entry.intersectionRect // entry.isIntersecting // entry.rootBounds // entry.target // entry.time }); }; The list of entries received by the callback includes one object for each threshold-crossing event — multiple entries can be received at a time, either from multiple targets or from a single target crossing multiple thresholds in a short amount of time. The entries are dispatched using a queue, so they should be ordered by the time they were generated, but you should preferably use to correctly order them. Each entry describes how much of a given element is intersecting with the root element, whether or not the element is considered to be intersecting or not, etc. The entry only contains information about that particular instant — if you want information that requires tracking over time, such as the scroll direction and speed, you may need to compute that yourself by memorizing previously received entries. Be aware that your callback is executed on the main thread. It should operate as quickly as possible; if anything time-consuming needs to be done, use . The code snippet below shows a callback which keeps a counter of how many times elements transition from not intersecting the root to intersecting by at least 75%. For a threshold value of 0.0 (default) the callback is called approximately upon transition of the boolean value of . The snippet thus first checks that the transition is a positive one, then determines whether is above 75%, in which case it increments the counter. const intersectionCallback = (entries) => { entries.forEach((entry) => { if (entry.isIntersecting) { let elem = entry.target; if (entry.intersectionRatio >= 0.75) { intersectionCounter++; } } }); }; Targeting an element to be observed Once you have created the observer, you need to give it a target element to watch: const target = document.querySelector(\"#listItem\"); observer.observe(target); // the callback we set up for the observer will be executed now for the first time // it waits until we assign a target to our observer (even if the target is currently not visible) Whenever the target meets a threshold specified for the , the callback is invoked. Also, note that if you specified the option, the target must be a descendant of the root element.\n\nAll areas considered by the Intersection Observer API are rectangles; elements which are irregularly shaped are considered as occupying the smallest rectangle which encloses all of the element's parts. Similarly, if the visible portion of an element is not rectangular, the element's intersection rectangle is considered to be the smallest rectangle that contains all the visible portions of the element. It's useful to understand a bit about how the various properties provided by describe an intersection. Before we can track the intersection of an element with a container, we need to know what that container is. That container is the intersection root, or root element. This can be either a specific element in the document which is an ancestor of the element to be observed, or to use the document's viewport as the container. The root intersection rectangle is the rectangle used to check against the target or targets. This rectangle is determined like this:\n• If the intersection root is the implicit root (that is, the top-level ), the root intersection rectangle is the viewport's rectangle.\n• If the intersection root has an overflow clip, the root intersection rectangle is the root element's content area.\n• Otherwise, the root intersection rectangle is the intersection root's bounding client rectangle (as returned by calling on it). The root intersection rectangle can be adjusted further by setting the root margin, , when creating the . The values in define offsets added to each side of the intersection root's bounding box to create the final intersection root bounds (which are disclosed in when the callback is executed). Positive values grow the box, while negative values shrink it. In the example below, we have a scrollable box and an element that's initially out of view. You can adjust the root right margin, and see that:\n• If the margin is negative, then even when the red element starts to become visible, it's still not considered intersecting with the root because the root's bounding box is shrunk.\n• If the margin is positive, the red element is considered intersecting with the root even if it's not visible, because it's intersecting with the root's margin area. <div class=\"demo\"> <div id=\"container\"> <div id=\"elem\"></div> <div id=\"gutter\"></div> </div> <div id=\"marginIndicator\"></div> </div> <div class=\"controls\"> <label> Set the right margin of the root: <input id=\"margin\" type=\"number\" value=\"0\" step=\"5\" />px </label> <label> You can also use this slider to scroll the container: <input id=\"scrollAmount\" type=\"range\" min=\"0\" max=\"300\" value=\"0\" /> </label> <p>Current intersection ratio: <span id=\"output\"></span></p> </div> let observer; function createObserver() { if (observer) { observer.disconnect(); } observer = new IntersectionObserver( (entries) => { entries.forEach((entry) => { output.textContent = entry.intersectionRatio.toFixed(2); }); }, { threshold: Array.from({ length: 1000 }, (_, i) => i / 1000), root: container, rootMargin: `0px ${margin.value}px 0px 0px`, }, ); if (margin.valueAsNumber < 0) { marginIndicator.style.width = `${-margin.valueAsNumber}px`; marginIndicator.style.left = `${margin.valueAsNumber}px`; marginIndicator.style.backgroundColor = \"blue\"; } else { marginIndicator.style.width = `${margin.valueAsNumber}px`; marginIndicator.style.left = \"0px\"; marginIndicator.style.backgroundColor = \"green\"; } observer.observe(elem); } createObserver(); margin.addEventListener(\"input\", () => { createObserver(); }); scrollAmount.addEventListener(\"input\", () => { container.scrollLeft = scrollAmount.value; }); Rather than reporting every infinitesimal change in how much a target element is visible, the Intersection Observer API uses thresholds. When you create an observer, you can provide one or more numeric values representing percentages of the target element which are visible. Then, the API only reports changes to visibility which cross these thresholds. For example, if you want to be informed every time a target's visibility passes backward or forward through each 25% mark, you would specify the array [0, 0.25, 0.5, 0.75, 1] as the list of thresholds when creating the observer. When the callback is invoked, it receives a list of objects, one for each observed target which has had the degree to which it intersects the root change such that the amount exposed crosses over one of the thresholds, in either direction. You can see if the target currently intersects the root by looking at the entry's property; if its value is , the target is at least partially intersecting the root element or document. This lets you determine whether the entry represents a transition from the elements intersecting to no longer intersecting or a transition from not intersecting to intersecting. Note that it's possible to have a zero intersection rectangle, which can happen if the intersection is exactly along the boundary between the two or the area of is zero. This state of the target and root sharing a boundary line is not considered enough to be considered transitioning into an intersecting state. To get a feeling for how thresholds work, try scrolling the box below around. Each colored box within it displays the percentage of itself that's visible in all four of its corners, so you can see these ratios change over time as you scroll the container. Each box has a different set of thresholds:\n• The first box has a threshold for each percentage point of visibility; that is, the array is .\n• The second box has a single threshold, at the 50% mark.\n• The third box has thresholds every 10% of visibility (0%, 10%, 20%, etc.).\n• The last box has thresholds each 25%. let observers = []; startup = () => { let wrapper = document.querySelector(\".wrapper\"); // Options for the observers let observerOptions = { root: null, rootMargin: \"0px\", threshold: [], }; // An array of threshold sets for each of the boxes. The // first box's thresholds are set programmatically // since there will be so many of them (for each percentage // point). let thresholdSets = [ [], [0.5], [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0], [0, 0.25, 0.5, 0.75, 1.0], ]; for (let i = 0; i <= 1.0; i += 0.01) { thresholdSets[0].push(i); } // Add each box, creating a new observer for each for (let i = 0; i < 4; i++) { let template = document .querySelector(\"#boxTemplate\") .content.cloneNode(true); let boxID = `box${i + 1}`; template.querySelector(\".sampleBox\").id = boxID; wrapper.appendChild(document.importNode(template, true)); // Set up the observer for this box observerOptions.threshold = thresholdSets[i]; observers[i] = new IntersectionObserver( intersectionCallback, observerOptions, ); observers[i].observe(document.querySelector(`#${boxID}`)); } // Scroll to the starting position document.scrollingElement.scrollTop = wrapper.firstElementChild.getBoundingClientRect().top + window.scrollY; document.scrollingElement.scrollLeft = 750; }; intersectionCallback = (entries) => { entries.forEach((entry) => { const box = entry.target; const visiblePct = `${Math.floor(entry.intersectionRatio * 100)}%`; box.querySelector(\".topLeft\").textContent = visiblePct; box.querySelector(\".topRight\").textContent = visiblePct; box.querySelector(\".bottomLeft\").textContent = visiblePct; box.querySelector(\".bottomRight\").textContent = visiblePct; }); }; startup(); The browser computes the final intersection rectangle as follows; this is all done for you, but it can be helpful to understand these steps in order to better grasp exactly when intersections will occur.\n• The target element's bounding rectangle (that is, the smallest rectangle that fully encloses the bounding boxes of every component that makes up the element) is obtained by calling on the target. This is the largest the intersection rectangle may be. The remaining steps will remove any portions that don't intersect.\n• Starting at the target's immediate parent block and moving outward, each containing block's clipping (if any) is applied to the intersection rectangle. A block's clipping is determined based on the intersection of the two blocks and the clipping mode (if any) specified by the property. Setting to anything but causes clipping to occur.\n• If one of the containing elements is the root of a nested browsing context (such as the document contained in an ), the intersection rectangle is clipped to the containing context's viewport, and recursion upward through the containers continues with the container's containing block. So if the top level of an is reached, the intersection rectangle is clipped to the frame's viewport, then the frame's parent element is the next block recursed through toward the intersection root.\n• When recursion upward reaches the intersection root, the resulting rectangle is mapped to the intersection root's coordinate space.\n• The resulting rectangle is then updated by intersecting it with the root intersection rectangle.\n• This rectangle is, finally, mapped to the coordinate space of the target's .\n\nFinally, let's take a look at the JavaScript code that uses the Intersection Observer API to make things happen. First, we need to prepare some variables and install the observer. const numSteps = 20.0; let boxElement; let prevRatio = 0.0; let increasingColor = \"rgb(40 40 190 / ratio)\"; let decreasingColor = \"rgb(190 40 40 / ratio)\"; // Set things up window.addEventListener( \"load\", (event) => { boxElement = document.querySelector(\"#box\"); createObserver(); }, false, ); The constants and variables we set up here are: A constant which indicates how many thresholds we want to have between a visibility ratio of 0.0 and 1.0. This variable will be used to record what the visibility ratio was the last time a threshold was crossed; this will let us figure out whether the target element is becoming more or less visible. A string defining a color we'll apply to the target element when the visibility ratio is increasing. The word \"ratio\" in this string will be replaced with the target's current visibility ratio, so that the element not only changes color but also becomes increasingly opaque as it becomes less obscured. Similarly, this is a string defining a color we'll apply when the visibility ratio is decreasing. We call to start listening for the event; once the page has finished loading, we get a reference to the element with the ID using , then call the method we'll create in a moment to handle building and installing the intersection observer. The method is called once page load is complete to handle actually creating the new and starting the process of observing the target element. function createObserver() { let observer; let options = { root: null, rootMargin: \"0px\", threshold: buildThresholdList(), }; observer = new IntersectionObserver(handleIntersect, options); observer.observe(boxElement); } This begins by setting up an object containing the settings for the observer. We want to watch for changes in visibility of the target element relative to the document's viewport, so is . We need no margin, so the margin offset, , is specified as \"0px\". This causes the observer to watch for changes in the intersection between the target element's bounds and those of the viewport, without any added (or subtracted) space. The list of visibility ratio thresholds, , is constructed by the function . The threshold list is built programmatically in this example since there are a number of them and the number is intended to be adjustable. Once is ready, we create the new observer, calling the constructor, specifying a function to be called when intersection crosses one of our thresholds, , and our set of options. We then call on the returned observer, passing into it the desired target element. We could opt to monitor multiple elements for visibility intersection changes with respect to the viewport by calling for each of those elements, if we wanted to do so. The function, which builds the list of thresholds, looks like this: function buildThresholdList() { let thresholds = []; let numSteps = 20; for (let i = 1.0; i <= numSteps; i++) { let ratio = i / numSteps; thresholds.push(ratio); } thresholds.push(0); return thresholds; } This builds the array of thresholds—each of which is a ratio between 0.0 and 1.0, by pushing the value onto the array for each integer between 1 and . It also pushes 0 to include that value. The result, given the default value of (20), is the following list of thresholds: We could, of course, hard-code the array of thresholds into our code, and often that's what you'll end up doing. But this example leaves room for adding configuration controls to adjust the granularity, for example. When the browser detects that the target element (in our case, the one with the ID ) has been unveiled or obscured such that its visibility ratio crosses one of the thresholds in our list, it calls our handler function, : For each in the list , we look to see if the entry's is going up; if it is, we set the target's to the string in (remember, it's ), replaces the word \"ratio\" with the entry's . The result: not only does the color get changed, but the transparency of the target element changes, too; as the intersection ratio goes down, the background color's alpha value goes down with it, resulting in an element that's more transparent. Similarly, if the is going down, we use the string and replace the word \"ratio\" in that with the before setting the target element's . Finally, in order to track whether the intersection ratio is going up or down, we remember the current ratio in the variable ."
    },
    {
        "link": "https://dev.to/kansoldev/how-i-used-the-intersectionobserver-api-to-lazyload-images-51c8",
        "document": "Web performance is an important aspect to consider when building web applications, as it is of necessity that users get a nice experience while using your application. In this article, I want to share my experience using the IntersectionObserver API in JS to lazy load property images on a real estate website i am building, which helped me improve the load time of the website by a significant amount. I won't dive too deep into how this API works, but I would link articles at the end that explains it in more detail.\n\nI have been building this website hmghomes.com, and working on making it load faster because it loads very slowly. I realized from the network tab in chrome dev tools that one of the biggest reasons the website takes time to load is because the sizes of the property images are large.\n\nI checked for possible solutions to the problem, and the most obvious one I saw was to optimize the images (of course!). I then stumbled on another solution to lazy load the images, as loading every single property image from the DB is not efficient. I wasn't sure how to go about doing this as there are multiple ways to lazy load images on a website. I was looking for the best approach for my use case, and after doing some research, I found out about the IntersectionObserver API.\n\nAt first, this API was very confusing to understand, like what am I observing?, How does intersection happen?, but thanks to this video by webdevsimplified on the topic, I was able to understand how to use it to achieve what i was looking for.\n\nHere is a preview of how the website loaded before\n\nHere is a preview of how the website loads now\n\nThis was the code I wrote to get the result I wanted\n\nLet me briefly explain the code,\n• None I first check when the DOM has fully loaded to be sure the code runs as expected\n• None I also checked if the IntersectionObserver API exists in the window object, because there are some browsers that don't support this\n• None An instance of the IntersectionObserver API class is then created, this is where the magic starts happening. The API takes in a callback function which receives 2 arguments, entries and observer, but i will only talk about the entries argument in this article. The entries are the items the intersectionObserver keeps track of that are yet to show on the DOM.\n• None Next, I am checking if the item is visible or almost visible to the user (that is what entry.isIntersecting means). If it is visible, I get the target element for that specific entry (which in this case is an image tag), after which I remove the .lazy class and add a style attribute to dynamically set a background image\n• None After doing all this, I called imageObserver.unobserve(image) to tell the Observer to stop tracking that specific entry. Why is this necessary? because it is already visible to the user at this point. The whole point of tracking an entry is to monitor it's position before it becomes visible to the user, once it shows, there is no point of monitoring it again. I would say that there can be cases where you might still want to observe the entry even after the intersection has been made, it all depends on what you are trying to achieve.\n\nI haven't yet pushed this live, I still need to optimize the JS and CSS files too, but this has started improving the speed of the website. Another thing I want to point out is that the IntersectionObserver API can be used for tasks other than just lazy loading, as long as it requires interacting with the users viewport. You can read more about this API from MDN docs, and This Article by David Herbert\n\nHave you ever used the IntersectionObserver API before?, I would like to know. You can find out more about what I do on Twitter and Github"
    },
    {
        "link": "https://debugbear.com/blog/lazy-load-background-images-intersection-observer",
        "document": "While we can defer offscreen images using the HTML attribute, lazy loading background images takes a bit more work. Since they are added by CSS rather than HTML, we need to use JavaScript to detect when offscreen background images are about to enter the user's viewport.\n\nIt would be nice to have a native property in CSS as well, but unfortunately, it doesn't currently exist. Luckily, the API provides a performance-friendly solution to lazy load background images without having to manually add JavaScript event listeners and perform viewport calculations, or use a third-party library.\n\nIn this article, we'll look into how to lazy load background images using the CSS property and the JavaScript API.\n\nis a native web API available in modern browsers, so you can use it without having to add a third-party library to your page. It allows you to asynchronously monitor when an HTML element visually overlaps (a.k.a. intersects) with one of its ancestors, such as the viewport.\n\nThis makes the API an excellent way to detect when offscreen elements are scrolling into view, thus one of its most frequent use cases is lazy loading background images.\n\nAs is supported by all modern browsers, you can use it without a fallback.\n\nAs the object runs asynchronously outside the main thread, it provides a performance-friendly way to monitor the visibility of HTML elements, avoiding the costly DOM queries and layout calculations that traditional scroll event listeners trigger on each scroll.\n\nBefore the API, developers had to implement lazy loading manually by attaching event listeners to , , , and other viewport-related events.\n\nThis approach was inefficient because these events fire extremely frequently during user interaction, and each event executes expensive DOM queries on the main thread, blocking it repeatedly. Even with throttling techniques, such as using the function, the performance overhead remains significant.\n\nThe API solves these web performance issues by making native lazy loading possible. Unlike manual event listeners, it uses the browser's compositor thread for intersection calculations and batches multiple intersection changes that happen close in time into a single callback, avoiding repeated DOM calculations. This results in reduced CPU usage, smoother scrolling, and better user experience.\n\nNow let's see how to lazy load background images using the API.\n\nTo see how to defer offscreen background images using the API in practice, I created a demo page that includes some CTA (call to action) elements with background images added in CSS in a vertical layout. The background images are lazy loaded from the fourth image onward.\n\nBelow, you can see a screencast of how the resources, including the deferred background images, download from the network in the Chrome browser. Note that the first two images are preloaded, which is why they download before the CSS and JavaScript files:\n\nNow let's see how to create the above demo using the API.\n\nTo defer offscreen background images, you can use the following HTML:\n\nThe code above adds the class to the offscreen elements starting from the fourth one. On mobile viewports, the first three elements typically appear above the fold, so we can safely lazy load the background images up from the fourth element.\n\nThe process of lazy loading will use the following workflow:\n• We'll show a simple gray background color for the elements as a visual placeholder using CSS.\n• We'll monitor the current positions of the deferred elements in JavaScript, using the API.\n• When an observed gets close to the viewport (as the user is scrolling down the page), we'll remove the class from the HTML using JavaScript.\n• When the class is removed, the CSS will swap the gray background color with the background image.\n\nSince in this demo, it's either the first or second image that's reported as the LCP element, I preloaded both (however, note that too many preloads may backfire, so be careful when using preloading):\n\nThe CSS below uses a simple but efficient technique to swap the placeholder background color with the background image when we remove the class with JavaScript — the cascade (CSS stands for 'Cascading Style Sheets' since the cascade is its most fundamental feature):\n\nThe code above first defines the backgrounds for the individual elements ( , , etc.) using the shorthand property, which:\n• first adds a light gray background color ( ), which will serve as the visual placeholder,\n• then specifies the location of the background image ( ),\n• finally prevents the repetition of the background image ( ).\n\nThen, it adds the class below the individual elements to leverage the cascade in the following way:\n• The rule will apply to the divs because it's located below the background image rules defined in the shorthand properties of the , , etc. declarations, so it will override them.\n• The background color ( ) defined in the shorthand properties will still apply to the divs, as the CSS doesn't specify a separate property for them.\n• When the class gets removed from the HTML, the rule won't apply to the previously deferred divs anymore, so the background images defined for the individual elements in the shorthand properties will start downloading from the network and then appear on the screen.\n\nThe code above also adds the property to the elements (it's equal to the ratio of the intrinsic width and height of the image files) so that they'll have the same dimensions as the background images.\n\nNote that without defining , the containers won't be the same size as the background images — see an example in the screenshot below (which is OK, if this is the design you want to achieve):\n\nIn the JavaScript code, we'll listen to the event, which fires when the HTML page is completely parsed and the DOM is ready to use. This ensures all the HTML elements are available in the DOM before we try to select and observe them:\n\nAfter setting up the event listener, the above script selects all elements with the class and adds them to the constant (which is a object that will include all the deferred elements).\n\nNext, it instantiates an object and assigns it to the constant, which will be created when the event fires.\n\nThe script also defines three properties for :\n• :\n• It specifies the element against which the positions of the observed elements will be compared.\n• The value sets the viewport as the element.\n• :\n• It creates a margin around the element (here, the viewport) so that the observation can start before it intersects with the observed element.\n• It's a shorthand that works similarly to the CSS property.\n• The code above sets it to , which creates a 200px margin at the top and bottom of the viewport, so the deferred images will start downloading 200px before they enter the viewport.\n• You can also use a different value if you want to start the download process sooner or later (e.g. 500px will start it sooner).\n• :\n• It specifies the intersection threshold when the callback function will be executed.\n• The value means that it starts executing immediately when an observed div enters the visibility zone (which is the extended with the ).\n• Otherwise, must be a decimal value between 0 and 1 (e.g. 0.1 would mean that the callback function is executed when an observed element has reached the 10% of the visibility zone).\n\nThe object also starts observing the deferred elements stored in the constant when the event fires — this functionality is set up in the loop at the end of the script.\n\nWhenever a deferred element's visibility state changes (i.e., when it intersects with the visibility area of the root element), the object:\n• creates a new object (called in the code above),\n• adds the new to the array,\n\nThe callback function runs a loop on the array and checks whether each in the array is intersecting with the visibility area of (which happens when the property of the is true).\n\nIf so, it removes the class of the belonging from the HTML and instructs to stop observing the element.\n\nTo support users who have JavaScript disabled in their browsers, you can add the following line of code below the tag in the section of the HTML page:\n\nThe code above overrides the rules of the CSS file when the tag is active (which happens when JavaScript is disabled in the user's browser), and downloads and displays the background images for non-JavaScript users who otherwise would just see the gray placeholder boxes in place of the deferred background images.\n\nOn the other hand, note that if you add the above code, the background images won't be lazy loaded for users who have JavaScript disabled in their browsers, but they will all start downloading at initial page load.\n\nThe API provides a modern and performance-friendly way to lazy load background images by using the compositor thread to asynchronously observe the location of offscreen elements, instead of blocking the main thread. By deferring offscreen background images, you can reduce page weight, speed up page load times, and improve Core Web Vitals.\n\nWith DebugBear, you can test the performance impact of web development best practices such as lazy loading background images, check how fast your pages load overall, catch web performance issues proactively, set up both synthetic tests and real user monitoring (RUM), and more.\n\nYou can get started for free by running a free website speed test, checking out our interactive demo, or signing up for a free 14-day trial for the full functionality (no credit card required)."
    }
]