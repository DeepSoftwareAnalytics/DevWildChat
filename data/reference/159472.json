[
    {
        "link": "https://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast",
        "document": "Creates a new instance of std::shared_ptr whose stored pointer is obtained from r's stored pointer using a cast expression.\n\nIf r is empty, so is the new (but its stored pointer is not necessarily null). Otherwise, the new will share ownership with the initial value of r, except that it is empty if the performed by returns a null pointer.\n\nLet be typename std::shared_ptr<T>::element_type, then the resulting std::shared_ptr's stored pointer will be obtained by evaluating, respectively:\n\n. If the result of the is a null pointer value, the returned will be empty.\n\nThe behavior of these functions is undefined unless the corresponding cast from to is well formed:\n\nThe behavior is undefined unless is well formed.\n\nThe behavior is undefined unless is well formed.\n\nThe behavior is undefined unless is well formed.\n\nThe behavior is undefined unless is well formed.\n\nThe expressions std::shared_ptr<T>(static_cast<T*>(r.get())), std::shared_ptr<T>(dynamic_cast<T*>(r.get())) and std::shared_ptr<T>(const_cast<T*>(r.get())) might seem to have the same effect, but they all will likely result in undefined behavior, attempting to delete the same object twice!"
    },
    {
        "link": "https://stackoverflow.com/questions/6065954/static-pointer-cast-for-weak-ptr",
        "document": "This ought to do it for you:\n\nThis will throw an exception if the weak_ptr has expired. If you would rather get a null weak_ptr, then use instead."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/memory/shared_ptr",
        "document": "is a smart pointer that retains shared ownership of an object through a pointer. Several objects may own the same object. The object is destroyed and its memory deallocated when either of the following happens:\n• the last remaining owning the object is destroyed;\n• the last remaining owning the object is assigned another pointer via or .\n\nThe object is destroyed using delete-expression or a custom deleter that is supplied to during construction.\n\nA can share ownership of an object while storing a pointer to another object. This feature can be used to point to member objects while owning the object they belong to. The stored pointer is the one accessed by get(), the dereference and the comparison operators. The managed pointer is the one passed to the deleter when use count reaches zero.\n\nA may also own no objects, in which case it is called empty (an empty may have a non-null stored pointer if the aliasing constructor was used to create it).\n\nAll specializations of meet the requirements of CopyConstructible, CopyAssignable, and LessThanComparable and are contextually convertible to .\n\nAll member functions (including copy constructor and copy assignment) can be called by multiple threads on different objects without additional synchronization even if these objects are copies and share ownership of the same object. If multiple threads of execution access the same object without synchronization and any of those accesses uses a non-const member function of then a data race will occur; the can be used to prevent the data race.\n\nThe ownership of an object can only be shared with another by copy constructing or copy assigning its value to another . Constructing a new using the raw underlying pointer owned by another leads to undefined behavior.\n\nmay be used with an incomplete type . However, the constructor from a raw pointer (template<class Y> shared_ptr(Y*)) and the template<class Y> void reset(Y*) member function may only be called with a pointer to a complete type (note that std::unique_ptr may be constructed from a raw pointer to an incomplete type).\n\nThe in std::shared_ptr<T> may be a function type: in this case it manages a pointer to function, rather than an object pointer. This is sometimes used to keep a dynamic library or a plugin loaded as long as any of its functions are referenced:\n\nIn a typical implementation, holds only two pointers:\n• the stored pointer (one returned by );\n\nThe control block is a dynamically-allocated object that holds:\n• either a pointer to the managed object or the managed object itself;\n• the number of s that own the managed object;\n• the number of s that refer to the managed object.\n\nWhen is created by calling std::make_shared or std::allocate_shared, the memory for both the control block and the managed object is created with a single allocation. The managed object is constructed in-place in a data member of the control block. When is created via one of the constructors, the managed object and the control block must be allocated separately. In this case, the control block stores a pointer to the managed object.\n\nThe pointer held by the directly is the one returned by get(), while the pointer/object held by the control block is the one that will be deleted when the number of shared owners reaches zero. These pointers are not necessarily equal.\n\nThe destructor of decrements the number of shared owners of the control block. If that counter reaches zero, the control block calls the destructor of the managed object. The control block does not deallocate itself until the std::weak_ptr counter reaches zero as well.\n\nIn existing implementations, the number of weak pointers is incremented ([1], [2]) if there is a shared pointer to the same control block.\n\nTo satisfy thread safety requirements, the reference counters are typically incremented using an equivalent of std::atomic::fetch_add with std::memory_order_relaxed (decrementing requires stronger ordering to safely destroy the control block)."
    },
    {
        "link": "https://stackoverflow.com/questions/14991664/weak-ptr-of-a-base-class-while-the-shared-ptr-is-of-a-derived-class",
        "document": "I have a structure that manages objects that derive from a base class , but does not control their lifetimes. I want this structure to be given weak pointers like so that it can know if the object has been destroyed elsewhere.\n\nHowever, outside of the managing structure where the shared pointer lives, I want the shared pointer to be the more specific (SpecificEntity uses Entity as a base class).\n\nIs there a way to accomplish this, or something like it?"
    },
    {
        "link": "https://cplusplus.com/reference/memory/dynamic_pointer_cast",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/57226966/casting-shared-ptrtype-to-weak-ptrvoid-and-back",
        "document": "How would I get a to a ?\n\nHow would I lock a and ultimately produce a ?\n\nhas a non-trivial destructor, is it right to assume will never call this destructor?\n\nThe void weak pointer is what I want in this case, it's used only to keep tabs on the reference count of shared pointers of multiple types, and give out shared pointers to existing objects without itself owning the object (it's part of a one object many references resource manager)."
    },
    {
        "link": "https://stackoverflow.com/questions/66768249/what-are-best-use-cases-of-shared-ptr-unique-ptr-and-weak-ptr",
        "document": "I assume you know what each of these smart pointers do so I am not going to explain them. Instead I will give you examples of how I have used them in my own code or from libraries I have used that need them.\n\nstd::unique_ptr: Can be returned from an API to indicate that the resource needs to be managed by the caller and that it is not safe to share the object. For example, gRPC creates instances like this. has sensitive lifetime and synchronization requirements. By returning it is clear that the caller is responsible for lifetime management and it makes it cumbersome to share the . It is still not impossible to share it (can get the raw pointer from the or use a reference to the , both of which are typically code smells).\n\nstd::shared_ptr/std::weak_ptr: Not the simplest use case, but here we go...\n\nIn this example, all instances on a thread need to have their audio mixed together using . So, each has a so that when the last instance holding the is destroyed, the mixer will be as well. The usage of just facilitates having a unique per thread. The storage of the should not prolong the life of the mixer as the lifetime of the is decided by the existence of instances (ie. no => no ) - this is why a is used. means that either no has been created on this thread or all previously existing players were deleted. means another exists on this thread and the current needs to get a to the same mixer. Note you have to be careful when using and from multiple threads as they are not thread safe. In this example, and the fact that is only created and destroyed within the same thread ensures it is safe.\n\nOf course, this could have all be done without the smart pointers but the smart pointers help communicate the intent of the code better."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/7fqfrv/notes_on_stdshared_ptr_and_stdweak_ptr",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://learncpp.com/cpp-tutorial/circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr",
        "document": "In the previous lesson, we saw how std::shared_ptr allowed us to have multiple smart pointers co-owning the same resource. However, in certain cases, this can become problematic. Consider the following case, where the shared pointers in two separate objects each point at the other object:\n\nIn the above example, we dynamically allocate two Persons, “Lucy” and “Ricky” using make_shared() (to ensure lucy and ricky are destroyed at the end of main()). Then we partner them up. This sets the std::shared_ptr inside “Lucy” to point at “Ricky”, and the std::shared_ptr inside “Ricky” to point at “Lucy”. Shared pointers are meant to be shared, so it’s fine that both the lucy shared pointer and Rick’s m_partner shared pointer both point at “Lucy” (and vice-versa).\n\nHowever, this program doesn’t execute as expected:\n\nAnd that’s it. No deallocations took place. Uh oh. What happened?\n\nAfter partnerUp() is called, there are two shared pointers pointing to “Ricky” (ricky, and Lucy’s m_partner) and two shared pointers pointing to “Lucy” (lucy, and Ricky’s m_partner).\n\nAt the end of main(), the ricky shared pointer goes out of scope first. When that happens, ricky checks if there are any other shared pointers that co-own the Person “Ricky”. There are (Lucy’s m_partner). Because of this, it doesn’t deallocate “Ricky” (if it did, then Lucy’s m_partner would end up as a dangling pointer). At this point, we now have one shared pointer to “Ricky” (Lucy’s m_partner) and two shared pointers to “Lucy” (lucy, and Ricky’s m_partner).\n\nNext the lucy shared pointer goes out of scope, and the same thing happens. The shared pointer lucy checks if there are any other shared pointers co-owning the Person “Lucy”. There are (Ricky’s m_partner), so “Lucy” isn’t deallocated. At this point, there is one shared pointer to “Lucy” (Ricky’s m_partner) and one shared pointer to “Ricky” (Lucy’s m_partner).\n\nThen the program ends -- and neither Person “Lucy” or “Ricky” have been deallocated! Essentially, “Lucy” ends up keeping “Ricky” from being destroyed, and “Ricky” ends up keeping “Lucy” from being destroyed.\n\nIt turns out that this can happen any time shared pointers form a circular reference.\n\nA Circular reference (also called a cyclical reference or a cycle) is a series of references where each object references the next, and the last object references back to the first, causing a referential loop. The references do not need to be actual C++ references -- they can be pointers, unique IDs, or any other means of identifying specific objects.\n\nIn the context of shared pointers, the references will be pointers.\n\nThis is exactly what we see in the case above: “Lucy” points at “Ricky”, and “Ricky” points at “Lucy”. With three pointers, you’d get the same thing when A points at B, B points at C, and C points at A. The practical effect of having shared pointers form a cycle is that each object ends up keeping the next object alive -- with the last object keeping the first object alive. Thus, no objects in the series can be deallocated because they all think some other object still needs it!\n\nIt turns out, this cyclical reference issue can even happen with a single std::shared_ptr -- a std::shared_ptr referencing the object that contains it is still a cycle (just a reductive one). Although it’s fairly unlikely that this would ever happen in practice, we’ll show you for additional comprehension:\n\nIn the above example, when ptr1 goes out of scope, the Resource is not deallocated because the Resource’s m_ptr is sharing the Resource. At that point, the only way for the Resource to be released would be to set m_ptr to something else (so nothing is sharing the Resource any longer). But we can’t access m_ptr because ptr1 is out of scope, so we no longer have a way to do this. The Resource has become a memory leak.\n\nSo what is std::weak_ptr for anyway?\n\nstd::weak_ptr was designed to solve the “cyclical ownership” problem described above. A std::weak_ptr is an observer -- it can observe and access the same object as a std::shared_ptr (or other std::weak_ptrs) but it is not considered an owner. Remember, when a std::shared pointer goes out of scope, it only considers whether other std::shared_ptr are co-owning the object. std::weak_ptr does not count!\n\nFunctionally, it works almost identically to the problematic example. However, now when ricky goes out of scope, it sees that there are no other std::shared_ptr pointing at “Ricky” (the std::weak_ptr from “Lucy” doesn’t count). Therefore, it will deallocate “Ricky”. The same occurs for lucy.\n\nOne downside of std::weak_ptr is that std::weak_ptr are not directly usable (they have no operator->). To use a std::weak_ptr, you must first convert it into a std::shared_ptr. Then you can use the std::shared_ptr. To convert a std::weak_ptr into a std::shared_ptr, you can use the lock() member function. Here’s the above example, updated to show this off:\n\nWe don’t have to worry about circular dependencies with std::shared_ptr variable “partner” since it’s just a local variable inside the function. It will eventually go out of scope at the end of the function and the reference count will be decremented by 1.\n\nConsider the case where a normal “dumb” pointer is holding the address of some object, and then that object is destroyed. Such a pointer is dangling, and dereferencing the pointer will lead to undefined behavior. And unfortunately, there is no way for us to determine whether a pointer holding a non-null address is dangling or not. This is a large part of the reason dumb pointers are dangerous.\n\nBecause std::weak_ptr won’t keep an owned resource alive, it’s similarly possible for a std::weak_ptr to be left pointing to a resource that has been deallocated by a std::shared_ptr. However, std::weak_ptr has a neat trick up its sleeve -- because it has access to the reference count for an object, it can determine if it is pointing to a valid object or not! If the reference count is non-zero, the resource is still valid. If the reference count is zero, then the resource has been destroyed.\n\nThe easiest way to test whether a std::weak_ptr is valid is to use the member function, which returns if the std::weak_ptr is pointing to an invalid object, and otherwise.\n\nHere’s a simple example showing this difference in behavior:\n\nBoth and use a smart pointer to allocate a Resource -- this smart pointer ensures that the allocated Resource will be destroyed at the end of the function. When returns a Resource*, it returns a dangling pointer (because std::unique_ptr destroyed the Resource at the end of the function). When returns a std::weak_ptr, that std::weak_ptr is similarly pointing to an invalid object (because std::shared_ptr destroyed the Resource at the end of the function).\n\nInside main(), we first test whether the returned dumb pointer is . Because the dumb pointer is still holding the address of the deallocated resource, this test fails. There is no way for to tell whether this pointer is dangling or not. In this case, because it is a dangling pointer, if we were to dereference this pointer, undefined behavior would result.\n\nNext, we test whether is . Because the reference count for the object being pointed to by is (because the object being pointed to was already destroyed), this resolves to . The code in can thus tell that is pointing to an invalid object, and we can conditionalize our code as appropriate!\n\nNote that if a std::weak_ptr is expired, then we shouldn’t call on it, because the object being pointed to has already been destroyed, so there is no object to share. If you do call on an expired std::weak_ptr, it will return a std::shared_ptr to .\n\nstd::shared_ptr can be used when you need multiple smart pointers that can co-own a resource. The resource will be deallocated when the last std::shared_ptr goes out of scope. std::weak_ptr can be used when you want a smart pointer that can see and use a shared resource, but does not participate in the ownership of that resource.\n• Fix the program presented in the section “A reductive case” so that the Resource is properly deallocated. Do not alter the code in .\n\nHere is the program again for ease of reference:"
    },
    {
        "link": "https://geeksforgeeks.org/auto_ptr-unique_ptr-shared_ptr-weak_ptr-in-cpp",
        "document": "Smart Pointer is a pointer-wrapping stack-allocated object. Smart pointers, in plain terms, are classes that wrap a pointer, or scoped pointers.\n\nC++ libraries provide implementations of smart pointers in the following types:\n\nThey all are declared in a memory header file( #include<memory>) which is used to manage dynamic memory allocation.\n\nThis class template is deprecated as of C++11. unique_ptr is a new facility with similar functionality, but with improved security. auto_ptr is a smart pointer that manages an object obtained via a new expression and deletes that object when auto_ptr itself is destroyed. An object when described using the auto_ptr class it stores a pointer to a single allocated object which ensures that when it goes out of scope, the object it points to must get automatically destroyed. It is based on an exclusive ownership model i.e. two pointers of the same type can’t point to the same resource at the same time. As shown in the below program, copying or assigning pointers changes the ownership i.e. source pointer has to give ownership to the destination pointer.\n\nThe copy constructor and the assignment operator of auto_ptr do not actually copy the stored pointer instead they transfer it, leaving the first auto_ptr object empty. This was one way to implement strict ownership so that only one auto_ptr object can own the pointer at any given time i.e. auto_ptr should not be used where copy semantics are needed.\n\nIt takes ownership of the pointer in a way that no two pointers should contain the same object. Assignment transfers ownership and resets the rvalue auto pointer to a null pointer. Thus, they can’t be used within STL containers due to the aforementioned inability to be copied.\n\nstd::unique_ptr was developed in C++11 as a replacement for std::auto_ptr. unique_ptr is a new facility with similar functionality, but with improved security (no fake copy assignments), added features (deleters), and support for arrays. It is a container for raw pointers. It explicitly prevents copying of its contained pointer as would happen with a normal assignment i.e. it allows exactly one owner of the underlying pointer. So, when using unique_ptr there can only be at most one unique_ptr at any one resource and when that unique_ptr is destroyed, the resource is automatically claimed. Also, since there can only be one unique_ptr to any resource, any attempt to make a copy of unique_ptr will cause a compile-time error.\n\nBut, unique_ptr can be moved using the new move semantics i.e. using the std::move() function to transfer ownership of the contained pointer to another unique_ptr.\n\nSo, it’s best to use unique_ptr when we want a single pointer to an object that will be reclaimed when that single pointer is destroyed.\n\nThe below code returns a resource and if we don’t explicitly capture the return value, the resource will be cleaned up. If we do, then we have exclusive ownership of that resource. In this way, we can think of unique_ptr as a safer and better replacement for auto_ptr.\n\nWhen to use unique_ptr?\n\nUse unique_ptr when you want to have single ownership(Exclusive) of the resource. Only one unique_ptr can point to one resource. Since there can be one unique_ptr for a single resource it’s not possible to copy one unique_ptr to another.\n\nA shared_ptr is a container for raw pointers. It is a reference counting ownership model i.e. it maintains the reference count of its contained pointer in cooperation with all copies of the shared_ptr. So, the counter is incremented each time a new pointer points to the resource and decremented when the destructor of the object is called.\n\nReference Counting: It is a technique of storing the number of references, pointers, or handles to a resource such as an object, block of memory, disk space, or other resources. An object referenced by the contained raw pointer will not be destroyed until the reference count is greater than zero i.e. until all copies of shared_ptr have been deleted. So, we should use shared_ptr when we want to assign one raw pointer to multiple owners.\n\nWhen to use shared_ptr?\n\nUse shared_ptr if you want to share ownership of a resource. Many shared_ptr can point to a single resource. shared_ptr maintains the reference count for this proposal. when all shared_ptr’s pointing to a resource goes out of scope the resource is destroyed.\n\nA weak_ptr is created as a copy of shared_ptr. It provides access to an object that is owned by one or more shared_ptr instances but does not participate in reference counting. The existence or destruction of weak_ptr has no effect on the shared_ptr or its other copies. It is required in some cases to break circular references between shared_ptr instances.\n\nCyclic Dependency (Problems with shared_ptr): Let’s consider a scenario where we have two classes A and B, and both have pointers to other classes. So, it’s always like A is pointing to B and B is pointing to A. Hence, use_count will never reach zero and they never get deleted.\n\nThis is the reason we use weak pointers(weak_ptr) as they are not reference counted. So, the class in which weak_ptr is declared doesn’t have a stronghold over it i.e. the ownership isn’t shared, but they can have access to these objects.\n\nSo, in the case of shared_ptr because of cyclic dependency use_count never reaches zero which is prevented by using weak_ptr, which removes this problem by declaring A_ptr as weak_ptr, thus class A does not own it, only has access to it and we also need to check the validity of object as it may go out of scope. In general, it is a design issue.\n\nWhen to use weak_ptr?\n\nWhen you do want to refer to your object from multiple places – for those references for which it’s ok to ignore and deallocate (so they’ll just note the object is gone when you try to dereference)."
    }
]