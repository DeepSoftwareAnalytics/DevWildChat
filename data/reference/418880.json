[
    {
        "link": "https://numpy.org/doc/2.2/user/absolute_beginners.html",
        "document": "Welcome to the absolute beginner’s guide to NumPy!\n\nNumPy (Numerical Python) is an open source Python library that’s widely used in science and engineering. The NumPy library contains multidimensional array data structures, such as the homogeneous, N-dimensional , and a large library of functions that operate efficiently on these data structures. Learn more about NumPy at What is NumPy, and if you have comments or suggestions, please reach out!\n\nOne way to initialize an array is using a Python sequence, such as a list. For example: Elements of an array can be accessed in various ways. For instance, we can access an individual element of this array as we would access an element in the original list: using the integer index of the element within square brackets. As with built-in Python sequences, NumPy arrays are “0-indexed”: the first element of the array is accessed using index , not . Like the original list, the array is mutable. Also like the original list, Python slice notation can be used for indexing. One major difference is that slice indexing of a list copies the elements into a new list, but slicing an array returns a view: an object that refers to the data in the original array. The original array can be mutated using the view. See Copies and views for a more comprehensive explanation of when array operations return views rather than copies. Two- and higher-dimensional arrays can be initialized from nested Python sequences: In NumPy, a dimension of an array is sometimes referred to as an “axis”. This terminology may be useful to disambiguate between the dimensionality of an array and the dimensionality of the data represented by the array. For instance, the array could represent three points, each lying within a four-dimensional space, but has only two “axes”. Another difference between an array and a list of lists is that an element of the array can be accessed by specifying the index along each axis within a single set of square brackets, separated by commas. For instance, the element is in row and column : It is familiar practice in mathematics to refer to elements of a matrix by the row index first and the column index second. This happens to be true for two-dimensional arrays, but a better mental model is to think of the column index as coming last and the row index as second to last. This generalizes to arrays with any number of dimensions. You might hear of a 0-D (zero-dimensional) array referred to as a “scalar”, a 1-D (one-dimensional) array as a “vector”, a 2-D (two-dimensional) array as a “matrix”, or an N-D (N-dimensional, where “N” is typically an integer greater than 2) array as a “tensor”. For clarity, it is best to avoid the mathematical terms when referring to an array because the mathematical objects with these names behave differently than arrays (e.g. “matrix” multiplication is fundamentally different from “array” multiplication), and there are other objects in the scientific Python ecosystem that have these names (e.g. the fundamental data structure of PyTorch is the “tensor”).\n\nCan you reshape an array?# Using will give a new shape to an array without changing the data. Just remember that when you use the reshape method, the array you want to produce needs to have the same number of elements as the original array. If you start with an array with 12 elements, you’ll need to make sure that your new array also has a total of 12 elements. If you start with this array: You can use to reshape your array. For example, you can reshape this array to an array with three rows and two columns: With , you can specify a few optional parameters: is the array to be reshaped. is the new shape you want. You can specify an integer or a tuple of integers. If you specify an integer, the result will be an array of that length. The shape should be compatible with the original shape. means to read/write the elements using C-like index order, means to read/write the elements using Fortran-like index order, means to read/write the elements in Fortran-like index order if a is Fortran contiguous in memory, C-like order otherwise. (This is an optional parameter and doesn’t need to be specified.) If you want to learn more about C and Fortran order, you can read more about the internal organization of NumPy arrays here. Essentially, C and Fortran orders have to do with how indices correspond to the order the array is stored in memory. In Fortran, when moving through the elements of a two-dimensional array as it is stored in memory, the first index is the most rapidly varying index. As the first index moves to the next row as it changes, the matrix is stored one column at a time. This is why Fortran is thought of as a Column-major language. In C on the other hand, the last index changes the most rapidly. The matrix is stored by rows, making it a Row-major language. What you do for C or Fortran depends on whether it’s more important to preserve the indexing convention or not reorder the data. Learn more about shape manipulation here.\n\nYou can index and slice NumPy arrays in the same ways you can slice Python lists. You can visualize it this way: You may want to take a section of your array or specific array elements to use in further analysis or additional operations. To do that, you’ll need to subset, slice, and/or index your arrays. If you want to select values from your array that fulfill certain conditions, it’s straightforward with NumPy. For example, if you start with this array: You can easily print all of the values in the array that are less than 5. You can also select, for example, numbers that are equal to or greater than 5, and use that condition to index an array. You can select elements that are divisible by 2: Or you can select elements that satisfy two conditions using the and operators: You can also make use of the logical operators & and | in order to return boolean values that specify whether or not the values in an array fulfill a certain condition. This can be useful with arrays that contain names or other categorical values. You can also use to select elements or indices from an array. You can use to print the indices of elements that are, for example, less than 5: In this example, a tuple of arrays was returned: one for each dimension. The first array represents the row indices where these values are found, and the second array represents the column indices where the values are found. If you want to generate a list of coordinates where the elements exist, you can zip the arrays, iterate over the list of coordinates, and print them. For example: You can also use to print the elements in an array that are less than 5 with: If the element you’re looking for doesn’t exist in the array, then the returned array of indices will be empty. For example: Learn more about indexing and slicing here and here. Read more about using the nonzero function at: .\n\nHow to create an array from existing data# You can easily create a new array from a section of an existing array. Let’s say you have this array: You can create a new array from a section of your array any time by specifying where you want to slice your array. Here, you grabbed a section of your array from index position 3 through index position 8 but not including position 8 itself. Reminder: Array indexes begin at 0. This means the first element of the array is at index 0, the second element is at index 1, and so on. You can also stack two existing arrays, both vertically and horizontally. Let’s say you have two arrays, and : You can stack them vertically with : Or stack them horizontally with : You can split an array into several smaller arrays using . You can specify either the number of equally shaped arrays to return or the columns after which the division should occur. Let’s say you have this array: If you wanted to split this array into three equally shaped arrays, you would run: If you wanted to split your array after the third and fourth column, you’d run: Learn more about stacking and splitting arrays here. You can use the method to create a new array object that looks at the same data as the original array (a shallow copy). Views are an important NumPy concept! NumPy functions, as well as operations like indexing and slicing, will return views whenever possible. This saves memory and is faster (no copy of the data has to be made). However it’s important to be aware of this - modifying data in a view also modifies the original array! Let’s say you create this array: Now we create an array by slicing and modify the first element of . This will modify the corresponding element in as well! Using the method will make a complete copy of the array and its data (a deep copy). To use this on your array, you could run: Learn more about copies and views here.\n\nHow to access the docstring for more information# When it comes to the data science ecosystem, Python and NumPy are built with the user in mind. One of the best examples of this is the built-in access to documentation. Every object contains the reference to a string, which is known as the docstring. In most cases, this docstring contains a quick and concise summary of the object and how to use it. Python has a built-in function that can help you access this information. This means that nearly any time you need more information, you can use to quickly find the information that you need. Help on built-in function max in module builtins: With a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if With two or more arguments, return the largest argument. Because access to additional information is so useful, IPython uses the character as a shorthand for accessing this documentation along with other relevant information. IPython is a command shell for interactive computing in multiple languages. You can find more information about IPython here. max With a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if With two or more arguments, return the largest argument. You can even use this notation for object methods and objects themselves. Let’s say you create this array: Then you can obtain a lot of useful information (first details about itself, followed by the docstring of of which is an instance): a of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, Arrays should be constructed using `array`, `zeros` or `empty` (refer to the See Also section below). The parameters given here refer to For more information, refer to the `numpy` module and examine the methods and attributes of an array. This also works for functions and other objects that you create. Just remember to include a docstring with your function using a string literal ( or around your documentation). For example, if you create this function: You can obtain information about the function: You can reach another level of information by reading the source code of the object you’re interested in. Using a double question mark ( ) allows you to access the source code. If the object in question is compiled in a language other than Python, using will return the same information as . You’ll find this with a lot of built-in objects and types, for example: len Docstring: Return the number of items in a container. len Docstring: Return the number of items in a container. have the same output because they were compiled in a programming language other than Python.\n\nHow to save and load NumPy objects# You will, at some point, want to save your arrays to disk and load them back without having to re-run the code. Fortunately, there are several ways to save and load objects with NumPy. The ndarray objects can be saved to and loaded from the disk files with and functions that handle normal text files, and functions that handle NumPy binary files with a .npy file extension, and a function that handles NumPy files with a .npz file extension. The .npy and .npz files store data, shape, dtype, and other information required to reconstruct the ndarray in a way that allows the array to be correctly retrieved, even when the file is on another machine with different architecture. If you want to store a single ndarray object, store it as a .npy file using . If you want to store more than one ndarray object in a single file, save it as a .npz file using . You can also save several arrays into a single file in compressed npz format with . It’s easy to save and load an array with . Just make sure to specify the array you want to save and a file name. For example, if you create this array: You can save it as “filename.npy” with: You can use to reconstruct your array. If you want to check your array, you can run: You can save a NumPy array as a plain text file like a .csv or .txt file with . For example, if you create this array: You can easily save it as a .csv file with the name “new_file.csv” like this: You can quickly and easily load your saved text file using : The and functions accept additional optional parameters such as header, footer, and delimiter. While text files can be easier for sharing, .npy and .npz files are smaller and faster to read. If you need more sophisticated handling of your text file (for example, if you need to work with lines that contain missing values), you will want to use the function. With , you can specify headers, footers, comments, and more. Learn more about input and output routines here."
    },
    {
        "link": "https://numpy.org/devdocs/user/absolute_beginners.html",
        "document": "Welcome to the absolute beginner’s guide to NumPy!\n\nNumPy (Numerical Python) is an open source Python library that’s widely used in science and engineering. The NumPy library contains multidimensional array data structures, such as the homogeneous, N-dimensional , and a large library of functions that operate efficiently on these data structures. Learn more about NumPy at What is NumPy, and if you have comments or suggestions, please reach out!\n\nOne way to initialize an array is using a Python sequence, such as a list. For example: Elements of an array can be accessed in various ways. For instance, we can access an individual element of this array as we would access an element in the original list: using the integer index of the element within square brackets. As with built-in Python sequences, NumPy arrays are “0-indexed”: the first element of the array is accessed using index , not . Like the original list, the array is mutable. Also like the original list, Python slice notation can be used for indexing. One major difference is that slice indexing of a list copies the elements into a new list, but slicing an array returns a view: an object that refers to the data in the original array. The original array can be mutated using the view. See Copies and views for a more comprehensive explanation of when array operations return views rather than copies. Two- and higher-dimensional arrays can be initialized from nested Python sequences: In NumPy, a dimension of an array is sometimes referred to as an “axis”. This terminology may be useful to disambiguate between the dimensionality of an array and the dimensionality of the data represented by the array. For instance, the array could represent three points, each lying within a four-dimensional space, but has only two “axes”. Another difference between an array and a list of lists is that an element of the array can be accessed by specifying the index along each axis within a single set of square brackets, separated by commas. For instance, the element is in row and column : It is familiar practice in mathematics to refer to elements of a matrix by the row index first and the column index second. This happens to be true for two-dimensional arrays, but a better mental model is to think of the column index as coming last and the row index as second to last. This generalizes to arrays with any number of dimensions. You might hear of a 0-D (zero-dimensional) array referred to as a “scalar”, a 1-D (one-dimensional) array as a “vector”, a 2-D (two-dimensional) array as a “matrix”, or an N-D (N-dimensional, where “N” is typically an integer greater than 2) array as a “tensor”. For clarity, it is best to avoid the mathematical terms when referring to an array because the mathematical objects with these names behave differently than arrays (e.g. “matrix” multiplication is fundamentally different from “array” multiplication), and there are other objects in the scientific Python ecosystem that have these names (e.g. the fundamental data structure of PyTorch is the “tensor”).\n\nCan you reshape an array?# Using will give a new shape to an array without changing the data. Just remember that when you use the reshape method, the array you want to produce needs to have the same number of elements as the original array. If you start with an array with 12 elements, you’ll need to make sure that your new array also has a total of 12 elements. If you start with this array: You can use to reshape your array. For example, you can reshape this array to an array with three rows and two columns: With , you can specify a few optional parameters: is the array to be reshaped. is the new shape you want. You can specify an integer or a tuple of integers. If you specify an integer, the result will be an array of that length. The shape should be compatible with the original shape. means to read/write the elements using C-like index order, means to read/write the elements using Fortran-like index order, means to read/write the elements in Fortran-like index order if a is Fortran contiguous in memory, C-like order otherwise. (This is an optional parameter and doesn’t need to be specified.) If you want to learn more about C and Fortran order, you can read more about the internal organization of NumPy arrays here. Essentially, C and Fortran orders have to do with how indices correspond to the order the array is stored in memory. In Fortran, when moving through the elements of a two-dimensional array as it is stored in memory, the first index is the most rapidly varying index. As the first index moves to the next row as it changes, the matrix is stored one column at a time. This is why Fortran is thought of as a Column-major language. In C on the other hand, the last index changes the most rapidly. The matrix is stored by rows, making it a Row-major language. What you do for C or Fortran depends on whether it’s more important to preserve the indexing convention or not reorder the data. Learn more about shape manipulation here.\n\nYou can index and slice NumPy arrays in the same ways you can slice Python lists. You can visualize it this way: You may want to take a section of your array or specific array elements to use in further analysis or additional operations. To do that, you’ll need to subset, slice, and/or index your arrays. If you want to select values from your array that fulfill certain conditions, it’s straightforward with NumPy. For example, if you start with this array: You can easily print all of the values in the array that are less than 5. You can also select, for example, numbers that are equal to or greater than 5, and use that condition to index an array. You can select elements that are divisible by 2: Or you can select elements that satisfy two conditions using the and operators: You can also make use of the logical operators & and | in order to return boolean values that specify whether or not the values in an array fulfill a certain condition. This can be useful with arrays that contain names or other categorical values. You can also use to select elements or indices from an array. You can use to print the indices of elements that are, for example, less than 5: In this example, a tuple of arrays was returned: one for each dimension. The first array represents the row indices where these values are found, and the second array represents the column indices where the values are found. If you want to generate a list of coordinates where the elements exist, you can zip the arrays, iterate over the list of coordinates, and print them. For example: You can also use to print the elements in an array that are less than 5 with: If the element you’re looking for doesn’t exist in the array, then the returned array of indices will be empty. For example: Learn more about indexing and slicing here and here. Read more about using the nonzero function at: .\n\nHow to create an array from existing data# You can easily create a new array from a section of an existing array. Let’s say you have this array: You can create a new array from a section of your array any time by specifying where you want to slice your array. Here, you grabbed a section of your array from index position 3 through index position 8 but not including position 8 itself. Reminder: Array indexes begin at 0. This means the first element of the array is at index 0, the second element is at index 1, and so on. You can also stack two existing arrays, both vertically and horizontally. Let’s say you have two arrays, and : You can stack them vertically with : Or stack them horizontally with : You can split an array into several smaller arrays using . You can specify either the number of equally shaped arrays to return or the columns after which the division should occur. Let’s say you have this array: If you wanted to split this array into three equally shaped arrays, you would run: If you wanted to split your array after the third and fourth column, you’d run: Learn more about stacking and splitting arrays here. You can use the method to create a new array object that looks at the same data as the original array (a shallow copy). Views are an important NumPy concept! NumPy functions, as well as operations like indexing and slicing, will return views whenever possible. This saves memory and is faster (no copy of the data has to be made). However it’s important to be aware of this - modifying data in a view also modifies the original array! Let’s say you create this array: Now we create an array by slicing and modify the first element of . This will modify the corresponding element in as well! Using the method will make a complete copy of the array and its data (a deep copy). To use this on your array, you could run: Learn more about copies and views here.\n\nHow to access the docstring for more information# When it comes to the data science ecosystem, Python and NumPy are built with the user in mind. One of the best examples of this is the built-in access to documentation. Every object contains the reference to a string, which is known as the docstring. In most cases, this docstring contains a quick and concise summary of the object and how to use it. Python has a built-in function that can help you access this information. This means that nearly any time you need more information, you can use to quickly find the information that you need. Help on built-in function max in module builtins: With a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if With two or more arguments, return the largest argument. Because access to additional information is so useful, IPython uses the character as a shorthand for accessing this documentation along with other relevant information. IPython is a command shell for interactive computing in multiple languages. You can find more information about IPython here. max With a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if With two or more arguments, return the largest argument. You can even use this notation for object methods and objects themselves. Let’s say you create this array: Then you can obtain a lot of useful information (first details about itself, followed by the docstring of of which is an instance): a of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, Arrays should be constructed using `array`, `zeros` or `empty` (refer to the See Also section below). The parameters given here refer to For more information, refer to the `numpy` module and examine the methods and attributes of an array. This also works for functions and other objects that you create. Just remember to include a docstring with your function using a string literal ( or around your documentation). For example, if you create this function: You can obtain information about the function: You can reach another level of information by reading the source code of the object you’re interested in. Using a double question mark ( ) allows you to access the source code. If the object in question is compiled in a language other than Python, using will return the same information as . You’ll find this with a lot of built-in objects and types, for example: len Docstring: Return the number of items in a container. len Docstring: Return the number of items in a container. have the same output because they were compiled in a programming language other than Python.\n\nHow to save and load NumPy objects# You will, at some point, want to save your arrays to disk and load them back without having to re-run the code. Fortunately, there are several ways to save and load objects with NumPy. The ndarray objects can be saved to and loaded from the disk files with and functions that handle normal text files, and functions that handle NumPy binary files with a .npy file extension, and a function that handles NumPy files with a .npz file extension. The .npy and .npz files store data, shape, dtype, and other information required to reconstruct the ndarray in a way that allows the array to be correctly retrieved, even when the file is on another machine with different architecture. If you want to store a single ndarray object, store it as a .npy file using . If you want to store more than one ndarray object in a single file, save it as a .npz file using . You can also save several arrays into a single file in compressed npz format with . It’s easy to save and load an array with . Just make sure to specify the array you want to save and a file name. For example, if you create this array: You can save it as “filename.npy” with: You can use to reconstruct your array. If you want to check your array, you can run: You can save a NumPy array as a plain text file like a .csv or .txt file with . For example, if you create this array: You can easily save it as a .csv file with the name “new_file.csv” like this: You can quickly and easily load your saved text file using : The and functions accept additional optional parameters such as header, footer, and delimiter. While text files can be easier for sharing, .npy and .npz files are smaller and faster to read. If you need more sophisticated handling of your text file (for example, if you need to work with lines that contain missing values), you will want to use the function. With , you can specify headers, footers, comments, and more. Learn more about input and output routines here."
    },
    {
        "link": "https://w3schools.com/python/numpy/numpy_creating_arrays.asp",
        "document": "NumPy is used to work with arrays. The array object in NumPy is called .\n\nWe can create a NumPy object by using the function.\n\nTo create an , we can pass a list, tuple or any array-like object into the method, and it will be converted into an :\n\nA dimension in arrays is one level of array depth (nested arrays).\n\n0-D arrays, or Scalars, are the elements in an array. Each value in an array is a 0-D array.\n\nAn array that has 0-D arrays as its elements is called uni-dimensional or 1-D array.\n\nThese are the most common and basic arrays.\n\nAn array that has 1-D arrays as its elements is called a 2-D array.\n\nThese are often used to represent matrix or 2nd order tensors.\n\nAn array that has 2-D arrays (matrices) as its elements is called 3-D array.\n\nThese are often used to represent a 3rd order tensor.\n\nNumPy Arrays provides the attribute that returns an integer that tells us how many dimensions the array have.\n\nAn array can have any number of dimensions.\n\nWhen the array is created, you can define the number of dimensions by using the argument.\n\nIn this array the innermost dimension (5th dim) has 4 elements, the 4th dim has 1 element that is the vector, the 3rd dim has 1 element that is the matrix with the vector, the 2nd dim has 1 element that is 3D array and 1st dim has 1 element that is a 4D array."
    },
    {
        "link": "https://stackoverflow.com/questions/28628773/how-to-generate-2d-numpy-array",
        "document": "I'm trying to generate a 2d numpy array with the help of generators:\n\nAnd if I try to do something like this:\n\nI, as expected, get a np.array of np.array. But I want not this, but ndarray, so I can get, for example, column in a way like this:\n\nSo, I'm curious whether there is a way to generate it in such a way.\n\nOf course it is possible with creating npdarray of required size and filling it with required values, but I want a way to do so in a line of code."
    },
    {
        "link": "https://stackoverflow.com/questions/54696566/creating-a-2d-numpy-array-python",
        "document": "For questions like these, the docs can be really useful. Check them out here:\n\nPay attention to the input to . It is one list, containing 2 lists of equal length.\n\nLook at the docs. See what says about raveling? It is joining one (3,) array to another, the result is (6,).\n\nis poorly named and often misused. It is not a drop in substitute for list append. For one thing it does not operate inplace.\n\nIn your , you get error because it expects an axis number as the 2nd argument. Reread the docs. You need to give a list of the arrays you want to join. may have misled.\n\nThe correct way to use :\n\nBut since both inputs are (3,), they can only be joined on the 0 axis, making a (6,) shape.\n\nhas a similar problem. The 2nd argument is supposed to be a dtype, not another array. You used correctly the first time.\n\njoins the components along a new axis. It's treating the list of arrays in basically the same as your original list of lists.\n\nis a useful frontend for , which behaves like (with a little more flexibility in the use of axis):"
    },
    {
        "link": "https://freecodecamp.org/news/multi-dimensional-arrays-in-python",
        "document": "Multi-dimensional arrays, also known as matrices, are a powerful data structure in Python. They allow you to store and manipulate data in multiple dimensions or axes.\n\nYou'll commonly use these types of arrays in fields such as mathematics, statistics, and computer science to represent and process structured data, such as images, videos, and scientific data.\n\nIn Python, you can create multi-dimensional arrays using various libraries, such as NumPy, Pandas, and TensorFlow. In this article, we will focus on NumPy, which is one of the most popular and widely used libraries for working with arrays in Python.\n\nNumPy provides a powerful N-dimensional array object that you can use to create and manipulate multi-dimensional arrays efficiently. We'll now look at some examples of how to create and work with multi-dimensional arrays in Python using NumPy.\n\nHow to Create Multi-Dimensional Arrays Using NumPy\n\nTo create a multi-dimensional array using NumPy, we can use the function and pass in a nested list of values as an argument. The outer list represents the rows of the array, and the inner lists represent the columns.\n\nHere is an example of how to create a 2-dimensional array using NumPy:\n\nIn this example, we first import the NumPy library using the statement. Then, we create a 2-dimensional array using the function and pass in a list of lists as an argument. Each inner list represents a row of the array, and the outer list contains all the rows. Finally, we print the array using the function.\n\nNumPy also provides other functions to create multi-dimensional arrays, such as , , and . You can use these functions to create arrays of specific shapes and sizes with default or random values.\n\nHow to Access and Modify Multi-dimensional Arrays Using NumPy\n\nOnce we have created a multi-dimensional array, we can access and modify its elements using indexing and slicing. We use the index notation to access an element at row and column , where and are zero-based indices.\n\nHere's an example of how to access and modify elements of a 2-dimensional array using NumPy:\n\nIn this example, we create a 2-dimensional array using the function, and then access an element at row 1, column 2 using indexing. We then modify an element at row 0, column 3 using indexing again. Finally, we print the modified array using the function.\n\nWe can also use slicing to access and modify multiple elements of a multi-dimensional array at once. We use the slice notation to access a subarray that contains rows through and columns through .\n\nHere's an example of how to use slicing to access and modify elements of a 2-dimensional array using NumPy:\n\nIn this example, we create a 2-dimensional array using the function, and then use slicing to access a subarray that contains rows 0 through 1 and columns 1 through 2. We then modify the subarray by multiplying it by 2, and print the modified original array using the function.\n\nHow to Perform Operations on Multi-dimensional Arrays\n\nNumPy provides a wide range of mathematical and statistical functions that you can use to perform operations on multi-dimensional arrays efficiently. These functions can help you perform element-wise operations, matrix operations, and other operations on arrays with different shapes and sizes.\n\nHere's an example of how to perform some common operations on a 2-dimensional array using NumPy:\n\nIn this example, we create a 2-dimensional array using the function, and then use various NumPy functions to perform operations on the array.\n\nWe first calculate the sum of all elements using the function. We then calculate the mean of each row using the function and specify the parameter to calculate the mean along each row. Finally, we calculate the dot product of the 2-dimensional array and another 2-dimensional array using the function.\n\nMulti-dimensional arrays are a powerful and important data structure in Python. They allow us to store and manipulate large amounts of data efficiently.\n\nIn this article, we have covered the basics of creating and manipulating multi-dimensional arrays using NumPy in Python. We have also looked at some common operations that we can perform on multi-dimensional arrays using NumPy functions.\n\nWith the knowledge gained from this article, you should now be able to create and manipulate multi-dimensional arrays to suit your specific needs in Python."
    },
    {
        "link": "https://stackoverflow.com/questions/57520683/best-practice-for-multidimensional-arrays-in-python",
        "document": "Suppose I have a collection of objects which I wish to save in python, say, a list of numbers: [0.12, 0.85, 0.11, 0.12], [0.23, 0.52, 0.10, 0.19], etc. Suppose further that these objects are indexed by 3 attributes, say, \"origin\", \"destination\", and \"month\". I wish to store these objects in an array-like object which can be easily sliced, ideally using either numerical index or a name.\n\nI'm looking for the best practice to achieve this in python. I did find this post, which seems quite suitable, but it seemed to require some overhead and there was little discussion of alternatives. I also found something called the xarray package, though this doesn't seem as popular. I am transitioning form R, where I would do this the array() function, which adds a multi-dimensional index to any vector-like structure."
    },
    {
        "link": "https://stackoverflow.com/questions/34070490/what-is-the-best-way-to-do-multi-dimensional-indexing-with-numpy",
        "document": "I am trying to do some indexing on a 3D numpy array. Basically I have an array which has shape ; for example . Generated, for example as follows:\n\nMy goal is to be able to index over and , with a 2D array such as , which means take the values indexed by 0 in the 3rd dimension, for the the first position in , the values indexed by 1 in the 3rd dimension for the second position of and so on. The result should have a shape that is or .\n\nThis would be equivalent to manually cycling all the values of the \"indexer array\" such as:\n\nIntuitively I would do something like , but it's shape ends up being .\n\nAny ideas on how to obtain the correct result?"
    },
    {
        "link": "https://numpy.org/doc/stable/reference/arrays.ndarray.html",
        "document": "An is a (usually fixed-size) multidimensional container of items of the same type and size. The number of dimensions and items in an array is defined by its , which is a of N non-negative integers that specify the sizes of each dimension. The type of items in the array is specified by a separate data-type object (dtype), one of which is associated with each ndarray.\n\nAs with other container objects in Python, the contents of an can be accessed and modified by indexing or slicing the array (using, for example, N integers), and via the methods and attributes of the .\n\nDifferent can share the same data, so that changes made in one may be visible in another. That is, an ndarray can be a “view” to another ndarray, and the data it is referring to is taken care of by the “base” ndarray. ndarrays can also be views to memory owned by Python or objects implementing the or array interfaces.\n\nAn instance of class consists of a contiguous one-dimensional segment of computer memory (owned by the array, or by some other object), combined with an indexing scheme that maps N integers into the location of an item in the block. The ranges in which the indices can vary is specified by the of the array. How many bytes each item takes and how the bytes are interpreted is defined by the data-type object associated with the array. A segment of memory is inherently 1-dimensional, and there are many different schemes for arranging the items of an N-dimensional array in a 1-dimensional block. NumPy is flexible, and objects can accommodate any strided indexing scheme. In a strided scheme, the N-dimensional index \\((n_0, n_1, ..., n_{N-1})\\) corresponds to the offset (in bytes): from the beginning of the memory block associated with the array. Here, \\(s_k\\) are integers which specify the of the array. The column-major order (used, for example, in the Fortran language and in Matlab) and row-major order (used in C) schemes are just specific kinds of strided scheme, and correspond to memory that can be addressed by the strides: Both the C and Fortran orders are contiguous, i.e., single-segment, memory layouts, in which every part of the memory block can be accessed by some combination of the indices. Contiguous arrays and single-segment arrays are synonymous and are used interchangeably throughout the documentation. While a C-style and Fortran-style contiguous array, which has the corresponding flags set, can be addressed with the above strides, the actual strides may be different. This can happen in two cases:\n• None If then for any legal index . This means that in the formula for the offset \\(n_k = 0\\) and thus \\(s_k n_k = 0\\) and the value of \\(s_k\\) = self.strides[k] is arbitrary.\n• None If an array has no elements ( ) there is no legal index and the strides are never used. Any array with no elements may be considered C-style and Fortran-style contiguous. Point 1. means that and always have the same contiguity and flags value. This also means that even a high dimensional array could be C-style and Fortran-style contiguous at the same time. An array is considered aligned if the memory offsets for all elements and the base offset itself is a multiple of . Understanding memory-alignment leads to better performance on most hardware. It does not generally hold that for C-style contiguous arrays or for Fortran-style contiguous arrays is true. Data in new is in the row-major (C) order, unless otherwise specified, but, for example, basic array slicing often produces views in a different scheme. Several algorithms in NumPy work on arbitrarily strided arrays. However, some algorithms require single-segment arrays. When an irregularly strided array is passed in to such algorithms, a copy is automatically made.\n\nArray attributes reflect information that is intrinsic to the array itself. Generally, accessing an array through its attributes allows you to get and sometimes set intrinsic properties of the array without creating a new array. The exposed attributes are the core parts of an array and only some of them can be reset meaningfully without creating a new array. Information on each attribute is given below. The following attributes contain information about the memory layout of the array: Information about the memory layout of the array. Tuple of bytes to step in each dimension when traversing an array. Python buffer object pointing to the start of the array's data. Number of elements in the array. Length of one array element in bytes. Total bytes consumed by the elements of the array. Base object if memory is from some other object. The data type object associated with the array can be found in the attribute: The real part of the array. The imaginary part of the array. An object to simplify the interaction of the array with the ctypes module.\n\nAn object has many methods which operate on or with the array in some fashion, typically returning an array result. These methods are briefly explained below. (Each method’s docstring has a more complete description.) For the following methods there are also corresponding functions in : , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , . Copy an element of an array to a standard Python scalar and return it. Return the array as an -levels deep nested list of Python scalars. A compatibility alias for , with exactly the same behavior. Construct Python bytes containing the raw data bytes in the array. Write array to a file as text or binary (default). Dump a pickle of the array to the specified file. Returns the pickle of the array as a string. Copy of the array, cast to a specified type. Swap the bytes of the array elements New view of array with the same data. Returns a field of the given array as a certain type. Fill the array with a scalar value. For reshape, resize, and transpose, the single tuple argument may be replaced with integers which will be interpreted as an n-tuple. Returns an array containing the same data with a new shape. Returns a view of the array with axes transposed. Return a view of the array with axis1 and axis2 interchanged. Return a copy of the array collapsed into one dimension. Remove axes of length one from a. For array methods that take an axis keyword, it defaults to None. If axis is None, then the array is treated as a 1-D array. Any other value for axis represents the dimension along which the operation should proceed. Return an array formed from the elements of a at the given indices. Set for all n in indices. Use an index array to construct a new array from a set of choices. Returns the indices that would sort this array. Partially sorts the elements in the array in such a way that the value of the element in k-th position is in the position it would be in a sorted array. Returns the indices that would partition this array. Find indices where elements of v should be inserted in a to maintain order. Return the indices of the elements that are non-zero. Return selected slices of this array along given axis. Many of these methods take an argument named axis. In such cases,\n• None If axis is None (the default), the array is treated as a 1-D array and the operation is performed over the entire array. This behavior is also the default if self is a 0-dimensional array or array scalar. (An array scalar is an instance of the types/classes float32, float64, etc., whereas a 0-dimensional array is an ndarray instance containing precisely one array scalar.)\n• None If axis is an integer, then the operation is done over the given axis (for each 1-D subarray that can be created along the given axis). Example of the axis argument A 3-dimensional array of size 3 x 3 x 3, summed over each of its three axes: # for sum, axis is the first keyword, so we may omit it, # specifying only its value The parameter dtype specifies the data type over which a reduction operation (like summing) should take place. The default reduce data type is the same as the data type of self. To avoid overflow, it can be useful to perform the reduction using a larger data type. For several methods, an optional out argument can also be provided and the result will be placed into the output array given. The out argument must be an and have the same number of elements. It can have a different data type in which case casting will be performed. Return the maximum along a given axis. Return indices of the maximum values along the given axis. Return the minimum along a given axis. Return indices of the minimum values along the given axis. Return an array whose values are limited to . Return a with each element rounded to the given number of decimals. Return the sum along diagonals of the array. Return the sum of the array elements over the given axis. Return the cumulative sum of the elements along the given axis. Returns the average of the array elements along given axis. Returns the variance of the array elements, along given axis. Returns the standard deviation of the array elements along given axis. Return the product of the array elements over the given axis Return the cumulative product of the elements along the given axis. Returns True if all elements evaluate to True. Returns True if any of the elements of a evaluate to True.\n\nArithmetic and comparison operations on are defined as element-wise operations, and generally yield objects as results. Each of the arithmetic operations ( , , , , , , , or , , , , , , ) and the comparisons ( , , , , , ) is equivalent to the corresponding universal function (or ufunc for short) in NumPy. For more information, see the section on Universal Functions. Truth value of an array ( ): Truth-value testing of an array invokes , which raises an error if the number of elements in the array is not 1, because the truth value of such arrays is ambiguous. Use and instead to be clear about what is meant in such cases. (If you wish to check for whether an array is empty, use for example .)\n• None Any third argument to is silently ignored, as the underlying takes only two arguments.\n• None Because is a built-in type (written in C), the special methods are not directly defined.\n• None The functions called to implement many arithmetic special methods for arrays can be modified using . In place operations will perform the calculation using the precision decided by the data type of the two operands, but will silently downcast the result (if necessary) so it can fit back into the array. Therefore, for mixed precision calculations, can be different than . For example, suppose . Then, is different than : while they both perform the same computation, casts the result to fit back in , whereas re-binds the name to the result. Matrix operators and were introduced in Python 3.5 following PEP 465, and the operator has been introduced in NumPy 1.10.0. Further information can be found in the documentation."
    },
    {
        "link": "https://medium.com/@debopamdeycse19/numpy-multi-dimensional-arrays-and-their-operations-b14bea16aaf6",
        "document": "Hello friends, In previous articles we talked about numpy basics, and how to install Numpy on your computer then we discussed how to create numpy arrays, slicing, indexing, and much more. In today’s article, we will discuss multi-dimensional arrays in Numpy and their essential operations.\n\nMulti-dimensional arrays also known as matrices, are crucial for processing images, analyzing sensor data, and performing simulations in data science, scientific computing, and numerical analysis.\n\nHow to create a multidimensional array in Python using numpy\n\nNumPy provides various methods to create multi-dimensional arrays effortlessly. Let’s see how to create multi-dimensional arrays (2-D and 3-D).\n\nThe output will be:\n\nThere are so many methods to create an array in numpy. See the documentation to learn more.\n\nOnce multi-dimensional arrays have been formed, you frequently need to modify them. For manipulating arrays, NumPy provides a large selection of functions let's see some of them.\n• How to concatenate multidimensional arrays in numpy\n\nTwo or more arrays are combined using concatenation along an already-existing axis. For this, you can use np.concatenate(). Let's see one example:\n\nThe output will be:\n\n2. How to access different rows of a multidimensional numpy array?\n\nIndexing and slicing multi-dimensional arrays is fundamental to accessing specific elements or subsets of your data. Indexing in multi-dimensional arrays is similar to indexing in lists but with multiple dimensions. You specify the row and column indices:\n\nThe output will be:\n\nSlicing allows you to extract a subset of elements from a multi-dimensional array. You specify a range of indices along each dimension:\n\nThe output will be:\n\nA large collection of functions in NumPy are available for working with multi-dimensional arrays. These operations may be aggregated or element-wise. You can perform addition, subtraction, multiplication, and division on multidimensional arrays in Numpy.\n\nThe output will be:\n\nThe output will be:\n\nAggregation functions are used to compute statistics on multi-dimensional arrays, such as sum, mean, median, and more. Let’s see some examples:\n\nThe output will be:\n\nThe output will be:\n\nYou were given a thorough understanding of indexing and slicing multidimensional arrays, which made it possible to effectively extract particular components or subsets. Finally, we experimented with executing operations on multi-dimensional arrays, such as aggregation operations and element-wise operations.\n\n“If you learn something new from this article, please show your support by giving it a clap. Your appreciation motivates me to create more articles for you. Thank you for your encouragement!”"
    }
]