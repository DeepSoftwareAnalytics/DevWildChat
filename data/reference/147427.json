[
    {
        "link": "https://digitalocean.com/community/tutorials/java-socket-programming-server-client",
        "document": "Welcome to Java Socket programming example. Every server is a program that runs on a specific system and listens on a specific port. Sockets are bound to the port numbers and when we run any server it just listens on the socket and waits for client requests. For example, tomcat server running on port 8080 waits for client requests and once it gets any client request, it responds to them.\n\nA socket is one endpoint of a two-way communication link between two programs running on the network. The socket is bound to a port number so that the TCP layer can identify the application that data is destined to be sent. In java socket programming example tutorial, we will learn how to write java socket server and java socket client program. We will also learn how server client program read and write data on the socket. java.net.Socket and java.net.ServerSocket are the java classes that implements Socket and Socket server.\n\nTo test java socket programming of server-client communication, first we need to run class. When you will run socket server, it will just print “Waiting for client request” and then wait for the client request. Now when you will run SocketClientExample class, it will send a request to java socket server and print the response message to console. Here is the output of java socket server program.\n\nHere is the output of Java socket client program.\n\nThat’s all for a quick roundup of Socket programming in java. I hope you can get started with java socket server and java socket client programming. Reference: Oracle Doc"
    },
    {
        "link": "https://geeksforgeeks.org/socket-programming-in-java",
        "document": "Socket programming in Java allows different programs to communicate with each other over a network, whether they are running on the same machine or different ones. This article describes a very basic one-way Client and Server setup, where a Client connects, sends messages to the server and the server shows them using a socket connection. There is a lot of low-level stuff that needs to happen for these things to work but the Java API networking package (java.net) takes care of all of that, making network programming very easy for programmers.\n\nTo connect to another machine we need a socket connection. A socket connection means both machines know each other’s IP address and TCP port. The class is used to create a socket.\n• The first argument IP address of Server i.e. 127.0.0.1 is the IP address of localhost, where code will run on the single stand-alone machine.\n\nTo exchange data over a socket connection, streams are used for input and output:\n\nExample to access these streams:\n\nThe socket connection is closed explicitly once the message to the server is sent.\n\nExample: Here, in the below program the Client keeps reading input from a user and sends it to the server until “Over” is typed.\n\nExplanation: In the above example, we have created a client program that establishes a socket connection to a server using an IP address and port, enabling data exchange. The client reads messages from the user and sends them to the server until the message “Over” is entered, after which the connection is closed.\n\nTo create a server application two sockets are needed.\n• None : This socket waits for incoming client requests. It listens for connections on a specific port.\n• None : Once a connection is established, the server uses this socket to communicate with the client.\n• None Once the connection is established, you can send and receive data through the socket using streams.\n• None method is used to send data to the client.\n\nOnce communication is finished, it’s important to close the socket and the input/output streams to free up resources.\n\nExample: The below Java program demonstrate the server-side programming\n\nExplanation: In the above example, we have implemented a server that listens on a specific port, accepts a client connection, and reads messages sent by the client. The server displays the messages until “Over” is received, after which it closes the connection and terminates.\n• None Server application makes a ServerSocket on a specific port which is 5000. This starts our Server listening for client requests coming in for port 5000.\n• None Then Server makes a new Socket to communicate with the client.\n• None The accept() method blocks(just sits there) until a client connects to the server.\n• None Then we take input from the socket using getInputStream() method. Our Server keeps receiving messages until the Client sends “Over”.\n• None After we’re done we close the connection by closing the socket and the input stream.\n• None To run the Client and Server application on your machine, compile both of them. Then first run the server application and then run the Client application.\n\nOpen two windows one for Server and another for Client.\n\nFirst run the Server application as:\n\nThen run the Client application on another terminal as\n• None Messages will appear in the Server window.\n\nNotice that sending “Over” closes the connection between the Client and the Server just like said before.\n\nNote : If you’re using Eclipse or likes of such:\n• None Compile both of them on two different terminals or tabs\n• None Type messages in the Client Window which will be received and shown by the Server Window simultaneously."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/networking/sockets/index.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\ns and s provide a relatively high-level mechanism for accessing resources on the Internet. Sometimes your programs require lower-level network communication, for example, when you want to write a client-server application.\n\nIn client-server applications, the server provides some service, such as processing database queries or sending out current stock prices. The client uses the service provided by the server, either displaying database query results to the user or making stock purchase recommendations to an investor. The communication that occurs between the client and the server must be reliable. That is, no data can be dropped and it must arrive on the client side in the same order in which the server sent it.\n\nTCP provides a reliable, point-to-point communication channel that client-server applications on the Internet use to communicate with each other. To communicate over TCP, a client program and a server program establish a connection to one another. Each program binds a socket to its end of the connection. To communicate, the client and the server each reads from and writes to the socket bound to the connection.\n\nA socket is one end-point of a two-way communication link between two programs running on the network. Socket classes are used to represent the connection between a client program and a server program. The java.net package provides two classes--Socket and ServerSocket--that implement the client side of the connection and the server side of the connection, respectively.\n\nReading from and Writing to a Socket\n\nThis page contains a small example that illustrates how a client program can read from and write to a socket.\n\nThe previous page showed an example of how to write a client program that interacts with an existing server via a Socket object. This page shows you how to write a program that implements the other side of the connection—a server program."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-create-a-simple-tcp-client-server-connection-in-java",
        "document": "How to Create a simple TCP Client-Server Connection in Java?\n\nTCP can be defined as Transmission Control Protocol. This is the standard protocol for transmitting data over a network. It provides reliable, structured, and error-checked data delivery between applications running on hosts connected via an IP (Internet Protocol) network. In Java, we can create TCP client-server connections using the Socket and ServerSocket classes from the java.net package.\n\nIn this article, we will learn how to create a simple TCP client-server connection in Java.\n• None TCP client-server communication consists of two important components. These two consist of a server and more than one client.\n• None The servers receive incoming connections from clients on a specific port number using a ServerSocket.\n• None The client then connects to the port using a Socket with the server's IP address.\n• None Once the connection is created, the data can be exchanged between the server and the client using\n• TCP : Transmission Control Protocol used to transmit data over a network and can provide network communications, point-to-point communication channels and can ensure data integrity and sequencing.\n• Socket : It is the terminal connection between two devices on the network and the Socket class can represent the client-side socket and can provide a connection to the server\n• Server in that class write the main method.\n• None Create the instance of the ServerSocket and assign the port as 9090.\n• accept() method of the ServerSocket to the wait for incoming client connections.\n• None Now, we can setup the input and output streams of the client socket and read and process the client data.\n• None Send the response to the client and close the sockets.\n\nBefore client connected to the server:\n• Client in that class write the main method of the program.\n• None Create the instance of the Socket and assign the port as 9090.\n• None Setup the input and output streams and send the data to the server.\n• None Setup the receive the response from the server.\n\nBelow we can see the output received by the client in console.\n\nIn the above example, we have created a TCP connection between client and server by sending and receiving data between client and server on port 9090."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/networking/sockets/clientServer.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nThis section shows you how to write a server and the client that goes with it. The server in the client/server pair serves up Knock Knock jokes. Knock Knock jokes are favored by children and are usually vehicles for bad puns. They go like this:\n\nThe example consists of two independently running Java programs: the client program and the server program. The client program is implemented by a single class, , and is very similar to the example from the previous section. The server program is implemented by two classes: and . , which is similar to , contains the method for the server program and performs the work of listening to the port, establishing connections, and reading from and writing to the socket. The class serves up the jokes. It keeps track of the current joke, the current state (sent knock knock, sent clue, and so on), and returns the various text pieces of the joke depending on the current state. This object implements the protocol—the language that the client and server have agreed to use to communicate.\n\nThe following section looks in detail at each class in both the client and the server and then shows you how to run them.\n\nThis section walks through the code that implements the Knock Knock server program, .\n\nThe server program begins by creating a new object to listen on a specific port (see the statement in bold in the following code segment). When running this server, choose a port that is not already dedicated to some other service. For example, this command starts the server program so that it listens on port 4444:\n\nThe server program creates the object in a -with-resources statement:\n\nis a class that provides a system-independent implementation of the server side of a client/server socket connection. The constructor for throws an exception if it can't listen on the specified port (for example, the port is already being used). In this case, the has no choice but to exit.\n\nIf the server successfully binds to its port, then the object is successfully created and the server continues to the next step—accepting a connection from a client (the next statement in the -with-resources statement):\n\nThe method waits until a client starts up and requests a connection on the host and port of this server. (Let's assume that you ran the server program on the computer named .) In this example, the server is running on the port number specified by the first command-line argument. When a connection is requested and successfully established, the accept method returns a new object which is bound to the same local port and has its remote address and remote port set to that of the client. The server can communicate with the client over this new and continue to listen for client connection requests on the original This particular version of the program doesn't listen for more client connection requests. However, a modified version of the program is provided in Supporting Multiple Clients.\n\nAfter the server successfully establishes a connection with a client, it communicates with the client using this code:\n\nThis code does the following:\n• Gets the socket's input and output stream and opens readers and writers on them.\n• Initiates communication with the client by writing to the socket (shown in bold).\n• Communicates with the client by reading from and writing to the socket (the loop).\n\nStep 1 is already familiar. Step 2 is shown in bold and is worth a few comments. The bold statements in the code segment above initiate the conversation with the client. The code creates a object—the object that keeps track of the current joke, the current state within the joke, and so on.\n\nAfter the is created, the code calls 's method to get the first message that the server sends to the client. For this example, the first thing that the server says is \"Knock! Knock!\" Next, the server writes the information to the connected to the client socket, thereby sending the message to the client.\n\nStep 3 is encoded in the loop. As long as the client and server still have something to say to each other, the server reads from and writes to the socket, sending messages back and forth between the client and the server.\n\nThe server initiated the conversation with a \"Knock! Knock!\" so afterwards the server must wait for the client to say \"Who's there?\" As a result, the loop iterates on a read from the input stream. The method waits until the client responds by writing something to its output stream (the server's input stream). When the client responds, the server passes the client's response to the object and asks the object for a suitable reply. The server immediately sends the reply to the client via the output stream connected to the socket, using a call to println. If the server's response generated from the object is \"Bye.\" this indicates that the client doesn't want any more jokes and the loop quits.\n\nThe Java runtime automatically closes the input and output streams, the client socket, and the server socket because they have been created in the -with-resources statement.\n\nThe class implements the protocol that the client and server use to communicate. This class keeps track of where the client and the server are in their conversation and serves up the server's response to the client's statements. The object contains the text of all the jokes and makes sure that the client gives the proper response to the server's statements. It wouldn't do to have the client say \"Dexter who?\" when the server says \"Knock! Knock!\"\n\nAll client/server pairs must have some protocol by which they speak to each other; otherwise, the data that passes back and forth would be meaningless. The protocol that your own clients and servers use depends entirely on the communication required by them to accomplish the task.\n\nThe class implements the client program that speaks to the . is based on the program in the previous section, Reading from and Writing to a Socket and should be somewhat familiar to you. But we'll go over the program anyway and look at what's happening in the client in the context of what's going on in the server.\n\nWhen you start the client program, the server should already be running and listening to the port, waiting for a client to request a connection. So, the first thing the client program does is to open a socket that is connected to the server running on the specified host name and port:\n\nWhen creating its socket, the example uses the host name of the first command-line argument, the name of the computer on your network that is running the server program .\n\nThe example uses the second command-line argument as the port number when creating its socket. This is a remote port number—the number of a port on the server computer—and is the port to which is listening. For example, the following command runs the example with as the name of the computer that is running the server program and 4444 as the remote port number:\n\nThe client's socket is bound to any available local port—a port on the client computer. Remember that the server gets a new socket as well. If you run the example with the command-line arguments in the previous example, then this socket is bound to local port number 4444 on the computer from which you ran the example. The server's socket and the client's socket are connected.\n\nNext comes the loop that implements the communication between the client and the server. The server speaks first, so the client must listen first. The client does this by reading from the input stream attached to the socket. If the server does speak, it says \"Bye.\" and the client exits the loop. Otherwise, the client displays the text to the standard output and then reads the response from the user, who types into the standard input. After the user types a carriage return, the client sends the text to the server through the output stream attached to the socket.\n\nThe communication ends when the server asks if the client wishes to hear another joke, the client says no, and the server says \"Bye.\"\n\nThe client automatically closes its input and output streams and the socket because they were created in the -with-resources statement.\n\nYou must start the server program first. To do this, run the server program using the Java interpreter, just as you would any other Java application. Specify as a command-line argument the port number on which the server program listens:\n\nNext, run the client program. Note that you can run the client on any computer on your network; it does not have to run on the same computer as the server. Specify as command-line arguments the host name and the port number of the computer running the server program:\n\nIf you are too quick, you might start the client before the server has a chance to initialize itself and begin listening on the port. If this happens, you will see a stack trace from the client. If this happens, just restart the client.\n\nIf you try to start a second client while the first client is connected to the server, the second client just hangs. The next section, Supporting Multiple Clients, talks about supporting multiple clients.\n\nWhen you successfully get a connection between the client and server, you will see the following text displayed on your screen:\n\nNow, you must respond with:\n\nThe client echoes what you type and sends the text to the server. The server responds with the first line of one of the many Knock Knock jokes in its repertoire. Now your screen should contain this (the text you typed is in bold):\n\nNow, you respond with:\n\nAgain, the client echoes what you type and sends the text to the server. The server responds with the punch line. Now your screen should contain this:\n\nIf you want to hear another joke, type y; if not, type n. If you type y, the server begins again with \"Knock! Knock!\" If you type n, the server says \"Bye.\" thus causing both the client and the server to exit.\n\nIf at any point you make a typing mistake, the object catches it and the server responds with a message similar to this:\n\nThe server then starts the joke over again:\n\nNote that the object is particular about spelling and punctuation but not about capitalization.\n\nTo keep the example simple, we designed it to listen for and handle a single connection request. However, multiple client requests can come into the same port and, consequently, into the same . Client connection requests are queued at the port, so the server must accept the connections sequentially. However, the server can service them simultaneously through the use of threads—one thread per each client connection.\n\nThe basic flow of logic in such a server is this:\n\nThe thread reads from and writes to the client connection as necessary."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html",
        "document": "Reads text from a character-input stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines.\n\nThe buffer size may be specified, or the default size may be used. The default is large enough for most purposes.\n\nIn general, each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream. It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders. For example,\n\nwill buffer the input from the specified file. Without buffering, each invocation of read() or readLine() could cause bytes to be read from the file, converted into characters, and then returned, which can be very inefficient.\n\nPrograms that use DataInputStreams for textual input can be localized by replacing each DataInputStream with an appropriate BufferedReader."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api?java/io/BufferedReader.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://medium.com/@AlexanderObregon/javas-bufferedreader-lines-method-explained-1cdc1db4b7b2",
        "document": "Processing large files efficiently is an important part of many Java applications. The method, part of the package, provides a simple and efficient way to read lines from a file as a stream. This article explains how the method works, discusses its practical applications such as filtering log files, and explores its integration with the Java Stream API.\n\nThe method is a feature of the class in Java. It returns a where each element represents a line from the underlying data source. This method is particularly useful for processing text data, such as reading files, handling log entries, or working with structured text.\n\nThe method leverages the underlying reader to sequentially read lines of text, converting them into a stream. A stream is a sequence of elements that can be processed using operations like filtering, mapping, or reducing. By combining with the Java Stream API, developers can write concise and efficient code for reading and processing large amounts of text.\n\nIn this example:\n• The method is called to produce a stream of lines.\n• The method of the stream is used to print each line.\n• Stream Integration\n\nUnlike traditional loops for reading lines, the method seamlessly integrates with the Stream API. This makes it easier to apply functional-style operations, like filtering or mapping, without additional code.\n• Efficient Memory Usage\n\nSince the method streams the lines lazily, it reads data only when needed. This is particularly useful when dealing with large files, as it prevents loading the entire file into memory.\n• Readability and Conciseness\n\nThe method allows for more readable and concise code compared to traditional approaches like loops.\n\nWhile using , it's important to handle the resource properly. A try-with-resources block automatically closes the reader after use, preventing resource leaks.\n\nAnother consideration is that the stream must not outlive the . Closing the invalidates the stream, and further operations on it will throw exceptions. Always structure the code to consume the stream within the same try-with-resources block. For example:\n\nHere, only lines containing the word “ERROR” are processed and displayed, showcasing how works in filtering scenarios. This flexibility allows developers to focus on the content they need without unnecessary complexity in the code structure.\n\nThe method has numerous applications in real-world scenarios where handling large text data is required. Below are some common use cases, each illustrating how the method can be applied effectively.\n\nLog files often contain thousands of entries, and searching for specific information like error messages or warnings can be tedious with traditional methods. The method, combined with the Stream API, provides a way to filter log entries dynamically.\n\nExample — Extracting all error messages from a log file.\n\nIn this example:\n• The operation is used to extract lines containing the word \"ERROR\".\n• This approach avoids the need for manual file scanning and parsing.\n\nData files, such as CSVs or tab-delimited files, are often too large to fit into memory all at once. With , you can process them line by line without memory constraints, making it ideal for scalable solutions.\n\nExample — Calculating the total value of a specific column in a CSV file.\n• Lines are split into columns, and the required column is converted to a numerical value for aggregation.\n\nSometimes, you may need to transform or search for specific text patterns. The method simplifies this by enabling operations like replacing patterns or extracting matching lines.\n\nExample — Masking sensitive data in a file before saving it elsewhere.\n\nIn this example:\n• The function applies a transformation to each line, masking sensitive data such as passwords.\n• The transformed lines are joined into a single string for writing to a new file.\n\nFor applications like search engines or text analysis tools, building an index from text files is a common task. The method helps parse files efficiently.\n\nExample — Creating an index of words and their line numbers.\n• Using the method to process each line and split it into words.\n• Storing the first occurrence of each word along with its line number.\n\nIn applications where logs are constantly appended, such as server logs, the method can help read new entries dynamically. Combined with techniques like file watching, this method is suitable for real-time log monitoring and analysis.\n\nThe method works seamlessly with the Java Stream API, making it a convenient option for processing text data in a functional programming style. By converting the file content into a stream of lines, you can chain various stream operations for filtering, mapping, or reducing data without needing intermediate storage or explicit loops.\n\nExample — Counting the Number of Lines That Match a Condition\n\nIn this example:\n• The operation is used to find lines starting with the string \"INFO\".\n• The operation aggregates the number of matching lines without needing an external counter variable.\n\nThis shows how the method, when combined with the Stream API, enables concise and readable code for common file processing tasks.\n\nWhen using the method, proper error handling and understanding potential edge cases are vital to prevent unexpected behavior and improve reliability. This section covers common issues and practical techniques for managing them effectively.\n\nThe and related classes can throw exceptions such as when issues arise, such as a file not being found or access being denied. Always handle these exceptions gracefully by using a block. For critical operations, logging the error or rethrowing it with additional context can provide more clarity.\n\nIn this example:\n• The block catches and prints an error message to alert the user to the issue.\n\nFailing to close a can lead to resource leaks, especially when reading large files. Always use a try-with-resources statement, as it automatically closes the resource after the block is executed, even if an exception is thrown.\n\nHere, the try-with-resources block automatically closes the .\n\nIf the file being read is empty, the method will return an empty stream. This is not an error but requires consideration in the logic to handle scenarios where no data is available.\n\nIn this example:\n• The operation checks if the stream contains any lines.\n• A message is displayed if the file is empty.\n\nText files may contain unexpected or malformed data. For example, when processing numerical data, a non-numeric line can cause an exception. Always validate or sanitize the input before processing.\n• Each line is parsed as an integer within a block.\n• Malformed lines are skipped by returning and filtering them out.\n\nThe method streams data lazily, but improper processing can lead to memory issues. For instance, collecting all lines into a list using on a very large file can exhaust memory. Always process lines incrementally to avoid such issues.\n\nThis example processes lines incrementally, reducing memory usage and preventing the application from becoming unresponsive.\n\nThe method is an effective tool for processing text files, particularly when used with the Java Stream API. Handling errors carefully and accounting for edge cases allows developers to manage large files and perform text processing tasks efficiently.\n\nThank you for reading! If you find this article helpful, please consider highlighting, clapping, responding or connecting with me on Twitter/X as it’s very appreciated and helps keeps content like this free!"
    },
    {
        "link": "https://download.java.net/java/early_access/jdk24/docs/api/java.base/java/io/class-use/BufferedReader.html",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/java.io.bufferedreader?view=net-android-35.0",
        "document": "Reads text from a character-input stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines.\n\nThe buffer size may be specified, or the default size may be used. The default is large enough for most purposes.\n\nIn general, each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream. It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders. For example,\n\nwill buffer the input from the specified file. Without buffering, each invocation of read() or readLine() could cause bytes to be read from the file, converted into characters, and then returned, which can be very inefficient.\n\nPrograms that use DataInputStreams for textual input can be localized by replacing each DataInputStream with an appropriate BufferedReader.\n\nPortions of this page are modifications based on work created and shared by the Android Open Source Project and used according to terms described in the Creative Commons 2.5 Attribution License.\n\nGets the JNI name of the type of the instance . Try to coerce to type , checking that the coercion is valid on the Java side. Try to coerce to type , checking that the coercion is valid on the Java side."
    }
]