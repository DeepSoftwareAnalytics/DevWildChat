[
    {
        "link": "https://dev.to/kalkwst/state-pattern-in-c-a82",
        "document": "The State is a behavioural design pattern that lets an object alter its behaviour when its internal state changes. For the system, it appears as if the object changed its class.\n\nThe State design pattern is one of the most useful patterns described by the Gang of Four. Games often depend on the State pattern because objects can change so frequently. Many other simulations, whether they are games or not, depend on the State pattern as well.\n\nYou can find the example code of this post, on GitHub\n\nThe State pattern is closely related to the Finite-State Machine.\n\nThe idea is that, at any given time, there's a finite number of states in which a program can be in. Within every unique state, the application behaves differently, and the program can be switched from one to the other instantaneously. However, depending on the current state, the application can only switch to certain states. The switching rules, called transitions, are predetermined.\n\nThis approach is very common around the web. Imagine we have a class on a blogging website. A post can be in one of three states: , and . The method of the document works a little differently in each state:\n• In the state, it publishes the document with a secret URL.\n• In the state, it makes the document public.\n• In the state, it doesn't do anything.\n\nState machines are usually implemented with long chains of conditional statements that select the appropriate behaviour depending on the object's current state. Usually, this state is just a set of variables. Even if you haven't heard about finite states before, you've probably implemented a state at least once.\n\n\n\nThe greatest weakness of a state machine based on conditionals reveals itself as soon as we start adding states and state-dependent behaviours. Most methods will contain humongous conditionals that pick the proper behaviour of a method according to the current state. This code is very difficult to maintain because any change to the transition logic might require changing conditionals in every method.\n\nThe problem only worsens with time. It's quite difficult to predict all possible states and transitions during the design phase. Hence, a lean state machine can grow into a bloated mess over time.\n\nThe State pattern suggests that we create new classes for all possible states of an object and extract all state-specific behaviours into these classes.\n\nInstead of implementing all behaviours, the original object called context, stores a reference to one of the state objects that represents its current state, and delegates all the state-related work to that object.\n\nTo transition the context into another state, replace the active state object with another object that represents that new state. This is possible only if all state classes follow the same interface and the context itself works with these objects through that interface.\n\nThis structure may look similar to the Strategy pattern, but there's one key difference. In the State pattern, the particular states may be aware of each other and initiate transitions from one state to another, whereas strategies rarely know about each other.\n\nIn its base implementation, the State pattern has four participants:\n• Context: The Context stores a reference to one of the concrete state objects and delegates to it all state-specific work. The context communicates with the state object via the state interface. The context exposes a setter method for passing it a new state object.\n• State: The State interface declares the state-specific methods. These methods should make sense for all concrete states because we don't want some of our states to have methods that are never called.\n• Concrete State: The Concrete States provide their implementations for the state-specific methods. To avoid duplication of similar code across multiple states, we may provide intermediate abstract classes encapsulating some common behaviour. State objects may store a backreference to the context object. Through this reference, the state can fetch any required info from the context object, and initiate state transitions. Both context and concrete states can set the next stage and perform the actual state transition by replacing the state object linked to the context.\n• Client: The Client can trigger state changes to the Context object.\n\nTo demonstrate how the State pattern works, we will implement a component which keeps track of the internal temperature of a steak and assesses a level of \"doneness\" to it.\n\nFirst, let's define our State participant, which represents the \"doneness\" level of a steak.\n\n\n\nWe have declared the , , and the abstract methods. These methods will be implemented by each of the states we can place the steak.\n\nNow that we have the State participant, we will define some ConcreteState objects. First, we will define a state for when the steak is uncooked, and therefore not safe to eat. In this state, we can increase or decrease the cooking temperature, but the steak will not be safe for consumption until the core temperature is greater than 48.9 degrees Celsius.\n\nWe will also implement the method , which determines whether or not the internal temperature of the steak is sufficiently high to allow it to move to another state. At this point, we'll assume that a steak can only move one state at a time.\n\n\n\nSimilarly, we can implement the rest of the states of the steak.\n\n\n\nNow that we have all of our states defined, we can finally implement our Context participant. In this case, the Context is a class which maintains a reference to the state it is currently in. Further, whenever we increase or decrease the temperature of the steak, it must call the current state's corresponding method.\n\n\n\nFinally, in our method, we can use these states by creating a object and then changing its internal temperature:\n\n\n\nAs we change the temperature, we change the state of the object. The output of this method looks like the following:\n\nAs the instance's internal temperature changes, the state in which it currently resides also changes, and consequently the apparent behaviour of that object shifts to whatever behaviour is defined by the current state.\n• The Bridge, the State and the Strategy patterns have very similar structures. Indeed, all of these patterns are based on composition, which is delegating work to other objects. However, they all solve different problems. A pattern isn’t just a recipe for structuring our code in a specific way. It can also communicate to other developers the problem the pattern solves.\n• The State can be considered as an extension of the Strategy pattern. Both patterns are based on composition: they change the behaviour of the context by delegating some work to helper objects. Strategy makes these objects completely independent and unaware of each other. However, State doesn’t restrict dependencies between concrete states, letting them alter the state of the context at will.\n\nIn this article, we have discussed what is the State pattern, when to use it and what are the pros and cons of using this design pattern. We then examined how the State pattern relates to other classic design patterns.\n\nIt's worth noting that the State pattern, along with the rest of the design patterns presented by the Gang of Four, is not a panacea or a be-all-end-all solution when designing an application. Once again it's up to the engineers to consider when to use a specific pattern. After all these patterns are useful when used as a precision tool, not a sledgehammer."
    },
    {
        "link": "https://medium.com/@ozkanardil/mastering-state-design-pattern-in-c-for-beginners-a0700322a289",
        "document": "The State Design Pattern holds significant importance in software development, particularly in enhancing the flexibility and maintainability of code. This design pattern allows an object to alter its behavior when its internal state changes, treating each state as a separate class. By encapsulating each state in a distinct class, the object can delegate state-specific functionalities, making it easier to add new states or modify existing ones without altering the object’s structure.\n\nMoreover, the State pattern promotes cleaner and more modular code by centralizing the logic related to each state. This not only simplifies the understanding of the codebase but also facilitates the addition of new states in the future. Additionally, the State pattern supports the Open/Closed Principle, enabling developers to extend the system’s behavior without modifying existing code.\n\nTransitioning to concrete examples, consider the application of the State pattern in the context of a satellite connection, such as a satellite internet link. Just as the pattern manages the various states of a network connection, it also facilitates the seamless management of a satellite system’s diverse states, improving the overall design and maintenance of the software.\n\nSimilarly, envision the application of the State pattern in everyday devices like a thermostat or a smartphone. By adopting this design approach, these devices can efficiently manage different states, responding to user inputs appropriately. In the case of a thermostat, for instance, the State pattern can be employed to handle various temperature settings, allowing for a more dynamic and adaptable system.\n\nIn essence, the State Design Pattern provides a structured and extensible way to manage the behavior of objects based on their internal states, contributing to the overall robustness and scalability of software systems.\n\nYou will find the class diagram below.\n• Tv class: The class serves as the context or container for the various states of the television. It maintains a reference to the current state object and delegates state-specific behavior to that object. This class encapsulates the functionality related to the television's different states, allowing for a more modular and maintainable code structure.\n• IPossibleStates interface: The interface defines a set of methods that represent the possible behaviors or actions associated with different states of the television. Each concrete state class implements this interface, ensuring a consistent set of methods across all state classes. This interface acts as a contract that enforces the implementation of state-specific behavior in each concrete state class.\n• Concrete classes (Mute, On, and Off): The concrete classes, such as , , and , implement the interface and represent specific states of the television. Each class encapsulates the behavior associated with its respective state. For example, the class defines how the television behaves when it is in a muted state, while the and classes handle the behaviors when the television is switched on or off, respectively. These classes facilitate a clean separation of concerns, making it easy to add or modify states without affecting the overall structure of the class.\n\nYou will find the high-level structure of the parts of the program.\n\nIn the context of managing the states of a television, the implementation involves the entities above.\n\nSo, let’s create the code for the elements of the sample project.\n\npublic class Off: IPossibleStates\n\n {\n\n Tv _tvContext;\n\n //Initially we'll start from Off state\n\n public Off(Tv context)\n\n {\n\n Console.WriteLine(\"Tv is Off now.\");\n\n _tvContext = context;\n\n }\n\n //Users can press any of these buttons at this state-On, Off or Mute\n\n //Tv is Off now, user is pressing On button\n\n public void PressOnButton(Tv context)\n\n {\n\n Console.WriteLine(\"On button is pressed. Going from Off to On state\");\n\n\n\n _tvContext.CurrentState = new On(context);\n\n }\n\n //Tv is Off already, user is pressing Off button again\n\n public void PressOffButton(Tv context)\n\n {\n\n Console.WriteLine(\"Off button is pressed. Tv is already in Off state\");\n\n }\n\n\n\n public void PressMuteButton(Tv context)\n\n {\n\n Console.WriteLine(\"Mute button is pressed. Tv is already in Off state, so Mute operation will not work.\");\n\n }\n\n }\n\nSo, we put them together within the program.cs class.\n\nYou will find the output below.\n\nIn this C# implementation, the IPossibleStates interface defines the common method HandleOperation, which is implemented by Mute.cs, On.cs, and Off.cs classes.\n\nThe Tv.cs class manages the current state and delegates operations to the concrete state objects through the IPossibleStates interface.\n\nThe client code demonstrates how the state transitions can be dynamically controlled through the Tv.cs class, showcasing the flexibility of the State Design Pattern in the context of managing television states."
    },
    {
        "link": "https://stackoverflow.com/questions/64174849/implementing-a-state-pattern",
        "document": "I have an object that based on it's properties, will perform different operations in it's service layer.\n\nLet's say it's a customer with the following states: Registered, RegisteredWithoutContactOnFile, and NoRegistration.\n\nThese states are based on properties set on the object. So it would be something like the following:\n\nThen there would be the CustomerService which does different database operations based on what is entered like such:\n\nI basically want to get rid of this if/else statement in the service layer and make it a state in my object so that I can more easily test it. Can anyone assist with how I would go about this or if I'm going about this the wrong way? I will say I am interested in the state pattern as I have been working on Finite State Machines for an AI agent but I feel like it makes sense here as well. Perhaps a strategy pattern would work? In short, I'm just trying to get the logic out of the service layer to make it more testable... any insight would be greatly appreciated!"
    },
    {
        "link": "https://medium.com/@lexitrainerph/state-pattern-in-c-from-basics-to-advanced-de3a0dc526af",
        "document": "The State Pattern is a behavioral design pattern that allows an object to change its behavior when its internal state changes. Instead of implementing state-specific behaviors within a monolithic object, the State Pattern uses individual state objects to encapsulate state-specific logic. In this blog post, we’ll explore the State Pattern in C#, starting from the basics and progressing to advanced scenarios.\n\nThe State Pattern is all about managing changes in behavior due to changes in state. It helps in organizing state-dependent logic and promotes the Single Responsibility Principle by ensuring that each state has its own class.\n• Context: Maintains an instance of a ConcreteState subclass that defines the current state.\n• State: Defines an interface for encapsulating the behavior associated with a particular state of the Context.\n• ConcreteState: Each subclass implements a behavior associated with a state of Context.\n\nState transitions can be more complex than simple toggles. Depending on the application, a state might transition to multiple other states. Ensure that the logic for determining the next state is encapsulated within the state classes.\n\nSometimes, it’s beneficial to maintain a history of states. This can be achieved by using a stack to push and pop states as the context changes.\n\nIn scenarios where state instances don’t maintain any internal data, they can be shared across multiple contexts.\n\nConsider the lifetime of state objects. Depending on the application, you might create new state objects for each transition, or you might reuse state objects.\n\nThe State Pattern is similar to the Strategy Pattern. However, while Strategy Pattern typically encapsulates algorithms, the State Pattern encapsulates state-dependent behaviors.\n• Order Processing Systems: An order might have states like New, Processed, Shipped, Delivered, and Canceled. Each state can dictate different behaviors for the order.\n• Game Development: Game characters might have states like Idle, Running, Jumping, and Attacking. Each state can have different animations and behaviors.\n• Workflow Systems: Workflow systems often have complex state transitions, with each state dictating what actions can be performed and what the next possible states are.\n\nThe State Pattern is a powerful design pattern that promotes organized, maintainable, and decoupled code by encapsulating state-dependent behaviors into individual state classes. It’s particularly useful in scenarios where an object’s behavior changes dynamically based on its state. With C#’s strong object-oriented features, implementing the State Pattern is both intuitive and effective. Whether you’re building a complex workflow system, a game, or any application with dynamic behaviors, the State Pattern can be an invaluable tool in your design arsenal."
    },
    {
        "link": "https://refactoring.guru/design-patterns/state",
        "document": "The State pattern is closely related to the concept of a Finite-State Machine . The main idea is that, at any given moment, there’s a finite number of states which a program can be in. Within any unique state, the program behaves differently, and the program can be switched from one state to another instantaneously. However, depending on a current state, the program may or may not switch to certain other states. These switching rules, called transitions, are also finite and predetermined. You can also apply this approach to objects. Imagine that we have a class. A document can be in one of three states: , and . The method of the document works a little bit differently in each state:\n• In , it moves the document to moderation.\n• In , it makes the document public, but only if the current user is an administrator.\n• In , it doesn’t do anything at all. Possible states and transitions of a document object. State machines are usually implemented with lots of conditional statements ( or ) that select the appropriate behavior depending on the current state of the object. Usually, this “state” is just a set of values of the object’s fields. Even if you’ve never heard about finite-state machines before, you’ve probably implemented a state at least once. Does the following code structure ring a bell? class Document is field state: string // ... method publish() is switch (state) \"draft\": state = \"moderation\" break \"moderation\": if (currentUser.role == \"admin\") state = \"published\" break \"published\": // Do nothing. break // ... The biggest weakness of a state machine based on conditionals reveals itself once we start adding more and more states and state-dependent behaviors to the class. Most methods will contain monstrous conditionals that pick the proper behavior of a method according to the current state. Code like this is very difficult to maintain because any change to the transition logic may require changing state conditionals in every method. The problem tends to get bigger as a project evolves. It’s quite difficult to predict all possible states and transitions at the design stage. Hence, a lean state machine built with a limited set of conditionals can grow into a bloated mess over time.\n\nThe State pattern suggests that you create new classes for all possible states of an object and extract all state-specific behaviors into these classes. Instead of implementing all behaviors on its own, the original object, called context, stores a reference to one of the state objects that represents its current state, and delegates all the state-related work to that object. To transition the context into another state, replace the active state object with another object that represents that new state. This is possible only if all state classes follow the same interface and the context itself works with these objects through that interface. This structure may look similar to the Strategy pattern, but there’s one key difference. In the State pattern, the particular states may be aware of each other and initiate transitions from one state to another, whereas strategies almost never know about each other.\n\nIn this example, the State pattern lets the same controls of the media player behave differently, depending on the current playback state. Example of changing object behavior with state objects. The main object of the player is always linked to a state object that performs most of the work for the player. Some actions replace the current state object of the player with another, which changes the way the player reacts to user interactions. // The AudioPlayer class acts as a context. It also maintains a // reference to an instance of one of the state classes that // represents the current state of the audio player. class AudioPlayer is field state: State field UI, volume, playlist, currentSong constructor AudioPlayer() is this.state = new ReadyState(this) // Context delegates handling user input to a state // object. Naturally, the outcome depends on what state // is currently active, since each state can handle the // input differently. UI = new UserInterface() UI.lockButton.onClick(this.clickLock) UI.playButton.onClick(this.clickPlay) UI.nextButton.onClick(this.clickNext) UI.prevButton.onClick(this.clickPrevious) // Other objects must be able to switch the audio player's // active state. method changeState(state: State) is this.state = state // UI methods delegate execution to the active state. method clickLock() is state.clickLock() method clickPlay() is state.clickPlay() method clickNext() is state.clickNext() method clickPrevious() is state.clickPrevious() // A state may call some service methods on the context. method startPlayback() is // ... method stopPlayback() is // ... method nextSong() is // ... method previousSong() is // ... method fastForward(time) is // ... method rewind(time) is // ... // The base state class declares methods that all concrete // states should implement and also provides a backreference to // the context object associated with the state. States can use // the backreference to transition the context to another state. abstract class State is protected field player: AudioPlayer // Context passes itself through the state constructor. This // may help a state fetch some useful context data if it's // needed. constructor State(player) is this.player = player abstract method clickLock() abstract method clickPlay() abstract method clickNext() abstract method clickPrevious() // Concrete states implement various behaviors associated with a // state of the context. class LockedState extends State is // When you unlock a locked player, it may assume one of two // states. method clickLock() is if (player.playing) player.changeState(new PlayingState(player)) else player.changeState(new ReadyState(player)) method clickPlay() is // Locked, so do nothing. method clickNext() is // Locked, so do nothing. method clickPrevious() is // Locked, so do nothing. // They can also trigger state transitions in the context. class ReadyState extends State is method clickLock() is player.changeState(new LockedState(player)) method clickPlay() is player.startPlayback() player.changeState(new PlayingState(player)) method clickNext() is player.nextSong() method clickPrevious() is player.previousSong() class PlayingState extends State is method clickLock() is player.changeState(new LockedState(player)) method clickPlay() is player.stopPlayback() player.changeState(new ReadyState(player)) method clickNext() is if (event.doubleclick) player.nextSong() else player.fastForward(5) method clickPrevious() is if (event.doubleclick) player.previous() else player.rewind(5)"
    },
    {
        "link": "https://learn.microsoft.com/en-us/archive/msdn-magazine/2001/july/design-patterns-solidify-your-csharp-application-architecture-with-design-patterns",
        "document": "s any seasoned object-oriented software developer knows, it is unthinkable to discuss software design and architecture without at least a rudimentary understanding of design patterns. Most, if not all, software applications, tools, and systems incorporate one or more design patterns. A design pattern is a description of a set of interacting classes that provide a framework for a solution to a generalized problem in a specific context or environment. In other words, a pattern suggests a solution to a particular problem or issue in object-oriented software development. Additionally, patterns take into account design constraints and other factors that limit their applicability to the solution in general. Together, the classes, the communication and interconnections among those classes, and the contextual specifics define a pattern that provides a solution to any problem in object-oriented software design that presents characteristics and requirements matching those addressed by the pattern context.\n\n I must confess that I am an enthusiastic proponent of design patterns. Ever since I read the seminal book Design Patterns by Gamma, Helm, Johnson, and Vlissides (Addison Wesley, 1995), I have rarely designed a feature that does not use any patterns. In fact, I spend considerable time in the early stages of software design to identify patterns that would fit naturally in the feature architecture. After all, patterns are time-tested and field-tested solutions to problems that have been addressed by experienced architects, developers, and language specialists, and it behooves anyone designing software to make use of the available knowledge and expertise in this discipline. It is almost always a better idea to go with a solution that has been proven successful time and again than to invent one completely from scratch.\n\n Few developers have the luxury of writing only small programs. Modern software applications and systems are complex, comprising hundreds of thousands of lines of code, and I know of code bases that are even larger. Programming demands a lot more than simple mastery of tools and languages—corporate software development typically requires a great deal of flexibility in design and architecture to accommodate the ever-changing needs of clients and users at various stages of product development, and often after the product has been released. Such dynamics dictate that software design not be brittle. It should be able to accept changes without any undesirable ripple effect that would necessitate the reworking of other, potentially unrelated, subsystems. It is frustrating and counterproductive to add features and components to modules that were never designed for extensibility. Sooner or later, closed, inflexible designs break under the weight of changes. Design patterns assist in laying the foundation for a flexible architecture, which is the hallmark of every good object-oriented design.\n\n Design patterns have been cataloged to address a variety of design problems, from small issues to large, architecture-level problems. In this article, I will describe some of the popular design patterns that I have found useful in my own projects. The article does not assume any prior knowledge of design patterns, although familiarity with concepts of object-oriented design will help. While any programming language that facilitates object-oriented development could be used to illustrate patterns, I will present examples exclusively in C#, exposing some of the strengths of the language along the way. I will not discuss any Microsoft® .NET-specific classes or libraries—instead, I'll focus on C# as a vehicle for designing object-oriented software. C# is a modern programming language that promotes object-oriented software development by offering syntactic constructs and semantic support for concepts that map directly to notions in object-oriented design. This is in contrast to C++, which supports procedural as well as object-oriented (and generic) programming. Nonetheless, if you are a C++ programmer, getting up to speed with C# should be a snap—the learning curve for C++ programmers is flat. Even if you haven't seen any C# code before, you should have no problem comprehending the example code in this article. In fact, I wouldn't be surprised if you find the C# implementation of the design patterns cleaner, especially if you have used or coded the patterns before. Books and articles that discuss design patterns typically explain the problem and the context in great detail, followed by a formal description of the solution. I will take a less rigorous approach in this article, focusing on the essence of the pattern instead, and illustrating an appropriate example with some sample code in C#.\n\n Let's start with the simplest design pattern: Singleton.\n\n Anyone who has ever written an MFC application—no matter how small—knows what a singleton is. A singleton is the sole instance of some class. To use an MFC analogy, the global instance of the CWinApp-derived application class is the singleton. Of course, while it's imperative that no additional instances of the application class be created, there really is nothing preventing you from creating additional instances. In situations like these, when you need to enforce singleton behavior for a specific class, a better alternative is to make the class itself responsible for ensuring that one and only one instance of the class can be created. Back in the MFC analogy, you see that the responsibility for keeping track of the solitary instance of the application class rests with the developers of the application. They must not inadvertently instantiate another application object.\n\n Now consider the class shown in Figure 1. Note how access to the singleton is controlled via the static method Instance. It is most often the case that the singleton should also be globally accessible, and this is achieved by making the creation method public. However, unlike the scenario in which a global variable is instantiated as the singleton, this pattern prevents creation of any additional instances, while simultaneously allowing global access. Note that the class constructor is private—there is no way to circumvent the static method and directly create an instance of the class.\n\n There are additional benefits, too. Specifically, this pattern can be extended to accommodate a variable number of instances of an object. For instance, let's say you have an application with a dedicated worker thread that is dispatched whenever a particular task is required. In the interest of conserving system resources, you have implemented the thread as a singleton. At some point along the way, if you decide to scale up your application because the rate at which tasks arrive is too much for your singleton thread to handle, it will be fairly straightforward to increase the number of worker threads in the application because all the logic that creates the threads and grants access to them is confined to one class.\n\n One other advantage to this pattern is that creation of the singleton can be delayed until it is actually needed, as shown in Figure 1. A variable declared at global scope will be created on startup regardless of whether it is needed—it may very well be that the object isn't always needed. C# doesn't allow variables at global scope anyway, but it is possible to create an object on the heap at the outset of a method and not use it until much later, if at all. The Singleton pattern offers an elegant solution in such cases.\n\n Additionally, as an implementation vehicle, C# is superior to C++ for this design pattern in a subtle but important way. A C++-based implementation has to take into account some sticky issues related to lifetime management that are automatically taken care of by the C# runtime. This is a significant benefit, as all you need to do in the C# version is make sure you have a live reference to the singleton object for as long as it's needed.\n\n Applications are often written so that the way they perform a particular task varies, depending on user input, the platform it's running on, the environment it's been deployed in, and so on. An example is asynchronous I/O on disk files: Win32® APIs under Windows NT® and Windows® 2000 support asynchronous I/O natively. However, that's not the case with Windows 95 or Windows 98. An application that relies on asynchronous file I/O, therefore, has to execute two different algorithms, depending on the deployment platform—one that uses native Win32 APIs, and another that is built from scratch, perhaps using multiple threads. Clients of such a service will be oblivious to the fact that different algorithms are being executed; as far as they are concerned, the end result is the same and that's all they care about.\n\n Another example is downloading a file from some remote server on the Internet. An application that offers a file download service that accepts a URL as input needs to examine the URL, identify the protocol (FTP or HTTP, for example), and then create an object that can communicate with the remote server using that protocol. Note that depending on user input, a different algorithm (protocol) will be used. However, again, the end result is the same—a file is downloaded.\n\n Let's consider a more concrete example: testing for primality. The following code declares an interface, a C# construct, with just one method: IsPrime.\n\n An interface is like a contract. It is a specification that inheriting classes must follow. More specifically, it defines method signatures but no implementations—the latter must be provided by the concrete classes that implement the interface. C# is clearly superior to C++ in this regard because C++ lacks native language support for interfaces. C++ programmers typically create interfaces by defining abstract classes with pure virtual methods. In C#, all interface members are public, and classes adhering to an interface must implement all methods in the interface.\n\n Now let's assume that I have three different algorithms for primality testing, each with its own performance/accuracy trade-off. One of them is very computation-intensive, but does a more thorough job of checking for factors, while another is faster but generates results that may be inaccurate for very large numbers. My application will ask the user for the desired performance and then invoke the appropriate algorithm. To this end, I will encapsulate my algorithms in classes that implement the Strategy interface. Here's an example.\n\n Having implemented all three algorithms in this manner, I can now design the client in a manner that decouples it from the implementation details of any specific algorithm. The client holds a reference to the interface, and does not need to know anything about the concrete implementation of the interface.\n\n Finally, I create an instance of the Primality class and, depending on user input, initialize it with the appropriate algorithm. The Test method of the Primality class invokes the IsPrime method of the Strategy interface that every algorithm implements.\n\n There are a number of advantages to structuring a family of algorithms in this manner, but the most important is that doing so decouples the client from the implementation details of any particular algorithm. This promotes extensibility in that additional algorithms can be developed and plugged in seamlessly, as long as they follow the base interface specification, thereby allowing algorithms to vary dynamically. Moreover, the Strategy pattern eliminates conditional statements that would otherwise litter client code.\n\n A client application often needs to augment the services provided by methods of some class, perhaps by inserting some preprocessing and post-processing tasks before and after the method calls, respectively. One way to accomplish this is to bracket each method invocation with calls to functions that achieve the desired effect. However, this approach is not only cumbersome, it also limits the framework's extensibility. For instance, if distinct pre- and post-processing tasks were to be carried out for different clients, the application logic would be obscured by conditional statements, leading to a maintenance nightmare. The question, then, is how to enhance the functionality offered by a class in a manner that does not cause repercussions in client code. The Decorator pattern is just what's needed.\n\n Consider a class with methods that clients can invoke to transfer files to and from some remote server. Such a class might look like the one in Figure 2.\n\n Next, let's consider a client interested in this functionality. In addition to being able to upload and download files, the client application would also like to log all file transfer requests and perform access checks for each invocation. An implementation based on the Decorator pattern would derive a class from FileTransfer and override the virtual methods, inserting the additional operations before and after calling the base methods (see Figure 3).\n\n The client continues to work with the same interface. In fact, the solution can be improved if the FileTransfer class, as well as the Decorator class, implement a common interface with the Upload and Download methods. Doing so will allow the client to work exclusively in terms of the interface and decouple it completely from a concrete implementation.\n\n The Decorator pattern thus allows dynamic and transparent addition and removal of responsibilities without affecting client code. It is particularly useful when a range of extensions or responsibilities can be applied to existing classes, and when defining subclasses to accommodate all those extensions is impractical. The Composite pattern is useful when individual objects as well as aggregates of those objects are to be treated uniformly. An everyday example is enumerating the contents of a file folder. A folder may contain not only files, but subfolders as well. An application designed to recursively display the list of all files in some top-level folder can use a conditional statement to distinguish between files and directories, and traverse down the directory tree to display the names of files in the subfolders. A better approach is suggested by the Composite pattern. In this approach, every folder item, be it a file, a subfolder, a network printer, or a moniker for any directory element, is an instance of a class that conforms to an interface offering a method to display a user-friendly name of the element. In this case, the client application does not have to treat each element differently, thereby reducing the complexity of the application logic.\n\n Another example, and one that I will present in C#, is a drawing application that pulls graphics primitives and blocks from an object database and paints them on a canvas. Let's assume that the database can contain lines, circles, and drawings made up of these primitives. Now consider the following interface.\n\n The Shape interface contains one method, Draw. A simple graphics object such as a line can implement this interface and override the Draw method to paint a line on some canvas, as you can see in Figure 4.\n\n The circle primitive can similarly override the Draw method in the Shape interface and produce the desired shape on the canvas. In order to treat aggregates as well as simple entities uniformly, however, objects of aggregates should also implement the Shape interface. A drawing is a collection of graphics objects, and its implementation of the Draw method will enumerate all primitives it contains and draw each one of them. Figure 5 shows how it works.\n\n Note that the client couldn't care less about whether an object is an instance of a graphics primitive or a collection of such entities. A common interface across individual elements and aggregates streamlines processing and allows you to add new objects without triggering any modifications in the client application.\n\n By presenting a shared interface across all components, the Composite pattern promotes code reuse and simplifies client logic considerably by removing the burden of having to make a distinction between individual elements and container objects.\n\n Note that the implementation of Drawing.Draw uses the collection classes available in the System.Collections library. For more information on these and other libraries, check out the documentation in the .NET Framework SDK.\n\n Every developer has implemented a finite state machine at least once in his or her career. You can't avoid them—they are everywhere, and not just limited to the world of software development. It's no wonder that literature on the design and implementation of deterministic finite automata is also readily available. Given the ubiquity of finite state machines, I am often surprised to see poor designs and buggy implementations with hardwired transitions and total disregard for extensibility. The ability to add more states to the design of a finite automaton is often an unwritten requirement, and implementations are frequently modified when requests for additional states and transitions arrive. If you've got a good design, you can anticipate and account for such changes. More importantly, behavior and operations specific to any state in a finite state machine should be confined and localized to the representation of that state. In other words, state-specific code lives in an object that implements that state. This, in turn, allows you to add new states and transitions easily.\n\n A popular design for finite state machines is based on table lookup. A table maps all possible inputs for each state to transitions that would lead the machine to perhaps a different state. Needless to say, while this design is simpler, it is unable to accommodate changes without significant modifications to the existing implementation. A better alternative is the solution offered by the State design pattern.\n\n Consider a software implementation of a soda vending machine that accepts nickels, dimes, and quarters only, and dispenses a can when the deposited amount reaches or exceeds 25 cents. With each coin that is inserted into the slot, the vending machine transitions to a different state, until the credit reaches the requisite amount, at which point the machine delivers the can of soda and resets to the start state. Figure 6 defines an abstract class to represent the base of all states that the vending machine can reach.\n\n All five states will be subclasses of this base class and override its methods appropriately. For instance, when the vending machine is in the Start state and a nickel is inserted, the machine moves to the Five state. If another nickel is inserted, it moves to the Ten state. This isolates the transition logic specific to each state in the corresponding object. The implementation of two such states is shown in Figure 7.\n\n The vending machine does not keep track of the transition logic—it forwards the operation to the instance of its current state, hence decoupling itself from state-specific behavior, as you can see in Figure 8.\n\n I have already described how such a design is superior to a simple, table-based implementation. To summarize, the State design pattern helps localize state-specific behavior to classes that implement concrete states, which promotes reuse and extensibility. This removes the need for conditional statements that would otherwise be scattered throughout the code, making life difficult for maintenance programmers, who vastly outnumber implementors in the real world.\n\n Design patterns distill years of experience in solutions to frequently encountered problems in the design of object-oriented software. They offer answers to questions that most software developers face regardless of the size or scope of the project. C# promises to enhance programmer productivity with its features that promote object-oriented design, while removing the onus of certain housekeeping chores from the developer. Together, they make a winning combination.\n\n Complete C# code listings for examples in this article are available at the link at the top of this article."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/interfaces",
        "document": "An interface contains definitions for a group of related functionalities that a non-abstract or a must implement. An interface may define methods, which must have an implementation. An interface may define a default implementation for members. An interface may not declare instance data such as fields, automatically implemented properties, or property-like events.\n\nBy using interfaces, you can, for example, include behavior from multiple sources in a class. That capability is important in C# because the language doesn't support multiple inheritance of classes. In addition, you must use an interface if you want to simulate inheritance for structs, because they can't actually inherit from another struct or class.\n\nYou define an interface by using the keyword as the following example shows.\n\nThe name of an interface must be a valid C# identifier name. By convention, interface names begin with a capital .\n\nAny class or struct that implements the IEquatable<T> interface must contain a definition for an Equals method that matches the signature that the interface specifies. As a result, you can count on a class of type that implements to contain an method with which an instance of this class can determine whether it's equal to another instance of the same class.\n\nThe definition of doesn't provide an implementation for . A class or struct can implement multiple interfaces, but a class can only inherit from a single class.\n\nFor more information about abstract classes, see Abstract and Sealed Classes and Class Members.\n\nInterfaces can contain instance methods, properties, events, indexers, or any combination of those four member types. Interfaces may contain static constructors, fields, constants, or operators. Beginning with C# 11, interface members that aren't fields may be . An interface can't contain instance fields, instance constructors, or finalizers. Interface members are public by default, and you can explicitly specify accessibility modifiers, such as , , , , , or . A member must have a default implementation.\n\nTo implement an interface member, the corresponding member of the implementing class must be public, non-static, and have the same name and signature as the interface member.\n\nA class or struct that implements an interface must provide an implementation for all declared members without a default implementation provided by the interface. However, if a base class implements an interface, any class that's derived from the base class inherits that implementation.\n\nThe following example shows an implementation of the IEquatable<T> interface. The implementing class, , must provide an implementation of the Equals method.\n\nProperties and indexers of a class can define extra accessors for a property or indexer that's defined in an interface. For example, an interface might declare a property that has a get accessor. The class that implements the interface can declare the same property with both a and set accessor. However, if the property or indexer uses explicit implementation, the accessors must match. For more information about explicit implementation, see Explicit Interface Implementation and Interface Properties.\n\nInterfaces can inherit from one or more interfaces. The derived interface inherits the members from its base interfaces. A class that implements a derived interface must implement all members in the derived interface, including all members of the derived interface's base interfaces. That class may be implicitly converted to the derived interface or any of its base interfaces. A class might include an interface multiple times through base classes that it inherits or through interfaces that other interfaces inherit. However, the class can provide an implementation of an interface only one time and only if the class declares the interface as part of the definition of the class ( ). If the interface is inherited because you inherited a base class that implements the interface, the base class provides the implementation of the members of the interface. However, the derived class can reimplement any virtual interface members instead of using the inherited implementation. When interfaces declare a default implementation of a method, any class implementing that interface inherits that implementation (You need to cast the class instance to the interface type to access the default implementation on the Interface member).\n\nA base class can also implement interface members by using virtual members. In that case, a derived class can change the interface behavior by overriding the virtual members. For more information about virtual members, see Polymorphism.\n\nAn interface has the following properties:\n• In C# versions earlier than 8.0, an interface is like an abstract base class with only abstract members. A class or struct that implements the interface must implement all its members.\n• Beginning with C# 8.0, an interface may define default implementations for some or all of its members. A class or struct that implements the interface doesn't have to implement members that have default implementations. For more information, see default interface methods.\n• An interface can't be instantiated directly. Its members are implemented by any class or struct that implements the interface.\n• A class or struct can implement multiple interfaces. A class can inherit a base class and also implement one or more interfaces."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/216833/design-patterns-why-the-need-for-interfaces",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://refactoring.guru/design-patterns/csharp",
        "document": ""
    },
    {
        "link": "https://dofactory.com/net/design-patterns",
        "document": "Design patterns are solutions to software design problems you find again and again in real-world application development. Patterns are about reusable designs and interactions of objects.\n\nThe 23 Gang of Four (GoF) patterns are generally considered the foundation for all other patterns. They are categorized in three groups: Creational, Structural, and Behavioral (for a complete list see below). This reference provides source code for each of the 23 GoF patterns.\n\nTo give you a head start, the C# source code for each pattern is provided in 3 forms: structural, real-world, and .NET optimized.\n\n\n\n\n\nStructural code uses type names as defined in the pattern definition and UML diagrams. Real-world code provides real-world programming situations where you may use these patterns. The third form, .NET optimized, demonstrates design patterns that fully exploit the latest C# and .NET features, such as, generics, reflection, lambdas, primary constructors, and more."
    }
]