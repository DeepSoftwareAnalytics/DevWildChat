[
    {
        "link": "https://legacy.reactjs.org/docs/uncontrolled-components.html",
        "document": "These docs are old and won’t be updated. Go to react.dev for the new React docs. These new documentation pages teach modern React and include live examples:\n\nIn most cases, we recommend using controlled components to implement forms. In a controlled component, form data is handled by a React component. The alternative is uncontrolled components, where form data is handled by the DOM itself.\n\nTo write an uncontrolled component, instead of writing an event handler for every state update, you can use a ref to get form values from the DOM.\n\nFor example, this code accepts a single name in an uncontrolled component:\n\nTry it on CodePen\n\nSince an uncontrolled component keeps the source of truth in the DOM, it is sometimes easier to integrate React and non-React code when using uncontrolled components. It can also be slightly less code if you want to be quick and dirty. Otherwise, you should usually use controlled components.\n\nIf it’s still not clear which type of component you should use for a particular situation, you might find this article on controlled versus uncontrolled inputs to be helpful.\n\nIn the React rendering lifecycle, the attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a attribute instead of . Changing the value of attribute after a component has mounted will not cause any update of the value in the DOM.\n\nLikewise, and support , and and supports .\n\nIn HTML, an lets the user choose one or more files from their device storage to be uploaded to a server or manipulated by JavaScript via the File API.\n\nIn React, an is always an uncontrolled component because its value can only be set by a user, and not programmatically.\n\nYou should use the File API to interact with the files. The following example shows how to create a ref to the DOM node to access file(s) in a submit handler:\n\nTry it on CodePen"
    },
    {
        "link": "https://react.dev/reference/react-dom/components/input",
        "document": "Typically, you will place every inside a tag. This tells the browser that this label is associated with that input. When the user clicks the label, the browser will automatically focus the input. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the associated input. If you can’t nest into a , associate them by passing the same ID to and . To avoid conflicts between multiple instances of one component, generate such an ID with .\n\nGive a to every , for example . The you specified will be used as a key in the form data, for example . By default, a inside a without a attribute will submit it. This can be surprising! If you have your own custom React component, consider using instead of (with no type). Then, to be explicit, use for buttons that are supposed to submit the form. An input like is uncontrolled. Even if you pass an initial value like , your JSX only specifies the initial value. It does not control what the value should be right now. To render a controlled input, pass the prop to it (or for checkboxes and radios). React will force the input to always have the you passed. Usually, you would do this by declaring a state variable: A controlled input makes sense if you needed state anyway—for example, to re-render your UI on every edit: !== && Your name is .\n\n It’s also useful if you want to offer multiple ways to adjust the input state (for example, by clicking a button): The you pass to controlled components should not be or . If you need the initial value to be empty (such as with the field below), initialize your state variable to an empty string ( ).\n\nIf you pass without , it will be impossible to type into the input. When you control an input by passing some to it, you force it to always have the value you passed. So if you pass a state variable as a but forget to update that state variable synchronously during the event handler, React will revert the input after every keystroke back to the that you specified. When you use a controlled input, you set the state on every keystroke. If the component containing your state re-renders a large tree, this can get slow. There’s a few ways you can optimize re-rendering performance. For example, suppose you start with a form that re-renders all page content on every keystroke: Since doesn’t rely on the input state, you can move the input state into its own component: This significantly improves performance because now only re-renders on every keystroke. If there is no way to avoid re-rendering (for example, if depends on the search input’s value), lets you keep the controlled input responsive even in the middle of a large re-render. If you render an input with but no , you will see an error in the console: You provided a prop to a form field without an handler. This will render a read-only field. If the field should be mutable use . Otherwise, set either or . As the error message suggests, if you only wanted to specify the initial value, pass instead: If you want to control this input with a state variable, specify an handler: If the value is intentionally read-only, add a prop to suppress the error: If you render a checkbox with but no , you will see an error in the console: You provided a prop to a form field without an handler. This will render a read-only field. If the field should be mutable use . Otherwise, set either or . As the error message suggests, if you only wanted to specify the initial value, pass instead: If you want to control this checkbox with a state variable, specify an handler: You need to read rather than for checkboxes. If the checkbox is intentionally read-only, add a prop to suppress the error: My input caret jumps to the beginning on every keystroke If you control an input, you must update its state variable to the input’s value from the DOM during . You can’t update it to something other than (or for checkboxes): You also can’t update it asynchronously: To fix your code, update it synchronously to : If this doesn’t fix the problem, it’s possible that the input gets removed and re-added from the DOM on every keystroke. This can happen if you’re accidentally resetting state on every re-render, for example if the input or one of its parents always receives a different attribute, or if you nest component function definitions (which is not supported and causes the “inner” component to always be considered a different tree). I’m getting an error: “A component is changing an uncontrolled input to be controlled” If you provide a to the component, it must remain a string throughout its lifetime. You cannot pass first and later pass because React won’t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string , not or . If your is coming from an API or a state variable, it might be initialized to or . In that case, either set it to an empty string ( ) initially, or pass to ensure is a string. Similarly, if you pass to a checkbox, ensure it’s always a boolean."
    },
    {
        "link": "https://reddit.com/r/reactjs/comments/1e4jj3n/controlled_or_uncontrolled_form_elements",
        "document": "I've been defaulting to using controlled elements 99% of the time. But I'm realising there may be less code overall with uncontrolled form elements, and maybe slight performance benefits.\n\nThe (old?) react docs seem to say to prefer controlled components. But I would be interested to hear from you folks.\n\nSo what are the reasons to pick one over the other? Which one do you prefer? Is it situational? Or is the grass just greener on the uncontrolled side."
    },
    {
        "link": "https://geeksforgeeks.org/controlled-vs-uncontrolled-components-in-reactjs",
        "document": "Controlled components in React are the components whose state and behaviors are managed by React components using states while the uncontrolled components manage their own state and control their behaviors with the help of DOM.\n\nUnderstanding the difference between controlled and uncontrolled components is essential for managing form data.\n\nUncontrolled Components are the components that do not rely on the React state and are handled by the DOM (Document Object Model). So in order to access any value that has been entered we take the help of refs.\n\nFor instance, if we want to add a file as an input, this cannot be controlled as this depends on the browser so this is an example of an uncontrolled input.\n\nExample: We are creating a simple form that comprises an input field with a label name and a submit button with an onSubmit function that triggers when we submit the form. We are accessing the name we have filled using useRef.\n\nStep to Run Application: Run the application using the following command from the root directory of the project:\n\nOutput: This output will be visible on http://localhost:3000/ in the Web browser.\n\nIn React, Controlled Components are those in which form’s data is handled by the component’s state. It takes its current value through props and makes changes through callbacks like onClick, onChange, etc. A parent component manages its own state and passes the new values as props to the controlled component.\n\nExample: We are creating a state name that stores the value we enter into the input field using the useState hook. We are creating an onChange function in the input field that stores the data we are entering in the input field to our state. There is another function handleSumit that gets triggered when we submit the form and it shows the name we have entered on the alert box.\n\nStep to Run Application: Run the application using the following command from the root directory of the project:\n\nOutput: This output will be visible on http://localhost:3000/ in the Web browser."
    },
    {
        "link": "https://stackoverflow.com/questions/37427508/react-changing-an-uncontrolled-input",
        "document": "I believe my input is controlled since it has a value. I am wondering what am I doing wrong?\n\nWarning: MyForm is changing an uncontrolled input of type text to be controlled. Input elements should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled input element for the lifetime of the component\n\nWhen I run my application I get the following warning:\n\nI have a simple react component with the form which I believe to have one controlled input:\n\nI believe my input is controlled since it has a value. For an input to be controlled, its value must correspond to that of a state variable. That condition is not initially met in your example because is not initially set. Therefore, the input is initially uncontrolled. Once the handler is triggered for the first time, gets set. At that point, the above condition is satisfied and the input is considered to be controlled. This transition from uncontrolled to controlled produces the error seen above. By initializing in the constructor: the input will be controlled from the start, fixing the issue. See React Controlled Components for more examples. Unrelated to this error, you should only have one default export. Your code above has two.\n\nWhen you first render your component, isn't set, so it evaluates to or , and you end up passing or to your . When ReactDOM checks to see if a field is controlled, it checks to see if (note that it's , not ), and since in JavaScript, it decides that it's uncontrolled. So, when is called, is set to a string value, your input goes from being uncontrolled to being controlled. If you do in your constructor, because , your input will have a value the whole time, and that message will go away.\n\nIn short, if you are using class component you have to initialize the input using state, like this: and you have to do this for all of your inputs you'd like to change their values in code. In the case of using functional components, you will be using hooks to manage the input value, and you have to put initial value for each input you'd like to manipulate later like this: If you'd like to have no initial value, you can put an empty string.\n\nI believe my input is controlled since it has a value. Now you can do this two ways the best way is to have a state key to each input with 1 onChange handler. If you have checkboxes you will need to write a separate onChange handler. With a Class component you would want to write it like this 👇 import React from 'react'; export default class MyForm extends React.Component { constructor(props) { super(props); this.state = { myFormFields: { name: '', dob: '', phone: '' } } this.onFormFieldChange = this.onFormFieldChange.bind(this) } // Always have your functions before your render to keep state batches in sync. onFormFieldChange(e) { // No need to return this function can be void this.setState({ myFormFields: { ...this.state.myFormFields, [e.target.name]: e.target.value } }) } render() { // Beauty of classes we can destruct our state making it easier to place const { myFormFields } = this.state return ( <form className=\"add-support-staff-form\"> <input name=\"name\" type=\"text\" value={myFormFields.name} onChange={this.onFormFieldChange}/> <input name=\"dob\" type=\"date\" value={myFormFields.dob} onChange={this.onFormFieldChange}/> <input name=\"phone\" type=\"number\" value={myFormFields.phone} onChange={this.onFormFieldChange}/> </form> ) } } export default MyForm; Hope that helps for a class but the most performative and what the newest thing the devs are pushing everyone to use is Functional Components. This is what you would want to steer to as class components don't intertwine well with the latest libraries as they all use custom hooks now. import React, { useState } from 'react'; const MyForm = (props) => { // Create form initial state const [myFormFields, setFormFields] = useState({ name: '', dob: '', phone: '' }) // Always have your functions before your return to keep state batches in sync. const onFormFieldChange = (e) => { // No need to return this function can be void setFormFields({ ...myFormFields, [e.target.name]: e.target.value }) } return ( <form className=\"add-support-staff-form\"> <input name=\"name\" type=\"text\" value={myFormFields.name} onChange={onFormFieldChange}/> <input name=\"dob\" type=\"date\" value={myFormFields.dob} onChange={onFormFieldChange}/> <input name=\"phone\" type=\"number\" value={myFormFields.phone} onChange={onFormFieldChange}/> </form> ) } export default MyForm;\n\nIn my case component was rerendering and throwing A component is changing an uncontrolled input of type checkbox to be controlled error. It turned out that this behaviour was a result of not keeping or for checkbox checked state (sometimes I got ). Here what my faulty component looked like: import * as React from 'react'; import { WrappedFieldProps } from 'redux-form/lib/Field'; type Option = { value: string; label: string; }; type CheckboxGroupProps = { name: string; options: Option[]; } & WrappedFieldProps; const CheckboxGroup: React.FC<CheckboxGroupProps> = (props) => { const { name, input, options, } = props; const [value, setValue] = React.useState<string>(); const [checked, setChecked] = React.useState<{ [name: string]: boolean }>( () => options.reduce((accu, option) => { accu[option.value] = false; return accu; }, {}), ); React.useEffect(() => { input.onChange(value); if (value) { setChecked({ [value]: true, // that setChecked argument is wrong, causes error }); } else { setChecked(() => options.reduce((accu, option) => { accu[option.value] = false; return accu; }, {})); } }, [value]); return ( <> {options.map(({ value, label }, index) => { return ( <LabeledContainer key={`${value}${index}`} > <Checkbox name={`${name}[${index}]`} checked={checked[value]} value={value} onChange={(event) => { if (event.target.checked) { setValue(value); } else { setValue(undefined); } return true; }} /> {label} </LabeledContainer> ); })} </> ); }; To fix that problem I changed to this That made all checkboxes keep their state as or without falling into which switches control from React to developer and vice versa.\n\nThis generally happens only when you are not controlling the value of the filed when the application started and after some event or some function fired or the state changed, you are now trying to control the value in input field. This transition of not having control over the input and then having control over it is what causes the issue to happen in the first place. The best way to avoid this is by declaring some value for the input in the constructor of the component. So that the input element has value from the start of the application."
    },
    {
        "link": "https://github.com/acdlite/react-fiber-architecture",
        "document": "React Fiber is an ongoing reimplementation of React's core algorithm. It is the culmination of over two years of research by the React team.\n\nThe goal of React Fiber is to increase its suitability for areas like animation, layout, and gestures. Its headline feature is incremental rendering: the ability to split rendering work into chunks and spread it out over multiple frames.\n\nOther key features include the ability to pause, abort, or reuse work as new updates come in; the ability to assign priority to different types of updates; and new concurrency primitives.\n\nFiber introduces several novel concepts that are difficult to grok solely by looking at code. This document began as a collection of notes I took as I followed along with Fiber's implementation in the React project. As it grew, I realized it may be a helpful resource for others, too.\n\nI'll attempt to use the plainest language possible, and to avoid jargon by explicitly defining key terms. I'll also link heavily to external resources when possible.\n\nPlease note that I am not on the React team, and do not speak from any authority. This is not an official document. I have asked members of the React team to review it for accuracy.\n\nThis is also a work in progress. Fiber is an ongoing project that will likely undergo significant refactors before it's completed. Also ongoing are my attempts at documenting its design here. Improvements and suggestions are highly welcome.\n\nMy goal is that after reading this document, you will understand Fiber well enough to follow along as it's implemented, and eventually even be able to contribute back to React.\n\nI strongly suggest that you are familiar with the following resources before continuing:\n• React Components, Elements, and Instances - \"Component\" is often an overloaded term. A firm grasp of these terms is crucial.\n• React Basic Theoretical Concepts - A description of the conceptual model of React without implementation burden. Some of this may not make sense on first reading. That's okay, it will make more sense with time.\n• React Design Principles - Pay special attention to the section on scheduling. It does a great job of explaining the why of React Fiber.\n\nPlease check out the prerequisites section if you haven't already.\n\nBefore we dive into the new stuff, let's review a few concepts.\n\nThe central idea of React's API is to think of updates as if they cause the entire app to re-render. This allows the developer to reason declaratively, rather than worry about how to efficiently transition the app from any particular state to another (A to B, B to C, C to A, and so on).\n\nActually re-rendering the entire app on each change only works for the most trivial apps; in a real-world app, it's prohibitively costly in terms of performance. React has optimizations which create the appearance of whole app re-rendering while maintaining great performance. The bulk of these optimizations are part of a process called reconciliation.\n\nReconciliation is the algorithm behind what is popularly understood as the \"virtual DOM.\" A high-level description goes something like this: when you render a React application, a tree of nodes that describes the app is generated and saved in memory. This tree is then flushed to the rendering environment — for example, in the case of a browser application, it's translated to a set of DOM operations. When the app is updated (usually via ), a new tree is generated. The new tree is diffed with the previous tree to compute which operations are needed to update the rendered app.\n\nAlthough Fiber is a ground-up rewrite of the reconciler, the high-level algorithm described in the React docs will be largely the same. The key points are:\n• Different component types are assumed to generate substantially different trees. React will not attempt to diff them, but rather replace the old tree completely.\n• Diffing of lists is performed using keys. Keys should be \"stable, predictable, and unique.\"\n\nThe DOM is just one of the rendering environments React can render to, the other major targets being native iOS and Android views via React Native. (This is why \"virtual DOM\" is a bit of a misnomer.)\n\nThe reason it can support so many targets is because React is designed so that reconciliation and rendering are separate phases. The reconciler does the work of computing which parts of a tree have changed; the renderer then uses that information to actually update the rendered app.\n\nThis separation means that React DOM and React Native can use their own renderers while sharing the same reconciler, provided by React core.\n\nFiber reimplements the reconciler. It is not principally concerned with rendering, though renderers will need to change to support (and take advantage of) the new architecture.\n\nReact's Design Principles document is so good on this subject that I'll just quote it here:\n• In a UI, it's not necessary for every update to be applied immediately; in fact, doing so can be wasteful, causing frames to drop and degrading the user experience.\n• Different types of updates have different priorities — an animation update needs to complete more quickly than, say, an update from a data store.\n• A push-based approach requires the app (you, the programmer) to decide how to schedule work. A pull-based approach allows the framework (React) to be smart and make those decisions for you.\n\nReact doesn't currently take advantage of scheduling in a significant way; an update results in the entire subtree being re-rendered immediately. Overhauling React's core algorithm to take advantage of scheduling is the driving idea behind Fiber.\n\nNow we're ready to dive into Fiber's implementation. The next section is more technical than what we've discussed so far. Please make sure you're comfortable with the previous material before moving on.\n\nWe're about to discuss the heart of React Fiber's architecture. Fibers are a much lower-level abstraction than application developers typically think about. If you find yourself frustrated in your attempts to understand it, don't feel discouraged. Keep trying and it will eventually make sense. (When you do finally get it, please suggest how to improve this section.)\n\nHere we go!\n\nWe've established that a primary goal of Fiber is to enable React to take advantage of scheduling. Specifically, we need to be able to\n• pause work and come back to it later.\n• assign priority to different types of work.\n• abort work if it's no longer needed.\n\nIn order to do any of this, we first need a way to break work down into units. In one sense, that's what a fiber is. A fiber represents a unit of work.\n\nTo go further, let's go back to the conception of React components as functions of data, commonly expressed as\n\nIt follows that rendering a React app is akin to calling a function whose body contains calls to other functions, and so on. This analogy is useful when thinking about fibers.\n\nThe way computers typically track a program's execution is using the call stack. When a function is executed, a new stack frame is added to the stack. That stack frame represents the work that is performed by that function.\n\nWhen dealing with UIs, the problem is that if too much work is executed all at once, it can cause animations to drop frames and look choppy. What's more, some of that work may be unnecessary if it's superseded by a more recent update. This is where the comparison between UI components and function breaks down, because components have more specific concerns than functions in general.\n\nNewer browsers (and React Native) implement APIs that help address this exact problem: schedules a low priority function to be called during an idle period, and schedules a high priority function to be called on the next animation frame. The problem is that, in order to use those APIs, you need a way to break rendering work into incremental units. If you rely only on the call stack, it will keep doing work until the stack is empty.\n\nWouldn't it be great if we could customize the behavior of the call stack to optimize for rendering UIs? Wouldn't it be great if we could interrupt the call stack at will and manipulate stack frames manually?\n\nThat's the purpose of React Fiber. Fiber is reimplementation of the stack, specialized for React components. You can think of a single fiber as a virtual stack frame.\n\nThe advantage of reimplementing the stack is that you can keep stack frames in memory and execute them however (and whenever) you want. This is crucial for accomplishing the goals we have for scheduling.\n\nAside from scheduling, manually dealing with stack frames unlocks the potential for features such as concurrency and error boundaries. We will cover these topics in future sections.\n\nIn the next section, we'll look more at the structure of a fiber.\n\nNote: as we get more specific about implementation details, the likelihood that something may change increases. Please file a PR if you notice any mistakes or outdated information.\n\nIn concrete terms, a fiber is a JavaScript object that contains information about a component, its input, and its output.\n\nA fiber corresponds to a stack frame, but it also corresponds to an instance of a component.\n\nHere are some of the important fields that belong to a fiber. (This list is not exhaustive.)\n\nThe type and key of a fiber serve the same purpose as they do for React elements. (In fact, when a fiber is created from an element, these two fields are copied over directly.)\n\nThe type of a fiber describes the component that it corresponds to. For composite components, the type is the function or class component itself. For host components ( , , etc.), the type is a string.\n\nConceptually, the type is the function (as in ) whose execution is being tracked by the stack frame.\n\nAlong with the type, the key is used during reconciliation to determine whether the fiber can be reused.\n\nThese fields point to other fibers, describing the recursive tree structure of a fiber.\n\nThe child fiber corresponds to the value returned by a component's method. So in the following example\n\nThe child fiber of corresponds to .\n\nThe sibling field accounts for the case where returns multiple children (a new feature in Fiber!):\n\nThe child fibers form a singly-linked list whose head is the first child. So in this example, the child of is and the sibling of is .\n\nGoing back to our function analogy, you can think of a child fiber as a tail-called function.\n\nThe return fiber is the fiber to which the program should return after processing the current one. It is conceptually the same as the return address of a stack frame. It can also be thought of as the parent fiber.\n\nIf a fiber has multiple child fibers, each child fiber's return fiber is the parent. So in our example in the previous section, the return fiber of and is .\n\nConceptually, props are the arguments of a function. A fiber's are set at the beginning of its execution, and are set at the end.\n\nWhen the incoming are equal to , it signals that the fiber's previous output can be reused, preventing unnecessary work.\n\nA number indicating the priority of the work represented by the fiber. The ReactPriorityLevel module lists the different priority levels and what they represent.\n\nWith the exception of , which is 0, a larger number indicates a lower priority. For example, you could use the following function to check if a fiber's priority is at least as high as the given level:\n\nThis function is for illustration only; it's not actually part of the React Fiber codebase.\n\nThe scheduler uses the priority field to search for the next unit of work to perform. This algorithm will be discussed in a future section.\n\nAt any time, a component instance has at most two fibers that correspond to it: the current, flushed fiber, and the work-in-progress fiber.\n\nThe alternate of the current fiber is the work-in-progress, and the alternate of the work-in-progress is the current fiber.\n\nA fiber's alternate is created lazily using a function called . Rather than always creating a new object, will attempt to reuse the fiber's alternate if it exists, minimizing allocations.\n\nYou should think of the field as an implementation detail, but it pops up often enough in the codebase that it's valuable to discuss it here.\n\nConceptually, the output of a fiber is the return value of a function.\n\nEvery fiber eventually has output, but output is created only at the leaf nodes by host components. The output is then transferred up the tree.\n\nThe output is what is eventually given to the renderer so that it can flush the changes to the rendering environment. It's the renderer's responsibility to define how the output is created and updated.\n\nThat's all there is for now, but this document is nowhere near complete. Future sections will describe the algorithms used throughout the lifecycle of an update. Topics to cover include:\n• how the scheduler finds the next unit of work to perform.\n• how priority is tracked and propagated through the fiber tree.\n• how the scheduler knows when to pause and resume work.\n• how work is flushed and marked as complete.\n• how side-effects (such as lifecycle methods) work.\n• what a coroutine is and how it can be used to implement features like context and layout."
    },
    {
        "link": "https://legacy.reactjs.org/docs/react-api.html",
        "document": "is the entry point to the React library. If you load React from a tag, these top-level APIs are available on the global. If you use ES6 with npm, you can write . If you use ES5 with npm, you can write .\n\nReact components let you split the UI into independent, reusable pieces, and think about each piece in isolation. React components can be defined by subclassing or .\n\nIf you don’t use ES6 classes, you may use the module instead. See Using React without ES6 for more information.\n\nReact components can also be defined as functions which can be wrapped:\n\nWe recommend using JSX to describe what your UI should look like. Each JSX element is just syntactic sugar for calling . You will not typically invoke the following methods directly if you are using JSX.\n\nSee Using React without JSX for more information.\n\nprovides several APIs for manipulating elements:\n\nalso provides a component for rendering multiple elements without a wrapper.\n\nSuspense lets components “wait” for something before rendering. Today, Suspense only supports one use case: loading components dynamically with . In the future, it will support other use cases like data fetching.\n\nTransitions are a new concurrent feature introduced in React 18. They allow you to mark updates as transitions, which tells React that they can be interrupted and avoid going back to Suspense fallbacks for already visible content.\n\nHooks are a new addition in React 16.8. They let you use state and other React features without writing a class. Hooks have a dedicated docs section and a separate API reference:\n\nis the base class for React components when they are defined using ES6 classes:\n\nSee the React.Component API Reference for a list of methods and properties related to the base class.\n\nis similar to . The difference between them is that doesn’t implement , but implements it with a shallow prop and state comparison.\n\nIf your React component’s function renders the same result given the same props and state, you can use for a performance boost in some cases.\n\nIf your component renders the same result given the same props, you can wrap it in a call to for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result.\n\nonly checks for prop changes. If your function component wrapped in has a , or Hook in its implementation, it will still rerender when state or context change.\n\nBy default it will only shallowly compare complex objects in the props object. If you want control over the comparison, you can also provide a custom comparison function as the second argument.\n\nThis method only exists as a performance optimization. Do not rely on it to “prevent” a render, as this can lead to bugs.\n\nCreate and return a new React element of the given type. The type argument can be either a tag name string (such as or ), a React component type (a class or a function), or a React fragment type.\n\nCode written with JSX will be converted to use . You will not typically invoke directly if you are using JSX. See React Without JSX to learn more.\n\nClone and return a new React element using as the starting point. should contain all new props, , or . The resulting element will have the original element’s props with the new props merged in shallowly. New children will replace existing children. and from the original element will be preserved if no and present in the .\n\nis almost equivalent to:\n\nHowever, it also preserves s. This means that if you get a child with a on it, you won’t accidentally steal it from your ancestor. You will get the same attached to your new element. The new or will replace old ones if present.\n\nThis API was introduced as a replacement of the deprecated .\n\nReturn a function that produces React elements of a given type. Like , the type argument can be either a tag name string (such as or ), a React component type (a class or a function), or a React fragment type.\n\nThis helper is considered legacy, and we encourage you to either use JSX or use directly instead.\n\nYou will not typically invoke directly if you are using JSX. See React Without JSX to learn more.\n\nVerifies the object is a React element. Returns or .\n\nprovides utilities for dealing with the opaque data structure.\n\nInvokes a function on every immediate child contained within with set to . If is an array it will be traversed and the function will be called for each child in the array. If children is or , this method will return or rather than an array.\n\nLike but does not return an array.\n\nReturns the total number of components in , equal to the number of times that a callback passed to or would be invoked.\n\nVerifies that has only one child (a React element) and returns it. Otherwise this method throws an error.\n\nReturns the opaque data structure as a flat array with keys assigned to each child. Useful if you want to manipulate collections of children in your render methods, especially if you want to reorder or slice before passing it down.\n\nThe component lets you return multiple elements in a method without creating an additional DOM element:\n\nYou can also use it with the shorthand syntax. For more information, see React v16.2.0: Improved Support for Fragments.\n\ncreates a ref that can be attached to React elements via the ref attribute.\n\ncreates a React component that forwards the ref attribute it receives to another component below in the tree. This technique is not very common but is particularly useful in two scenarios:\n\naccepts a rendering function as an argument. React will call this function with and as two arguments. This function should return a React node.\n\nIn the above example, React passes a given to element as a second argument to the rendering function inside the call. This rendering function passes the to the element.\n\nAs a result, after React attaches the ref, will point directly to the DOM element instance.\n\nFor more information, see forwarding refs.\n\nlets you define a component that is loaded dynamically. This helps reduce the bundle size to delay loading components that aren’t used during the initial render.\n\nYou can learn how to use it from our code splitting documentation. You might also want to check out this article explaining how to use it in more detail.\n\nNote that rendering components requires that there’s a component higher in the rendering tree. This is how you specify a loading indicator.\n\nlets you specify the loading indicator in case some components in the tree below it are not yet ready to render. In the future we plan to let handle more scenarios such as data fetching. You can read about this in our roadmap.\n\nToday, lazy loading components is the only use case supported by :\n\nIt is documented in our code splitting guide. Note that components can be deep inside the tree — it doesn’t have to wrap every one of them. The best practice is to place where you want to see a loading indicator, but to use wherever you want to do code splitting.\n\nDuring server side rendering Suspense Boundaries allow you to flush your application in smaller chunks by suspending. When a component suspends we schedule a low priority task to render the closest Suspense boundary’s fallback. If the component unsuspends before we flush the fallback then we send down the actual content and throw away the fallback.\n\nSuspense boundaries depend on their parent boundaries being hydrated before they can hydrate, but they can hydrate independently from sibling boundaries. Events on a boundary before it is hydrated will cause the boundary to hydrate at a higher priority than neighboring boundaries. Read more\n\nlets you mark updates inside the provided callback as transitions. This method is designed to be used when is not available."
    },
    {
        "link": "https://legacy.reactjs.org/docs/react-component.html",
        "document": "This page contains a detailed API reference for the React component class definition. It assumes you’re familiar with fundamental React concepts, such as Components and Props, as well as State and Lifecycle. If you’re not, read them first.\n\nReact lets you define components as classes or functions. Components defined as classes currently provide more features which are described in detail on this page. To define a React component class, you need to extend :\n\nThe only method you must define in a subclass is called . All the other methods described on this page are optional.\n\nWe strongly recommend against creating your own base component classes. In React components, code reuse is primarily achieved through composition rather than inheritance.\n\nEach component has several “lifecycle methods” that you can override to run code at particular times in the process. You can use this lifecycle diagram as a cheat sheet. In the list below, commonly used lifecycle methods are marked as bold. The rest of them exist for relatively rare use cases.\n\nThese methods are called in the following order when an instance of a component is being created and inserted into the DOM:\n\nAn update can be caused by changes to props or state. These methods are called in the following order when a component is being re-rendered:\n\nThis method is called when a component is being removed from the DOM:\n\nThese methods are called when there is an error during rendering, in a lifecycle method, or in the constructor of any child component.\n\nEach component also provides some other APIs:\n\nThe methods in this section cover the vast majority of use cases you’ll encounter creating React components. For a visual reference, check out this lifecycle diagram.\n\nThe method is the only required method in a class component.\n\nWhen called, it should examine and and return one of the following types:\n• React elements. Typically created via JSX. For example, and are React elements that instruct React to render a DOM node, or another user-defined component, respectively.\n• Arrays and fragments. Let you return multiple elements from render. See the documentation on fragments for more details.\n• Portals. Let you render children into a different DOM subtree. See the documentation on portals for more details.\n• String and numbers. These are rendered as text nodes in the DOM.\n• Booleans or or . Render nothing. (Mostly exists to support pattern, where is boolean).\n\nThe function should be pure, meaning that it does not modify component state, it returns the same result each time it’s invoked, and it does not directly interact with the browser.\n\nIf you need to interact with the browser, perform your work in or the other lifecycle methods instead. Keeping pure makes components easier to think about.\n\nIf you don’t initialize state and you don’t bind methods, you don’t need to implement a constructor for your React component.\n\nThe constructor for a React component is called before it is mounted. When implementing the constructor for a subclass, you should call before any other statement. Otherwise, will be undefined in the constructor, which can lead to bugs.\n\nTypically, in React constructors are only used for two purposes:\n• Initializing local state by assigning an object to .\n\nYou should not call in the . Instead, if your component needs to use local state, assign the initial state to directly in the constructor:\n\nConstructor is the only place where you should assign directly. In all other methods, you need to use instead.\n\nAvoid introducing any side-effects or subscriptions in the constructor. For those use cases, use instead.\n\nis invoked immediately after a component is mounted (inserted into the tree). Initialization that requires DOM nodes should go here. If you need to load data from a remote endpoint, this is a good place to instantiate the network request.\n\nThis method is a good place to set up any subscriptions. If you do that, don’t forget to unsubscribe in .\n\nYou may call immediately in . It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the will be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.\n\nis invoked immediately after updating occurs. This method is not called for the initial render.\n\nUse this as an opportunity to operate on the DOM when the component has been updated. This is also a good place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed).\n\nYou may call immediately in but note that it must be wrapped in a condition like in the example above, or you’ll cause an infinite loop. It would also cause an extra re-rendering which, while not visible to the user, can affect the component performance. If you’re trying to “mirror” some state to a prop coming from above, consider using the prop directly instead. Read more about why copying props into state causes bugs.\n\nIf your component implements the lifecycle (which is rare), the value it returns will be passed as a third “snapshot” parameter to . Otherwise this parameter will be undefined.\n\nis invoked immediately before a component is unmounted and destroyed. Perform any necessary cleanup in this method, such as invalidating timers, canceling network requests, or cleaning up any subscriptions that were created in .\n\nYou should not call in because the component will never be re-rendered. Once a component instance is unmounted, it will never be mounted again.\n\nThe methods in this section correspond to uncommon use cases. They’re handy once in a while, but most of your components probably don’t need any of them. You can see most of the methods below on this lifecycle diagram if you click the “Show less common lifecycles” checkbox at the top of it.\n\nUse to let React know if a component’s output is not affected by the current change in state or props. The default behavior is to re-render on every state change, and in the vast majority of cases you should rely on the default behavior.\n\nis invoked before rendering when new props or state are being received. Defaults to . This method is not called for the initial render or when is used.\n\nThis method only exists as a performance optimization. Do not rely on it to “prevent” a rendering, as this can lead to bugs. Consider using the built-in instead of writing by hand. performs a shallow comparison of props and state, and reduces the chance that you’ll skip a necessary update.\n\nIf you are confident you want to write it by hand, you may compare with and with and return to tell React the update can be skipped. Note that returning does not prevent child components from re-rendering when their state changes.\n\nWe do not recommend doing deep equality checks or using in . It is very inefficient and will harm performance.\n\nCurrently, if returns , then , , and will not be invoked. In the future React may treat as a hint rather than a strict directive, and returning may still result in a re-rendering of the component.\n\nis invoked right before calling the render method, both on the initial mount and on subsequent updates. It should return an object to update the state, or to update nothing.\n\nThis method exists for rare use cases where the state depends on changes in props over time. For example, it might be handy for implementing a component that compares its previous and next children to decide which of them to animate in and out.\n\nDeriving state leads to verbose code and makes your components difficult to think about. Make sure you’re familiar with simpler alternatives:\n• If you need to perform a side effect (for example, data fetching or an animation) in response to a change in props, use lifecycle instead.\n• If you want to re-compute some data only when a prop changes, use a memoization helper instead.\n• If you want to “reset” some state when a prop changes, consider either making a component fully controlled or fully uncontrolled with a instead.\n\nThis method doesn’t have access to the component instance. If you’d like, you can reuse some code between and the other class methods by extracting pure functions of the component props and state outside the class definition.\n\nNote that this method is fired on every render, regardless of the cause. This is in contrast to , which only fires when the parent causes a re-render and not as a result of a local .\n\nis invoked right before the most recently rendered output is committed to e.g. the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to .\n\nThis use case is not common, but it may occur in UIs like a chat thread that need to handle scroll position in a special way.\n\nA snapshot value (or ) should be returned.\n\nIn the above examples, it is important to read the property in because there may be delays between “render” phase lifecycles (like ) and “commit” phase lifecycles (like and ).\n\nError boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.\n\nA class component becomes an error boundary if it defines either (or both) of the lifecycle methods or . Updating state from these lifecycles lets you capture an unhandled JavaScript error in the below tree and display a fallback UI.\n\nOnly use error boundaries for recovering from unexpected exceptions; don’t try to use them for control flow.\n\nFor more details, see Error Handling in React 16.\n\nThis lifecycle is invoked after an error has been thrown by a descendant component. It receives the error that was thrown as a parameter and should return a value to update state.\n\nThis lifecycle is invoked after an error has been thrown by a descendant component. It receives two parameters:\n• - The error that was thrown.\n• - An object with a key containing information about which component threw the error.\n\nis called during the “commit” phase, so side-effects are permitted. It should be used for things like logging errors:\n\nProduction and development builds of React slightly differ in the way handles errors.\n\nOn development, the errors will bubble up to , this means that any or will intercept the errors that have been caught by .\n\nOn production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught by .\n\nThe lifecycle methods below are marked as “legacy”. They still work, but we don’t recommend using them in the new code. You can learn more about migrating away from legacy lifecycle methods in this blog post.\n\nis invoked just before mounting occurs. It is called before , therefore calling synchronously in this method will not trigger an extra rendering. Generally, we recommend using the instead for initializing state.\n\nAvoid introducing any side-effects or subscriptions in this method. For those use cases, use instead.\n\nThis is the only lifecycle method called on server rendering.\n\nis invoked before a mounted component receives new props. If you need to update the state in response to prop changes (for example, to reset it), you may compare and and perform state transitions using in this method.\n\nNote that if a parent component causes your component to re-render, this method will be called even if props have not changed. Make sure to compare the current and next values if you only want to handle changes.\n\nReact doesn’t call with initial props during mounting. It only calls this method if some of component’s props may update. Calling generally doesn’t trigger .\n\nis invoked just before rendering when new props or state are being received. Use this as an opportunity to perform preparation before an update occurs. This method is not called for the initial render.\n\nNote that you cannot call here; nor should you do anything else (e.g. dispatch a Redux action) that would trigger an update to a React component before returns.\n\nTypically, this method can be replaced by . If you were reading from the DOM in this method (e.g. to save a scroll position), you can move that logic to .\n\nUnlike the lifecycle methods above (which React calls for you), the methods below are the methods you can call from your components.\n\nThere are just two of them: and .\n\nenqueues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state. This is the primary method you use to update the user interface in response to event handlers and server responses.\n\nThink of as a request rather than an immediate command to update the component. For better perceived performance, React may delay it, and then update several components in a single pass. In the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in , but this may hurt performance.\n\ndoes not always immediately update the component. It may batch or defer the update until later. This makes reading right after calling a potential pitfall. Instead, use or a callback ( ), either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, read about the argument below.\n\nwill always lead to a re-render unless returns . If mutable objects are being used and conditional rendering logic cannot be implemented in , calling only when the new state differs from the previous state will avoid unnecessary re-renders.\n\nThe first argument is an function with the signature:\n\nis a reference to the component state at the time the change is being applied. It should not be directly mutated. Instead, changes should be represented by building a new object based on the input from and . For instance, suppose we wanted to increment a value in state by :\n\nBoth and received by the updater function are guaranteed to be up-to-date. The output of the updater is shallowly merged with .\n\nThe second parameter to is an optional callback function that will be executed once is completed and the component is re-rendered. Generally we recommend using for such logic instead.\n\nYou may optionally pass an object as the first argument to instead of a function:\n\nThis performs a shallow merge of into the new state, e.g., to adjust a shopping cart item quantity:\n\nThis form of is also asynchronous, and multiple calls during the same cycle may be batched together. For example, if you attempt to increment an item quantity more than once in the same cycle, that will result in the equivalent of:\n\nSubsequent calls will override values from previous calls in the same cycle, so the quantity will only be incremented once. If the next state depends on the current state, we recommend using the updater function form, instead:\n\nFor more detail, see:\n• In depth: When and why are calls batched?\n\nBy default, when your component’s state or props change, your component will re-render. If your method depends on some other data, you can tell React that the component needs re-rendering by calling .\n\nCalling will cause to be called on the component, skipping . This will trigger the normal lifecycle methods for child components, including the method of each child. React will still only update the DOM if the markup changes.\n\nNormally you should try to avoid all uses of and only read from and in .\n\ncan be defined as a property on the component class itself, to set the default props for the class. This is used for props, but not for props. For example:\n\nIf is not provided, it will be set by default to :\n\nIf is set to , it will remain :\n\nThe string is used in debugging messages. Usually, you don’t need to set it explicitly because it’s inferred from the name of the function or class that defines the component. You might want to set it explicitly if you want to display a different name for debugging purposes or when you create a higher-order component, see Wrap the Display Name for Easy Debugging for details.\n\ncontains the props that were defined by the caller of this component. See Components and Props for an introduction to props.\n\nIn particular, is a special prop, typically defined by the child tags in the JSX expression rather than in the tag itself.\n\nThe state contains data specific to this component that may change over time. The state is user-defined, and it should be a plain JavaScript object.\n\nIf some value isn’t used for rendering or data flow (for example, a timer ID), you don’t have to put it in the state. Such values can be defined as fields on the component instance.\n\nSee State and Lifecycle for more information about the state.\n\nNever mutate directly, as calling afterwards may replace the mutation you made. Treat as if it were immutable."
    },
    {
        "link": "https://github.com/acdlite/react-fiber-architecture/blob/master/README.md",
        "document": "React Fiber is an ongoing reimplementation of React's core algorithm. It is the culmination of over two years of research by the React team.\n\nThe goal of React Fiber is to increase its suitability for areas like animation, layout, and gestures. Its headline feature is incremental rendering: the ability to split rendering work into chunks and spread it out over multiple frames.\n\nOther key features include the ability to pause, abort, or reuse work as new updates come in; the ability to assign priority to different types of updates; and new concurrency primitives.\n\nFiber introduces several novel concepts that are difficult to grok solely by looking at code. This document began as a collection of notes I took as I followed along with Fiber's implementation in the React project. As it grew, I realized it may be a helpful resource for others, too.\n\nI'll attempt to use the plainest language possible, and to avoid jargon by explicitly defining key terms. I'll also link heavily to external resources when possible.\n\nPlease note that I am not on the React team, and do not speak from any authority. This is not an official document. I have asked members of the React team to review it for accuracy.\n\nThis is also a work in progress. Fiber is an ongoing project that will likely undergo significant refactors before it's completed. Also ongoing are my attempts at documenting its design here. Improvements and suggestions are highly welcome.\n\nMy goal is that after reading this document, you will understand Fiber well enough to follow along as it's implemented, and eventually even be able to contribute back to React.\n\nI strongly suggest that you are familiar with the following resources before continuing:\n• React Components, Elements, and Instances - \"Component\" is often an overloaded term. A firm grasp of these terms is crucial.\n• React Basic Theoretical Concepts - A description of the conceptual model of React without implementation burden. Some of this may not make sense on first reading. That's okay, it will make more sense with time.\n• React Design Principles - Pay special attention to the section on scheduling. It does a great job of explaining the why of React Fiber.\n\nPlease check out the prerequisites section if you haven't already.\n\nBefore we dive into the new stuff, let's review a few concepts.\n\nThe central idea of React's API is to think of updates as if they cause the entire app to re-render. This allows the developer to reason declaratively, rather than worry about how to efficiently transition the app from any particular state to another (A to B, B to C, C to A, and so on).\n\nActually re-rendering the entire app on each change only works for the most trivial apps; in a real-world app, it's prohibitively costly in terms of performance. React has optimizations which create the appearance of whole app re-rendering while maintaining great performance. The bulk of these optimizations are part of a process called reconciliation.\n\nReconciliation is the algorithm behind what is popularly understood as the \"virtual DOM.\" A high-level description goes something like this: when you render a React application, a tree of nodes that describes the app is generated and saved in memory. This tree is then flushed to the rendering environment — for example, in the case of a browser application, it's translated to a set of DOM operations. When the app is updated (usually via ), a new tree is generated. The new tree is diffed with the previous tree to compute which operations are needed to update the rendered app.\n\nAlthough Fiber is a ground-up rewrite of the reconciler, the high-level algorithm described in the React docs will be largely the same. The key points are:\n• Different component types are assumed to generate substantially different trees. React will not attempt to diff them, but rather replace the old tree completely.\n• Diffing of lists is performed using keys. Keys should be \"stable, predictable, and unique.\"\n\nThe DOM is just one of the rendering environments React can render to, the other major targets being native iOS and Android views via React Native. (This is why \"virtual DOM\" is a bit of a misnomer.)\n\nThe reason it can support so many targets is because React is designed so that reconciliation and rendering are separate phases. The reconciler does the work of computing which parts of a tree have changed; the renderer then uses that information to actually update the rendered app.\n\nThis separation means that React DOM and React Native can use their own renderers while sharing the same reconciler, provided by React core.\n\nFiber reimplements the reconciler. It is not principally concerned with rendering, though renderers will need to change to support (and take advantage of) the new architecture.\n\nReact's Design Principles document is so good on this subject that I'll just quote it here:\n• In a UI, it's not necessary for every update to be applied immediately; in fact, doing so can be wasteful, causing frames to drop and degrading the user experience.\n• Different types of updates have different priorities — an animation update needs to complete more quickly than, say, an update from a data store.\n• A push-based approach requires the app (you, the programmer) to decide how to schedule work. A pull-based approach allows the framework (React) to be smart and make those decisions for you.\n\nReact doesn't currently take advantage of scheduling in a significant way; an update results in the entire subtree being re-rendered immediately. Overhauling React's core algorithm to take advantage of scheduling is the driving idea behind Fiber.\n\nNow we're ready to dive into Fiber's implementation. The next section is more technical than what we've discussed so far. Please make sure you're comfortable with the previous material before moving on.\n\nWe're about to discuss the heart of React Fiber's architecture. Fibers are a much lower-level abstraction than application developers typically think about. If you find yourself frustrated in your attempts to understand it, don't feel discouraged. Keep trying and it will eventually make sense. (When you do finally get it, please suggest how to improve this section.)\n\nHere we go!\n\nWe've established that a primary goal of Fiber is to enable React to take advantage of scheduling. Specifically, we need to be able to\n• pause work and come back to it later.\n• assign priority to different types of work.\n• abort work if it's no longer needed.\n\nIn order to do any of this, we first need a way to break work down into units. In one sense, that's what a fiber is. A fiber represents a unit of work.\n\nTo go further, let's go back to the conception of React components as functions of data, commonly expressed as\n\nIt follows that rendering a React app is akin to calling a function whose body contains calls to other functions, and so on. This analogy is useful when thinking about fibers.\n\nThe way computers typically track a program's execution is using the call stack. When a function is executed, a new stack frame is added to the stack. That stack frame represents the work that is performed by that function.\n\nWhen dealing with UIs, the problem is that if too much work is executed all at once, it can cause animations to drop frames and look choppy. What's more, some of that work may be unnecessary if it's superseded by a more recent update. This is where the comparison between UI components and function breaks down, because components have more specific concerns than functions in general.\n\nNewer browsers (and React Native) implement APIs that help address this exact problem: schedules a low priority function to be called during an idle period, and schedules a high priority function to be called on the next animation frame. The problem is that, in order to use those APIs, you need a way to break rendering work into incremental units. If you rely only on the call stack, it will keep doing work until the stack is empty.\n\nWouldn't it be great if we could customize the behavior of the call stack to optimize for rendering UIs? Wouldn't it be great if we could interrupt the call stack at will and manipulate stack frames manually?\n\nThat's the purpose of React Fiber. Fiber is reimplementation of the stack, specialized for React components. You can think of a single fiber as a virtual stack frame.\n\nThe advantage of reimplementing the stack is that you can keep stack frames in memory and execute them however (and whenever) you want. This is crucial for accomplishing the goals we have for scheduling.\n\nAside from scheduling, manually dealing with stack frames unlocks the potential for features such as concurrency and error boundaries. We will cover these topics in future sections.\n\nIn the next section, we'll look more at the structure of a fiber.\n\nNote: as we get more specific about implementation details, the likelihood that something may change increases. Please file a PR if you notice any mistakes or outdated information.\n\nIn concrete terms, a fiber is a JavaScript object that contains information about a component, its input, and its output.\n\nA fiber corresponds to a stack frame, but it also corresponds to an instance of a component.\n\nHere are some of the important fields that belong to a fiber. (This list is not exhaustive.)\n\nThe type and key of a fiber serve the same purpose as they do for React elements. (In fact, when a fiber is created from an element, these two fields are copied over directly.)\n\nThe type of a fiber describes the component that it corresponds to. For composite components, the type is the function or class component itself. For host components ( , , etc.), the type is a string.\n\nConceptually, the type is the function (as in ) whose execution is being tracked by the stack frame.\n\nAlong with the type, the key is used during reconciliation to determine whether the fiber can be reused.\n\nThese fields point to other fibers, describing the recursive tree structure of a fiber.\n\nThe child fiber corresponds to the value returned by a component's method. So in the following example\n\nThe child fiber of corresponds to .\n\nThe sibling field accounts for the case where returns multiple children (a new feature in Fiber!):\n\nThe child fibers form a singly-linked list whose head is the first child. So in this example, the child of is and the sibling of is .\n\nGoing back to our function analogy, you can think of a child fiber as a tail-called function.\n\nThe return fiber is the fiber to which the program should return after processing the current one. It is conceptually the same as the return address of a stack frame. It can also be thought of as the parent fiber.\n\nIf a fiber has multiple child fibers, each child fiber's return fiber is the parent. So in our example in the previous section, the return fiber of and is .\n\nConceptually, props are the arguments of a function. A fiber's are set at the beginning of its execution, and are set at the end.\n\nWhen the incoming are equal to , it signals that the fiber's previous output can be reused, preventing unnecessary work.\n\nA number indicating the priority of the work represented by the fiber. The ReactPriorityLevel module lists the different priority levels and what they represent.\n\nWith the exception of , which is 0, a larger number indicates a lower priority. For example, you could use the following function to check if a fiber's priority is at least as high as the given level:\n\nThis function is for illustration only; it's not actually part of the React Fiber codebase.\n\nThe scheduler uses the priority field to search for the next unit of work to perform. This algorithm will be discussed in a future section.\n\nAt any time, a component instance has at most two fibers that correspond to it: the current, flushed fiber, and the work-in-progress fiber.\n\nThe alternate of the current fiber is the work-in-progress, and the alternate of the work-in-progress is the current fiber.\n\nA fiber's alternate is created lazily using a function called . Rather than always creating a new object, will attempt to reuse the fiber's alternate if it exists, minimizing allocations.\n\nYou should think of the field as an implementation detail, but it pops up often enough in the codebase that it's valuable to discuss it here.\n\nConceptually, the output of a fiber is the return value of a function.\n\nEvery fiber eventually has output, but output is created only at the leaf nodes by host components. The output is then transferred up the tree.\n\nThe output is what is eventually given to the renderer so that it can flush the changes to the rendering environment. It's the renderer's responsibility to define how the output is created and updated.\n\nThat's all there is for now, but this document is nowhere near complete. Future sections will describe the algorithms used throughout the lifecycle of an update. Topics to cover include:\n• how the scheduler finds the next unit of work to perform.\n• how priority is tracked and propagated through the fiber tree.\n• how the scheduler knows when to pause and resume work.\n• how work is flushed and marked as complete.\n• how side-effects (such as lifecycle methods) work.\n• what a coroutine is and how it can be used to implement features like context and layout."
    },
    {
        "link": "https://blog.logrocket.com/deep-dive-react-fiber",
        "document": "This post was updated on 22 October 2024 by David Omotayo to include updates about the key improvements in React Fiber since React v16, such as concurrency, automatic batching, and new hooks like , , and .\n\nEver wondered what happens when you call ?\n\nWe know that ReactDOM builds the DOM tree under the hood and renders the application on the screen. But how does React actually build the DOM tree? And how does it update the tree when the app’s state changes?\n\nIn this post, we’ll learn what React Fiber is and how React built the DOM tree until React v15.0.0, the pitfalls of that model, and how the new model from React v16.0.0 to the current version solves these problems.\n\nThis post will cover a wide range of concepts that are purely internal implementation details and are not strictly necessary for actual frontend development using React.\n\nReact Fiber is an internal engine change geared to make React faster and smarter. The Fiber reconciler, which became the default reconciler for React 16 and above, is a complete rewrite of React’s reconciliation algorithm to solve some long-standing issues in React.\n\nBecause Fiber is asynchronous, React can:\n• Pause, resume, and restart rendering work on components as new updates come in\n• Reuse previously completed work and even abort it if not needed\n• Split work into chunks and prioritize tasks based on importance\n\nThis change allows React to break away from the limits of the synchronous stack reconciler. Previously, you could add or remove items, for example, but it had to work until the stack was empty, and tasks couldn’t be interrupted.\n\nThis change also allows React to fine-tune rendering components, ensuring that the most important updates happen as soon as possible.\n\nNow, to truly understand the powers of Fiber, let’s talk about the old reconciler: the stack reconciler.\n\nThe module passes the to the reconciler, but there are two questions here:\n• What does refer to?\n• What is the reconciler?\n\nis a React element and “elements describe the tree.” According to the React blog, “An element is a plain object describing a component instance or DOM node and its desired properties.”\n\nIn other words, elements are not actual DOM nodes or component instances; they are a way to describe to React what kind of elements they are, what properties they hold, and who their children are.\n\nThis is where React’s real power lies: React abstracts away the complex pieces of how to build, render, and manage the lifecycle of the actual DOM tree by itself, effectively making the life of the developer easier.\n\nTo understand what this really means, let’s look at a traditional approach using object-oriented concepts.\n\nIn the typical object-oriented programming world, developers must instantiate and manage the lifecycle of every DOM element. For instance, if you want to create a simple form and a submit button, the state management still requires some effort from the developer.\n\nLet’s assume the component has a state variable. The lifecycle of the component looks something like the flowchart below, where each state must be managed by the app:\n\nThis size of the flowchart and the number of lines of code grow exponentially as the number of state variables increases.\n\nSo, React has elements to solve this problem; in React, there are two kinds of elements: the DOM element and the component element.\n\nThe DOM element is an element that’s a string; for instance, .\n\nThe component element is a class or a function, for example, , where is either a class or a functional component. These are the typical React components we generally use.\n\nIt is important to understand that both types are simple objects. They are mere descriptions of what must be rendered on the screen and don’t instigate rendering when you create and instantiate them.\n\nThis makes it easier for React to parse and traverse them to build the DOM tree. The actual rendering happens later when traversing finishes.\n\nWhen React encounters a class or a function component, it will ask that element what element it renders based on its props.\n\nFor instance, if the component rendered the following, then React will ask the and components what they render based on their corresponding props:\n\nSo, if the component is a functional component that looks like the following, React will call to know what elements it renders and see that it renders a with a child\n\nReact will repeat this process until it knows the underlying DOM tag elements for every component on the page.\n\nThis exact process of recursively traversing a tree to know the underlying DOM tag elements of a React app’s component tree is known as reconciliation.\n\nBy the end of the reconciliation, React knows the result of the DOM tree, and a renderer like or applies the minimal set of changes necessary to update the DOM nodes. This means that when you call or , React performs reconciliation.\n\nIn the case of , it performs a traversal and determines what changed in the tree by diffing the new tree with the rendered tree. Then, it applies those changes to the current tree, thereby updating the state corresponding to the call.\n\nNow that we understand what reconciliation is, let’s look at the pitfalls of this model.\n\nWhat is the React stack reconciler?\n\nOh, by the way, why is this called the “stack” reconciler? This name is derived from the “stack” data structure, which is a last-in, first-out mechanism.\n\nAnd, what does stack have anything to do with what we just saw? Well, as it turns out, since we are effectively performing recursion, it has everything to do with a stack.\n\nWhat is recursion in React?\n\nTo understand why that’s the case, let’s take a simple example and see what happens in the call stack:\n\nAs we can see, the call stack pushes every call to into the stack until it pops , which is the first function call to return.\n\nThen, it continues pushing the recursive calls and pops again when it reaches the return statement. In this way, it effectively uses the call stack until returns and becomes the last item pop from the stack.\n\nThe reconciliation algorithm we just saw is a purely recursive algorithm. An update results in the entire subtree rerendering immediately. While this works well, this has some limitations.\n\nAs Andrew Clark notes, in a UI, it’s not necessary for every update to apply immediately; in fact, doing so can be wasteful, causing frames to drop and degrading the user experience.\n\nAlso, different types of updates have different priorities — an animation update must be completed faster than an update from a data store.\n\nNow, what do we mean when we refer to dropped frames, and why is this a problem with the recursive approach? To understand this, let’s briefly review what frame rate is and why it’s important from a user experience point of view.\n\nFrame rate is the frequency consecutive images appear on a display. Everything we see on our computer screens is composed of images or frames played on the screen at a rate that appears instantaneous to the eye.\n\nTo understand what this means, think of the computer display as a flipbook and the pages of the flipbook as frames played at some rate when you flip them.\n\nComparatively, a computer display is nothing but an automatic flipbook that plays continuously when things change on the screen.\n\nTypically, for a video to feel smooth and instantaneous to the human eye, the video must play at a rate of about 30 frames per second (FPS); anything higher gives a better experience.\n\nMost devices these days refresh their screens at 60 FPS, 1/60 = 16.67ms, which means a new frame displays every 16ms. This number is important because if the React renderer takes more than 16ms to render something on the screen, the browser drops that frame.\n\nIn reality, however, the browser has housekeeping to do, so all your work must be completed within 10ms. When you fail to meet this budget, the frame rate drops, and the content judders on screen. This is often referred to as jank, and it negatively impacts the user’s experience.\n\nOf course, this is not a big concern for static and textual content. But in the case of displaying animations, this number is critical.\n\nIf the React reconciliation algorithm traverses the entire tree each time there is an update, rerenders it, and the traversal takes more than 16ms, it will drop frames.\n\nThis is a big reason why many wanted updates categorized by priority and not blindly applying every update passed down to the reconciler. Also, many wanted the ability to pause and resume work in the next frame. This way, React could have better control over working with the 16ms rendering budget.\n\nThis led the React team to rewrite the reconciliation algorithm, which is called Fiber. So, let’s look at how Fiber works to solve this problem.\n\nNow that we know what motivated Fiber’s development, let’s summarize the features needed to achieve it. Again, I am referring to Andrew Clark’s notes for this:\n• Assign priority to different types of work\n• Pause work and come back to it later\n\nOne of the challenges with implementing something like this is how the JavaScript engine works and the lack of threads in the language. To understand this, let’s briefly explore how the JavaScript engine handles execution contexts.\n\nWhenever you write a function in JavaScript, the JavaScript engine creates a function execution context.\n\nEach time the JavaScript engine starts, it creates a global execution context that holds the global objects; for example, the object in the browser and the object in Node.js. JavaScript handles both contexts using a stack data structure also known as the execution stack.\n\nSo, when you write something like this, the JavaScript engine first creates a global execution context and pushes it into the execution stack:\n\nThen, it creates a function execution context for the function. Since is called inside , it creates another function execution context for and pushes it into the stack.\n\nWhen the function returns, the engine destroys the context of . When we exit the function, the context is destroyed. The stack during execution looks like this:\n\nBut, what happens when the browser makes an asynchronous event like an HTTP request? Does the JavaScript engine stock the execution stack and handle the asynchronous event, or does it wait until the event completes?\n\nThe JavaScript engine does something different here: on top of the execution stack, the JavaScript engine has a queue data structure, also known as the event queue. The event queue handles asynchronous calls like HTTP or network events coming into the browser.\n\nThe JavaScript engine handles the items in the queue by waiting for the execution stack to empty. So, each time the execution stack empties, the JavaScript engine checks the event queue, pops items off the queue, and handles the event.\n\nIt is important to note that the JavaScript engine checks the event queue only when the execution stack is empty or the only item in the execution stack is the global execution context.\n\nAlthough we call them asynchronous events, there is a subtle distinction here: the events are asynchronous with respect to when they arrive into the queue, but they’re not really asynchronous with respect to when they are actually handled.\n\nComing back to our stack reconciler, when React traverses the tree, it does so in the execution stack. So, when the updates arrive, they arrive in the event queue (sort of). And, only when the execution stack empties, the updates are handled.\n\nThis is precisely the problem Fiber solves by almost reimplementing the stack with intelligent capabilities—pausing, resuming, and aborting, for example.\n\nAgain referencing Andrew Clark, “Fiber is a reimplementation of the stack, specialized for React components. You can think of a single fiber as a virtual stack frame.\n\n“The advantage of reimplementing the stack is that you can keep stack frames in memory and execute them however and whenever you want. This is crucial for accomplishing the goals we have for scheduling.\n\n“Aside from scheduling, manually dealing with stack frames unlocks the potential for features such as concurrency and error boundaries. We will cover these topics in future sections.”\n\nIn simple terms, a fiber represents a unit of work with its own virtual stack. In the previous implementation of the reconciliation algorithm, React created a tree of objects (React elements) that are immutable and traversed the tree recursively.\n\nIn the current implementation, React creates a tree of fiber nodes that can mutate. The fiber node effectively holds the component’s state, props, and underlying DOM element it renders to.\n\nAnd, since fiber nodes can mutate, React doesn’t need to recreate every node for updates; it can simply clone and update the node when there is an update.\n\nIn the case of a fiber tree, React doesn’t perform recursive traversal. Instead, it creates a singly-linked list and performs a parent-first, depth-first traversal.\n\nA fiber node represents a stack frame and an instance of a React component. A fiber node comprises the following members:\n\nand , for example, host components (strings), classes, or functions for composite components.\n\nThe key is the same as the key we pass to the React element.\n\nRepresents the element returned when we call on the component:\n\nThe child of is because it returns a element.\n\nIn the above case, and are the children of , which is the parent. The two children form a singly-linked list.\n\nReturn is the return back to the stack frame, which is a logical return back to the parent fiber node, and thus, represents the parent.\n\nMemoization means storing the values of a function execution’s result so you can use it later, thereby avoiding recomputation. represents the props passed to the component, and initializes at the end of the execution stack, storing the props of this node.\n\nWhen the incoming are equal to , it signals that the fiber’s previous output can be reused, preventing unnecessary work.\n\nis a number indicating the priority of the work represented by the fiber. The module lists the different priority levels and what they represent. With the exception of , which is zero, a larger number indicates a lower priority.\n\nFor example, you could use the following function to check if a fiber’s priority is at least as high as the given level. The scheduler uses the priority field to search for the next unit of work to perform:\n\nAt any time, a component instance has at most two fibers that correspond to it: the current fiber and the in-progress fiber. The alternate of the current fiber is the fiber in progress, and the alternate of the fiber in progress is the current fiber.\n\nThe current fiber represents what is rendered already, and the in-progress fiber is conceptually the stack frame that has not returned.\n\nThe output is the leaf nodes of a React application. They are specific to the rendering environment (for example, in a browser app, they are and ). In JSX, they are denoted using lowercase tag names.\n\nConceptually, the output of a fiber is the return value of a function. Every fiber eventually has an output, but the output is created only at the leaf nodes by host components. The output is then transferred up the tree.\n\nThe output is eventually given to the renderer so that it can flush the changes to the rendering environment. For example, let’s look at how the fiber tree looks for an app with the following code:\n\nWe can see that the fiber tree is composed of singly-linked lists of child nodes linked to each other (sibling relationship) and a linked list of parent-to-child relationships. This tree can be traversed using a depth-first search.\n\nTo understand how React builds this tree and performs the reconciliation algorithm on it, let’s look at a unit test in the React source code with an attached debugger to follow the process; you can clone the React source code and navigate to this directory.\n\nTo begin, add a Jest test and attach a debugger. This is a simple test for rendering a button with text. When you click the button, the app destroys the button and renders a with different text, so the text is a state variable here:\n\nIn the initial render, React creates a current tree that renders initially.\n\nis the function that creates each React fiber using the data from the specific React element. When we run the test, put a breakpoint at this function, and look at the call stack:\n\nAs we can see, the call stack tracks back to a call, which eventually goes down to . There are a few other functions that are of interest here: , , and .\n\nis when React starts building up the tree, starting with the node and recursively moving on to , , and , which are the children of . The function holds a reference to the next fiber node that has work to do.\n\ntakes a fiber node as an input argument, gets the alternate of the node, and calls . This is the equivalent of starting the execution of the function execution contexts in the execution stack.\n\nWhen React builds the tree, simply leads up to and creates the fiber nodes. React recursively performs work and eventually returns a null, indicating that it has reached the end of the tree.\n\nNow, what happens when we perform , which clicks the button and triggers a state update? In this case, React traverses the fiber tree, clones each node, and checks whether it needs to perform any work on each node.\n\nWhen we look at the call stack of this scenario, it looks something like this:\n\nAlthough we did not see and in the first call stack, we can see them here. Just like and , these two functions perform the completion part of the current execution, which means returning back to the stack.\n\nAs we can see, together these four functions execute the unit of work and give control over the work being done currently, which is exactly what was missing in the stack reconciler.\n\nThe image below shows that each fiber node is composed of four phases required to complete that unit of work.\n\nIt’s important to note here that each node doesn’t move to until its children and siblings return .\n\nFor instance, it starts with and for , then moves on to and for , and so on. It comes back and completes the work on once all the children of complete the work.\n\nThis is when React completes its render phase. The tree that’s newly built based on the update is called the tree. This is basically the draft tree waiting to be rendered.\n\nOnce the render phase completes, React moves on to the commit phase, where it basically swaps the root pointers of the current tree and tree, thereby effectively swapping the current tree with the draft tree it built up based on the update.\n\nNot just that, React also reuses the old current after swapping the pointer from root to the tree. The net effect of this optimized process is a smooth transition from the previous state of the app to the next state and the next state, and so on.\n\nAnd what about the 16ms frame time? React effectively runs an internal timer for each unit of work being performed and constantly monitors this time limit while performing the work.\n\nThe moment the time runs out, React pauses the current unit of work, hands the control back to the main thread, and lets the browser render whatever is finished at that point.\n\nThen, in the next frame, React picks up where it left off and continues building the tree. Then, when it has enough time, it commits the tree and completes the render.\n\nOverview of changes and improvements since React v16\n\nReact Fiber has seen several significant changes and improvements since its introduction in React v16, with the most impactful updates in React v18. These changes are particularly aimed at improving performance and developer experience while addressing issues related to asynchronous rendering and concurrency.\n\nHere are the key improvements and changes since React v16:\n\nThe most significant update to React fiber since its inception is concurrency. This is a foundational update to React’s core rendering model which leverages the capabilities of React Fiber to provide interruptible rendering.\n\nConcurrent mode lets React pause, abort, or resume rendering updates based on priority and handle multiple updates concurrently rather than waiting for one update to finish before starting another. This is a stark contrast to the traditional, synchronous rendering model where updates are rendered in a single, uninterrupted, synchronous transaction.\n\nAlthough concurrency mode was initially developed alongside the React Fiber architecture in React v16, it was officially released with React v18 as the core rendering mechanism and offered key features such as:\n• Time slicing — This allows React to break up rendering tasks into chunks and spread them out over multiple frames, preventing the app from becoming unresponsive during large updates\n• Selective hydration — When rendering server-side content on the client, React can now hydrate only the parts of the UI that are immediately needed\n• Deferred rendering — If React determines that an update is not immediately necessary for the user experience, it can defer the rendering of that update. This allows React to focus on more important updates and prevent the UI from becoming unresponsive\n\nAutomatic batching is a key feature that is the direct result of the underlying changes in React Fiber. It helps to reduce the number of re-renders that happen when a state changes by allowing React to group multiple state updates into a single re-render.\n\nFor example, when you call multiple functions in a single render cycle, React automatically batches them together into a single update. This can be observed in the code example below:\n\nThe function calls twice, once to increment the count by and then again to increment it by .\n\nReact automatically batches these two state updates into a single update. This means that only one re-render will occur, and “rendering” will only log once in the terminal.\n\nBefore the release of React v18, batched updates were performed inside the React event handler. This meant that outside of React’s lifecycle (such as inside a or a promise), updates would not be batched automatically. With React Fiber’s improved update in v18, updates are batched across all contexts, including asynchronous code, , promises, and native event handlers.\n\nSuspense is a feature that is closely tied to concurrent mode and was initially introduced with React fiber in v16, but its capabilities were greatly expanded with updates in React v17 and v18.\n\nThe feature has undergone significant improvements since its initial release. It was originally designed to manage lazy loading (code splitting) of components using , but its functionality has expanded, especially with the introduction of concurrent mode in v18.\n\nNow, Suspense plays a key role in handling asynchronous operations like data fetching and offers more granular control over UI rendering during these operations. You can declaratively specify what React should show when a part of the tree is not yet ready to render.\n\nThis is done using a option which renders a component or string while the asynchronous task is in operation:\n\nAnother key improvement is streaming in server side rendering (SSR) and selective hydration. With this improvement, the server can send an initial lightweight HTML shell to the client and hydrate content in chunks as data becomes available.\n\nReact can selectively hydrate only the parts of the app that are immediately visible to the user while suspending the rest until the necessary data or resources are ready.\n\nTransitions is a new API built on top of React Fiber that uses its scheduling algorithm to distinguish and mark updates as urgent or non-urgent.\n\nUrgent updates include tasks like user inputs or animations where immediate feedback is expected. Non-urgent updates, like rendering a list of search results, are low priority, and slight delays are acceptable.\n\nThe transitions API comprises a hook which allows you to mark state updates as not urgent, as every state update not marked is considered as urgent by default.\n\nThe hook handles transitions between UI states in a non-blocking manner. It returns an array with two values:\n• — A boolean indicating if the transition is in progress\n\nTo see how the hook works, imagine a component that displays a long list of items that can be filtered. Without , updating the filter can cause a laggy experience as React re-renders the long list each time the filter changes.\n\nWith , we can mark the update that renders the filtered list as non-urgent, keeping the user input responsive:\n\nIn this example, is updated immediately as it’s urgent for the user to see their typing reflected in the input, while is wrapped in , allowing React to update the filtered list when the system is ready.\n\nThe is used to display a loading message when the filtering process takes time. This will help improve user experience by giving the user feedback while the list is being updated in the background.\n\nReact v18 introduced a new client rendering API, and , which offer a better way to handle and render root nodes. replaces the previous API and is essential for enabling new features like concurrency. Improvements highlighted in previous and subsequent sections won’t work without it.\n\n, like its predecessor, helps React connect with the DOM and manage it internally. It creates a root for the DOM node and binds it to a React node, such as a top-level component like , or a React element constructed with :\n\nThe API is the SSR equivalent of the API. It replaces and allows you to render React components inside a browser DOM node whose HTML content was previously generated in a server environment:\n\nAs shown in the code examples, both APIs return an object with a method. These methods serve the same purpose of rendering React components to the DOM but behave slightly differently.\n\nThe method in creates a new root instance for the React application, meaning the component tree will be rendered from scratch. In contrast, the method in only hydrates an existing DOM structure previously rendered on the server.\n\nThe returned object also includes a second method, , which is used to destroy the rendered tree inside a React root. Apps built entirely with React typically won’t need to call ; it’s mainly for third-party code that needs to unmount all components in the root and detach React from the root DOM node.\n\nThe React team has made transitioning to the new client rendering API easier by allowing users to continue using the existing APIs in React 17. This means existing React 17 applications can be gradually migrated to React v18 without breaking changes.\n\nReact v18 also introduced new hooks: and , which serve specific purposes related to optimizing performance and addressing use cases that weren’t fully handled by existing hooks like or .\n\nThe hook lets you synchronize your components with external data sources that don’t follow React’s update lifecycle. This hook ensures consistency between React’s internal state and external stores (such as state management libraries), especially during concurrent rendering.\n\nwas specifically designed to address problems related to race conditions, which occur when an external store’s state changes during the rendering phase, leading to inconsistencies between the state React reads and the state it uses to render components.\n\nWithout , libraries typically rely on and to subscribe to external stores and trigger re-renders when the store changes.\n\nHowever, in a concurrently rendered environment, this can cause problems because runs after the commit phase, meaning React might finish rendering before detecting any changes in the external state, potentially leading to stale or inconsistent data.\n\nSimilarly, with , which runs before the browser paints, React might still commit a render based on an outdated external state because the state could have changed during React’s rendering process.\n\nTo learn more about the hook, refer to this article.\n\nThe hook is designed for injecting styles or performing DOM manipulations before React makes any DOM mutations. This is especially useful for CSS-in-JS libraries like Emotion and styled components that need to ensure styles are inserted before the rendering phase to avoid flickering or style inconsistencies.\n\nI hope you enjoyed reading this post. Please feel free to leave comments or questions if you have any."
    }
]