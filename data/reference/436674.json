[
    {
        "link": "https://geeksforgeeks.org/python-user-defined-functions",
        "document": "A User-Defined Function (UDF) is a function created by the user to perform specific tasks in a program. Unlike built-in functions provided by a programming language, UDFs allow for customization and code reusability, improving program structure and efficiency.\n\nExplanation: fun(x) checks if a number is even or odd using x % 2. If divisible by 2, it prints “even”, otherwise “odd”.\n\nThese functions accept parameters (arguments) to process and return results dynamically. Parameters allow for flexibility, enabling the function to handle different inputs each time it is called.\n\nExplanation: fun(name) prints a greeting with the provided name. When called with “shakshi”, it outputs “Hello, shakshi”.\n\nA function can have default values assigned to its parameters. If no argument is provided when calling the function, it takes the default value.\n\nExplanation: fun(x, y=50) takes two parameters, where y has a default value of 50. It prints the values of x and y. When called with fun(10), it uses 10 for x and the default value 50 for y .\n\nFunction arguments can be passed using keywords to improve code readability. This ensures the correct mapping of values to parameters, regardless of their order.\n\nExplanation: fun(name, age) prints the name and age with the message “is [age] years old.” It is called using keyword arguments (age=21, name=”shakshi”), which assigns the values explicitly to name and age.\n\nWhen the number of arguments is unknown, a function can accept multiple arguments using *args (for non-keyword arguments) or **kwargs (for keyword arguments).\n\nExplanation: fun(*args) uses a variable-length argument list, allowing it to accept any number of arguments. It then iterates through each argument and prints it.\n\nA function can return a value using the return statement. This allows the function to send back a result for further computation.\n\nExplanation: fun(num) takes a number num as input and returns its square (num * num). When called with fun(5), it calculates 5 * 5 and stores the result in res.\n\nA lambda function is an anonymous (nameless) function that is defined in a single line using the lambda keyword. It is used for short, simple operations where defining a full function is unnecessary.\n\nExplanation: lambda x: x * x takes one input x and returns its square (x * x). When res(4) is called, it computes 4 * 4, resulting in 16 .\n\nPass by reference or Pass by value in Python\n\nPython handles argument passing by reference for mutable objects (e.g., lists, dictionaries) and by value for immutable objects (e.g., integers, strings, tuples). If an immutable object is modified inside a function, a new object is created, whereas changes to mutable objects reflect outside the function.\n\nExplanation: fun(x) prints the value of x and its memory identifier using id(). In the driver code, x is assigned the value 12 and before calling the function, both the value and id of x are printed. When the function is called, it prints the same information for x .\n\nExplanation: fun(a) modifies the first element of the passed list ([0] = 100). Since lists are mutable in Python, the change is reflected outside the function. Before the call, a is [1, 2, 3], and after the call, it becomes [100, 2, 3].\n\nWhat is a user-defined function with an example?\n\nWhat is the difference between inbuilt and user-defined functions in Python?\n\nWhat are the disadvantages of user-defined functions in Python?\n\nWhat is the difference between user-defined and predefined functions?"
    },
    {
        "link": "https://realpython.com/python-return-statement",
        "document": "The Python statement is a special statement that you can use inside a function or method to send the function’s result back to the caller. A statement consists of the keyword followed by an optional return value. The return value of a Python function can be any Python object, and you can use them to perform further computation in your programs.\n\nUsing the statement effectively is a core skill if you want to code custom functions that are Pythonic and robust.\n\nIn this tutorial, you’ll learn that:\n• You use to send objects from your functions back to the caller code.\n• You can use to return one single value or multiple values separated by commas.\n• You should try to keep your code readable and maintainable by avoiding complex statements.\n\nWith this knowledge, you’ll be able to write more readable, maintainable, and concise functions in Python. If you’re totally new to Python functions, then you can check out Defining Your Own Python Function before diving into this tutorial.\n\nMost programming languages allow you to assign a name to a code block that performs a concrete computation. These named code blocks can be reused quickly because you can use their name to call them from different places in your code. Programmers call these named code blocks subroutines, routines, procedures, or functions depending on the language they use. In some languages, there’s a clear difference between a routine or procedure and a function. Sometimes that difference is so strong that you need to use a specific keyword to define a procedure or subroutine and another keyword to define a function. For example the Visual Basic programming language uses and to differentiate between the two. In general, a procedure is a named code block that performs a set of actions without computing a final value or result. On the other hand, a function is a named code block that performs some actions with the purpose of computing a final value or result, which is then sent back to the caller code. Both procedures and functions can act upon a set of input values, commonly known as arguments. In Python, these kinds of named code blocks are known as functions because they always send a value back to the caller. The Python documentation defines a function as follows: A series of statements which returns some value to a caller. It can also be passed zero or more arguments which may be used in the execution of the body. (Source) Even though the official documentation states that a function “returns some value to the caller,” you’ll soon see that functions can return any Python object to the caller code. In general, a function takes arguments (if any), performs some operations, and returns a value (or object). The value that a function returns to the caller is generally known as the function’s return value. All Python functions have a return value, either explicit or implicit. You’ll cover the difference between explicit and implicit return values later in this tutorial. To write a Python function, you need a header that starts with the keyword, followed by the name of the function, an optional list of comma-separated arguments inside a required pair of parentheses, and a final colon. The second component of a function is its code block, or body. Python defines code blocks using indentation instead of brackets, and keywords, and so on. So, to define a function in Python you can use the following syntax: When you’re coding a Python function, you need to define a header with the keyword, the name of the function, and a list of arguments in parentheses. Note that the list of arguments is optional, but the parentheses are syntactically required. Then you need to define the function’s code block, which will begin one level of indentation to the right. In the above example, you use a statement. This kind of statement is useful when you need a placeholder statement in your code to make it syntactically correct, but you don’t need to perform any action. statements are also known as the null operation because they don’t perform any action. Note: The full syntax to define functions and their arguments is beyond the scope of this tutorial. For an in-depth resource on this topic, check out Defining Your Own Python Function. To use a function, you need to call it. A function call consists of the function’s name followed by the function’s arguments in parentheses: You’ll need to pass arguments to a function call only if the function requires them. The parentheses, on the other hand, are always required in a function call. If you forget them, then you won’t be calling the function but referencing it as a function object. To make your functions return a value, you need to use the Python statement. That’s what you’ll cover from this point on.\n\nThe Python statement is a special statement that you can use inside a function or method to send the function’s result back to the caller. A statement consists of the keyword followed by an optional return value. The return value of a Python function can be any Python object. Everything in Python is an object. So, your functions can return numeric values ( , , and values), collections and sequences of objects ( , , , or objects), user-defined objects, classes, functions, and even modules or packages. You can omit the return value of a function and use a bare without a return value. You can also omit the entire statement. In both cases, the return value will be . In the next two sections, you’ll cover the basics of how the statement works and how you can use it to return the function’s result back to the caller code. An explicit statement immediately terminates a function execution and sends the return value back to the caller code. To add an explicit statement to a Python function, you need to use followed by an optional return value: When you define , you add an explicit statement ( ) at the end of the function’s code block. is the explicit return value of . This means that any time you call , the function will send back to the caller. Note: You can use explicit statements with or without a return value. If you build a statement without specifying a return value, then you’ll be implicitly returning . If you define a function with an explicit statement that has an explicit return value, then you can use that return value in any expression: Since returns a numeric value, you can use that value in a math expression or any other kind of expression in which the value has a logical or coherent meaning. This is how a caller code can take advantage of a function’s return value. Note that you can use a statement only inside a function or method definition. If you use it anywhere else, then you’ll get a : When you use outside a function or method, you get a telling you that the statement can’t be used outside a function. Note: Regular methods, class methods, and static methods are just functions within the context of Python classes. So, all the statement concepts that you’ll cover apply to them as well. You can use any Python object as a return value. Since everything in Python is an object, you can return strings, lists, tuples, dictionaries, functions, classes, instances, user-defined objects, and even modules or packages. For example, say you need to write a function that takes a list of integers and returns a list containing only the even numbers in the original list. Here’s a way of coding this function: uses a list comprehension to create a list that filters out the odd numbers in the original . Then the function returns the resulting list, which contains only even numbers. A common practice is to use the result of an expression as a return value in a statement. To apply this idea, you can rewrite as follows: The list comprehension gets evaluated and then the function returns with the resulting list. Note that you can only use expressions in a statement. Expressions are different from statements like conditionals or loops. Note: Even though comprehensions are built using and (optionally) keywords, they’re considered expressions rather than statements. That’s why you can use them in a statement. For a further example, say you need to calculate the mean of a sample of numeric values. To do that, you need to divide the sum of the values by the number of values. Here’s an example that uses the built-in functions and : In , you don’t use a local variable to store the result of the calculation. Instead, you use the expression directly as a return value. Python first evaluates the expression and then returns the result of the evaluation, which in this case is the value . A Python function will always have a return value. There is no notion of procedure or routine in Python. So, if you don’t explicitly use a return value in a statement, or if you totally omit the statement, then Python will implicitly return a default value for you. That default return value will always be . Say you’re writing a function that adds to a number , but you forget to supply a statement. In this case, you’ll get an implicit statement that uses as a return value: # No return statement at all If you don’t supply an explicit statement with an explicit return value, then Python will supply an implicit statement using as a return value. In the above example, adds to and stores the value in but it doesn’t return . That’s why you get instead of . To fix the problem, you need to either or directly . An example of a function that returns is . The goal of this function is to print objects to a text stream file, which is normally the standard output (your screen). So, this function doesn’t need an explicit statement because it doesn’t return anything useful or meaningful: The call to prints to the screen. Since this is the purpose of , the function doesn’t need to return anything useful, so you get as a return value. Note: The Python interpreter doesn’t display . So, to show a return value of in an interactive session, you need to explicitly use . Regardless of how long and complex your functions are, any function without an explicit statement, or one with a statement without a return value, will return .\n\nIf you’re working in an interactive session, then you might think that printing a value and returning a value are equivalent operations. Consider the following two functions and their output: Both functions seem to do the same thing. In both cases, you see printed on your screen. There’s only a subtle visible difference—the single quotation marks in the second example. But take a look at what happens if you return another data type, say an object: There’s no visible difference now. In both cases, you can see on your screen. That behavior can be confusing if you’re just starting with Python. You might think that returning and printing a value are equivalent actions. Now, suppose you’re getting deeper into Python and you’re starting to write your first script. You open a text editor and type the following code: takes two numbers, adds them, and returns the result. On line 5, you call to sum plus . Since you’re still learning the difference between returning and printing a value, you might expect your script to print to the screen. However, that’s not what happens, and you get nothing on your screen. Try it out by yourself. Save your script to a file called and run it from your command line as follows: If you run from your command line, then you won’t see any result on your screen. That’s because when you run a script, the return values of the functions that you call in the script don’t get printed to the screen like they do in an interactive session. If you want that your script to show the result of calling on your screen, then you need to explicitly call . Check out the following update of : Now, when you run , you’ll see the number on your screen. So, if you’re working in an interactive session, then Python will show the result of any function call directly to your screen. But if you’re writing a script and you want to see a function’s return value, then you need to explicitly use .\n\nYou can use a statement to return multiple values from a function. To do that, you just need to supply several return values separated by commas. For example, suppose you need to write a function that takes a sample of numeric data and returns a summary of statistical measures. To code that function, you can use the Python standard module , which provides several functions for calculating mathematical statistics of numeric data. Here’s a possible implementation of your function: In , you take advantage of Python’s ability to return multiple values in a single statement by returning the mean, median, and mode of the sample at the same time. Note that, to return multiple values, you just need to write them in a comma-separated list in the order you want them returned. Note: If your functions needs several different return types, then you’re dealing with a more complex scenario. In this case, you can get some help from How to Use Type Hints for Multiple Return Types in Python. Once you’ve coded , you can take advantage of a powerful Python feature known as iterable unpacking to unpack the three measures into three separated variables, or you can just store everything in one variable: Here, you unpack the three return values of into the variables , , and . Note that in the last example, you store all the values in a single variable, , which turns out to be a Python . Note: You can build a Python by just assigning several comma-separated values to a single variable. There’s no need to use parentheses to create a . That’s why multiple return values are packed in a . The built-in function is also an example of a function that returns multiple values. The function takes two (non-complex) numbers as arguments and returns two numbers, the quotient of the two input values and the remainder of the division: The call to returns a tuple containing the quotient and remainder that result from dividing the two non-complex numbers provided as arguments. This is an example of a function with multiple return values.\n\nUsing the Python Statement: Best Practices So far, you’ve covered the basics of how the Python statement works. You now know how to write functions that return one or multiple values to the caller. Additionally, you’ve learned that if you don’t add an explicit statement with an explicit return value to a given function, then Python will add it for you. That value will be . In this section, you’ll cover several examples that will guide you through a set of good programming practices for effectively using the statement. These practices will help you to write more readable, maintainable, robust, and efficient functions in Python. Some programmers rely on the implicit statement that Python adds to any function without an explicit one. This can be confusing for developers who come from other programming languages in which a function without a return value is called a procedure. There are situations in which you can add an explicit to your functions. In other situations, however, you can rely on Python’s default behavior:\n• If your function performs actions but doesn’t have a clear and useful value, then you can omit returning because doing that would just be superfluous and confusing. You can also use a bare without a return value just to make clear your intention of returning from the function.\n• If your function has multiple statements and returning is a valid option, then you should consider the explicit use of instead of relying on the Python’s default behavior. These practices can improve the readability and maintainability of your code by explicitly communicating your intent. When it comes to returning , you can use one of three possible approaches:\n• Omit the statement and rely on the default behavior of returning .\n• Use a bare without a return value, which also returns . Here’s how this works in practice: Whether or not to return explicitly is a personal decision. However, you should consider that in some cases, an explicit can avoid maintainability problems. This is especially true for developers who come from other programming languages that don’t behave like Python does. When writing custom functions, you might accidentally forget to return a value from a function. In this case, Python will return for you. This can cause subtle bugs that can be difficult for a beginning Python developer to understand and debug. You can avoid this problem by writing the statement immediately after the header of the function. Then you can make a second pass to write the function’s body. Here’s a template that you can use when coding your Python functions: If you get used to starting your functions like this, then chances are that you’ll no longer miss the statement. With this approach, you can write the body of the function, test it, and rename the variables once you know that the function works. This practice can increase your productivity and make your functions less error-prone. It can also save you a lot of debugging time. As you saw before, it’s a common practice to use the result of an expression as a return value in Python functions. If the expression that you’re using gets too complex, then this practice can lead to functions that are difficult to understand, debug, and maintain. For example, if you’re doing a complex calculation, then it would be more readable to incrementally calculate the final result using temporary variables with meaningful names. Consider the following function that calculates the variance of a sample of numeric data: The expression that you use here is quite complex and difficult to understand. It’s also difficult to debug because you’re performing multiple operations in a single expression. To work around this particular problem, you can take advantage of an incremental development approach that improves the readability of the function. Take a look at the following alternative implementation of : In this second implementation of , you calculate the variance in several steps. Each step is represented by a temporary variable with a meaningful name. Temporary variables like , , and are often helpful when it comes to debugging your code. If, for example, something goes wrong with one of them, then you can call to know what’s happening before the statement runs. In general, you should avoid using complex expressions in your statement. Instead, you can break your code into multiple steps and use temporary variables for each step. Using temporary variables can make your code easier to debug, understand, and maintain. Functions that don’t have an explicit statement with a meaningful return value often preform actions that have side effects. A side effect can be, for example, printing something to the screen, modifying a global variable, updating the state of an object, writing some text to a file, and so on. Modifying global variables is generally considered a bad programming practice. Just like programs with complex expressions, programs that modify global variables can be difficult to debug, understand, and maintain. When you modify a global variable, you’re potentially affecting all the functions, classes, objects, and any other parts of your programs that rely on that global variable. To understand a program that modifies global variables, you need to be aware of all the parts of the program that can see, access, and change those variables. So, good practice recommends writing self-contained functions that take some arguments and return a useful value (or values) without causing any side effect on global variables. Additionally, functions with an explicit statement that return a meaningful value are easier to test than functions that modify or update global variables. The following example show a function that changes a global variable. The function uses the statement, which is also considered a bad programming practice in Python: In this example, you first create a global variable, , with an initial value of . Inside , you use a statement to tell the function that you want to modify a global variable. The last statement increments by . The result of calling will depend on the initial value of . Different initial values for will generate different results, so the function’s result can’t be controlled by the function itself. To avoid this kind of behavior, you can write a self-contained that takes arguments and returns a coherent value that depends only on the input arguments: # Explicitly assign a new value to counter Now the result of calling depends only on the input arguments rather than on the initial value of . This makes the function more robust and easier to test. Note: For a better understanding of how to test your Python code, check out Test-Driven Development With PyTest. If you’d like a deeper dive into using global variables in functions, then Using and Creating Global Variables in Your Python Functions is for you. Additionally, when you need to update , you can do so explicitly with a call to . This way, you’ll have more control over what’s happening with throughout your code. In general, it’s a good practice to avoid functions that modify global variables. If possible, try to write self-contained functions with an explicit statement that returns a coherent and meaningful value. Python functions are not restricted to having a single statement. If a given function has more than one statement, then the first one encountered will determine the end of the function’s execution and also its return value. A common way of writing functions with multiple statements is to use conditional statements that allow you to provide different statements depending on the result of evaluating some conditions. Suppose you need to code a function that takes a number and returns its absolute value. If the number is greater than , then you’ll return the same number. If the number is less than , then you’ll return its opposite, or non-negative value. Here’s a possible implementation for this function: has two explicit statements, each of them wrapped in its own statement. It also has an implicit statement. If happens to be , then neither condition is true, and the function ends without hitting any explicit statement. When this happens, you automatically get . Take a look at the following call to using as an argument: When you call using as an argument, you get as a result. That’s because the flow of execution gets to the end of the function without reaching any explicit statement. Unfortunately, the absolute value of is , not . To fix this problem, you can add a third statement, either in a new clause or in a final clause: Now, checks every possible condition, , , and . The purpose of this example is to show that when you’re using conditional statements to provide multiple statements, you need to make sure that every possible option gets its own statement. Otherwise, your function will have a hidden bug. Finally, you can implement in a more concise, efficient, and Pythonic way using a single statement: In this case, your function hits the first statement if . In all other cases, whether or , it hits the second statement. With this new implementation, your function looks a lot better. It’s more readable, concise, and efficient. Note: There’s a convenient built-in Python function called for computing the absolute value of a number. The function in the above example is intended only to illustrate the point under discussion. If you’re using statements to provide several statements, then you don’t need an clause to cover the last condition. Just add a statement at the end of the function’s code block and at the first level of indentation. Another common use case for the combination of and statements is when you’re coding a predicate or Boolean-valued function. This kind of function returns either or according to a given condition. For example, say you need to write a function that takes two integers, and , and returns if is divisible by . Otherwise, the function should return . Here’s a possible implementation: returns if the remainder of dividing by is equal to . Otherwise, it returns . Note that in Python, a value is falsy, so you need to use the operator to negate the truth value of the condition. Sometimes you’ll write predicate functions that involve operators like the following: In these cases, you can directly use a Boolean expression in your statement. This is possible because these operators return either or . Following this idea, here’s a new implementation of : If is divisible by , then returns , which is falsy in Python. So, to return , you need to use the operator. Note: Python follows a set of rules to determine the truth value of an object. For example, the following objects are considered falsy:\n• Numeric types with a zero value like , , , , and\n• Empty sequences and collections like , , , , , and\n• Objects that implement with a return value of or with a return value of Any other object will be considered truthy. On the other hand, if you try to use conditions that involve Boolean operators like and in the way you saw before, then your predicate functions won’t work correctly. That’s because these operators behave differently. They return one of the operands in the condition rather than or : In general, returns the first false operand or the last operand. On the other hand, returns the first true operand or the last operand. So, to write a predicate that involves one of these operators, you’ll need to use an explicit statement or a call to the built-in function . Suppose you want to write a predicate function that takes two values and returns if both are true and otherwise. Here’s your first approach to this function: Since returns operands instead of or , your function doesn’t work correctly. There are at least three possibilities for fixing this problem: If you use the first approach, then you can write as follows: The statement checks if and are both truthy. If so, then returns . Otherwise, it returns . If, on the other hand, you use a Python conditional expression or ternary operator, then you can write your predicate function as follows: Here, you use a conditional expression to provide a return value for . The conditional expression is evaluated to if both and are truthy. Otherwise, the final result is . Finally, if you use , then you can code as follows: returns if and are true and otherwise. It’s up to you what approach to use for solving this problem. However, the second solution seems more readable. What do you think? A statement inside a loop performs some kind of short-circuit. It breaks the loop execution and makes the function return immediately. To better understand this behavior, you can write a function that emulates . This built-in function takes an iterable and returns if at least one of its items is truthy. To emulate , you can code a function like the following: If any in is true, then the flow of execution enters in the block. The statement breaks the loop and returns immediately with a return value of . If no value in is true, then returns . This function implements a short-circuit evaluation. For example, suppose that you pass an iterable that contains a million items. If the first item in that iterable happens to be true, then the loop runs only one time rather than a million times. This can save you a lot of processing time when running your code. It’s important to note that to use a statement inside a loop, you need to wrap the statement in an statement. Otherwise, the loop will always break in its first iteration. As soon as a function hits a statement, it terminates without executing any subsequent code. Consequently, the code that appears after the function’s statement is commonly called dead code. The Python interpreter totally ignores dead code when running your functions. So, having that kind of code in a function is useless and confusing. Consider the following function, which adds code after its statement: The statement in this example will never execute because that statement appears after the function’s statement. Identifying dead code and removing it is a good practice that you can apply to write better functions. It’s worth noting that if you’re using conditional statements to provide multiple statements, then you can have code after a statement that won’t be dead as long as it’s outside the statement: Even though the call to is after a statement, it’s not dead code. When is evaluated to , the call is run and you get printed to your screen. When you’re writing a function that returns multiple values in a single statement, you can consider using a object to make your functions more readable. is a collection class that returns a subclass of that has fields or attributes. You can access those attributes using dot notation or an indexing operation. The initializer of takes several arguments. However, to start using in your code, you just need to know about the first two:\n• holds the name of the tuple-like class that you’re creating. It needs to be a string.\n• holds the names of the fields or attributes of the tuple-like class. It can be a sequence of strings such as or a single string with each name separated by whitespace or commas, such as or . Using a when you need to return multiple values can make your functions significantly more readable without too much effort. Consider the following update of using a as a return value: Inside , you create a called . This object can have named attributes that you can access by using dot notation or by using an indexing operation. In this example, those attributes are , , and . You can create a object and use it as a return value. To do that, you need to instantiate like you’d do with any Python class. Note that you need to supply a concrete value for each named attribute, just like you did in your statement. # Get the mean by its attribute name # Get the median by its index # Unpack the values into three variables When you call with a sample of numeric data, you get a object containing the mean, median, and mode of the sample. Note that you can access each element of the tuple by using either dot notation or an indexing operation. Finally, you can also use an iterable unpacking operation to store each value in its own independent variable.\n\nIn Python, functions are first-class objects. A first-class object is an object that can be assigned to a variable, passed as an argument to a function, or used as a return value in a function. So, you can use a function object as a return value in any statement. A function that takes a function as an argument, returns a function as a result, or both is a higher-order function. A closure factory function is a common example of a higher-order function in Python. This kind of function takes some arguments and returns an inner function. The inner function is commonly known as a closure. A closure carries information about its enclosing execution scope. This provides a way to retain state information between function calls. Closure factory functions are useful when you need to write code based on the concept of lazy or delayed evaluation. Suppose you need to write a helper function that takes a number and returns the result of multiplying that number by a given factor. You can code that function as follows: takes and as arguments and returns their product. Since rarely changes in your application, you find it annoying to supply the same factor in every function call. So, you need a way to retain the state or value of between calls to and change it only when needed. To retain the current value of between calls, you can use a closure. The following implementation of uses a closure to retain the value of between calls: Inside , you define an inner function called and return it without calling it. The function object you return is a closure that retains information about the state of . In other words, it remembers the value of between calls. That’s why remembers that was equal to and remembers that was equal to . Note that you can freely reuse and because they don’t forget their respective state information. You can also use a function to create closures. Sometimes the use of a function can make your closure factory more concise. Here’s an alternative implementation of using a function: This implementation works just like the original example. In this case, the use of a function provides a quick and concise way to code .\n\nAnother way of using the statement for returning function objects is to write decorator functions. A decorator function takes a function object as an argument and returns a function object. The decorator processes the decorated function in some way and returns it or replaces it with another function or callable object. Decorators are useful when you need to add extra logic to existing functions without modifying them. For example, you can code a decorator to log function calls, validate the arguments to a function, measure the execution time of a given function, and so on. The following example shows a decorator function that you can use to get an idea of the execution time of a given Python function: The syntax above the header of is equivalent to the expression . In this case, you can say that is decorating . Python runs decorator functions as soon as you import or run a module or a script. So, when you call , you’re really calling the return value of , which is the function object . The call to the decorated will return the mean of the sample and will also measure the execution time of the original . In this case, you use to measure the execution time inside the decorator. lives in a module called that provides a set of time-related functions. returns the time in seconds since the epoch as a floating-point number. The difference between the time before and after the call to will give you an idea of the function’s execution time. Note: In , you use the function , which suspends the execution of the calling code for a given number of seconds. For a better understanding on how to use , check out Python sleep(): How to Add Time Delays to Your Code. Other common examples of decorators in Python are , , and . If you want to dive deeper into Python decorators, then take a look at Primer on Python Decorators. You can also check out Python Decorators 101.\n\nThe Python statement allows you to send any Python object from your custom functions back to the caller code. This statement is a fundamental part of any Python function or method. If you master how to use it, then you’ll be ready to code robust functions. Next, you’ll find common questions that sum up the most important concepts you’ve learned in this tutorial. You can use these questions to check, recap, and solidify your knowledge. After each question, you’ll find an answer hidden in a collapsible section. Click the Show/Hide toggle to reveal it. But first, try to come up with the answer on your own. What’s the difference between explicit and implicit return statements?Show/Hide An explicit statement immediately ends the function’s execution and sends the specified value back to the caller. For example, a function can return a number, a list, or any other object. If no return statement is present, Python adds one implicitly, which returns . How do I return single or multiple values from my functions to the caller code?Show/Hide In Python, the statement allows you to send values back to the caller from a function. To return a single value, use the keyword followed by the value. This can be any data type, such as a number, string, list, or object. To return multiple values, list them after the return keyword separated by commas. Python packs these values into a tuple. You can then unpack the tuple into separate variables or store it as a single variable. What are the best practices I should apply when using the return statement?Show/Hide First, explicitly return when appropriate. If your function should return , do so explicitly with for clarity. However, if your function performs actions without a clear return value, you can omit the statement and rely on Python implicitly returning . Additionally, avoid complex return expressions. Instead, break them down to improve readability and debugging. You can also use short-circuiting in loops to simplify your code. Employ statements inside loops to exit early when a condition is met, saving processing time. You should also prefer self-contained functions over those that modify global variables, and when using conditional returns, handle all possible conditions with appropriate return statements to avoid hidden bugs. Creating a closure factory function involves making a function that returns another function. This inner function retains access to the variables from the outer function. It’s perfect for situations where you want to keep some state information between calls. For decorator functions, you write a function that takes another function, adds some extra functionality, and returns this new function. Decorators are great for tasks like logging and timing that aren’t central to the original function’s purpose. Do you want to take a quick quiz to evaluate your new skills? If so, then click the link below: Test your knowledge with our interactive “The Python return Statement” quiz. You’ll receive a score upon completion to help you track your learning progress: In this quiz, you can practice your understanding of how to use the Python return statement when writing functions. Additionally, you'll cover some good programming practices related to the use of return. With this knowledge, you'll be able to write readable, robust, and maintainable functions in Python."
    },
    {
        "link": "https://w3resource.com/python/python-user-defined-functions.php",
        "document": "In all programming and scripting language, a function is a block of program statements which can be used repetitively in a program. It saves the time of a developer. In Python concept of function is same as in other languages. There are some built-in functions which are part of Python. Besides that, we can defines functions according to our need.\n• In Python, a user-defined function's declaration begins with the keyword def and followed by the function name.\n• The function may take arguments(s) as input within the opening and closing parentheses, just after the function name followed by a colon.\n• After defining the function name and arguments(s) a block of program statement(s) start at the next line and these statement(s) must be indented.\n\nHere is the syntax of a user defined function.\n\nCalling a function in Python is similar to other programming languages, using the function name, parenthesis (opening and closing) and parameter(s). See the syntax, followed by an example.\n\n1. Lines 1-2 : Details (definition) of the function. \n\n 2. Line 3 : Call the function.\n\n 3. Line 1 : Pass parameters : x = 3, y = 4\n\n 4. Line 2 : Print the value of two parameters as well as their average value.\n\nThe following function has no arguments.\n\n1. Lines 1-4 : Details (definition) of the function. \n\n 2. Line 5 : Call the function.\n\n 3. Line 1 : No parameter passes.\n\n 4. Line 2-4 : Execute three print statements.\n\nIn Python the return statement (the word return followed by an expression.) is used to return a value from a function, return statement without an expression argument returns none. See the syntax.\n\nThe following function returns the square of the sum of two numbers.\n\n1. Lines 1-2 : Details (definition) of the function. \n\n 2. Line 3 : Call the function within a print statement.\n\n 3. Line 1 : Pass the parameters x = 2, y = 3\n\n 4. Line 2 : Calculate and return the value of (x + y)2\n\nIn function's parameters list we can specify a default value(s) for one or more arguments. A default value can be written in the format \"argument1 = value\", therefore we will have the option to declare or not declare a value for those arguments. See the following example.\n\nThe following function returns the square of the sum of two numbers, where default value of the second argument is 2.\n\nFor first print statement [ Line no 3] \n\n Line 3 : Call the function without a second argument, within a print statement.\n\n Line 1 : Pass the parameters x = 2, default value.\n\n Line 2 : Calculate and return the value of (x + y)2\n\nFor second print statement [ Line no 4] \n\n Line 3 : Call the function with all arguments, within a print statement.\n\n Line 1 : Pass the parameters x = 2, y = 4. \n\n Line 2 : Calculate and return the value of (x + y)2\n\nWe have already learned how to use default arguments values, functions can also be called using keyword arguments. Arguments which are preceded with a variable name followed by a '=' sign (e.g. var_name=\") are called keyword arguments.\n\nAll the keyword arguments passed must match one of the arguments accepted by the function. You may change the order of appearance of the keyword. See the following example.\n\nLine 1: The function named marks has three parameters, there is no default value in the first parameter (english) but remaining parameters have default values (math = 85, science = 80).\n\n Line 3: The parameter english gets the value of 71, math gets the value 77 and science gets the default value of 80. \n\n Line 4: The parameter english gets the value of 65, math gets the default value of 85 and science gets the value of 74 due to keyword arguments. \n\n Line 5: Here we use three keyword arguments and the parameter english gets the value 75, math gets the value 90 and science gets the value 70.\n\nThe 'arbitrary argument' list is an another way to pass arguments to a function. In the function body, these arguments will be wrapped in a tuple and it can be defined with *args construct. Before this variable, you can define a number of arguments or no argument.\n\nIn Python, small anonymous (unnamed) functions can be created with lambda keyword. Lambda forms can be used as an argument to other function where function objects are required but syntactically they are restricted to a single expression. A function like this:\n\nmay also be defined using lambda\n\nIn Python, a string literal is used for documenting a module, function, class, or method. You can access string literals by __doc__ (notice the double underscores) attribute of the object (e.g. my_function.__doc__).\n\n- String literal literals must be enclosed with a triple quote. Docstring should be informative\n\n- The first line may briefly describe the object's purpose. The line should begin with a capital letter and ends with a dot.\n\n- If a documentation string is a muti-line string then the second line should be blank followed by any detailed explanation starting from the third line.\n\nSee the following example with multi-line docstring."
    },
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    },
    {
        "link": "https://sites.pitt.edu/~naraehan/python3/user_defined_functions.html",
        "document": "On this page: , , docstrings, , value-returning vs. void functions Let's bust out some old-school algebra. You learned \"functions\" as something like:\n\n f(x) = x2 + 1 \n\n In Python, defining the function works as follows. is the keyword for defining a function. The function name is followed by parameter(s) in . The colon signals the start of the function body, which is marked by indentation. Inside the function body, the statement determines the value to be returned. After function definition is complete, calling the function with an argument returns a value. Let's try a different function. Below is a function that takes a verb (hopefully) and returns a gerund form: Below is a slightly more complex function. It takes two arguments, has a conditional in the function body, and starts with a string: def (wd1, wd2): \"\"\"Tests if two words start with the same character, and returns True/False. Case distinction is ignored.\"\"\" if wd1[0].lower() == wd2[0].lower(): return True else: return False same_initial( , ) same_initial( , ) The string is called a \"docstring\". Placed at the very top of the function body, it acts as a documentation on the function. This string gets printed out when you call on the function: help(same_initial) Help on function same_initial in module __main__: same_initial(wd1, wd2) Tests if two words start with the same character, and returns True/False. Case distinction is ignored. Here's another example. This function returns a list of characters two strings have in common. (Would be better if there were no duplicates. Can you improve it?) def (wd1, wd2): common = [] for c in wd1: if c in wd2: common.append(c) return sorted(common) in_both( , ) in_both( , ) \n\n You might be thinking: \"Wait a minute, I didn't see any return statement in the Defining Functions tutorial\". You are right -- the function Ed defined did not include any return statement, only a bunch of print functions. In Python, it is possible to compose a function without a return statement. Functions like this are called void, and they return , Python's special object for \"nothing\". Here's an example of a void function: OK, then, how are void functions and \"returning\"-type functions different? Good question. Let me illustrate with examples. Here's function defined above, and its void counterpart : Calling the two functions, you first notice the slight difference in the output. The returning function gives you a string (note ), while the printing function shows the printed output of the string -- notice the absence of quotes. Note that the returned value shows up in the interactive shell environment only; in a script, only commands result in an output display. Now, since returns a value, it can be scooped into a variable via an assignment statement. Try doing the same with , and you run into unintended consequences: printing happens upon the assignment statement, and you end up with nothing as the variable's value, because this function, being void, returns nothing. In addition, a value-returning function can be plugged right into another function. Again, since void functions return nothing, they can't. Below, is passed on to the function to a successful outcome. With , printing happens regardless and then it runs into a type error: len(get_ing( )) len(print_ing( )) Traceback (most recent call last): File \"<pyshell#371>\", line 1, in <module> len(print_ing('eat')) TypeError: object of type 'NoneType' has no len() Lastly, if printing is what you need, it can also be done with the value-returning function: simply use the statement with it. That took a while, but I hope you now clearly see the fundamental differences between the two function types. Truth be told, the returning-type functions are far more function-like and useful. In other languages, void-type functions are not even called a function at all -- they are called procedures instead."
    },
    {
        "link": "https://docs.python.org/3/tutorial/errors.html",
        "document": "Until now error messages haven’t been more than mentioned, but if you have tried out the examples you have probably seen some. There are (at least) two distinguishable kinds of errors: syntax errors and exceptions.\n\nSyntax errors, also known as parsing errors, are perhaps the most common kind of complaint you get while you are still learning Python: The parser repeats the offending line and displays little arrows pointing at the place where the error was detected. Note that this is not always the place that needs to be fixed. In the example, the error is detected at the function , since a colon ( ) is missing just before it. The file name ( in our example) and line number are printed so you know where to look in case the input came from a file.\n\nEven if a statement or expression is syntactically correct, it may cause an error when an attempt is made to execute it. Errors detected during execution are called exceptions and are not unconditionally fatal: you will soon learn how to handle them in Python programs. Most exceptions are not handled by programs, however, and result in error messages as shown here: File , line , in : File , line , in : name 'spam' is not defined File , line , in : can only concatenate str (not \"int\") to str The last line of the error message indicates what happened. Exceptions come in different types, and the type is printed as part of the message: the types in the example are , and . The string printed as the exception type is the name of the built-in exception that occurred. This is true for all built-in exceptions, but need not be true for user-defined exceptions (although it is a useful convention). Standard exception names are built-in identifiers (not reserved keywords). The rest of the line provides detail based on the type of exception and what caused it. The preceding part of the error message shows the context where the exception occurred, in the form of a stack traceback. In general it contains a stack traceback listing source lines; however, it will not display lines read from standard input. Built-in Exceptions lists the built-in exceptions and their meanings.\n\nIt is possible to write programs that handle selected exceptions. Look at the following example, which asks the user for input until a valid integer has been entered, but allows the user to interrupt the program (using - or whatever the operating system supports); note that a user-generated interruption is signalled by raising the exception. \"Oops! That was no valid number. Try again...\" The statement works as follows.\n• None First, the try clause (the statement(s) between the and keywords) is executed.\n• None If no exception occurs, the except clause is skipped and execution of the statement is finished.\n• None If an exception occurs during execution of the clause, the rest of the clause is skipped. Then, if its type matches the exception named after the keyword, the except clause is executed, and then execution continues after the try/except block.\n• None If an exception occurs which does not match the exception named in the except clause, it is passed on to outer statements; if no handler is found, it is an unhandled exception and execution stops with an error message. A statement may have more than one except clause, to specify handlers for different exceptions. At most one handler will be executed. Handlers only handle exceptions that occur in the corresponding try clause, not in other handlers of the same statement. An except clause may name multiple exceptions as a parenthesized tuple, for example: A class in an clause matches exceptions which are instances of the class itself or one of its derived classes (but not the other way around — an except clause listing a derived class does not match instances of its base classes). For example, the following code will print B, C, D in that order: Note that if the except clauses were reversed (with first), it would have printed B, B, B — the first matching except clause is triggered. When an exception occurs, it may have associated values, also known as the exception’s arguments. The presence and types of the arguments depend on the exception type. The except clause may specify a variable after the exception name. The variable is bound to the exception instance which typically has an attribute that stores the arguments. For convenience, builtin exception types define to print all the arguments without explicitly accessing . # __str__ allows args to be printed directly, # but may be overridden in exception subclasses The exception’s output is printed as the last part (‘detail’) of the message for unhandled exceptions. is the common base class of all exceptions. One of its subclasses, , is the base class of all the non-fatal exceptions. Exceptions which are not subclasses of are not typically handled, because they are used to indicate that the program should terminate. They include which is raised by and which is raised when a user wishes to interrupt the program. can be used as a wildcard that catches (almost) everything. However, it is good practice to be as specific as possible with the types of exceptions that we intend to handle, and to allow any unexpected exceptions to propagate on. The most common pattern for handling is to print or log the exception and then re-raise it (allowing a caller to handle the exception as well): \"Could not convert data to an integer.\" The … statement has an optional else clause, which, when present, must follow all except clauses. It is useful for code that must be executed if the try clause does not raise an exception. For example: The use of the clause is better than adding additional code to the clause because it avoids accidentally catching an exception that wasn’t raised by the code being protected by the … statement. Exception handlers do not handle only exceptions that occur immediately in the try clause, but also those that occur inside functions that are called (even indirectly) in the try clause. For example:\n\nThe statement allows the programmer to force a specified exception to occur. For example: The sole argument to indicates the exception to be raised. This must be either an exception instance or an exception class (a class that derives from , such as or one of its subclasses). If an exception class is passed, it will be implicitly instantiated by calling its constructor with no arguments: If you need to determine whether an exception was raised but don’t intend to handle it, a simpler form of the statement allows you to re-raise the exception:\n\nIf an unhandled exception occurs inside an section, it will have the exception being handled attached to it and included in the error message: File , line , in : [Errno 2] No such file or directory: 'database.sqlite' During handling of the above exception, another exception occurred: File , line , in : To indicate that an exception is a direct consequence of another, the statement allows an optional clause: # exc must be exception instance or None. This can be useful when you are transforming exceptions. For example: File , line , in File , line , in The above exception was the direct cause of the following exception: File , line , in : It also allows disabling automatic exception chaining using the idiom: For more information about chaining mechanics, see Built-in Exceptions.\n\nThe statement has another optional clause which is intended to define clean-up actions that must be executed under all circumstances. For example: If a clause is present, the clause will execute as the last task before the statement completes. The clause runs whether or not the statement produces an exception. The following points discuss more complex cases when an exception occurs:\n• None If an exception occurs during execution of the clause, the exception may be handled by an clause. If the exception is not handled by an clause, the exception is re-raised after the clause has been executed.\n• None An exception could occur during execution of an or clause. Again, the exception is re-raised after the clause has been executed.\n• None If the clause executes a , or statement, exceptions are not re-raised.\n• None If the statement reaches a , or statement, the clause will execute just prior to the , or statement’s execution.\n• None If a clause includes a statement, the returned value will be the one from the clause’s statement, not the value from the clause’s statement. As you can see, the clause is executed in any event. The raised by dividing two strings is not handled by the clause and therefore re-raised after the clause has been executed. In real world applications, the clause is useful for releasing external resources (such as files or network connections), regardless of whether the use of the resource was successful.\n\nSome objects define standard clean-up actions to be undertaken when the object is no longer needed, regardless of whether or not the operation using the object succeeded or failed. Look at the following example, which tries to open a file and print its contents to the screen. The problem with this code is that it leaves the file open for an indeterminate amount of time after this part of the code has finished executing. This is not an issue in simple scripts, but can be a problem for larger applications. The statement allows objects like files to be used in a way that ensures they are always cleaned up promptly and correctly. After the statement is executed, the file f is always closed, even if a problem was encountered while processing the lines. Objects which, like files, provide predefined clean-up actions will indicate this in their documentation.\n\nThere are situations where it is necessary to report several exceptions that have occurred. This is often the case in concurrency frameworks, when several tasks may have failed in parallel, but there are also other use cases where it is desirable to continue execution and collect multiple errors rather than raise the first exception. The builtin wraps a list of exception instances so that they can be raised together. It is an exception itself, so it can be caught like any other exception. By using instead of , we can selectively handle only the exceptions in the group that match a certain type. In the following example, which shows a nested exception group, each clause extracts from the group exceptions of a certain type while letting all other exceptions propagate to other clauses and eventually to be reraised. Note that the exceptions nested in an exception group must be instances, not types. This is because in practice the exceptions would typically be ones that have already been raised and caught by the program, along the following pattern:\n\nWhen an exception is created in order to be raised, it is usually initialized with information that describes the error that has occurred. There are cases where it is useful to add information after the exception was caught. For this purpose, exceptions have a method that accepts a string and adds it to the exception’s notes list. The standard traceback rendering includes all notes, in the order they were added, after the exception. For example, when collecting exceptions into an exception group, we may want to add context information for the individual errors. In the following each exception in the group has a note indicating when this error has occurred. | ExceptionGroup: We have some problems (3 sub-exceptions)"
    },
    {
        "link": "https://harithj.medium.com/mastering-error-handling-in-python-a-comprehensive-guide-b0202840a5ad",
        "document": "Error handling is an essential aspect of programming. Writing code that can anticipate and gracefully handle errors not only improves the stability of your applications but also makes them easier to maintain and debug. In this comprehensive guide, we’ll explore best practices for error handling in Python, covering everything from custom exceptions to the proper use of try-except blocks.\n\nBy the end of this article, you’ll have a solid understanding of how to implement effective error handling in your Python projects, making your code more robust and maintainable.\n\nErrors are inevitable in any software application. They can result from programming mistakes, invalid user input, or unexpected situations, such as network outages or file corruption. Proper error handling allows your application to continue running, recover from errors, or provide useful feedback to the user when something goes wrong. Ignoring errors can lead to unpredictable behavior, data corruption, or application crashes.\n\nIn Python, errors are handled using exceptions. An exception is an event that occurs during the execution of a program, indicating that something has gone wrong. When an exception is raised, the normal flow of the program is interrupted, and the Python interpreter looks for an appropriate exception handler to deal with the situation.\n\nSome common built-in exceptions in Python include , , , and . You can also create your own custom exceptions to handle specific errors in your application.\n\nTo create a custom exception, define a new class that inherits from the built-in class. This allows you to create error types specific to your application, making it easier to identify and handle particular errors.\n\nA try-except block is used to enclose code that might raise an exception. If an exception occurs within the try block, it is caught and handled by the corresponding except block. You can catch specific exceptions or multiple exceptions at once.\n\nIf a function encounters an error it can’t handle, it should raise the exception to be caught and handled by the calling function. This can be achieved using the keyword without any arguments or by raising a new exception with additional context.\n\nThe clause is used in try-except blocks to execute code that must run regardless of whether an exception was raised or not. This is particularly useful for cleaning up resources, such as closing file handles or database connections.\n\nWhen handling exceptions, it’s important to log them for later analysis and debugging. Python’s built-in module provides a flexible framework for emitting log messages from your code. Make sure to log the traceback as well, which provides valuable context about the exception.\n• Don’t catch all exceptions: Avoid using a bare clause, as it catches all exceptions, including system-level ones, which can make debugging difficult. Always specify the exceptions you want to catch.\n• Use exception chaining: If you raise a new exception in response to another one, use the keyword to chain the exceptions. This helps preserve the original traceback and provides better context when debugging.\n• Avoid using exceptions for control flow: Exceptions should be reserved for handling errors, not for controlling the normal flow of your program. Instead, use conditional statements and other control structures for regular flow control.\n• Write informative error messages: When raising exceptions, include a clear and concise error message that provides context about the error. This makes it easier to understand and debug the issue.\n\nMastering error handling in Python is crucial for writing robust and maintainable code. By following the best practices outlined in this guide, you’ll be well-equipped to handle exceptions effectively in your Python projects. Remember to use custom exceptions, try-except blocks, and proper logging to create applications that can recover from errors gracefully and provide useful feedback to users.\n\nEmbrace the power of effective error handling, and watch your Python applications become more reliable and resilient. Happy coding!"
    },
    {
        "link": "https://geeksforgeeks.org/python-exception-handling",
        "document": "Python Exception Handling handles errors that occur during the execution of a program. Exception handling allows to respond to the error, instead of crashing the running program. It enables you to catch and manage errors, making your code more robust and user-friendly.\n\nExample: Trying to divide a number by zero will cause an exception.\n\nExplanation: In this example, dividing number by 0 raises a ZeroDivisionError. The try block contains the code that might cause an exception and the except block handles the exception, printing an error message instead of stopping the program.\n• Error : Errors are serious issues that a program should not try to handle. They are usually problems in the code’s logic or configuration and need to be fixed by the programmer. Examples include syntax errors and memory errors.\n• Exception : Exceptions are less severe than errors and can be handled by the program. They occur due to situations like invalid input, missing files or network issues.\n\nExplanation: A syntax error is a coding mistake that prevents the code from running. In contrast, an exception like ZeroDivisionError can be managed during the program’s execution using exception handling.\n\nException handling in Python is done using the try, except, else and finally blocks.\n\ntry, except, else and finally Blocks\n• try Block lets us test a block of code for errors. Python will “try” to execute the code in this block. If an exception occurs, execution will immediately jump to the except block.\n• except Block: enables us to handle the error or exception. If the code inside the try block throws an error, Python jumps to the except block and executes it. We can handle specific exceptions or use a general except to catch all exceptions.\n• else Block: is optional and if included, must follow all except blocks. The else block runs only if no exceptions are raised in the try block. This is useful for code that should execute if the try block succeeds.\n• finally Block: always runs, regardless of whether an exception occurred or not. It is typically used for cleanup operations (closing files, releasing resources).\n• try block asks for user input and tries to divide 100 by the input number.\n• else block runs if no exception occurs, displaying the result.\n• finally block runs regardless of the outcome, indicating the completion of execution.\n\nPython has many built-in exceptions, each representing a specific error condition. Some common ones include:\n\nThe base class for all built-in exceptions. The base class for all non-exit exceptions. Base class for all errors related to arithmetic operations. Raised when a division or modulo operation is performed with zero as the divisor. Raised when a numerical operation exceeds the maximum limit of a data type. Raised when an attribute reference or assignment fails. Raised when a sequence subscript is out of range. Raised when a dictionary key is not found. Raised when an operation runs out of memory. Raised when a local or global name is not found. Raised when an operation or function is applied to an object of inappropriate type. Raised when a function receives an argument of the right type but inappropriate value. Raised when an import statement has issues. Raised when a module cannot be found.\n\nWhen working with exceptions in Python, we can handle errors more efficiently by specifying the types of exceptions we expect. This can make code both safer and easier to debug.\n\nCatching specific exceptions makes code to respond to different exception types differently.\n• None The ValueError is caught because the string “str” cannot be converted to an integer.\n• None If x were 0 and conversion successful, the ZeroDivisionError would be caught when attempting to calculate its inverse.\n\nWe can catch multiple exceptions in a single block if we need to handle them in the same way or we can separate them if different types of exceptions require different handling.\n• None The ValueError is caught when trying to convert “twenty” to an integer.\n• None TypeError might occur if the operation was incorrectly applied to non-integer types, but it’s not triggered in this specific setup.\n• None IndexError would be caught if an index outside the range of the list was accessed, but in this scenario, it’s under control.\n\nHere’s a simple calculation that may fail due to various reasons.\n• None An ArithmeticError (more specific like ZeroDivisionError) might be caught if this were a number-to-number division error. However, TypeError is actually triggered here due to attempting to divide a string by a number.\n• catch-all except: is used to catch the TypeError, demonstrating the risk that the programmer might not realize the actual cause of the error (type mismatch) without more detailed error logging.\n\nWe raise an exception in Python using the raise keyword followed by an instance of the exception class that we want to trigger. We can choose from built-in exceptions or define our own custom exceptions by inheriting from Python’s built-in Exception class.\n• None The function set checks if the age is negative. If so, it raises a ValueError with a message explaining the issue.\n• None This ensures that the age attribute cannot be set to an invalid state, thus maintaining the integrity of the data.\n• Improved program reliability : By handling exceptions properly, you can prevent your program from crashing or producing incorrect results due to unexpected errors or input.\n• Simplified error handling : Exception handling allows you to separate error handling code from the main program logic, making it easier to read and maintain your code.\n• Cleaner code: With exception handling, you can avoid using complex conditional statements to check for errors, leading to cleaner and more readable code.\n• Easier debugging : When an exception is raised, the Python interpreter prints a traceback that shows the exact location where the exception occurred, making it easier to debug your code.\n• Performance overhead: Exception handling can be slower than using conditional statements to check for errors, as the interpreter has to perform additional work to catch and handle the exception.\n• Increased code complexity : Exception handling can make your code more complex, especially if you have to handle multiple types of exceptions or implement complex error handling logic.\n• Possible security risks: Improperly handled exceptions can potentially reveal sensitive information or create security vulnerabilities in your code, so it’s important to handle exceptions carefully and avoid exposing too much information about your program."
    },
    {
        "link": "https://stackoverflow.com/questions/1630706/best-practice-in-python-for-return-value-on-error-vs-success",
        "document": "The general case is to throw exceptions for exceptional circumstances. I wish that I could remember the exact quote (or who said it), but you should strive for functions that accept as many values and types as is reasonable and maintain a very narrowly defined behavior. This is a variant of what Nadia was talking about. Consider the following usages of your function:\n\nI would expect that (5) throws an exception since passing is a type error. The rest of them, however, make some sort of sense but it really depends on the contract that the function states. If were defined as returning the intersection of two iterables, then everything other than (5) should work as long as you make a valid representation of the empty set. The implementation would be something like:\n\nI usually write helper functions that enforce whatever the contract is and then call them to check all of the preconditions. Something like:\n\nYou can also extend this concept and pass in the \"policy\" as an optional argument. I would not advise doing this unless you want to embrace Policy Based Design. I did want to mention it just in case you haven't looked into this option before.\n\nIf the contract for is that it only accepts two non-empty parameters, then be explicit and throw exceptions if the contract is breached:\n\nI think that the moral of the story is whatever you do, do it consistently and be explicit. Personally, I usually favor raising exceptions whenever a contract is breached or I am given a value that I really cannot use. If the values that I am given are reasonable, then I try to do something reasonable in return. You might also want to read the C++ FAQ Lite entry on exceptions. This particular entry gives you some more food for thought about exceptions."
    },
    {
        "link": "https://llego.dev/posts/error-handling-strategies-best-practices-python",
        "document": "Error handling is a critical component of writing robust and production-ready Python code. Properly handling errors and exceptions helps make programs more reliable, user-friendly, and secure. This comprehensive guide examines key principles, strategies, and best practices for effective error handling in Python.\n\nErrors and exceptions are an inevitable part of writing programs. Bugs in code, unexpected user input, network interruptions, and many other factors can trigger exceptions and runtime errors. Without proper error handling, programs may crash unexpectedly or expose sensitive system information through tracebacks.\n\nRobust error handling improves overall code quality. It prevents crashes, provides useful feedback to users, secures sensitive system data, and facilitates diagnosing and fixing bugs during development. This guide explores error handling best practices using tools built into Python and supplemental libraries.\n• Handling various exception types and use cases\n• Best practices for writing clean and user-friendly error messages\n\nFollow these evidence-based guidelines and strategies to write Python code that gracefully handles errors and provides excellent user experiences.\n\nApproaching error handling systematically and deliberately is key to writing robust Python programs. Keep these core principles in mind:\n\nFail Fast, Fail Early - Check for potential errors as early as possible and raise exceptions immediately when issues occur. This helps locate the root cause quickly and prevents propagating bad data or issues further in the program.\n\nDon’t Ignore Errors - Do not suppress or ignore errors without considering the implications. Handle exceptions appropriately based on context and severity.\n\nDocument Expected Errors - Document what errors could occur and how the program handles them with docstrings and comments. This helps other developers use your code.\n\nPrioritize Clarity - Error messages should clearly explain what went wrong and how to resolve issues to users and developers. Avoid opaque errors and tracebacks with generic exception names like or .\n\nSecure Sensitive Data - Do not expose system paths, database credentials, or other sensitive data in error messages. Log errors securely and show users generalized messages.\n\nFail Gracefully - If the error does not critically break code execution, catch the exception and fail gracefully to allow continued program functioning rather than crashing entirely.\n\nMinimize Scope - Only handle exceptions that the immediate code block can properly resolve. Re-raising exceptions propagates them to outer scopes that may have more context to handle the issue.\n\nKeeping these principles in mind while programming and debugging helps developers write more robust error handling suitable for production systems.\n\nPython has several built-in mechanisms for error handling:\n\nExceptions indicate an error occurred during execution. Python generates a variety of built-in exception types like , , and that indicate what went wrong. Custom exceptions can also subclass the base class.\n\n/ blocks handle exceptions in Python. The block contains code that may raise an exception. The block catches and handles the exception. Multiple blocks can handle different exception types.\n\nA block executes after a / block completes but before leaving the scope. This is useful for cleanup like closing files.\n\nAn block after / runs only if no exceptions occurred. This avoids needing to track success with a boolean flag:\n\nThis covers Python’s basic error handling tools. Robust error handling also requires knowledge of common exception hierarchies and types.\n\nPython defines various exceptions for errors in code, I/O, imports, system issues, and more. Here are best practices for handling some common exceptions:\n\nA occurs when a function receives an argument of the expected type but an inappropriate value. Handle by validating arguments and inputs before passing to functions:\n\nA happens when an operation or function is applied to an incompatible type. Adding extra type checking helps avoid :\n\nAn occurs when Python cannot import a module. Catching this exception allows gracefully handling missing dependencies:\n\nAn happens when a system operation fails, like unable to open a file, reach a network resource, or find a path. The error message usually indicates the underlying reason:\n\nAn indicates trying to access an element in a sequence that is out-of-bounds. Check array sizes before accessing elements to avoid this exception:\n\nError messages should clearly communicate issues to users without exposing sensitive system information. Follow these best practices for writing good error messages:\n• Be Specific - Avoid generic error messages like “An error occurred”. Provide details about what failed, such as citing invalid user inputs or missing files.\n• Be Actionable - Tell users how to resolve issues when possible. For invalid credentials, suggest signing up or resetting password.\n• Be User-Focused - Avoid technical jargon and discuss problems from the user’s perspective. For example, “File not found” rather than “IOError: [Errno 2] No such file or directory”.\n• Keep Sensitive Data Private - Do not reveal system paths, code snippets, or network details. Log them separately for debugging instead.\n• Use Proper Grammar and Formatting - Messages should be written concisely with proper spelling, grammar, and formatting. Follow style guidelines like capitalizing first word and no period at end.\n• Provide Context - Where possible include context like which function failed, the argument types, and valid value examples. But strive for brevity.\n• Use Built-in Parameters - Some exceptions like and allow passing a descriptive message as a parameter.\n• Do Not Fail Silently - Never fail with a generic exception or fail without an error. The lack of errors can make issues harder to debug.\n\nBelow is an example illustrating some recommended practices for clear, user-friendly error messages:\n\nExceptions provide important clues during debugging by signaling when and where code failures occur. Strategically raising and handling exceptions helps isolate bugs.\n\nFollow these best practices to leverage exceptions for debugging:\n• Add Debug Prints - Print variable values at strategic points before exception handlers to inspect program state.\n• Handle Exceptions Granularly - Divide code into smaller functions and handle exceptions locally to pinpoint where issues arise.\n• Log Exceptions - Keep a detailed audit trail by logging caught exceptions along with relevant context like time, user, call stack, and system details.\n• ** Raise Exceptions Early** - Validate prerequisites of functions at start and raise exceptions immediately if failure conditions found. Avoid masking underlying issues.\n• Create Reproducible Test Cases - Isolate the minimum steps to recreate exceptions in unit tests and document the steps. Simpler test cases help isolate causes.\n• Use Debugger - Debuggers like allow stepping through code line-by-line after an exception occurs to inspect stack and variables.\n• Catch Narrow Exceptions First - In exception handling, catch specific exceptions before broad ones to differentiate error causes.\n\nUsing exceptions effectively speeds up debugging by signaling failures immediately and clearly highlighting where issues occur within the program logic.\n\nHow code is structured also impacts error handling. These guidelines help better organize code for managing errors:\n\nEncapsulate complex operations prone to failure in functions instead of spreading across code. Localize error handling to these functions.\n\nKeep the main business logic separate from error handling code. Extract error handling into helper functions and classes to avoid cluttering application logic.\n\nNote exceptions that functions may raise in docstrings and comments. This helps developers who use your code handle errors properly.\n\nUse multiple / blocks each handling specific exceptions rather than overbroad blocks. This makes error handling more precise.\n\nHave functions raise exceptions as soon as errors occur. Catch and handle exceptions at the highest level scope possible. This avoids repetition.\n\nFor common error cases, define custom exception classes with clear names that explain the errors. This makes handling across the program consistent.\n\nFollowing these guidelines helps organize code in a maintainable way that keeps error handling responsibility clear and simple.\n\nIn addition to built-in Python error handling mechanisms, several libraries provide useful supplemental features:\n\nRobust logging using the module helps track handled and unhandled exceptions. The call stack tracks where errors originated.\n\nSentry aggregates and analyzes exceptions across systems providing alerts and context about crashes in production.\n\nThe function extracts exception details into a chained exception to avoid losing context from original failures.\n\nDecorator functions like can automatically re-execute functions that failed, simplifying some types of error handling.\n\nWeb frameworks like Flask-RESTful have exception handling mechanisms tailored for web APIs. HTTP status codes clearly convey API errors.\n\nExternal libraries help group related exceptions and enable handling them together. For example, groups all request-related exceptions.\n\nCareful attention to error handling helps create reliable and user-friendly Python programs. Following Python’s principles and best practices ensures errors get handled appropriately.\n\nLeverage built-in mechanisms like exceptions, / blocks, and informative error messages. Structure code strategically to localize and simplify error handling. Employ supplemental tools like debugging techniques and logging to build robust and resilient applications.\n\nEffective error handling requires adopting a conscientious mindset oriented around defensively writing code. Failing fast, documenting expectations, and guiding users through errors leads to correct and graceful failure handling. This allows Python developers to write code that remains resilient in the face of inevitable real-world exceptions and edge cases."
    }
]