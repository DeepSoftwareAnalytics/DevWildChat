[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html",
        "document": "\n• to a specific address (IP address and port number). If the address is , then the system will pick up an ephemeral port and a valid local address to bind the socket. - The IP address and port number to bind to. - if the bind operation fails, or if the socket is already bound. - if a is present and its method doesn't allow the operation. - if endpoint is a SocketAddress subclass not supported by this socket\n• to a specific address (IP address and port number). If the address is , then the system will pick up an ephemeral port and a valid local address to bind the socket. The argument is the requested maximum number of pending connections on the socket. Its exact semantics are implementation specific. In particular, an implementation may impose a maximum length or may choose to ignore the parameter altogther. The value provided should be greater than . If it is less than or equal to , then an implementation specific default will be used. - The IP address and port number to bind to. - requested maximum length of the queue of incoming connections. - if the bind operation fails, or if the socket is already bound. - if a is present and its method doesn't allow the operation. - if endpoint is a SocketAddress subclass not supported by this socket\n• Returns the local address of this server socket. If the socket was bound prior to being , then this method will continue to return the local address after the socket is closed. If there is a security manager set, its method is called with the local address and as its arguments to see if the operation is allowed. If the operation is not allowed, the address is returned. the address to which this socket is bound, or the loopback address if denied by the security manager, or if the socket is unbound.\n• Returns the port number on which this socket is listening. If the socket was bound prior to being , then this method will continue to return the port number after the socket is closed. the port number to which this socket is listening or -1 if the socket is not bound yet.\n• Returns the address of the endpoint this socket is bound to. If the socket was bound prior to being , then this method will continue to return the address of the endpoint after the socket is closed. If there is a security manager set, its method is called with the local address and as its arguments to see if the operation is allowed. If the operation is not allowed, a representing the address and the local port to which the socket is bound is returned. a representing the local endpoint of this socket, or a representing the loopback address if denied by the security manager, or if the socket is not bound yet.\n• Listens for a connection to be made to this socket and accepts it. The method blocks until a connection is made. A new Socket is created and, if there is a security manager, the security manager's method is called with and as its arguments to ensure the operation is allowed. This could result in a SecurityException. - if an I/O error occurs when waiting for a connection. - if a security manager exists and its method doesn't allow the operation. - if a timeout was previously set with setSoTimeout and the timeout has been reached. - if this socket has an associated channel, the channel is in non-blocking mode, and there is no connection ready to be accepted\n• Subclasses of ServerSocket use this method to override accept() to return their own subclass of socket. So a FooServerSocket will typically hand this method an empty FooSocket. On return from implAccept the FooSocket will be connected to a client. - if this socket has an associated channel, and the channel is in non-blocking mode - if an I/O error occurs when waiting for a connection.\n• Closes this socket. Any thread currently blocked in will throw a If this socket has an associated channel then the channel is closed as well. - if an I/O error occurs when closing the socket.\n• Returns the unique object associated with this socket, if any. A server socket will have a channel if, and only if, the channel itself was created via the method. the server-socket channel associated with this socket, or if this socket was not created for a channel\n• Returns the binding state of the ServerSocket. true if the ServerSocket successfully bound to an address\n• Returns the closed state of the ServerSocket. true if the socket has been closed\n• java.net.SocketTimeoutException is raised, though the ServerSocket is still valid. The option must be enabled prior to entering the blocking operation to have effect. The timeout must be . A timeout of zero is interpreted as an infinite timeout. Enable/disable with the specified timeout, in milliseconds. With this option set to a non-zero timeout, a call to accept() for this ServerSocket will block for only this amount of time. If the timeout expires, ais raised, though the ServerSocket is still valid. The optionbe enabled prior to entering the blocking operation to have effect. The timeout must be. A timeout of zero is interpreted as an infinite timeout. - the specified timeout, in milliseconds - if there is an error in the underlying protocol, such as a TCP error.\n• Retrieve setting for . 0 returns implies that the option is disabled (i.e., timeout of infinity).\n• When a TCP connection is closed the connection may remain in a timeout state for a period of time after the connection is closed (typically known as the state or wait state). For applications using a well known socket address or port it may not be possible to bind a socket to the required if there is a connection in the timeout state involving the socket address or port. Enabling prior to binding the socket using allows the socket to be bound even though a previous connection is in a timeout state. When a is created the initial setting of is not defined. Applications can use to determine the initial setting of . The behaviour when is enabled or disabled after a socket is bound (See ) is not defined. - whether to enable or disable the socket option - if an error occurs enabling or disabling the socket option, or the socket is closed.\n• a indicating whether or not is enabled. - if there is an error in the underlying protocol, such as a TCP error.\n• . Returns the implementation address and implementation port of this socket as a If there is a security manager set, its method is called with the local address and as its arguments to see if the operation is allowed. If the operation is not allowed, an representing the address is returned as the implementation address.\n• Sets the server socket implementation factory for the application. The factory can be specified only once. When an application creates a new server socket, the socket implementation factory's method is called to create the actual socket implementation. Passing to the method is a no-op unless the factory was already set. If there is a security manager, this method first calls the security manager's method to ensure the operation is allowed. This could result in a SecurityException. - if an I/O error occurs when setting the socket factory. - if the factory has already been defined. - if a security manager exists and its method doesn't allow the operation.\n• . The value actually set in the accepted socket must be determined by calling Sets a default proposed value for the option for sockets accepted from this. The value actually set in the accepted socket must be determined by calling after the socket is returned by The value of is used both to set the size of the internal socket receive buffer, and to set the size of the TCP receive window that is advertized to the remote peer. It is possible to change the value subsequently, by calling . However, if the application wishes to allow a receive window larger than 64K bytes, as defined by RFC1323 then the proposed value must be set in the ServerSocket before it is bound to a local address. This implies, that the ServerSocket must be created with the no-argument constructor, then setReceiveBufferSize() must be called and lastly the ServerSocket is bound to an address by calling bind(). Failure to do this will not cause an error, and the buffer size may be set to the requested value but the TCP receive window in sockets accepted from this ServerSocket will be no larger than 64K bytes. - the size to which to set the receive buffer size. This value must be greater than 0. - if there is an error in the underlying protocol, such as a TCP error. - if the value is 0 or is negative.\n• , that is the proposed buffer size that will be used for Sockets accepted from this . Gets the value of the option for this, that is the proposed buffer size that will be used for Sockets accepted from this Note, the value actually set in the accepted socket is determined by calling . the value of the option for this . - if there is an error in the underlying protocol, such as a TCP error.\n• Sockets use the TCP/IP protocol by default. Some implementations may offer alternative protocols which have different performance characteristics than TCP/IP. This method allows the application to express its own preferences as to how these tradeoffs should be made when the implementation chooses from the available protocols. Performance preferences are described by three integers whose values indicate the relative importance of short connection time, low latency, and high bandwidth. The absolute values of the integers are irrelevant; in order to choose a protocol the values are simply compared, with larger values indicating stronger preferences. If the application prefers short connection time over both low latency and high bandwidth, for example, then it could invoke this method with the values . If the application prefers high bandwidth above low latency, and low latency above short connection time, then it could invoke this method with the values . Invoking this method after this socket has been bound will have no effect. This implies that in order to use this capability requires the socket to be created with the no-argument constructor. - An expressing the relative importance of a short connection time - An expressing the relative importance of low latency - An expressing the relative importance of high bandwidth"
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api?java/net/ServerSocket.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://geeksforgeeks.org/java-net-serversocket-class-in-java",
        "document": "ServerSocket Class in Java provides a system-independent way to implement the server side of a client/server socket connection. The constructor for ServerSocket throws an exception if it can’t listen on the specified port (for example, the port is already being used).\n• java.nio channel , ServerSocket class is used for retrieving a ServerSocket associated with this channel.\n• java.rmi.Server , ServerSocket class is used to create a server socket on the specified port (port 0 indicates an anonymous port).\n• javax.net , the ServerSocket is used widely to:\n• None return a server socket bound to the specified port.\n• None return a server socket bound to the specified port, and uses the specified connection backlog.\n• None return a server socket bound to the specified port, with a specified listen backlog and local IP.\n\nThe below Java program demonstrates the working of server-side programming using ServerSocket class.\n\nExplanation: In the above example, it demonstrates a basic server-side implementation using the ServerSocket class. It listens on port 6666, accepts a client connection, reads a message sent by the client, and then closes the connection.\n\nThe below Java program demonstrate the working of client-side programming using ServerSocket class.\n\nExplanation: In the above example, it demonstrates a basic client-side implementation using the Socket class. It connects to a server at localhost on port 6666, sends a message “Hello GFG Readers!”, and then closes the connection.\n\nListens for a connection to be made to this socket and accepts it. Binds the ServerSocket to a specific address (IP address and port number). Binds the ServerSocket to a specific address (IP address and port number) and requests queqe length. If a request arrives when the queue is full then the request will be rejected by the server. Returns the unique ServerSocketChannel object associated with this socket, if any. Returns the local address of this server socket. Returns the port number on which this socket is listening. Returns the address of the endpoint this socket is bound to, or null if it is not bound yet. Gets the value of the SO_RCVBUF option for this ServerSocket, that is the proposed buffer size that will be used for Sockets accepted from this ServerSocket. Subclasses of ServerSocket use this method to override accept() to return their own subclass of the Returns the binding state of the ServerSocket. Returns the closed state of the ServerSocket. Sets a default proposed value for the SO_RCVBUF option for sockets accepted from this ServerSocket. Sets the server socket implementation factory for the application. Enable/disable SO_TIMEOUT with the specified timeout, in milliseconds. Returns the implementation address and implementation port of this socket as a String."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/java-socket-programming-server-client",
        "document": "Welcome to Java Socket programming example. Every server is a program that runs on a specific system and listens on a specific port. Sockets are bound to the port numbers and when we run any server it just listens on the socket and waits for client requests. For example, tomcat server running on port 8080 waits for client requests and once it gets any client request, it responds to them.\n\nA socket is one endpoint of a two-way communication link between two programs running on the network. The socket is bound to a port number so that the TCP layer can identify the application that data is destined to be sent. In java socket programming example tutorial, we will learn how to write java socket server and java socket client program. We will also learn how server client program read and write data on the socket. java.net.Socket and java.net.ServerSocket are the java classes that implements Socket and Socket server.\n\nTo test java socket programming of server-client communication, first we need to run class. When you will run socket server, it will just print “Waiting for client request” and then wait for the client request. Now when you will run SocketClientExample class, it will send a request to java socket server and print the response message to console. Here is the output of java socket server program.\n\nHere is the output of Java socket client program.\n\nThat’s all for a quick roundup of Socket programming in java. I hope you can get started with java socket server and java socket client programming. Reference: Oracle Doc"
    },
    {
        "link": "https://baeldung.com/a-guide-to-java-sockets",
        "document": "The term socket programming refers to writing programs that execute across multiple computers in which the devices are all connected to each other using a network.\n\nThere are two communication protocols that we can use for socket programming: User Datagram Protocol (UDP) and Transfer Control Protocol (TCP).\n\nThe main difference between the two is that UDP is connection-less, meaning there’s no session between the client and the server, while TCP is connection-oriented, meaning an exclusive connection must first be established between the client and server for communication to take place.\n\nThis tutorial presents an introduction to sockets programming over TCP/IP networks, and demonstrates how to write client/server applications in Java. UDP isn’t a mainstream protocol, and as such, might not be encountered often.\n\nJava provides a collection of classes and interfaces that take care of low-level communication details between the client and server.\n\nThese are mostly contained in the java.net package, so we need to make the following import:\n\nWe also need the java.io package, which gives us input and output streams to write to and read from while communicating:\n\nFor the sake of simplicity, we’ll run our client and server programs on the same computer. If we were to execute them on different networked computers, the only thing that would change is the IP address. In this case, we’ll use localhost on 127.0.0.1.\n\nLet’s get our hands dirty with the most basic of examples involving a client and a server. It’s going to be a two-way communication application where the client greets the server and the server responds.\n\nWe’ll create the server application in a class called GreetServer.java with the following code.\n\nWe’ll include the main method and the global variables to draw attention to how we’ll be running all servers in this article. For the rest of the examples in this article, we’ll omit this kind of repetitive code:\n\nWe’ll also create a client called GreetClient.java with this code:\n\nNow let’s start the server. In our IDE, we do this by simply running it as a Java application.\n\nThen we’ll send a greeting to the server using a unit test, which confirms the server sends a greeting in response:\n\nThis example gives us a feel for what to expect later in the article. As such, we might not yet completely understand what’s happening here.\n\nIn the following sections, we’ll dissect socket communication using this simple example, and dive into more complex ones as well.\n\nWe’ll use the above example to step through different parts of this section.\n\nBy definition, a socket is one endpoint of a two-way communication link between two programs running on different computers on a network. A socket is bound to a port number so that the transport layer can identify the application that data is destined to be sent to.\n\nUsually, a server runs on a specific computer on the network and has a socket that’s bound to a specific port number. In our case, we’ll use the same computer as the client, and start the server on port 6666:\n\nThe server just waits, listening to the socket for a client to make a connection request. This happens in the next step:\n\nWhen the server code encounters the accept method, it blocks until a client makes a connection request to it.\n\nIf everything goes well, the server accepts the connection. Upon acceptance, the server gets a new socket, clientSocket, bound to the same local port, 6666, and also has its remote endpoint set to the address and port of the client.\n\nAt this point, the new Socket object puts the server in direct connection with the client. We can then access the output and input streams to write and receive messages to and from the client respectively:\n\nNow the server is capable of exchanging messages with the client endlessly until the socket is closed with its streams.\n\nHowever, in our example, the server can only send a greeting response before it closes the connection. This means that if we ran our test again, the server would refuse the connection.\n\nTo allow continuity in communication, we’ll have to read from the input stream inside a while loop, and only exit when the client sends a termination request. We’ll see this in action in the following section.\n\nFor every new client, the server needs a new socket returned by the accept call. We use the serverSocket to continue to listen for connection requests, while tending to the needs of the connected clients. We haven’t yet allowed for this in our first example.\n\nThe client must know the hostname or IP of the machine on which the server is running, and the port number on which the server is listening.\n\nTo make a connection request, the client tries to rendezvous with the server on the server’s machine and port:\n\nThe client also needs to identify itself to the server, so it binds to a local port number assigned by the system that it’ll use during this connection. We don’t deal with this ourselves.\n\nThe above constructor only creates a new socket when the server has accepted the connection; otherwise, we’ll get a connection refused exception. When successfully created, we can then obtain input and output streams from it to communicate with the server:\n\nThe input stream of the client is connected to the output stream of the server, just like the input stream of the server is connected to the output stream of the client.\n\nOur current server blocks until a client connects to it, and then blocks again to listen to a message from the client. After the single message, it closes the connection because we haven’t dealt with continuity.\n\nAs such, it’s only helpful in ping requests. But imagine that we’d like to implement a chat server; continuous back and forth communication between the server and client would definitely be required.\n\nWe’ll have to create a while loop to continuously observe the input stream of the server for incoming messages.\n\nSo let’s create a new server called EchoServer.java, whose sole purpose is to echo back whatever messages it receives from clients:\n\nNotice that we added a termination condition, where the while loop exits when we receive a period character.\n\nWe’ll start EchoServer using the main method, just as we did for the GreetServer. This time, we start it on another port, such as 4444, to avoid confusion.\n\nThe EchoClient is similar to GreetClient, so we can duplicate the code. We’re separating them for clarity.\n\nIn a different test class, we’ll create a test to show that multiple requests to the EchoServer will be served without the server closing the socket. This is true as long as we’re sending requests from the same client.\n\nDealing with multiple clients is a different case, which we’ll see in a subsequent section.\n\nNow let’s create a setup method to initiate a connection with the server:\n\nWe’ll also create a tearDown method to release all our resources. This is best practice for every case where we use network resources:\n\nThen we’ll test our echo server with a few requests:\n\nThis is an improvement over the initial example, where we’d only communicate once before the server closed our connection. Now we send a termination signal to tell the server when we’re done with the session.\n\nAs much as the previous example was an improvement over the first one, it’s still not a great solution. A server must have the capacity to service many clients and many requests simultaneously.\n\nHandling multiple clients is what we’re going to cover in this section.\n\nAnother feature we’ll see here is that the same client could disconnect and reconnect again, without getting a connection refused exception or a connection reset on the server. We weren’t previously able to do this.\n\nThis means that our server is going to be more robust and resilient across multiple requests from multiple clients.\n\nWe’ll do this by creating a new socket for every new client and service that client’s request on a different thread. The number of clients being served simultaneously will equal the number of threads running.\n\nThe main thread will be running a while loop as it listens for new connections.\n\nNow let’s see this in action. We’ll create another server called EchoMultiServer.java. Inside it, we’ll create a handler thread class to manage each client’s communications on its socket:\n\nNotice that we now call accept inside a while loop. Every time the while loop is executed, it blocks on the accept call until a new client connects. Then the handler thread, EchoClientHandler, is created for this client.\n\nWhat happens inside the thread is the same as the EchoServer, where we handled only a single client. The EchoMultiServer delegates this work to EchoClientHandler so that it can keep listening for more clients in the while loop.\n\nWe’ll still use EchoClient to test the server. This time, we’ll create multiple clients each sending and receiving multiple messages from the server.\n\nLet’s start our server using its main method on port 5555.\n\nFor clarity, we’ll still put tests in a new suite:\n\nWe could create as many of these test cases as we please, each spawning a new client, and the server will serve them all.\n\nIn this article, we focused on an introduction to sockets programming over TCP/IP, and wrote a simple Client/Server application in Java."
    },
    {
        "link": "http://jcodec.org",
        "document": "JCodec is a library implementing a set of popular video and audio codecs. Currently JCodec supports:\n\nThose are just some of the things JCodec dev team is planning to work on:\n\nJCodec can be used in both standard Java and Android. It contains platform-agnostic java classes. To use the latest version of JCodec add the maven dependency as below:\n\nOR gradle dependency as below:\n\nAdditionally if you want to use JCodec with AWT images (BufferedImage) add this maven dependency:\n\nOR if you want to use JCodec with Android images (Bitmap) add this gradle dependency:\n\nFor the latest and greatest (the 0.2.3-SNAPSHOT) clone this Git project and build locally like so:\n\nIf you JUST need the jars, download them from here:\n\nThere is virtually no documentation right now but the plan is to catch up on this so stay tuned. stackoverflow.com contains quite a bit information at this point.\n\nAlso check the 'samples' subfolder. It's a maven project, and it contains some code samples for the popular use-cases:\n\nBecause JCodec is a pure Java implementation please adjust your performance expectations accordingly. We usually make the best effort to write efficient code but despite this the decoding will typically be an order of magnitude slower than the native implementations (such as FFMpeg). We are currently looking into implementing performance-critical parts in OpenCL (or RenderScript for Android) but the ETA is unknown.\n\nExpect the encoded quality/bitrate for h.264 (AVC) to be so much worse compared to the well known native encoders (such as x264). This is because very little work has been put so far into developing the encoder and also because encoders usually trade speed for quality, speed is something we don't have in Java, hence the quality. Again we may potentially fix that in the future by introducing OpenCL (RenderScript) code but at this point it's an unknown.\n\nThat said the decode quality should be at the industry level. This is because the decoding process is usually specified by the standard and the correct decoder implementations are expected to produce bit-exact outputs.\n\nGetting a single frame from a movie ( supports only AVC, H.264 in MP4, ISO BMF, Quicktime container ):\n\nGet all frames from a video file\n\nGetting a sequence of frames from a movie ( supports only AVC, H.264 in MP4, ISO BMF, Quicktime container ):\n\nMaking a video with a set of images from memory:\n\nFeel free to communicate any questions or concerns to us. Dev team email: jcodecproject@gmail.com"
    },
    {
        "link": "https://github.com/jcodec/jcodec",
        "document": "JCodec is a library implementing a set of popular video and audio codecs. Currently JCodec supports:\n\nThose are just some of the things JCodec dev team is planning to work on:\n\nJCodec can be used in both standard Java and Android. It contains platform-agnostic java classes. To use the latest version of JCodec add the maven dependency as below:\n\nOR gradle dependency as below:\n\nAdditionally if you want to use JCodec with AWT images (BufferedImage) add this maven dependency:\n\nOR if you want to use JCodec with Android images (Bitmap) add this gradle dependency:\n\nFor the latest and greatest (the 0.2.6-SNAPSHOT) clone this Git project and build locally like so:\n\nIf you JUST need the jars, download them from here:\n\nThere is virtually no documentation right now but the plan is to catch up on this so stay tuned. stackoverflow.com contains quite a bit information at this point.\n\nAlso check the 'samples' subfolder. It's a maven project, and it contains some code samples for the popular use-cases:\n\nBecause JCodec is a pure Java implementation please adjust your performance expectations accordingly. We usually make the best effort to write efficient code but despite this the decoding will typically be an order of magnitude slower than the native implementations (such as FFMpeg). We are currently looking into implementing performance-critical parts in OpenCL (or RenderScript for Android) but the ETA is unknown.\n\nExpect the encoded quality/bitrate for h.264 (AVC) to be so much worse compared to the well known native encoders (such as x264). This is because very little work has been put so far into developing the encoder and also because encoders usually trade speed for quality, speed is something we don't have in Java, hence the quality. Again we may potentially fix that in the future by introducing OpenCL (RenderScript) code but at this point it's an unknown.\n\nThat said the decode quality should be at the industry level. This is because the decoding process is usually specified by the standard and the correct decoder implementations are expected to produce bit-exact outputs.\n\nMaking a video with a set of images from memory:\n\nSome editors (e.g. Final Cut Pro 7) employ a clever hack to support multiple versions of metadata for mp4 files. The trick is to append a new version of atom to end of file and set previous version atom name to . Jcodec supports this hack via\n\nSee for complete usage example.\n\nTo list available versions use\n\nFeel free to communicate any questions or concerns to us. Dev team email: jcodecproject@gmail.com"
    },
    {
        "link": "https://stackoverflow.com/questions/56829683/jcodec-simple-h264-encode-decode",
        "document": "Ok, so trying to get my head around jcodec. Basically, I want to record what's on the screen as BufferedImages, encode the buffered images as H264 frames and then decode them and convert them back to buffered image.\n\nThis is the code I have, the ScreenRecorder class extends thread and basically captures the screen in a while true loop. That part works. Then, it seems that encoding the BufferedImage from ScreenRecorder as a H264 frame works too but then when i try to decode it I get an AIOBE\n\nJust trying to figure out how jcodec works. Any ideas as to what i am doing wrong? Any help would be appreciated"
    },
    {
        "link": "https://github.com/jcodec/jcodec/blob/master/README.md",
        "document": "JCodec is a library implementing a set of popular video and audio codecs. Currently JCodec supports:\n\nThose are just some of the things JCodec dev team is planning to work on:\n\nJCodec can be used in both standard Java and Android. It contains platform-agnostic java classes. To use the latest version of JCodec add the maven dependency as below:\n\nOR gradle dependency as below:\n\nAdditionally if you want to use JCodec with AWT images (BufferedImage) add this maven dependency:\n\nOR if you want to use JCodec with Android images (Bitmap) add this gradle dependency:\n\nFor the latest and greatest (the 0.2.6-SNAPSHOT) clone this Git project and build locally like so:\n\nIf you JUST need the jars, download them from here:\n\nThere is virtually no documentation right now but the plan is to catch up on this so stay tuned. stackoverflow.com contains quite a bit information at this point.\n\nAlso check the 'samples' subfolder. It's a maven project, and it contains some code samples for the popular use-cases:\n\nBecause JCodec is a pure Java implementation please adjust your performance expectations accordingly. We usually make the best effort to write efficient code but despite this the decoding will typically be an order of magnitude slower than the native implementations (such as FFMpeg). We are currently looking into implementing performance-critical parts in OpenCL (or RenderScript for Android) but the ETA is unknown.\n\nExpect the encoded quality/bitrate for h.264 (AVC) to be so much worse compared to the well known native encoders (such as x264). This is because very little work has been put so far into developing the encoder and also because encoders usually trade speed for quality, speed is something we don't have in Java, hence the quality. Again we may potentially fix that in the future by introducing OpenCL (RenderScript) code but at this point it's an unknown.\n\nThat said the decode quality should be at the industry level. This is because the decoding process is usually specified by the standard and the correct decoder implementations are expected to produce bit-exact outputs.\n\nMaking a video with a set of images from memory:\n\nSome editors (e.g. Final Cut Pro 7) employ a clever hack to support multiple versions of metadata for mp4 files. The trick is to append a new version of atom to end of file and set previous version atom name to . Jcodec supports this hack via\n\nSee for complete usage example.\n\nTo list available versions use\n\nFeel free to communicate any questions or concerns to us. Dev team email: jcodecproject@gmail.com"
    },
    {
        "link": "https://stackoverflow.com/questions/73179426/decode-h264-video-to-java-awt-image-bufferedimage-in-java",
        "document": "I am trying to make an AirPlay server in java with this library. I am able to start the server and connect to it and I am getting video input, however the input is in h264 format and I tried decoding it with JCodec but it always says I need an sps/pps and I don't know how to create/find this with just a byte[]. This is the onVideo method which is pretty much just copy-pasted from some websites:\n\nEdit: I've uploaded a (\"working\") version to github, but the decoded image is discolored and doesn't update all pixels so when something is on the screen and the frame changes, that something can still be on the image."
    }
]