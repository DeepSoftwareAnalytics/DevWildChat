[
    {
        "link": "https://stackoverflow.com/questions/70694382/how-to-memoize-useselector-value-so-that-re-render-is-prevented-on-any-state-cha",
        "document": "I am using callback to memoize part of component which uses useSelector value. But another state variable is changing withing the component as I am taking input, which is triggering another re render of comp, thereby useselector is getting called again and re rendering the part where I have used useCallback as selector value is there as a dependency. How can I memorize useSelector value so that any state change change within the component does not trigger selector update unless dispatch gets called somewhere and updates the state.\n\nchat is the selector value and message is the state for input tag.\n\nI decided to set aside chat selector value inside of useCallback to prevent re render on input state change ie \"message\" but re rendering is happening"
    },
    {
        "link": "https://medium.com/@ztolley/react-re-render-optimisation-d16ba64754a5",
        "document": "Why does my React component keep re-rendering?\n\nIt’s a common question and when I Googled it I found plenty of articles and videos on the subject. One thing that was mentioned was “That’s what React is meant to do”. React will re-render your component ‘just in case’ and then compare the rendered output with the DOM and update only if needed. I’m from a generation of developers that had limited CPU resources and lived by the phrases “Don’t do something unless you have to” and “Why compute something 100 times if you only need to compute it once?”. I can see why React it does it though, how does React know if it should re-render?\n\nI’m working on a complex React app that has a constant stream of data and results in a lot of unnecessary re-rendering. The UI remains responsive and CPU is happy but there are some user interactions that don’t quite work as they should and debugging is made harder when the code is called unnecessarily. I also find that sometimes React gets it wrong and updates the DOM when it doesn’t need to.\n\nI was never 100% sure what caused a re-render. In theory it’s simple and yet I found components re-rendering and couldn’t understand why. I wanted to fully understand it with a practical example in isolation, that way it is easier to understand what is going on and test optimisations. The resulting experiment can be found here: https://idyllic-otter-27b62e.netlify.app/ . If you go to that page, open the dev tools to display the console. Each component logs its renders so you an see what is going on. The page demonstrates a mixture of , , and to optimise when a component renders and when it doesn’t.\n\nWhen it comes to rendering the fundamental rule is:\n\nThat last one is a big deal and is demonstrated in the test page. When the user changes the top level counter the component re-renders along with the ‘Normal Child’ component. In a large application this means if the top level component re-renders then the app is potentially doing a lot of unnecessary work.\n\nThere are steps you can take to improve things. In the test page there is no need to re-render the ‘Normal Child’ as it will just produce the same output. React supports the idea of ‘Memoization’, this tells React to only call the function/component when it’s dependencies change. If no dependencies are listed, it will only run once and the result is cached. Unlike some memo libraries the result is not cached for all calls and keyed by input, but it will still reduce repetitive calls.\n\nIn the test page when the counter is updated then the ‘Memo Child’ component doesn’t re-render. But what if that child has it’s own state? Good news, it still works. ‘Memo With Child’ doesn’t re-render when the parent component does but if you change its internal state then it will. If your child component needs to make changes to parent then that works too. So the child component in the page updates the parent counter but does not re-render itself.\n\nIf you have a component that takes a prop from the parent and memoizes that, as shown in ‘Memo Child With Prop’, that will only render when the prop changes or when it’s own state changes. It also, through the magic of hooks, maintains it’s state when the parent changes.\n\nReact applications get complex real fast and before you know it you have a piece of data high up in the hierarchy that something lower down needs to use or separate branches need to use. You can pass that data down via props, known as ‘prop drilling’ which results in code that cannot be easily used and difficult to debug and manage. Alternatively you can use a ‘Context’. Contexts let you create a store/provider high up in the tree and access it from a component lower down.\n\nA side effect of using context is that the components between the parent and destination don’t use the context properties so won’t re-render when its values change. In the test page the ‘Clock Grand Child’ components display a context value.\n\nThere are a few things to watch out for:\n\nWhen you select values from the context no matter how few you select, if anything changes in the context it will cause that component to re-render:\n\nIn this example component if the context description property changes the the component will re-render, even though it only uses title.\n\nAnother side effect is that if you create the store and context in the parent component, and that store changes, it triggers the parent and children to re-render. In a large app this can be very costly. A good pattern to follow is to ‘lift’ the state to a component above the app. What does this actually mean in practice? Well the best way to demonstrate this is in code.\n\nIf you can’t stop the component re-rendering, such as in response to changes to the context, and/or the component is non-trivial then consider wrapping compute heavy parts in a function. Like the other React memo this will tell React to only calculate a value once or when it’s dependencies change.\n\nAlternatively pass those pieces of data into a child component that has been memoized or wrap part of the component render in .\n\nOne gotcha that can still trigger a render in a memoised component occurs when you pass a function from the parent to child. The function defined in the parent will be re-defined on each render, so the reference to a function will change every time.\n\nTo avoid this you can make use of . This will create a reference to the function that remains constant for each render.\n\nThe good news is that methods generated by don’t need to be wrapped like this, and they also have the added bonus that they can provide the current state.\n\nDon’t forget, if your call-back function relies on a property, you must include that as a dependency as the function will only have a snapshot of that value when the call-back was created.\n\nWith small contexts or parents it may not be worth the extra work and complexity these approaches involve.\n\nReact will re-render components when it doesn’t really need to and spend compute cycles deciding if the output should be used or thrown. With a clear understanding of how React decides when the render and a few simple patterns, it is possible to avoid uneccsary re-rendering though this comes at a cost and sometimes and added complexity or overhead can cancel out any benefits.\n\nThere is another thing to consider that I’ll look at in a follow up article. It is good practice to measure your performance before and after any optimisations to judge if they are needed and/or effective. Never optimise blind, you may make things worse. I will look at the React developer tools and how they can help with this."
    },
    {
        "link": "https://stackoverflow.com/questions/56551433/useselector-with-react-memo-vs-connect",
        "document": "Well, first, interesting enough although React.memo is a HOC it does not create the same nesting as connect does. I have created a test code:\n\nAnd here is the structure rendered:\n\nWe can see that a content for connect is rendered deeper.\n\nSecond, the docs say:\n\nby default useSelector() will do a reference equality comparison of the selected value when running the selector function after an action is dispatched, and will only cause the component to re-render if the selected value changed. However, unlike connect(), useSelector() does not prevent the component from re-rendering due to its parent re-rendering, even if the component's props did not change.\n\nthat means the component which useSelector will not be re-rendered when unrelated parts of the store change. And this is the most important part of the optimization. Whether optimizing with React.memo or not is now completely depends on your decision and in most cases, it simply is not needed. We use React.memo only in cases when the component is very expensive to render.\n\nTo summarize, connect wrapper was required to connect to the store. With useSelector we do not have to wrap anymore. We still need to wrap with React.memo in rare cases when we need to optimize some heavy components. The work of React.memo was also done by connect but in most cases, it was premature optimization."
    },
    {
        "link": "https://geeksforgeeks.org/methods-to-optimize-the-re-render-in-react-redux-connected-component",
        "document": "For a smooth user experience, fast rendering in React applications is crucial. Using React-Redux can sometimes lead to performance issues due to unnecessary re-renders of connected components. This article will explore several methods to avoid the rendering of these components. By implementing these techniques, you can enhance the efficiency and performance of your React-Redux applications, ensuring they run smoothly and responsively.\n\nThese are the following approaches to optimize the rendering of connected components in React-Redux:\n\n'React.memo' is a HOC(high-order component) used to memoize the functional components so that re-render may be blocked for them if props are same. Using 'React.memo', you can make sure that a functional component is rendered only when its props change. This lowers the rendering overhead for components with no changed props.\n\nThe 'useSelector' hook helps you extracts data from the Redux store, whereas 'useDispatch' allows you to dispatch actions. This can enable to subscribe only when parts of the state changes, so that unnecessary re-renders are minimized.\n\nDividing the state into smaller, more manageable views can improve performance by decreasing the number of components that need to re-render whenever a portion of the state is changed. By splitting the state, you can separate the state changes impact such that only the necessary components are re-render.\n\nThe 'reselect' library is useful for creating memoized selectors that recalculate only when the values of the inputs change. Memoized selectors minimize unnecessary computations done thus speeding up component rendering.\n\nWhen we pass anonymous functions or objects to other components using props in React, this can potentially lead to some unnecessary re-renders because each new reference is treated as a different entity each time it changes its host component's state. This is not so with named functions and constants whose values remain the same even after their references are updated in other parts of code.\n\nStep to Optimize the re-render in react-redux connected component\n\nExample: Set up a Redux store, create actions and reducers for 'prop1' and 'prop2', connect a memoized component to display them, and wrap it in the Redux provider in the main app.\n\nOutput: Below is a demonstration showing the initial rendered 'MyComponent' displaying 'prop1' and 'prop2' values from the Redux store, and how the component re-renders when these values are changed. If the values of 'prop1' and 'prop2' in the Redux store do not change, 'MyComponent' will not re-render, demonstrating the efficiency of using 'React.memo'."
    },
    {
        "link": "https://reddit.com/r/reactjs/comments/1he2p71/how_does_useselector_hook_trigger_a_component",
        "document": "\n• the state changes (using useState Hook)\n• if the props of the component changes.\n\nBut I'm genuinely curious as to how useSelector listens to a state slice change in the store and how exactly does React trigger a re-render based on the state slice change? Like where's the connection between these two (useSelector and react rendering trigger)? . Does it use useState internally? Or something else.\n\nWould be really grateful if I get an explanation."
    },
    {
        "link": "https://redux-toolkit.js.org/api/createSlice",
        "document": "A function that accepts an initial state, an object of reducer functions, and a \"slice name\", and automatically generates action creators and action types that correspond to the reducers and state.\n\nThis API is the standard approach for writing Redux logic.\n\nInternally, it uses and , so you may also use Immer to write \"mutating\" immutable updates:\n\naccepts a single configuration object parameter, with the following options:\n\nThe initial state value for this slice of state.\n\nThis may also be a \"lazy initializer\" function, which should return an initial state value when called. This will be used whenever the reducer is called with as its state value, and is primarily useful for cases like reading initial state from .\n\nA string name for this slice of state. Generated action type constants will use this as a prefix.\n\nAn object containing Redux \"case reducer\" functions (functions intended to handle a specific action type, equivalent to a single case statement in a switch).\n\nThe keys in the object will be used to generate string action type constants, and these will show up in the Redux DevTools Extension when they are dispatched. Also, if any other part of the application happens to dispatch an action with the exact same type string, the corresponding reducer will be run. Therefore, you should give the functions descriptive names.\n\nThis object will be passed to , so the reducers may safely \"mutate\" the state they are given.\n\nIf you need to customize the creation of the payload value of an action creator by means of a , the value of the appropriate field of the argument object should be an object instead of a function. This object must contain two properties: and . The value of the field should be the case reducer function while the value of the field should be the prepare callback function:\n\nAlternatively, the field can be a callback which receives a \"create\" object.\n\nThe main benefit of this is that you can create async thunks as part of your slice (though for bundle size reasons, you need a bit of setup for this). Types are also slightly simplified for prepared reducers.\n• reducer The slice case reducer to use.\n• reducer The slice case reducer to use.\n\nThe action passed to the case reducer will be inferred from the prepare callback's return.\n\nCreates an async thunk instead of an action creator.\n\nThe configuration object can contain case reducers for each of the lifecycle actions ( , , and ), as well as a reducer that will run for both fulfilled and rejected actions (note that this will run after any provided / reducers. Conceptually it can be thought of like a block.).\n\nEach case reducer will be attached to the slice's object, e.g. .\n\nThe configuration object can also contain .\n\nConceptually, each slice reducer \"owns\" its slice of state. There's also a natural correspondence between the update logic defined inside , and the action types that are generated based on those.\n\nHowever, there are many times that a Redux slice may also need to update its own state in response to action types that were defined elsewhere in the application (such as clearing many different kinds of data when a \"user logged out\" action is dispatched). This can include action types defined by another call, actions generated by a , RTK Query endpoint matchers, or any other action. In addition, one of the key concepts of Redux is that many slice reducers can independently respond to the same action type.\n\nallows to respond and update its own state in response to other action types besides the types it has generated.\n\nAs with the field, each case reducer in is wrapped in Immer and may use \"mutating\" syntax to safely update the state inside.\n\nHowever, unlike the field, each individual case reducer inside of will not generate a new action type or action creator.\n\nIf two fields from and happen to end up with the same action type string, the function from will be used to handle that action type.\n\nSimilar to , the field uses a \"builder callback\" notation to define handlers for specific action types, matching against a range of actions, or handling a default case. This is conceptually similar to a switch statement, but with better TS support as it can infer the action type from the provided action creator. It's particularly useful for working with actions produced by and .\n\nSee the \"Builder Callback Notation\" section of the reference for details on how to use , , and\n\nIndicates a preference of where the slice should be located. Defaults to .\n\nThis is used by and the default generated .\n\nA set of selectors that receive the slice state as their first parameter, and any other parameters.\n\nEach selector will have a corresponding key in the resulting object.\n\nwill return an object that looks like:\n\nEach function defined in the argument will have a corresponding action creator generated using and included in the result's field using the same function name.\n\nThe generated function is suitable for passing to the Redux function as a \"slice reducer\".\n\nYou may want to consider destructuring the action creators and exporting them individually, for ease of searching for references in a larger codebase.\n\nThe functions passed to the parameter can be accessed through the return field. This can be particularly useful for testing or direct access to reducers created inline.\n\nResult's function provides access to the initial state value given to the slice. If a lazy state initializer was provided, it will be called and a fresh value returned.\n\ncreates an instance of the slice that is aware it's been injected - see .\n\nSlice selectors are written to expect the slice's state as their first parameter, but the slice may be located anywhere inside the store's root state.\n\nAs a result, there are two ways of getting final selectors:\n\nMost commonly, the slice is reliably mounted under its .\n\nFollowing this, the slice has a selector attached, which assumes that the slice is located under .\n\nthen uses this selector to wrap each of the selectors provided.\n\nis called with a single parameter, a callback. This function should receive the store root state (or whatever you expect to call the resulting selectors with) and return the slice state.\n\nIf no callback is passed, selectors will be returned as is - expecting the slice state as their first parameter (the same as calling )."
    },
    {
        "link": "https://redux-toolkit.js.org/usage/usage-guide",
        "document": "The Redux core library is deliberately unopinionated. It lets you decide how you want to handle everything, like store setup, what your state contains, and how you want to build your reducers.\n\nThis is good in some cases, because it gives you flexibility, but that flexibility isn't always needed. Sometimes we just want the simplest possible way to get started, with some good default behavior out of the box. Or, maybe you're writing a larger application and finding yourself writing some similar code, and you'd like to cut down on how much of that code you have to write by hand.\n\nAs described in the Quick Start page, the goal of Redux Toolkit is to help simplify common Redux use cases. It is not intended to be a complete solution for everything you might want to do with Redux, but it should make a lot of the Redux-related code you need to write a lot simpler (or in some cases, eliminate some of the hand-written code entirely).\n\nRedux Toolkit exports several individual functions that you can use in your application, and adds dependencies on some other packages that are commonly used with Redux (like Reselect and Redux-Thunk). This lets you decide how to use these in your own application, whether it be a brand new project or updating a large existing app.\n\nLet's look at some of the ways that Redux Toolkit can help make your Redux-related code better.\n\nEvery Redux app needs to configure and create a Redux store. This usually involves several steps:\n• Setting up middleware, likely including at least one middleware to handle asynchronous logic\n• Possibly altering some of the logic based on whether the application is being built for development or production\n\nThe following example from the Configuring Your Store page in the Redux docs shows a typical store setup process:\n\nThis example is readable, but the process isn't always straightforward:\n• The basic Redux function takes positional arguments: . Sometimes it's easy to forget which parameter is which.\n• The process of setting up middleware and enhancers can be confusing, especially if you're trying to add several pieces of configuration.\n• The Redux DevTools Extension docs initially suggest using some hand-written code that checks the global namespace to see if the extension is available. Many users copy and paste those snippets, which make the setup code harder to read.\n\nhelps with those issues by:\n• Having an options object with \"named\" parameters, which can be easier to read\n• Letting you provide arrays of middleware and enhancers you want to add to the store, and calling and for you automatically\n\nIn addition, adds some middleware by default, each with a specific goal:\n• is the most commonly used middleware for working with both synchronous and async logic outside of components\n• In development, middleware that check for common mistakes like mutating the state or using non-serializable values.\n\nThis means the store setup code itself is a bit shorter and easier to read, and also that you get good default behavior out of the box.\n\nThe simplest way to use it is to just pass the root reducer function as a parameter named :\n\nYou can also pass an object full of \"slice reducers\", and will call for you:\n\nNote that this only works for one level of reducers. If you want to nest reducers, you'll need to call yourself to handle the nesting.\n\nIf you need to customize the store setup, you can pass additional options. Here's what the hot reloading example might look like using Redux Toolkit:\n\nIf you provide the argument, will only use whatever middleware you've listed. If you want to have some custom middleware and the defaults all together, you can use the callback notation, call and include the results in the array you return.\n\nReducers are the most important Redux concept. A typical reducer function needs to:\n• Look at the field of the action object to see how it should respond\n• Update its state immutably, by making copies of the parts of the state that need to change and only modifying those copies\n\nWhile you can use any conditional logic you want in a reducer, the most common approach is a statement, because it's a straightforward way to handle multiple possible values for a single field. However, many people don't like switch statements. The Redux docs show an example of writing a function that acts as a lookup table based on action types, but leave it up to users to customize that function themselves.\n\nThe other common pain points around writing reducers have to do with updating state immutably. JavaScript is a mutable language, updating nested immutable data by hand is hard, and it's easy to make mistakes.\n\nSince the \"lookup table\" approach is popular, Redux Toolkit includes a function similar to the one shown in the Redux docs. However, our utility has some special \"magic\" that makes it even better. It uses the Immer library internally, which lets you write code that \"mutates\" some data, but actually applies the updates immutably. This makes it effectively impossible to accidentally mutate state in a reducer.\n\nIn general, any Redux reducer that uses a statement can be converted to use directly. Each in the switch becomes a key in the object passed to . Immutable update logic, like spreading objects or copying arrays, can probably be converted to direct \"mutation\". It's also fine to keep the immutable updates as-is and return the updated copies, too.\n\nHere's some examples of how you can use . We'll start with a typical \"todo list\" reducer that uses switch statements and immutable updates:\n\nNotice that we specifically call to return a copied array with the new todo entry, to return a copied array for the toggle case, and use the object spread operator to make a copy of the todo that needs to be updated.\n\nWith , we can shorten that example considerably:\n\nThe ability to \"mutate\" the state is especially helpful when trying to update deeply nested state. This complex and painful code:\n\nCan be simplified down to just:\n\nWhile the Redux Toolkit function can be really helpful, keep in mind that:\n• The \"mutative\" code only works correctly inside of our function\n• Immer won't let you mix \"mutating\" the draft state and also returning a new state value\n\nSee the API reference for more details.\n\nRedux encourages you to write \"action creator\" functions that encapsulate the process of creating an action object. While this is not strictly required, it's a standard part of Redux usage.\n\nMost action creators are very simple. They take some parameters, and return an action object with a specific field and the parameters inside the action. These parameters are typically put in a field called , which is part of the Flux Standard Action convention for organizing the contents of action objects. A typical action creator might look like:\n\nWriting action creators by hand can get tedious. Redux Toolkit provides a function called , which simply generates an action creator that uses the given action type, and turns its argument into the field:\n\nalso accepts a \"prepare callback\" argument, which allows you to customize the resulting field and optionally add a field. See the API reference for details on defining action creators with a prepare callback.\n\nRedux reducers need to look for specific action types to determine how they should update their state. Normally, this is done by defining action type strings and action creator functions separately. Redux Toolkit function make this easier, by defining the action type as a field on the action creator.\n\nThis means you don't have to write or use a separate action type variable, or repeat the name and value of an action type like .\n\nIf you want to use one of these action creators in a switch statement, you need to reference yourself:\n\nRedux state is typically organized into \"slices\", defined by the reducers that are passed to :\n\nIn this example, both and would be considered \"slices\". Both of the reducers:\n• \"Own\" a piece of state, including what the initial value is\n• Define how that state is updated\n\nThe common approach is to define a slice's reducer function in its own file, and the action creators in a second file. Because both functions need to refer to the same action types, those are usually defined in a third file and imported in both places:\n\nThe only truly necessary part here is the reducer itself. Consider the other parts:\n• We could have written the action types as inline strings in both places\n• The action creators are good, but they're not required to use Redux - a component could skip supplying a argument to , and just call itself\n• The only reason we're even writing multiple files is because it's common to separate code by what it does\n\nThe \"ducks\" file structure proposes putting all of your Redux-related logic for a given slice into a single file, like this:\n\nThat simplifies things because we don't need to have multiple files, and we can remove the redundant imports of the action type constants. But, we still have to write the action types and the action creators by hand.\n\nIn modern JavaScript, there are several legal ways to define both keys and functions in an object (and this isn't specific to Redux), and you can mix and match different key definitions and function definitions. For example, these are all legal ways to define a function inside an object:\n\nUsing the \"object literal function shorthand\" is probably the shortest code, but feel free to use whichever of those approaches you want.\n\nTo simplify this process, Redux Toolkit includes a function that will auto-generate the action types and action creators for you, based on the names of the reducer functions you provide.\n\nHere's how that posts example would look with :\n\nlooked at all of the functions that were defined in the field, and for every \"case reducer\" function provided, generates an action creator that uses the name of the reducer as the action type itself. So, the reducer became an action type of , and the action creator will return an action with that type.\n\nMost of the time, you'll want to define a slice, and export its action creators and reducers. The recommended way to do this is using ES6 destructuring and export syntax:\n\nYou could also just export the slice object itself directly if you prefer.\n\nSlices defined this way are very similar in concept to the \"Redux Ducks\" pattern for defining and exporting action creators and reducers. However, there are a couple potential downsides to be aware of when importing and exporting slices.\n\nFirst, Redux action types are not meant to be exclusive to a single slice. Conceptually, each slice reducer \"owns\" its own piece of the Redux state, but it should be able to listen to any action type and update its state appropriately. For example, many different slices might want to respond to a \"user logged out\" action by clearing data or resetting back to initial state values. Keep that in mind as you design your state shape and create your slices.\n\nSecond, JS modules can have \"circular reference\" problems if two modules try to import each other. This can result in imports being undefined, which will likely break the code that needs that import. Specifically in the case of \"ducks\" or slices, this can occur if slices defined in two different files both want to respond to actions defined in the other file.\n\nThis CodeSandbox example demonstrates the problem:\n\nIf you encounter this, you may need to restructure your code in a way that avoids the circular references. This will usually require extracting shared code to a separate common file that both modules can import and use. In this case, you might define some common action types in a separate file using , import those action creators into each slice file, and handle them using the argument.\n\nThe article How to fix circular dependency issues in JS has additional info and examples that can help with this issue.\n\nBy itself, a Redux store doesn't know anything about async logic. It only knows how to synchronously dispatch actions, update the state by calling the root reducer function, and notify the UI that something has changed. Any asynchronicity has to happen outside the store.\n\nBut, what if you want to have async logic interact with the store by dispatching or checking the current store state? That's where Redux middleware come in. They extend the store, and allow you to:\n• Execute extra logic when any action is dispatched (such as logging the action and state)\n• Write extra code that has access to and\n• Teach how to accept other values besides plain action objects, such as functions and promises, by intercepting them and dispatching real action objects instead\n\nThe most common reason to use middleware is to allow different kinds of async logic to interact with the store. This allows you to write code that can dispatch actions and check the store state, while keeping that logic separate from your UI.\n\nThere are many kinds of async middleware for Redux, and each lets you write your logic using different syntax. The most common async middleware are:\n• , which lets you write plain functions that may contain async logic directly\n• , which uses generator functions that return descriptions of behavior so they can be executed by the middleware\n• , which uses the RxJS observable library to create chains of functions that process actions\n\nEach of these libraries has different use cases and tradeoffs.\n\nIf you do need to write data fetching logic yourself, we recommend using the Redux Thunk middleware as the standard approach, as it is sufficient for most typical use cases (such as basic AJAX data fetching). In addition, use of the syntax in thunks makes them easier to read.\n\nThe Redux Toolkit function automatically sets up the thunk middleware by default, so you can immediately start writing thunks as part of your application code.\n\nRedux Toolkit does not currently provide any special APIs or syntax for writing thunk functions. In particular, they cannot be defined as part of a call. You have to write them separate from the reducer logic, exactly the same as with plain Redux code.\n\nMany Redux apps have structured their code using a \"folder-by-type\" approach. In that structure, thunk action creators are usually defined in an \"actions\" file, alongside the plain action creators.\n\nBecause we don't have separate \"actions\" files, it makes sense to write these thunks directly in our \"slice\" files. That way, they have access to the plain action creators from the slice, and it's easy to find where the thunk function lives.\n\nA typical slice file that includes thunks would look like this:\n• A \"start\" action is dispatched before the request to indicate that the request is in progress. This may be used to track loading state, to allow skipping duplicate requests, or show loading indicators in the UI.\n• Depending on the request result, the async logic dispatches either a \"success\" action containing the result data, or a \"failure\" action containing error details. The reducer logic clears the loading state in both cases, and either processes the result data from the success case, or stores the error value for potential display.\n\nThese steps are not required, but are recommended in the Redux tutorials as a suggested pattern.\n\nA typical implementation might look like:\n\nHowever, writing code using this approach is tedious. Each separate type of request needs repeated similar implementation:\n• Unique action types need to be defined for the three different cases\n• Each of those action types usually has a corresponding action creator function\n• A thunk has to be written that dispatches the correct actions in the right sequence\n\nabstracts this pattern by generating the action types and action creators and generating a thunk that dispatches those actions.\n\nAs a developer, you are probably most concerned with the actual logic needed to make an API request, what action type names show up in the Redux action history log, and how your reducers should process the fetched data. The repetitive details of defining the multiple action types and dispatching the actions in the right sequence aren't what matters.\n\nsimplifies this process - you only need to provide a string for the action type prefix and a payload creator callback that does the actual async logic and returns a promise with the result. In return, will give you a thunk that will take care of dispatching the right actions based on the promise you return, and action types that you can handle in your reducers:\n\nThe thunk action creator accepts a single argument, which will be passed as the first argument to your payload creator callback.\n\nThe payload creator will also receive a object containing the parameters that are normally passed to a standard Redux thunk function, as well as an auto-generated unique random request ID string and an object:\n\nYou can use any of these as needed inside the payload callback to determine what the final result should be.\n\nMost applications typically deal with data that is deeply nested or relational. The goal of normalizing data is to efficiently organize the data in your state. This is typically done by storing collections as objects with the key of an , while storing a sorted array of those . For a more in-depth explanation and further examples, there is a great reference in the Redux docs page on \"Normalizing State Shape\".\n\nNormalizing data doesn't require any special libraries. Here's a basic example of how you might normalize the response from a API request that returns data in the shape of , using some hand-written logic:\n\nAlthough we're capable of writing this code, it does become repetitive, especially if you're handling multiple types of data. In addition, this example only handles loading entries into the state, not updating them.\n\nis a popular existing library for normalizing data. You can use it on its own without Redux, but it is very commonly used with Redux. The typical usage is to format collections from an API response and then process them in your reducers.\n\nAs with the hand-written version, this doesn't handle adding additional entries into the state, or updating them later - it's just loading in everything that was received.\n\nRedux Toolkit's API provides a standardized way to store your data in a slice by taking a collection and putting it into the shape of . Along with this predefined state shape, it generates a set of reducer functions and selectors that know how to work with the data.\n\nYou can view the full code of this example usage on CodeSandbox\n\nIf you're already using or another normalization library, you could consider using it along with . To expand on the examples above, here is a demonstration of how we could use to format a payload, then leverage the utilities provides.\n\nBy default, the , , and CRUD methods expect an array of entities. However, they also allow you to pass in an object that is in the shape of as an alternative, which makes it easier to insert pre-normalized data.\n\nYou can view the full code of this example usage on CodeSandbox\n\nThe entity adapter provides a selector factory that generates the most common selectors for you. Taking the examples above, we can add selectors to our like this:\n\nYou could then use these selectors in a component like this:\n\nBy default, assumes that your data has unique IDs in an field. If your data set stores its ID in a different field, you can pass in a argument that returns the appropriate field.\n\nprovides a argument that you can leverage to sort the collection of in state. This can be very useful for when you want to guarantee a sort order and your data doesn't come presorted.\n\nOne of the core usage principles for Redux is that you should not put non-serializable values in state or actions.\n\nHowever, like most rules, there are exceptions. There may be occasions when you have to deal with actions that need to accept non-serializable data. This should be done very rarely and only if necessary, and these non-serializable payloads shouldn't ever make it into your application state through a reducer.\n\nThe serializability dev check middleware will automatically warn anytime it detects non-serializable values in your actions or state. We encourage you to leave this middleware active to help avoid accidentally making mistakes. However, if you do need to turnoff those warnings, you can customize the middleware by configuring it to ignore specific action types, or fields in actions and state:\n\nIf using Redux-Persist, you should specifically ignore all the action types it dispatches:\n\nAdditionally, you can purge any persisted state by adding an extra reducer to the specific slice that you would like to clear when calling persistor.purge(). This is especially helpful when you are looking to clear persisted state on a dispatched logout action.\n\nIt is also strongly recommended to blacklist any api(s) that you have configured with RTK Query. If the api slice reducer is not blacklisted, the api cache will be automatically persisted and restored which could leave you with phantom subscriptions from components that do not exist any more. Configuring this should look something like this:\n\nSee Redux Toolkit #121: How to use this with Redux-Persist? and Redux-Persist #988: non-serializable value error for further discussion.\n\nRRF includes timestamp values in most actions and state as of 3.x, but there are PRs that may improve that behavior as of 4.x.\n\nA possible configuration to work with that behavior could look like:"
    },
    {
        "link": "https://freecodecamp.org/news/use-redux-toolkit-to-manage-state-in-react-apps",
        "document": "State management is one of the most important things you'll deal with in front end development.\n\nYou can manage state in React in various ways. Some examples include using state in class components, using React hooks such as useState and useEffect hook, using the Context API, or using Redux.\n\nIn this article I will show you how to use the Redux toolkit for state management in React.\n• Basic knowledge of React (beginners are welcome) and JavaScript is required.\n• Have Node installed so you can download the package using .\n\nRedux Toolkit is a set of tools you can use for state management in React in place of Redux. The Redux team created it.\n\nRedux Toolkit offers a standardized approach to building Redux code and comes with libraries and tools that make it simpler to create scalable, maintainable, and effective Redux code.\n\nHow is it different from the old Redux?\n\nRedux toolkit is different from Redux in a few ways. First, it has less boilerplate code, and it has decent support. It also works best with functional components (unlike Redux which works best with class components).\n\nThere are various reasons why you should use Redux toolkit over Redux for state management:\n• You don't have to set up thunk manually in Redux toolkit as it comes with . This enables you to perform async operations.\n• Enhancing developer experience: Redux Toolkit includes a number of tools and utilities that can enhance the developer experience, such as the ability to use Redux DevTools out-of-the-box.\n• Redux hooks like useSelector and useDispatch make your code shorter and easier to read/write.\n• Improving performance: Redux Toolkit includes a built-in memoization feature that can help improve the performance of your Redux application by reducing unnecessary re-renders.\n\nIn summary, Redux Toolkit is a great choice for developers who want to simplify their Redux code and improve performance, while also enhancing the developer experience. It can be particularly useful in larger, more complex applications where managing state can become difficult.\n\nHow to Get Started with Redux Toolkit\n\nFor this project, you won't use to create your React app. Instead, you'll use Vite and React plugins. This is because CRA is no longer recommended by the React docs.\n\nTo create your app, run the code below in your terminal:\n\nNext, run the following commands in the terminal:\n\nTo make use of Redux Toolkit in your project, run the code below in your terminal:\n\nAfter the installation is complete, create a file named . Import from Redux Toolkit and then create an empty Redux store which will be exported like you can see in the code below:\n\nThis code creates a Redux store, and also automatically configures the Redux DevTools extension so that you can inspect the store while developing.\n\nHow to connect the Redux Store to React\n\nAfter you've created the store, you will have to wrap your with a which will be imported from react-redux. Also the store you created above will be passed in into the provider as a prop.\n\nAfter the store has been created, create a file . Then import from .\n\nA Redux slice is a concept introduced by Redux Toolkit that represents a self-contained piece of the Redux store that includes a reducer function, initial state, and action creators.\n\nSlices provide a way to organize and modularize Redux code, making it easier to manage and maintain as your application grows. You can think of slices as mini-Redux stores that handle a specific piece of state within your application.\n• Name, which is usually set to be a string.\n• Reducer, which contains actions that define how the state can be updated.\n\nCreating a state slice creates a more modular and maintainable architecture for your application, making it easier to reason about and update as your application grows.\n\nBy organizing your Redux code into slices, you can create a more modular and maintainable architecture for your application, making it easier to reason about and update as your application grows.\n\nAfter you create the slice, the reducers and the Redux actions inside the reducers are exported differently. This is because the slice created will need to be exported before it can be used inside the store.\n\nBy exporting the reducer from the slice, you can easily use it to configure your Redux store. It also makes it easy to test the reducer in isolation, without needing to set up a full Redux store. This can be useful for unit testing and ensuring that the reducer behaves as expected for each action it handles.\n\nHow to add the slice to the store\n\nThe exported from the slice is imported and added to the store you created earlier. This allows you to complete the configuration of the store.\n\nHow to use the state and actions in your React components.\n\nUp until now, you've just been going through the initial set up for Redux Toolkit, setting up the store and creating the reducer. Now you need to start making use of the state and actions in your app to achieve the desired functionality.\n\nYou will be using two hooks: and . Data are being read from the store through the hook while the actions are being dispatched using the hook.\n\nThe corresponding actions (increment, decrement, and incrementByAmount) are being imported from the file to be used by the .\n\nTake a look at the code below where the state is set to a variable using the hook and the actions is set to a variable using the . There are three buttons: the button, button, and button. An event was placed on each button which run the various action.\n\nWhen these buttons are clicked, two things happens:\n• The Redux action is dispatched to the store.\n• The slice reducer will see the action and then update the state.\n\nHere's the code that does all that:\n\nThis is exactly what you should get when you run your code:\n\nThis tutorial walked you through how you can make use of Redux toolkit in handling your state in React. You learned how to create a store using various hooks such as the useSelector and useDispatch hook to read data from the store.\n\nAt this point you should be confident enough to use the Redux toolkit for managing state in your React app."
    },
    {
        "link": "https://medium.com/@michal-worwag/redux-toolkit-a-modern-approach-to-state-management-in-react-applications-ccc93ad353f3",
        "document": "In some point of developing the application you will probably need global state shared between various components to avoid props drilling. And to do this we can use Redux Toolkit which simplify the traditional complex Redux setup.\n\nRedux is very powerful, but often required substantial boilerplate code and mutliple files to set up even simple state management solutions. We had to manually create action types, action creators and reducers. This approach was leading to repetitive code and potential inconsistencies. Redux Toolkit emerged as the official, opinionated solution to these challenges.\n\nRedux Toolkit provides for us several essential features that simplifies the development process:\n• CreateSlice: A function that enables writing reducers and actions in a more intuitive way\n\nFirst , we need to install and setup a new project with Redux Toolkit\n\nYou can install Redux DevTools extension to your browser debugging application’s state changes.\n\nIt can be used as a browser extension (for Chrome, Edge and Firefox), as a standalone app or as a React component integrated in the client app.\n\nYou can check it here: https://github.com/reduxjs/redux-devtools\n\nHere’s how to create a Redux store using Redux Toolkit. Let’s start with creating file It should looks like this:\n\nWe are importing here two key pieces:\n• — is a slice of our state that handles shopping cart functionality (we will create it later)\n\nNext, we create the store:\n\nThis is where things get interesting. The function creates a Redux store that’s pre-configured with good defaults. The object is like a map of our application’s state. Each key in the object becomes a “slice” of our state tree. In this case, we’re saying “there’s a piece of state called ‘cart’ that’s managed by ”. If we were too look at our state in Redux DevTools, we’d see a structure like:\n\nThe last two lines define TypeScript types for our store:\n\nuses TypeScript’s utility to automatically figure out the type of our entire state tree. It’s like saying “whatever type of data \n\n returns, that’s what is”. This is incredibly useful because now when we write code like:\n\nTypeScript knows exactly what shape the state object should have.\n\nAppDispatch captures the type of our store’s dispatch function. This is important because Redux Toolkit adds extra functionality to the basic dispatch function, like handling thunks (for async actions). by exporting this type , we can ensure our dispatched actionsare properly typed:\n\nTo put this in perspective , imagine you’re building a house. The store is like the foundation and framework, the reducers are like the different rooms (each managing its own space), and these TypeScript types are like the blueprint that ensures everything fits together correctly.\n\nIn main file of our app we need to wrap our application with wrapper from t package and provide which we created in first step. Main file should looks like this:\n\nOk, I’ll skip explaining types, because this is not important in this article. Let’s focus on important things.\n\nFirst thing we need to define shape of our cart’s state:\n\nThis is like setting up a new empty shopping cart when a customer first enters the store.\n\nNow comes the heart of our slice:\n\nThe function is one of Redux Toolkit’s most powerful features. It’s creating a mini-store just for our cart functionality. The object defines all the ways we can modify our cart state. Here, we have one action: . When this action is called, it takes the payload and adds it to our cart items array.\n\nNotice how we can directly “mutate” the state by using . This looks like we’re modifying state directly (which would normally be a Redux no-no), but behind the scenes, Redux Toolkit uses Immer to turn this into a proper immutable update.\n\nFinally, we export what we need:\n\nThese exports let other parts of our application:\n• Use the reducer in our store configuration (as we saw in the previous store setup)\n\nTo see how this works in practice, here’s how we might use it in a component:\n\nThe hook is like getting a direct line to our Redux store’s message center. Think of it as a remote control that can send commands to update our application’s state. The action we import is the specific command we want to send.\n\nInside our component, we set up our dispatch function:\n\nBy calling , we’re getting our “remote control” ready to use. This is like picking up the remote before you want to change the channel -we’re preparing to send commands to our Redux store.\n\nThe heart of our component is the click handler:\n\nThis function does something quite fascinating. When called, it’s like pressing a button on our remote control. The creates action (think of it as formatting our command in a way Redux understands), and dispatch sends that command to Redux. When it happens:\n• The action travels to our Redux store\n• The store finds the right reducer (in our cart slice) to handle this action\n• The reducer updated our cart state by adding the new product\n• React notices the state change and updates any component that are watching the cart\n\nThis pattern is powerful because it creates a predictable, one-way flow of data: user interaction → action dispatch → state update → UI update. No matter how complex our application becomes, we always know exactly how our data is being modified.\n\nRedux Toolkit represents a modern solution for state management in React applications, significantly simplifying the traditional Redux approach. Through features like createSlice and ImmerJS integration, it reduces boilerplate code while maintaining Redux’s powerful state management capabilities. Whether you’re building a simple shopping cart or a complex application, Redux Toolkit provides the tools needed for efficient and maintainable state management in your React projects."
    },
    {
        "link": "https://blog.nashtechglobal.com/redux-toolkit-a-beginners-guide-to-state-management-with-react",
        "document": "The foundation of any strong React application is state management. Redux has long been a reliable tool for component-to-component state management, particularly in intricate applications. But for beginners, putting it up could be difficult and verbose. Presenting Redux Toolkit (RTK), a more user-friendly, potent, and effective method of incorporating Redux into your React apps.\n\nThe fundamentals of utilizing Redux Toolkit with React and how it streamlines state management will be discussed in this article.\n\nThe official, suggested method for writing Redux logic is Redux Toolkit. It provides a simplified API and wraps Redux’s essential functionalities, which:\n• Reduces boilerplate by offering best practices and shortcuts.\n• Provides a “batteries included” setup with middleware, DevTools, and other configuration options.\n• Immer’s default support for immutability enables programmers to create “mutative” code that is actually immutable.\n• Simple Setup: Creating a store and slices is quicker, and the configuration is easier than with vanilla Redux.\n• Optimized: RTK is designed with best practices in mind, like avoiding deeply nested switch statements in reducers.\n• Reduced Boilerplate: Reduces the setup time and code needed to manage slices and actions, focusing more on the business logic.\n\nLet’s get started with a simple example to show you how to use RTK in a React project.\n\nFirst, ensure you have a React project. If not, you can create one by running:\n\nNext, install the necessary dependencies:\n\nIn RTK, a “slice” is a portion of your state that consists of actions, reducers, and the state. Let’s make a straightforward counter slice.\n• In your folder, create a new file: .\n\nNext, configure your store. Create a file in the folder.\n\nStep 5: Provide the Store to Your App\n\nTo make the store accessible throughout your app, wrap it in the Provider component and send it as a prop. Modify index.js:\n\nYou may now use your components’ dispatch actions and state. Let’s make a basic counter component in Counter.js, for example.\n\nThis is what’s taking place in Counter.js:\n• The state (state.counter.value) is accessed by useSelector.\n• useDispatch Sends out actions (such increments and decrements) to change the state.\n\nRTK is an excellent option for React apps of any size since it makes Redux implementation easier. RTK makes it more simpler to set up slices, actions, and the store, allowing you to concentrate on the logic of your app rather than boilerplate. You should have no trouble managing state in a more effective and sustainable manner if you adhere to this approach.\n\nFinally, for more such updates and to read more about such topics, please follow our LinkedIn page Frontend Competency."
    }
]