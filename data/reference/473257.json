[
    {
        "link": "https://cplusplus.com/reference/map/multimap",
        "document": "an unsigned integral type that can represent any non-negative value of\n\nusually the same as size_t"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/multimap",
        "document": "is an associative container that contains a sorted list of key-value pairs, while permitting multiple entries with the same key. Sorting is done according to the comparison function , applied to the keys. Search, insertion, and removal operations have logarithmic complexity.\n\nIterators of iterate in non-descending order of keys, where non-descending is defined by the comparison that was used for construction. That is, given\n• and , dereferenceable iterators to , with .\n\nm.value_comp()(*it_r, *it_l) == false (least to greatest if using the default comparison).\n\nEverywhere the standard library uses the Compare requirements, equivalence is determined by using the equivalence relation as described on Compare. In imprecise terms, two objects a and b are considered equivalent if neither compares less than the other: !comp(a, b) && !comp(b, a).\n\nmeets the requirements of Container, AllocatorAwareContainer, AssociativeContainer and ReversibleContainer.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/multimap-associative-containers-the-c-standard-template-library-stl",
        "document": "In C++, multimap is an associative container similar to map, but it can have multiple elements with same keys. It stores all the elements in increasing order based on their keys by default but can be changed if required. It provides fast insertion, deletion and search on this sorted data.\n\nExplanation: In the above program, we created a multimap inserted 4 key-value pairs: {1, “Geeks”}, {3, “For”}, {1, “C++”} and {2, “STL”}. As we can see in the output, it is above to store elements with duplicate values.\n\nMultimap is defined as the std::multimap class template inside the <map> header file.\n• comp: Custom comparator function that defines how to compare two keys for sorting. It is optional and if not provided, data is sorted in increasing order of the keys.\n• mm: Name assigned to the multimap.\n\nWe can declare and initialize a multimap in different ways as shown in the below example:\n\nExplanation: In the above example,\n• multimap<int, string> mm2 = {{1, “Geeks”}, {2, “For”}, {1, “C++”}} mm2 using an initializer list, which directly populates it with three key-value pairs.\n\nBasic operations on multimap containers are shown below:\n\nA key-value pair can be inserted into multimap using insert() method. Insertion using [] operator is not valid because there can be multiple elements with same key.\n\nOrder of elements with the same key is determined by the insertion order.\n\nTo know more methods to insert elements, refer to this article. – Different Ways to Insert Multiple Key-Value Pairs\n\nElements of the multimaps can only be accessed by using iterators. The key can be accessed via the first member, and the value can be accessed via the second member using the -> operator. As already told, [] operator is not valid. We can use next() and advance() methods to move the iterators.\n\nHowever, we can quickly access the first and last element using begin() and end() iterators.\n\nExplanation: In the above program, we get the iterator to the 2nd element by moving the begin() iterator one position using advance() method. Then the key and value are accessed using it->first and it->second.\n\nIn multimap, the key of any element cannot be modified. But we can modify the value using the iterator to that element.\n\nMultimap can be traversed by either range-based for loop or using begin() and end() iterators with a loop.\n\nMultimaps allows fast search by key operation using find() method. This function returns iterator to the first element with the given key. If the given key is not found, it returns end() iterator.\n\nIf you want to find a particular element within all the elements with same key, you can search in the range returned by equal_range() method.\n\nElements can be removed from multimap using erase() function either by passing the key or iterator. If the key is passed, then all the elements with that key are removed. If the iterator is passed, then only the pointed element is removed.\n\nThe below table lists the time complexity of the above operations on multimap:\n\nThe following examples’ aim is to help you master multimap operations beyond the basic operations:\n\nA multimap is an associative container that provides the built-in implementation of a Red-Black Tree. It is a self-balancing binary search tree that stores data in some sorted order and provides logarithmic time complexity for insert, delete, and access operations. In multimap, duplicate keys are stored in the same order they were inserted, which is why multiple elements with the same key can exist.\n\nPrimary difference between multimap and map is shown below:\n• None allows one element per key.\n• None Multimap allows multiple elements with the same key.\n\nFollowing is the list of all member functions of std::multimap class in C++:\n\nReturns a constant reverse iterator referring to the last element in the multimap. Returns a constant reverse iterator pointing to the element before the first element in the multimap. Insert the key and its element in the multimap container with a given hint. Removes all the elements from the multimap. Returns whether the multimap is empty. Returns the maximum number of elements a multimap can hold. Returns the object that determines how the elements in the multimap are ordered (‘<‘ by default). Returns an iterator pointing to the last element of the container. Returns a reverse iterator pointing to the element preceding to the first element of the multimap. Returns a constant iterator referring to the first element in the multimap. Returns a constant iterator pointing to the element that follows the last element in the multimap. Swap the contents of one multimap with another multimap of same type and size. Returns the number of elements in the multimap container. Inserts the key and its element in the multimap container. Returns an iterator referring to the first element in the multimap. Returns an iterator to the element that follows the last element in the multimap. Find the first element in the multimap that is equal to or greater than the given key. Find the first element in the multimap that is just greater than the given key. Returns the number of matches to element with key-value in the multimap. Removes the key value from the multimap. Returns an iterator to the element with key-value in the multimap if found, else returns the iterator to end. Returns an iterator of pairs. The pair refers to the bounds of a range that includes all the elements in the container which have a key equivalent to k. Used to insert elements in the multimap. Used to insert multiple elements at time in the multimap This function is used to merge two multisets into one. Returns the object that determines how the elements in the multimap are ordered (‘<‘ by default)."
    },
    {
        "link": "https://cplusplus.com/reference/map/multimap/multimap",
        "document": "The container keeps an internal copy ofand, which are used to allocate storage and to sort the elements throughout its lifetime.The copy constructorcreates a container that keeps and uses copies of's allocator and comparison object The storage for the elements is allocated using this internal allocator The elements are sorted according to the comparison object\n\nThe container keeps an internal copy of, which is used to allocate and deallocate storage for its elements, and to construct and destroy them (as specified by its allocator_traits ). If noargument is passed to the constructor, a default-constructed allocator is used, except in the following cases:- The copy constructorcreates a container that keeps and uses a copy of the allocator returned by calling the appropriate selected_on_container_copy_construction trait on's allocator.- The move constructoracquires's allocator.The container also keeps an internal copy of(or's comparison object ), which is used to establish the order of the elements in the container and to check for elements with equivalent keys.All elements areor otherwiseby calling allocator_traits::construct with the appropriate arguments.The elements are sorted according to the comparison object . If elements with equivalent keys are passed to the constructor, their relative order is preserved."
    },
    {
        "link": "https://stackoverflow.com/questions/25240275/multimap-with-custom-keys-comparison-function",
        "document": "The comparator for a map or multimap is expected to express a strict weak ordering relation between the set of keys. Your requirement \"two objects are equivalent if just one of their fields matches\" cannot be such a relation. Take these three keys:\n\nclearly, keys 1 and 2 are equivalent, because they have the same . Likewise, 2 and 3 are equivalent because of the same . That means, that 1 and 3 have to be equivalent as well, although they have no matching fields.\n\nAs a corollary, all possible keys have to be equivalent under these circumstances, which means you dont have any ordering at all and a multimap is not the right way to go.\n\nFor your case, Boost.MultiIndex comes to mind. You could then have two separate indices for and and do your , and searches over both indices separately."
    },
    {
        "link": "https://geeksforgeeks.org/custom-comparator-for-multimap-in-cpp",
        "document": "In C++ multimap is a container to store key-value pairs allowing duplicate keys which is not allowed in a map container. By default, the multimap container uses the less than '<' operator to compare the keys for ordering the entries but also allows the use of the custom comparator. In this article, we will learn how to use a multimap with a custom comparator in C++.\n\nCustom Comparator for Multimap in C++\n\nTo use a std::multimap with a custom comparator, we can define a comparison function or a functor (a class that overloads the ) and then use it as a template parameter when declaring the multimap so that the elements of the multimap will be ordered automatically based on the conditions mentioned in the custom comparator.\n\nC++ Program to Use a Multimap with a Custom Comparator\n\nThe below example demonstrates how we can use a multimap with a custom comparator in C++.\n\nTime Complexity: O(N log N), here N is the number of elements in a multimap.\n\nAuxiliary Space: O(N)"
    },
    {
        "link": "https://stackoverflow.com/questions/52074218/custom-compare-function-for-stdmultimap-when-keys-are-equal",
        "document": "What I would like to do is to compare the keys, in case they are equal, then compare the values.\n\nNo, you can not make a comparison for according to the values.\n\nI would suggest using instead and simply sort. The operator< of will take care of what you want.\n\nUpdate: After reading the other answer(i.e, ), I was thinking about, how bad is the .\n\nThen I came up with the following benchmark, which shows, why should be at first place in the above problem."
    },
    {
        "link": "https://geeksforgeeks.org/multimap-associative-containers-the-c-standard-template-library-stl",
        "document": "In C++, multimap is an associative container similar to map, but it can have multiple elements with same keys. It stores all the elements in increasing order based on their keys by default but can be changed if required. It provides fast insertion, deletion and search on this sorted data.\n\nExplanation: In the above program, we created a multimap inserted 4 key-value pairs: {1, “Geeks”}, {3, “For”}, {1, “C++”} and {2, “STL”}. As we can see in the output, it is above to store elements with duplicate values.\n\nMultimap is defined as the std::multimap class template inside the <map> header file.\n• comp: Custom comparator function that defines how to compare two keys for sorting. It is optional and if not provided, data is sorted in increasing order of the keys.\n• mm: Name assigned to the multimap.\n\nWe can declare and initialize a multimap in different ways as shown in the below example:\n\nExplanation: In the above example,\n• multimap<int, string> mm2 = {{1, “Geeks”}, {2, “For”}, {1, “C++”}} mm2 using an initializer list, which directly populates it with three key-value pairs.\n\nBasic operations on multimap containers are shown below:\n\nA key-value pair can be inserted into multimap using insert() method. Insertion using [] operator is not valid because there can be multiple elements with same key.\n\nOrder of elements with the same key is determined by the insertion order.\n\nTo know more methods to insert elements, refer to this article. – Different Ways to Insert Multiple Key-Value Pairs\n\nElements of the multimaps can only be accessed by using iterators. The key can be accessed via the first member, and the value can be accessed via the second member using the -> operator. As already told, [] operator is not valid. We can use next() and advance() methods to move the iterators.\n\nHowever, we can quickly access the first and last element using begin() and end() iterators.\n\nExplanation: In the above program, we get the iterator to the 2nd element by moving the begin() iterator one position using advance() method. Then the key and value are accessed using it->first and it->second.\n\nIn multimap, the key of any element cannot be modified. But we can modify the value using the iterator to that element.\n\nMultimap can be traversed by either range-based for loop or using begin() and end() iterators with a loop.\n\nMultimaps allows fast search by key operation using find() method. This function returns iterator to the first element with the given key. If the given key is not found, it returns end() iterator.\n\nIf you want to find a particular element within all the elements with same key, you can search in the range returned by equal_range() method.\n\nElements can be removed from multimap using erase() function either by passing the key or iterator. If the key is passed, then all the elements with that key are removed. If the iterator is passed, then only the pointed element is removed.\n\nThe below table lists the time complexity of the above operations on multimap:\n\nThe following examples’ aim is to help you master multimap operations beyond the basic operations:\n\nA multimap is an associative container that provides the built-in implementation of a Red-Black Tree. It is a self-balancing binary search tree that stores data in some sorted order and provides logarithmic time complexity for insert, delete, and access operations. In multimap, duplicate keys are stored in the same order they were inserted, which is why multiple elements with the same key can exist.\n\nPrimary difference between multimap and map is shown below:\n• None allows one element per key.\n• None Multimap allows multiple elements with the same key.\n\nFollowing is the list of all member functions of std::multimap class in C++:\n\nReturns a constant reverse iterator referring to the last element in the multimap. Returns a constant reverse iterator pointing to the element before the first element in the multimap. Insert the key and its element in the multimap container with a given hint. Removes all the elements from the multimap. Returns whether the multimap is empty. Returns the maximum number of elements a multimap can hold. Returns the object that determines how the elements in the multimap are ordered (‘<‘ by default). Returns an iterator pointing to the last element of the container. Returns a reverse iterator pointing to the element preceding to the first element of the multimap. Returns a constant iterator referring to the first element in the multimap. Returns a constant iterator pointing to the element that follows the last element in the multimap. Swap the contents of one multimap with another multimap of same type and size. Returns the number of elements in the multimap container. Inserts the key and its element in the multimap container. Returns an iterator referring to the first element in the multimap. Returns an iterator to the element that follows the last element in the multimap. Find the first element in the multimap that is equal to or greater than the given key. Find the first element in the multimap that is just greater than the given key. Returns the number of matches to element with key-value in the multimap. Removes the key value from the multimap. Returns an iterator to the element with key-value in the multimap if found, else returns the iterator to end. Returns an iterator of pairs. The pair refers to the bounds of a range that includes all the elements in the container which have a key equivalent to k. Used to insert elements in the multimap. Used to insert multiple elements at time in the multimap This function is used to merge two multisets into one. Returns the object that determines how the elements in the multimap are ordered (‘<‘ by default)."
    },
    {
        "link": "https://stackoverflow.com/questions/25240275/multimap-with-custom-keys-comparison-function",
        "document": "The comparator for a map or multimap is expected to express a strict weak ordering relation between the set of keys. Your requirement \"two objects are equivalent if just one of their fields matches\" cannot be such a relation. Take these three keys:\n\nclearly, keys 1 and 2 are equivalent, because they have the same . Likewise, 2 and 3 are equivalent because of the same . That means, that 1 and 3 have to be equivalent as well, although they have no matching fields.\n\nAs a corollary, all possible keys have to be equivalent under these circumstances, which means you dont have any ordering at all and a multimap is not the right way to go.\n\nFor your case, Boost.MultiIndex comes to mind. You could then have two separate indices for and and do your , and searches over both indices separately."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/multimap/multimap",
        "document": "Constructs new container from a variety of data sources and optionally using user supplied allocator alloc or comparison function object comp.\n\nConstructs the container with the contents of the range .\n\nConstructs the container with the contents of .\n\nConstant. If is given and , then linear.\n\nwhere is in general, linear in if is already sorted by .\n\nAfter container move construction (overload (8,9)), references, pointers, and iterators (other than the end iterator) to remain valid, but refer to elements that are now in *this. The current standard makes this guarantee via the blanket statement in [container.reqmts]/67, and a more direct guarantee is under consideration via LWG issue 2321.\n\nAlthough not formally required until C++23, some implementations has already put the template parameter into non-deduced contexts in earlier modes.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    }
]