[
    {
        "link": "https://csharpindepth.com/articles/Events",
        "document": "People often find it difficult to see the difference between events and delegates. C# doesn't help matters by allowing you to declare field-like events which are automatically backed by a delegate variable of the same name. This article aims to clarify the matter for you. Another source of confusion is the overloading of the term \"delegate\". Sometimes it is used to mean a delegate type, and at other times it can be used to mean an instance of a delegate type. I'll use \"delegate type\" and \"delegate instance\" to distinguish between them, and \"delegate\" when talking about the whole topic in a general sense.\n\nIn some ways, you can think of a delegate type as being a bit like an interface with a single method. It specifies the signature of a method, and when you have a delegate instance, you can make a call to it as if it were a method with the same signature. Delegates provide other features, but the ability to make calls with a particular signature is the reason for the existence of the delegate concept. Delegates hold a reference to a method, and (for instance methods) a reference to the target object the method should be called on.\n\nDelegates types are declared with the keyword. They can appear either on their own or nested within a class, as shown below.\n\nThis code declares two delegate types. The first is which has a single parameter of type and returns a . The second is which has two parameters, and doesn't return anything (because the return type is specified as ).\n\nNote that the keyword doesn't always mean that a delegate type is being declared. The same keyword is used when creating instances of the delegate type using anonymous methods.\n\nThe types declared here derive from , which in turn derives from . In practice, you'll only see delegate types deriving from . The difference between and is largely historical; in betas of .NET 1.0 the difference was significant (and annoying) - Microsoft considered merging the two types together, but decided it was too late in the release cycle to make such a major change. You can pretty much pretend that they're only one type.\n\nAny delegate type you create has the members inherited from its parent types, one constructor with parameters of and and three extra methods: , and . We'll come back to the constructor in a minute. The methods can't be inherited from anything, because the signatures vary according to the signature the delegate is declared with. Using the sample code above, the first delegate has the following methods:\n\nAs you can see, the return type of and matches that of the declaration signature, as are the parameters of and the first parameters of . We'll see the purpose of in the next section, and cover and in the section on advanced usage. It's a bit premature to talk about calling methods when we don't know how to create an instance, however. We'll cover that (and more) in the next section.\n\nNow we know how a delegate type is declared and what it contains, let's look at how to create an instance of such a type, and what we can do with it.\n\nNote: this article doesn't cover the features of C# 2.0 and 3.0 for creating delegate instances, nor generic delegate variance introduced in C# 4.0. My article on closures talks about the features of C# 2.0 and 3.0 - alternatively, read chapters 5, 9 and 13 of C# in Depth for a lot more detail. By concentrating on the explicit manner of creating instances in C# 1.0/1.1, I believe it will be easier to understand what's going on under the hood. When you understand the basics, it's clearly worth knowing the features these later versions provide - but if you try to use them without having a firm grasp on the basics, you may well get confused.\n\nAs mentioned earlier, the key points of data in any particular delegate instance are the method the delegate refers to, and a reference to call the method on (the target). For static methods, no target is required. The CLR itself supports other slightly different forms of delegate, where either the first argument passed to a static method is held within the delegate, or the target of an instance method is provided as an argument when the method is called. See the documentation for for more information on this if you're interested, but don't worry too much about it.\n\nSo, now that we know the two pieces of data required to create an instance (along with the type itself, of course), how do we tell the compiler what they are? We use what the C# specification calls a delegate-creation-expression which is of the form . The expression must either be another delegate of the same type (or a compatible delegate type in C# 2.0) or a method group - the name of a method and optionally a target, specified as if you were calling the method, but without the arguments or brackets. Creating copies of a delegate is fairly rare, so we will concentrate on the more common form. A few examples are listed below:\n\nThe constructor we mentioned earlier has two parameters - an and an . The is a reference to the target (or for static methods) and the is a pointer to the method itself.\n\nOne point to note is that delegate instances can refer to methods and targets which wouldn't normally be visible at the point the call is actually made. For instance, a private method can be used to create a delegate instance, and then the delegate instance can be returned from a public member. Alternatively, the target of an instance may be an object which the eventual caller knows nothing about. However, both the target and the method must be accessible to the creating code. In other words, if (and only if) you can call a particular method on a particular object, you can use that method and target for delegate creation. Access rights are effectively ignored at call time. Speaking of which...\n\nDelegate instances are called just as if they were the methods themselves. For instance, to call the delegate referred to by variable above, we could write:\n\nThe method referred to by the delegate instance is called on the target object (if there is one), and the result is returned. Producing a complete program to demonstrate this without including a lot of seemingly irrelevant code is tricky. However, here's a program which gives one example of a static method and one of an instance method. could be written as just in the same way that (within an instance method) you could write instead of - I've included the class name just to make it clear how you would reference methods from other classes.\n\nThe C# syntax is just a short-hand for calling the method provided by each delegate type. Delegates can also be run asynchronously if they provide / methods. These are explained later.\n\nDelegates can be combined such that when you call the delegate, a whole list of methods are called - potentially with different targets. When I said before that a delegate contained a target and a method, that was a slight simplification. That's what a delegate instance representing one method contains. For the sake of clarity, I'll refer to such delegate instances as simple delegates. The alternative is a delegate instance which is effectively a list of simple delegates, all of the same type (i.e. having the same signature). I'll call these combined delegates. Combined delegates can themselves be combined together, effectively creating one big list of simple delegates in the obvious fashion.\n\nIt's important to understand that delegate instances are always immutable. Anything which combines them together (or takes one away from the other) creates a new delegate instance to represent the new list of targets/methods to call. This is just like strings: if you call for instance, it doesn't actually change the string you call it on - it just returns a new string with the appropriate padding.\n\nCombining two delegate instances is usually done using the addition operator, as if the delegate instances were strings or numbers. Subtracting one from another is usually done with the subtraction operator. Note that when you subtract one combined delegate from another, the subtraction works in terms of lists. If the list to subtract is not found in the original list, the result is just the original list. Otherwise, the last occurrence of the list is removed. This is best shown with some examples. Instead of actual code, the following uses lists of simple delegates , etc. For instance, is a combined delegate which, when executed, would call then then . An empty list is represented by rather than an actual delegate instance.\n\nDelegate instances can also be combined with the static method, and one can be subtracted from another with the static method. The C# compiler converts the addition and subtraction operators into calls to these methods. Because they are static methods, they work easily with references.\n\nThe addition and subtraction operators always work as part of assignment: is exactly equivalent to , and likewise for subtraction. Again, the original delegate instance remains unchanged; the value of just changes to be a reference to the appropriate new combined delegate.\n\nNote that because extra delegates are both added to and removed from the end of the list, is always a no-op.\n\nIf a delegate type is declared to return a value (i.e. it's not declared with a return type) and a combined delegate instance is called, the value returned from that call is the one returned by the last simple delegate in the list.\n\nFirst things first: events aren't delegate instances. Let's try that again.\n\nIt's unfortunate in some ways that C# lets you use them in the same way in certain situations, but it's very important that you understand the difference.\n\nI find the easiest way to understand events is to think of them a bit like properties. While properties look like they're fields, they're definitely not - and you can write properties which don't use fields at all. Similarly, while events look like delegate instances in terms of the way you express the add and remove operations, they're not.\n\nEvents are pairs of methods, appropriately decorated in IL to tie them together and let languages know that the methods represent events. The methods correspond to add and remove operations, each of which take a delegate instance parameter of the same type (the type of the event). What you do with those operations is pretty much up to you, but the typical use is to add or remove the delegate from a list of handlers for the event. When the event is triggered (whatever that trigger might be - a button click, a timeout, an unhandled exception) the handlers are called in turn. Note that in C#, the calling of the event handlers is not part of the event itself. (CIL defines an association with a method, and indeed \"other\" methods, but these are not used in C#.)\n\nThe add and remove methods are called in C# using and respectively, where may be qualified with a reference (e.g. ) or a type name (e.g. ). Static events are relatively rare.\n\nEvents themselves can be declared in two ways. The first is with explicit add and remove methods, declared in a very similar way to properties, but with the keyword. Here's an example of an event for the delegate type. Note how it doesn't actually do anything with the delegate instances which are passed to the add and remove methods - it just prints out which operation has been called. Note that the remove operation is called even though we've told it to remove .\n\nAlthough it would be very rare to ignore the value in this way, there are times when you don't want to back an event with a simple delegate variable. For instance, in situations where there are lots of events but only a few are likely to be subscribed to, you could have a map from some key describing the event to the delegate currently handling it. This is what Windows Forms does - it means that you can have a huge number of events without wasting a lot of memory with variables which will usually just have values.\n\nC# provides a simple way of declaring both a delegate variable and an event at the same time. This is called a field-like event, and is declared very simply - it's the same as the \"longhand\" event declaration, but without the \"body\" part:\n\nThis creates a delegate variable and an event, both with the same type. The access to the event is determined by the event declaration (so the example above creates a public event, for instance) but the delegate variable is always private. The implicit body of the event is the obvious one to add/remove delegate instances to the delegate variable, but the changes are made within a lock. For C# 1.1, the event is equivalent to:\n\nThat's for an instance member. For an event declared as static, the variable is also static and a lock is taken out on where is the name of the class declaring the event. In C# 2.0 there is little guarantee about what is used for locking - only that a single object associated with the instance is used for locking with instance events, and a single object associated with the class is used for locking static events. (Note that this only holds for class events, not struct events - there are issues in terms of locking with struct events; in practice I don't remember ever seeing a struct with any events.) None of this is actually as useful as you might think - see the threading section for more details.\n\nSo, what happens when you refer to in code? Well, within the text of type itself (including nested types) the compiler generates code which refers to the delegate variable ( in my sample above). In all other contexts, the compiler generates code which refers to the event.\n\nNow we know what they are, what's the point of having both delegates and events? The answer is encapsulation. Suppose events didn't exist as a concept in C#/.NET. How would another class subscribe to an event? Three options:\n\nOption 1 is clearly horrible, for all the normal reasons we abhor public variables. Option 2 is slightly better, but allows subscribers to effectively override each other - it would be all too easy to write which would replace any existing event handlers rather than adding a new one. In addition, you still need to write the properties.\n\nOption 3 is basically what events give you, but with a guaranteed convention (generated by the compiler and backed by extra flags in the IL) and a \"free\" implementation if you're happy with the semantics that field-like events give you. Subscribing to and unsubscribing from events is encapsulated without allowing arbitrary access to the list of event handlers, and languages can make things simpler by providing syntax for both declaration and subscription.\n\nEarlier we touched on field-like events locking during the add/remove operations. This is to provide a certain amount of thread safety. Unfortunately, it's not terribly useful. Firstly, even with 2.0, the spec allows for the lock to be the reference to object, or the type itself for static events. That goes against the principle of locking on privately held references to avoid accidental deadlocks.\n\nIronically, the second problem is the exact reverse of the first - because in C# 2.0 you can't guarantee which lock is going to be used, you can't use it yourself when raising an event to ensure that you see the most recent value in the thread doing the raising. You can lock on something else or call one of the memory barrier methods, but it leaves something of a nasty taste in the mouth.\n\nIf you want to be truly thread-safe, such that when you raise an event you always use the most recent value of the delegate variable, along with making sure that the add/remove operations don't interfere with each other, you need to write the body of the add/remove operations yourself. Here's an example:\n\nYou could use a single lock for all your events, or even for other things as well - it depends on your situation. Note that you need to assign the current value to a local variable inside the lock (to get the most recent value) and then test it for nullity and execute it outside the lock: holding the lock whilst raising the event is a very bad idea, as you could easily deadlock. (Event handlers may well need to wait for another thread to do something, and if that other thread were to call the add or remove operation on your event, you'd get deadlock.)\n\nThis all works because once has been assigned the value of , the value of won't change even if does. So if all the handlers are unsubscribed from the event, will become but will still have whatever value it had when it was assigned. In fact, as delegate instances are immutable, whatever handlers were subscribed when the line was executed will be called, even if others have subscribed between then and the line.\n\nNow, it's important to consider whether or not you even need thread safety. Are event handlers going to be added or removed from other threads? Do you need to raise the event from another thread? If you're in complete control of your application, the answer may very well be \"no\". (If you're writing a class library, it's more likely that being thread-safe is important.) If you don't need thread safety, you may want to implement the add/remove operations to get round the problem of the externally visible lock that C# uses (or may use in the case of 2.0). At that point, the operations become pretty trivial. Here's the equivalent of the earlier code, but without thread safety.\n\nThe check for nullity is due to delegate variables being when there aren't any delegate instances to call. One way to make things simpler is to use a no-op delegate instance as the \"default\" one, which is never removed. At that point, you can just obtain the value of the delegate variable (inside a lock if you're being thread-safe) and then execute the delegate instance. If there are no \"real\" delegate targets to call, the no-op target will execute and that's all that will happen.\n\nEarlier we saw how a call to is actually a short-hand for . Delegates types may also allow asynchronous behaviour using the / pair. These are optional as far as the CLI specification is concerned, but C# delegate types always provide them. They follow the same model for asynchronous execution as the rest of .NET, allowing a callback handler to be provided, along with an object to store state information. The delegates are executed on threads created by the system thread-pool.\n\nThe first example below operates without a callback, simply using and from the same thread. This is occasionally useful when a single thread is used for an operation which is synchronous in general, but which contains elements which may be performed in parallel. The methods involved are all static for the sake of simplicity, but delegate instances with specific target objects can also be used, and often are. returns whatever value was returned by the delegate call. If the call threw an exception, the same exception is thrown by .\n\nThe calls to are just to demonstrate that the execution really does occur in parallel. The sleep in is as large as it is to force the system thread-pool to run the tasks on two different threads - the thread-pool serializes requests which don't take long in order to avoid creating more threads than it needs to. By sleeping for a long time, we're simulating a long-running request. Here's the output from a sample run:\n\nThe calls to block until the delegate has completed in much the same way as calls to block until the threads involved have terminated. The values returned by the calls to allows access to the state passed as the last parameter to , but this isn't typically used in the style of asynchronous invocation shown above.\n\nThe code above is fairly simple, but often not as powerful as a model which uses callbacks after the delegate has completed. Typically, the callback will call to obtain the result of the delegate. Although it is still a theoretically blocking call, it will never actually block because the callback only executes when the delegate has completed anyway. The callback may well use the state provided to as extra context information. The sample code below uses the same counting and parsing delegates as the previous example, but with a callback displaying the results. The state is used to determine how to format each result, so a single callback can be used for both asynchronous calls. Note the cast from to : the value provided to the callback is always an instance of , and this can be used to obtain the original delegate instance, so that the callback can call . It is somewhat anomalous that lives in the namespace when all the other classes involved are in either or , but such is life.\n\nThis time almost all the work is done on thread-pool threads. The main thread just kicks off the asynchronous tasks and then sleeps for long enough to let all the work finish. (Thread-pool threads are background threads - without the extra call, the application would terminate before the delegate calls finished executing.) Some sample output is below - notice how this time, because there is no guaranteed ordering to the calls to , the parser result is displayed before the counter result. In the previous example, the parser almost certainly completed before the counter did, but the main thread waited to obtain the result of the counter first.\n\nNote that you must call when you use asynchronous execution in order to guarantee not to leak memory or handles. Some implementations may not leak, but you shouldn't rely on this. See my thread-pool article for some sample code to allow \"fire and forget\" style asynchronous behaviour if this is inconvenient.\n\nDelegates provide a simple way of representing a method call, potentially with a target object, as a piece of data which can be passed around. They are the basis for events, which are effectively conventions for adding and removing handler code to be invoked at appropriate times."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/events",
        "document": "Events in .NET are based on the delegate model. The delegate model follows the observer design pattern, which enables a subscriber to register with and receive notifications from a provider. An event sender pushes a notification when an event occurs. An event receiver defines the response. This article describes the major components of the delegate model, how to consume events in applications, and how to implement events in your code.\n\nAn event is a message sent by an object to signal the occurrence of an action. The action might be user interaction, such as a button press, or it might result from other program logic, such as a property value change. The object that raises the event is called the event sender. The event sender doesn't know the object or method that receives (handles) the events it raises. The event is typically a member of the event sender. For example, the Click event is a member of the Button class, and the PropertyChanged event is a member of the class that implements the INotifyPropertyChanged interface.\n\nTo define an event, you use the C# event or the Visual Basic Event keyword in the signature of your event class, and specify the type of delegate for the event. Delegates are described in the next section.\n\nTypically, to raise an event, you add a method that is marked as and (in C#) or and (in Visual Basic). The naming convention for the method is , such as . The method should take one parameter that specifies an event data object, which is an object of type EventArgs or a derived type. You provide this method to enable derived classes to override the logic for raising the event. A derived class should always call the method of the base class to ensure registered delegates receive the event.\n\nThe following example shows how to declare an event named . The event is associated with the EventHandler delegate and raised in a method named :\n\nA delegate is a type that holds a reference to a method. A delegate is declared with a signature that shows the return type and parameters for the methods it references. It can hold references only to methods that match its signature. A delegate is equivalent to a type-safe function pointer or a callback. A delegate declaration is sufficient to define a delegate class.\n\nDelegates have many uses in .NET. In the context of events, a delegate is an intermediary (or pointer-like mechanism) between the event source and the code that handles the event. You associate a delegate with an event by including the delegate type in the event declaration, as shown in the example in the previous section. For more information about delegates, see the Delegate class.\n\n.NET provides the EventHandler and EventHandler<TEventArgs> delegates to support most event scenarios. Use the EventHandler delegate for all events that don't include event data. Use the EventHandler<TEventArgs> delegate for events that include data about the event. These delegates have no return type value and take two parameters (an object for the source of the event and an object for event data).\n\nDelegates are multicast class objects, which means they can hold references to more than one event-handling method. For more information, see the Delegate reference page. Delegates provide flexibility and fine-grained control in event handling. A delegate acts as an event dispatcher for the class that raises the event by maintaining a list of registered event handlers for the event.\n\nUse the EventHandler and EventHandler<TEventArgs> delegate types to define the needed delegate. You mark a delegate with the type in [C#]](../../csharp/language-reference/builtin-types/reference-types.md#the-delegate-type) or the type in Visual Basic in the declaration. The following example shows how to declare a delegate named :\n\nData associated with an event can be provided through an event data class. .NET provides many event data classes that you can use in your applications. For example, the SerialDataReceivedEventArgs class is the event data class for the SerialPort.DataReceived event. .NET follows a naming pattern where all event data classes end with the suffix. You determine which event data class is associated with an event by looking at the delegate for the event. For example, the SerialDataReceivedEventHandler delegate includes the SerialDataReceivedEventArgs class as a parameter.\n\nThe EventArgs class is typically the base type for event data classes. You also use this class if an event doesn't have any data associated with it. When you create an event that notifies subscribers that something happened without any additional data, include the EventArgs class as the second parameter in the delegate. You can pass the EventArgs.Empty value when no data is provided. The EventHandler delegate includes the EventArgs class as a parameter.\n\nYou can create a class that derives from the EventArgs class to provide any members needed to pass data related to the event. Typically, you should use the same naming pattern as .NET and end your event data class name with the suffix.\n\nThe following example shows an event data class named that contains properties that are specific to the event being raised:\n\nTo respond to an event, you define an event handler method in the event receiver. This method must match the signature of the delegate for the event you're handling. In the event handler, you perform the actions that are required when the event is raised, such as collecting user input after the user presses a button. To receive notifications when the event occurs, your event handler method must subscribe to the event.\n\nThe following example shows an event handler method named that matches the signature for the EventHandler delegate. The method subscribes to the event:\n\n.NET allows subscribers to register for event notifications either statically or dynamically. Static event handlers are in effect for the entire life of the class whose events they handle. Dynamic event handlers are explicitly activated and deactivated during program execution, usually in response to some conditional program logic. You can use dynamic handlers when event notifications are needed only under certain conditions, or when run-time conditions determine the specific handler to call. The example in the previous section shows how to dynamically add an event handler. For more information, see Events (in Visual Basic) and Events (in C#).\n\nIf your class raises multiple events, the compiler generates one field per event delegate instance. If the number of events is large, the storage cost of one field per delegate might not be acceptable. For these scenarios, .NET provides event properties that you can use with another data structure of your choice to store event delegates.\n\nEvent properties consist of event declarations accompanied by event accessors. Event accessors are methods that you define to add or remove event delegate instances from the storage data structure.\n\nThe trade-off is between memory and speed. If your class defines many events that are infrequently raised, you should implement event properties. For more information, see Handle multiple events by using event properties.\n\nThe following resources describe other tasks and concepts related to working with events:\n• Raise and consume events: Find examples for raising and consuming events.\n• Handle multiple events with event properties: Discover how to use event properties to handle multiple events.\n• Explore the observer design pattern: Review a design pattern that enables a subscriber to register with and receive notifications from a provider.\n\nSpecification reference documentation is available for the APIs that support event handling:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/answers/questions/1163467/c-events-and-delegates-when-should-i-take-what",
        "document": "When to define an event, and when a delegate\n\nHere is the basic idea:\n• If something has happened inside your class, like a property changed, and you want to inform the possible subscribers about it, then you need to define an event in your class, and raise the event when something happens (like property changed).\n• If you want to inject a piece of functionality in a method, or a property, then your method or your property need to accept a delegate as parameter, one example is the link extension methods.\n\nEvents are declared as class members, and you add a delegate to them using += operator.\n\nDelegates are type and will be declared usually as namespace members (like classes).\n\nAfter you defined a delegate (which is like defining signature of a method as a type with a name), then you can define fields, properties variables, input or output arguments of that delegate type.\n\nIn the following examples you will see the usage, and see some differences.\n\nAfter you defined a delegate (which is like defining signature of a method as a type with a name), then you can define fields, properties variables, input or output arguments of that delegate type, for example, let's say you have defined:\n\nThen you can define the following in your class:\n\nWhich is a good example of injecting a functionality, in a method.\n\nAssuming you have defined the following delegate (which is going to be used to define an event):\n\nIt basically is defining a type which explains a method, accepting a string parameter, and a void return value; and since I'm going to use it for an event, by assigning a name , I'm saying a method which is going to handle the event, should follow that signature.\n\nThen you can define the event and the property and raise the event like this:\n\nWhat is Action, or Action<T>, or Funct<T>?\n\nThese are just some predefined delegates. Everytime that you want to pass a delegate as a method parameter, then you need to define the delegate. These actions and funcs makes it easier for you. For example in above delegate example, instead of defining a new delegate type, I could easily use which basically means a method accepting a string parameter which return bool.\n\nLooking at the source code of .NET framework, you see:\n\nWhat's the difference between a delegate field and an event?\n\nLets say you have defined both of following in your class:\n\nThey are very similar (as they both rely on which is a predefined delegate), but they are different as well:\n• The first one is an event, the second one is a public field of delegate type.\n• No one can assign a delegate to your event, they only can add (+=) or remove delegates (-=), but in addition to add (+=), and remove (-=), they can assign (=) delegate to the public field.\n• No one can raise event like a delegate outside of your class, but they can invoke your public delegate field.\n• Like properties and methods, you can define events in interfaces but you cannot do the same for fields.\n\nHere are a few examples to demonstrate the differences which I mentioned above:\n• works and will assign a new multicast delegate to the field.\n• doesn't work outside of your class.\n• works and will run all the delegates which has been assigned to the field.\n\nYou can learn more about the events:\n• Delegates vs. Events - Distinguishing between Delegates and Events"
    },
    {
        "link": "https://stackoverflow.com/questions/803242/understanding-events-and-event-handlers-in-c-sharp",
        "document": "What do event handlers do, why are they needed, and how do I to create one?\n\nI understand the purpose of events, especially within the context of creating user interfaces. I think this is the prototype for creating an event:\n\nThe community is reviewing whether to reopen this question as of 21 days ago.\n\nWant to improve this question? Update the question so it focuses on one problem only by editing this post .\n\n. This question needs to be more focused . It is not currently accepting answers.\n\nTo understand event handlers, you need to understand delegates. In C#, you can think of a delegate as a pointer (or a reference) to a method. This is useful because the pointer can be passed around as a value. The central concept of a delegate is its signature, or shape. That is (1) the return type and (2) the input arguments. For example, if we create a delegate , it can only point to methods which return , and take an and . Kind of like a square hole and a square peg. So we say these methods have the same signature, or shape, as the delegate. So knowing how to create a reference to a method, let's think about the purpose of events: we want to cause some code to be executed when something happens elsewhere in the system - or \"handle the event\". To do this, we create specific methods for the code we want to be executed. The glue between the event and the methods to be executed are the delegates. The event must internally store a \"list\" of pointers to the methods to call when the event is raised.* Of course, to be able to call a method, we need to know what arguments to pass to it! We use the delegate as the \"contract\" between the event and all the specific methods that will be called. So the default (and many like it) represents a specific shape of method (again, void/object-EventArgs). When you declare an event, you are saying which shape of method (EventHandler) that event will invoke, by specifying a delegate: //This delegate can be used to point to methods //which return void and take a string. public delegate void MyEventHandler(string foo); //This event can cause any method which conforms //to MyEventHandler to be called. public event MyEventHandler SomethingHappened; //Here is some code I want to be executed //when SomethingHappened fires. void HandleSomethingHappened(string foo) { //Do some stuff } //I am creating a delegate (pointer) to HandleSomethingHappened //and adding it to SomethingHappened's list of \"Event Handlers\". myObj.SomethingHappened += new MyEventHandler(HandleSomethingHappened); //To raise the event within a method. SomethingHappened(\"bar\"); (*This is the key to events in .NET and peels away the \"magic\" - an event is really, under the covers, just a list of methods of the same \"shape\". The list is stored where the event lives. When the event is \"raised\", it's really just \"go through this list of methods and call each one, using these values as the parameters\". Assigning an event handler is just a prettier, easier way of adding your method to this list of methods to be called).\n\nC# knows two terms, and . Let's start with the first one. A is a reference to a method. Just like you can create a reference to an instance: You can use a delegate to create an reference to a method: Now that you have this reference to a method, you can call the method via the reference: But why would you? You can also just call directly. In this case you can. However, there are many cases to think about where you don't want the rest of the application to have knowledge of or to call directly. An obvious one is if you want to be able to replace into from one central place (aka factory method pattern). So, if you have a class and it needs to use the , this is how the code will look like without delegates (you'll need to let know about the type of your ): If you'd use delegates, you don't have to expose the type of my factory: Thus, you can give a delegate to some other class to use, without exposing your type to them. The only thing you're exposing is the signature of your method (how many parameters you have and such). \"Signature of my method\", where did I hear that before? O yes, interfaces!!! interfaces describe the signature of a whole class. Think of delegates as describing the signature of only one method! Another large difference between an interface and a delegate is that when you're writing your class, you don't have to say to C# \"this method implements that type of delegate\". With interfaces, you do need to say \"this class implements that type of an interface\". Further, a delegate reference can (with some restrictions, see below) reference multiple methods (called ). This means that when you call the delegate, multiple explicitly-attached methods will be executed. An object reference can always only reference to one object. The restrictions for a are that the (method/delegate) signature should not have any return value ( ) and the keywords and is not used in the signature. Obviously, you can't call two methods that return a number and expect them to return the same number. Once the signature complies, the delegate is automatically a . Events are just properties (like the get;set; properties to instance fields) which expose subscription to the delegate from other objects. These properties, however, don't support get;set;. Instead, they support add; remove; Usage in UI (WinForms,WPF,UWP So on) So, now we know that a delegate is a reference to a method and that we can have an event to let the world know that they can give us their methods to be referenced from our delegate, and we are a UI button, then: we can ask anyone who is interested in whether I was clicked, to register their method with us (via the event we exposed). We can use all those methods that were given to us and reference them by our delegate. And then, we'll wait and wait.... until a user comes and clicks on that button, then we'll have enough reason to invoke the delegate. And because the delegate references all those methods given to us, all those methods will be invoked. We don't know what those methods do, nor we know which class implements those methods. All we do care about is that someone was interested in us being clicked, and gave us a reference to a method that complied with our desired signature. Languages like Java don't have delegates. They use interfaces instead. The way they do that is to ask anyone who is interested in 'us being clicked', to implement a certain interface (with a certain method we can call), then give us the whole instance that implements the interface. We keep a list of all objects implementing this interface and can call their 'certain method we can call' whenever we get clicked.\n\nHere is a code example which may help: using System; using System.Collections.Generic; using System.Text; namespace Event_Example { // First we have to define a delegate that acts as a signature for the // function that is ultimately called when the event is triggered. // You will notice that the second parameter is of MyEventArgs type. // This object will contain information about the triggered event. public delegate void MyEventHandler(object source, MyEventArgs e); // This is a class which describes the event to the class that receives it. // An EventArgs class must always derive from System.EventArgs. public class MyEventArgs : EventArgs { private string EventInfo; public MyEventArgs(string Text) { EventInfo = Text; } public string GetInfo() { return EventInfo; } } // This next class is the one which contains an event and triggers it // once an action is performed. For example, lets trigger this event // once a variable is incremented over a particular value. Notice the // event uses the MyEventHandler delegate to create a signature // for the called function. public class MyClass { public event MyEventHandler OnMaximum; private int i; private int Maximum = 10; public int MyValue { get { return i; } set { if(value <= Maximum) { i = value; } else { // To make sure we only trigger the event if a handler is present // we check the event to make sure it's not null. if(OnMaximum != null) { OnMaximum(this, new MyEventArgs(\"You've entered \" + value.ToString() + \", but the maximum is \" + Maximum.ToString())); } } } } } class Program { // This is the actual method that will be assigned to the event handler // within the above class. This is where we perform an action once the // event has been triggered. static void MaximumReached(object source, MyEventArgs e) { Console.WriteLine(e.GetInfo()); } static void Main(string[] args) { // Now lets test the event contained in the above class. MyClass MyObject = new MyClass(); MyObject.OnMaximum += new MyEventHandler(MaximumReached); for(int x = 0; x <= 15; x++) { MyObject.MyValue = x; } Console.ReadLine(); } } }\n\nAnother thing to know about, in some cases, you have to use the Delegates/Events when you need a low level of coupling ! If you want to use a component in several place in application, you need to make a component with low level of coupling and the specific unconcerned LOGIC must be delegated OUTSIDE of your component ! This ensures that you have a decoupled system and a cleaner code. In SOLID principle this is the \"D\", (Dependency inversion principle). Also known as \"IoC\", Inversion of control. You can make \"IoC\" with Events, Delegates and DI (Dependency Injection). It's easy to access a method in a child class. But more difficult to access a method in a parent class from child. You have to pass the parent reference to the child ! (or use DI with Interface) Delegates/Events allows us to communicate from the child to the parent without reference ! In this diagram above, I do not use Delegate/Event and the parent component B has to have a reference of the parent component A to execute the unconcerned business logic in method of A. (high level of coupling) With this approach, I would have to put all the references of all components that use component B ! :( In this diagram above, I use Delegate/Event and the component B doesn't have to known A. (low level of coupling) And you can use your component B anywhere in your application !\n\nThis will be a long one but its the simplest explanation, the problem this is such a nuisance of a topic is because people are just using different words to explain the same thing First of all, you should know a few things DELEGATES: It's nothing but a list of methods, why create a list? because when your code is being executed, that list is taken and every method there is executed one by one, just don't listen to textbook definitions take this and you will be all right\n• a wrapper for a method that can send and receive methods just like a variable to create a delegate you go now to execute all these methods stored in a list called delegate, you go using the dot and explicitly saying invoke shines in async programming where you use beginInvoke, but that is out of the scope of this topic there is one more thing called \"Creating an object of the delegate/instantiate Delegate\" which is pretty much as it sounds but just to avoid confusion it goes like (for the above example ) example : demo del = new demo(); (or) Public demo del = null; to add any method to the list called delegate you go += and you also need to remove it once the \"requirements of the methods are met\" you go -= (requirements of the methods are met mean you no longer need the method to be active or aka \"listening\") if you don't remove it, it could cause a \"memory leak\" meaning your computers ram will be eaten alive, technically allocated memory will not be released example: say there is a method public int calculate (int c) to add this method to delegate you go 1. del = calculate; 2. del += calculate; .... all are valid to remove del -= calculate first of all notice the similarities between the delegate and the method, the return type(output) and the input/parameters are the same, and that is a rule you just cannot add any random or a bunch of methods in a delegate it needs to follow the input-output rule now why are there 2 different ways to do one thing, the only thing different is the assignment operators (+, =), this introduces a new topic called which is nothing but a constrained version of a Delegate, It's still a List of methods don't confuse when people explain these terminologies, they change the name, so stick with this to understand what is the constraint? you cannot do this what's the harm in it, say a bunch of methods are added to the Delegate(List), you do that 👆 all are wiped out and only a single method \"calculate\" remains, so to prevent that Events are used, Event Syntax One more thing you cannot do with events is invoke the delegate directly like since its public it can be accessed and invoked but with events, it can't now you just add the methods to the event (a special type of delegate) when to use an event vs a delegate, depends on your situation but pragmatically events are popular MULTICASTING: nothing but adding more than one method to a delegate BROADCASTING: adding more than one method to an event PUBLISHER: the one that executes the method (term used in broadcasting), only a single entity SUBSCRIBER: The methods that are being executed, can be multiple LISTENER: the same thing as a subscriber but the term is used in multicasting EVENT HANDLER: same thing as a subscriber/event listener so what the difference? it's basically the same thing, some say an eventlistener detect for the event to occur and the event handler \"handles\" or execute the code, ITS THE SAME THING PRACTICALLY! action and func are just delegates that have been created and instantiated so 2 lines of code in a word, the difference is just in return types ACTION: does not return anything while taking 0 or more than 1 input FUNC: returns one thing and takes in parameters"
    },
    {
        "link": "https://medium.com/nerd-for-tech/c-delegates-actions-events-summary-please-8fab0244a40a",
        "document": "I don’t know if I’m the only one, but for some reason, I have “understood” this many times, and forgotten and gotten confused as many times. I’m trying to write some clear notes for me that maybe can help somebody else too. CLEAR being the key word here. I’ll try.\n\nI want to mention delegates, and then the .NET types that we can use as delegates for some scenarios. Let’s go!\n\nA delegate in C# is a type that refers to methods with a parameter list and return type. Delegates are used to pass methods as arguments to other methods.\n\nOK, that is correct but I would not be able to say it back even after reading it. Let’s see a delegate first.\n\nThe delegate doesn’t care whether the methods are static or not so it will work well with both types. Here are some examples of methods that will work with that delegate.\n\nWe can set one or more methods to run with one delegate. In the case that we are retuning a value from the method (like Decimal above), it makes sense to set the delegate to a specific method depending on something (since we have to store the returned value somewhere), just like you can see with this code:\n\nIf we wanted to call more than one method with the same delegate, we would replace the random assignment above with something like this.\n\nMethods are not guaranteed to be called in the order they were added to the delegate. Delegates are objects, so they can also be passed to other methods. In that example, once we have the delegateCalcHandler, we could pass it to another method like this:\n\nJust like you can add methods to a delegate with the += notation, you can remove methods with -=.\n\nWhen the methods we are using are returning void we can use the Action type provided by C#. .NET provides a set of Action types, from Action with no arguments, to Action with 16 arguments (Action, Action<T1>, Action <T1, T2>…).\n\nActions can also be for static and instance methods, but I’m not going to use any more static ones for the sake of simplicity.\n\nThe parameters used for actions can be anything, and they don’t have to all be the same type.\n\nWhen you create Action delegates in a class (I have it inside the method in my example), they are created as properties with set and get methods, so it’s possible for code outside the class to access them. You can add the keyword to them and then they are created as fields instead of properties.\n\nAs somebody pointed out in the comments, it’s worth mentioning that similar to the Actions, you also have Funcs. Actions are used for when the methods return void, while with Funcs you will have a return value. However, similar to the example I have above for Actions, if I do this, the last one in wins:\n\nSo that doesn’t make a lot of sense, so what’s the point? For starters a Func is a delegate object, not a method, so you can pass it around. You could have this, and it would work.\n\nJust like you can pass it, you can do the other things you can do with objects. You could also do something like this.\n\nOr even better, instead of using the delegate way in the assignments above:\n\nWhen you create the Actions as Events in a class, they are created as fields not properties with get and set properties. Also, they are assigned a delegate on creation, so there is no need to check for null before calling it.\n\nIf you are going to use events, use EventHandler instead of event Action\n\nA better way to do events is with the EventHandler. It is better because it allows subscribers to be given data about the event.\n\nIf we are using EventHandlers, the methods we can use with them need to have the parameters\n\nWe will probably need to pass some customized information to the methods, and we can do that by creating a class that inherits from EventArgs.\n\nIn this case, the event is created this way:\n\nWhat happens if we have more than one subscriber and we are not handling exceptions?\n\nWe could take care of the problem this way:\n\nIf we don’t want to have the try-catch blocks in each method, we can also do this:\n\nAnd those are the notes I have so far for delegates, actions, and events.\n\nIf you read this far, I hope this helps. If you think something is not right or confusing, please let me know."
    },
    {
        "link": "https://stackoverflow.com/questions/6716275/how-do-i-set-the-position-of-the-mouse-cursor-from-a-console-app-in-c",
        "document": "I've found many articles on how to set the mouse position in a C# windows forms project - I want to do this in a console application. How can I set the absolute mouse position from a C# windows console application?\n\nHint: it's not Console.setCursorPosition, that only sets the position of the text cursor in the console."
    },
    {
        "link": "https://stackoverflow.com/questions/56479946/update-form-text-on-mouse-move",
        "document": "I have a simple form and I want to display the Cursor position updated continually as the user moves the mouse. The problem I am running into is that the text does not update when the mouse is moved.\n\nLike I said, it gives me the initial mouse location but never updates"
    },
    {
        "link": "https://reddit.com/r/csharp/comments/yig4cz/i_need_help_with_consolesetcursorposition",
        "document": "I'm a high school student and i started programming in c# 1 month ago, i have some serious trouble understanding how to use Console.SetCursorPosition, can anybody explain me how do i use it?\n\nA little example would be useful too."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/menurc/using-carets",
        "document": "This section has code samples for the following tasks:\n\nUpon receiving the keyboard focus, the window should create and display the caret. Use the CreateCaret function to create a caret in the given window. You can then call SetCaretPos to set the current position of the caret and ShowCaret to make the caret visible.\n\nThe system sends the WM_SETFOCUS message to the window receiving keyboard focus; therefore, an application should create and display the caret while processing this message.\n\nTo create a caret based on a bitmap, you must specify a bitmap handle when using CreateCaret. You can use a graphics application to create the bitmap and a resource compiler to add the bitmap to your application's resources. Your application can then use the LoadBitmap function to load the bitmap handle. For example, you could replace the CreateCaret line in the preceding example with the following lines to create a bitmap caret.\n\nAlternatively, you can use the CreateBitmap or CreateDIBitmap function to retrieve the handle of the caret bitmap. For more information about bitmaps, see Bitmaps.\n\nIf your application specifies a bitmap handle, CreateCaret ignores the width and height parameters. The bitmap defines the size of the caret.\n\nWhenever your application redraws a screen while processing a message other than WM_PAINT, it must make the caret invisible by using the HideCaret function. When your application is finished drawing, redisplay the caret by using the ShowCaret function. If your application processes the WM_PAINT message, it is not necessary to hide and redisplay the caret, because this function does this automatically.\n\nThe following code sample shows how to have your application hide the caret while drawing a character on the screen and while processing the WM_CHAR message.\n\nIf your application calls the HideCaret function several times without calling ShowCaret, the caret will not be displayed until the application also calls ShowCaret the same number of times.\n\nWhen a window loses the keyboard focus, the system sends the WM_KILLFOCUS message to the window. Your application should destroy the caret while processing this message by using the DestroyCaret function. The following code shows how to destroy a caret in a window that no longer has the keyboard focus.\n\nIn 16-bit Windows, a Windows-based application could call the GetCaretBlinkTime function to save the current blink time, then call the SetCaretBlinkTime function to adjust the blink time during its processing of the WM_SETFOCUS message. The application would restore the saved blink time for the use of other applications by calling SetCaretBlinkTime during its processing of the WM_KILLFOCUS message. However, this technique does not work in multithreaded environments. Specifically, the deactivation of one application is not synchronized with the activation of another application, so that if one application hangs, another application can still be activated.\n\nApplications should respect the blink time chosen by the user. The SetCaretBlinkTime function should only be called by an application that allows the user to set the blink time.\n\nThe following example demonstrates how to use a caret in a simple text editor. The example updates the caret position as the user types printable characters and uses various keys to move through the client area."
    },
    {
        "link": "https://discussions.unity.com/t/after-adding-text-to-an-input-field-i-want-focus-to-set-the-caret-to-the-end/165830",
        "document": ""
    }
]