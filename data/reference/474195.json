[
    {
        "link": "https://expressjs.com/en/guide/using-middleware.html",
        "document": "Express is a routing and middleware web framework that has minimal functionality of its own: An Express application is essentially a series of middleware function calls.\n\nMiddleware functions are functions that have access to the request object ( ), the response object ( ), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named .\n\nMiddleware functions can perform the following tasks:\n• Make changes to the request and the response objects.\n• Call the next middleware function in the stack.\n\nIf the current middleware function does not end the request-response cycle, it must call to pass control to the next middleware function. Otherwise, the request will be left hanging.\n\nAn Express application can use the following types of middleware:\n\nYou can load application-level and router-level middleware with an optional mount path. You can also load a series of middleware functions together, which creates a sub-stack of the middleware system at a mount point.\n\nBind application-level middleware to an instance of the app object by using the and functions, where is the HTTP method of the request that the middleware function handles (such as GET, PUT, or POST) in lowercase.\n\nThis example shows a middleware function with no mount path. The function is executed every time the app receives a request.\n\nThis example shows a middleware function mounted on the path. The function is executed for any type of HTTP request on the path.\n\nThis example shows a route and its handler function (middleware system). The function handles GET requests to the path.\n\nHere is an example of loading a series of middleware functions at a mount point, with a mount path. It illustrates a middleware sub-stack that prints request info for any type of HTTP request to the path.\n\nRoute handlers enable you to define multiple routes for a path. The example below defines two routes for GET requests to the path. The second route will not cause any problems, but it will never get called because the first route ends the request-response cycle.\n\nThis example shows a middleware sub-stack that handles GET requests to the path.\n\nTo skip the rest of the middleware functions from a router middleware stack, call to pass control to the next route.\n\nThis example shows a middleware sub-stack that handles GET requests to the path.\n\nMiddleware can also be declared in an array for reusability.\n\nThis example shows an array with a middleware sub-stack that handles GET requests to the path\n\nRouter-level middleware works in the same way as application-level middleware, except it is bound to an instance of .\n\nLoad router-level middleware by using the and functions.\n\nThe following example code replicates the middleware system that is shown above for application-level middleware, by using router-level middleware:\n\n// a middleware function with no mount path. This code is executed for every request to the router // a middleware sub-stack shows request info for any type of HTTP request to the /user/:id path // a middleware sub-stack that handles GET requests to the /user/:id path // if the user ID is 0, skip to the next router // otherwise pass control to the next middleware function in this stack // handler for the /user/:id path, which renders a special page // mount the router on the app\n\nTo skip the rest of the router’s middleware functions, call to pass control back out of the router instance.\n\nThis example shows a middleware sub-stack that handles GET requests to the path.\n\nDefine error-handling middleware functions in the same way as other middleware functions, except with four arguments instead of three, specifically with the signature :\n\nFor details about error-handling middleware, see: Error handling.\n\nStarting with version 4.x, Express no longer depends on Connect. The middleware functions that were previously included with Express are now in separate modules; see the list of middleware functions.\n\nExpress has the following built-in middleware functions:\n• express.static serves static assets such as HTML files, images, and so on.\n• express.json parses incoming requests with JSON payloads. NOTE: Available with Express 4.16.0+\n• express.urlencoded parses incoming requests with URL-encoded payloads. NOTE: Available with Express 4.16.0+\n\nUse third-party middleware to add functionality to Express apps.\n\nInstall the Node.js module for the required functionality, then load it in your app at the application level or at the router level.\n\nThe following example illustrates installing and loading the cookie-parsing middleware function .\n\nFor a partial list of third-party middleware functions that are commonly used with Express, see: Third-party middleware."
    },
    {
        "link": "https://expressjs.com/en/guide/routing.html",
        "document": "Routing refers to how an application’s endpoints (URIs) respond to client requests. For an introduction to routing, see Basic routing.\n\nYou define routing using methods of the Express object that correspond to HTTP methods; for example, to handle GET requests and to handle POST requests. For a full list, see app.METHOD. You can also use app.all() to handle all HTTP methods and app.use() to specify middleware as the callback function (See Using middleware for details).\n\nThese routing methods specify a callback function (sometimes called “handler functions”) called when the application receives a request to the specified route (endpoint) and HTTP method. In other words, the application “listens” for requests that match the specified route(s) and method(s), and when it detects a match, it calls the specified callback function.\n\nIn fact, the routing methods can have more than one callback function as arguments. With multiple callback functions, it is important to provide as an argument to the callback function and then call within the body of the function to hand off control to the next callback.\n\nThe following code is an example of a very basic route.\n\nA route method is derived from one of the HTTP methods, and is attached to an instance of the class.\n\nThe following code is an example of routes that are defined for the and the methods to the root of the app.\n\nExpress supports methods that correspond to all HTTP request methods: , , and so on. For a full list, see app.METHOD.\n\nThere is a special routing method, , used to load middleware functions at a path for all HTTP request methods. For example, the following handler is executed for requests to the route whether using , , , , or any other HTTP request method supported in the http module.\n\nRoute paths, in combination with a request method, define the endpoints at which requests can be made. Route paths can be strings, string patterns, or regular expressions.\n\nThis route path will match requests to the root route, .\n\nThis route path will match requests to .\n\nThis route path will match requests to .\n\nThis route path will match and .\n\nThis route path will match , , , and so on.\n\nThis route path will match , , , , and so on.\n\nThis route path will match and .\n\nThis route path will match anything with an “a” in it.\n\nThis route path will match and , but not , , and so on.\n\nRoute parameters are named URL segments that are used to capture the values specified at their position in the URL. The captured values are populated in the object, with the name of the route parameter specified in the path as their respective keys.\n\nTo define routes with route parameters, simply specify the route parameters in the path of the route as shown below.\n\nSince the hyphen ( ) and the dot ( ) are interpreted literally, they can be used along with route parameters for useful purposes.\n\nTo have more control over the exact string that can be matched by a route parameter, you can append a regular expression in parentheses ( ):\n\nYou can provide multiple callback functions that behave like middleware to handle a request. The only exception is that these callbacks might invoke to bypass the remaining route callbacks. You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.\n\nRoute handlers can be in the form of a function, an array of functions, or combinations of both, as shown in the following examples.\n\nA single callback function can handle a route. For example:\n\nMore than one callback function can handle a route (make sure you specify the object). For example:\n\nAn array of callback functions can handle a route. For example:\n\nA combination of independent functions and arrays of functions can handle a route. For example:\n\nThe methods on the response object ( ) in the following table can send a response to the client, and terminate the request-response cycle. If none of these methods are called from a route handler, the client request will be left hanging.\n\nYou can create chainable route handlers for a route path by using . Because the path is specified at a single location, creating modular routes is helpful, as is reducing redundancy and typos. For more information about routes, see: Router() documentation.\n\nHere is an example of chained route handlers that are defined by using .\n\nUse the class to create modular, mountable route handlers. A instance is a complete middleware and routing system; for this reason, it is often referred to as a “mini-app”.\n\nThe following example creates a router as a module, loads a middleware function in it, defines some routes, and mounts the router module on a path in the main app.\n\nCreate a router file named in the app directory, with the following content:\n\nThen, load the router module in the app:\n\nThe app will now be able to handle requests to and , as well as call the middleware function that is specific to the route.\n\nBut if the parent route has path parameters, it will not be accessible by default from the sub-routes. To make it accessible, you will need to pass the option to the Router constructor reference."
    },
    {
        "link": "https://hackernoon.com/effective-use-of-middleware-in-expressjs-practical-approaches",
        "document": "Hello there! Welcome to our exploration of the fascinating world of Express.js middleware! In this guide, we're taking a good look into middleware and its pivotal role within Express.js applications.\n\nMiddleware acts as a bridge between the incoming client requests and the outgoing server responses.\n\nIt's like a helpful intermediary that steps in to process, modify, or augment requests as they move through your application.\n\nImagine you're hosting a party where each guest enters through a hallway.\n\nNow, think of middleware as the courteous host who greets each guest, checks their invitations, offers them appetizers, and ensures they head to the right room.\n\nSimilarly, middleware in Express.js helps streamline your application flow, enhancing its performance, security, and functionality.\n\nConsider an authentication middleware that ensures users are logged in before they can access certain routes.\n\nThis middleware intercepts the request, checks if the user is authenticated, and either lets them proceed or redirects them to the login page.\n\nThis simple example showcases how middleware can add an extra layer of control to your application's behavior.\n\nMiddleware is like the behind-the-scenes conductor of a grand orchestra, orchestrating the flow of data and requests in your Express.js application. It plays a crucial role in keeping your code organized, maintainable, and scalable.\n\nInstead of cramming every feature into one monolithic codebase, middleware lets you compartmentalize different tasks, making your application more manageable and elegant.\n\nAs we dive deeper into this guide, we'll not only define middleware but also uncover its significance in crafting efficient and feature-rich Express.js applications.\n\nLet's start by resolving how middleware functions within the request-response cycle, shedding light on its essential role.\n\nReady to explore? Let's move on to the next section!\n\n2. The Role of Middleware in Express.js\n\n2.1 Explanation of middleware in the request-response cycle\n\nLet's unwrap the concept of middleware further by understanding how it operates within the rhythm of the request-response cycle in Express.js.\n\nVisualize this cycle as hosting a grand party, where the guests (requests) arrive and engage in lively conversations, and you, as the host (middleware), ensure everything runs smoothly.\n\nThe beauty of middleware is that it allows you to greet guests, offer them refreshments, and guide them to different sections of the party based on their needs.\n\nImagine your guests arriving at a magnificent mansion (your application).\n\nAs they walk through the door, you, the charming host (middleware), warmly greet them, verify their invitations, and maybe even hand them a sparkling drink.\n\nThen, depending on their preferences, you guide them to the dance floor, the lounge, or the buffet.\n\nNow, let's break down how middleware handles requests and responses, using the party metaphor:\n\nRequest Middleware: Think of this as the vigilant bouncer stationed at the entrance. Just like a bouncer checks guest invitations and ensures the party's security, request middleware processes incoming data, adds crucial headers, and carries out security checks. For instance, you can use middleware to log incoming requests, keeping a watchful eye on your application's activity.\n\nResponse Middleware: Imagine this as the decorator who adds finishing touches before guests experience a new area of the party. Response middleware polishes the response data, adds final headers, or carries out any necessary clean-up tasks. Comparable to how a decorator enhances the ambiance, response middleware improves the user experience.\n\nBy maintaining this metaphor, middleware continues to play the role of a gracious host who ensures a seamless and enjoyable experience for both guests (requests) and the ambiance (responses).\n\nAs our party analogy continues, let's explore the various amenities and facilities available within our grand mansion (Express.js application).\n\nJust as a lavish party requires multiple stations for guests to enjoy, an Express.js application employs built-in middleware to handle different aspects of the party.\n\n3.2 Examples and use cases for built-in middleware\n\nNow, let's delve into some specific built-in middleware stations within our party mansion, understanding their roles and how they enhance the overall experience:\n\nThink of these as the gourmet chefs stationed at the buffet table. They prepare and serve delectable dishes (data) that guests can savor.\n\nThese middleware stations handle parsing incoming data from requests—be it JSON or form data.\n\nThey ensure that the guests (requests) get to enjoy the buffet without any hassle.\n\nImagine this as the art gallery within our mansion.\n\nThis middleware station showcases the visually appealing assets of our party—images, stylesheets, and JavaScript files.\n\nIt serves these static files directly to guests (clients), allowing them to appreciate the artistic elements that enrich their experience.\n\nConsider this as the signage that guides guests to different sections of the mansion. express.Router() acts as a modular middleware, allowing you to organize routes into separate files.\n\nThis keeps your codebase neat and tidy, just like well-placed signs that ensure guests never lose their way.\n\nBy associating built-in middleware with our party mansion, we're creating an environment where guests (requests) can enjoy various facilities without encountering any confusion.\n\nNow that we've toured the built-in amenities, let's step into the realm of crafting custom middleware to tailor the party experience even further.\n\nContinuing with our party analogy, imagine you want to introduce a unique station in the mansion—a room where guests can personalize their experience.\n\nSimilarly, in Express.js, crafting custom middleware lets you add tailored features to your application.\n\nYou're the architect here, building a distinct experience for your guests (requests).\n\nThink of a custom middleware function as the host who introduces a unique party game for the guests. It follows a specific structure: accepting the request, response, and next parameters. The next parameter is the baton you pass to ensure the party game moves forward smoothly.\n\nHere's a detailed example: Let's say you want to create a middleware that logs the timestamp of each incoming request.\n\nAdding custom middleware is like inviting a talented performer to entertain your party guests.\n\nYou register your middleware function using app.use(), ensuring it's available for every incoming request.\n\nImagine a photo booth station within your mansion—a perfect example of custom middleware. Let's create middleware that adds a personalized signature to the response of each guest (request).\n\nNow, every time a guest (request) receives a response, they'll also get a personalized signature. This showcases how custom middleware empowers you to tailor the experience for your guests (requests), leaving a lasting impression.\n\nWith custom middleware, you're not just throwing a party; you're crafting an unforgettable experience. Next, we'll learn how to manage the flow of middleware and explore its impact on the overall party atmosphere—your Express.js application.\n\nLet's envision our mansion party as a sequence of elegantly themed rooms, each offering a unique experience.\n\nJust like our rooms, Express.js applications arrange middleware functions in organized chains.\n\nThese chains are like a curated journey where guests (requests) traverse through various rooms, each showcasing a distinct facet of the party.\n\nBy organizing them thoughtfully, you ensure guests have a delightful and seamless transition, much like a well-designed sequence of experiences.\n\nHere's how you might structure middleware chains for different routes in your Express.js app:\n\nJust as you'd carefully orchestrate the sequence of party activities, the order in which middleware functions are executed matters in Express.js.\n\nMiddleware functions are processed in the order they're added using app.use().\n\nThink of it as arranging guests' activities to ensure they enjoy the party to the fullest.\n\nConsider a scenario: You have a middleware that logs guest preferences and another that provides personalized recommendations.\n\nThe logging middleware should come before the recommendation middleware to gather data before making suggestions.\n\nHere's how the order of middleware execution impacts the outcome:\n\nImagine you're hosting two events in different rooms: a formal dinner in one and a live concert in another.\n\nYou decide to have an attire-checking station. If you place the attire-checking middleware after guests enter the formal dinner, it won't be effective, and guests might not meet the dress code.\n\nSimilarly, in Express.js, understanding middleware order prevents issues like serving static assets before authentication.\n\nHere's how to handle middleware order to ensure efficient execution:\n\nBy meticulously arranging middleware functions, you create a symphony of experiences for your guests (requests). Just as orchestrating activities enhances a grand party, managing middleware order elevates the user experience and ensures a seamless flow through your Express.js application.\n\nWrapping up, here’s a simple Express.js server example for you to visualize chaining organization:\n\nIn this example, we've created an Express.js server with three middleware functions: logMiddleware, recommendationMiddleware, and checkAttireMiddleware. These middlewares are organized in chains for different routes: /public and /private.\n\nThe order of middleware execution and their roles can be observed as you interact with the different routes.\n\nThis simple server showcases how middleware functions are organized, executed, and contribute to the overall flow of your Express.js application.\n\nErrors are an inevitable part of any software application, much like unexpected mishaps during a grand party.\n\nLet's imagine our mansion party in full swing, with guests enjoying different rooms and activities. Just as a party may encounter unforeseen mishaps, errors can occur in your Express.js application. Handling these errors gracefully is crucial to maintaining a pleasant experience.\n\nConsider our host role as the guardian of the party's smooth flow. Similarly, error-handling middleware acts as the party planner who quickly resolves issues without disrupting the festivities. To implement error handling, you need to create a middleware that handles errors and gracefully guides guests (requests) through unexpected situations.\n\nHere's how you might craft an error-handling middleware:\n\nIn Express.js, middleware functions serve various purposes, and it's crucial to differentiate between standard middleware and error-handling middleware.\n\nStandard middleware is designed to enhance the user experience and carry out tasks such as parsing request data, handling authentication, and serving static assets.\n\nOn the other hand, error-handling middleware is dedicated to addressing errors that might occur during the request-response cycle.\n\nIt's specifically designed to gracefully manage unexpected situations and prevent them from disrupting the application's functionality.\n\nImagine you're hosting a grand masquerade ball. While most rooms are designed for enjoyment, there's an emergency station where staff address unexpected issues. Similarly, in Express.js, standard middleware focuses on enhancing the experience, while error-handling middleware specifically handles errors.\n\nJust as a dedicated emergency station ensures the safety of the event, error-handling middleware safeguards your application's stability. This differentiation ensures that even when unexpected errors arise, your guests (requests) are well taken care of.\n\n6.3 Best practices for error handling and responses\n\nJust as impeccable service and clear communication ensure guest satisfaction at a party, effective error handling in your application is a reflection of professionalism. When it comes to error handling and responses, consider the following best practices:\n\nLogging Errors: In the event of an error, log relevant information using console.error() or a logging library. This provides valuable insights for debugging and improving your application.\n\nHTTP Status Codes: Assign appropriate HTTP status codes to your responses. For example, use res.status(404).send(\"Resource not found\") for a resource that doesn't exist. Consistent status codes help clients understand the nature of the error.\n\nDetailed Error Messages: Provide detailed error messages in responses to aid both developers and users in understanding what went wrong. You can use JSON responses for this purpose.\n\nIn our mansion party, impeccable service is a priority. Similarly, when handling errors in Express.js, maintaining professionalism and providing clear responses is essential. Error-handling middleware can log errors, provide appropriate HTTP status codes, and send detailed error messages.\n\nBy following this practices, you assure guests (requests) that you're on top of the situation, just like our party planner swiftly addressing unexpected hiccups.\n\nSecurity is paramount in any event, and our Express.js application's security is no different.\n\nIn this section, we're putting on our bouncer hats to ensure only authorized guests are allowed to enjoy the party.\n\nJust as bouncers verify guests' identities and grant access, authentication and authorization middleware verify users' permissions within our application.\n\nAuthentication is like checking the guest list before granting entry to the mansion party.\n\nThis process ensures only authorized users gain access to protected areas of the application.\n\nHere's how you might implement a basic authentication middleware:\n\nAuthorization is akin to granting different access levels based on guests' invitations.\n\nAuthorization middleware in Express.js controls what specific users can and cannot do within the application.\n\nJust as certain rooms are off-limits to certain guests, authorization middleware limits access to particular routes.\n\nMiddleware, including authentication and authorization, acts as our vigilant security personnel throughout the party.\n\nJust as bouncers ensure a safe and enjoyable experience for guests, middleware safeguards our application by preventing unauthorized access and malicious activities.\n\nIt's a crucial component in the defense against potential security threats.\n\nBy implementing authentication and authorization middleware, you're fortifying your Express.js application against unauthorized access and ensuring that only authorized users can access specific routes and perform authorized actions.\n\nIt's like having a team of trusted bouncers guarding your party's VIP section and ensuring a secure environment for all guests.\n\nAs our mansion party continues, we're thrilled to introduce our special VIP guests—third-party middleware modules. These modules bring their own unique talents to the table, just like guest performers at a grand event.\n\nThird-party middleware enhances your Express.js application with powerful features, and today, we're focusing on one of the headliners: the helmet middleware.\n\nImagine third-party middleware as top-notch entertainers at your event.\n\nThey come with their acts, saving you time and effort. Developed by the community, these modules seamlessly enhance your Express.js application. Let's dive into the star of the show: helmet.\n\nLet's showcase the superstar helmet middleware and how it empowers your application's security.\n\nThe `helmet` middleware is like your party's security team, ensuring every corner is safe.\n\nIt provides powerful security features by setting essential HTTP headers that mitigate various vulnerabilities and attacks.\n\nJust as a vigilant security team monitors guests, helmet monitors your application's security. Consider the powerful Content-Security-Policy header it adds. This header prevents cross-site scripting (XSS) and other attacks by defining where resources can be loaded from.\n\nFor instance, the following code configures the script-src directive:\n\nWith this code, only scripts from your application and example.com are allowed, preventing unauthorized script execution.\n\nNow, let's shift our focus to another esteemed guest: the morgan middleware.\n\nThink of morgan as the event's official photographer, capturing every intricate detail by logging incoming requests and responses.\n\nIn the spirit of having a dedicated photographer at your event, morgan diligently logs essential details of each guest's arrival and departure.\n\nThis middleware can be tailored to log specific aspects of incoming requests and responses.\n\nFor instance, this code snippet captures the request method, URL, status, response time, and more:\n\nWith this setup, every log entry offers concise yet informative insights about incoming requests—akin to the photographs that capture memorable moments of your event.\n\nIn this extended example, we've introduced a custom token user-ip using morgan.token().\n\nThis token captures the user's IP address, whether it's obtained from the x-forwarded-for header or the remote address of the connection.\n\nThen, we've defined a custom logging format named customFormat that includes the :method, :url, :status, :response-time, and the custom :user-ip tokens.\n\nBy utilizing this custom logging format, you're creating logs that provide detailed insights into each request's method, URL, status code, response time, and the user's IP address.\n\nThis richer information can be incredibly valuable for diagnosing issues, monitoring performance, and gaining a deeper understanding of how your application is being used.\n\nRemember that these examples are meant to be adaptable to your specific needs. By customizing the format and tokens, you can tailor the logging to suit your application's unique requirements.\n\nOur final guest is the cors middleware, managing interactions with guests from various domains. Just as your party welcomes attendees from diverse backgrounds, cors facilitates cross-origin communication by adding necessary headers.\n\nIn this example, we've imported the cors middleware and used app.use(cors()) to enable CORS for all routes. By doing this, your Express app will include the necessary CORS headers in its responses, allowing cross-origin requests from any origin.\n\nThis is a basic example, but you can customize the behavior of cors by passing in options. For instance, you can specify which origins are allowed, what headers are permitted, and more. The cors middleware is a powerful tool for handling cross-origin requests securely and efficiently.\n\nBy inviting these VIP guests —helmet, morgan, and cors— to your application, you enhance its security, logging capabilities, and cross-origin communication.\n\nSimilar to how special performers elevate your party's atmosphere, third-party middleware enriches your Express.js application with powerful functionalities.\n\nOne of the key principles in developing middleware is to ensure that each middleware function has a clear and single-purpose responsibility. This enhances code organization and maintainability, making it easier to understand and modify the behavior of your application.\n\nConsider an authentication middleware. Instead of combining authentication and authorization checks within a single middleware, separate them into two distinct middleware functions.\n\nThis approach keeps the responsibilities clear and makes it easier to manage each aspect individually.\n\n9.2 Judicious Use of Middleware for Code Readability\n\nWhile middleware can enhance code organization, excessive use can lead to overly complex pipelines.\n• Carefully consider whether a middleware is essential for every route.\n• Avoid using middleware for small, isolated tasks that can be handled inline.\n\nSuppose you have a route that requires sending an email notification. Instead of creating a separate middleware for this single task, handle it inline within the route handler for clarity.\n\nTesting and debugging middleware is crucial to ensure that your application functions as expected. Isolate middleware testing and use tools like chai, mocha, or jest to write comprehensive tests for various scenarios.\n\nUse debugging tools to troubleshoot middleware behavior and catch errors.\n\nWhen testing a middleware, consider using a mock request and response to simulate different scenarios and assertions.\n\nBy adhering to these best practices, your middleware usage becomes more effective, promotes maintainable code, and ensures reliable application behavior.\n\nRemember that flexibility and adaptability are key; tailor these practices to your application's specific requirements.\n\nCongratulations! You've finished a comprehensive journey through the world of Express.js middleware.\n\nWe've explored the fundamental concepts, practical applications, and best practices that empower you to build robust and efficient web applications.\n\nAs you've seen, middleware plays a crucial role in enhancing your app's functionality, security, and maintainability.\n\nBy mastering middleware, you've gained the ability to seamlessly integrate various functionalities into your application's request-response cycle.\n\nWhether you're handling data parsing, logging, authentication, security, or any custom functionality, middleware empowers you to customize your app's behavior at different stages.\n\nAs you continue refining your skills and honing your expertise, remember to maintain the principles of focused and single-purpose middleware functions.\n\nKeep your code readable by judiciously choosing when to use middleware and when to handle tasks inline.\n\nTesting and debugging middleware ensures your app's reliability and stability.\n\nThank you for investing your time in this exploration of Express.js middleware.\n\nRemember that this is just the beginning of your journey.\n\nKeep building, experimenting, and exploring the ever-evolving world of web development.\n\nIf you enjoyed this article and want to explore more about web development, feel free to connect with me on various platforms:\n\nYour feedback and questions are always welcome."
    },
    {
        "link": "https://codewithpawan.medium.com/authentication-and-authorization-in-node-js-a-comprehensive-guide-2755b57dce27",
        "document": "Authentication and authorization are two fundamental concepts in web application security. They ensure that users have the right level of access to resources while protecting sensitive data. In this guide, we’ll explore how to implement authentication and authorization in Node.js applications, covering best practices, popular libraries, and strategies for securing your Node.js projects.\n\nBefore diving into authentication and authorization, make sure you have Node.js installed on your system. You can download it from the official website: Node.js Downloads.\n\nAuthentication is the process of verifying the identity of a user, ensuring they are who they claim to be. This is typically achieved through the use of credentials, such as usernames and passwords.\n• Use HTTPS: Always use HTTPS to secure data transmission between the client and server, especially when handling login credentials.\n• Password Hashing: Store passwords securely by hashing and salting them. Libraries like can help with this.\n• Multi-Factor Authentication (MFA): Implement MFA to add an extra layer of security. This could involve something the user knows (password) and something they have (e.g., a mobile app token).\n• Session Management: Use secure and random session tokens to manage user sessions.\n\nPassport.js is a widely-used authentication library for Node.js. It supports various authentication strategies, including local (username and password), OAuth, and OpenID. Here’s how to set up Passport.js for local authentication:\n\nJSON Web Tokens are a popular way to implement authentication and authorization in Node.js. Users receive a token upon login, which they include in subsequent requests. Here’s a simple example using the library:\n\nAuthorization defines what actions a user is allowed to perform after they’ve been authenticated. It involves granting or denying access to specific resources or functionality.\n• Role-Based Access Control (RBAC): Implement RBAC to assign roles (e.g., admin, user) to users and restrict access based on their roles.\n• Middleware: Use middleware functions to check a user’s permissions before granting access to a route or resource.\n• Access Tokens: Issue access tokens with user permissions encoded. Verify these tokens on the server-side for every request.\n\nHere’s a basic example of role-based authorization using middleware in Express.js:\n\nAuthentication and authorization are vital for securing your Node.js applications. By following best practices and using reliable libraries like Passport.js and JSON Web Tokens, you can create robust authentication and authorization systems. Remember to stay updated with the latest security developments and continuously monitor and improve your application’s security measures."
    },
    {
        "link": "https://geeksforgeeks.org/middleware-in-express-js",
        "document": "Middleware functions are the building blocks of any web server, especially in frameworks like ExpressJS. It plays a vital role in the request-response cycle. They are functions that have access to the request object (req), the response object (res), and the next function in the application’s request-response cycle.\n\nWhat is Middleware in Express?\n\nMiddleware in Express refers to functions that process requests before reaching the route handlers. These functions can modify request and response objects, end the request-response cycle, or call the next middleware function.\n• None Middleware functions are executed in the order they are defined.\n• None They can perform tasks like authentication, logging, or error handling.\n• (req, res, next) => {}: This is the middleware function where you can perform actions on the request and response objects before the final handler is executed.\n• next(): This function is called to pass control to the next middleware in the stack if the current one doesn’t end the request-response cycle.\n\nIn Express.js, middleware functions are executed sequentially in the order they are added to the application. When a request is received, it is passed through the middleware functions in the order they were defined. Each middleware can perform a task and either send a response or call the next() function to pass control to the next middleware function.\n\nHere’s how the typical flow looks:\n• Middleware functions are applied to the request, one by one.\n• None Each middleware can either:\n• Call next() to pass control to the next middleware.\n• None If no middleware ends the cycle, the route handler is reached, and a final response is sent.\n\nExpressJS offers different types of middleware and you should choose the middleware based on functionality required.\n• Application-level middleware: Bound to the entire application using app.use() app.METHOD() and executes for all routes.\n• Router-level middleware : Associated with specific routes using router.use() router.METHOD() and executes for routes defined within that router.\n• Error-handling middleware: Handles errors during the request-response cycle. Defined with four parameters (err, req, res, next).\n\nWhen you navigate to http://localhost:3000/, you will see:\n\nMiddleware can be chained from one to another, Hence creating a chain of functions that are executed in order. The last function sends the response back to the browser. So, before sending the response back to the browser the different middleware processes the request.\n\nThe next() function in the express is responsible for calling the next middleware function if there is one.\n\nModified requests will be available to each middleware via the next function\n• Middleware 1: Logs the HTTP method and URL of the incoming request.\n\nWhen a client makes a GET request to http://localhost:3000/, the server responds with:\n• Reusability: Middleware functions can be reused across different routes or applications.\n• Maintainability : Organizes code logically, making it easier to manage and update.\n• Performance Optimization : Allows for tasks like caching, compression, and security checks to be handled efficiently.\n\nBest Practices for Middleware in ExpressJS\n• None Always call next() to pass control to the next middleware unless you are ending the request-response cycle.\n• None Use specific middleware for different tasks (e.g., authentication, logging) to keep the code modular and clean.\n• None Place error-handling middleware at the end of the middleware stack to catch any unhandled errors.\n• None Avoid using synchronous code in middleware to prevent blocking the event loop.\n\nWhat is the purpose of next() in Express middleware?\n\nHow do I handle errors in middleware?\n\nCan middleware be applied to specific routes?\n\nIs it a good practice to have large middleware functions?\n\nHow can I avoid security issues with middleware?"
    },
    {
        "link": "https://stackoverflow.com/questions/14588032/mongoose-password-hashing",
        "document": "There is a better solution. The usual way is to do it with the following,\n\nproblem is, it doesn't work on update.\n\nSolution: I personally do it with my validator, eg: I am using zod for the following.\n\nSo, encrypt it when you are validating the inputs. Same when you want to update user data, use validator and encrypt password again.\n\nTips: SALT_WORK_FACTOR should be an integer, use 10 or up depending on your server performance"
    },
    {
        "link": "https://sivabharathy.in/blog/understanding-mongoose-pre-hooks",
        "document": "Mongoose pre hooks are middleware functions that run before certain operations, such as saving or validating a document. They are useful for a variety of tasks, including data validation, transformation, and managing related data.\n\nPre hooks allow you to:\n• Validate or sanitize data before it’s saved to the database.\n\nHere are some of the most commonly used pre hooks in Mongoose, along with examples.\n\nThis hook is triggered before a document is saved. It's often used to perform validation or modify data.\n\nThis hook is called before the validation occurs. It can be used to validate or modify fields prior to validation.\n\nTriggered before a document is removed, this hook can be useful for cleaning up related data.\n\nThis hook runs before a document is updated. It allows you to modify the update operation before it executes.\n\nThese hooks are triggered before and operations, allowing you to modify the query.\n\nThis hook runs before an aggregation operation, allowing you to modify the aggregation pipeline.\n\nTriggered before multiple documents are inserted, this hook allows for processing each document.\n\nPre hooks are defined within your schema. You can chain multiple pre hooks for a single event.\n• None Use : Always call at the end of your pre hook. If you encounter an error, pass it to .\n• None Be Cautious with : Inside pre hooks, refers to the document being processed. Make sure to handle it correctly, especially when using arrow functions, as they do not bind their own .\n• None Keep Logic Simple: Pre hooks should contain logic that is simple and does not perform heavy operations that could delay processing.\n\nMongoose pre hooks are powerful tools that help you enforce data integrity, perform validations, and manage related data effectively. By understanding and utilizing these hooks, you can create more robust and maintainable applications. Whether you’re hashing passwords, cleaning up data, or ensuring consistent formats, pre hooks can streamline your Mongoose workflows and enhance your application’s functionality."
    },
    {
        "link": "https://mongoosejs.com/docs/6.x/docs/api.html",
        "document": "\n• type The name of the type\n• value The value that failed to cast\n• path The path in the doc where this cast error occurred\n• [reason] The original error that was thrown\n• [options] passed down to the MongoDB driver's function, except for 4 mongoose-specific options explained below.\n• [options.bufferCommands=true] Mongoose specific option. Set to false to disable buffering on all models associated with this connection.\n• [options.bufferTimeoutMS=10000] Mongoose specific option. If is true, Mongoose will throw an error after if the operation is still buffered.\n• [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.\n• [options.user] username for authentication, equivalent to . Maintained for backwards compatibility.\n• [options.pass] password for authentication, equivalent to . Maintained for backwards compatibility.\n• [options.maxPoolSize=100] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See Slow Trains in MongoDB and Node.js.\n• [options.minPoolSize=0] The minimum number of sockets the MongoDB driver will keep open for this connection.\n• [options.serverSelectionTimeoutMS] If , the MongoDB driver will try to find a server to send any given operation to, and keep retrying for milliseconds before erroring out. If not set, the MongoDB driver defaults to using (30 seconds).\n• [options.heartbeatFrequencyMS] If , the MongoDB driver sends a heartbeat every to check on the status of the connection. A heartbeat is subject to , so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits . We recommend you do not set this setting below 1000, too many heartbeats can lead to performance degradation.\n• [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n• [options.connectTimeoutMS=30000] How long the MongoDB driver will wait before killing a socket due to inactivity during initial connection. Defaults to 30000. This option is passed transparently to Node.js' function.\n• [options.socketTimeoutMS=30000] How long the MongoDB driver will wait before killing a socket due to inactivity after initial connection. A socket may be inactive because of either no activity or a long-running operation. This is set to by default, you should set this to 2-3x your longest running operation if you expect some of your database operations to run longer than 20 seconds. This option is passed to Node.js function after the MongoDB driver successfully completes.\n• [options.family=0] Passed transparently to Node.js' function. May be either , , or . means use IPv4 only, means use IPv6 only, means try both.\n• [options.autoCreate=false] Set to to make Mongoose automatically call on every model created on this connection.\n• [options] passed down to the MongoDB driver's function, except for 4 mongoose-specific options explained below.\n• [options.bufferCommands=true] Mongoose specific option. Set to false to disable buffering on all models associated with this connection.\n• [options.dbName] The name of the database you want to use. If not provided, Mongoose uses the database name from connection string.\n• [options.user] username for authentication, equivalent to . Maintained for backwards compatibility.\n• [options.pass] password for authentication, equivalent to . Maintained for backwards compatibility.\n• [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n• [options.maxPoolSize=5] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See Slow Trains in MongoDB and Node.js.\n• [options.minPoolSize=1] The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See Slow Trains in MongoDB and Node.js.\n• [options.connectTimeoutMS=30000] How long the MongoDB driver will wait before killing a socket due to inactivity during initial connection. Defaults to 30000. This option is passed transparently to Node.js' function.\n• [options.socketTimeoutMS=30000] How long the MongoDB driver will wait before killing a socket due to inactivity after initial connection. A socket may be inactive because of either no activity or a long-running operation. This is set to by default, you should set this to 2-3x your longest running operation if you expect some of your database operations to run longer than 20 seconds. This option is passed to Node.js function after the MongoDB driver successfully completes.\n• [options.family=0] Passed transparently to Node.js' function. May be either , , or . means use IPv4 only, means use IPv6 only, means try both.\n• the created Connection object. Connections are not thenable, so you can't do . To await use instead.\n• name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n• [callback] called after all connection close, or when first error occurred.\n• resolves when all connections are closed, or rejects with the first error that occurred.\n• name model name or class extending Model\n• [schema] the schema to use.\n• [collection] name (optional, inferred from model name)\n• The model associated with . Mongoose will create the model if it doesn't already exist.\n• [fn] overwrites the function used to pluralize collection names\n• the current function used to pluralize collection names, defaults to the legacy function from .\n• key The name of the option or a object of multiple key-value pairs\n• value The value of the option, unused if \"key\" is a object\n• options.continueOnError by default. If set to , mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.\n• Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.\n• [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\n• obj plain object with paths to add, or another schema\n• [prefix] path to prefix the newly added paths with\n• alias the path(s) to use as an alias for\n• name the name of the discriminator\n• key The name of the Option to get the current value for\n• fields The Fields to index, with the order, available values:\n• [options.expires=null] Mongoose-specific syntactic sugar, uses ms to convert option into seconds for the in the above link.\n• [options.language_override=null] Tells mongodb to use the specified field instead of for parsing text indexes.\n• list of indexes defined in the schema\n• [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\n• name The Method Name for a single function, or a Object of \"string-function\" pairs.\n• paths List of Paths to omit for the new Schema\n• [options] Options to pass to the new Schema Constructor (same as ). Defaults to if not set.\n• path The name of the Path to get / set\n• [obj] The Type to set the path to, if provided the path will be SET, otherwise the path will be GET\n• paths List of Paths to pick for the new Schema\n• [options] Options to pass to the new Schema Constructor (same as ). Defaults to if not set.\n• [opts] Options to pass to the plugin\n• [opts.deduplicate=false] If true, ignore duplicate plugins (same argument using )\n• methodName The method name or regular expression to match method name\n• [options.document] If is a hook for both document and query middleware, set to to run on document middleware.\n• [options.query] If is a hook for both document and query middleware, set to to run on query middleware.\n• methodName The method name or regular expression to match method name\n• [options.document] If is a hook for both document and query middleware, set to to run on document middleware. For example, set to to apply this hook to rather than .\n• [options.query] If is a hook for both document and query middleware, set to to run on query middleware.\n• name name of the document method to call later\n• args arguments to pass to the method\n• key The name of the option to set the value to\n• [value] The value to set the option to, if not passed, the option will be reset to default\n• name The Method Name for a single function, or a Object of \"string-function\" pairs.\n• name The name of the Virtual\n• [options.ref] model name or model instance. Marks this as a populate virtual.\n• [options.localField] Required for populate virtuals. See populate virtual docs for more information.\n• [options.foreignField] Required for populate virtuals. See populate virtual docs for more information.\n• [options.justOne=false] Only works with populate virtuals. If truthy, will be a single doc or . Otherwise, the populate virtual will be an array.\n• [options.count=false] Only works with populate virtuals. If truthy, this populate virtual will contain the number of documents rather than the documents themselves when you .\n• [options.get=null] Adds a getter to this virtual to transform the populated doc.\n• name The name of the Virtual to get\n• Returns a Promise if no is given.\n• name of the collection\n• Returns a Promise if no is given.\n• name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n• Returns a Promise if no is given.\n• Returns a Promise if no is given.\n• name the model name or class extending Model\n• [collection] name of mongodb collection (optional) if not given it will be induced from model name\n• [options.overwriteModels=false] If true, overwrite existing models with the same name to avoid\n• uri The URI to connect with.\n• [options.bufferCommands=true] Mongoose specific option. Set to false to disable buffering on all models associated with this connection.\n• [options.bufferTimeoutMS=10000] Mongoose specific option. If is true, Mongoose will throw an error after if the operation is still buffered.\n• [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.\n• [options.user] username for authentication, equivalent to . Maintained for backwards compatibility.\n• [options.pass] password for authentication, equivalent to . Maintained for backwards compatibility.\n• [options.maxPoolSize=100] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See Slow Trains in MongoDB and Node.js.\n• [options.minPoolSize=0] The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See Slow Trains in MongoDB and Node.js.\n• [options.serverSelectionTimeoutMS] If , the MongoDB driver will try to find a server to send any given operation to, and keep retrying for milliseconds before erroring out. If not set, the MongoDB driver defaults to using (30 seconds).\n• [options.heartbeatFrequencyMS] If , the MongoDB driver sends a heartbeat every to check on the status of the connection. A heartbeat is subject to , so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits . We recommend you do not set this setting below 1000, too many heartbeats can lead to performance degradation.\n• [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n• [options.connectTimeoutMS=30000] How long the MongoDB driver will wait before killing a socket due to inactivity during initial connection. Defaults to 30000. This option is passed transparently to Node.js' function.\n• [options.socketTimeoutMS=30000] How long the MongoDB driver will wait before killing a socket due to inactivity after initial connection. A socket may be inactive because of either no activity or a long-running operation. This is set to by default, you should set this to 2-3x your longest running operation if you expect some of your database operations to run longer than 20 seconds. This option is passed to Node.js function after the MongoDB driver successfully completes.\n• [options.family=0] Passed transparently to Node.js' function. May be either 4 6 4 6 0` means try both.\n• [options.autoCreate=false] Set to to make Mongoose automatically call on every model created on this connection.\n• client The Client to set to be used.\n• [options.continueOnError] by default. If set to , mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.\n• Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.\n• promise that is fulfilled if Mongoose successfully committed the transaction, or rejects if the transaction was aborted or if Mongoose failed to commit the transaction. If fulfilled, the promise resolves to a MongoDB command result.\n• name The database name\n• [options.useCache=false] If true, cache results so calling multiple times with the same name only creates 1 connection object.\n• [options.noListener=false] If true, the connection object will not make the db listen to events on the original connection. See issue #9961.\n• [options] passed without changes to the MongoDB driver's function\n• path path or array of paths to check. throws if any of the given paths is not populated.\n• [values] optional values to . Convenient if you want to manually populate a path and assert that the path was populated in 1 call.\n• array of populated documents. Empty array if there are no populated documents associated with this document.\n• val increment by this value\n• [val] optional, overrides whether mongoose thinks the doc is deleted\n• whether mongoose thinks this doc is deleted.\n• path the field to mark as valid\n• path path or object of key/vals to set\n• val the value to set\n• [options] optionally specify options that modify the behavior of the set\n• [options.merge=false] if true, setting a nested path will merge existing values rather than overwrite the whole object. So becomes\n• When used as a getter (no argument), a boolean will be returned indicating the timestamps option state or if unset \"undefined\" will be used, otherwise will return \"this\"\n• [path] Specific Path to depopulate. If unset, will depopulate all paths on the Document. Or multiple space-delimited paths.\n• [doc] a document to compare. If falsy, will always return \"false\".\n• [options.virtuals=false] Apply virtuals before getting this path\n• [options.getters=true] If false, skip applying getters and just get the raw value\n• path the field to invalidate. For array elements, use the syntax, where is the 0-based index in the array.\n• err the error which states the reason was invalid\n• the current ValidationError, with all currently invalidated paths\n• [options.ignoreAtomics=false] If true, doesn't return true if path is underneath an array that was modified with atomic operations like\n• [scope] the scope to run validators with\n• [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for will not contain . If true, will return an array that contains .\n• obj the object to overwrite this document with\n• path either the path to populate or an object specifying all parameters, or either an array of those\n• [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's field.\n• [options] Options for the population query (sort, etc)\n• [options.populate=null] Recursively populate paths in the populated documents. See deep populate docs.\n• [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make retain and array entries.\n• [options.getters=false] if true, Mongoose will call any getters defined on the . By default, Mongoose gets the raw value of . For example, you would need to set this option to if you wanted to add a getter to your .\n• [options.clone=false] When you do , blog posts with the same author will share 1 copy of an doc. Enable this option to make Mongoose clone populated docs before assigning them.\n• [options.match=null] Add an additional filter to the populate query. Can be a filter object containing MongoDB query syntax, or a function that returns a filter object.\n• [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n• Returns a Promise if no is given.\n• [options.session=null] the session associated with this save operation. If not specified, defaults to the document's associated session.\n• [options.safe] (DEPRECATED) overrides schema's safe option. Use the option instead.\n• [options.validateBeforeSave] set to false to save without validating.\n• [options.validateModifiedOnly=false] If , Mongoose will only validate modified paths, as opposed to modified paths and paths.\n• [options.j] set to true for MongoDB to wait until this has been journaled before resolving the returned promise. Overrides the schema-level option\n• [options.wtimeout] sets a timeout for the write concern. Overrides the schema-level option.\n• [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to to skip that check. See restrictions on field names\n• [options.timestamps=true] if and timestamps are enabled, skip timestamps for this .\n• Returns undefined if used with callback or a Promise otherwise.\n• path path or object of key/vals to set\n• val the value to set\n• [options] optionally specify options that modify the behavior of the set\n• [options.flattenMaps=true] if true, convert Maps to POJOs. Useful if you want to the result.\n• [options.virtuals=false] if true, apply virtuals, including aliases. Use to just apply getters, not virtuals\n• [options.aliases=true] if , you can set to skip applying aliases. This option is a no-op if .\n• [options.minimize=true] if true, omit any empty objects from the output\n• [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n• [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n• [options.versionKey=true] if false, exclude the version key ( by default) from the output\n• [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to the result of .\n• [options.useProjection=false]\n• If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has in the schema.\n• [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See and the Mongoose lean tutorial.\n• [options.timestamps=null] If set to and schema-level timestamps are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n• [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n• [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n• [callback] optional callback called after validation completes, passing an error if one occurred\n• Returns a Promise if no is given.\n• [pathsToValidate] only validate the given paths\n• [options.validateModifiedOnly=false] If , Mongoose will only validate modified paths, as opposed to modified paths and paths.\n• [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n• ValidationError if there are errors during validation, or undefined if there is no error.\n• [fields] optional object containing the fields that were selected in the query which returned this document. You do not need to set this parameter to ensure Mongoose handles your query projection.\n• [skipId=false] optional boolean. If true, mongoose doesn't add an field to the document.\n• [pipeline] aggregation pipeline as an array of objects\n• obj object or document to apply defaults on\n• [options.timestamps] defaults to , when set to false, mongoose will not add/update timestamps to the documents.\n• [options.session=null] The session associated with this bulk write. See transactions docs.\n• [options.w=1] The write concern. See for more information.\n• [ops.updateOne.filter] Update the first document that matches this filter\n• [ops.updateOne.upsert=false] If true, insert a doc if none match\n• [ops.updateOne.timestamps=true] If false, do not apply timestamps to the operation\n• [ops.updateOne.collation] The MongoDB collation to use\n• [ops.updateOne.arrayFilters] The array filters used in\n• [ops.updateMany.filter] Update all the documents that match this filter\n• [ops.updateMany.upsert=false] If true, insert a doc if no documents match\n• [ops.updateMany.timestamps=true] If false, do not apply timestamps to the operation\n• [ops.updateMany.collation] The MongoDB collation to use\n• [ops.updateMany.arrayFilters] The array filters used in\n• [ops.deleteOne.filter] Delete the first document that matches this filter\n• [ops.deleteMany.filter] Delete all documents that match this filter\n• [ops.replaceOne.filter] Replace the first document that matches this filter\n• [ops.replaceOne.upsert=false] If true, insert a doc if no documents match\n• [options.ordered=true] If true, execute writes in order and stop at the first error. If false, execute writes in parallel and continue until all writes have either succeeded or errored.\n• [options.session=null] The session associated with this bulk write. See transactions docs.\n• [options.w=1] The write concern. See for more information.\n• [options.skipValidation=false] Set to true to skip Mongoose schema validation on bulk write operations. Mongoose currently runs validation on and operations by default.\n• [options.bypassDocumentValidation=false] If true, disable MongoDB server-side schema validation for all writes in this bulk.\n• [options.strict=null] Overwrites the option on schema. If false, allows filtering and writing fields not defined in the schema for all writes in this bulk.\n• [options.throwOnValidationError=false] If true and , throw an error if one of the operations failed validation, but all valid operations completed successfully.\n• resolves to a if the operation succeeds\n• options.ignoreCastErrors If set to will not throw a ValidationError and only return values that were successfully cast.\n• Returns if callback is specified, returns a promise if no callback.\n• docs Documents to insert, as a spread or array\n• [options] Options passed down to . To specify , must be an array, not a spread. See Model.save for available options.\n• [options] If string, same as .\n• [options.value] the string stored in the property. If not specified, Mongoose uses the parameter.\n• [options.clone=true] By default, clones the given . Set to to skip cloning.\n• [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n• [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to to make Mongoose use the discriminator schema's hooks instead.\n• [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to to make Mongoose use the discriminator schema's plugins instead.\n• id value of to query by\n• id value of to query by\n• id value of to query by\n• [options.session=null] The session associated with this query. See transactions docs.\n• [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n• [options.rawResult] if true, returns the raw result from the MongoDB driver\n• id value of to query by\n• [options.returnDocument='before'] Has two possible values, and . By default, it will return the document before the update was applied.\n• [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See and the Mongoose lean tutorial.\n• [options.session=null] The session associated with this query. See transactions docs.\n• [options.timestamps=null] If set to and schema-level timestamps are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n• [options.overwrite=false] By default, if you don't include any update operators in , Mongoose will wrap in for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding . An alternative to this would be using Model.findOneAndReplace({ _id: id }, update, options, callback).\n• [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n• [options.runValidators] if true, runs update validators on this command. Update validators validate the update operation against the model's schema\n• [options.setDefaultsOnInsert=true] If and are true, mongoose will apply the defaults specified in the model's schema if a new document is created\n• [options.rawResult] if true, returns the raw result from the MongoDB driver\n• [options.upsert=false] if true, and no documents found, insert a new document\n• [options.new=false] if true, return the modified document rather than the original\n• [options.session=null] The session associated with this query. See transactions docs.\n• [options.rawResult] if true, returns the raw result from the MongoDB driver\n• [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n• [options.session=null] The session associated with this query. See transactions docs.\n• [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n• [options.rawResult] if true, returns the raw result from the MongoDB driver\n• filter Replace the first document that matches this filter\n• [options.returnDocument='before'] Has two possible values, and . By default, it will return the document before the update was applied.\n• [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See and the Mongoose lean tutorial.\n• [options.session=null] The session associated with this query. See transactions docs.\n• [options.timestamps=null] If set to and schema-level timestamps are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n• [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n• [options.rawResult] if true, returns the raw result from the MongoDB driver\n• [options.returnDocument='before'] Has two possible values, and . By default, it will return the document before the update was applied.\n• [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See and the Mongoose lean tutorial.\n• [options.session=null] The session associated with this query. See transactions docs.\n• [options.timestamps=null] If set to and schema-level timestamps are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n• [options.overwrite=false] By default, if you don't include any update operators in , Mongoose will wrap in for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding . An alternative to this would be using Model.findOneAndReplace(conditions, update, options, callback).\n• [options.upsert=false] if true, and no documents found, insert a new document\n• [options.new=false] if true, return the modified document rather than the original\n• [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n• [options.runValidators] if true, runs update validators on this command. Update validators validate the update operation against the model's schema\n• [options.setDefaultsOnInsert=true] If and are true, mongoose will apply the defaults specified in the model's schema if a new document is created\n• [options.rawResult] if true, returns the raw result from the MongoDB driver\n• [projection] optional projection containing which fields should be selected for this document\n• [options.ordered=true] if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An with is called an \"unordered\" .\n• [options.rawResult=false] if false, the returned promise resolves to the documents that passed mongoose document validation. If , will return the raw result from the MongoDB driver with a property that contains and if this is an unordered .\n• [options.lean=false] if , skips hydrating the documents. This means Mongoose will not cast or validate any of the documents passed to . This option is useful if you need the extra performance, but comes with data integrity risk. Consider using with .\n• [options.limit=null] this limits the number of documents being processed (validation/casting) by mongoose in parallel, this does NOT send the documents in batches to MongoDB. Use this option if you're processing a large number of documents and your app is running out of memory.\n• [options.populate=null] populates the result documents. This option is a no-op if is set.\n• [options.throwOnValidationError=false] If true and , throw an error if one of the operations failed validation, but all valid operations completed successfully.\n• resolving to the raw result from the MongoDB driver if was , or the documents that passed validation, otherwise\n• Returns if callback is specified, returns a promise if no callback.\n• [opts.jsMode=false] it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X\n• [opts.out] sets the output target for the map reduce job\n• [opts.out.inline=1] the results are returned in an array\n• [opts.out.replace] add the results to collectionName: the results replace the collection\n• [opts.out.reduce] add the results to collectionName: if dups are detected, uses the reducer / finalize functions\n• [opts.out.merge] add the results to collectionName: if dups exist the new docs overwrite the old\n• docs Either a single document or array of documents to populate.\n• options Either the paths to populate or an object specifying all parameters\n• [options.populate=null] Recursively populate paths in the populated documents. See deep populate docs.\n• [options.retainNullValues=false] By default, Mongoose removes null and undefined values from populated arrays. Use this option to make retain and array entries.\n• [options.getters=false] If true, Mongoose will call any getters defined on the . By default, Mongoose gets the raw value of . For example, you would need to set this option to if you wanted to add a getter to your .\n• [options.clone=false] When you do , blog posts with the same author will share 1 copy of an doc. Enable this option to make Mongoose clone populated docs before assigning them.\n• [options.match=null] Add an additional filter to the populate query. Can be a filter object containing MongoDB query syntax, or a function that returns a filter object.\n• [options.skipInvalidIds=false] By default, Mongoose throws a cast error if and schemas don't line up. If you enable this option, Mongoose will instead filter out any properties that cannot be casted to 's schema type.\n• [options.perDocumentLimit=null] For legacy reasons, with may give incorrect results because it only executes a single query for every document being populated. If you set , Mongoose will ensure correct per document by executing a separate query for each document to . For example, will execute 2 additional queries if returns 2 documents.\n• [options.strictPopulate=true] Set to false to allow populating paths that aren't defined in the given model's schema.\n• [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n• [callback(err,doc)] Optional callback, executed upon completion. Receives and the .\n• [options.session=null] the session associated with this operation. If not specified, defaults to the document's associated session.\n• [options.session=null] the session associated with this save operation. If not specified, defaults to the document's associated session.\n• [options.safe] (DEPRECATED) overrides schema's safe option. Use the option instead.\n• [options.validateBeforeSave] set to false to save without validating.\n• [options.validateModifiedOnly=false] if , Mongoose will only validate modified paths, as opposed to modified paths and paths.\n• [options.j] set to true for MongoDB to wait until this has been journaled before resolving the returned promise. Overrides the schema-level option\n• [options.wtimeout] sets a timeout for the write concern. Overrides the schema-level option.\n• [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to to skip that check. See restrictions on field names\n• [options.timestamps=true] if and timestamps are enabled, skip timestamps for this .\n• Returns undefined if used with callback or a Promise otherwise.\n• [options.session=null] the session associated with this operation.\n• [options.upsert=false] if true, and no documents found, insert a new document\n• [options.writeConcern=null] sets the write concern for replica sets. Overrides the schema-level write concern\n• [options.timestamps=null] If set to and schema-level timestamps are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n• [options.background=null] if specified, overrides each index's property\n• Returns if callback is specified, returns a promise if no callback, when the Promise resolves the value is a list of the dropped indexes.\n• fields fields/conditions that may contain aliased keys\n• [options.upsert=false] if true, and no documents found, insert a new document\n• [options.writeConcern=null] sets the write concern for replica sets. Overrides the schema-level write concern\n• [options.multi=false] whether multiple documents should be updated or just the first one that matches .\n• [options.runValidators=false] if true, runs update validators on this command. Update validators validate the update operation against the model's schema.\n• [options.setDefaultsOnInsert=false] by default. If and are true, mongoose will apply the defaults specified in the model's schema if a new document is created.\n• [options.timestamps=null] If set to and schema-level timestamps are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n• [options.overwrite=false] By default, if you don't include any update operators in , Mongoose will wrap in for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding .\n• [options.upsert=false] if true, and no documents found, insert a new document\n• [options.writeConcern=null] sets the write concern for replica sets. Overrides the schema-level write concern\n• [options.timestamps=null] If set to and schema-level timestamps are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n• [callback] where has 5 properties: , , , , and .\n• [options.upsert=false] if true, and no documents found, insert a new document\n• [options.writeConcern=null] sets the write concern for replica sets. Overrides the schema-level write concern\n• [options.timestamps=null] If set to and schema-level timestamps are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n• [options.hydrate=false] if true and is set, Mongoose will automatically hydrate into a fully fledged Mongoose document\n• val1 Lower Left Coordinates OR a object of lower-left(ll) and upper-right(ur) Coordinates\n• [model] the model to cast to. If not set, defaults to\n• err if set, will fail fast before sending the query to MongoDB\n• [callback] optional params depend on the function being called\n• [verbose] The verbosity mode. Either 'queryPlanner', 'executionStats', or 'allPlansExecution'. The default is 'queryPlanner'\n• [filter] mongodb selector. If not specified, returns all documents.\n• [options.rawResult] if true, returns the raw result from the MongoDB driver\n• [options.session=null] The session associated with this query. See transactions docs.\n• [options.rawResult] if true, returns the raw result from the MongoDB driver\n• [options.session=null] The session associated with this query. See transactions docs.\n• [options.rawResult] if true, returns the raw result from the MongoDB driver\n• [options.session=null] The session associated with this query. See transactions docs.\n• [options.new=false] By default, returns the document as it was before was applied. If you set , will instead give you the object after was applied.\n• [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See and the Mongoose lean tutorial.\n• [options.session=null] The session associated with this query. See transactions docs.\n• [options.timestamps=null] If set to and schema-level timestamps are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n• [options.returnOriginal=null] An alias for the option. is equivalent to .\n• [options.rawResult] if true, returns the raw result from the MongoDB driver\n• [options.session=null] The session associated with this query. See transactions docs.\n• [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n• [options.new=false] By default, returns the document as it was before was applied. If you set , will instead give you the object after was applied.\n• [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See and the Mongoose lean tutorial.\n• [options.session=null] The session associated with this query. See transactions docs.\n• [options.timestamps=null] If set to and schema-level timestamps are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n• [options.returnOriginal=null] An alias for the option. is equivalent to .\n• [callback] optional params are (error, doc), unless is used, in which case params are (error, writeOpResult)\n• object Must contain a property which is a String and a property which is an Array. See the examples.\n• path path or object of key/value pairs to get\n• val must be of length 2, first element is , 2nd element is .\n• options if specified, overwrites the current options\n• [err] optional error to throw if no docs match . If not specified, will throw a\n• path either the path(s) to populate or an object specifying all parameters\n• [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's field.\n• [options] Options for the population query (sort, etc)\n• [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make retain and array entries.\n• [options.getters=false] if true, Mongoose will call any getters defined on the . By default, Mongoose gets the raw value of . For example, you would need to set this option to if you wanted to add a getter to your .\n• [options.clone=false] When you do , blog posts with the same author will share 1 copy of an doc. Enable this option to make Mongoose clone populated docs before assigning them.\n• [options.match=null] Add an additional filter to the populate query. Can be a filter object containing MongoDB query syntax, or a function that returns a filter object.\n• [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n• pref one of the listed preference options or aliases\n• level one of the listed read concern level or their aliases\n• [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n• [options.upsert=false] if true, and no documents found, insert a new document\n• [options.writeConcern=null] sets the write concern for replica sets. Overrides the schema-level write concern\n• [options.timestamps=null] If set to and schema-level timestamps are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n• path path or object of key/value pairs to set\n• [val] the value to set\n• val number of elements to slice or array with number of elements to skip and number of elements to slice\n• [opts.awaitData] false by default. Set to true to keep the cursor open even if there's no data.\n• [opts.maxAwaitTimeMS] the maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. Requires and to be true\n• fn function to run to transform the query result\n• [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n• [options.upsert=false] if true, and no documents found, insert a new document\n• [options.writeConcern=null] sets the write concern for replica sets. Overrides the schema-level write concern\n• [options.timestamps=null] If set to and schema-level timestamps are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n• [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n• [options.upsert=false] if true, and no documents found, insert a new document\n• [options.writeConcern=null] sets the write concern for replica sets. Overrides the schema-level write concern\n• [options.timestamps=null] If set to and schema-level timestamps are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n• [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n• [options.upsert=false] if true, and no documents found, insert a new document\n• [options.writeConcern=null] sets the write concern for replica sets. Overrides the schema-level write concern\n• [options.timestamps=null] If set to and schema-level timestamps are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n• val 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or any of the more advanced options.\n• writeConcern the write concern value to set\n• [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n• [options.batchSize] if set, will call with arrays of documents with length at most\n• [options.continueOnError=false] if true, iterates through all docs even if throws an error. If false, throws an error immediately if the given function throws an error.\n• [callback] executed when all docs have been processed\n• [pipeline] aggregation pipeline as an array of objects\n• [model] the model to use with this aggregate.\n• value Should tell server it can use hard drive to store data during aggregation.\n• ...ops operator(s) to append. Can either be a spread of objects or a single parameter of a object array.\n• fieldName The name of the output field which has the count as its value. It must be a non-empty string, must not start with $ and must not contain the . character.\n• [options.useMongooseAggCursor] use experimental mongoose-specific aggregation cursor (for and other query cursor semantics)\n• Returns a Promise if no \"callback\" is given.\n• [callback] The callback function to call, if not specified, will return a Promise instead.\n• Returns a promise if no \"callback\" is given\n• options to $graphLookup as described in the above link\n• value a hint object or the index name\n• num maximum number of records to pass to the next stage\n• options to $lookup as described in the above link\n• [model] Set the model associated with this aggregate. If not provided, returns the already stored model.\n• [options.maxTimeMS] number limits the time this aggregation will run, see MongoDB docs on\n• [options.allowDiskUse] boolean if true, the MongoDB server will use the hard drive to store data during this aggregation\n• The current pipeline similar to the operation that will be executed\n• pref one of the listed preference options or their aliases\n• level one of the listed read concern level or their aliases\n• newRoot the field or document which will become the new root document\n• num number of records to skip before next stage\n• options to $unionWith query as described in the above link\n• fields the field(s) to unwind, either as field names or as objects with options. If passing a string, prefixing the field name with '$' is optional. If passing an object, must start with '$'.\n• [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n• [callback] executed when all docs have been processed\n• caster Function that casts arbitrary values to this type, or throws an error if casting failed\n• [fn] If set, will overwrite the current set function\n• The input or the already set function\n• value value to cast\n• caster Function that casts arbitrary values to this type, or throws an error if casting failed\n• val The default value to set\n• If no validators, returns the output from calling , otherwise no return\n• ref either a model name, a Model, or a function that returns a model name or model.\n• required enable/disable the validator, or function that returns required boolean, or options object\n• [options.isRequired] enable/disable the validator, or function that returns required boolean\n• [options.ErrorConstructor] custom error constructor. The constructor receives 1 parameter, an object containing the validator properties.\n• [obj.validator] validator function. If the validator function returns or a truthy value, validation succeeds. If it returns falsy (except ) or throws an error, validation fails.\n• [obj.message] optional error message. If function, should return the error message as a string\n• [obj.propsParameter=false] If true, Mongoose will pass the validator properties object (with the function, , etc.) as the 2nd arg to the validator function. This is disabled by default because many validators rely on positional args, so turning this on may cause unpredictable behavior in external validators.\n• [errorMsg] optional error message. If function, should return the error message as a string\n• option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n• value The value of the option you'd like to set.\n• [options.ref] if is not nullish, this becomes a populated virtual\n• [options.localField] the local field to populate on if this is a populated virtual.\n• [options.foreignField] the foreign field to populate on if this is a populated virtual.\n• [options.justOne=false] by default, a populated virtual is an array. If you set , the populated virtual will be a single doc or .\n• [options.getters=false] if you set this to , Mongoose will call any custom getters you defined on this virtual\n• [options.count=false] if you set this to , will set this virtual to the number of populated documents, as opposed to the documents themselves, using\n• [options.perDocumentLimit=null] For legacy reasons, with may give incorrect results because it only executes a single query for every document being populated. If you set , Mongoose will ensure correct per document by executing a separate query for each document to . For example, will execute 2 additional queries if returns 2 documents.\n• doc The document this virtual is attached to\n• the value after applying all getters\n• the value after applying all setters\n• option The option you'd like to set the value for\n• value value for option\n• schema fields to add to the schema for instances of this sub-class\n• [options] If string, same as .\n• [options.value] the string stored in the property. If not specified, Mongoose uses the parameter.\n• [options.clone=true] By default, clones the given . Set to to skip cloning.\n• the constructor Mongoose will use for creating instances of this discriminator model\n• option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n• value The value of the option you'd like to set.\n• schema fields to add to the schema for instances of this sub-class\n• [options] If string, same as .\n• [options.value] the string stored in the property. If not specified, Mongoose uses the parameter.\n• [options.clone=true] By default, clones the given . Set to to skip cloning.\n• the constructor Mongoose will use for creating instances of this discriminator model\n• option The option you'd like to set the value for\n• value value for option\n• obj the value to cast to this arrays SubDocument schema\n• the subdocument or null if not found.\n• [options] optional options to pass to each documents method call during conversion\n• [options.flattenMaps=false] set to to convert the map to a POJO rather than a native JavaScript map"
    },
    {
        "link": "https://stackoverflow.com/questions/43035070/hashed-passwords-are-not-being-saved-with-pre-save-hook-in-mongoose",
        "document": "I am using Postman to test an API that I am working on for a project. I am sending\n\nas the request body to this API route\n\nThis is my Users Schema\n\nThe pre save hook is supposed to encrypt the password and then save it to the password and confirmPassword fields. If I use Chrome debugger to set a breakpoint at the end of the pre save hook (where next() is called), and inspect this.password and this.confirmPassword, I see that they are set to the newly created hash, but when I check the database afterwards both of those fields are set to the original password string"
    },
    {
        "link": "https://srivastavayushmaan1347.medium.com/how-can-mongoose-middleware-ensure-data-integrity-and-security-in-your-mongodb-application-56f04adabab9",
        "document": "The Problem: Ensuring Data Integrity and Consistency in MongoDB\n\nImagine you are building a Node.js application that involves a user management system. Users can sign up, and you want to ensure that every user's email is unique and formatted correctly. You also want to hash users' passwords before storing them in the database for security reasons.\n\nWithout a systematic approach to enforce these rules, you might end up with inconsistent data, like duplicate emails or plain text passwords stored in your database. This is where Mongoose middleware can be a lifesaver.\n\nMongoose is an ODM (Object Data Modeling) library for MongoDB and Node.js. Middleware (also known as pre and post hooks) in Mongoose allows you to define functions that run at specific stages of the lifecycle of a document. Middleware is used to define functions that run before or after specific actions (like saving or validating a document) take place.\n\nWhy Do We Need Mongoose Middleware?\n• Data Validation and Consistency: Ensure that data meets specific criteria before it is saved to the database.\n• Data Transformation: Automatically transform data before it is saved (e.g., hashing passwords).\n• Logging and Analytics: Track changes to documents for logging or analytics purposes.\n• Cascade Deletes and Updates: Manage related documents when a document is updated or deleted.\n\nLet's tackle the problem of ensuring unique, correctly formatted emails and hashed passwords using Mongoose middleware.\n\nStep 1: Setting Up Mongoose and Defining the User Schema\n\nFirst, install Mongoose if you haven't already:\n\nNext, create a Mongoose schema for the user:\n\nTo ensure that passwords are hashed before saving, use the pre middleware on the save method:\n\nTo check if the email is unique before saving, use the pre middleware on the validate method:\n\nNow, create the User model and test the middleware:\n\nMongoose middleware is a powerful tool for enforcing data integrity, consistency, and security in your MongoDB applications. By using pre and post hooks, you can automate tasks like data validation, transformation, and logging, significantly reducing the risk of human error and ensuring that your application’s data remains clean and secure.\n\nIn our example, we tackled the common issues of ensuring unique emails and hashing passwords, demonstrating how Mongoose middleware can be used to solve real-world problems effectively."
    }
]