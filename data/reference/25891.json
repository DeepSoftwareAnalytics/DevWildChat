[
    {
        "link": "https://redux.js.org/usage/side-effects-approaches",
        "document": "By itself, a Redux store doesn't know anything about async logic. It only knows how to synchronously dispatch actions, update the state by calling the root reducer function, and notify the UI that something has changed. Any asynchronicity has to happen outside the store.\n\nRedux reducers must never contain \"side effects\". A \"side effect\" is any change to state or behavior that can be seen outside of returning a value from a function. Some common kinds of side effects are things like:\n‚Ä¢ Logging a value to the console\n‚Ä¢ Modifying some state that exists outside of a function, or mutating arguments to a function\n‚Ä¢ Generating random numbers or unique random IDs (such as or )\n\nHowever, any real app will need to do these kinds of things somewhere. So, if we can't put side effects in reducers, where can we put them?\n\nRedux middleware were designed to enable writing logic that has side effects.\n\nA Redux middleware can do anything when it sees a dispatched action: log something, modify the action, delay the action, make an async call, and more. Also, since middleware form a pipeline around the real function, this also means that we could actually pass something that isn't a plain action object to , as long as a middleware intercepts that value and doesn't let it reach the reducers.\n\nMiddleware also have access to and . That means you could write some async logic in a middleware, and still have the ability to interact with the Redux store by dispatching actions.\n\nBecause of this, Redux side effects and async logic are normally implemented through middleware.\n\nIn practice, the single most common use case for side effects in a typical Redux app is fetching and caching data from the server.\n\nAnother use case more specific to Redux is writing logic that responds to a dispatched action or state change by executing additional logic, such as dispatching more actions.\n\nWe recommend using the tools that best fit each use case (see below for the reasons for our recommendations, as well as further details on each tool):\n\nPer the React docs section on \"alternatives for data fetching in Effects\", you should use either data fetching approaches that are built into a server-side framework, or a client-side cache. You should not write data fetching and cache management code yourself.\n\nRTK Query was specifically designed to be a complete data fetching and caching layer for Redux-based applications. It manages all the fetching, caching, and loading status logic for you, and covers many edge cases that are typically forgotten or hard to handle if you write data fetching code yourself, as well as having cache lifecycle management built-in. It also makes it simple to fetch and use data via the auto-generated React hooks.\n\nWe specifically recommend against sagas for data fetching because the complexity of sagas is not helpful, and you would still have to write all of the caching + loading status management logic yourself.\n\nWe've intentionally designed the RTK listener middleware to be straightforward to use. It uses standard syntax, covers most common reactive use cases (responding to actions or state changes, debouncing, delays), and even several advanced cases (launching child tasks). It has a small bundle size (~3K), is included with Redux Toolkit, and works great with TypeScript.\n\nWe specifically recommend against sagas or observables for most reactive logic for multiple reasons:\n‚Ä¢ Sagas: require understanding generator function syntax as well as the saga effects behaviors; add multiple levels of indirection due to needing extra actions dispatched; have poor TypeScript support; and the power and complexity is simply not needed for most Redux use cases.\n‚Ä¢ Observables: require understanding the RxJS API and mental model; can be difficult to debug; can add significant bundle size\n\nThe lowest-level technique for managing side effects with Redux is to write your own custom middleware that listens for specific actions and runs logic. However, that's rarely used. Instead, most apps have historically used one of the common pre-built Redux side effects middleware available in the ecosystem: thunks, sagas, or observables. Each of these has its own different use cases and tradeoffs.\n\nMore recently, our official Redux Toolkit package has added two new APIs for managing side effects: the \"listener\" middleware for writing reactive logic, and RTK Query for fetching and caching server state.\n\nThe Redux \"thunk\" middleware has traditionally been the most widely used middleware for writing async logic.\n\nThunks work by passing a function into . The thunk middleware intercepts the function, calls it, and passes in . The thunk function can now do any sync/async logic and interact with the store.\n\nThunks are best used for complex sync logic that needs access to and , or moderate async logic such as one-shot \"fetch some async data and dispatch an action with the result\" requests.\n\nWe have traditionally recommended thunks as the default approach, and Redux Toolkit specifically includes the API for the \"request and dispatch\" use case. For other use cases, you can write your own thunk functions.\n‚Ä¢ üëç: Just write functions; may contain any logic\n‚Ä¢ üëé: Can't respond to dispatched actions; imperative; can't be cancelled\n\nThe Redux-Saga middleware has traditionally been the second most common tool for side effects, after thunks. It's inspired by the backend \"saga\" pattern, where long-running workflows can respond to events triggered throughout the system.\n\nConceptually, you can think of sagas as \"background threads\" inside the Redux app, which have the ability to listen to dispatched actions and run additional logic.\n\nSagas are written using generator functions. Saga functions return descriptions of side effects and pause themselves, and the saga middleware is responsible for executing the side effect and resuming the saga function with the result. The library includes a variety of effects definitions such as:\n‚Ä¢ : executes an async function and returns the result when the promise resolves:\n‚Ä¢ : spawns a \"child saga\", like an additional thread that can do more work\n‚Ä¢ : listens for a given Redux action, triggers a saga function to execute, and cancels previous running copies of the saga if it's dispatched again\n\nSagas are extremely powerful, and are best used for highly complex async workflows that require \"background thread\"-type behavior or debouncing/cancelling.\n\nSaga users have often pointed to the fact that saga functions only return descriptions of the desired effects as a major positive that makes them more testable.\n‚Ä¢ üëç: Sagas are testable because they only return descriptions of effects; powerful effects model; pause/cancel capabilities\n‚Ä¢ üëé: generator functions are complex; unique saga effects API; saga tests often only test implementation results and need to be rewritten every time the saga is touched, making them a lot less valuable; do not work well with TypeScript;\n\nThe Redux-Observable middleware lets you use RxJS observables to create processing pipelines called \"epics\".\n\nSince RxJS is a framework-agnostic library, observable users point to the fact that you can reuse knowledge of how to use it across different platforms as a major selling point. In addition, RxJS lets you construct declarative pipelines that handle timing cases like cancellation or debouncing.\n\nSimilar to sagas, observables are powerful and best used for highly complex async workflows that require \"background thread\"-type behavior or debouncing/cancelling.\n‚Ä¢ üëç: Observables are a highly powerful data flow model; RxJS knowledge can be used separate from Redux; declarative syntax\n‚Ä¢ üëé: RxJS API is complex; mental model; can be hard to debug; bundle size\n\nRedux Toolkit includes the API to handle \"reactive\" logic. It's specifically intended to be a lighter-weight alternative to sagas and observables that handles 90% of the same use cases, with a smaller bundle size, simpler API, and better TypeScript support.\n\nConceptually, this is similar to React's hook, but for Redux store updates.\n\nThe listener middleware lets you add entries that match against actions to determine when to run the callback. Similar to thunks, an callback can be sync or async, and have access to and . They also receive a object with several primitives for building async workflows, such as:\n‚Ä¢ : pauses until a certain action is dispatched or state change occurs\n‚Ä¢ : creates a \"child task\" that can do additional work\n\nThese primitives allow listeners to replicate almost all of the effects behaviors from Redux-Saga.\n\nListeners can be used for a wide variety of tasks, such as lightweight store persistence, triggering additional logic when an action is dispatched, watching for state changes, and complex long-running \"background thread\"-style async workflows.\n\nIn addition, listener entries can be added and removed dynamically at runtime by dispatching special actions. This integrates nicely with React's hook, and can be used for adding additional behavior that corresponds to a component's lifetime.\n‚Ä¢ üëç: Built into Redux Toolkit; is more familiar syntax; similar to thunks; lightweight concepts and size; works great with TypeScript\n‚Ä¢ üëé: Relatively new and not as \"battle-tested\" yet; not quite as flexible as sagas/observables\n\nRedux Toolkit includes RTK Query, a purpose-built data fetching and caching solution for Redux apps. It's designed to simplify common cases for loading data in a web application, eliminating the need to hand-write data fetching & caching logic yourself.\n\nRTK Query relies on creating an API definition consisting of many \"endpoints\". An endpoint can be a \"query\" for fetching data, or a \"mutation\" for sending an update to the server. RTKQ manages fetching and caching data internally, including tracking usage of each cache entry and removing cached data that's no longer needed. It features a unique \"tag\" system for triggering automatic refetches of data as mutations update state on the server.\n\nLike the rest of Redux, RTKQ is UI-agnostic at its core, and can be used with any UI framework. However, it also comes with React integration built in, and can automatically generate React hooks for each endpoint. This provides a familiar and simple API for fetching and updating data from React components.\n\nRTKQ provides a -based implementation out of the box, and works great with REST APIs. It's also flexible enough to be used with GraphQL APIs, and can even be configured to work with arbitrary async functions, allowing integration with external SDKs such as Firebase, Supabase, or your own async logic.\n\nRTKQ also has powerful capabilities such as endpoint \"lifecycle methods\", allowing you to run logic as cache entries are added and removed. This can be used for scenarios like fetching initial data for a chat room, then subscribing to a socket for additional messages that are used to update the cache.\n\nRTK Query is specifically built to solve the use case of data fetching and caching of server state.\n‚Ä¢ üëç: Built into RTK; eliminates the need to write any code (thunks, selectors, effects, reducers) for managing data fetching and loading state; works great with TS; integrates into the rest of the Redux store; built-in React hooks\n\nGiven that thunks, sagas, observables, and listeners are all forms of Redux middleware (and RTK Query includes its own custom middleware), it's always possible to write your own custom middleware if none of these tools sufficiently handles your use cases.\n\nNote that we specifically recommend against trying to use custom middleware as a technique for managing the bulk of your app's logic! Some users have tried creating dozens of custom middleware, one per specific app feature. This adds significant overhead, as each middleware has to run as part of each call to . It's better to use a general-purpose middleware such as thunks or listeners instead, where there's a single middleware instance added that can handle many different chunks of logic.\n\nMany apps use websockets or some other form of persistent connection, primarily to receive streaming updates from the server.\n\nWe generally recommend that most websocket usage in a Redux app should live inside a custom middleware, for several reasons:\n‚Ä¢ Middleware exist for the lifetime of the application\n‚Ä¢ Like with the store itself, you probably only need a single instance of a given connection that the whole app can use\n‚Ä¢ Middleware can see all dispatched actions and dispatch actions themselves. This means a middleware can take dispatched actions and turn those into messages sent over the websocket, and dispatch new actions when a message is received over the websocket.\n‚Ä¢ A websocket connection instance isn't serializable, so it doesn't belong in the store state itself\n\nDepending on the needs of the application, you could create the socket as part of the middleware init process, create the socket on demand in the middleware by dispatching an initialization action, or create it in a separate module file so it can be accessed elsewhere.\n\nWebsockets can also be used in an RTK Query lifecycle callback, where they could respond to messages by applying updates to the RTKQ cache.\n\nState machines can be very useful for defining possible known states for a system and the possible transitions between each state, as well as triggering side effects when a transition occurs.\n\nRedux reducers can be written as true Finite State Machines, but RTK doesn't include anything to help with this. In practice, they tend to be partial state machines that really only care about the dispatched action to determine how to update the state. Listeners, sagas, and observables can be used for the \"run side effects after dispatch\" aspect, but can sometimes require more work to ensure a side effect only runs at a specific time.\n\nXState is a powerful library for defining true state machines and executing them, including managing state transitions based on events and triggering related side effects. It also has related tools for creating state machine definitions via a graphical editor, which can then be loaded into the XState logic for execution.\n\nWhile there currently is no official integration between XState and Redux, it is possible to use an XState machine as a Redux reducer, and the XState developers have created a useful POC demonstrating using XState as a Redux side effects middleware:\n‚Ä¢ Reason for middleware and side effects:\n‚Ä¢ \"How to dispatch a Redux action with a timeout?\"\n‚Ä¢ \"Why do we need middleware for async flow?\""
    },
    {
        "link": "https://blog.pixelfreestudio.com/how-to-handle-side-effects-in-state-management-with-redux-saga",
        "document": "Managing state in modern web applications can be challenging, particularly when it comes to handling side effects such as asynchronous API calls, timers, or complex workflows. In Redux-based applications, state is typically updated in a predictable and synchronous manner, but real-world applications require interacting with external data sources and managing side effects efficiently. This is where Redux Saga comes in.\n\nRedux Saga is a middleware library that helps you handle side effects in a Redux application by using generator functions, which allow you to write asynchronous code that looks synchronous. This not only improves the readability and maintainability of your code but also gives you more control over how your application‚Äôs side effects are managed.\n\nIn this article, we‚Äôll explore how to handle side effects in state management with Redux Saga. We‚Äôll cover how Redux Saga works, how to integrate it into a Redux application, and how to use it to manage complex side effects like API calls, retries, debouncing, and more.\n\nWhat are Side Effects in Redux?\n\nIn Redux, side effects refer to operations that happen outside of your Redux flow and interact with the outside world. This can include:\n\nTimers or delays (such as waiting for a certain period before executing a function).\n\nSide effects are called ‚Äúside effects‚Äù because they don‚Äôt fit into the pure, predictable flow of Redux. Redux reducers are expected to be pure functions, meaning they should always return the same output given the same input and have no side effects (such as fetching data or updating the DOM). To handle side effects, you need middleware like Redux Saga to manage those interactions while keeping your reducers pure.\n\nThere are several ways to handle side effects in Redux, such as using Redux Thunk or even managing side effects directly inside React components. However, Redux Saga offers a few key benefits that make it an attractive choice for complex applications:\n\nDeclarative control: With Redux Saga, you can write asynchronous logic in a declarative way, making your code easier to understand and maintain.\n\nEffect isolation: It isolates side effects from your components and reducers, which keeps your codebase clean and predictable.\n\nGenerator functions: Sagas use JavaScript generator functions, allowing you to handle asynchronous code in a synchronous-looking style, which simplifies error handling, retries, and cancellations.\n\nComplex workflows: Redux Saga excels in managing complex side effects such as parallel data fetching, task cancellation, retry logic, and debouncing API calls.\n\nWhen to Use Redux Saga\n\nRedux Saga is especially useful when:\n‚Ä¢ You have complex side effects like multiple API calls, parallel processing, or workflows that need cancellation or retry mechanisms.\n‚Ä¢ You want more fine-grained control over the flow of your asynchronous actions.\n‚Ä¢ You need to debounce or throttle actions, preventing unnecessary API requests or user input.\n‚Ä¢ Your application needs error recovery mechanisms, such as retrying failed network requests or handling errors gracefully.\n\nBefore diving into Redux Saga‚Äôs core functionality, let‚Äôs start with how to set it up in a Redux application.\n\nTo get started, install Redux Saga along with Redux:\n\nOr, if you prefer using Yarn:\n\nNext, set up a basic Redux store. If you already have a store, you can integrate Redux Saga into it. Otherwise, here‚Äôs a quick example of how to set up a Redux store with middleware:\n\nHere, we create the Redux store and apply the . We also run our root saga using , which will listen for actions dispatched by the Redux store and execute the corresponding saga.\n\nA saga is simply a generator function that listens for dispatched actions and runs side effects in response. Let‚Äôs write a basic saga to handle an API call.\n\nGenerator functions ( ): Sagas are written as generator functions, which allow you to pause and resume function execution, making asynchronous code easier to manage.\n\neffect: The effect is used to invoke a function (such as an API call). By yielding , Redux Saga knows to pause until the API request completes.\n\neffect: The effect dispatches an action to the Redux store. In this case, it dispatches either a success or failure action based on the result of the API call.\n\neffect: The effect listens for specific actions ( ) and triggers the every time this action is dispatched.\n\nThis pattern ensures that API calls (or any other side effects) are handled in a predictable, testable way, without cluttering your Redux reducers.\n\nRedux Saga becomes particularly useful when handling more complex side effects. Let‚Äôs look at some advanced techniques for managing side effects in real-world applications.\n\nSometimes, you need to make multiple API calls at once and wait for all of them to complete before proceeding. Redux Saga makes this easy with the effect, which allows you to run multiple effects in parallel.\n\nHere, both API calls are initiated simultaneously, and the saga waits for both responses before dispatching a success or failure action. This is especially useful when you need to fetch data from multiple sources concurrently.\n\nNetwork requests can fail for various reasons, but instead of immediately giving up, you may want to retry the request a few times before ultimately failing. Redux Saga provides the effect for this.\n\nIn this example, the saga will attempt to fetch data up to three times, waiting one second between each attempt. If all attempts fail, it will dispatch a failure action.\n\nThere are scenarios where you need to cancel an ongoing task, such as when a user navigates away from a page, or a new action supersedes the current task. Redux Saga allows you to cancel tasks using the effect.\n\nHere, creates a task that can be canceled. If the action is dispatched, the ongoing API call will be canceled, improving performance and user experience when a task is no longer relevant.\n\nDebouncing is a technique where you delay the execution of a function until a certain period has passed since the last event. This is useful for handling user input or preventing multiple API calls when typing.\n\nIn this example, the will only be executed if no new action is dispatched within 500 milliseconds. This avoids unnecessary API requests when users are typing in a search field.\n\nOne of the biggest advantages of Redux Saga is its testability. Since sagas use generator functions and yield effects, they can be easily tested without actually performing the side effects (like making API calls). You can simply test that the correct effects are yielded.\n\nHere‚Äôs an example of how to test the :\n\nThis test ensures that the saga behaves correctly when the API call succeeds. You can similarly test failure scenarios by simulating errors.\n\nWhile we‚Äôve covered the basics of Redux Saga, there are several advanced techniques that can take your side effect management to the next level. These techniques can help you optimize your application, improve maintainability, and make your sagas even more powerful and flexible. Let‚Äôs explore some of these advanced features and how to apply them effectively in your Redux Saga workflow.\n\n1. Using the Effect for Optimized Performance\n\nIn many cases, users trigger the same action multiple times in quick succession. For example, a user might click a button multiple times or type quickly into a search field, causing multiple API requests to be sent. To handle this efficiently, Redux Saga provides the effect, which ensures that only the latest action is handled and any previous unfinished requests are canceled.\n\nLet‚Äôs consider a search input where users are typing and triggering a action with each keystroke. You don‚Äôt want to fire an API call for every keystroke‚Äîinstead, you want only the latest request to be processed.\n\nHere, ensures that if a new action is dispatched while the previous one is still being processed, the previous request is canceled, and only the latest request is processed. This is particularly useful in scenarios like form submissions, search queries, or any action triggered by frequent user input.\n\nWhen your application needs to handle multiple sagas concurrently, Redux Saga‚Äôs effect allows you to run them in parallel. This is particularly useful when you have multiple side effects that can run independently of each other.\n\nLet‚Äôs say you need to load user data, notifications, and settings when a user logs in. You want all three data fetches to happen in parallel, rather than waiting for each one to complete before starting the next.\n\nIn this example, all three API calls (for user data, notifications, and settings) are made concurrently. The effect ensures that the sagas run in parallel, which speeds up the login process by fetching all the necessary data at the same time.\n\nThere are scenarios where you want to run multiple tasks but stop once one of them completes. For instance, you might want to cancel an API request if it takes too long or if the user navigates away from the page. In these cases, you can use the effect to create a ‚Äúrace‚Äù between sagas, where only the first saga to finish is considered.\n\nExample: Timeout for an API Request\n\nHere‚Äôs an example where an API request will automatically be canceled if it takes longer than 3 seconds.\n\nIn this example, if the API request takes more than 3 seconds ( ), the saga dispatches a failure action with a timeout message. Otherwise, it processes the response if the API request completes in time.\n\nSometimes you need to run multiple sagas in sequence, where the output of one saga is required by the next. This is common in multi-step processes such as completing a user onboarding flow or processing a multi-step form.\n\nLet‚Äôs say you need to create a new user, and then fetch additional data about that user from another API endpoint after the user is created.\n\nHere, the saga waits for the user to be created ( ) before making the second API call to fetch additional user data. This ensures that the second API call depends on the result of the first, preserving the sequence of actions.\n\nIn real-time applications, you may need to handle WebSocket connections to receive updates or notifications. Redux Saga can manage these WebSocket events, enabling you to listen for server-sent events and update your application‚Äôs state in real-time.\n\nHere‚Äôs an example of how Redux Saga can handle a WebSocket connection that listens for messages and dispatches actions based on those messages.\n\nIn this example:\n‚Ä¢ A WebSocket connection is established, and Redux Saga listens for incoming messages.\n‚Ä¢ Each message received is dispatched as a Redux action ( ).\n‚Ä¢ If the WebSocket connection encounters an error, a failure action ( ) is dispatched.\n\nThis approach allows you to handle real-time updates in a Redux application using Redux Saga, maintaining a clean separation between WebSocket events and Redux state.\n\nTesting sagas is straightforward because of their declarative nature. You can test advanced Redux Saga features like , , and by asserting that the correct effects are yielded.\n\nIn this test, we verify that the saga listens for the action and correctly invokes with the effect.\n\nHandling side effects in a Redux application can become complex as your application grows, but Redux Saga offers a powerful and declarative way to manage them. From API calls and retries to task cancellations and debouncing user input, Redux Saga gives you fine-grained control over side effects, making your application more maintainable and scalable.\n\nBy using generator functions, Redux Saga simplifies the flow of asynchronous code, making it easier to reason about and test. Whether you‚Äôre building a small project or a large-scale application, Redux Saga can help you manage side effects in a clean, predictable, and maintainable way.\n\nAt PixelFree Studio, we specialize in building scalable, high-performance applications using the latest tools and state management techniques like Redux Saga. If you‚Äôre looking to improve the way your app handles side effects or need expert guidance in state management, reach out to us today. We can help you build robust, maintainable applications with modern web development best practices.\n‚Ä¢ The Impact of Network Latency on Web Performance\n‚Ä¢ How to Use Asynchronous Loading for Faster Websites"
    },
    {
        "link": "https://dev.to/finallynero/what-do-you-use-to-handle-side-effects-in-react-react-107j",
        "document": "I am about to start a project where I will be using react and redux, In previous applications I have built I used redux-saga to handle side effects like api calls e.t.c but the fact that redux-saga has so much boilerplate code I didn't really enjoy using it. I have used redux-thunk but not in production.\n\nPlease what other libraries do you use to handle side effects and why did you choose them over the available alternatives?"
    },
    {
        "link": "https://stackoverflow.com/questions/32925837/how-to-handle-complex-side-effects-in-redux",
        "document": "I've been struggling for hours to finding a solution to this problem...\n\nI am developing a game with an online scoreboard. The player can log in and log out at any time. After finishing a game, the player will see the scoreboard, and see their own rank, and the score will be submitted automatically.\n\nThe scoreboard shows the player‚Äôs ranking, and the leaderboard.\n\nThe scoreboard is used both when the user finishes playing (to submit a score), and when the user just wants to check out their ranking.\n\nThis is where the logic becomes very complicated:\n‚Ä¢ None If the user is logged in, then the score will be submitted first. After the new record is saved then the scoreboard will be loaded.\n‚Ä¢ None Otherwise, the scoreboard will be loaded immediately. The player will be given an option to log in or register. After that, the score will be submitted, and then the scoreboard will be refreshed again.\n‚Ä¢ None However, if there is no score to submit (just viewing the high score table). In this case, the player‚Äôs existing record is simply downloaded. But since this action does not affect the scoreboard, both the scoreboard and the player‚Äôs record should be downloaded simultaneously.\n‚Ä¢ None There is an unlimited number of levels. Each level has a different scoreboard. When the user views a scoreboard, then the user is ‚Äòobserving‚Äô that scoreboard. When it is closed, the user stops observing it.\n‚Ä¢ None The user can log in and log out at any time. If the user logs out, the user‚Äôs ranking should disappear, and if the user logs in as another account, then the ranking information for that account should be fetched and displayed. ...but this fetching this information should only take place for the scoreboard whose user is currently observing.\n‚Ä¢ None For viewing operations, the results should be cached in-memory, so that if user re-subscribes to the same scoreboard, there will be no fetching. However, if there is a score being submitted, the cache should not be used.\n‚Ä¢ None Any of these network operations may fail, and the player must be able to retry them.\n‚Ä¢ None These operations should be atomic. All the states should be updated in one go (no intermediate states).\n\nCurrently, I am able to solve this using Bacon.js (a functional reactive programming library), as it comes with atomic update support. The code is quite concise, but right now it is a messy unpredictable spaghetti code.\n\nI started looking at Redux. So I tried to structure the store, and came up with something like this (in YAMLish syntax):\n\nThe problem becomes: where do I put the side-effects.\n\nFor side-effect-free actions, this becomes very easy. For instance, on action, the reducer could simply blast all the records off.\n\nHowever, some actions do have side effect. For example, if I am not logged in before submitting the score, then I log in successfully, the action saves the user into the store.\n\nBut because I have a score to submit, this action must also cause an AJAX request to be fired off, and at the same time, set the to .\n\nThe question is: how do I signify that a side-effects (score submission) should take place when I log in in an atomic way?\n\nIn Elm architecture, an updater can also emit side-effects when using the form of , but in Redux, it‚Äôs just .\n\nFrom the Async Actions docs, the way they recommend is to put them in an action creator. Does this means that the logic of submitting the score will have to be put in the action creator for a successful login action as well?\n\nI find this a bit odd, because the code responsible for this chain reaction now exists in 2 places:\n‚Ä¢ In the reducer. When action is dispatched, the reducer must also set the status of the records belonging to the observed scoreboards to .\n‚Ä¢ In the action creator, which performs the actual side-effect of fetching/submitting score.\n\nIt also seems that I have to manually keep track of all the active observers. Whereas in Bacon.js version, I did something like this:\n\nThe actual Bacon code is a lot longer, because of the all the complex rules above, that made the Bacon version barely-readable.\n\nBut Bacon kept track of all active subscriptions automatically. This led me to start questioning that it might not be worth the switch, because rewriting this to Redux would require a lot of manual handling. Can anyone suggest some pointer?"
    },
    {
        "link": "https://cody-by-umar.medium.com/mastering-redux-sagas-handling-side-effects-in-redux-applications-39b74714b55f",
        "document": "In this post, we‚Äôll explore Redux Saga, a middleware library for handling side effects in Redux. Learn how Redux Saga simplifies asynchronous operations, improves code readability, and enhances maintainability in Redux-based applications.\n\nManaging side effects (e.g., API calls, data fetching, and asynchronous actions) in Redux applications can be challenging. While Redux itself is great for state management, it doesn‚Äôt provide built-in tools for handling side effects.\n\nRedux Saga, a popular middleware library, addresses this limitation. It enables you to write complex asynchronous code in a clean, readable, and maintainable way using ES6 generators. In this blog, we‚Äôll discuss what Redux Sagas are, why they‚Äôre useful, and how to integrate them into your application.\n\nRedux Saga is a library designed to handle side effects in Redux applications. It acts as middleware that listens for Redux actions and allows you to define asynchronous workflows using sagas. Sagas are written using generator functions, which pause and resume execution, making asynchronous code look synchronous."
    },
    {
        "link": "https://stackoverflow.com/questions/70873211/react-error-cannot-find-module-react-when-trying-to-run-npm-start",
        "document": "I am running into a bug when trying to run 'npm start' for a react app.\n\nMy app had been running mostly as I expected while developing, however I ran into a bug that required me to update my node version as a potential fix. I updated node to v16.13.2 and I also decided to update npm to v8.3.2. Now when trying to run npm start I receive the following error. I also find it odd that the files referenced are not from directories within my current project folder.\n\nI have tried the following so far:\n‚Ä¢ Deleting the package-lock.json and node_modules folder and then reinstalling with npm install.\n\nI was wondering if anyone could kindly help with a solution?"
    },
    {
        "link": "https://docs.datadoghq.com/real_user_monitoring/browser",
        "document": "Datadog Real User Monitoring (RUM) provides deep insight into your application‚Äôs frontend performance. Monitor real user data to optimize your web experience and provide exceptional user experiences. Correlate synthetic tests, backend metrics, traces, and logs in a single place to identify and troubleshoot performance issues across the stack.\n\nDatadog helps you understand the current level of user experience, identify areas for improvement, and measure the success of each change and/or deployment. Use this information to identify and resolve unexpected front-end issues before users are impacted to deliver the best experience.\n\nWith the Datadog RUM Browser SDK, you can also:\n‚Ä¢ Monitor your application‚Äôs pageviews and performance to investigate performance issues\n‚Ä¢ Gain complete, end-to-end visibilty into resources and requests (such as images, CSS files, JavaScript assets, and font files)\n‚Ä¢ Automatically collect and monitor any interesting events with all relevant context, and manually collect errors that aren‚Äôt automatically tracked\n‚Ä¢ Track user interactions that were performed during a user journey so you can get insight into user behavior while meeting privacy requirements\n‚Ä¢ Pinpoint the cause of an error down to the line of code to resolve it\n\nThe responsibility of keeping user data secure is shared between Datadog and developers who leverage the RUM SDKs. Learn more about Shared responsibility.\n\nFrom here, you can modify the data and context the RUM Browser SDK collects to support your specific needs. Learn how to override default settings in Advanced Configuration."
    },
    {
        "link": "https://stackoverflow.com/questions/52801814/this-syntax-requires-an-imported-helper-but-module-tslib-cannot-be-found-wit",
        "document": "How can this problem be solved?\n\nsrc/index.ts:5:1 - error TS2354: This syntax requires an imported helper but module 'tslib' cannot be found.\n\nThis results in an error:\n\nI have demo project I'm about to compile to ES5 with ES2015 modules enabled and tslib used for external TS helpers:\n\nIn my case, tslib was already installed and i was seeing this error only for 1 component while everything else was working fine - build and functionality. I just restarted my vscode and it vanished. So, try that if the error is still there after you have done things which others have suggested.\n\nAs the reference states, module resolution is set to Node mode only for , and is set to classic mode for : There are two possible module resolution strategies: Node and Classic. You can use the --moduleResolution flag to specify the module resolution strategy. If not specified, the default is Classic for --module AMD | System | ES2015 or Node otherwise Since classic mode is unaware of , the compiler cannot resolve module. should be set explicitly for ES2015 modules:\n\nMy error appeared to be sporadic but likely caused by editing a file in the \"node_modules\" folder. NOTE: I tried running \"npm install' prior to deleting the files and that did not solve the issue.\n\nIn my case the error was caused by special builder in my Angular repository (I'm using nrwl/nx monorepo pattern with NodeJS server as one of the applications). It didn't include in the compilation output. Setting in the production build configuration in solved the issue. Credit goes to @vincastl here: https://github.com/nrwl/nx/issues/2625 Posting it here as it was the first post I found trying to solve this issue, perhaps I'm not alone.\n\n>> npm install -g npm-check-updates >> ncu -u tslib ...tslib ^1.10.0 ‚Üí ^2.6.0 [This command will update to the compatible version] >> npm install\n‚Ä¢ In my case, the OP issue popped up when I upgraded my Node version from 12+ to 16+ for my Angular 9 project.\n‚Ä¢ By using the above commands, the tslib updated and the issue was fixed. :) Just a note: In case if it doesn't work, kindly undo the tslib version and run \"npm install\" to revert to previous state. Because, other packages that are dependent on the older version might not be compatible. This too happened in my case.\n\nI was facing the same issue in a NX Monorepo, specifically with an express node project bundled with webpack created using / . If I just build the app for production it would run well on my local machine, but when I was trying to build into a docker container, it always returned me this error: node:internal/modules/cjs/loader:1080 throw err; ^ Error: Cannot find module 'tslib' Require stack: - /app/backend/main.js at Module._resolveFilename (node:internal/modules/cjs/loader:1077:15) at Module._load (node:internal/modules/cjs/loader:922:27) at Module.require (node:internal/modules/cjs/loader:1143:19) at require (node:internal/modules/cjs/helpers:119:18) at Array.<anonymous> (/app/backend/main.js:8:18) at __webpack_require__ (/app/backend/main.js:37:41) at /app/backend/main.js:51:17 at /app/backend/main.js:63:3 at Object.<anonymous> (/app/backend/main.js:68:12) at Module._compile (node:internal/modules/cjs/loader:1256:14) { code: 'MODULE_NOT_FOUND', requireStack: [ '/app/backend/main.js' ] } I solved it by adding in the file: : Dependencies to keep external to the bundle. ( (default), , or an array of module names) I hope it helps anybody struggling with the same problem.\n\nThis issue occurred for me when I updated my version of TypeScript. It can sometimes happen when updating TypeScript without updating Angular or other related packages, which can cause a mismatch between versions. The solution that worked for me was to simply restart the TypeScript server in VS Code. To do so:\n‚Ä¢ None Press Ctrl + Shift + P to open the Command Palette in Visual Studio Code.\n‚Ä¢ None Type \"TypeScript: Restart TS Server\" and select it from the dropdown. Closing and reopening VS Code manually achieves the same result. As other answers have mentioned, running \"npm install tslib\" might also help resolve the issue.\n\nStart asking to get answers Find the answer to your question by asking. Ask question See similar questions with these tags."
    },
    {
        "link": "https://nodejs.org/api/all.html",
        "document": ""
    },
    {
        "link": "https://docs.groovy-lang.org/next/html/documentation",
        "document": ""
    },
    {
        "link": "https://kentcdodds.com/blog/common-mistakes-with-react-testing-library",
        "document": "Hi there üëã I created React Testing Library because I wasn't satisfied with the testing landscape at the time. It expanded to DOM Testing Library and now we have Testing Library implementations (wrappers) for every popular JavaScript framework and testing tool that targets the DOM (and even some that don't).\n\nAs time has gone on, we've made some small changes to the API and we've discovered suboptimal patterns. Despite our efforts to document the \"better way\" to use the utilities we provide, I still see blog posts and tests written following these suboptimal patterns and I'd like to go through some of these, explain why they're not great and how you can improve your tests to avoid these pitfalls.\n\nIf you'd like to avoid several of these common mistakes, then the official ESLint plugins could help out a lot:\n\nUsing as the variable name for the return value from\n\nThe name is old cruft from and we don't need that here. The return value from is not \"wrapping\" anything. It's simply a collection of utilities that (thanks to the next thing) you should actually not often need anyway.\n\nFor a long time now happens automatically (supported for most major testing frameworks) and you no longer need to worry about it. Learn more.\n\nwas added in DOM Testing Library v6.11.0 (which means you should have access to it in ). It comes from the same statement you get from:\n\nThe benefit of using is you no longer need to keep the call destructure up-to-date as you add/remove the queries you need. You only need to type and let your editor's magic autocomplete take care of the rest.\n\nThe only exception to this is if you're setting the or which you probably should avoid doing (I honestly can't think of a legitimate use case for those options anymore and they only exist for historical reasons at this point).\n\nYou can also call instead of\n\nThat assertion comes from . It's strongly recommended to use because the error messages you get with it are much better.\n\nI see people wrapping things in like this because they see these \"act\" warnings all the time and are just desperately trying anything they can to get them to go away, but what they don't know is that and are already wrapped in ! So those are doing nothing useful.\n\nMost of the time, if you're seeing an warning, it's not just something to be silenced, but it's actually telling you that something unexpected is happening in your test. You can learn more about this from my blog post (and videos): Fix the \"not wrapped in act(...)\" warning.\n\nWe maintain a page called \"Which query should I use?\" of the queries you should attempt to use in the order you should attempt to use them. If your goal is aligned with ours of having tests that give you confidence that your app will work when your users use them, then you'll want to query the DOM as closely to the way your end-users do so as possible. The queries we provide will help you to do this, but not all queries are created equally.\n\nUsing to query for elements\n\nAs a sub-section of \"Using the wrong query\" I want to talk about querying on the directly.\n\nWe want to ensure that your users can interact with your UI and if you query around using we lose a lot of that confidence, the test is harder to read, and it will break more frequently. This goes hand-in-hand with the next sub-section:\n\nAs a sub-section of \"Using the wrong query\", I want to talk about why I recommend you query by the actual text (in the case of localization, I recommend the default locale), rather than using test IDs or other mechanisms everywhere.\n\nIf you don't query by the actual text, then you have to do extra work to make sure that your translations are getting applied correctly. The biggest complaint I hear about this is that it leads to content writers breaking your tests. My rebuttal to that is that first, if a content writer changes \"Username\" to \"Email\" that's a change I definitely want to know about (because I'll need to change my implementation). Also, if there is a situation where they break something, fixing that issue takes no time at all. It's easy to triage and easy to fix.\n\nSo the cost is pretty low, and the benefit is you get increased confidence that your translations are applied correctly and your tests are easier to write and read.\n\nI should mention that not everyone agrees with me on this, feel free to read more about it in this tweet thread.\n\nNot using most of the time\n\nAs a sub-section of \"Using the wrong query\" I want to talk about . In recent versions, the queries have been seriously improved (primarily thanks to great work by Sebastian Silbermann) and are now the number one recommended approach to query your component's output. Here are some of my favorite features.\n\nThe option allows you to query elements by their \"Accessible Name\" which is what screen readers will read for the element and it works even if your element has its text content split up by different elements. For example:\n\nOne reason people don't use queries is because they're not familiar with the implicit roles placed on elements. Here's a list of Roles on MDN. So another one of my favorite features of the queries is that if we're unable to find an element with the role you've specified, not only will we log the entire DOM to you like we do with normal or variants, but we also log all the available roles you can query by!\n\nThis will fail with the following error message:\n\nNotice that we didn't have to add the to our button for it to have the role of button. That's an implicit role, which leads us perfectly into our next one...\n\nSlapping accessibility attributes willy nilly is not only unnecessary (as in the case above), but it can also confuse screen readers and their users. The accessibility attributes should really only be used when semantic HTML doesn't satisfy your use case (like if you're building a non-native UI that you want to make accessible like an autocomplete). If that's what you're building, be sure to use an existing library that does this accessibly or follow the WAI-ARIA practices. They often have great examples.\n\nis a package that's built on top of , but it provides several methods that resemble the user interactions more closely. In the example above, will simply trigger a single change event on the input. However the call, will trigger , , and events for each character as well. It's much closer to the user's actual interactions. This has the benefit of working well with libraries that you may use which don't actually listen for the change event.\n\nWe're still working on to ensure that it delivers what it promises: firing all the same events the user would fire when performing a specific action. I don't think we're quite there yet and this is why it's not baked-into (though it may be at some point in the future). However, I'm confident enough in it to recommend you give it a look and use it's utilities over .\n\nUsing variants for anything except checking for non-existence\n\nThe only reason the variant of the queries is exposed is for you to have a function you can call which does not throw an error if no element is found to match the query (it returns if no element is found). The only reason this is useful is to verify that an element is not rendered to the page. The reason this is so important is because the and variants will throw an extremely helpful error if no element is found‚Äìit prints out the whole document so you can see what's rendered and maybe why your query failed to find what you were looking for. Whereas will only return and the best can do is say: \"null isn't in the document\" which is not very helpful.\n\nUsing to wait for elements that can be queried with\n\nThose two bits of code are basically equivalent ( queries use under the hood), but the second is simpler and the error message you get will be better.\n\nThe purpose of is to allow you to wait for a specific thing to happen. If you pass an empty callback it might work today because all you need to wait for is \"one tick of the event loop\" thanks to the way your mocks work. But you'll be left with a fragile test which could easily fail if you refactor your async logic.\n\nLet's say that for the example above, was called twice. So the call will fail, however, we'll have to wait for the timeout before we see that test failure. By putting a single assertion in there, we can both wait for the UI to settle to the state we want to assert on, and also fail faster if one of the assertions do end up failing.\n\nis intended for things that have a non-deterministic amount of time between the action you performed and the assertion passing. Because of this, the callback can be called (or checked for errors) a non-deterministic number of times and frequency (it's called both on an interval as well as when there are DOM mutations). So this means that your side-effect could run multiple times!\n\nThis also means that you can't use snapshot assertions within . If you do want to use a snapshot assertion, then first wait for a specific assertion, and then after that you can take your snapshot.\n\nThis one's not really a big deal actually, but I thought I'd mention it and give my opinion on it. If queries are unsuccessful in finding the element, they'll throw a really helpful error message that shows you the full DOM structure (with syntax highlighting) which will help you during debugging. Because of this, the assertion could never possibly fail (because the query will throw before the assertion has a chance to).\n\nFor this reason, many people skip the assertion. This really is fine honestly, but I personally normally keep the assertion in there just to communicate to readers of the code that it's not just an old query hanging around after a refactor but that I'm explicitly asserting that it exists.\n\nAs maintainers of the testing library family of tools, we do our best to make APIs that lead people to use things as effectively as possible and where that falls short we try to document things correctly. But this can be really difficult (especially as APIs change/improve/etc). Hopefully this was helpful to you. We really just want to make you more successful at shipping your software with confidence."
    },
    {
        "link": "https://stackoverflow.com/questions/63062395/react-testing-library-using-await-wait-after-fireevent",
        "document": "5 months later I'm coming back to answer my question (I've learned a lot since posting this question lol)....\n\nFirst of all, since it is 5 months later I want to underscore that it is better to use the library instead of if possible.\n\nI also would be remiss to not call out that there are a lot of antipatterns in the code ...You should only ever make one assertion in . You should avoid using in favor of more accessible alternatives.\n\nAnd finally the reason the first test was failing is that you can not use with . is not async and will not wait. This would have been the better solution:\n\nThen the test would have waited on the element to be available.\n\nThe second test passed because is wrapped in RTL's async utility, ( is now deprecated in favor of ). That is essentially what does under the hood -- is the async version of .\n\nWhen I posted the question I didn't fully understand that is a Javascript key word (and just syntactical sugar to make code wait on a promise to resolve). (now ) is a utility from RTL that will make execution of the test wait until the callback does not throw an error."
    },
    {
        "link": "https://testim.io/blog/react-testing-library-waitfor",
        "document": "This post will look into the waitFor utility provided by the React Testing Library. It is used to test our asynchronous code effortlessly. First, we‚Äôll create a complete React app, which will perform asynchronous tasks. After that, we‚Äôll test it using waitFor.\n\nBefore jumping into the tutorial, let‚Äôs look at the waitFor utility and what problems it can solve.\n\nAs mentioned, the utility waitFor is used when you have some async code to check. The most common async code is when we do an API call to get data in a front-end ReactJS application. The data from an API endpoint usually takes one to two seconds to get back, but the React code cannot wait for that time. In these scenarios, we use the Fetch API or Axios in ReactJS, which waits for the data to get back from the API. But it also continues to run code after the async task. This kind of async behavior is needed because JavaScript is a single-threaded language.\n\nThis code is common in almost all modern web apps, like social media or e-commerce. To test any web app, we need to use waitFor, or else the ReactJS/JavaScript behavior will go ahead with other parts of the code. We‚Äôll also look into this issue in our post.\n\nWe‚Äôll create a new React app named waitfor-testing using the below command:\n\nNow, remove everything from the App.js file and just keep a heading tag containing waitFor Testing:\n\nNow, run the React application with npm start, and we‚Äôll see the text at http://localhost:3000/.\n\nWe‚Äôll create a components folder inside the src folder. Next, create a file AsyncTest.js inside it. Here, we‚Äôll first import a getUser function from the API file, which we will create next.\n\nInside the component, we have a state of data created through the useState hook. Next, from a useEffect hook, we‚Äôll pass the props name to getUser function. This getUser function, which we will create next, will return a resolve, and we‚Äôll catch it in the then statement. Here, we‚Äôll be setting it to setData.\n\nNow, inside a return, we‚Äôll first check if the data is null. If it‚Äôs null, we‚Äôll see the Loading text. Or else we‚Äôll be showing the data.\n\nNow, create an api.js file in the components folder. Here, we have created the getUser function. It‚Äôs using async and returning a Promise type. We‚Äôre just changing the provided name to uppercase, using the JavaScript function of toUpperCase().\n\nNow, we‚Äôll write the test case for our file AsyncTest.js. React comes with the React Testing Library, so we don‚Äôt have to install anything. First, create a file AsyncTest.test.js in the components folder. Here, we‚Äôll first import render, screen from the React Testing Library. After that, we‚Äôll import the AsyncTest component too. Inside a describe block, we have our only test case in an it statement. The second parameter to the it statement is a function. First, we render the component with the render method and pass a prop of bobby. Next, we have the usual expect from the React Testing Library. Here, we‚Äôll check whether the text BOBBY is rendered on the screen. import { render, screen, waitFor } from '@testing-library/react' import AsyncTest from './AsyncTest' describe('should pass with correct case', () => { it('should make user Uppercase', () => { render(<AsyncTestname=\"bobby\"/>) expect(screen.getByText('BOBBY')).not.toBeNull() }) }) Now, run the command npm run test from the terminal. We‚Äôll see that the test case was unsuccessful. We can see from the output that the text Loading‚Ä¶ is there in the DOM. This happens because asynchronous code generally takes one to two seconds to resolve, and React doesn‚Äôt wait for the time.\n\nWe need to use waitFor, which must be used for asynchronous code. First, we‚Äôll add the import of waitFor in our import statement. Notice that we have marked the function as async because we will use await inside the function.\n\nNow, run the command npm run test from the terminal. And the test case will run successfully!\n\nconst MoreAsync = ({ name }) => { const [data, setData] = useState(null); useEffect(() => { if (!name) { setData(null) return } getUserWithCar(name).then(setData) }, [name]) return <>{data === null ? <div>Loading...</div> : data}</> } export default MoreAsync Now, in the api.js file, we‚Äôll add the getUserWithCar function. It‚Äôs using async and returning a Promise type. From inside the function, we‚Äôll call the getUser function with the name. Notice that we have to use await here since the getUser function returns a Promise. After that, we‚Äôll use another await to check if the user is NABENDU and call a new async function getCar with nexon. Or else we‚Äôll call getCar with Hyundai. In the function getCar, we‚Äôll make the first letter a capital and return it. Back in the App.js file, we‚Äôll import the MoreAsync component. We‚Äôll call it two times, one with props as nabendu and another with props as bob. Now, in http://localhost:3000/, we‚Äôll see the two following sets of text. Now, we‚Äôll write the test case for our file MoreAsync.js. So create a file called MoreAsync.test.js in the components folder. Again, it‚Äôs similar to the file AsyncTest.test.js. Here, again, we‚Äôll import render, screen, waitFor from the React Testing Library. After that, we‚Äôll import the MoreAsync component. Inside the it block, we have an async function. We‚Äôll also need to add waitFor in expect again because our complex asynchronous component does asynchronous tasks twice. If we don‚Äôt do this, we‚Äôll get the error because React will render Loading text. It will not wait for the asynchronous task to complete and return the result. import { render, screen, waitFor } from '@testing-library/react' import MoreAsync from './MoreAsync' describe('should pass with correct case', () => { it('should render user with car', async () => { render(<MoreAsyncname=\"bobby\"/>) awaitwaitFor(() => { expect(screen.getByText('BOBBY drives a Hyundai')).not.toBeNull() }) }) })\n\nNow, run the command npm run test from the terminal, and both test cases will run successfully. It will run tests from the earlier AsyncTest.test.js and also the current MoreAsync.test.js. In this post, you learned about the React Testing Library asynchronous testing function of waitFor. First, we created a simple React project. Then, we made a simple component, doing an asynchronous task. While writing the test case, we found it impossible to test it without waitFor. This is required because React is very quick to render components. And it doesn‚Äôt wait for asynchronous tasks to complete. After that, we created a more complex component using two asynchronous calls. We tested it successfully using waitFor. You can find the code for this project here."
    },
    {
        "link": "https://testing-library.com/docs/react-testing-library/example-intro",
        "document": "This is a minimal setup to get you started. If you want to see a description of what each line does, scroll down to the annotated version. Scroll down to Full Example to see a more advanced test setup.\n\nSee the following sections for a detailed breakdown of the test\n\nOur example here uses axios to make its API calls. If your application uses to make its API calls, then be aware that by default JSDOM does not include fetch. If you are using vitest as your test runner, it will be included for you. For jest you may wish to manually polyfill or use the jest-fixed-jsdom environment which includes fetch.\n\nUse the function from to mock an API request that our tested component makes.\n\nThe method renders a React element into the DOM.\n\nThe method allows you to fire events to simulate user actions."
    },
    {
        "link": "https://stackoverflow.com/questions/65725591/react-testing-library-how-to-use-waitfor",
        "document": "I'm following a tutorial on React testing. The tutorial has a simple component like this, to show how to test asynchronous actions:\n\nAnd the test file is like this:\n\nThe terminal says has been deprecated and to use instead.\n\nHow can I use in this test file?"
    }
]