[
    {
        "link": "https://mathworks.com/help/matlab/ref/strrep.html",
        "document": ""
    },
    {
        "link": "https://mathworks.com/help/slrequirements/ref/strrep.html",
        "document": ""
    },
    {
        "link": "https://ww2.mathworks.cn/help/matlab/ref/strrep.html",
        "document": ""
    },
    {
        "link": "https://mathworks.com/help/stateflow/ref/strrep.html",
        "document": ""
    },
    {
        "link": "https://mathworks.com/help//releases/R2021a/matlab/ref/strrep.html",
        "document": "Create a character vector with a repeated, overlapping pattern. Compare the results of using the , , and functions to replace the pattern.\n\nFind the indices of the repeating pattern using the function. finds all instances of the pattern, including instances that overlap.\n\nReplace using . When you use , it replaces every instance identified by .\n\nReplace using . It does not replace every instance that replaces.\n\nReplace using . The results are identical to the results using the function.\n\nfinds all instances of a pattern before replacing any instance. However, the and functions replace an instance of a pattern as soon as they find it within the text."
    },
    {
        "link": "https://mathworks.com/help/matlab/ref/strrep.html",
        "document": ""
    },
    {
        "link": "https://mathworks.com/help/stateflow/ref/strrep.html",
        "document": ""
    },
    {
        "link": "https://ww2.mathworks.cn/help/matlab/ref/strrep.html",
        "document": ""
    },
    {
        "link": "https://swcarpentry.github.io/matlab-novice-inflammation/instructor/aio.html",
        "document": "Last updated on 2025-01-08 | Edit this page\n• How can I store values and do simple calculations with them?\n• Navigate among important sections of the MATLAB environment.\n• Identify what type of data is stored in MATLAB arrays. Before we can start programming, we need to know a little about the MATLAB interface. Using the default setup, the MATLAB desktop contains several important sections:\n• In the Command Window we can execute commands. Commands are typed after the prompt and are executed immediately after pressing .\n• Alternatively, we can open the Editor, write our code and run it all at once. The advantage of this is that we can save our code and run it again in the same way at a later stage.\n• The Workspace contains all the variables which we have loaded into memory.\n• The Current Folder window shows files in the current directory, and we can change the current folder using this window.\n• Search Documentation on the top right of your screen lets you search for functions. Suggestions for functions that would do what you want to do will pop up. Clicking on them will open the documentation. Another way to access the documentation is via the command — we will return to this later. In this lesson we will learn how to manipulate the inflammation dataset with MATLAB. But before we discuss how to deal with many data points, we will show how to store a single value on the computer. We can create a new variable by assigning a value to it using : At first glance nothing appears to have happened! We don’t get any output in the command window because we put a semi-colon after the variable assignment: this suppresses output, which is generally a good thing because it makes code run more quickly. Let’s run the command again without the semi-colon, and this time we have some output in the command window: A variable is just a name for a piece of data or value. Variable names must begin with a letter, and are case sensitive. They can contain also numbers or underscores. Examples of valid variable names are , or . Once a variable has a value, we can print it using the function: or simply typing its name, followed by Storing single values is fine, but how can we store multiple values in the same variable? We can create an array using square brackets, separating each value with a comma: In a similar way, we can create matrices using semi-colons to separate rows: Something to bear in mind about arrays and matrices is that all values in an array must be of the same type e.g. all numbers or all strings. It is however possible to convert between data types e.g. which converts numbers to a string representation. So once we have a numeric value stored in a variable, we can do arithmetic with it: That last command combines several new concepts, so let’s break it down: The function takes a single argument — the value to print. So if we want to print more than one value on a single line, we can print an array of values (i.e. one argument), which we create using square brackets, and recall that an array must contain values all of the same type. In this case we convert the number to a string so that we can print an array of characters. We can change the value of a variable by assigning it a new one: Assigning a value to one variable does not change the values of other variables. For example, we just changed the value of from 55 to 57.5, but hasn’t changed: Since doesn’t “remember” where its value came from, it isn’t automatically updated when changes. This is important to remember, and different from the way spreadsheets work. Now that we know how to assign values to variables, let’s view a list of all the variables in our workspace: To remove a variable from MATLAB, use the command: Alternatively, we can look at the Workspace. The workspace contains all variable names and assigned values that we currently work with. As long as they pop up in the workspace, they are universally available. It’s generally a good idea to keep the workspace as clean as possible. To remove all variables from the workspace, execute the command on its own. Predict what variables refer to what values after each statement in the following program: The first two lines assign the initial values to the variables, so mass = 47.5 and age = 122. The next line evaluates i.e. , then assigns the result to the variable . The last line evaulates i.e. , then assigns the result to the variable . So the final values are mass = 95, and age = 102. The key point to understand here is that the expression to the right of the sign is evaluated first, and the result is then assigned to the variable specified to the left of the sign. Before we get started, let’s create some directories to help organise this project. Good Enough Practices for Scientific Computing is a paper written by researchers involved with the Carpentries, which covers basic workflow skills for research computing. It recommends the following for project organization:\n• Put each project in its own directory, which is named after the project.\n• Put text documents associated with the project in the directory.\n• Put raw data and metadata in the directory, and files generated during clean-up and analysis in a directory.\n• Put source code for the project in the directory, and programs brought in from elsewhere or compiled locally in the directory.\n• Name all files to reflect their content or function. Our main project directory is , where we’ll save all our scripts and function files. We already have and directories here. A crucial step is to set the current folder in MATLAB to our project directory. Use the Current Folder window in the MATLAB GUI to browse to your project folder ( ). In order to check the current directory, we can run (print working directory). A second check we can do is to run the (list) command in the Command Window to list the contents of the working directory — we should get the following output: Reading data from files and writing data to them are essential tasks in scientific computing, and admittedly, something that we’d rather not spend a lot of time thinking about. Fortunately, MATLAB comes with a number of high-level tools to do these things efficiently, sparing us the grisly detail. If we know what our data looks like (in this case, we have a matrix stored as comma-separated values) and we’re unsure about what command we want to use, we can search the documentation. Type into the documentation toolbar. MATLAB suggests using . If we have a closer look at the documentation, MATLAB also tells us, which in- and output arguments this function has. Octave does not provide a function named , but the equivalent functionality (in both Octave and MATLAB) can be achieved with for the files we will work with in this lesson. To load the data from our CSV file into MATLAB, type the following command into the MATLAB command window, and press : This loads the data and assigns it to a variable, patient_data. This is a good example of when to use a semi-colon to suppress output — try re-running the command without the semi-colon to find out why. You should see a wall of numbers printed, which is the data from the file. The expression is a function call. Functions generally need arguments to run. In the case of the function, we need to provide a single argument: the name of the file we want to read data from. This argument needs to be a character string or string, so we put it in quotes. Now that our data is in memory, we can start doing things with it. First, let’s find out its size: The output tells us that the variable refers to a table of values that has 60 rows and 40 columns. MATLAB stores all data in the form of multi-dimensional arrays. For example:\n• Numbers, or scalars are represented as two dimensional arrays with only one row and one column, as are single characters.\n• Lists of numbers, or vectors are two dimensional as well, but the value of one of the dimensions equals one. By default vectors are row vectors, meaning they have one row and as many columns as there are elements in the vector.\n• Tables of numbers, or matrices are arrays with more than one column and more than one row.\n• Even character strings, like sentences, are stored as an “array of characters”. Normally, MATLAB arrays can’t store elements of different data types. For instance, a MATLAB array can’t store both a and a . To do that, you have to use a Cell Array. We can use the function to find out what type of data lives inside an array: This output tells us that contains double precision floating-point numbers. This is the default numeric data type in MATLAB. If you want to store other numeric data types, you need to tell MATLAB explicitly. For example, the command, assigns the value to the name , storing it as a 16-bit signed integer.\n• Use to read tabular CSV data into a program.\n\nLast updated on 2025-01-08 | Edit this page\n• How can I process and visualize my data? Now that we know how to access data we want to compute with, we’re ready to analyze . MATLAB knows how to perform common mathematical operations on arrays. If we want to find the average inflammation for all patients on all days, we can just ask for the mean of the array: We couldn’t just do because, that would compute the mean of each column in our table, and return an array of mean values. The expression flattens the table into a one-dimensional array. To get details about what a function, like , does and how to use it, we can search the documentation, or use MATLAB’s command. mean Average or mean value. S = mean(X) is the mean value of the elements in X if X is a vector. For matrices, S is a row vector containing the mean value of each column. For N-D arrays, S is the mean value of the elements along the first array dimension whose size does not equal 1. mean(X,DIM) takes the mean along the dimension DIM of X. S = mean(...,TYPE) specifies the type in which the mean is performed, and the type of S. Available options are: 'double' - S has class double for any input X 'native' - S has the same class as X 'default' - If X is floating point, that is double or single, S has the same class as X. If X is not floating point, S has class double. S = mean(...,NANFLAG) specifies how NaN (Not-A-Number) values are treated. The default is 'includenan': 'includenan' - the mean of a vector containing NaN values is also NaN. 'omitnan' - the mean of a vector containing NaN values is the mean of all its non-NaN elements. If all elements are NaN, the result is NaN. Example: X = [1 2 3; 3 3 6; 4 6 8; 4 7 7] mean(X,1) mean(X,2) Class support for input X: float: double, single integer: uint8, int8, uint16, int16, uint32, int32, uint64, int64 See also median, std, min, max, var, cov, mode. We can also compute other statistics, like the maximum, minimum and standard deviation. When analyzing data though, we often want to look at partial statistics, such as the maximum value per patient or the average value per day. One way to do this is to assign the data we want to a new temporary array, then ask it to do the calculation: We don’t actually need to store the row in a variable of its own. Instead, we can combine the selection and the function call: What if we need the maximum inflammation for all patients, or the average for each day? As the diagram below shows, we want to perform the operation across an axis: To support this, MATLAB allows us to specify the dimension we want to work on. If we ask for the average across the dimension 1, we’re asking for one summary value per column, which is the average of all the rows. In other words, we’re asking for the average inflammation per day for all patients. ans = Columns 1 through 10 0 0.4500 1.1167 1.7500 2.4333 3.1500 3.8000 3.8833 5.2333 5.5167 Columns 11 through 20 5.9500 5.9000 8.3500 7.7333 8.3667 9.5000 9.5833 10.6333 11.5667 12.3500 Columns 21 through 30 13.2500 11.9667 11.0333 10.1667 10.0000 8.6667 9.1500 7.2500 7.3333 6.5833 Columns 31 through 40 6.0667 5.9500 5.1167 3.6000 3.3000 3.5667 2.4833 1.5000 1.1333 0.5667 If we average across axis 2, we’re asking for one summary value per row, which is the average of all the columns. In other words, we’re asking for the average inflammation per patient over all the days: We can quickly check the size of this array: The size tells us we have a 60-by-1 vector, confirming that this is the average inflammation per patient over all days in the trial. The mathematician Richard Hamming once said, “The purpose of computing is insight, not numbers,” and the best way to develop insight is often to visualize data. Visualization deserves an entire lecture (or course) of its own, but we can explore a few features of MATLAB here. The function represents the matrix as a color image. Every value in the matrix is mapped to a color. Blue regions in this heat map are low values, while yellow shows high values. As we can see, inflammation rises and falls over a 40 day period. It’s good practice to give the figure a , and to label the axes using and so that other people can understand what it shows (including us if we return to this plot 6 months from now). Let’s take a look at the average inflammation over time: Here, we have calculated the average per day across all patients then used the function to display a line graph of those values. The result is roughly a linear rise and fall, which is suspicious: based on other studies, we expect a sharper rise and slower fall. Let’s have a look at two other statistics: the maximum and minimum inflammation per day across all patients. Like , the functions and can also operate across a specified dimension of the matrix. However, the syntax is slightly different. To see why, run a on each of these functions. From the figures, we see that the maximum value rises and falls perfectly smoothly, while the minimum seems to be a step function. Neither result seems particularly likely, so either there’s a mistake in our calculations or something is wrong with our data. When we plot just one variable using the command e.g. or , what do the x-values represent? The x-values are the indices of the y-data, so the first y-value is plotted against index 1, the second y-value against 2 etc. Why are the vertical lines in our plot of the minimum inflammation per day not perfectly vertical? MATLAB interpolates between the points on a 2D line plot. Create a plot showing the standard deviation of the inflammation data for each day across all patients. Hint: search the documentation for standard deviation It is often convenient to combine multiple plots into one figure using the command which plots our graphs in a grid pattern. The first two parameters describe the grid we want to use, while the third parameter indicates the placement on the grid. Our work so far has convinced us that something is wrong with our first data file. We would like to check the other 11 the same way, but typing in the same commands repeatedly is tedious and error-prone. Since computers don’t get bored (that we know of), we should create a way to do a complete analysis with a single command, and then figure out how to repeat that step once for each file. These operations are the subjects of the next two lessons.\n\nLast updated on 2025-01-08 | Edit this page\n• How can I save and re-use my programs? So far, we’ve typed in commands one-by-one on the command line to get MATLAB to do things for us. But what if we want to repeat our analysis? Sure, it’s only a handful of commands, and typing them in shouldn’t take us more than a few minutes. But if we forget a step or make a mistake, we’ll waste time rewriting commands. Also, we’ll quickly find ourselves doing more complex analyses, and we’ll need our results to be more easily reproducible. In addition to running MATLAB commands one-by-one on the command line, we can also write several commands in a script. A MATLAB script is just a text file with a extension. We’ve written commands to load data from a file and display some plots of statistics about that data. Let’s put those commands in a script called , which we’ll save in our current directory, . To create a new script in the current directory, we use then we type the contents of the script: Note that we are explicitly creating a new figure window using the command. Try this on the command line: MATLAB’s plotting commands only create a new figure window if one doesn’t already exist: the default behaviour is to reuse the current figure window as we saw in the previous episode. Explicitly creating a new figure window in the script avoids any unexpected results from plotting on top of existing figures. You can get MATLAB to run the commands in the script by typing in the name of the script (without the ) in the MATLAB command line: MATLAB knows about files in the current directory, but if we want to run a script saved in a different location, we need to make sure that this file is visible to MATLAB. We do this by adding directories to the MATLAB path. The path is a list of directories MATLAB will search through to locate files. To add a directory to the MATLAB path, we go to the tab, click on , and then on . We navigate to the directory and add it to the path to tell MATLAB where to look for our files. When you refer to a file (either code or data), MATLAB will search all the directories in the path to find it. Alternatively, for data files, we can provide the relative or absolute file path. Octave has only recently gained a MATLAB-like user interface. To change the path in any version of Octave, including command-line-only installations, use In this script, let’s save the figures to disk as image files using the command. In order to maintain an organised project we’ll save the images in the directory: You might have noticed that we described what we want our code to do using the percent sign: . This is another plus of writing scripts: you can comment your code to make it easier to understand when you come back to it after a while. A comment can appear on any line, but be aware that the first line or block of comments in a script or function is used by MATLAB as the help text. When we use the command, MATLAB returns the help text. The first help text line (known as the H1 line) typically includes the name of the program, and a brief description. The command works in just the same way for our own programs as for built-in MATLAB functions. You should write help text for all of your own scripts and functions. Let’s write an H1 line at the top of our script: We can then get help for our script by running Let’s modify our script so that it creates and saves sub-plots, rather than individual plots. As before we’ll save the images in the directory. When saving plots to disk, it’s sometimes useful to turn off their visibility as MATLAB plots them. For example, we might not want to view (or spend time closing) the figures in MATLAB, and not displaying the figures could make the script run faster. Let’s add a couple of lines of code to do this: We can ask MATLAB to create an empty figure window without displaying it by setting its property to , like so: When we do this, we have to be careful to manually “close” the figure after we are doing plotting on it - the same as we would “close” an actual figure window if it were open:\n\nLast updated on 2025-01-08 | Edit this page\n• How can I repeat the same operations on multiple values?\n• Explain what a for loop does.\n• Trace changes to a loop variable as the loops runs.\n• Use a for loop to process multiple files Recall that we have to do this analysis for every one of our dozen datasets, and we need a better way than typing out commands for each one, because we’ll find ourselves writing a lot of duplicate code. Remember, code that is repeated in two or more places will eventually be wrong in at least one. Also, if we make changes in the way we analyze our datasets, we have to introduce that change in every copy of our code. To avoid all of this repetition, we have to teach MATLAB to repeat our commands, and to do that, we have to learn how to write loops. Suppose we want to print each character in the word “lead” on a line of its own. One way is to use four statements: But this is a bad approach for two reasons:\n• None It doesn’t scale: if we want to print the characters in a string that’s hundreds of letters long, we’d be better off typing them in.\n• None It’s fragile: if we change to a longer string, it only prints part of the data, and if we change it to a shorter one, it produces an error, because we’re asking for characters that don’t exist. error: A(I): index out of bounds; value 4 out of bound 3 This improved version uses a for loop to repeat an operation—in this case, printing to the screen—once for each element in an array. The general form of a for loop is: for variable = collection do things with variable end The for loop executes the commands in the loop body for every value in the array . This value is called the loop variable, and we can call it whatever we like. In our example, we gave it the name . We have to terminate the loop body with the keyword, and we can have as many commands as we like in the loop body. But, we have to remember that they will all be repeated as many times as there are values in . Our for loop has made our code more scalable, and less fragile. There’s still one little thing about it that should bother us. For our loop to deal appropriately with shorter or longer words, we have to change the first line of our loop by hand: Although this works, it’s not the best way to write our loop:\n• None We might update and forget to modify the loop to reflect that change.\n• None We might make a mistake while counting the number of letters in . Fortunately, MATLAB provides us with a convenient function to write a better loop: This is much more robust code, as it can deal identically with words of arbitrary length. Loops are not only for working with strings, they allow us to do repetitive calculations regardless of data type. Here’s another loop that calculates the sum of all even numbers between 1 and 10: It’s worth tracing the execution of this little program step by step. We can use the MATLAB debugger to trace the execution of a program. The first step is to set a break point by clicking just to the right of a line number on the symbol. A red circle will appear — this is the break point, and when we run the script, MATLAB will pause execution at that line. A green arrow appears, pointing to the next line to be run. To continue running the program one line at a time, we use the button. We can then inspect variables in the workspace or by hovering the cursor over where they appear in the code, or get MATLAB to evaluate expressions in the command window (notice the prompt changes to ). This process is useful to check your understanding of a program, in order to correct mistakes. This process is illustrated below: Since we want to sum only even numbers, the loop index starts at 2 and increases by 2 with every iteration. When we enter the loop, is zero - the value assigned to it beforehand. The first time through, the loop body adds the value of the first even number (2) to the old value of (0), and updates to refer to that new value. On the next loop iteration, is 4 and the initial value of is 2, so the new value assigned to is 6. After reaches the final value (10), is 30; since this is the end of the range for the loop finishes and the statements give us the final answer. Note that a loop variable is just a variable that’s being used to record progress in a loop. It still exists after the loop is over, and we can re-use variables previously defined as loop variables as well: MATLAB uses the caret ( ) to perform exponentiation: You can also use a loop to perform exponentiation. Remember that is just … times. Let a variable be the base of the number and the exponent. Write a loop to compute . Check your result for and . Write a loop that spells the word “aluminum,” adding one letter at a time: % spell a string adding one letter at a time using a loop In MATLAB, the colon operator ( ) accepts a stride or skip argument between the start and stop: Using this, write a loop to print the letters of “aluminum” in reverse order, one letter per line. We now have almost everything we need to process multiple data files using a loop and the plotting code in our script. We still need to generate a list of data files to process, and then we can use a loop to repeat the analysis for each file. We can use the command to return a structure array containing the names of the files in the directory. Each element in this structure array is a structure, containing information about a single file in the form of named fields. To access the name field of the first file, we can use the following syntax: To get the modification date of the third file, we can do: A good first step towards processing multiple files is to write a loop which prints the name of each of our files. Let’s write this in a script which we will then develop further: Another task is to generate the file names for the figures we’re going to save. Let’s name the output file after the data file used to generate the figure. So for the data set we will call the figure . We can use the command for this purpose. The syntax for the command is like this: So for example if we have the string and want to get the string , we can execute the following command: In Octave, the function doesn’t exist, but the function is a direct replacement. The above example becomes Recall that we’re saving our figures to the directory. The best way to generate a path to a file in MATLAB is by using the command. This generates a file path with the correct separators for the platform you’re using (i.e. forward slash for Linux and macOS, and backslash for Windows). This makes your code more portable which is great for collaboration. Putting these concepts together, we can now generate the paths for the data files, and the image files we want to save: We’re now ready to modify to actually process multiple data files: We run the modified script using its name in the Command Window: The first three figures output to the directory are as shown below: Sure enough, the maxima of these data sets show exactly the same ramp as the first, and their minima show the same staircase structure. We’ve now automated the analysis and have confirmed that all the data files we have looked at show the same artifact. This is what we set out to test, and now we can just call one script to do it. With minor modifications, this script could be re-used to check all our future data files.\n• Use to create a loop that repeats one or more operations.\n\nLast updated on 2025-01-08 | Edit this page\n• How can programs do different things for different data values?\n• Construct a conditional statement using if, elseif, and else\n• Combine conditional tests using AND and OR Our previous lessons have shown us how to manipulate data and repeat things. However, the programs we have written so far always do the same things, regardless of what data they’re given. We want programs to make choices based on the values they are manipulating. The tool that MATLAB gives us for doing this is called a conditional statement, and it looks like this: The second line of this code uses the keyword to tell MATLAB that we want to make a choice. If the test that follows is true, the body of the (i.e., the lines between and ) are executed. If the test is false, the body of the (i.e., the lines between and ) are executed instead. Only one or the other is ever executed. Conditional statements don’t have to have an block. If there isn’t one, MATLAB simply doesn’t do anything if the test is false: We can also chain several tests together using . This makes it simple to write a script that gives the sign of a number: %CONDITIONAL_DEMO Demo script to illustrate use of conditionals One important thing to notice in the code above is that we use a double equals sign to test for equality rather than a single equals sign. This is because the latter is used to mean assignment. In our test, we want to check for the equality of and , not assign 0 to . This convention was inherited from C, and it does take a bit of getting used to… During a conditional statement, if one of the conditions is true, this marks the end of the test: no subsequent conditions will be tested and execution jumps to the end of the conditional. Let’s demonstrate this by adding another condition which is true. % Demo script to illustrate use of conditionals % This block will never be executed We can also combine tests, using (and) and (or). is true if both tests are true: one part is not true is true if either test is true: at least one part is true In this case, “either” means “either or both”, not “either one or the other but not both”. The conditions we have tested above evaluate to a logical value: or . However these numerical comparison tests aren’t the only values which are or in MATLAB. For example, is considered and is considered . In fact, any value can be used in a conditional statement. Run the code below in order to discover which values are considered and which are considered . Write a script called that performs a test on two variables, and displays when the first variable is within 10% of the other and otherwise. Compare your implementation with your partner’s: do you get the same answer for all possible pairs of numbers? %NEAR Display 1 if variable a is within 10% of variable b Another thing to realize is that statements can also be combined with loops. For example, if we want to sum the positive numbers in a list, we can write this: With a little extra effort, we can calculate the positive and negative sums in a loop: We can even put one loop inside another: Will changing the order of nesting in the above loop change the output? Why? Write down the output you might expect from changing the order of the loops, then rewrite the code to test your hypothesis. Reordering the nested loops changes the output. In the new code, the number loop happens within the letter loop, so while letter = a, number takes the values 1, 2, and 3 in turn. Currently, our script reads in data, analyzes it, and saves plots of the results. If we would rather display the plots interactively, we would have to remove (or comment out) the following code: And, we’d also have to change this line of code, from: This is not a lot of code to change every time, but it’s still work that’s easily avoided using conditionals. Here’s our script re-written to use conditionals to switch between saving plots as images and plotting them interactively:\n• Use and to make choices based on values in your program.\n\nLast updated on 2025-01-07 | Edit this page\n• How can I teach MATLAB how to do new things?\n• Recognize why we should divide programs into small, single-purpose functions. If we only had one data set to analyze, it would probably be faster to load the file into a spreadsheet and use that to plot some simple statistics. But we have twelve files to check, and may have more in future. In this lesson, we’ll learn how to write a function so that we can repeat several operations with a single command. Let’s start by defining a function that converts temperatures from Fahrenheit to Kelvin: A MATLAB function must be saved in a text file with a extension. The name of that file must be the same as the function defined inside it. The name must start with a letter and cannot contain spaces. So, you will need to save the above code in a file called . Remember to save your m-files in the current directory. The first line of our function is called the function definition, and it declares that we’re writing a function named , that has a single input parameter, , and a single output parameter, . Anything following the function definition line is called the body of the function. The keyword marks the end of the function body, and the function won’t know about any code after . A function can have multiple input and output parameters if required, but isn’t required to have any of either. The general form of a function is shown in the pseudo-code below: % This section below is called the body of the function Just as we saw with scripts, functions must be visible to MATLAB, i.e., a file containing a function has to be placed in a directory that MATLAB knows about. The most convenient of those directories is the current working directory. In common with MATLAB, Octave searches the current working directory and the path for functions called from the command line. We can call our function from the command line like any other MATLAB function: When we pass a value, like , to the function, the value is assigned to the variable so that it can be used inside the function. If we want to return a value from the function, we must assign that value to a variable named -–in the first line of our function, we promised that the output of our function would be named . Outside of the function, the variables and aren’t visible; they are only used by the function body to refer to the input and output values. This is one of the major differences between scripts and functions: a script can be thought of as automating the command line, with full access to all variables in the base workspace, whereas a function can only read and write variables from the calling workspace if they are passed as arguments — i.e. a function has its own separate workspace. Now that we’ve seen how to convert Fahrenheit to Kelvin, it’s easy to convert Kelvin to Celsius. Again, we can call this function like any other: What about converting Fahrenheit to Celsius? We could write out the formula, but we don’t need to. Instead, we can compose the two functions we have already created: This is our first taste of how larger programs are built: we define basic operations, then combine them in ever-larger chunks to get the effect we want. Real-life functions will usually be larger than the ones shown here—typically half a dozen to a few dozen lines—but they shouldn’t ever be much longer than that, or the next person who reads it won’t be able to understand what’s going on. In MATLAB, we concatenate strings by putting them into an array or using the function: Write a function called that has two parameters, and and adds before and after : Getting the Outside If the variable refers to a string, then is the string’s first character and is its last. Write a function called that returns a string made up of just the first and last characters of its input: %OUTER Return first and last characters from a string Consider our function from earlier in the episode: What does the following code display when run — and why? is 0 because the function has no knowledge of the variable which exists outside of the function. Once we start putting things in functions so that we can re-use them, we need to start testing that those functions are working correctly. To see how to do this, let’s write a function to center a dataset around a particular value: We could test this on our actual data, but since we don’t know what the values ought to be, it will be hard to tell if the result was correct, Instead, let’s create a matrix of 0’s, and then center that around 3: That looks right, so let’s try out function on our real data: It’s hard to tell from the default output whether the result is correct–this is often the case when working with fairly large arrays–but, there are a few simple tests that will reassure us. And let’s do the same after applying our function to the data: That seems almost right: the original mean was about 6.1, so the lower bound from zero is now about -6.1. The mean of the centered data isn’t quite zero–we’ll explore why not in the challenges–but it’s pretty close. We can even go further and check that the standard deviation hasn’t changed: The difference is very small. It’s still possible that our function is wrong, but it seems unlikely enough that we should probably get back to doing our analysis. We have one more task first, though: we should write some documentation for our function to remind ourselves later what it’s for and how to use it. % Returns a new array containing the values in % DATA centered around the value. Comment lines immediately below the function definition line are called “help text”. Typing brings up the help text for that function: Center Center data around a desired value. center(DATA, DESIRED) Returns a new array containing the values in DATA centered around the value.\n• None Write a function called that takes an array as input and returns an array of the same shape with its values scaled to lie in the range 0.0 to 1.0. (If L and H are the lowest and highest values in the input array, respectively, then the function should map a value v to (v - L)/(H - L).) Be sure to give the function a comment block explaining its use.\n• None Run to see how to use to generate regularly-spaced values. Use arrays like this to test your function. %NORMALISE Return original array, normalised so that the % new values lie in the range 0 to 1. Write a function called which plots the three summary graphs (max, min, std) for a given inflammation data file. The function should operate on a single data file, and should have two parameters: and . When called, the function should create the three graphs produced in the previous lesson. Whether they are displayed or saved to the directory should be controlled by the value of i.e. should display the corresponding graphs for the first data set; should save the figures for the second dataset to the directory. You should mostly be reusing code from the script. Be sure to give your function help text. % or save to disk using plot_switch = 1. Automate the analysis for all files Modify the script so that as it loops over the data files, it calls the function for each file in turn. Your script should save the image files to the ‘results’ directory rather than displaying the figures in the MATLAB GUI. We have now solved our original problem: we can analyze any number of data files with a single command. More importantly, we have met two of the most important ideas in programming:\n• None Use arrays to store related values, and loops to repeat operations on them.\n• None Use functions to make code easier to re-use and easier to understand.\n• Break programs up into short, single-purpose functions with meaningful names.\n\nLast updated on 2025-01-08 | Edit this page\n• How can I make sure my programs are correct?\n• Explain what an assertion is.\n• Add assertions to programs that correctly check the program’s state.\n• Explain what test-driven development is, and use it when creating new functions.\n• Explain why variables should be initialized using actual data values rather than arbitrary constants. Our previous lessons have introduced the basic tools of programming: variables and lists, file I/O, loops, conditionals, and functions. What they haven’t done is show us how to tell whether a program is getting the right answer, and how to tell if it’s still getting the right answer as we make changes to it. To achieve that, we need to:\n• write programs that check their own operation,\n• write and run tests for widely-used functions, and\n• make sure we know what “correct” actually means. The good news is, doing these things will speed up our programming, not slow it down. The first step toward getting the right answers from our programs is to assume that mistakes will happen and to guard against them. This is called defensive programming, and the most common way to do it is to add assertions to our code so that it checks itself as it runs. An assertion is simply a statement that something must be true at a certain point in a program. When MATLAB sees one, it checks the assertion’s condition. If it’s true, MATLAB does nothing, but if it’s false, MATLAB halts the program immediately and prints an error message. For example, this piece of code halts as soon as the loop encounters a value that isn’t positive: Programs like the Firefox browser are full of assertions: 10-20% of the code they contain are there to check that the other 80-90% are working correctly. Broadly speaking, assertions fall into three categories:\n• A precondition is something that must be true at the start of a function in order for it to work correctly.\n• A postcondition is something that the function guarantees is true when it finishes.\n• An invariant is something that is always true at a particular point inside a piece of code. For example, suppose we are representing rectangles using an array of four coordinates , such that (x0,y0) are the bottom left coordinates, and (x1,y1) are the top right coordinates. In order to do some calculations, we need to normalize the rectangle so that it is at the origin, measures 1.0 units on its longest axis, and is oriented so the longest axis is the y axis. Here is a function that does that, but checks that its input is correctly formatted and that its result makes sense: % Normalizes a rectangle so that it is at the origin % and is oriented with the longest axis in the y direction: Error using normalize_rectangle (line 7) Rectangle must contain 4 coordinates The post-conditions help us catch bugs by telling us when our calculations cannot have been correct. For example, if we normalize a rectangle that is taller than it is wide, everything seems OK: but if we normalize one that’s wider than it is tall, the assertion is triggered: Re-reading our function, we realize that line 21 should divide by . If we had left out the assertion at the end of the function, we would have created and returned something that had the right shape as a valid answer, but wasn’t. Detecting and debugging that would almost certainly have taken more time in the long run than writing the assertion. But assertions aren’t just about catching errors: they also help people understand programs. Each assertion gives the person reading the program a chance to check (consciously or otherwise) that their understanding matches what the code is doing. Most good programmers follow two rules when adding assertions to their code. The first is, fail early, fail often. The greater the distance between when and where an error occurs and when it’s noticed, the harder the error will be to debug, so good code catches mistakes as early as possible. The second rule is, turn bugs into assertions or tests. If you made a mistake in a piece of code, the odds are good that you have made other mistakes nearby, or will make the same mistake (or a related one) the next time you change it. Writing assertions to check that you haven’t regressed (i.e., haven’t re-introduced an old problem) can save a lot of time in the long run, and helps to warn people who are reading the code (including your future self) that this bit is tricky. Suppose you are writing a function called that calculates the average of the numbers in a list. What pre-conditions and post-conditions would you write for it? Compare your answer to your neighbor’s: can you think of an input array that will pass your tests but not hers or vice versa? An assertion checks that something is true at a particular point in the program. The next step is to check the overall behavior of a piece of code, i.e., to make sure that it produces the right output when it’s given a particular input. For example, suppose we need to find where two or more time series overlap. The range of each time series is represented as a pair of numbers, which are the time the interval started and ended. The output is the largest range that they all include: Most novice programmers would solve this problem like this:\n• Call it interactively on two or three different inputs.\n• If it produces the wrong answer, fix the function and re-run that test. This clearly works–after all, thousands of scientists are doing it right now–but there’s a better way:\n• Write a function that should pass those tests.\n• If produces any wrong answers, fix it and re-run the test functions. Writing the tests before writing the function they exercise is called test-driven development (TDD). Its advocates believe it produces better code faster because:\n• None If people write tests after writing the thing to be tested, they are subject to confirmation bias, i.e., they subconsciously write tests to show that their code is correct, rather than to find errors.\n• None Writing tests helps programmers figure out what the function is actually supposed to do. Below are three test functions for , but first we need a brief aside to explain some MATLAB behaviour. The syntax returns a matrix of logical values. If we just want a or answer for the whole matrix (e.g. to use with ), we need to use instead. Looking For Help For a more detailed explanation, search the MATLAB help files (or type at the command prompt). The error is actually reassuring: we haven’t written yet, so if the tests passed, it would be a sign that someone else had and that we were accidentally using their function. And as a bonus of writing these tests, we’ve implicitly defined what our inputs and output look like: we expect two or more input arguments, each of which is a vector with length = 2, and we return a single vector as output. Given that will have to accept varying numbers of input arguments, we need to learn how to deal with an unknown number of input arguments before we can write . Consider the example below from the MATLAB documentation: MATLAB has a special variable which can be used as the last parameter in a function definition to represent a variable number of inputs. Within the function is a cell array containing the input arguments, and the variable gives the number of input arguments used during the function call. A cell array is a MATLAB data type with indexed data containers called cells. Each cell can contain any type of data, and is indexed using braces, or “curly brackets” . Using what we have just learned about and fill in the blanks below to complete the first draft of our function. Now that we have written the function , when we run the tests: we shouldn’t see an error. Something important is missing, though. We don’t have any tests for the case where the ranges don’t overlap at all, or for the case where the ranges overlap at a point. We’ll leave this as a final assignment. Fix . Uncomment the two commented lines in . You’ll see that our objective is to return a special value: (Not a Number), for the following cases:\n• The ranges overlap at their endpoints. As you make change to the code, run regularly to make sure you aren’t breaking anything. Once you’re done, running shouldn’t raise any errors. Hint: read about the function in the help files to make sure you understand what these first two lines are doing. Once testing has uncovered problems, the next step is to fix them. Many novices do this by making more-or-less random changes to their code until it seems to produce the right answer, but that’s very inefficient (and the result is usually only correct for the one case they’re testing). The more experienced a programmer is, the more systematically they debug, and most follow some variation on the rules explained below. The first step in debugging something is to know what it’s supposed to do. “My program doesn’t work” isn’t good enough: in order to diagnose and fix problems, we need to be able to tell correct output from incorrect. If we can write a test case for the failing case—i.e., if we can assert that with these inputs, the function should produce that result—then we’re ready to start debugging. If we can’t, then we need to figure out how we’re going to know when we’ve fixed things. But writing test cases for scientific software is frequently harder than writing test cases for commercial applications, because if we knew what the output of the scientific code was supposed to be, we wouldn’t be running the software: we’d be writing up our results and moving on to the next program. In practice, scientists tend to do the following:\n• None Test with simplified data. Before doing statistics on a real data set, we should try calculating statistics for a single record, for two identical records, for two records whose values are one step apart, or for some other case where we can calculate the right answer by hand.\n• None Test a simplified case. If our program is supposed to simulate magnetic eddies in rapidly-rotating blobs of supercooled helium, our first test should be a blob of helium that isn’t rotating, and isn’t being subjected to any external electromagnetic fields. Similarly, if we’re looking at the effects of climate change on speciation, our first test should hold temperature, precipitation, and other factors constant.\n• None Compare to an oracle. A test oracle is something—experimental data, an older program whose results are trusted, or even a human expert—against which we can compare the results of our new program. If we have a test oracle, we should store its output for particular cases so that we can compare it with our new results as often as we like without re-running that program.\n• None Check conservation laws. Mass, energy, and other quantities are conserved in physical systems, so they should be in programs as well. Similarly, if we are analyzing patient data, the number of records should either stay the same or decrease as we move from one analysis to the next (since we might throw away outliers or records with missing values). If “new” patients start appearing out of nowhere as we move through our pipeline, it’s probably a sign that something is wrong.\n• None Visualize. Data analysts frequently use simple visualizations to check both the science they’re doing and the correctness of their code (just as we did in the opening lesson of this tutorial). This should only be used for debugging as a last resort, though, since it’s very hard to compare two visualizations automatically. We can only debug something when it fails, so the second step is always to find a test case that makes it fail every time. The “every time” part is important because few things are more frustrating than debugging an intermittent problem: if we have to call a function a dozen times to get a single failure, the odds are good that we’ll scroll past the failure when it actually occurs. As part of this, it’s always important to check that our code is “plugged in”, i.e., that we’re actually exercising the problem that we think we are. Every programmer has spent hours chasing a bug, only to realize that they were actually calling their code on the wrong data set or with the wrong configuration settings, or are using the wrong version of the software entirely. Mistakes like these are particularly likely to happen when we’re tired, frustrated, and up against a deadline, which is one of the reasons late-night (or overnight) coding sessions are almost never worthwhile. If it takes 20 minutes for the bug to surface, we can only do three experiments an hour. That doesn’t mean we’ll get less data in more time: we’re also more likely to be distracted by other things as we wait for our program to fail, which means the time we are spending on the problem is less focused. It’s therefore critical to make it fail fast. As well as making the program fail fast in time, we want to make it fail fast in space, i.e., we want to localize the failure to the smallest possible region of code:\n• None The smaller the gap between cause and effect, the easier the connection is to find. Many programmers therefore use a divide and conquer strategy to find bugs, i.e., if the output of a function is wrong, they check whether things are OK in the middle, then concentrate on either the first or second half, and so on.\n• None N things can interact in N2 different ways, so every line of code that isn’t run as part of a test means more than one thing we don’t need to worry about. Replacing random chunks of code is unlikely to do much good. (After all, if you got it wrong the first time, you’ll probably get it wrong the second and third as well.) Good programmers therefore change one thing at a time, for a reason. They are either trying to gather more information (“is the bug still there if we change the order of the loops?”) or test a fix (“can we make the bug go away by sorting our data before processing it?”). Every time we make a change, however small, we should re-run our tests immediately, because the more things we change at once, the harder it is to know what’s responsible for what (those N2 interactions again). And we should re-run all of our tests: more than half of fixes made to code introduce (or re-introduce) bugs, so re-running all of our tests tells us whether we have regressed. Good scientists keep track of what they’ve done so that they can reproduce their work, and so that they don’t waste time repeating the same experiments or running ones whose results won’t be interesting. Similarly, debugging works best when we keep track of what we’ve done and how well it worked. If we find ourselves asking, “Did left followed by right with an odd number of lines cause the crash? Or was it right followed by left? Or was I using an even number of lines?” then it’s time to step away from the computer, take a deep breath, and start working more systematically. Records are particularly useful when the time comes to ask for help. People are more likely to listen to us when we can explain clearly what we did, and we’re better able to give them the information they need to be useful. Version control is often used to reset software to a known state during debugging, and to explore recent changes to code that might be responsible for bugs. In particular, most version control systems have a command that will show who last changed particular lines of code… And speaking of help: if we can’t find a bug in 10 minutes, we should be humble and ask for help. Just explaining the problem aloud is often useful, since hearing what we’re thinking helps us spot inconsistencies and hidden assumptions. Asking for help also helps alleviate confirmation bias. If we have just spent an hour writing a complicated program, we want it to work, so we’re likely to keep telling ourselves why it should, rather than searching for the reason it doesn’t. People who aren’t emotionally invested in the code can be more objective, which is why they’re often able to spot the simple mistakes we have overlooked. Part of being humble is learning from our mistakes. Programmers tend to get the same things wrong over and over: either they don’t understand the language and libraries they’re working with, or their model of how things work is wrong. In either case, taking note of why the error occurred and checking for it next time quickly turns into not making the mistake at all. And that is what makes us most productive in the long run. As the saying goes, A week of hard work can sometimes save you an hour of thought. If we train ourselves to avoid making some kinds of mistakes, to break our code into modular, testable chunks, and to turn every assumption (or mistake) into an assertion, it will actually take us less time to produce working programs, not more.\n• Use assertions to catch errors, and to document what behavior is expected."
    },
    {
        "link": "https://cse.unl.edu/~sincovec/Matlab/Lesson%2019/CS211%20Lesson%2019%20-%20Strings%20and%20String%20Functions.htm",
        "document": "\n• Be able to find and replace substrings within strings\n• Be able to convert between numbers and strings\n• MATLAB represents a text string as an row vector of characters (char data type), where each character is stored in 2 bytes of memory.\n• String literals are represented as a sequence of characters enclosed in single quotes, e.g., .\n• Consider the output of the following code: Letters = 'abcde';\n\ndisp(Letters); % display Letters (as a char array)\n\nfprintf('%s\n\n', Letters); % display Letters as a string\n\nfprintf('%c\n\n', Letters); % display each character of Letters\n\nfprintf('%d\n\n', Letters); % display Unicode values of Letters\n• When using , MATLAB displays a character array variable as a string.\n• To input a value as a character array, you must include as the second argument of the function. For example,\n• You can reference individual or multiple characters within a char array in the same way you access elements within other row vectors. For example,\n• You can create 2-D character arrays, but all rows must have the same number of columns.\n• Consider the output of the following code: % notice the trailing blanks to make them all the same length % the char() function adds the required trailing blanks for you\n• Cell arrays (which will be covered in Lesson 21) are the best way to store an array of strings .\n• MATLAB provides many useful functions for string manipulation. Only a few of them are presented in this lesson. If you would like to investigate additional string functions, search for \" \" in the MATLAB help system.\n• Use the function (not ) to get the number of characters in a string.\n• Use the and functions to convert between numbers and strings.\n• To manipulate a character's Unicode value as a number, cast the character to a number.\n• To convert a number into its equivalent Unicode character, cast the number into a char.\n• Use the logical function to determine if a variable is a char array.\n• Concatenation appends one string to the end of another.\n• takes two or more strings as input arguments, concatenates them, and returns a single string as an output argument.\n• concatenates strings vertically padding with spaces to create a 2-D matrix (like ).\n• Use the logical function (or one of its variants) to compare strings for equality.\n• Do not use the equality operator ( ) to compare strings for equality!\n• Use to compare the first n characters of a string.\n• Use to compare the first n characters of a string ignoring case.\n• It is OK to compare individual characters in a string using the (equality) operator:\n• MATLAB does not provide a function to determine alphabetical (lexicographical) ordering of strings\n• Use the function to remove trailing blanks from a string.\n• Use the function to remove leading and trailing blanks from a string.\n• Use the function to convert all upper case letters in a string to lower case.\n• Use the function to convert all lower case letters in a string to upper case.\n• Use the function to determine the category of individual characters within a string\n• Categories include: alpha, alphanum, cntrl, digit, lower, wspace, upper, and xdigit (see isstrprop in the MATLAB help system).\n• Use the function to find a substring within a string .\n• returns a row vector containing the starting indexes of the matching substrings within a string.\n• if the substring is not present in the string, returns an empty vector, not zero.\n• Use the function to test if a vector is empty.\n• Text = 'Give the check to Bill. Bill always pays the bill.';\n\nfindstr(Text, 'Bill')\n\nfindstr(lower(Text), 'bill')\n\nfindstr(Text, 'eggplant')\n• Use the function to find a string within a 2D array of strings, where each row is separate string.\n• If a third argument with a value of is passed to , then only exact matches will be recognized. Otherwise, partial matches are returned.\n• Use the function to replace every occurrence of substring with string within string . Consider the following example code: Text = 'Give the check to Bill. Bill always pays the bill.';\n\n strrep(Text, 'Bill', 'Jill')\n\nstrrep(Text, 'always ', '')\n• The function is useful for removing words or \"tokens\" (separated by delimiters) from a string\n• The default delimiters are white space (blanks, tabs, and new-line characters).\n• The second optional parameter to is a vector of delimiters.\n• Remainder = 'This is a string.';\n\n[Word Remainder] = strtok(Remainder)\n\n[Word Remainder] = strtok(Remainder)\n\n[Word Remainder] = strtok(Remainder)\n\n[Word Remainder] = strtok(Remainder)\n• Always use the MATLAB string functions to create, compare, and manipulate string data.\n• MATLAB does not have a built-in function that will compare two strings and determine whether the first string is \"less than\", \"equal to\", or \"greater than\" a second string. Such a comparison is necessary if you were to sort a list of strings into alphabetical order, such as for a dictionary.\n• A basic algorithm for determining whether one string is less than another string requires that you skip over all characters that are equal to each other. Then you can base your comparison of the two strings on the first characters that are not equal. For example, when comparing \"Johnathon\" with \"Johnston\", the first string is less than the second string because 'a' is less than 's' in the 5th position of the strings.\n• An algorithm (written in MATLAB pseudocode) for a lexicographical comparison of two strings is below. The typical way to indicate \"less than\", \"equal to\", or \"greater than\" is by returning -1, 0, and +1 respectively.\n\n \n\n % Skip over all the characters that are equal\n\n Index = 1;\n\n while Index < length(String1) and Index < length(String2) and String1(index) == String2(index)\n\n Index = Index + 1;\n\n end\n\n \n\n % Return the appropriate code\n\n if String1(Index) < String2(Index) then return -1: \n\n elseif string1(Index) > string2(Index) then return +1;\n\n else % the characters at this position are equal -- the shorter of the two strings should be \"less than\"\n\n if length(String1) == length(String2) then return 0; % they are \"equal\"\n\n elseif length(String1) < length(String2) then return -1;\n\n else return +1;\n\n end"
    }
]