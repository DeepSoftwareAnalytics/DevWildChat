[
    {
        "link": "https://dreamsof.dev/2020-01-15-scaffolding-new-vanilla-react-app-with-typescript",
        "document": "Righto, I want to get deeper into vanilla React development (outside of the scope of SharePoint). This will enable me to utilise all of my React skills for future endeavours. I will be scaffolding a new React app using TypeScript because I put great value on Type safety when working within JavaScript - this is a preference I don’t want to shy away from due to my background as a C# dev.\n\nCheck the installed version of npm, update if necessary.\n\nThe app is now running in your browser (or at least it should be).\n\nNavigate to, and update the tag within the App.tsx file as follows:\n\nSave the App.tsx file; the app in your browser should automatically refresh the DOM showing the changes. You can go to the Dev Tools in Chrome by hitting F12 and monitor the components as they update - only the changed component will update - this is the core of React!\n\nWe’re not done yet! Let’s improve our workflow a little by installing and configuring TSLint.\n\nThe reason that we use the deprecated version is because it’s rated 5 stars, where the new version is rated only 3 stars (and buggy AF).\n\nNavigate to the root of your app folder structure, add a new file\n\nYou can use my example as a starting point.\n\nWork your way through the scaffolded and files and resolve the rules issues you see. Here is an example:\n\nHere you’ll see the default App.tsx component, which uses single quotation marks for import strings (among others).\n\nPressing [Ctrl + .] (period) will provide the following options; note that you can select to only fix a single instance, or even disable linting for the very next line. We would fix all per the screenshot in this instance.\n\nRight, we’ve got a basic app scaffolded. Now it’s time to add some more functionality.\n\nI’m going to scaffold a new component that will be used as a basis for future blog posts on the subject. We’re adding properties and state functionality that doesn’t do a hell of a lot now, but will be used in future.\n\nProperties are used to configure a component at the time it’s run; I typically use this for configuration of the component.\n\nState is used where a component will change at some point and that change must be re-rendered in the UI; I typically use State where dynamic data is a concern.\n\nAdd a new folder structure to the project;\n\nWithin that new folder, add the following files:\n\nNow update those files as follows:\n\nAdd the new Component to the App\n\nRight, we’ve now got a new component. How do we get that to be visible within our React app?\n\nWe’re going to return to App.tsx and make the following update.\n\nYou should see something similar to the following (red text being the very boring component we just added).\n\nWe’re done here, the App is ready for us to add functionality and flesh it out - as mentioned previously, I plan to use this app to highlight other functionality."
    },
    {
        "link": "https://graphite.dev/guides/typescript-cra",
        "document": "In this guide, we'll walk through setting up a new React project with TypeScript using Create React App.\n\nCreate React App is an officially supported command-line interface (CLI) tool from Facebook that helps developers to create single-page React applications quickly without dealing with complex configurations. It sets up the environment so you can use the latest JavaScript features, providing a good developer experience and optimizing the application for production.\n\nBefore you start, ensure you have the following installed:\n• npm (comes with Node.js) or yarn (alternative package manager)\n\nTo create a new React app with TypeScript, you can use the command, which comes with npm 5.2+ and higher. allows you to run command-line tools from npm without installing them globally.\n\nOpen your terminal and run the following command:\n\nHere, is the name of your project. You can replace it with your preferred project name. The flag tells Create React App to use the TypeScript template.\n\nThis command does a few things: - : Executes the Create React App CLI without requiring a global installation. - : The CLI command to scaffold new React applications. - : The directory name for your new application. - : Specifies that you want to use the TypeScript template.\n\nOnce the setup is complete, navigate to your project directory:\n\nThis command starts the development server and opens your new React app in the browser. You should see the default CRA welcome screen.\n\nYour newly created React app with TypeScript will have the following structure:\n• : This directory contains the source code for your React app.\n• : The main component of your app.\n• : The entry point of your app.\n• : Provides TypeScript with information about the environment.\n• : This directory contains static files like .\n\nBy default, CRA with TypeScript comes with a few type definitions. You can add more types as needed.\n\nTypescript also leverages props to provide structure to components. Props (short for properties) are used to pass data and event handlers from a parent component to a child component in frameworks like React. They help maintain a structured and manageable way of controlling component behavior and rendering dynamic content based on the passed data.\n\nFor example, let's create a new component with typed props:\n\nIn this example, we define an interface that describes the props our component expects. The prop must be a string. This ensures type safety and provides better developer experience with autocompletion and type checking.\n\nUsing the new component\n\nTo use the component, import it and include it in your :\n\nExporting a component makes it available to be used in other parts of an application by including an keyword before the component definition. This allows other files or components to import and utilize the exported component, facilitating modular and reusable code architecture.\n\nThe file is where you configure TypeScript options. CRA provides a sensible default configuration, but you can customize it according to your needs. Here is an example :\n\nThis example configuration specifies that the code should compile to ES5 (a version of JavaScript), making it compatible with older browsers. The configuration also enables various features, such as allowing JavaScript files ( ), importing JSON modules ( ), and using JSX syntax ( ) set specifically for React, ensuring interoperability with CommonJS and ES modules. Additionally, it enforces stricter coding practices ( ), like consistent file naming ( ) and preventing fall-through cases in switch statements ( ), while excluding output generation ( ), focusing solely on type-checking and syntax verification.\n\nYou can add additional packages to your project using npm or yarn. For example, to add React Router for navigation, run:\n\nThe package provides TypeScript definitions for React Router.\n\nTo maintain code quality, you can integrate ESLint and Prettier into your project. CRA with TypeScript already includes ESLint, but you can customize it further.\n\nInstall Prettier and ESLint configuration for Prettier by running:\n\nThis file specifies the formatting rules to automatically apply to your codebase for consistency and style adherence.\n\nUpdating your to include Prettier ensures that your code not only adheres to the best practices and conventions defined by ESLint but also aligns with the consistent formatting enforced by Prettier. This integration allows for the automatic highlighting of style issues as errors, which can be fixed on-the-fly, improving code quality and efficiency.\n• To start the development server, use:\n• This command compiles the TypeScript code and opens your application in a web browser, watching for any changes you make to the files.\n• To build the application for production, use:\n• This command prepares the application for deployment, optimizing and minifying the code.\n\nYou have now created your first react app using Create React App and TypeScript!\n\nFor further reading see the official Create React App documentation."
    },
    {
        "link": "https://jetbrains.com/guide/javascript/tutorials/react_typescript_tdd/project_setup",
        "document": "React has become very popular, as has TypeScript. But it can be difficult to keep your tools and build configurations up-to-date. Many frameworks have CLI (command-line interface) tools that make those decisions for you, using best practices. They'll generate a project with the right choices, then update those choices as things evolve.\n\nReact's create-react-app takes care of this, including for TypeScript projects. In this tutorial step, we will generate a React+TypeScript project then open it in the IDE.\n\nThe finished code for this tutorial step is in the repository.\n\nBefore starting, make sure to install Node.js on your system.\n\nAs shown in the create-react-app docs, use the command introduced in npm 5.2 to get a package and install a command, without having to globally install a package. Thus, to use to make a TypeScript project:\n\nIf you are using a JetBrains IDE that includes WebStorm, you can use a nice UI for new projects:\n\nYou now have a working React+TypeScript project, toolchain, and hello-world style app. It's actually quite an achievement. Assembling all of this, and it assembled, is an incredible effort. has shifted that off your shoulders, onto their shoulders.\n\nLet's see this React+TypeScript app in our browser. scripts make it easy to discover commands that are common to a project. The most common? Starting the dev server, which compiles the universe, serves a page over HTTP, and helpfully opens your browser:\n\nThis dev server is now watching for changes. If you edit a file, it will regenerate the universe and tell the browser to reload the page. Open and change to , then save. Your terminal shows a recompile and your browser updates.\n\nIn the terminal, (macOS) / (Windows/Linux) to stop the dev server. Let's take a look at how the IDE can put a nice friendly face on running scripts.\n\nWe will first use the tool window. Click on the tool icon (usually on the left) and double click in the listing of run scripts. You'll get a run window at the bottom with a UI for showing output and restarting.\n\nAlternatively, open the top-level that was generated by . Here's what the scaffold provided -- note the section:\n\nLet's run the script from here, instead of the tool window. First, close the currently-running tool window and dev server, then close the tool that is listing the available scripts. Now, in , click the green play icon in the gutter by the run script:\n\nAs you can see, the generated is quite compact. The genius of lies in moving a bunch of \"What the hell is this?\" configuration files, into packages. Thus, own those decisions and complexity. You can then upgrade those packages and gain new/fixed wiring of all the JavaScript build tools.\n\nThat's great for development, but for production, we need files on disk, shrunk as small as possible. There's a lot of complexity behind this, but has hidden it behind an npm script:\n\nThis generates output into a directory. The output is self-contained, even including an file. Thus, you can copy the site to a static hosting site, as-is.\n\nRunning this in the IDE's UI, instead of the terminal, is easy: just click on in the tool window, or better still, use the gutter icon in .\n\nThe IDE should mark the new directory as \"excluded\" giving it a different color in the folder listing. If not, right-click on the new directory and . This prevents the IDE from indexing the contents of that directory.\n\nThis Is Only a Test\n\nProjects generated from are also wired up for testing: dependencies, configuration files, and sample tests. We'll see more later, but for now, let's run the tests. Unsurprisingly, it's similar to the above:\n\nuses the Jest test framework along with helpers from Testing Library. Jest runs when source or test files change, so make a small edit to change the to . When you save the file, you'll see that the tests re-run and pass:\n\nWe can also run this script in the IDE. to stop the test runner in the terminal, then back in , click the green play icon in the gutter beside .\n\nIn this first step we used existing tools to generate a working React+TypeScript project, with all the tooling configured. We also gave a brief tour of driving this in the IDE.\n\nIn our next step we'll clean up some of the generated app, fix some of the tooling, and take a look a little more at how TypeScript helps your productivity."
    },
    {
        "link": "https://aimconsulting.com/insights/react-app-scaffolding-tip-to-organize-your-directories",
        "document": "If you’re a React developer, you’ve likely spun up a new React app countless times.\n\nIn recent years, you’ve probably been using a project generator. You might be running npx create-react-app my-app, npx create-next-app@latest, or npm init gatsby.\n\nIn this article, we’ll outline the set of steps that take place immediately after this command, starting when you open your new project in an IDE, access , and create your first directory.\n\nThough creating a directory is one of the simplest things a developer does, it’s not as simple as you may think. The directories you create and the libraries you install—the toolsets and developer experience you put in place in your first minutes with this new project—can have a huge impact on how flexible and easy to maintain the application will be.\n\nStrategies & libraries you can employ when scaffolding your React app include:\n\nApplications that grow usually do so for a reason: they are useful and necessary. If you work on or manage a growing application, you will eventually encounter the time suck we call IDE file structure scroll.\n\nThis occurs when working in a directory of a directory of a directory, for example, a , with 15 or 20 components. At one point, you need to access a file in your folder and a file in your folder, where state is managed.\n\nIf these directories are all named purely alphabetically, you will have to scroll up, open the directory to access file one, and then scroll far down to open the directory and access file two.\n\nThough this won’t seem like a huge hassle the first few times you encounter it, keep in mind that and are a special type of directory. They contain files that are accessed on a regular basis by many parts of the application.\n\nConsequently, during development, you will need to access them frequently. The time spent scrolling up to and down to adds up to minutes which — over the lifetime of the application — will add up to hours.\n\nand are also much less likely to contain hundreds of directories or files than . Even with their folders open in the IDE, they have a less significant effect on IDE file structure scroll than .\n\nThey are, as we mentioned above, a special type of directory and both contain files that are accessed on a regular basis by many parts of the application.\n\nWith this in mind, it makes sense to anchor them in one place within your directory structure—both to make them simple to find and to make them accessible with one scroll.\n\nThe easy solution to this problem is to prefix these directories with an underscore ( ). The underscore preface will pin them to the top of the parent directory, providing a consistent placement for all high-use directories.\n\nYou can get more elaborate with your prefixes, adding numbers or letters to enforce more specific ordering, but often an underscore is enough.\n\nAs you can see in the image above, the new directory structure is more organized and cleaner. The commonly-used and universal resources are all in a consistent location at the top of the parent directory, so we know easily where to access them.\n\nLet’s say you’re a few days in with your new React app when you decide to make the above change and prefix some directories with an underscore.\n\nIf you navigate the file structure via command line or your operating system’s file inspector and simply rename the directory to , every reference to in your application will break.\n\nIf you’re using an IDE like Visual Studio Code, it will probably recommend that those paths be rewritten, which is great.\n\nBut there is a more transparent and durable way to make your application automatically support the renaming of these top-level directories using aliased directories.\n\nAn alias is a secondary or symbolic reference to an expression, symbol, or path. When you configure an aliased directory in a React app, you tell Webpack what absolute path that alias represents. You are then free to use the alias instead of the absolute relative path in your imports.\n\nYou can now move this file to a different directory without breaking the import of MyNewWidget. You can also rename entirely.\n\nWhen you update the aliased directory configuration, all imports from will continue to work as before.\n\nAs we mentioned above, Visual Studio Code and some other IDEs will offer to fix import paths when you move a directory, but aliased directories are built into the application and not dependent upon the IDE to fix your mistakes.\n\nIf you’re using Craco, you can configure aliased directories with a file:\n\nNote that in the example above, not every directory and child directory in the application has been aliased. Typically only the top-level directories in the codebase are aliased, and nothing below.\n\nA few of the aliases are prefaced with . This is a trick we use to avoid conflicts with external npm libraries. For example, our project has a directory named . This can cause imports of the Redux library ( ) to conflict with your imports from your local directory.\n\nIn general, any alias with a name similar to a commonly used React library we preface with . You can use whatever affix (or suffix) you like to prevent these conflicts.\n\nOne tedious aspect of aliased directories is that you may need to configure and update them in a few different places, depending on your configuration. Typescript may need to be configured as well as Webpack:\n\nFinally, Jest and React Testing Library execute in a separate runtime. If you are getting errors about imports when running unit tests, add the alias declarations to the jest config in :\n\nNow that you have the tools to create a much more useable, durable directory structure that will reduce developer hassles and more easily adapt to changes in the codebase, let’s take a look at a few more examples. Below is the path to from the example above:\n\nLet’s say you want to import 5 widgets from . With no additional changes, those imports would look like so:\n\nA lot of React developers are accustomed to Visual Studio Code, and VS Code will often automatically suggest these import paths for you.\n\nBut that’s still a lot of lines of imports. Additionally, each path has to go all the way to the Javascript file in which the component is defined.\n\nNot pretty. This project could do with some barrel files.\n\nThere are many articles about barrel files on the Internet, but most of them don’t start from first principles. We’ve already seen that in React you import modules where they will be used. Conversely, before a module can be used, it must be exported.\n\nIf you have written a React component before you have exported a module:\n\nWithout that at the bottom of the file, your component can’t be used anywhere else in the app. Barrel files are files that standardize and consolidate the exporting of modules.\n\nThere are just about as many novel barrel file patterns as there are blog posts about barrel files. We’ll outline one simple pattern and explain how it works together with aliased directories.\n\nFirst, every component we create has an file in it, a barrel file for one or a few components, that exports the main component in the directory as well as any child components that might be imported elsewhere.\n\nMost components only need one export. If a child component doesn’t need to be imported elsewhere, it doesn’t need to be exported:\n\nFor a directory like , which has a lot of child elements at the same level that are likely to be referenced in multiple places in the app, it’s worthwhile to create an additional barrel file at .\n\nNote that because we have an with an export in each individual component directory, my paths no longer have to go all the way to :\n\nAlso note that we’re renaming and exporting the default export from each component directory. If there were other, non-default components those exports would look different:\n\nWhat we have effectively done, in , is turn into a local component library. Now, when we want to import 5 components from , instead of 5 individual default imports:\n\nWe can have a single import path to with 5 named imports:\n\nWith that, we’ve created a more durable and legible import pattern that can be leveraged all over the application.\n\nOne helpful tool is a template extension to automatically generate new components that follow these patterns.\n\nThis is especially helpful, in large projects with multiple developers, for keeping the export patterns consistent across barrel files.\n\nYou can also use extensions that automatically generate barrel files but be sure that the pattern the extension uses will produce the kinds of imports you want for your application.\n\n“Fake It, Till You Make It:” Internalization Before Translation\n\nIf you’ve worked as a freelance front-end developer for any amount of time, you’ve likely had this experience:\n• Client contracts you to develop an app\n• You develop and launch the app\n• Client requests that another language be added to the app\n\nUnlike almost everything else in a React app, natural language strings are notoriously hard to search for or locate using an automated tool. It takes very little effort to implement and utilize internationalization library under the hood; it takes an immense amount of effort to implement one later.\n\nWe recommend that you implement an internationalization library as soon as you start. Don’t even ask your client. She (and your team) will thank you later.\n\nThere are very simple and very complex libraries in this category. And there are heavyweight solutions, like , that ship utilities for not only tagging language strings and switching between languages, but also for importing and exporting language string sets for manual or automated translation.\n\nThese libraries all work in a similar fashion. You declare or initialize the library, sometimes wrapping the rest of your application in a provider, and feed in the set of language strings.\n\nWhen your user toggles a language select, you update a or prop on that provider.\n\nWe’ve mentioned that will export your full collection of language strings for you. This library is well-suited to large projects with manual or automated translation workflows.\n\nWith a workflow of this sort, you would export the language strings from your application to a JSON file, hand them off to a team of translation talent, and get back a series of translated JSON files, one for each language.\n\nIn cases like this, the prop is especially important as it gives the translator what might be important context for translation.\n\nLet’s say your client is securing this translation talent as you work, but you will be developing the app for weeks or perhaps months before those translators get ahold of your file of strings.\n\nWhat happens if you need to test or demonstrate the locale switching before that?\n\nThere are automated solutions that will take an AI’s best guess at how long a given string might be in your most lengthy locale (usually German). But we’ve also created Node.js scripts to generate fake translation files:\n\nThis simple script loops through each locale and generates a new file with fake translations. The fake translations consist of the default string (in this case, in ) and the new locale.\n\nUntil official translations are provided, these files can be imported back into the application to test locale switching.\n\nTypescript or Not Typescript: That Is the Question\n\nFor most developers, their relationship with Typescript is either love or hate. Typescript maintainers call it a “superset” of Javascript.\n\nTypescript was developed because Javascript is a loosely typed language. You do not have to declare the data types of variables, and you can intentionally or accidentally change data types during execution.\n\nThis can result in unexpected behavior. For example, , a comparison of the number 1 with the string “1”, is .\n\nThose who have been working with Javascript for a long time understand this and anticipate when to be cautious about data type and when we can safely leverage loose typing.\n\nThey know to force type when checking equivalency. For example, is false. And they (probably) have some habits that involve on-the-fly type coercion.\n\nTypescript, by contrast, enforces static typing on Javascript. Variables are declared with typing, and that typing is enforced.\n\nThere are many advantages to strict typing. For any project under active development by a team of developers, anything more complex than a simple single page app or a Gatsby site, Typescript is a good idea.\n\nBut for your weekend project or your sister-in-law’s knitting blog, it might not be worth the overhead. Weigh Typescript’s advantages over the learning curve and implementation challenges.\n\nThe adoption of Typescript often goes hand in hand with the jettisoning of PropTypes prop checking from the project.\n\nIt’s important to remember that Typescript and PropTypes do different things. Typescript checks types within your code during composition. PropTypes checks the type of any prop fed into your component at runtime.\n\nTypescript is therefore not the best tool to verify that data you receive at runtime is of the proper type or format. External data fetched from an API at runtime may still benefit from old-fashioned PropTypes checking.\n\n[ES]Lint Traps: Is Stricter Always Better?\n\nESLint is the linting solution in place in most React applications. ESLint offers a lot of rules. Some pertain to JS conventions, others to formatting and layout.\n\nThere are a variety of rulesets that can be installed and extended within your ESLint config. Some are very strict, some relatively lenient.\n\nWhat you must decide is how strict or lenient to be, and how this is informed or affected by your overall business and management strategies.\n\nTypically, there are two ways to manage onboarding risk for a development team:\n\nThe first is to lock down your applications in various ways: with strict typing, ESLint rulesets, and other kinds of scaffolding strategies.\n\nThe second is to create a culture of documentation, collaboration, and low-stakes learning among your developers.\n\nIf a strict set of linting rules is justified by your security or reliability needs, or those of your clients, then by all means use the tools available to your organization. But we recommend that you first consider the long-term benefits of offering young talent a more lenient development experience and a supportive work culture.\n\nESLint and Typescript should never be a substitute for proper mentorship and a positive work environment.\n\n“But There’s Nothing To Test!” Jest and React Testing Library\n\nIt’s frustrating to stop and add unit tests when you’ve just started building your application. Especially for layout components that receive few or no props.\n\nA way around this is to add a very simple test file to every new component you create: a test that simply renders the component. This test file can be generated from a template as the rest of the component is scaffolded.\n\nYou may have noticed that the Create React App generator creates a test file in the root directory:\n\nYou might think that simply rendering the component doesn’t test anything. And it is true that there are no statements in the above snippet. Jest alone will provide basic testing of return values for utilities and custom hooks, and these tests should be put in place concurrent with function and hook development.\n\nBut for components, you can catch a lot of errors in your application logic and JSX by simply rendering the component when unit tests are run. Oftentimes we don’t even know what functionality will be added to a component when scaffolding out the application, and it doesn’t make sense yet to test for language strings, images, styling, or responses to click events.\n\nInstead, simply be consistent. Implement a component template, and configure it to create a test file which automatically renders the component.\n\nAnd when someone on the team circles back to add test coverage, the files and rendering will already be in place.\n\nMirror Mirror On the Wall, Who’s the Prettiest of Them All?\n\nIf you’ve been working as a developer long enough, you remember the days when code style standards were enforced manually, in code reviews, and referenced in extensive documentation.\n\nFortunately, most modern IDEs now support formatting plugins. For Javascript projects, the most common plugin is Prettier.\n\nImplementing Prettier is simple: everyone on the team installs the Prettier plugin on their IDE, you agree on your formatting preferences, and you add Prettier configuration to .\n\nPrettier does something different than Typescript or ESLint, and in fact if you’re not careful Prettier’s Format on Save can conflict with some ESLint rules, reintroducing the issue as soon as you save the file.\n\nBut instating and uniformly using a Prettier configuration will help your team to avoid introducing unmodified but reformatted lines into your git commits.\n\nWhat is “A11y” Anyway?\n\nIt takes years of automated and manual testing—not to mention training—to build skills in Web accessibility (commonly abbreviated as A11y).\n\nThere are rudimentary aspects like tags, s, and color contrast issues that are easily checked with automated tools. But these automated checks can’t teach a nuanced application of semantic HTML5 elements, or how to manually test for keyboard traps.\n\nFor this reason, it’s difficult to reach a state where your entire front-end team and development teams are fully qualified to conduct an audit for WCAG level AA accessibility.\n\nWhat you can do is teach your developers to run an automated test every time they update an interface. Pa11y is an excellent tool that can be run locally.\n\nChrome’s Lighthouse also includes an A11y audit. These tools won’t catch everything, but they will rule out common A11y issues and save time that can be allocated to manual A11y audits.\n\nOne Script to Bring Them All and in the [Pipeline] Bind Them\n\nIf your organization’s git repository provider offers a CI/CD pipeline, use it to run the build script and execute automated checks exposed by the tools introduced above.\n\nUnit tests, ESLint, accessibility, and Prettier checks can be run for each pull request. Translation files can be exported, and fake translation files generated, before an Express server is stood up for testing.\n\nGet these automated checks in place as soon as possible so your developers can get used to the process: you don’t want to be stuck troubleshooting the 342 ESLint and React Testing Library failures blocking urgent pull requests two days before your site goes live.\n\nThere’s an added benefit to automating these checks on pull requests. When Jenkins is enforcing whatever coding standards you have chosen to employ, you also free up manual code reviews for higher-level discussion (increasing mentorship and improving that “supportive work culture” we mentioned above).\n\nThis article outlines basic scaffolding strategies (some as simple as naming a directory) that you can use to keep technical debt low and help your application grow with your development team and organization over time.\n\nThese are only a few of the strategies AIM consultants might recommend for your unique use cases and business needs.\n\nAt AIM Consulting, our application development approach is team-centric and holistic, from architecture and design to modernizing software development processes and custom application development.\n\nOur experts can help strategize and resolve issues with architecture, security, and buggy performance — and clear a stacked backlog.\n\nAIM Consultants work with your team to reach all of your current and future application development targets faster, more efficiently, and at the highest quality."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/typescript-new-project",
        "document": "You may have worked with TypeScript before when using a starter project or a tool like the Angular CLI. In this tutorial, you will learn how to set up a TypeScript project without a starter’s help. You will also learn how compiling works in TypeScript and how to use a linter with your TypeScript project.\n• Use Google TypeScript Style to Lint and Code\n\nTo complete this tutorial, you will need the following:\n• The latest version of Node installed on your machine. You can accomplish this by following the How to Install Node.js and Create a Local Development Environment tutorial.\n• Familiarity with . comes with Node. To learn more about working with , check out this How To Use Node.js Modules with and tutorial.\n\nTo begin your TypeScript project, you will need to create a directory for your project:\n\nNow change into your project directory:\n\nWith your project directory set up, you can install TypeScript:\n\nIt is important to include the flag because it saves TypeScript as a development dependency. This means that TypeScript is required for the development of your project.\n\nWith TypeScript installed, you can initialize your TypeScript project by using the following command:\n\nalso includes a tool called , which will run executable packages. allows us to run packages without having to install them globally.\n\nThe command is used here because it is the built-in TypeScript compiler. When you write code in TypeScript, running will transform or compile your code into JavaScript.\n\nUsing the flag in the above command will initialize your project by creating a file in your project directory. This file will allow you to configure further and customize how TypeScript and the compiler interact. You can remove, add, and change configurations in this file to best meet your needs.\n\nOpen in your editor to find the default configuration:\n\nThere will be many options, most of which are commented out:\n\nYou can customize your TypeScript configuration through the file. For instance, you might consider uncommenting the entry and setting it to , which will put all of your compiled TypeScript files into that directory.\n\nWith TypeScript installed and your file in place, you can now move on to coding your TypeScript app and compiling it.\n\nYou can now begin coding your TypeScript project. Open a new file named in your editor. Write the following TypeScript code in :\n\nWith this TypeScript code in place, your project is ready to be compiled. Run from your project’s directory:\n\nYou will notice that the compiled JavaScript file and the sourcemap file have both been added to the folder if you specified that in the file.\n\nOpen and you will find the following compiled JavaScript code:\n\nRunning the TypeScript compiler every time you make a change can be tedious. To fix this, you can put the compiler in watch mode which will recompile your code every time changes are made.\n\nYou can activate watch mode using the following command:\n\nYou’ve learned how the TypeScript compiler works, and you are now able to successfully compile your TypeScript files. You can take your TypeScript projects to the next level by introducing a linter into your workflow.\n\nStep 3 — Using Google TypeScript Style to Lint and Correct Your Code\n\nUsing a linter when coding will help you quickly find inconsistencies, syntax errors, and omissions in your code. Additionally, a style guide will not only help you ensure that your code is well-formed and consistent but also allow you to use additional tools to enforce that style. A common tool for these is eslint, which works well with many IDEs to help during the development process.\n\nWith your project now set up, you can use other tools in the TypeScript ecosystem to help and avoid having to set up linting and configuration in the file by hand. Google TypeScript Style is one such tool. Google TypeScript Style, known as GTS, is a style guide, linter, and automatic code corrector all in one. Using GTS will help you to quickly bootstrap a new TypeScript project and avoid focusing on small, organizational details to focus on designing your project. GTS also offers opinionated default configuration. This means that you won’t have to do much configuration customization.\n\nFrom here, initialize GTS using the following command:\n\nThe above command will generate everything you need to get started with your TypeScript, including a file and a linting setup. A file will also be generated if you don’t have one in place already.\n\nRunning will also add helpful scripts to your file. For example, you can now run to compile your TypeScript project. To check for linting errors, you can now run .\n\nNote: Installing TypeScript before installing GTS ensures that you have the most recent version of TypeScript when developing your application. As a result of GTS development moving more slowly than that of TypeScript, you may find that it will suggest downgrading TypeScript in your dev dependencies. You can instruct GTS not to overwrite this value if you need the newer features. Additionally, as the eslint TypeScript linter has a range of supported versions of TypeScript, newer versions of the language may fall outside of this range. In this case, eslint will warn you of such. There is a good chance that it will continue to work just fine, but if you do run into problems, you can downgrade your version of TypeScript by specifying it when you install it. For example, .\n\nGTS is now installed and properly integrated into your TypeScript project. Using GTS on future projects will allow you to quickly set up new TypeScript projects with the necessary configurations in place.\n\nAs GTS provides an opinionated, no-configuration approach, it will use its own sensible linting and fixing rules. These follow many best practices, but if you find yourself needing to modify the rules in any way, you can do so by extending the default rules. To do so, create a file in your project directory named which extends the style rules:\n\nThis will allow you to add to or modify the style rules provided by GTS.\n\nIn this tutorial, you began a TypeScript project with customized configurations. You also integrated Google TypeScript Style into your TypeScript project. Using GTS will help you to quickly get up and running with a new TypeScript project. With GTS, you won’t need to manually set up configuration or integrate a linter into your workflow.\n\nAs an additional step, you might be interested in learning how to work with TypeScript in Visual Studio Code. You can also check out this article to learn how to use TypeScript with React."
    },
    {
        "link": "https://react.dev/learn/typescript",
        "document": "The type describing your component’s props can be as simple or as complex as you need, though they should be an object type described with either a or . You can learn about how TypeScript describes objects in Object Types but you may also be interested in using Union Types to describe a prop that can be one of a few different types and the Creating Types from Types guide for more advanced use cases. The type definitions from include types for the built-in Hooks, so you can use them in your components without any additional setup. They are built to take into account the code you write in your component, so you will get inferred types a lot of the time and ideally do not need to handle the minutiae of providing the types. However, we can look at a few examples of how to provide types for Hooks. The Hook will re-use the value passed in as the initial state to determine what the type of the value should be. For example: This will assign the type of to , and will be a function accepting either a argument, or a function that returns a . If you want to explicitly provide a type for the state, you can do so by providing a type argument to the call: This isn’t very useful in this case, but a common case where you may want to provide a type is when you have a union type. For example, here can be one of a few different strings: Or, as recommended in Principles for structuring state, you can group related state as an object and describe the different possibilities via object types: The Hook is a more complex Hook that takes a reducer function and an initial state. The types for the reducer function are inferred from the initial state. You can optionally provide a type argument to the call to provide a type for the state, but it is often better to set the type on the initial state instead:\n\nWe are using TypeScript in a few key places:\n• describes the shape of the reducer’s state.\n• describes the different actions which can be dispatched to the reducer.\n• provides a type for the initial state, and also the type which is used by by default.\n• sets the types for the reducer function’s arguments and return value. A more explicit alternative to setting the type on is to provide a type argument to : The Hook is a technique for passing data down the component tree without having to pass props through components. It is used by creating a provider component and often by creating a Hook to consume the value in a child component. The type of the value provided by the context is inferred from the value passed to the call:\n\nThis technique works when you have a default value which makes sense - but there are occasionally cases when you do not, and in those cases can feel reasonable as a default value. However, to allow the type-system to understand your code, you need to explicitly set on the . This causes the issue that you need to eliminate the in the type for context consumers. Our recommendation is to have the Hook do a runtime check for it’s existence and throw an error when not present: ! \"useGetComplexObject must be used within a Provider\" \n\n The Hooks will create/re-access a memorized value from a function call, re-running the function only when dependencies passed as the 2nd parameter are changed. The result of calling the Hook is inferred from the return value from the function in the first parameter. You can be more explicit by providing a type argument to the Hook. The provide a stable reference to a function as long as the dependencies passed into the second parameter are the same. Like , the function’s type is inferred from the return value of the function in the first parameter, and you can be more explicit by providing a type argument to the Hook. When working in TypeScript strict mode requires adding types for the parameters in your callback. This is because the type of the callback is inferred from the return value of the function, and without parameters the type cannot be fully understood. Depending on your code-style preferences, you could use the functions from the React types to provide the type for the event handler at the same time as defining the callback: There is quite an expansive set of types which come from the package, it is worth a read when you feel comfortable with how React and TypeScript interact. You can find them in React’s folder in DefinitelyTyped. We will cover a few of the more common types here. When working with DOM events in React, the type of the event can often be inferred from the event handler. However, when you want to extract a function to be passed to an event handler, you will need to explicitly set the type of the event.\n\nThere are many types of events provided in the React types - the full list can be found here which is based on the most popular events from the DOM. When determining the type you are looking for you can first look at the hover information for the event handler you are using, which will show the type of the event. If you need to use an event that is not included in this list, you can use the type, which is the base type for all events. There are two common paths to describing the children of a component. The first is to use the type, which is a union of all the possible types that can be passed as children in JSX: This is a very broad definition of children. The second is to use the type, which is only JSX elements and not JavaScript primitives like strings or numbers: Note, that you cannot use TypeScript to describe that the children are a certain type of JSX elements, so you cannot use the type-system to describe a component which only accepts children. You can see an example of both and with the type-checker in this TypeScript playground. When using inline styles in React, you can use to describe the object passed to the prop. This type is a union of all the possible CSS properties, and is a good way to ensure you are passing valid CSS properties to the prop, and to get auto-complete in your editor. This guide has covered the basics of using TypeScript with React, but there is a lot more to learn. Individual API pages on the docs may contain more in-depth documentation on how to use them with TypeScript. We recommend the following resources:\n• The TypeScript handbook is the official documentation for TypeScript, and covers most key language features.\n• The TypeScript release notes cover new features in depth.\n• React TypeScript Cheatsheet is a community-maintained cheatsheet for using TypeScript with React, covering a lot of useful edge cases and providing more breadth than this document.\n• TypeScript Community Discord is a great place to ask questions and get help with TypeScript and React issues."
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/react.html",
        "document": ""
    },
    {
        "link": "https://thiraphat-ps-dev.medium.com/best-practices-for-structuring-a-react-typescript-project-f5ee7f9a264e",
        "document": "Structuring a React TypeScript project effectively is crucial for maintaining code quality, scalability, and ease of collaboration. Here’s a guide to best practices for organizing your React TypeScript project:\n\nStart by setting up your project with the necessary tools and configurations.\n\nOrganize components in a way that promotes reusability and clarity.\n\nPlace all your route-specific components or page components in the directory.\n\nEncapsulate reusable logic in custom hooks and place them in the directory.\n\nAbstract API calls and other external services into the directory.\n\nDefine and export TypeScript types in the directory.\n\nPlace utility functions and helpers in the directory.\n\nUse CSS Modules for component-specific styles and organize global styles in a separate directory.\n\nA well-structured React TypeScript project promotes maintainability, scalability, and ease of collaboration. By organizing your project into clear directories for components, hooks, services, types, utilities, and styling, and by following consistent configuration and coding practices, you can ensure a robust and efficient development workflow."
    },
    {
        "link": "https://medium.com/@tusharupadhyay691/effective-react-typescript-project-structure-best-practices-for-scalability-and-maintainability-bcbcf0e09bd5",
        "document": "Structuring a React TypeScript project effectively is key to maintaining code quality, scalability, and ease of collaboration. A well-organized project ensures that your codebase remains manageable, even as it grows. Here’s a guide on how to structure your React TypeScript project with best practices in mind.\n\nStart by setting up your project with the right tools and configurations.\n\nBreak down your UI into reusable, modular components.\n\nEncapsulate reusable logic with custom hooks in the directory.\n\nAbstract API calls into a directory to keep your logic clean and maintainable.\n\nDefine your TypeScript types in the directory to ensure a consistent and scalable codebase.\n\nFor component-specific styles, use CSS Modules to scope your CSS to individual components. For global styles, organize them in a separate directory.\n\nEnsure consistency and quality with TypeScript, ESLint, and Prettier configurations.\n\nBy structuring your React TypeScript project with clear directories for components, hooks, services, types, utilities, and styling, and by following consistent configuration practices, you set the foundation for a scalable, maintainable, and collaborative codebase.\n• Please consider clapping and following the writer! 👏"
    },
    {
        "link": "https://sitepoint.com/react-with-typescript-best-practices",
        "document": "React and TypeScript are two awesome technologies used by a lot of developers these days. Knowing how to do things can get tricky, and sometimes it’s hard to find the right answer. Not to worry. We’ve put together the best practices along with examples to clarify any doubts you may have.\n• Leverage TypeScript for Enhanced Safety: Utilize TypeScript with React to benefit from static typing which enhances code safety, predictability, and developer productivity by catching errors at compile time.\n• Configure TypeScript Efficiently: Start with a robust `tsconfig.json` setup, enabling options like `strict`, `noEmit`, and `esModuleInterop` to enforce best practices and simplify handling modules and compilation.\n• Integrate ESLint and Prettier: Set up ESLint with the TypeScript parser and Prettier for consistent code formatting. This helps maintain code quality and consistency, especially in team environments.\n• Utilize TypeScript with Hooks: Take advantage of TypeScript’s capabilities to infer types in React Hooks for cleaner and safer code. Use generics and union types to handle complex state logic.\n• Type Props and State Accurately: Define component props and state using TypeScript interfaces or types to ensure components receive the correct data, enhancing the component’s reliability and maintainability.\n• Adopt Best Practices for Project Setup: Use the Create React App with TypeScript template for initial setup to quickly start projects with sensible defaults and build configurations optimized for TypeScript.\n\nHow React and TypeScript Work Together\n\nBefore we begin, let’s revisit how React and TypeScript work together. React is a “JavaScript library for building user interfaces”, while TypeScript is a “typed superset of JavaScript that compiles to plain JavaScript.” By using them together, we essentially build our UIs using a typed version of JavaScript.\n\nThe reason you might use them together would be to get the benefits of a statically typed language (TypeScript) for your UI. This means more safety and fewer bugs shipping to the front end.\n\nA common question that’s always good to review is whether TypeScript compiles your React code. The way TypeScript works is similar to this interaction:\n\nTS: “Hey, is this all your UI code?”\n\n React: “Yup!”\n\n TS: “Cool! I’m going to compile it and make sure you didn’t miss anything.”\n\n React: “Sounds good to me!”\n\nSo the answer is yes, it does! But later, when we cover the settings, most of the time you’ll want to use . What this means is TypeScript will not emit JavaScript out after compilation. This is because typically, we’re just utilizing TypeScript to do our type-checking.\n\nThe output is handled, in a CRA setting, by . We run and bundles the output for production.\n\nTo recap, TypeScript compiles your React code to type-check your code. It doesn’t emit any JavaScript output (in most scenarios). The output is still similar to a non-TypeScript React project.\n\nCan TypeScript Work with React and webpack?\n\nYes, TypeScript can work with React and webpack. Lucky for you, the webpack documentation has a guide on that.\n\nHopefully, that gives you a gentle refresher on how the two work together. Now, on to best practices!\n\nWe’ve researched the most common questions and put together this handy list of the most common use cases for React with TypeScript. This way, you can use this article as a reference in your own projects.\n\nOne of the least fun, yet most important parts of development is configuration. How can we set things up in the shortest amount of time that will provide maximum efficiency and productivity? We’ll discuss project setup including:\n\nThe quickest way to start a React/TypeScript app is by using with the TypeScript template. You can do this by running:\n\nThis will get you the bare minimum to start writing React with TypeScript. A few noticeable differences are:\n\nThe is for “TypeScript JSX“. The is the TypeScript configuration file, which has some defaults set. The references the types of , and helps with things like allowing for SVG imports.\n\nLucky for us, the latest React/TypeScript template generates for us. However, they add the bare minimum to get started. We suggest you modify yours to match the one below. We’ve added comments to explain the purpose of each option as well:\n\nThe additional recommendations come from the react-typescript-cheatsheet community and the explanations come from the Compiler Options docs in the Official TypeScript Handbook. This is a wonderful resource if you want to learn about other options and what they do.\n\nIn order to ensure that your code follows the rules of the project or your team, and the style is consistent, it’s recommended you set up ESLint and Prettier. To get them to play nicely, follow these steps to set it up.\n• Create a file at the root and add the following:\n• Create a file at the root and add the following:\n\nThese recommendations come from a community resource written called “Using ESLint and Prettier in a TypeScript Project”, by Robert Cooper. If you visit this resource, you can read more about the “why” behind these rules and configurations.\n\nWe’ve added ESLint and Prettier and the next step to improve our DX is to automatically fix/prettify our code on save.\n\nFirst, install the ESLint extension and the Prettier extension for VS Code. This will allow ESLint to integrate with your editor seamlessly.\n\nNext, update your Workspace settings by adding the following to your :\n\nThis will allow VS Code to work its magic and fix your code when you save. It’s beautiful!\n\nThese suggestions also come from the previously linked article “Using ESLint and Prettier in a TypeScript Project”, by Robert Cooper.\n\nNote: to read more about , look here, and read here for .\n\nOne of the core concepts of React is components. Here, we’ll be referring to standard components as of React v16.8, meaning ones that use hooks as opposed to classes.\n\nIn general, there’s much to be concerned with for basic components. Let’s look at an example:\n\nNotice the key difference here. In the first example, we’re writing our function as a function declaration. We annotate the return type with because that’s what it returns. In contrast, the second example uses a function expression. Because the second instance returns a function, instead of a value or expression, we annotate the function type with for React “Function Component”.\n\nIt can be confusing to remember the two. It’s mostly a matter of design choice. Whichever you choose to use in your project, use it consistently.\n\nThe next core concept we’ll cover is props. You can define your props using either an interface or a type. Let’s look at another example:\n\nWhen it comes to types or interfaces, we suggest following the guidelines presented by the community:\n• “always use interface for public API’s definition when authoring a library or 3rd-party ambient type definitions.”\n• “consider using type for your React Component Props and State, because it is more constrained.”\n\nYou can read more about the discussion and see a handy table comparing types vs interfaces here.\n\nLet’s look at one more example so we can see something a little bit more practical:\n\nIn this component, we use a type for our props. Each prop has a short description listed above it to provide more context to other developers. The after the prop named indicates that it’s optional. The prop takes a because it accepts everything that’s a valid return value of a component (read more here). To account for our optional prop, we use a default value when destructuring it. This example should cover the basics and show you have to write types for your props and use both optional and default values.\n\nIn general, keep these things in mind when writing your props in a React and TypeScript project:\n• Always add descriptive comments to your props using the TSDoc notation .\n• Whether you use types or interfaces for your component props, use them consistently.\n• When props are optional, handle appropriately or use default values.\n\nLuckily, the TypeScript type inference works well when using hooks. This means you don’t have much to worry about. For instance, take this example:\n\nTypeScript infers the values given to use by the hook. This is an area where React and TypeScript just work together and it’s beautiful.\n\nOn the rare occasions where you need to initialize a hook with a null-ish value, you can make use of a generic and pass a union to correctly type your hook. See this instance:\n\nThe other place where TypeScript shines with Hooks is with , where you can take advantage of discriminated unions. Here’s a useful example:\n\nThe beauty here lies in the usefulness of discriminated unions. Notice how has a union of two similar-looking objects. The property is a string literal. The difference between this and a type is that the value must match the literal string defined in the type. This means your program is extra safe because a developer can only call an action that has a key set to or .\n\nAs you can see, Hooks don’t add much complexity to the nature of a React and TypeScript project. If anything, they lend themselves well to the duo.\n\nThis section is to cover the most common use cases where people stumble when using TypeScript with React. We hope by sharing this, you’ll avoid the pitfalls and even share this knowledge with others.\n\nOne of the most common cases is correctly typing the used on an input field in a form. Here’s an example:\n\nSometimes you want to take component props declared for one component and extend them to use them on another component. But you might want to modify one or two. Well, remember how we looked at the two ways to type component props, types or interfaces? Depending on which you used determines how you extend the component props. Let’s first look at the way using :\n\nIf you declared your props using an , then we can use the keyword to essentially “extend” that interface but make a modification or two:\n\nBoth methods solve the problem. It’s up to you to decide which to use. Personally, extending an interface feels more readable, but ultimately, it’s up to you and your team.\n\nYou can read more about both concepts in the TypeScript Handbook:\n\nWhether it’s for a GraphQL client like Apollo or for testing with something like React Testing Library, we often find ourselves using third-party libraries in React and TypeScript projects. When this happens, the first thing you want to do is see if there’s a package with the TypeScript type definitions. You can do so by running:\n\nFor instance, if you’re using Jest, you can do this by running:\n\nThis would then give you added type-safety whenever you’re using Jest in your project.\n\nThe namespace is reserved for package type definitions. They live in a repository called DefinitelyTyped, which is partially maintained by the TypeScript team and partially the community.\n\nShould these be saved as or in my ?\n\nThe short answer is “it depends”. Most of the time, they can go under if you’re building a web application. However, if you’re writing a React library in TypeScript, you may want to include them as .\n\nThere are a few answers to this on Stack Overflow, which you may check out for further information.\n\nWhat happens if they don’t have a @types package?\n\nIf you don’t find a package on npm, then you essentially have two options:\n\nThe first option means you create a file based on the package name and put it at the root. If, for instance, we needed types for our package , then we could create a basic declaration file called at the root:\n\nThis won’t provide you type safety but it will unblock you.\n\nA more thorough declaration file would be where you add types for the library/package:\n\nIf you’ve never written a declaration file, then we suggest you take a look at the guide in the official TypeScript Handbook.\n\nUsing React and TypeScript together in the best way takes a bit of learning due to the amount of information, but the benefits pay off immensely in the long run. In this article, we covered configuration, components, props, hooks, common use cases, and third-party libraries. Although we could dive deeper into a lot of individual areas, this should cover the 80% needed to help you follow best practices.\n\nIf you’d like to see this in action, you can see this example on GitHub.\n\nIf you’d like to get in touch, share feedback on this article or chat about using the two technologies together, you can reach me on Twitter @jsjoeio.\n\nIf you’d like to dive deeper, here are some resources we suggest:\n\nA lot of these recommendations came straight from the react-typescript-cheatsheet. If you’re looking for specific examples or details on anything React-TypeScript, this is the place to go. We welcome contributions as well!\n\nAnother fantastic resource is the TypeScript Handbook. This is kept up to date by the TypeScript team and provides examples and an in-depth explanation behind the inner workings of the language.\n\nDid you know you can test out React with TypeScript code right in the browser? All you have to do is import React. Here’s a link to get you started.\n\nRead our guide on practical ways to advance your TypeScript skills to set yourself up for continuous learning as you move forward.\n\nCan you use React with TypeScript? es, you can absolutely use React with TypeScript. In fact, combining React with TypeScript has become increasingly popular in the web development community. TypeScript is a statically typed superset of JavaScript that provides enhanced tooling and type safety, making it an excellent choice for building robust and maintainable React applications.\n\nWhen using React with TypeScript, you typically create React components as TypeScript classes or functional components with TypeScript function signatures. TypeScript allows you to define strong types for props and state, reducing the risk of runtime errors and making your codebase more predictable. Additionally, TypeScript’s autocompletion and type checking in modern code editors provide valuable assistance during development.\n\nTo start a React project with TypeScript, you can use tools like Create React App with TypeScript template or manually configure TypeScript in an existing React project. With TypeScript, you can enjoy the benefits of static typing while building dynamic and interactive user interfaces with React, resulting in more reliable and maintainable web applications. Is TypeScript necessary for React? No, TypeScript is not necessary for building React applications, but it can be highly beneficial. React was originally developed using JavaScript (ECMAScript), and many React applications are still written in plain JavaScript. React works seamlessly with JavaScript, and you can create fully functional and efficient React applications without TypeScript.\n\nHowever, TypeScript can provide significant advantages when working with React. TypeScript is a statically typed superset of JavaScript, which means it adds type annotations and checking to JavaScript code. These type annotations can catch type-related errors at compile-time, offering improved code quality and maintainability. TypeScript can make large and complex React codebases more manageable by providing type safety for props, state, and function parameters, reducing the likelihood of runtime errors.\n\nIn summary, TypeScript is not a requirement for React, and you can use React effectively with plain JavaScript. However, TypeScript can enhance your development experience by adding type checking and improving code predictability, making it a valuable choice for building robust and maintainable React applications, especially in larger and more complex projects. How to use TypeScript in React apps? Start by setting up a new React project with TypeScript. You can use tools like Create React App with TypeScript template or manually configure TypeScript in an existing React project. \n\nNext, write your React components using TypeScript. You can create functional components with TypeScript function signatures or use TypeScript classes for class components. TypeScript allows you to specify prop types and state types, providing strong type checking and autocompletion support in code editors. If you’re using third-party libraries or packages in your React app, make sure to install TypeScript type definitions for those dependencies. Many popular libraries have community-maintained TypeScript type declarations available on DefinitelyTyped What Is the difference between React.js and React TypeScript? The primary distinction between React.js and React TypeScript is the choice of programming language used for development.\n\nReact.js (JavaScript): React.js, commonly referred to as React, is a JavaScript library designed for building user interfaces. When using React.js, developers typically write their applications in plain JavaScript, often leveraging modern JavaScript features such as ES6 and ES7. One notable characteristic of React.js is that it doesn’t enforce strict typing by default. As a result, developers rely on runtime checks and tools like PropTypes for type validation and error detection.\n\nReact TypeScript: React TypeScript, on the other hand, involves the use of TypeScript, a statically typed superset of JavaScript, in React application development. With React TypeScript, developers write their React components using TypeScript’s syntax. This approach offers a significant advantage: static type checking during development. TypeScript empowers developers to define types and interfaces for props, state, and other data, which can catch type-related errors at compile-time rather than runtime. This leads to improved code quality, enhanced code predictability, and a reduction in runtime errors.\n\nIn summary, React.js is the JavaScript library for building user interfaces, while React TypeScript is the same library but integrated with TypeScript to provide enhanced type safety and development support. The choice between React.js and React TypeScript depends on project requirements, developer preferences, and the importance of static typing for a particular application. Both options are valid and widely used in the development of web applications and user interfaces. Starting a React project with TypeScript or JavaScript depends on various considerations.\n\nBeginning with TypeScript: Starting with TypeScript can be advantageous when you prioritize strong type safety and improved development tooling. TypeScript’s static type checking helps catch errors at compile-time, leading to more robust and maintainable code. If you’re working on a sizable or complex project, TypeScript can be particularly beneficial in preventing bugs and making the codebase easier to manage. TypeScript also provides enhanced code documentation through type definitions, which can improve code readability and collaboration within your team.\n\nOpting for JavaScript: Choosing JavaScript may be more suitable for smaller projects or when you’re working under tight deadlines. JavaScript is more lightweight and has a shorter learning curve, making it quicker to set up and get started. If your team lacks experience with TypeScript or if the project requirements don’t necessitate strong typing, JavaScript might be a pragmatic choice. Additionally, the JavaScript ecosystem boasts an extensive collection of libraries and resources, making it easier to find solutions and support for your project."
    }
]