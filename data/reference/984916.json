[
    {
        "link": "https://swagger.io/docs/specification/v3_0/describing-parameters",
        "document": "In OpenAPI 3.0, parameters are defined in the section of an operation or path. To describe a parameter, you specify its , location ( ), data type (defined by either or ) and other attributes, such as or . Here is an example:\n\nNote that is an array, so, in YAML, each parameter definition must be listed with a dash ( ) in front of it.\n\nOpenAPI 3.0 distinguishes between the following parameter types based on the parameter location. The location is determined by the parameter’s key, for example, or .\n• cookie parameters, which are passed in the header, such as\n\nPath parameters are variable parts of a URL path. They are typically used to point to a specific resource within a collection, such as a user identified by ID. A URL can have several path parameters, each denoted with curly braces .\n\nEach path parameter must be substituted with an actual value when the client makes an API call. In OpenAPI, a path parameter is defined using . The parameter name must be the same as specified in the path. Also remember to add , because path parameters are always required. For example, the endpoint would be described as:\n\nPath parameters containing arrays and objects can be serialized in different ways:\n\nThe serialization method is specified by the and keywords. To learn more, see Parameter Serialization.\n\nQuery parameters are the most common type of parameters. They appear at the end of the request URL after a question mark ( ), with different pairs separated by ampersands ( ). Query parameters can be required and optional.\n\nNote: To describe API keys passed as query parameters, use and instead. See API Keys.\n\nQuery parameters can be primitive values, arrays and objects. OpenAPI 3.0 provides several ways to serialize objects and arrays in the query string.\n\nArrays can be serialized as:\n• – or , depending on the keyword\n• (same as in OpenAPI 2.0) –\n• (same as in OpenAPI 2.0) –\n\nObjects can be serialized as:\n• – or , depending on the keyword\n\nThe serialization method is specified by the and keywords. To learn more, see Parameter Serialization.\n\nRFC 3986 defines a set of reserved characters that are used as URI component delimiters. When these characters need to be used literally in a query parameter value, they are usually percent-encoded. For example, is encoded as (or ), so that the parameter value would be sent as\n\nIf you want a query parameter that is not percent-encoded, add to the parameter definition:\n\nIn this case, the parameter value would be sent like so:\n\nAn API call may require that custom headers be sent with an HTTP request. OpenAPI lets you define custom request headers as parameters. For example, suppose, a call to requires the header:\n\nUsing OpenAPI 3.0, you would define this operation as follows:\n\nIn a similar way, you can define custom response headers. Header parameter can be primitives, arrays and objects. Arrays and objects are serialized using the style. For more information, see Parameter Serialization.\n\nNote: Header parameters named , and are not allowed. To describe these headers, use the corresponding OpenAPI keywords:\n\nOperations can also pass parameters in the header, as . Multiple cookie parameters are sent in the same header, separated by a semicolon and space.\n\nCookie parameters can be primitive values, arrays and objects. Arrays and objects are serialized using the style. For more information, see Parameter Serialization.\n\nNote: To define cookie authentication, use API keys instead.\n\nBy default, OpenAPI treats all request parameters as optional. You can add to mark a parameter as required. Note that path parameters must have , because they are always required.\n\nTo describe the parameter contents, you can use either the or keyword. They are mutually exclusive and used in different scenarios. In most cases, you would use . It lets you describe primitive values, as well as simple arrays and objects serialized into a string. The serialization method for array and object parameters is defined by the and keywords used in that parameter.\n\nis used in complex serialization scenarios that are not covered by and . For example, if you need to send a JSON string in the query string like so:\n\nIn this case, you need to wrap the parameter into as shown below. The defines the parameter data structure, and the media type (in this example – ) serves as a reference to an external specification that describes the serialization format.\n\nNote for Swagger UI and Swagger Editor users: Parameters with are supported in Swagger UI 3.23.7+ and Swagger Editor 3.6.34+.\n\nUse the keyword in the parameter schema to specify the default value for an optional parameter. The default value is the one that the server uses if the client does not supply the parameter value in the request. The value type must be the same as the parameter’s data type. A typical example is paging parameters such as and :\n\nAssuming defaults to 0 and defaults to 20 and ranges from 0 to 100, you would define these parameters as:\n\nThere are two common mistakes when using the keyword:\n• Using with parameters or properties, for example, with path parameters. This does not make sense – if a value is required, the client must always send it, and the default value is never used.\n• Using to specify a sample value. This is not intended use of and can lead to unexpected behavior in some Swagger tools. Use the or keyword for this purpose instead. See Adding Examples.\n\nYou can restrict a parameter to a fixed set of values by adding the to the parameter’s . The enum values must be of the same type as the parameter data type.\n\nYou can define a constant parameter as a required parameter with only one possible value:\n\nThe property specifies possible values. In this example, only one value can be used, and this will be the only value available in the Swagger UI for the user to choose from.\n\nNote: A constant parameter is not the same as the default parameter value. A constant parameter is always sent by the client, whereas the default value is something that the server uses if the parameter is not sent by the client.\n\nQuery string parameters may only have a name and no value, like so:\n\nUse to describe such parameters:\n\nOpenAPI 3.0 also supports in schemas, allowing operation parameters to have the value. For example, the following schema corresponds to in C# and in Java:\n\nNote: is not the same as an optional parameter or an empty-valued parameter. means the parameter value can be . Specific implementations may choose to map an absent or empty-valued parameter to , but strictly speaking these are not the same thing.\n\nYou can specify an or multiple for a parameter. The example value should match the parameter schema. Single example:\n\nUse to mark a parameter as deprecated.\n\nCommon Parameters for All Methods of a Path\n\nParameters shared by all operations of a path can be defined on the path level instead of the operation level. Path-level parameters are inherited by all operations of that path. A typical use case are the GET/PUT/PATCH/DELETE operations that manipulate a resource accessed via a path parameter.\n\nAny extra parameters defined at the operation level are used together with path-level parameters:\n\nSpecific path-level parameters can be overridden on the operation level, but cannot be removed.\n\nDifferent API paths may have common parameters, such as pagination parameters. You can define common parameters under parameters in the global section and reference them elsewhere via .\n\nNote that the parameters defined in are not parameters applied to all operations — they are simply global definitions that can be easily re-used.\n\nOpenAPI 3.0 does not support parameter dependencies and mutually exclusive parameters. There is an open feature request at https://github.com/OAI/OpenAPI-Specification/issues/256. What you can do is document the restrictions in the parameter description and define the logic in the 400 Bad Request response. For example, consider the endpoint that accepts either a relative date range ( ) or an exact range ( + ):\n\nYou can describe this endpoint as follows:\n\nDid not find what you were looking for? Ask the community\n\n Found a mistake? Let us know"
    },
    {
        "link": "https://stackoverflow.com/questions/63862351/openapi-how-to-describe-query-parameters",
        "document": "I'm trying to figure out how to document two of my query parameters in OpenAPI.\n\nMy filtering follows the recommendations of JSON:API, which takes the form of, for example:\n\nThe key is an associative array that can contain a set list of resource names in my API. The value assigned to each filter key is either a single id or list of comma separated ids.\n\nFor sorting also follows the JSON:API recommendation, so something like these:\n\nThe query parameter is assigned the value of one sort field or list of comma separated sort fields. Note that the minus sign that prefixes the field indicates a descending sort.\n\nHow do I represent the my filtering and sorting in OpenAPI?\n\nFor example, I'm not sure it's possible for me to specify that the filter key is an associative array, or that it accepts a comma separated list of ids. Almost the same issue for sort: how to represent a comma separated list of sort fields?"
    },
    {
        "link": "https://speakeasy.com/post/openapi-tips-query-parameters-serialization",
        "document": "The OpenAPI spec is best known for descriptions of RESTful APIs, but it’is designed to be capable of describing any HTTP API whether that be REST or something more akin to RPC based calls.\n\nThat leads to the spec having a lot of flexibility baked-in: there’s a lot of ways to achieve the exact same result that are equally valid in the eyes of the spec. Because of this, the OpenAPI documentation (opens in a new tab) is very ambiguous when it comes to how you should define your API.\n\nThat’s why we’re taking the time to eliminate some of the most common ambiguities that you’ll encounter when you build your OpenAPI schema. In this case we’ll be taking a look at how to serialize query parameters in your OpenAPI 3.0.X schema.\n\nThe OpenAPI spec grants quite a bit of flexibility in defining query parameters for any operation. There are many serialization options and defaults, therefore it’s advisable you define query parameters as strictly as possible in your schema. This will improve your API documentation thereby reducing ambiguity for end-users. In addition, explicit definitions will aid any OpenAPI tooling you may be using to produce artifacts, such as client SDKs.\n\nAs an API developer, strict definitions will also give you a more intuitive understanding of each operatio’s intended behavior as you iterate on your OpenAPI schema. Concretely, we recommend that you:\n• Describe your query parameters as explicitly as possible by using OpenAPI defined formats.\n• Use additional validation attributes as much as possible: mark properties as required, allowReserved, allowEmptyValue, and indicate when fields are nullable.\n\nIt’s also important to note that OpenAPI considers a unique operation as a combination of a path and HTTP method, so it is not possible to have multiple operations that only differ by query parameters. In this case, it’s advisable to use unique paths as shown below:\n\nQuery parameters are criteria which appear at the end of a request URL demarcated by a question mark (?), with different key=value pairs usually separated by ampersands (&). They may be required or optional, and can be specified in an OpenAPI schema by specifying in: query. Consider the following operation for an event catalog:\n\nQuery parameters could be defined in the schema as follows:\n\nWhen you’re working with query parameters, it’s important to understand serialization. Let’s explore what serialization is, and the variety of ways the OpenAPI specification supports serialization of query parameters.\n\nSerialization is responsible for transforming data into a format that can be used in transit and reconstructed later. For query parameters specifically, this format is the query string for requests of that operation. The serialization method allows us to define this through the use of the following keywords:\n• style – defines how multiple values are delimited. Possible styles depend on the parameter location – path , query , header or cookie .\n• explode – (true/false) specifies whether arrays and objects should generate separate parameters for each array item or object property.\n\nOpenAPI supports serialization of arrays and objects in all operation parameters (path, query, header, cookie). The serialization rules are based on a subset of URI template patterns defined by RFC 6570 (opens in a new tab).\n\nFrom the OpenAPI Swagger documentation, query parameters support the following style values:\n• form (default): ampersand-separated values, also known as form-style query expansion. Corresponds to the URI template.\n• spaceDelimited: space-separated array values. Has effect only for non-exploded arrays ( ), that is, the space separates the array values if the array is a single parameter, as in arr=a b c.\n• pipeDelimited: pipeline-separated array values. Has effect only for non-exploded arrays ( ), that is, the pipe separates the array values if the array is a single parameter, as in arr=a|b|c.\n• deepObject: simple non-nested objects are serialized as The behavior for nested objects and arrays is undefined.\n\nThe default serialization method is style: form and explode: true. As shown in the GET /events call above, the query string is created with this default serialization when the schema has no references to style or explode. However, we recommend explicitly setting these values, even in the default case, to reap the benefits discussed in “Recommended Practices” above.\n\nStyle and explode cover the most common serialization methods, but not all. For more complex scenarios (ex. a JSON-formatted object in the query string), you can use the content keyword and specify the media type that defines the serialization format. The example schema below does exactly that:\n\nQuery parameters can be specified with quite a few additional attributes to further determine their serialization, optionality, and nullability.\n\nThis is the only additional attribute which is specific to query parameters. From the OpenAPI Swagger documentation: The allowReserved keyword specifies whether the reserved characters, defined as :/?#[]@!$&’()*+,;= by RFC 3986 (opens in a new tab), are allowed to be sent as they are as query parameter values or should be percent-encoded. By default, allowReserved is false, and reserved characters are percent-encoded. For example, / is encoded as %2F (or %2f), so that the parameter value, events/event_info.txt, will be sent as events%2Fevent_info.txt. To preserve the / as is, allowReserved would have to be set to true as shown below:\n\nBy default, OpenAPI treats all request parameters as optional. You can add required: true to mark a parameter as required.\n\nUse the default keyword in the parameter schema to specify the default value for an optional parameter. The default value is the one that the server uses if the client does not supply the parameter value in the request. The value type must be the same as the parameter’s data type.\n\nConsider a simple example, where default used with paging parameters allows these 2 calls from the client to be equivalent:\n\nThis would be specified in the schema like so:\n\nThe default keyword should not be used with required values. If a parameter is required, the client must always send it and therefore override the default.\n\nYou can restrict a parameter to a fixed set of values by adding the enum to the parameter’s schema. The enum values must be the same type as the parameter data type.\n\nA constant parameter can then be defined as a required parameter with only one possible value as shown below:\n\nThe enum property specifies possible values, and in this example, only one value can be used.\n\nIt’s important to note a constant parameter is not the same as the default parameter value. A constant parameter is always sent by the client, whereas the default value is something that the server uses if the parameter is not sent by the client.\n\nQuery string parameters may only have a name and no value, like so:\n\nUse allowEmptyValue to describe such parameters:\n\nThe OpenAPI spec also supports nullable in schemas, allowing operation parameters to have the null value when nullable: true. This simply means the parameter value can be null, and is not the same as an empty-valued or optional parameter.\n\nUse deprecated: true to mark a parameter as deprecated.\n\nCommon Parameters Across Methods in Same Path\n\nParameters may be defined once to be used in multiple methods/paths in an OpenAPI schema. Parameters shared by all operations of a path can be defined on the path level instead of the operation level. These path-level parameters are inherited by all operations (GET/PUT/PATCH/DELETE) of that path. An example is shown below(manipulating the same resource in different ways is a good use case here):\n\nAny extra parameters defined at the operation level are used in addition to path-level parameters. Specific path-level parameters may also be overridden on the operation level, but cannot be removed.\n\nParameters can also be shared across multiple paths. Pagination is a good candidate for this:\n\nNote the above parameters defined in components are simply global definitions that can be handily referenced. They are not necessarily applied to all methods of an operation."
    },
    {
        "link": "https://github.com/OAI/OpenAPI-Specification/issues/1500",
        "document": "I have an API , which can accept multiple parameters like,\n\nI get same response for all the above url's.\n\nHow Can I document this in Swagger using OenAPI 3.0.0 ?"
    },
    {
        "link": "https://stackoverflow.com/questions/40495880/how-to-define-different-query-parameters-for-same-path-in-openapi-swagger",
        "document": "I am starting a REST service, using Swagger Codegen. I need to have different responses for different parameters.\n\nExample: can use or , and these parameters should produce different response messages.\n\nI want my OpenAPI YAML file to document these two query params separately. Is this possible?"
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/db/queries",
        "document": "Once you’ve created your data models, Django automatically gives you a database-abstraction API that lets you create, retrieve, update and delete objects. This document explains how to use this API. Refer to the data model reference for full details of all the various model lookup options.\n\nThroughout this guide (and in the reference), we’ll refer to the following models, which comprise a blog application:\n\nTo retrieve objects from your database, construct a via a on your model class. A represents a collection of objects from your database. It can have zero, one or many filters. Filters narrow down the query results based on the given parameters. In SQL terms, a equates to a statement, and a filter is a limiting clause such as or . You get a by using your model’s . Each model has at least one , and it’s called by default. Access it directly via the model class, like so: are accessible only via model classes, rather than from model instances, to enforce a separation between “table-level” operations and “record-level” operations. The is the main source of for a model. For example, returns a that contains all objects in the database. The simplest way to retrieve objects from a table is to get all of them. To do this, use the method on a : The method returns a of all the objects in the database. The returned by describes all objects in the database table. Usually, though, you’ll need to select only a subset of the complete set of objects. To create such a subset, you refine the initial , adding filter conditions. The two most common ways to refine a are: Returns a new containing objects that match the given lookup parameters. Returns a new containing objects that do not match the given lookup parameters. The lookup parameters ( in the above function definitions) should be in the format described in Field lookups below. For example, to get a of blog entries from the year 2006, use like so: With the default manager class, it is the same as: The result of refining a is itself a , so it’s possible to chain refinements together. For example: This takes the initial of all entries in the database, adds a filter, then an exclusion, then another filter. The final result is a containing all entries with a headline that starts with “What”, that were published between January 30, 2005, and the current day. Each time you refine a , you get a brand-new that is in no way bound to the previous . Each refinement creates a separate and distinct that can be stored, used and reused. These three are separate. The first is a base containing all entries that contain a headline starting with “What”. The second is a subset of the first, with an additional criteria that excludes records whose is today or in the future. The third is a subset of the first, with an additional criteria that selects only the records whose is today or in the future. The initial ( ) is unaffected by the refinement process. are lazy – the act of creating a doesn’t involve any database activity. You can stack filters together all day long, and Django won’t actually run the query until the is evaluated. Take a look at this example: Though this looks like three database hits, in fact it hits the database only once, at the last line ( ). In general, the results of a aren’t fetched from the database until you “ask” for them. When you do, the is evaluated by accessing the database. For more details on exactly when evaluation takes place, see When QuerySets are evaluated. will always give you a , even if only a single object matches the query - in this case, it will be a containing a single element. If you know there is only one object that matches your query, you can use the method on a which returns the object directly: You can use any query expression with , just like with - again, see Field lookups below. Note that there is a difference between using , and using with a slice of . If there are no results that match the query, will raise a exception. This exception is an attribute of the model class that the query is being performed on - so in the code above, if there is no object with a primary key of 1, Django will raise . Similarly, Django will complain if more than one item matches the query. In this case, it will raise , which again is an attribute of the model class itself. Most of the time you’ll use , , and when you need to look up objects from the database. However, that’s far from all there is; see the QuerySet API Reference for a complete list of all the various methods. Use a subset of Python’s array-slicing syntax to limit your to a certain number of results. This is the equivalent of SQL’s and clauses. For example, this returns the first 5 objects ( ): This returns the sixth through tenth objects ( ): Generally, slicing a returns a new – it doesn’t evaluate the query. An exception is if you use the “step” parameter of Python slice syntax. For example, this would actually execute the query in order to return a list of every second object of the first 10: Further filtering or ordering of a sliced queryset is prohibited due to the ambiguous nature of how that might work. To retrieve a single object rather than a list (e.g. ), use an index instead of a slice. For example, this returns the first in the database, after ordering entries alphabetically by headline: This is roughly equivalent to: Note, however, that the first of these will raise while the second will raise if no objects match the given criteria. See for more details. Field lookups are how you specify the meat of an SQL clause. They’re specified as keyword arguments to the methods , and . Basic lookups keyword arguments take the form . (That’s a double-underscore). For example: translates (roughly) into the following SQL: Python has the ability to define functions that accept arbitrary name-value arguments whose names and values are evaluated at runtime. For more information, see Keyword Arguments in the official Python tutorial. The field specified in a lookup has to be the name of a model field. There’s one exception though, in case of a you can specify the field name suffixed with . In this case, the value parameter is expected to contain the raw value of the foreign model’s primary key. For example: If you pass an invalid keyword argument, a lookup function will raise . The database API supports about two dozen lookup types; a complete reference can be found in the field lookup reference. To give you a taste of what’s available, here’s some of the more common lookups you’ll probably use: An “exact” match. For example: Would generate SQL along these lines: If you don’t provide a lookup type – that is, if your keyword argument doesn’t contain a double underscore – the lookup type is assumed to be . For example, the following two statements are equivalent: This is for convenience, because lookups are the common case. Would match a titled , , or even . Note this will match the headline but not . Starts-with and ends-with search, respectively. There are also case-insensitive versions called and . Again, this only scratches the surface. A complete reference can be found in the field lookup reference. Django offers a powerful and intuitive way to “follow” relationships in lookups, taking care of the SQL s for you automatically, behind the scenes. To span a relationship, use the field name of related fields across models, separated by double underscores, until you get to the field you want. This example retrieves all objects with a whose is : This spanning can be as deep as you’d like. It works backwards, too. While it , by default you refer to a “reverse” relationship in a lookup using the lowercase name of the model. This example retrieves all objects which have at least one whose contains : If you are filtering across multiple relationships and one of the intermediate models doesn’t have a value that meets the filter condition, Django will treat it as if there is an empty (all values are ), but valid, object there. All this means is that no error will be raised. For example, in this filter: (if there was a related model), if there was no associated with an entry, it would be treated as if there was also no attached, rather than raising an error because of the missing . Usually this is exactly what you want to have happen. The only case where it might be confusing is if you are using . Thus: will return objects that have an empty on the and also those which have an empty on the . If you don’t want those latter objects, you could write: When spanning a or a reverse (such as from to ), filtering on multiple attributes raises the question of whether to require each attribute to coincide in the same related object. We might seek blogs that have an entry from 2008 with “Lennon” in its headline, or we might seek blogs that merely have any entry from 2008 as well as some newer or older entry with “Lennon” in its headline. To select all blogs containing at least one entry from 2008 having “Lennon” in its headline (the same entry satisfying both conditions), we would write: Otherwise, to perform a more permissive query selecting any blogs with merely some entry with “Lennon” in its headline and some entry from 2008, we would write: Suppose there is only one blog that has both entries containing “Lennon” and entries from 2008, but that none of the entries from 2008 contained “Lennon”. The first query would not return any blogs, but the second query would return that one blog. (This is because the entries selected by the second filter may or may not be the same as the entries in the first filter. We are filtering the items with each filter statement, not the items.) In short, if each condition needs to match the same related object, then each should be contained in a single call. As the second (more permissive) query chains multiple filters, it performs multiple joins to the primary model, potentially yielding duplicates. The behavior of for queries that span multi-value relationships, as described above, is not implemented equivalently for . Instead, the conditions in a single call will not necessarily refer to the same item. For example, the following query would exclude blogs that contain both entries with “Lennon” in the headline and entries published in 2008: However, unlike the behavior when using , this will not limit blogs based on entries that satisfy both conditions. In order to do that, i.e. to select all blogs that do not contain entries published with “Lennon” that were published in 2008, you need to make two queries: Filters can reference fields on the model¶ In the examples given so far, we have constructed filters that compare the value of a model field with a constant. But what if you want to compare the value of a model field with another field on the same model? Django provides to allow such comparisons. Instances of act as a reference to a model field within a query. These references can then be used in query filters to compare the values of two different fields on the same model instance. For example, to find a list of all blog entries that have had more comments than pingbacks, we construct an object to reference the pingback count, and use that object in the query: Django supports the use of addition, subtraction, multiplication, division, modulo, and power arithmetic with objects, both with constants and with other objects. To find all the blog entries with more than twice as many comments as pingbacks, we modify the query: To find all the entries where the rating of the entry is less than the sum of the pingback count and comment count, we would issue the query: You can also use the double underscore notation to span relationships in an object. An object with a double underscore will introduce any joins needed to access the related object. For example, to retrieve all the entries where the author’s name is the same as the blog name, we could issue the query: For date and date/time fields, you can add or subtract a object. The following would return all entries that were modified more than 3 days after they were published: The objects support bitwise operations by , , , , and . For example: For example, to find all objects published in the same year as they were last modified: To find the earliest year an entry was published, we can issue the query: This example finds the value of the highest rated entry and the total number of comments on all entries for each year: For convenience, Django provides a lookup shortcut, which stands for “primary key”. In the example model, the primary key is the field, so these three statements are equivalent: The use of isn’t limited to queries – any query term can be combined with to perform a query on the primary key of a model: # Get blogs entries with id 1, 4 and 7 # Get all blog entries with id > 14 lookups also work across joins. For example, these three statements are equivalent: The field lookups that equate to SQL statements ( , , , , , and ) will automatically escape the two special characters used in statements – the percent sign and the underscore. (In a statement, the percent sign signifies a multiple-character wildcard and the underscore signifies a single-character wildcard.) This means things should work intuitively, so the abstraction doesn’t leak. For example, to retrieve all the entries that contain a percent sign, use the percent sign as any other character: Django takes care of the quoting for you; the resulting SQL will look something like this: Same goes for underscores. Both percentage signs and underscores are handled for you transparently. Each contains a cache to minimize database access. Understanding how it works will allow you to write the most efficient code. In a newly created , the cache is empty. The first time a is evaluated – and, hence, a database query happens – Django saves the query results in the ’s cache and returns the results that have been explicitly requested (e.g., the next element, if the is being iterated over). Subsequent evaluations of the reuse the cached results. Keep this caching behavior in mind, because it may bite you if you don’t use your s correctly. For example, the following will create two s, evaluate them, and throw them away: That means the same database query will be executed twice, effectively doubling your database load. Also, there’s a possibility the two lists may not include the same database records, because an may have been added or deleted in the split second between the two requests. To avoid this problem, save the and reuse it: # Reuse the cache from the evaluation. When s are not cached¶ Querysets do not always cache their results. When evaluating only part of the queryset, the cache is checked, but if it is not populated then the items returned by the subsequent query are not cached. Specifically, this means that limiting the queryset using an array slice or an index will not populate the cache. For example, repeatedly getting a certain index in a queryset object will query the database each time: However, if the entire queryset has already been evaluated, the cache will be checked instead: Here are some examples of other actions that will result in the entire queryset being evaluated and therefore populate the cache: Simply printing the queryset will not populate the cache. This is because the call to only returns a slice of the entire queryset.\n\nIf you are writing asynchronous views or code, you cannot use the ORM for queries in quite the way we have described above, as you cannot call blocking synchronous code from asynchronous code - it will block up the event loop (or, more likely, Django will notice and raise a to stop that from happening). Fortunately, you can do many queries using Django’s asynchronous query APIs. Every method that might block - such as or - has an asynchronous variant ( or ), and when you iterate over results, you can use asynchronous iteration ( ) instead. The default way of iterating over a query - with - will result in a blocking database query behind the scenes as Django loads the results at iteration time. To fix this, you can swap to : Be aware that you also can’t do other things that might iterate over the queryset, such as wrapping around it to force its evaluation (you can use in a comprehension, if you want it). Because methods like and do not actually run the query - they set up the queryset to run when it’s iterated over - you can use those freely in asynchronous code. For a guide to which methods can keep being used like this, and which have asynchronous versions, read the next section. Some methods on managers and querysets - like and - force execution of the queryset and are blocking. Some, like and , don’t force execution and so are safe to run from asynchronous code. But how are you supposed to tell the difference? While you could poke around and see if there is an -prefixed version of the method (for example, we have but not ), there is a more logical way - look up what kind of method it is in the QuerySet reference. In there, you’ll find the methods on QuerySets grouped into two sections:\n• None Methods that return new querysets: These are the non-blocking ones, and don’t have asynchronous versions. You’re free to use these in any situation, though read the notes on and before you use them.\n• None Methods that do not return querysets: These are the blocking ones, and have asynchronous versions - the asynchronous name for each is noted in its documentation, though our standard pattern is to add an prefix. Using this distinction, you can work out when you need to use asynchronous versions, and when you don’t. For example, here’s a valid asynchronous query: returns a queryset, and so it’s fine to keep chaining it inside an asynchronous environment, whereas evaluates and returns a model instance - thus, we change to , and use at the front of the whole expression in order to call it in an asynchronous-friendly way. If you forget to put the part in, you may see errors like “coroutine object has no attribute x” or “<coroutine …>” strings in place of your model instances. If you ever see these, you are missing an somewhere to turn that coroutine into a real value. Transactions are not currently supported with asynchronous queries and updates. You will find that trying to use one raises . If you wish to use a transaction, we suggest you write your ORM code inside a separate, synchronous function and then call that using - see Asynchronous support for more.\n\nLookups implementation is different in , mainly due to the existence of key transformations. To demonstrate, we will use the following example model: As with other fields, storing as the field’s value will store it as SQL . While not recommended, it is possible to store JSON scalar instead of SQL by using . Whichever of the values is stored, when retrieved from the database, the Python representation of the JSON scalar is the same as SQL , i.e. . Therefore, it can be hard to distinguish between them. This only applies to as the top-level value of the field. If is inside a or , it will always be interpreted as JSON . When querying, value will always be interpreted as JSON . To query for SQL , use : Unless you are sure you wish to work with SQL values, consider setting and providing a suitable default for empty values, such as . To query based on a given dictionary key, use that key as the lookup name: Multiple keys can be chained together to form a path lookup: If the key is an integer, it will be interpreted as an index transform in an array: If the key you wish to query by clashes with the name of another lookup, use the lookup instead. To query for missing keys, use the lookup: The lookup examples given above implicitly use the lookup. Key, index, and path transforms can also be chained with: , , , , , , , , , , , and , as well as with Containment and key lookups. Represents the text value of a key, index, or path transform of . You can use the double underscore notation in to chain dictionary key and index transforms. Due to the way in which key-path queries work, and are not guaranteed to produce exhaustive sets. If you want to include objects that do not have the path, add the lookup. Since any string could be a key in a JSON object, any lookup other than those listed below will be interpreted as a key lookup. No errors are raised. Be extra careful for typing mistakes, and always check your queries work as you intend. Using on key, index, or path transforms will sort the objects using the string representation of the values. This is because MariaDB and Oracle Database do not provide a function that converts JSON values into their equivalent SQL values. On Oracle Database, using as the lookup value in an query will return objects that do not have as the value at the given path, including objects that do not have the path. On other database backends, the query will return objects that have the path and the value is not . On PostgreSQL, if only one key or index is used, the SQL operator is used. If multiple operators are used then the operator is used. On SQLite, , , and string values will always be interpreted as , , and JSON respectively. The lookup is overridden on . The returned objects are those where the given of key-value pairs are all contained in the top-level of the field. For example: is not supported on Oracle and SQLite. This is the inverse of the lookup - the objects returned will be those where the key-value pairs on the object are a subset of those in the value passed. For example: is not supported on Oracle and SQLite. Returns objects where the given key is in the top-level of the data. For example: Returns objects where all of the given keys are in the top-level of the data. For example: Returns objects where any of the given keys are in the top-level of the data. For example:\n\nKeyword argument queries – in , etc. – are “AND”ed together. If you need to execute more complex queries (for example, queries with statements), you can use . A ( ) is an object used to encapsulate a collection of keyword arguments. These keyword arguments are specified as in “Field lookups” above. For example, this object encapsulates a single query: objects can be combined using the , , and operators. When an operator is used on two objects, it yields a new object. For example, this statement yields a single object that represents the “OR” of two queries: This is equivalent to the following SQL clause: You can compose statements of arbitrary complexity by combining objects with the , , and operators and use parenthetical grouping. Also, objects can be negated using the operator, allowing for combined lookups that combine both a normal query and a negated ( ) query: Each lookup function that takes keyword-arguments (e.g. , , ) can also be passed one or more objects as positional (not-named) arguments. If you provide multiple object arguments to a lookup function, the arguments will be “AND”ed together. For example: Lookup functions can mix the use of objects and keyword arguments. All arguments provided to a lookup function (be they keyword arguments or objects) are “AND”ed together. However, if a object is provided, it must precede the definition of any keyword arguments. For example: … would be a valid query, equivalent to the previous example; but: The OR lookups examples in Django’s unit tests show some possible uses of .\n\nThe delete method, conveniently, is named . This method immediately deletes the object and returns the number of objects deleted and a dictionary with the number of deletions per object type. Example: You can also delete objects in bulk. Every has a method, which deletes all members of that . For example, this deletes all objects with a year of 2005: Keep in mind that this will, whenever possible, be executed purely in SQL, and so the methods of individual object instances will not necessarily be called during the process. If you’ve provided a custom method on a model class and want to ensure that it is called, you will need to “manually” delete instances of that model (e.g., by iterating over a and calling on each object individually) rather than using the bulk method of a . When Django deletes an object, by default it emulates the behavior of the SQL constraint – in other words, any objects which had foreign keys pointing at the object to be deleted will be deleted along with it. For example: # This will delete the Blog and all of its Entry objects. This cascade behavior is customizable via the argument to the . Note that is the only method that is not exposed on a itself. This is a safety mechanism to prevent you from accidentally requesting , and deleting all the entries. If you do want to delete all the objects, then you have to explicitly request a complete query set:\n\nSometimes you want to set a field to a particular value for all the objects in a . You can do this with the method. For example: # Update all the headlines with pub_date in 2007. You can only set non-relation fields and fields using this method. To update a non-relation field, provide the new value as a constant. To update fields, set the new value to be the new model instance you want to point to. For example: # Change every Entry so that it belongs to this Blog. The method is applied instantly and returns the number of rows matched by the query (which may not be equal to the number of rows updated if some rows already have the new value). The only restriction on the being updated is that it can only access one database table: the model’s main table. You can filter based on related fields, but you can only update columns in the model’s main table. Example: # Update all the headlines belonging to this Blog. Be aware that the method is converted directly to an SQL statement. It is a bulk operation for direct updates. It doesn’t run any methods on your models, or emit the or signals (which are a consequence of calling ), or honor the field option. If you want to save every item in a and make sure that the method is called on each instance, you don’t need any special function to handle that. Loop over them and call : Calls to update can also use to update one field based on the value of another field in the model. This is especially useful for incrementing counters based upon their current value. For example, to increment the pingback count for every entry in the blog: However, unlike objects in filter and exclude clauses, you can’t introduce joins when you use objects in an update – you can only reference fields local to the model being updated. If you attempt to introduce a join with an object, a will be raised:\n\nWhen you define a relationship in a model (i.e., a , , or ), instances of that model will have a convenient API to access the related object(s). Using the models at the top of this page, for example, an object can get its associated object by accessing the attribute: . Django also creates API accessors for the “other” side of the relationship – the link from the related model to the model that defines the relationship. For example, a object has access to a list of all related objects via the attribute: . All examples in this section use the sample , and models defined at the top of this page. If a model has a , instances of that model will have access to the related (foreign) object via an attribute of the model. You can get and set via a foreign-key attribute. As you may expect, changes to the foreign key aren’t saved to the database until you call . Example: If a field has set (i.e., it allows values), you can assign to remove the relation. Example: Forward access to one-to-many relationships is cached the first time the related object is accessed. Subsequent accesses to the foreign key on the same object instance are cached. Example: # Hits the database to retrieve the associated Blog. Note that the method recursively prepopulates the cache of all one-to-many relationships ahead of time. Example: If a model has a , instances of the foreign-key model will have access to a that returns all instances of the first model. By default, this is named , where is the source model name, lowercased. This returns , which can be filtered and manipulated as described in the “Retrieving objects” section above. You can override the name by setting the parameter in the definition. For example, if the model was altered to , the above example code would look like this: By default the used for reverse relations is a subclass of the default manager for that model. If you would like to specify a different manager for a given query you can use the following syntax: If performed default filtering in its method, that filtering would apply to the call. Specifying a custom reverse manager also enables you to call its custom methods: When calling with a reverse relation, the default manager will be used. If you want to prefetch related objects using a custom reverse manager, use . For example: In addition to the methods defined in “Retrieving objects” above, the has additional methods used to handle the set of related objects. A synopsis of each is below, and complete details can be found in the related objects reference. Adds the specified model objects to the related object set. Creates a new object, saves it and puts it in the related object set. Returns the newly created object. Removes the specified model objects from the related object set. Removes all objects from the related object set. To assign the members of a related set, use the method with an iterable of object instances. For example, if and are instances: If the method is available, any preexisting objects will be removed from the before all objects in the iterable (in this case, a list) are added to the set. If the method is not available, all objects in the iterable will be added without removing any existing elements. Each “reverse” operation described in this section has an immediate effect on the database. Every addition, creation and deletion is immediately and automatically saved to the database. Both ends of a many-to-many relationship get automatic API access to the other end. The API works similar to a “backward” one-to-many relationship, above. One difference is in the attribute naming: The model that defines the uses the attribute name of that field itself, whereas the “reverse” model uses the lowercased model name of the original model, plus (just like reverse one-to-many relationships). An example makes this easier to understand: # Returns all Author objects for this Entry. # Returns all Entry objects for this Author. Like , can specify . In the above example, if the in had specified , then each instance would have an attribute instead of . Another difference from one-to-many relationships is that in addition to model instances, the , , and methods on many-to-many relationships accept primary key values. For example, if and are instances, then these calls work identically: One-to-one relationships are very similar to many-to-one relationships. If you define a on your model, instances of that model will have access to the related object via an attribute of the model. The difference comes in “reverse” queries. The related model in a one-to-one relationship also has access to a object, but that represents a single object, rather than a collection of objects: If no object has been assigned to this relationship, Django will raise a exception. Instances can be assigned to the reverse relationship in the same way as you would assign the forward relationship: How are the backward relationships possible?¶ Other object-relational mappers require you to define relationships on both sides. The Django developers believe this is a violation of the DRY (Don’t Repeat Yourself) principle, so Django only requires you to define the relationship on one end. But how is this possible, given that a model class doesn’t know which other model classes are related to it until those other model classes are loaded? The answer lies in the . When Django starts, it imports each application listed in , and then the module inside each application. Whenever a new model class is created, Django adds backward-relationships to any related models. If the related models haven’t been imported yet, Django keeps tracks of the relationships and adds them when the related models eventually are imported. For this reason, it’s particularly important that all the models you’re using be defined in applications listed in . Otherwise, backwards relations may not work properly. Queries involving related objects follow the same rules as queries involving normal value fields. When specifying the value for a query to match, you may use either an object instance itself, or the primary key value for the object. For example, if you have a Blog object with , the following three queries would be identical:"
    },
    {
        "link": "https://stackoverflow.com/questions/62099463/django-filter-by-two-parameters",
        "document": "I want to filter by two parameters. I have this:\n\nBut this works only if two filters are chosen(otherwise it returns nothing). I want my program to filter by one filter if only one is chosen and filter by two parameters if two are chosen. How can I do that?"
    },
    {
        "link": "https://stackoverflow.com/questions/9410647/how-to-filter-model-results-for-multiple-values-for-a-many-to-many-field-in-djan",
        "document": "If your model looks like this:\n\nThen, you can execute this query:\n\nWhich roughly translates to \"find all groups that have players whose names match 'Player1' and 'Player2'\"\n\nOr you can fetch the objects individually:"
    },
    {
        "link": "https://django-rest-framework.org/api-guide/filtering",
        "document": ""
    },
    {
        "link": "https://django-filter.readthedocs.io/en/stable/guide/usage.html",
        "document": "Django-filter provides a simple way to filter down a queryset based on parameters a user provides. Say we have a model and we want to let our users filter which products they see on a list page.\n\nWe have a number of fields and we want to let our users filter based on the name, the price or the release_date. We create a for this: As you can see this uses a very similar API to Django’s . Just like with a we can also override filters, or add new ones using a declarative syntax. The declarative syntax provides you with the most flexibility when creating filters, however it is fairly verbose. We’ll use the below example to outline the core filter arguments on a : There are two main arguments for filters:\n• None : The name of the model field to filter on. You can traverse “relationship paths” using Django’s syntax to filter fields on a related model. ex, .\n• None : The field lookup to use when filtering. Django’s syntax can again be used in order to support lookup transforms. ex, . Together, the field and represent a complete Django lookup expression. A detailed explanation of lookup expressions is provided in Django’s lookup reference. django-filter supports expressions containing both transforms and a final lookup. The FilterSet Meta class provides a attribute that can be used for easily specifying multiple filters without significant code duplication. The base syntax supports a list of multiple field names: The above generates ‘exact’ lookups for both the ‘price’ and ‘release_date’ fields. Additionally, a dictionary can be used to specify multiple lookup expressions for each field: The above would generate ‘price__lt’, ‘price__gt’, ‘release_date’, and ‘release_date__year__gt’ filters. The filter lookup type ‘exact’ is an implicit default and therefore never added to a filter name. In the above example, the release date’s exact filter is ‘release_date’, not ‘release_date__exact’. This can be overridden by the FILTERS_DEFAULT_LOOKUP_EXPR setting. Items in the sequence in the class may include “relationship paths” using Django’s syntax to filter on fields on a related model: Like , it is possible to override default filters for all the models fields of the same kind using on the class: The may be initialized with an optional argument. If a request object is passed, then you may access the request during filtering. This allows you to filter by properties on the request, such as the currently logged-in user or the header. It is not guaranteed that a will be provided to the instance. Any code depending on a request should handle the case. To filter the primary queryset by the object, simply override the property. For example, you could filter blog articles to only those that are published and those that are owned by the logged-in user (presumably the author’s draft articles). The argument for and supports callable behavior. If a callable is passed, it will be invoked with the as its only argument. This allows you to perform the same kinds of request-based filtering without resorting to overriding . You can control the behavior of a filter by specifying a to perform filtering. View more information in the method reference. Note that you may access the filterset’s properties, such as the .\n\nNow we need to write a view: If a queryset argument isn’t provided then all the items in the default manager of the model will be used. If you want to access the filtered objects in your views, for example if you want to paginate them, you can do that. They are in f.qs\n\nAnd lastly we need a template: And that’s all there is to it! The attribute contains a normal Django form, and when we iterate over the we get the objects in the resulting queryset.\n\nIn addition to the above usage there is also a class-based generic view included in django-filter, which lives at . You must provide either a or argument, similar to in Django itself: If you provide a optionally you can set to specify a list or a tuple of the fields that you want to include for the automatic construction of the filterset class. You must provide a template at which gets the context parameter . Additionally, the context will contain which holds the filtered queryset. A legacy functional generic view is still included in django-filter, although its use is deprecated. It can be found at . You must provide the same arguments to it as the class based view: The needed template and its context variables will also be the same as the class-based view above."
    }
]