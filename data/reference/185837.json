[
    {
        "link": "https://tuxcare.com/blog/troubleshooting-common-centos-7-problems-a-guide-for-system-administrators",
        "document": "It is common knowledge that security is crucial for every enterprise dealing with sensitive information, and that includes just about every business today. When we consider server systems like CentOS 7, the need for enhanced security becomes even more vital due to the inherent open-source nature of these systems.\n\nThis blog post is a hands-on guide to bolstering the security of your CentOS 7 environment, discussing both practical tips and best practices to ward off potential security threats.\n\nCentOS (Community Enterprise Operating System) is a popular open-source Linux distribution that serves as a reliable option for managing web servers, databases, and email servers, among other tasks. Being an open-source platform, it has a massive community of developers consistently working on updates and security patches.\n\nNevertheless, the security responsibility lies significantly in the hands of the users and system administrators. CentOS 7, despite being one of the safest distributions, isn’t immune to potential threats. Consequently, steps need to be taken to ensure your CentOS 7.9 environment is as secure as possible, just as you would with any other server or service you manage.\n\nSecure Shell (SSH) is the standard protocol for remote server management in CentOS 7. However, it can become a security concern if not properly configured. Here are the best practices:\n\nDisable root logins: In the SSH configuration file (`/etc/ssh/sshd_config`), find the line “PermitRootLogin” and set it to “no”. This action will prevent direct root logins, which could otherwise provide a potential intruder with escalated privileges.\n\nLimit the number of users who can log in via SSH: Again, in the SSH configuration file, add an “AllowUsers” line followed by the usernames of those you want to give SSH access.\n\nImplement key-based authentication: Passwords can be cracked, but SSH keys provide a more secure authentication method. In the case of CentOS 7, you can use tools such as `ssh-keygen` and `ssh-copy-id` to generate and distribute keys.\n\nCentOS 7 uses Firewalld, an interface to iptables, to manage the system’s firewall. Firewalld is dynamic and can adjust the rules without disconnecting current connections. Here’s how to secure it:\n\nOnly allow necessary services: Use the command `firewall-cmd –list-all` to see which services are allowed in the current zone. Remove unnecessary ones with `firewall-cmd –remove-service`.\n\nLimit open ports: Ports should be kept closed unless necessary for your server to function. Use `firewall-cmd –list-ports` to check open ports and `firewall-cmd –remove-port` to close them.\n\nRegular updates are essential to ensure your system is protected from the latest known vulnerabilities. Use `yum update` to install the latest updates on CentOS 7.\n\nSecurity-Enhanced Linux (SELinux) is a Linux kernel security module that provides a mechanism for supporting access control security policies. It comes pre-installed on CentOS 7.\n\nDon’t disable SELinux: While it might be tempting to disable SELinux because of its complexity, it significantly improves system security.\n\nLearn and use the tools: `sestatus` can be used to check the status of SELinux, `semanage` to manage SELinux policies, and `sealert` to review SELinux alerts.\n\nIntrusion Detection Systems (IDS) like AIDE (Advanced Intrusion Detection Environment) or RKHunter can be extremely useful. They monitor your system for any suspicious activity and notify you of potential breaches.\n\nRegular backups can save the day in case of a catastrophic event. Tools like rsync or Bacula can be used to automate the backup process.\n\nEnsuring your CentOS 7 environment is secure involves various steps, from securing SSH logins and configuring the firewall to regular system updates, utilizing SELinux, employing intrusion detection systems, and implementing regular backups.\n\nWhile this might seem daunting, remember that security is not a one-time event but an ongoing process. A well-secured CentOS 7 environment system requires regular updates and vigilant monitoring. Start by securing one aspect at a time, continuously improve, and always stay alert for new security threats.\n\nFor those who want a more hands-off approach to server security, considering services like KernelCare Enterprise that provide automated kernel patching and updating without system reboots might be a good idea. It fits seamlessly into your CentOS 7 infrastructure and offers a level of convenience while not compromising on the robustness of your security measures.\n\nTuxCare, which delivers KernelCare Enterprise, also offers end-of-life security updates for Linux distributions that are no longer supported – a solution called Extended Lifecycle Support. When CentOS 7 reaches end of life in 2024, TuxCare will extend the security lifecycle of your CentOS 7 systems for four additional years – giving you plenty of time to migrate to a different distribution.\n\nDon’t let your CentOS 7 environment be the weak link in your infrastructure. Follow this guide, remain diligent, and your server security will be robust enough to withstand most threats."
    },
    {
        "link": "https://medium.com/@dolpa/centos-7-network-troubleshooting-982fa663a859",
        "document": "\n• Test the problem (reproduce the problem, get background information, collect logs errors and etc…)\n• Fix (change the configuration and check if the problem is still exist)\n\nCommand ping can be used to check connectivity to another server:\n\nIn the example I’m sending 5 packages to host 8.8.8.8 which is global DNS.\n\nTo get ip address of eth0 network interface:\n\nUse traceroute to get information about every host on the network package path:\n\nTo see route table you can use ip route:\n\nCommand host may be used then you need to make resolving of hostname:\n\nAnd the last command to get current status of the system or check it is dig:\n\ndig is very powerful tool and please read the manual of it."
    },
    {
        "link": "https://redswitches.com/blog/centos-7-network-config",
        "document": "CentOS 7 network configuration is critical to keeping the systems running smoothly. That’s why editing the config files that control the network configuration of a CentOS 7 server is an essential step when you’re setting up a new server or maintaining an existing server.\n\nYou can edit these configuration options via the terminal’s GUI or config files. Whichever method you opt for, the objective is to streamline the performance of your network connectivity so that the applications deployed on the CentOS 7 server don’t face any outages.\n\nThis tutorial will show how you can easily customize network interface configuration. First, we’ll show you how to use a network manager to set up a static IPv4 address on your dedicated server. Then, we’ll show you how to easily change these settings using the command line and GUI utility.\n\nNaming network interfaces is essential for better interface management. Choosing the naming convention becomes very important in a multi-interface or virtualized setup with several network interfaces.\n\nNetwork interface naming conventions assign names based on attributes like location and type. These predictable network Interface names provide consistent labels for easier identification.\n\nCentOS 7 uses “biosdevname” or “systemd” schemes. Some examples of these conventions are “eno1” (Ethernet Onboard 1), “ens2” (Ethernet Server 2), “enp0sX” (Ethernet PCI slot 0, interface X), and “enx<MAC>” (Ethernet with MAC).\n\nIf you’re coming from CentOS 6, you should know that the network interface naming convention has changed in CentOS 7.\n\nIn CentOS 6, the network interfaces were numbered, starting from 0. So, for instance, the first interface would be eth0. In CentOS 7, the naming convention has changed because of the changes by the RHEL 6. Now, the first network interface is enp3s0.\n\nTo change CentOS 7 network config files, you need a bare metal, cloud VPS, or dedicated server running CentOS 7.\n\nConfigure Network Settings on CentOS 7 Using the Terminal\n\nSince many sysadmins prefer the terminal, we’ll start by discussing how you can edit Centos 7 network config files.\n\nYou can easily set up a static IP address by changing the network script the network interface uses. This involves the following steps.\n\nBefore changing anything, you need to find the correct network interface. This is important because a bare metal server can connect multiple network interfaces to internal or external connections. That’s why you must find the network interface name you wish to modify before proceeding.\n\nWe’ll use the following command to list all network devices.\n\nNow that you have the network interface name use the following command to access the network configuration for the network interface.\n\nstep # 3: Make the Changes in the CentOS 7 Network Interface Configuration Details\n\nNow, to set the static IP for the CentOS 7 network interface configuration, change the following values:\n\nBOOTPROTO to “static” to change the boot protocol to a static IP address\n\n ONBOOT to “yes” to enable the network interface at the system startup.\n\nNext, you need to add the following information about the IP address and the DNS server IP address:\n• None IPADRR (The static IP address assigned to the network interface)\n\nImportant: You can get information about the gateway and DNS by using the command.\n\nSave the file and exit the text editor.\n\nAt this point, the information you added in the previous step is saved to the network configuration file. However, the changes are ineffective because the network interface is still on the old settings.\n\nTherefore, you need to restart the network for the new settings to take effect. For this, use the following command in the terminal:\n\nTo configure a network interface for DHCP (Dynamic Host Configuration Protocol) in CentOS 7, follow these steps:\n\nIdentify the device name with the command #nmcli d, and follow the steps outlined in the static IP configuration section.\n\nNavigate to the network configuration directory, often found at /etc/sysconfig/network-scripts/.\n\nLocate the configuration file corresponding to the target network interface, e.g., /etc/sysconfig/network-scripts/ifcfg-ens33.\n\nIn our case, the network interface is eth0.\n\nUse a text editor like vi or Nano to modify the file to include the following settings.\n\nSave the changes and close the text editor.\n\nYou need to restart the network interface to ensure your changes take effect. For this, use the following command:\n\nTo confirm the changes, use the ip addr, ifconfig, or nmcli d command. You should observe that the network interface now has an IP address acquired through DHCP.\n\nWe hope you can now adjust the interface name and file paths to enable DHCP for a network interface in CentOS 7.\n\nYou can use the GUI to change the config network CentOS 7 files if you want to use the Network Manager utility. The significant details of the process are similar to what we mentioned earlier in the terminal section.\n\nYou must carry out the following steps to configure a static IP address via the GUI.\n\nIn the terminal, type the nmtui command to launch the Network Manager. Next, in the NetworkManager TUI screen, select Edit a Connection.\n\nThis will open the list of all available network interfaces. Select the network interface you wish to modify.\n\nUse the arrow keys to navigate to the “Edit a connection” and press Enter.\n\nChoose the network interface you want to configure (e.g., eth0 or ens33) from the list, and press Enter.\n\nOn the “Edit Connection” screen, navigate through the options using arrow keys and set the following:\n• None Select “Automatically connect” to ensure the interface connects during boot.\n\nReview the changes, navigate to OK with the TAB key, and press Enter to confirm the changes.\n\nAfter making the changes, return to the terminal and use the following command to restart the network service:\n\nAfter making the changes and restarting the network service, it is essential to check if the new settings are in force. For this, you should display the current information by entering the following command in the terminal:\n\nTo configure a network interface for DHCP in CentOS 7. We suggest using the nmtui (NetworkManager Text User Interface) command.\n\nThe process has the following steps.\n\nOpen a terminal and enter nmtui to launch the NetworkManager Text User Interface.\n\nUse the arrow keys to navigate the menu and select “Edit a connection” by pressing the Enter key.\n\nSelect the appropriate network interface you want to configure (e.g., eth0 or ens33) from the list and press Enter.\n\nOn the screen, make the following changes:\n• None Configure DNS servers and search domains if necessary.\n\nWhen done, press Tab to select “OK” and press Enter.\n\nReview the changes, navigate to OK by pressing the TAB key, and press Enter to confirm the changes.\n\nYou need to restart the network service to ensure your changes take effect. Enter the following command in the terminal:\n\nYou should assign a hostname to your system if you haven’t done it already. These names are visible to the entire network, making it easy for all users to identify your CentOS 7 server.\n\nSetting up the hostname using the nmtui utility in CentOS 7 involves the following steps.\n\nOpen a terminal and enter nmtui to launch the NetworkManager Text User Interface.\n\nUse the arrow keys on the main screen to select “Set system hostname” from the menu, and then press Enter.\n• None Enter the desired hostname into the provided field.\n• None Navigate to the “OK” button using the Tab key, and press Enter.\n\nYou need to restart the network service to ensure the new hostname is applied and visible to all users. Enter the following command in the terminal:\n\nVerify the hostname change by executing the hostname command in the terminal.\n\nAs a server admin, you should keep a close watch on the network settings of your CentOS 7 server because, during typical usage, network settings might change as admins add new services and rename or modify existing services.\n\nTo validate your network settings in CentOS 7, follow these steps:\n\nUse the ip addr or ifconfig command to display the configured network interfaces and their associated IP addresses, subnet masks, and status.\n\nThe ip route command displays the routing table and confirms the default gateway settings.\n\nThe ping command tests connectivity to external data sources (servers and websites). This test confirms that your network is functional. We’ll ping Google, but you can use any website or server for this test.\n\nNext, test DNS resolution by using the nslookup or dig command to query DNS servers for the IP address of a domain.\n\nReview the configuration files in the /etc/sysconfig/network-scripts/ directory, such as ifcfg-<interface-name>, to ensure they reflect the most optimal settings.\n\nVerify that your DNS servers are correctly configured. For this, check the /etc/resolv.conf file to see the DNS server IP addresses.\n\nFollowing these steps, you can comprehensively validate your network settings in CentOS 7. This ensures your network connections, IP settings, hostname resolution, and DNS configuration are all in order.\n\nAlso Read: How to Install CentOS 7 in 4 Easy Steps\n\nThis short tutorial demonstrated how to change the CentOS 7 network config files easily. While we showed how to set a static IP address for a network interface, you can use the process to set other options, such as a DHCP configuration or setting the system’s hostname. In addition to this blog, you can also read about CentOS vs Ubuntu, CentOS vs Debian, HAProxy for CentOS 7 servers, and how to install MySQL on CentOS 7.\n\nReady to configure your CentOS 7 server’s network for optimal performance and security? Trust Redswitches, your reliable partner in server management and networking solutions. Our expert team can guide you through every step of the process, ensuring your network is robust and efficient. Contact us today to get started.\n\nQ. Where is the network config file in CentOS 7?\n\nIn CentOS 7, the network configuration files are typically in the /etc/sysconfig/network-scripts/ directory. These files, such as ifcfg-<interface-name>, contain network settings like IP addresses and DNS servers.\n\nQ. Where is the network interface file in CentOS?\n\nIn CentOS 7, network interface configuration files are found in the /etc/sysconfig/network-scripts/ directory. These files store settings like IP addresses and gateway information for specific network interfaces.\n\nQ. How to check Network status by using the systemctl command in CentOS 7?\n\nTo check the network status using the systemctl command in CentOS 7, you can use the following command:\n\nThis command provides you with information about the status of the network service, including whether it’s active, inactive, or failed. It also displays recent log entries related to the network service.\n\nQ. Where is the hosts file in CentOS 7?\n\nIn CentOS 7, the hosts file is located at /etc/hosts. This file maps IP addresses to hostnames, crucial for local DNS resolution. You can edit this file to add custom hostname mappings or modify existing ones.\n\nQ. What’s the use of the nmcli dev command in CentOS 7?\n\nIn CentOS 7, the nmcli dev command manages network devices. It facilitates tasks such as viewing device details, enabling/disabling devices, modifying settings, connecting/disconnecting, monitoring statuses, and aiding network configuration and management via the command line."
    },
    {
        "link": "https://upcloud.com/resources/tutorials/troubleshoot-network-connectivity-linux-server",
        "document": "When your Linux server experiences network connectivity issues, you need reliable tools and techniques to quickly identify and resolve the problem. This guide covers essential Linux commands for troubleshooting, including how to check network interfaces, test internet connectivity, and verify DNS records. Whether you’re using Ubuntu, CentOS, or Debian, these steps will help you diagnose network failures, check server configurations, and restore connectivity.\n\nWhen your Linux server seems to be offline or otherwise inaccessible, you should always be able to log in with the web console at your UpCloud control panel or through a VNC connection. Once logged in, test your server’s internet connection using ping and a public IP address such as Google’s public DNS server, which is most likely to reply, provided your internet connection works.\n\nYour output should show something like\n\nIf the server is unable to reach the destination, there may be a problem with your configuration. Follow the steps described here in order to troubleshoot the most common network issues with Linux Cloud Servers.\n\nIf your Linux server is unreachable, start by checking your network interfaces. Use the ip addr command to view the status of all interfaces, ensuring critical connections like eth0 are enabled. Should you find any interfaces disabled, activate them with ifup. Troubleshoot persistent issues by restarting interfaces using the ifdown –force and ifup commands.\n\nMake sure the network interfaces, such as eth0, are enabled. To see all the configured interfaces, use this command.\n\nThe output of the command will show the status of each network interface on the server with “state UP” or “state DOWN”, for example, as below.\n\nTurn on any disabled interfaces with the next command.\n\nHere the interface name is one of the names listed in the command output such as , or .\n\nWhen all network interfaces have been enabled, try using the command again. If the problem persists, check that the network interfaces have IPs assigned to them, and they match the information in the Network section of the UpCloud control panel.\n\nTry restarting any problematic interface with the following commands.\n\nIf either of these commands fails, the interface may be in a state unknown to the command script. Try the same commands again withthe — parameter to resolve any such issues.\n\nIf restarting the network interface fixed the issue then great! If not, continue with the troubleshooting.\n\nLinux commonly stores network settings in specific files and reads them, for example, at boot or when using the ifup command. To make changes to the network configuration, you’ll need to open the right file in a text editor. In Debian and Ubuntu-based distributions, this can be done with\n\nIn most cases, the file should list the following interfaces.\n\nIn CentOS and other Red Hat variants, these configurations are split into separate files for each network interface and stored in . The default interface for internet connection is usually called , which opens the corresponding configuration file.\n\nThe configuration file for eth0 should look like this.\n\nIf the interface configuration files do not match the example here, edit the file specific to your system to restore the original functionality. For any changes made to these files to take effect, you must restart the interfaces to which the changes apply as described previously with and commands.\n\nIf your server can ping an IP but fails to connect to domains, it may be a DNS issue. Use ping upcloud.com to test domain name resolution, and check DNS configuration with sudo cat /etc/resolv.conf. Ensure your DNS servers, such as UpCloud’s resolvers, are properly configured in this file or through your network interfaces file.\n\nIf the domain does not reply, the problem is most likely with how your server resolves domain names to IP addresses. Check your server’s DNS records.\n\nThe list should contain a minimum of 1 name server. All default DNS resolvers at UpCloud have the same IP addresses regardless of the availability zone. The DNS servers are provided automatically by the DHCP protocol, and there should be no need for manual configurations in the operating system.\n\nIf your server has a public IPv6 address, you can also use IPv6 with the following servers:\n\nIf the list is empty do not edit it manually, because if you have a nameserver manager installed any changes you make will just get reverted. Instead, you can try to update it on Ubuntu and some Debian systems with this command.\n\nOn Debian servers, which do not have installed, you can edit the file directly.\n\nAdd the lines shown below to the file, save and exit.\n\nFor those with installed, in case resolv.conf is still empty after the update command, you can add nameservers to your interfaces file. Open it for editing.\n\nAdd a name server to the end of the eth0 section.\n\nAfterwards, save the file and exit. You will also need to restart the network service with the following command.\n\nIn CentOS and other Red Hat variants the file is populated a little differently, if the file is empty, you can add up to two DNS entries in your network configuration file for the network interface responsible for the public IP. For example, open it with the next command.\n\nEdit the file to look like this.\n\nExit the editor and restart the interface which the configuration file you just edited using and commands.\n\nTry pinging your server over the internet. Open a terminal or command prompt on your own computer and try pinging your server’s public IP, which you can find in the UpCloud control panel under the Network section.\n\nTest the internet connection by pinging another site from your server. For example, use the following command to ping Google’s public DNS.\n\nIf you have a second server deployed on your account and the problem is with the interface assigned with the private IP address, try to ping your other server to and from it using the private IPs listed in the UpCloud control panel.\n\nShould ping fail to receive a reply, try restarting your server’s network services. In Debian and Ubuntu 12.04 or older, use the command below.\n\nOn CentOS and other Red Hat-based systems, restart the network with the command underneath instead.\n\nIn Ubuntu 14.04 and newer, you’ll need to run the command for each network interface separately. For example, you can restart eth0 simply by following the following.\n\nAfter restarting the network services, try running ping again both ways. Check your firewall settings if ping works in one direction but not in the other.\n\nFind out where the connection fails\n\nWhen basic troubleshooting doesn’t resolve the issue, test network routes using tools like mtr, traceroute, or tracepath to identify where connectivity fails. These commands provide visibility into each node the connection passes through, helping pinpoint any network routing failures.\n\nUbuntu servers have a networking tool called for this purpose. Start it with the following command.\n\nTo quit, just press on your keyboard.\n\nYou can use traceroute instead on Debian systems where mtr is usually not installed by default.\n\nDifferent distributions run different tools and the output of these tools also differs slightly. The runs in the foreground until cancelled, updating the response table on each pass, example output is shown below.\n\nand are very similar to one another, they run pass over the network to the given destination and show the latency to each node that replied. The example of the traceroute shown underneath has much of the same information as .\n\nTry the same from your own computer to the server using one of the tools mentioned above, for example, using the command below.\n\nIf an outbound trace does not reach even the first node, check your network settings and firewall. The firewall may also be responsible for connection rejections if the trace over the internet to your server falls short just before reaching the server.\n\nCheck that your connection is not getting blocked by a firewall. CentOS and some other Red Hat-based distributions have strict firewall rules by default. The following command will list all server-side firewall rules on your system.\n\nIptables is the Linux built-in software firewall, and the command above prints out the following.\n\nThis is an example of a simple firewall table. It has rules to allow SSH and HTTP traffic, but block all other input, which also blocks ping attempts. Check your server’s for any is shown that might block your connection.\n\nYour UpCloud control panel also provides an easily configurable firewall in your server settings under the Firewall tab.\n\nThe example image above has a few accepted incoming rules, but the default rule is set to reject. Make sure there are no rules blocking your desired connection.\n\nCheck the most up-to-date information on UpCloud infrastructure at status.upcloud.com, where you can also subscribe to updates by email, SMS, and Atom or RSS feeds.\n\nIf everything seems to be in order, but the network connection still just doesn’t work, or you are otherwise unable to troubleshoot the connection issues, don’t hesitate to ask for help."
    },
    {
        "link": "https://if-not-true-then-false.com/2014/centos-7-netinstall-guide",
        "document": "This step-by-step walkthrough with screenshots, howto install CentOS (The Community ENTerprise Operating System) 7.7 Linux with Network installation (NetInstall).\n\nCentOS 7.7 is released and it brings all Red Hat (RHEL) 7.7 goodness to all CentOS 7.7 users.\n\nNote: only 64-bit (x86_64) image is available.\n\n2. Burn CentOS 7 Image to CD and Boot Computer or Create Bootable USB Stick⌗\n\nCheck CentOS image MD5 sum and burn image to CD with your favorite CD burner or create bootable USB stick. And boot computer using CentOS installation media.\n\nThis is best to do first, because network is really needed on NetInstall.\n\n\n\nIf you have network connection, then easiest way to keep time everything sync, is use NTP (Network Time Protocol).\n\n\n\nSelect disk(s) what you want to use for installation. Then you can also select partitioning type (automatic or manual) and encryption. I selected manual partitioning without encryption.\n\n\n\nYou can add partitions when you click +-sign on bottom left\n\n\n\nWhile installer create partitions and install packages it’s time to set root password and create user account."
    },
    {
        "link": "https://redhat.com/en/blog/ping-traceroute-netstat",
        "document": "I've spent a career building networks and servers, deploying them, troubleshooting them, and caring for applications. When there's a network problem, be it outages or failed deployments (or you're just plain curious about how things work), three simple tools come to mind: , , and .\n\nThe command is one of the most well-known tools available. Simply put, sends an \"are you there?\" message to a remote host. If the host is, in fact, there, returns a \"yup, I'm here\" message. It does this using a protocol known as ICMP, or Internet Control Message Protocol. ICMP was designed to be an error reporting protocol and has a wide variety of uses that we won't go into here.\n\nPing uses two ICMP message types: type 8 (Echo Request) and type 0 (Echo Reply). When you issue a command, the source sends an ICMP Echo Request to the destination. If the destination is available and is allowed to respond, then it replies with an ICMP Echo Reply. Once the message returns to the source, the command displays a success message as well as the Round Trip Time (RTT). The RTT can be an indicator of the latency between the source and the destination.\n\nWhen the command completes, it displays a summary of the ping session. This summary tells you how many packets were sent and received, how much packet loss there was, and statistics on the RTT of the traffic. Ping is an excellent first step for identifying whether or not a destination is \"alive.\" Keep in mind, however, that some networks block ICMP traffic, so a failure to respond is not a guarantee that the destination is offline.\n\nHere is an example:\n\nThe example above shows a session to google.com. From the output, you can see the IP address being contacted, the sequence number of each packet sent, and the round-trip time. In this case, six packets were sent with an average RTT of 14ms.\n\nOne thing to note about the output above and the utility, in general, is that is strictly an IPv4 tool. If you're testing in an IPv6 network you'll need to use the utility. Ping6 behaves roughly identical to the utility with the exception that it uses IPv6.\n\nTraceroute is a finicky beast. This tool is meant to identify the path between a source and a destination point. The reality is mostly true, with a couple of caveats. Let's start by explaining how traceroute works:\n\nThink of as a string of commands. At each step along the path, identifies the hop's IP as well as the latency to that hop. But how is it finding each hop? Turns out, it's using a bit of trickery.\n\nTraceroute uses UDP or ICMP, depending on the OS. On a typical *nix system it uses UDP and sends traffic to port 33434 by default. On a Windows system, uses ICMP. As with , can be blocked by not responding to the protocol/port being used.\n\nWhen you invoke , you identify the destination you're trying to reach. The command begins by sending a packet to the destination, but it sets the packet's time to live (TTL) to one. This behavior is significant because the TTL value determines how many hops a packet is allowed to pass through before an ICMP Time Exceeded message is returned to the source. The trick here is to start the TTL at one and increment it by one after the ICMP message is received:\n\nTraceroute displays the ICMP message's source address as the name of the hop and moves on to the next hop. When the source address finally matches the destination address, knows that it has reached the destination. It then outputs the full route from the source to the destination with the RTT for each hop. As with , the RTT values shown are not necessarily representative of the real RTT to a service such as HTTP or SSH. Traceroute, like , is considered to be lower priority compared to other traffic, so RTT values aren't guaranteed.\n\nThere is a second caveat with that you should be aware of: Traceroute shows you the path from the source to the destination, but this does not mean that the reverse is true. In fact, there is no current way to identify the path from the destination to the source without running a second from the destination. Keep this in mind when troubleshooting path issues.\n\nNetstat is an indispensable tool that shows you all of the network connections on an endpoint. That is, by invoking on your local machine, all of the open ports and connections are shown. This output includes connections that are not completely established as well as connections that are being torn down:\n\nThe output above shows several different ports in a listening state as well as a few established connections. For listening ports, if the source address is 0.0.0.0, it is listening on all available interfaces. If there is an IP address instead, then the port is open only on that specific interface.\n\nThe established connections show the source and destination IPs as well as the source and destination ports. The Recv-Q and Send-Q fields show the number of bytes pending acknowledgment in either direction. Finally, the PID/Program name field shows the process ID and the name of the process responsible for the listening port or connection.\n\nNetstat also has a number of switches that can be used to view other information, such as the routing table or interface statistics. Both IPv4 and IPv6 are supported: There are switches to limit to either version, but both are displayed by default.\n\nIn recent years, has been superseded by the command. You can find more information on the command in this article by Ken Hess.\n\nAs you can see, these tools are invaluable when troubleshooting network issues. As a network or systems administrator, I highly recommend becoming intimately familiar with these tools. Having them available might save you a lot of time troubleshooting later.\n\n[ Want more on networking topics? Check out the Linux networking cheat sheet. ]"
    },
    {
        "link": "https://wiki.centos.org/attachments/Events(2f)Dojo(2f)Bangalore2014/Network-jkalliyat.pdf",
        "document": ""
    },
    {
        "link": "https://phoenixnap.com/kb/linux-network-commands",
        "document": "Network commands are an essential toolkit for any network administrator or sysadmin. The commands help set up, troubleshoot, diagnose, and manage a Linux system's network connections.\n\nNavigating the various available commands and documentation is overwhelming, and having a single reference point is crucial when working on networking tasks.\n\nThis article provides 20 essential Linux network commands and a free downloadable PDF cheat sheet.\n\nLinux provides many helpful networking commands and tools. The commands typically perform complex networking tasks like monitoring, troubleshooting, and network configuration. Most networking utilities are part of the older (legacy) package or the more modern .\n\nSpecific command syntax may differ depending on the command version. Double-check a command's syntax with:\n\nThe man command displays the manual page for the specified command in the terminal.\n\nBelow is a brief overview of 20 Linux networking commands.\n\nThe ip command is a unified networking tool for Linux systems. The command helps view and configure routing, interfaces, network devices, and tunnels.\n\nThe command is part of the package and replaces many older networking tools, such as the , , and commands.\n\nThe syntax for the command is:\n\nEach part of the command does the following:\n• are the command-line parameters that modify the command's behavior.\n• represents the available objects for configuration.\n• is a subcommand, an action performed on an object. The available commands differ depending on the object.\n\nThe command shows the help menu when used without any options, objects, or commands:\n\nAdd the option to see the current version:\n\nThe output prints the package and library version for the utility.\n\nThe command manages and shows network interface IP addresses. The command aliases are or .\n\nThe syntax for the command is:\n\nThe available subcommands on the object are:\n\nEvery subcommand has additional options and keywords to perform specific tasks for the network interface addresses.\n\nThe command without any subcommands shows the network interface information, including the associated IP addresses:\n\nThe output for is identical.\n\nTo show a specific network interface, use the subcommand and add the interface name. For example:\n\nThe command filters the output and shows only information relevant to the specified interface.\n\nThe command manages and shows network interface information. It allows viewing, changing, enabling, and disabling network interfaces.\n\nThe syntax for the command is:\n\nThe subcommands enable the following actions:\n• - Changes or adds information to a network interface.\n\nSubcommands have additional options and allow targeting specific interfaces.\n\nThe command without any additional subcommands and options shows all network interface link information:\n\nThe command provides the same output.\n\nTo turn off an interface, use the following syntax as a superuser:\n\nThe interface shows the state as after executing the command.\n\nSimilarly, to disable an interface, use the keyword:\n\nThe interface state changes to .\n\nThe command shows and configures the IP routing table. The command allows users to adjust the routing table and perform other crucial networking tasks with the routing table.\n\nThe command follows a specific syntax, as shown below:\n\nThe following actions are available as subcommands:\n• - Adds a new route to the table.\n\nThe parameter determines where the network traffic is directed. Additional options help control the traffic flow further.\n\nTo view the routing table, run the following command:\n\nEach line in the output represents individual routes in the table.\n\nThe ifconfig (interface configuration) command manages and shows network interface information on a system. The command is part of the package.\n\nAlthough the command has limited functions compared to the command, the command is still commonly used for configuring network interfaces.\n\nThe syntax for the command is:\n\nThe syntax breaks down into the following:\n• - The network interface to configure or show information for. The parameter is optional, and not specifying an interface shows the status of all active interfaces.\n• - Command-line options to perform specific actions or configure certain parameters. The parameter is also optional.\n\nTo display the summary of all active network interfaces, run:\n\nThe command prints a shortlist with crucial information about active interfaces.\n\nThe dig command queries Domain Name Systems (DNS) and finds information for DNS records. The command collects domain name information and associated records.\n\nUse to troubleshoot DNS issues and to verify DNS configuration on a Linux system. It is suitable for creating scripts and automating tasks related to network troubleshooting. The robust command is so prevalent in network troubleshooting that a Windows version of dig is available.\n\nThe command syntax is as follows:\n\nThe components of the command are:\n• - Parameters that modify the behavior of the command.\n• - The domain name to query.\n• - The DNS record type to query. Defaults to A records.\n• - A specified DNS server for the query.\n\nAll parameters are optional. The command shows the default DNS resolver information and query statistics without additional options.\n\nTo perform a simple DNS lookup, run the command with a domain name:\n\nAlternatively, provide the IP address and the option to perform a reverse DNS lookup. For example:\n\nThe in the output shows the requested domain name.\n\nThe nslookup command is similar to the command. The main difference between the two commands is that features an interactive mode. It enables diagnosing and querying DNS servers, which is helpful for network troubleshooting and DNS tasks.\n\nThe command is available for most Unix-like and Windows operating systems.\n\nThe general syntax for the command is:\n• - The domain name to look up. Not specifying a name enables querying multiple domains in interactive mode.\n• - The DNS server to use for the lookup. Defaults to the system DNS server when left out.\n\nThe following example shows how to perform a DNS lookup for a domain:\n\nThe output shows the DNS resolution information for the provided domain.\n\nThe netstat command (network statistics) is a networking utility that shows various networking statistics. The command provides statistics for network ports and shows port availability.\n\nThe command is part of the package and is considered obsolete. The recommended replacement is the command, which is part of . Other functionalities of the command are available with the command.\n\nThe syntax for the command is simple:\n\nThe command allows combining various options to customize the output and to show specific network information types. The command lists open sockets for all configured address families without any options.\n\nFor example, to list all TCP ports with the command, use the options:\n\nThe output shows all active TCP connections on the system.\n\nThe traceroute command is a networking diagnostics tool available for Linux, macOS, and Windows. The command tracks the route that packets take to reach a destination on a TCP/IP network.\n\nUse the command to discover routing issues and bottlenecks by showing a packet's intermediate hops while traveling from source to destination.\n\nThe default trace is 30 hops with a packet size of 60 bytes for IPv4 (80 bytes for IPv6).\n\nThe syntax for the command is:\n\nThe parameter is required, while additional options control whether to perform DNS lookups, the TTL parameter, and the packet type.\n\nTo trace a packet route using the TCP protocol, run the command as an administrator with the option. For example:\n\nThe output shows the sequential route from source to destination.\n\nThe command is similar to the command. The command identifies paths and latencies from source to destination, mapping the router and network hops.\n\nAlthough is a well-known command with comprehensive options, the command is a simple network mapping tool available on most Linux systems. For more details, see the comparison between tracepath and traceroute.\n\nThe syntax for the command is:\n\nThe additional control the query behavior, such as the number of hops and whether to perform a reverse DNS lookup for the addresses. The field is required and represents the destination.\n\nRun the command without any options to perform a simple trace from destination to host:\n\nThe output shows the hop number, IP address or resolved hostname, and the round-trip time (RTT) for each hop.\n\nThe host command is a simple tool for performing DNS lookups. The command resolves IP addresses into domain names and vice versa.\n\nUse the command to perform a query for DNS records and basic DNS troubleshooting.\n\nThe syntax for the command is:\n\nThe various control the command's behavior, such as the query type or the start of authority (SOA) for the provided domain.\n\nTo perform a simple DNS lookup, use the command and provide a hostname or IP address. For example:\n\nThe output shows the resolved IPv4 and IPv6 addresses for the provided hostname.\n\nThe hostname command helps display and change a system's hostname and domain and identifies devices within a network environment.\n\nUse the command to display, change, or search for hostnames.\n\nThe syntax for the command is:\n\nThe parameter control what the command displays, while the parameter temporarily sets the hostname to the provided name.\n\nTo temporarily change the system hostname, run the command without any options and provide a name:\n\nThe command does not produce an output. Check the current hostname by running:\n\nThe current hostname prints to the screen.\n\nThe ping command is a network utility for testing whether a host is reachable. The command sends ICMP requests to a host (a computer or server) and measures the round-trip time (RTT).\n\nPinging helps determine the network latency between two nodes and whether a network is reachable.\n\nThe syntax for the command is:\n\nState the of the host to ping. Add options to control the command's behavior, such as the ping request number, intervals, or packet size.\n\nAn example command request looks like the following:\n\nThe command sends five ICMP packets to the provided host and prints the statistics.\n\nThe ss command is a CLI tool for displaying network statistics. The tool is part of the package and is a faster alternative to the command.\n\nUse the command to examine network sockets and view various network-related data.\n\nThe basic syntax for the command is:\n\nThe parameter allows filtering sockets by protocol, while the parameter helps queue sockets by state to narrow down the result view.\n\nFor example, to show all listening TCP sockets using the command, add the options:\n\nThe output shows all TCP sockets in the state waiting for incoming connections.\n\nThe command in Linux is a specialized command for displaying and configuring the routing table. The command modifies the kernel's IP routing tables and helps set up static routes to specific hosts or networks.\n\nUse the command after configuring a network interface with a tool such as the command.\n\nThe syntax for the command is:\n\nIt contains the following components:\n• - Optional command-line parameters that control the output view, address family, and IP protocol.\n• - An action to perform, such as or .\n• - Additional arguments that differ depending on the subcommand.\n\nTo view the current routing table, use the command without any options:\n\nUse the following format to add a default gateway:\n\nThe command adds a default route, which is used when no other routes match. The provided gateway must be a directly reachable route.\n\nThe command shows and configures the Address Resolution Protocol (ARP) cache. The ARP protocol maps IP addresses to physical Media Access Control (MAC) addresses in a local network. The cache stores these mappings for all devices on the local network.\n\nThe syntax for the command is in the following format:\n• The parameter modifies the command's behavior, such as setting up and deleting actions, or controlling the output.\n• The parameter is an optional identifier for a remote system for which to resolve a MAC address. If unprovided, the command checks the local ARP cache.\n\nTo display the ARP cache, run the command without any additional parameters:\n\nThe output shows the ARP cache (IP and MAC addresses) in a table.\n\nThe command shows and configures wireless network interface information. The command comes in handy for troubleshooting wireless network issues.\n\nUse the command to view or change a wireless network's name, power management settings, and other wireless configurations.\n\nThe syntax for the command is:\n\nThe parameter filters the wireless network interface by name, whereas the parameter controls various settings, such as the operation mode, rate limits, and the wireless encryption key.\n\nTo view the available wireless interfaces on the system and the current setup, run the command without any parameters:\n\nThe command shows all information on wireless interfaces on the system.\n\nThe and commands are command-line tools for downloading files from the internet. The two tools are similar, but there are slight differences in how they work and the options they offer:\n• The wget command downloads files from the web using HTTP, HTTPS, or FTP protocols. The tool is simple to use for file downloads.\n• The curl command is versatile and supports various network protocols, such as SCP, IMAP POP3, SMTP, etc. The tool also sends HTTP requests and interacts with web services.\n\nUse or to test network download speeds.\n\nThe syntaxes for the and commands are similar:\n\nThe parameter controls the various download and output options, while the parameter is a file's download URL. The command features many advanced options and usage patterns compared to the command.\n\nTo download a file using the command, use the following format:\n\nAlternatively, to use to achieve the same task, run:\n\nThe file downloads from the specified URL and saves the contents to the provided file name.\n\nThe command (my traceroute) is a diagnostics tool that combines elements from the and commands. The command sends real-time insights into network quality, making it an excellent tool for troubleshooting high latency and packet loss.\n\nThe syntax for the command is:\n\nThe parameter controls the packet number and size, while the parameter contains the destination.\n\nThe command, without any parameters, starts a trace session to the provided host. For example:\n\nThe command queries information about domain names, IP addresses, and other network-related information. Use the command to fetch domain ownership details, such as the domain's ownership details, registration date, and expiration date.\n\nThe syntax for the command is:\n• The parameter allows setting a specific WHOIS server to query, changing the protocol, and adding additional query parameters.\n• The parameter is the domain name, IP address, or Autonomous System Number (ASN) to look up.\n\nRun the command without any options to perform a simple query for a given domain name. For example:\n\nThe output shows the results of the basic WHOIS lookup for the provided domain name.\n\nThe command is a network monitoring utility. Use the command to view network connections and bandwidth usage in real time.\n\nThe syntax for the command is:\n\nThe parameter controls the display information. The command also requires sufficient privileges to monitor all traffic on the network interface.\n\nThe primary usage of is without any additional options:\n\nThe command opens a new monitoring screen, which changes as data transfers via the network interface.\n\nThe interface allows controlling the display from the monitoring screen, such as toggling the source (s) or destination (d) views. To exit the screen, press q.\n\nThe command is a packet sniffer and network security tool that captures real-time network packet information. Use the command to analyze traffic, troubleshoot issues, and monitor network security.\n\nThe syntax for the command is:\n\nThe parameter handles various display options, controls the packet number, and enables working with files. Use the [filter] parameter to enter the criteria for packet capturing.\n\nTo capture packets on a specific port, use the following format:\n\nThe filter captures packets on the specified port to monitor HTTP traffic.\n\nThe command is a simple utility to check the network interface status. The command helps determine whether an ethernet cable is connected to an interface.\n\nUse to check a network's physical link, especially after changes to the network interface.\n\nThe syntax for the command is:\n\nThe parameter allows setting a specific configuration file or running in batch mode for scripting. State the parameter to check the status of the specified interface.\n\nTo list the status for all network interfaces, run the command without any parameters:\n\nIf the output states link beat detected, the interface has an active physical link.\n\nWe've created a handy cheat sheet for Linux networking commands, which features all the commands from this guide. Use the cheat sheet as a reference when working on networking tasks.\n\nClick the button below to download the free Linux Networking Commands Cheat Sheet PDF!\n\nAfter reading this guide, you know the essential Linux networking commands. Refer to this article when you need a specific command, or keep the free PDF cheat sheet at hand.\n\nCheck out our ultimate Linux Commands Cheat Sheet if you want additional cheat sheets!"
    },
    {
        "link": "https://theurbanpenguin.com/understand-your-network-more-effectively-with-tcpdump",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/tcpdump-command-in-linux-with-examples",
        "document": "tcpdump is a packet sniffing and packet analyzing tool for a System Administrator to troubleshoot connectivity issues in Linux. It is used to capture, filter, and analyze network traffic such as TCP/IP packets going through your system. It is many times used as a security tool as well. It saves the captured information in a pcap file, these pcap files can then be opened through Wireshark or through the command tool itself.\n\nMany Operating Systems have tcpdump command pre-installed but to install it, use the following commands. For RedHat based linux OS\n\n1. To capture the packets of current network interface\n\nThis will capture the packets from the current interface of the network through which the system is connected to the internet. 2. To capture packets from a specific network interface\n\nThis command will now capture the packets from wlo1 network interface. 3. To capture specific number of packets\n\nThis command will capture only 4 packets from the wlo1 interface. 4. To print captured packets in ASCII format\n\nThis command will now print the captured packets from wlo1 to ASCII value. 5. To display all available interfaces\n\nThis command will display all the interfaces that are available in the system. 6. To display packets in HEX and ASCII values\n\nThis command will now print the packets captured from the wlo1 interface in the HEX and ASCII values. 7. To save captured packets into a file\n\nThis command will now output all the captures packets in a file named as captured_packets.pcap. 8. To read captured packets from a file\n\nThis command will now read the captured packets from the captured_packets.pcap file. 9. To capture packets with ip address\n\nThis command will now capture the packets with IP addresses. 10. To capture only TCP packets\n\nThis command will now capture only TCP packets from wlo1.\n\nWhat is tcpdump and how is it used?\n\nHow to capture packets with tcpdump?\n\nTo capture packets with , you can run the command without any options to capture all packets on the default network interface: However, capturing all traffic can generate an overwhelming amount of data, so it’s common to specify an interface with the option: This command starts capturing all packets on the interface. Replace with the appropriate interface as per your system configuration. You might need to use to list all available interfaces.\n\nHow to filter packets using tcpdump?\n\nHow to save tcpdump output to a file?\n\nWhat are some common options for tcpdump?"
    }
]