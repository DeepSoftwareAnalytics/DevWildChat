[
    {
        "link": "https://stackoverflow.com/questions/21657544/finding-common-characters-in-two-strings",
        "document": "Their is a more better version in c++ : C++ bitset and its application A bitset is an array of bool but each Boolean value is not stored separately instead bitset optimizes the space such that each bool takes 1 bit space only, so space taken by bitset bs is less than that of bool bs[N] and vector bs(N). However, a limitation of bitset is, N must be known at compile time, i.e., a constant (this limitation is not there with vector and dynamic array)\n\nAs bitset stores the same information in compressed manner the operation on bitset are faster than that of array and vector. We can access each bit of bitset individually with help of array indexing operator [] that is bs[3] shows bit at index 3 of bitset bs just like a simple array. Remember bitset starts its indexing backward that is for 10110, 0 are at 0th and 3rd indices whereas 1 are at 1st 2nd and 4th indices. We can construct a bitset using integer number as well as binary string via constructors which is shown in below code. The size of bitset is fixed at compile time that is, it can’t be changed at runtime. For more information about bitset visit the site : https://www.geeksforgeeks.org/c-bitset-and-its-application\n\nThe code is as follows :"
    },
    {
        "link": "https://stackoverflow.com/questions/57049206/how-to-find-the-number-of-common-characters-in-two-strings-c",
        "document": "If string 1 and string 2 are equal sizes, how would we find the num of common characters and store into some int?\n\nThe common number of characters is 6 out of 7 (count duplicates).\n\nso far I have:\n\nbut when I output count its = 0.\n\nEDIT: got it to work guys, something was wrong with my initialized string but now its fine! Thanks."
    },
    {
        "link": "https://geeksforgeeks.org/check-if-there-is-any-common-character-in-two-given-strings",
        "document": "Check if there is any common character in two given strings\n\nGiven two strings. The task is to check that is there any common character in between two strings.\n\nApproach: Traverse the 1st string and map the characters of the string with its frequency, in this map characters act as a key and the frequency its value. Then traverse the second string and we will check if there is any character that is present in both the string then it is confirmed that there is a common sub-sequence.\n\nBelow is the implementation of above approach:\n\nTime Complexity: O(n) where n is the length of the string.\n\nAuxiliary Space: O(n) where n is the length of the string.\n\nConvert str1 and str2 into sets of characters using the set() function.\n\nFind the intersection of the two sets using the intersection() method, which returns a new set containing only the elements that are common to both sets.\n\nCheck if the resulting set common has at least one element using the len() function.\n\nIf the length of common is greater than 0, return True, indicating that there is at least one common character between str1 and str2.\n\nIf the length of common is 0, return False, indicating that there are no common characters between str1 and str2.\n\nThe time complexity of the set() function used to convert each input string into a set of characters is O(n), where n is the length of the input string.\n\nThe time complexity of the intersection() method used to find the common characters between the two sets is O(min(m, n)), where m and n are the sizes of the input sets.\n\nThe len() function used to check the size of the resulting set has a time complexity of O(1).\n\nOverall, the time complexity of the function is O(n+m), where n and m are the lengths of the input strings.\n\nSpace complexity:\n\nThe space complexity of the function is O(n+m), where n and m are the lengths of the input strings. This is because the function creates two sets, each of which stores up to n and m characters, respectively."
    },
    {
        "link": "https://geeksforgeeks.org/common-characters-n-strings",
        "document": "Given n strings, find the common characters in all the strings. In simple words, find characters that appear in all the strings and display them in alphabetical order or lexicographical order.\n\nNote* we’ll be considering that the strings contain lower case letters only.\n\nWe’ll use two hash arrays of size 26 (for a-z, where 0 is a, and z is 25). \n\nThe approach will be simple, if we have seen a character before we’ll mark it and if we haven’t then ignore the character because it is not a common one."
    },
    {
        "link": "https://medium.com/@alex.omegapy/common-string-manipulation-errors-in-c-and-how-to-avoid-them-e9da3e822305",
        "document": "In software development, working with strings is notoriously error-prone and can generate security vulnerabilities, especially in C++. C++ is a flexible programming language that allows manual memory management and when combined with the primitive nature of strings, it is very easy for developers to accidentally introduce errors and dangerous vulnerabilities when manipulating strings.\n\nBelow is a list of common string-manipulating errors:\n\nOne of the most common errors leading to significant security vulnerabilities. This happened usually when copying data to a buffer that is not large enough to hold that data (Ballman, 2016), especially when functions such as ‘strcpy()’, which does not check the length of the destination when coping an array of characters. A solution is to use functions like ‘strncpy()’, which limit the number of characters copied; however using ‘sdt::string’ is often a better solution as it is dynamic length, meaning is not a bounded array and it is no need to manage the null terminators ‘\\0’.\n\nMaking sure that a destination string buffer is compliant with the length of the string stored is compliant with the SEI CERT C++ CODING STANDARD STR50-CPP “Guarantee that storage for strings has sufficient space for character data and the null terminator” (SEI External WIKI, n.d., STR50-CPP).\n\nSee the code examples below:\n\nWhen C-style strings are used ‘char[ ]’ not allocating the null-terminator ‘\\0’ at the end of the character array may result in undefined behavior and memory corruption, as well as creating vulgarities. Without a null terminator, functions may read out-of-bounds memory and can be exploited for nefarious purposes. Thus, always add ‘\\0’, if the string is 9 characters long the character array should have a length of 10 to accommodate ‘\\0’ at the end of it.\n\nThis is part of STR50-CPP.\n\nSee the code examples below:\n\nWhen C-style strings are used ‘char[]’, always limits the input size, that is when using ‘std::cin’ to the length of the character array receiving the inputs to the length of the array — 1 (to accommodate ‘\\0’). Failing to do so may cause data overflows.\n\nSee the code examples below:\n\nDo not create a ‘std::string’ from a null pointer, for example, using ‘std::getenv()’, that is getting an environment variable without checking if the variable exists, this may result in a null pointer if the environment variable does not exists. Allocating the value of a null pointer to a ‘std::string’ may lead to undefined behavior and dereferencing a null pointer, that is trying to access an invalid memory address.\n\nMaking sure that a ‘std::string’ is not created from a null pointer is compliant with the SEI CERT C++ CODING STANDARD STR51-CPP “Do not attempt to create a std::string from a null pointer” (SEI External WIKI, n.d., STR51-CPP).\n\nSee the code examples below:\n\nMaking sure that a string iterator is still valid after modifying a string is crucial as it can result in the iterator not reflecting changes to the string properly. This often occurs when using the ‘insert()’ or ‘replace()’ methods. Thus, revalidating the iterator by relocating the value of the string after each string modification is essential.\n\nMaking sure that the string iterator is still valid after modifying a string is compliant with the SEI CERT C++ CODING STANDARD STR52-CPP “Use valid references, pointers, and iterators to reference elements of a basic_string” (SEI External WIKI, n.d., STR52-CPP).\n\nSee the code examples below\n\nDo not access elements outside the valid range of a string, this often occurs when using functions like ‘front()’ and ‘back()’, this can lead to undefined behavior. Thus, always perform range checks before trying to access an element, or use safer functions like ‘at()’ that throw exceptions on out-of-range access.\n\nNot accessing elements outside the valid range of a string is compliant with the SEI CERT C++ CODING STANDARD STR53-CPP “Range check element access” (SEI External WIKI, n.d., STR53-CPP).\n\nSee the code examples below:\n\nThe table below shows a summary of the risk assessment of the C++ string-related coding rules from the SEI CERT C++ Coding Standard.\n\nNote: From “Rule 05. Characters and Strings (STR). SEI CERT C++ Coding Standard” by SEI External WIKI. (n.d.)\n• Rule(s) are the rules from rules from the SEI CERT C++ Coding Standard.\n• Severity refers to the potential impact on security.\n• Likelihood refers to how likely it is that violating the rule will result in a security vulnerability.\n• Remediation Cost refers to the amount of effort needed to fix the violation.\n• Priority (P) refers to the priority level at which a violation should be addressed, the lower the numbers the higher the priority.\n• Level refers to the level of enforcement, that is how strictly the coding standard needs to be followed to not introduce vulnerabilities.\n\nTo summarize, working with strings is notoriously error-prone and may cause security vulnerabilities, especially in C++. C++ is a flexible programming language that allows manual memory management, which increases the risk of introducing errors and vulnerabilities. However, by following the SEI CERT C++ Coding Standards, C++ developers can generate secure and reliable code when manipulating strings."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/string/byte/strlen",
        "document": "Returns the length of the given byte string, that is, the number of characters in a character array whose first element is pointed to by str up to and not including the first null character. The behavior is undefined if there is no null character in the character array pointed to by str.\n\nThe length of the null-terminated string str."
    },
    {
        "link": "https://programiz.com/cpp-programming/library-function/cstring/strlen",
        "document": "The function in C++ returns the length of the given C-string. It is defined in the cstring header file. #include <iostream> #include <cstring> using namespace std; int main() { // initialize C-string char song[] = \"We Will Rock You!\"; // print the length of the song string cout << strlen(song); return 0; } // Output: 17\n\nThe syntax of the function is:\n\nHere, is the string whose length we need to find out, which is casted to a .\n\nThe function takes the following parameter:\n• str - pointer to the C-string (null-terminated string) whose length is to be calculated\n• the length of the C-string ( )\n\nThe prototype of as defined in the cstring header file is:\n\nNote: The returned length does not include the null character .\n\nThe behavior of is undefined if:\n• there is no null character in the string i.e. if it is not a C-string\n• C++ Program to Find the Length of a String"
    },
    {
        "link": "https://stackoverflow.com/questions/19107845/which-c-header-file-declares-strlen",
        "document": "Neither. and are not libraries, they are header files which define the interface to various functions and classes.\n\nThe C language standard says that the function is declared in the header file . In C++, including places into the global namespace, while including instead places into the namespace.\n\nThe actual implementation of the function is in the C standard library (aka or on certain platforms). Ordinarily, this is linked in with your executable at link time.\n\nIn your particular compiler and toolchain, it just so happens that the header file includes into it, which means that any code that includes the former also gets the latter for free. This is an implementation detail and should not be relied upon—if your compile your code with another compiler, you may suddenly find yourself in a sea of compiler errors.\n\nThe proper thing to do is to also include here; even though it's not necessary with your particular compiler, it may be necessary with other compilers."
    },
    {
        "link": "https://public.dhe.ibm.com/systems/power/docs/systemi/v6r1/en_US/sc094949.pdf",
        "document": ""
    },
    {
        "link": "https://cplusplus.com/reference/cstring/strlen",
        "document": ""
    }
]