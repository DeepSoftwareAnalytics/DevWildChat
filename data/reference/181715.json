[
    {
        "link": "https://stackoverflow.com/questions/4617034/how-can-i-open-multiple-files-using-with-open-in-python",
        "document": "As of Python 2.7 (or 3.1 respectively) you can write\n\nIn the rare case that you want to open a variable number of files all at the same time, you can use , starting from Python version 3.3:\n\nNote that more commonly you want to process files sequentially rather than opening all of them at the same time, in particular if you have a variable number of files:"
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-python",
        "document": "File handling refers to the process of performing operations on a file such as creating, opening, reading, writing and closing it, through a programming interface. It involves managing the data flow between the program and the file system on the storage device, ensuring that data is handled safely and efficiently.\n\nTo open a file we can use function, which requires file path and mode as arguments:\n\nWhen opening a file, we must specify the mode we want to which specifies what we want to do with the file. Here’s a table of the different modes available:\n\nOpens the file for reading. File must exist; otherwise, it raises an error. Opens the file for reading binary data. File must exist; otherwise, it raises an error. Opens the file for both reading and writing. File must exist; otherwise, it raises an error. Opens the file for both reading and writing binary data. File must exist; otherwise, it raises an error. Opens the file for writing. Creates a new file or truncates the existing file. Opens the file for writing binary data. Creates a new file or truncates the existing file. Opens the file for both writing and reading. Creates a new file or truncates the existing file. Opens the file for both writing and reading binary data. Creates a new file or truncates the existing file. Opens the file for appending data. Creates a new file if it doesn’t exist. Opens the file for appending binary data. Creates a new file if it doesn’t exist. Opens the file for appending and reading. Creates a new file if it doesn’t exist. Opens the file for appending and reading binary data. Creates a new file if it doesn’t exist. Creates a new file. Raises an error if the file already exists. Creates a new binary file. Raises an error if the file already exists. Creates a new file for reading and writing. Raises an error if the file exists. Exclusive creation with read and write in binary mode. Creates a new binary file for reading and writing. Raises an error if the file exists.\n\nFor this article we are using text file with text:\n\nReading a file can be achieved by file.read() which reads the entire content of the file. After reading the file we can close the file using file.close() which closes the file after reading it, which is necessary to free up system resources.\n\nWriting to a file is done using file.write() which writes the specified string to the file. If the file exists, its content is erased. If it doesn’t exist, a new file is created.\n\nExample: Writing to a File in Write Mode (w)\n\nIt is done using adds the specified string to the end of the file without erasing its existing content.\n\nExample: For this example, we will use the Python file created in the previous example.\n\nClosing a file is essential to ensure that all resources used by the file are properly released. loses the file and ensures that any changes made to the file are saved.\n\nstatement is used for resource management. It ensures that file is properly closed after its suite finishes, even if an exception is raised. with open() as method automatically handles closing the file once the block of code is exited, even if an error occurs. This reduces the risk of file corruption and resource leakage.\n\nIt’s important to handle exceptions to ensure that files are closed properly, even if an error occurs during file operations.\n• None Versatility : File handling in Python allows us to perform a wide range of operations, such as creating, reading, writing, appending, renaming and deleting files.\n• Flexibility : File handling in Python is highly flexible, as it allows us to work with different file types (e.g. text files, binary files, CSV files , etc.) and to perform different operations on files (e.g. read, write, append, etc.).\n• User – friendly : Python provides a user-friendly interface for file handling, making it easy to create, read and manipulate files.\n• Cross-platform : Python file-handling functions work across different platforms (e.g. Windows, Mac, Linux), allowing for seamless integration and compatibility.\n• Error-prone: File handling operations in Python can be prone to errors, especially if the code is not carefully written or if there are issues with the file system (e.g. file permissions, file locks, etc.).\n• Security risks : File handling in Python can also pose security risks, especially if the program accepts user input that can be used to access or modify sensitive files on the system.\n• Complexity : File handling in Python can be complex, especially when working with more advanced file formats or operations. Careful attention must be paid to the code to ensure that files are handled properly and securely.\n• Performance : File handling operations in Python can be slower than other programming languages, especially when dealing with large files or performing complex operations.\n\nWhat are the types of files in Python?\n\nWhat are the 4 file handling functions?\n\nWhy is file handling useful?\n\nIn Python file handling, is a method of file objects that returns the current position of the file pointer (cursor) within the file. It returns an integer representing the byte offset from the beginning of the file where the next read or write operation will occur. # Open a file in read mode file = open('example.txt', 'r') # Read the first 10 characters content = file.read(10) print(content) # Check the current position of the file pointer position = file.tell() print(\"Current position:\", position) # Close the file file.close()\n• None reads the first 10 characters from the file.\n• None returns the current position of the file pointer after reading."
    },
    {
        "link": "https://w3schools.com/python/python_file_handling.asp",
        "document": "File handling is an important part of any web application.\n\nPython has several functions for creating, reading, updating, and deleting files.\n\nThe key function for working with files in Python is the function.\n\nThe function takes two parameters; filename, and mode.\n\nThere are four different methods (modes) for opening a file:\n\n- Read - Default value. Opens a file for reading, error if the file does not exist - Append - Opens a file for appending, creates the file if it does not exist - Write - Opens a file for writing, creates the file if it does not exist - Create - Creates the specified file, returns an error if the file exists\n\nIn addition you can specify if the file should be handled as binary or text mode\n\nTo open a file for reading it is enough to specify the name of the file:\n\nThe code above is the same as:\n\nBecause for read, and for text are the default values, you do not need to specify them.\n\nNote: Make sure the file exists, or else you will get an error."
    },
    {
        "link": "https://freecodecamp.org/news/python-write-to-file-open-read-append-and-other-file-handling-functions-explained",
        "document": "Hi! If you want to learn how to work with files in Python, then this article is for you. Working with files is an important skill that every Python developer should learn, so let's get started.\n\nIn this article, you will learn:\n• How to open files for multiple operations.\n• How to work with file object methods.\n• How to work with context managers and why they are useful.\n• How to handle exceptions that could be raised when you work with files.\n\nOne of the most important functions that you will need to use as you work with files in Python is , a built-in function that opens a file and allows your program to use it and work with it.\n\nThis is the basic syntax:\n\n💡 Tip: These are the two most commonly used arguments to call this function. There are six additional optional arguments. To learn more about them, please read this article in the documentation.\n\nThe first parameter of the function is , the absolute or relative path to the file that you are trying to work with.\n\nWe usually use a relative path, which indicates where the file is located relative to the location of the script (Python file) that is calling the function.\n\nFor example, the path in this function call:\n\nOnly contains the name of the file. This can be used when the file that you are trying to open is in the same directory or folder as the Python script, like this:\n\nBut if the file is within a nested folder, like this:\n\nThe names.txt file is in the \"data\" folder\n\nThen we need to use a specific path to tell the function that the file is within another folder.\n\nIn this example, this would be the path:\n\nNotice that we are writing first (the name of the folder followed by a ) and then (the name of the file with the extension).\n\n💡 Tip: The three letters that follow the dot in is the \"extension\" of the file, or its type. In this case, indicates that it's a text file.\n\nThe second parameter of the function is the , a string with one character. That single character basically tells Python what you are planning to do with the file in your program.\n\nYou can also choose to open the file in:\n\nTo use text or binary mode, you would need to add these characters to the main mode. For example: means writing in binary mode.\n\n💡 Tip: The default modes are read ( ) and text ( ), which means \"open for reading text\" ( ), so you don't need to specify them in if you want to use them because they are assigned by default. You can simply write .\n\nIt really makes sense for Python to grant only certain permissions based what you are planning to do with the file, right? Why should Python allow your program to do more than necessary? This is basically why modes exist.\n\nThink about it — allowing a program to do more than necessary can problematic. For example, if you only need to read the content of a file, it can be dangerous to allow your program to modify it unexpectedly, which could potentially introduce bugs.\n\nNow that you know more about the arguments that the function takes, let's see how you can open a file and store it in a variable to use it in your program.\n\nThis is the basic syntax:\n\nWe are simply assigning the value returned to a variable. For example:\n\nI know you might be asking: what type of value is returned by ?\n\nLet's talk a little bit about them.\n\nAccording to the Python Documentation, a file object is:\n\nThis is basically telling us that a file object is an object that lets us work and interact with existing files in our Python program.\n\nFile objects have attributes, such as:\n• name: the name of the file.\n• closed: if the file is closed. otherwise.\n• mode: the mode used to open the file.\n\nNow let's see how you can access the content of a file through a file object.\n\nFor us to be able to work file objects, we need to have a way to \"interact\" with them in our program and that is exactly what methods do. Let's see some of them.\n\nThe first method that you need to learn about is , which returns the entire content of the file as a string.\n\nHere we have an example:\n\nYou can use the function to confirm that the value returned by is a string:\n\nIn this case, the entire file was printed because we did not specify a maximum number of bytes, but we can do this as well.\n\nHere we have an example:\n\nThe value returned is limited to this number of bytes:\n\n❗️Important: You need to close a file after the task has been completed to free the resources associated to the file. To do this, you need to call the method, like this:\n\nYou can read a file line by line with these two methods. They are slightly different, so let's see them in detail.\n\nreads one line of the file until it reaches the end of that line. A trailing newline character ( ) is kept in the string.\n\n💡 Tip: Optionally, you can pass the size, the maximum number of characters that you want to include in the resulting string.\n\nThis is the first line of the file.\n\nIn contrast, returns a list with all the lines of the file as individual elements (strings). This is the syntax:\n\nNotice that there is a (newline character) at the end of each string, except the last one.\n\n💡 Tip: You can get the same list with .\n\nYou can work with this list in your program by assigning it to a variable or using it in a loop:\n\nWe can also iterate over directly (the file object) in a loop:\n\nThose are the main methods used to read file objects. Now let's see how you can create files.\n\nIf you need to create a file \"dynamically\" using Python, you can do it with the mode.\n\nLet's see how. This is the basic syntax:\n\nHere's an example. This is my current working directory:\n\nIf I run this line of code:\n\nA new file with that name is created:\n\nWith this mode, you can create a file and then write to it dynamically using methods that you will learn in just a few moments.\n\n💡 Tip: The file will be initially empty until you modify it.\n\nA curious thing is that if you try to run this line again and a file with that name already exists, you will see this error:\n\nAccording to the Python Documentation, this exception (runtime error) is:\n\nNow that you know how to create a file, let's see how you can modify it.\n\nTo modify (write to) a file, you need to use the method. You have two ways to do it (append or write) based on the mode that you choose to open it with. Let's see them in detail.\n\n\"Appending\" means adding something to the end of another thing. The mode allows you to open a file to append some content to it.\n\nFor example, if we have this file:\n\nAnd we want to add a new line to it, we can open it using the mode (append) and then, call the method, passing the content that we want to append as argument.\n\nThis is the basic syntax to call the method:\n\n💡 Tip: Notice that I'm adding before the line to indicate that I want the new line to appear as a separate line, not as a continuation of the existing line.\n\nThis is the file now, after running the script:\n\n💡 Tip: The new line might not be displayed in the file until runs.\n\nSometimes, you may want to delete the content of a file and replace it entirely with new content. You can do this with the method if you open the file with the mode.\n\nHere we have this text file:\n\nThis is the result:\n\nAs you can see, opening a file with the mode and then writing to it replaces the existing content.\n\n💡 Tip: The method returns the number of characters written.\n\nIf you want to write several lines at once, you can use the method, which takes a list of strings. Each string represents a line to be added to the file.\n\nHere's an example. This is the initial file:\n\nIf we run this script:\n\nThe lines are added to the end of the file:\n\nNow you know how to create, read, and write to a file, but what if you want to do more than one thing in the same program? Let's see what happens if we try to do this with the modes that you have learned so far:\n\nIf you open a file in mode (read), and then try to write to it:\n\nYou will get this error:\n\nSimilarly, if you open a file in mode (write), and then try to read it:\n\nYou will see this error:\n\nThe same will occur with the (append) mode.\n\nHow can we solve this? To be able to read a file and perform another operation in the same program, you need to add the symbol to the mode, like this:\n\nVery useful, right? This is probably what you will use in your programs, but be sure to include only the modes that you need to avoid potential bugs.\n\nSometimes files are no longer needed. Let's see how you can delete files using Python.\n\nTo remove a file using Python, you need to import a module called which contains functions that interact with your operating system.\n\n💡 Tip: A module is a Python file with related variables, functions, and classes.\n\nParticularly, you need the function. This function takes the path to the file as argument and deletes the file automatically.\n\nLet's see an example. We want to remove the file called .\n\nTo do it, we write this code:\n• The first line: is called an \"import statement\". This statement is written at the top of your file and it gives you access to the functions defined in the module.\n• The second line: removes the file specified.\n\n💡 Tip: you can use an absolute or a relative path.\n\nNow that you know how to delete files, let's see an interesting tool... Context Managers!\n\nContext Managers are Python constructs that will make your life much easier. By using them, you don't need to remember to close a file at the end of your program and you have access to the file in the particular part of the program that you choose.\n\nThis is an example of a context manager used to work with files:\n\n💡 Tip: The body of the context manager has to be indented, just like we indent loops, functions, and classes. If the code is not indented, it will not be considered part of the context manager.\n\nWhen the body of the context manager has been completed, the file closes automatically.\n\nThis context manager opens the file for read/write operations and assigns that file object to the variable . This variable is used in the body of the context manager to refer to the file object.\n\nTrying to Read it Again\n\nAfter the body has been completed, the file is automatically closed, so it can't be read without opening it again. But wait! We have a line that tries to read it again, right here below:\n\nLet's see what happens:\n\nThis error is thrown because we are trying to read a closed file. Awesome, right? The context manager does all the heavy work for us, it is readable, and concise.\n\n🔹 How to Handle Exceptions When Working With Files\n\nWhen you're working with files, errors can occur. Sometimes you may not have the necessary permissions to modify or access a file, or a file might not even exist.\n\nAs a programmer, you need to foresee these circumstances and handle them in your program to avoid sudden crashes that could definitely affect the user experience.\n\nLet's see some of the most common exceptions (runtime errors) that you might find when you work with files:\n\nAccording to the Python Documentation, this exception is:\n\nFor example, if the file that you're trying to open doesn't exist in your current working directory:\n\nYou will see this error:\n\nLet's break this error down this line by line:\n• . This line tells you that the error was raised when the code on the file located in was running. Specifically, when was executed in .\n• . This is the line that caused the error.\n• None FileNotFoundError: [Errno 2] No such file or directory: 'names.txt' . This line says that a exception was raised because the file or directory doesn't exist.\n\n💡 Tip: Python is very descriptive with the error messages, right? This is a huge advantage during the process of debugging.\n\nThis is another common exception when working with files. According to the Python Documentation, this exception is:\n\nThis exception is raised when you are trying to read or modify a file that don't have permission to access. If you try to do so, you will see this error:\n\nAccording to the Python Documentation, this exception is:\n\nThis particular exception is raised when you try to open or work on a directory instead of a file, so be really careful with the path that you pass as argument.\n\nTo handle these exceptions, you can use a try/except statement. With this statement, you can \"tell\" your program what to do in case something unexpected happens.\n\nThis is the basic syntax:\n\nHere you can see an example with :\n• Try to open the file .\n• If a is thrown, don't crash! Simply print a descriptive statement for the user.\n\n💡 Tip: You can choose how to handle the situation by writing the appropriate code in the block. Perhaps you could create a new file if it doesn't exist already.\n\nTo close the file automatically after the task (regardless of whether an exception was raised or not in the block) you can add the block.\n\nThis is an example:\n\nThere are many ways to customize the try/except/finally statement and you can even add an block to run a block of code only if no exceptions were raised in the block.\n\n💡 Tip: To learn more about exception handling in Python, you may like to read my article: \"How to Handle Exceptions in Python: A Detailed Visual Introduction\".\n• You can create, read, write, and delete files using Python.\n• File objects have their own set of methods that you can use to work with them in your program.\n• Context Managers help you work with files and manage them by closing them automatically when a task has been completed.\n• Exception handling is key in Python. Common exceptions when you are working with files include , and . They can be handled using try/except/else/finally.\n\nI really hope you liked my article and found it helpful. Now you can work with files in your Python projects. Check out my online courses. Follow me on Twitter. ⭐️"
    },
    {
        "link": "https://docs.python.org/3/library/filesys.html",
        "document": "The modules described in this chapter deal with disk files and directories. For example, there are modules for reading the properties of files, manipulating paths in a portable way, and creating temporary files. The full list of modules in this chapter is:\n\nOperating system interfaces, including functions to work with files at a lower level than Python file objects. Python’s built-in I/O library, including both abstract classes and some concrete classes such as file I/O. The standard way to open files for reading and writing with Python."
    },
    {
        "link": "https://realpython.com/python-with-statement",
        "document": "The statement in Python is a quite useful tool for properly managing external resources in your programs. It allows you to take advantage of existing context managers to automatically handle the setup and teardown phases whenever you’re dealing with external resources or with operations that require those phases.\n\nBesides, the context management protocol allows you to create your own context managers so you can customize the way you deal with system resources. So, what’s the statement good for?\n• What the Python statement is for and how to use it\n• What the context management protocol is\n• How to implement your own context managers\n\nWith this knowledge, you’ll write more expressive code and avoid resource leaks in your programs. The statement helps you implement some common resource management patterns by abstracting their functionality and allowing them to be factored out and reused.\n\nOne common problem you’ll face in programming is how to properly manage external resources, such as files, locks, and network connections. Sometimes, a program will retain those resources forever, even if you no longer need them. This kind of issue is called a memory leak because the available memory gets reduced every time you create and open a new instance of a given resource without closing an existing one. Managing resources properly is often a tricky problem. It requires both a setup phase and a teardown phase. The latter phase requires you to perform some cleanup actions, such as closing a file, releasing a lock, or closing a network connection. If you forget to perform these cleanup actions, then your application keeps the resource alive. This might compromise valuable system resources, such as memory and network bandwidth. For example, a common problem that can arise when developers are working with databases is when a program keeps creating new connections without releasing or reusing them. In that case, the database back end can stop accepting new connections. This might require an admin to log in and manually kill those stale connections to make the database usable again. Another frequent issue shows up when developers are working with files. Writing text to files is usually a buffered operation. This means that calling on a file won’t immediately result in writing text to the physical file but to a temporary buffer. Sometimes, when the buffer isn’t full and developers forget to call , part of the data can be lost forever. Another possibility is that your application runs into errors or exceptions that cause the control flow to bypass the code responsible for releasing the resource at hand. Here’s an example in which you use to write some text to a file: This implementation doesn’t guarantee the file will be closed if an exception occurs during the call. In this case, the code will never call , and therefore your program might leak a file descriptor. In Python, you can use two general approaches to deal with resource management. You can wrap your code in: The first approach is quite general and allows you to provide setup and teardown code to manage any kind of resource. However, it’s a little bit verbose. Also, what if you forget any cleanup actions? The second approach provides a straightforward way to provide and reuse setup and teardown code. In this case, you’ll have the limitation that the statement only works with context managers. In the next two sections, you’ll learn how to use both approaches in your code. Working with files is probably the most common example of resource management in programming. In Python, you can use a … statement to handle opening and closing files properly: # Make sure to close the file after using it In this example, you need to safely open the file , which you can do by wrapping the call to in a … statement. Later, when you try to write to , the clause will guarantee that is properly closed, even if an exception occurs during the call to in the clause. You can use this pattern to handle setup and teardown logic when you’re managing external resources in Python. The block in the above example can potentially raise exceptions, such as or . You can handle those exceptions in an clause like this: \"An error occurred while writing to the file: # Make sure to close the file after using it In this example, you catch any potential exceptions that can occur while writing to the file. In real-life situations, you should use a specific exception type instead of the general to prevent unknown errors from passing silently. The Python statement creates a runtime context that allows you to run a group of statements under the control of a context manager. PEP 343 added the statement to make it possible to factor out standard use cases of the … statement. Compared to traditional … constructs, the statement can make your code clearer, safer, and reusable. Many classes in the standard library support the statement. A classic example of this is , which allows you to work with file objects using . To write a statement, you need to use the following general syntax: The context manager object results from evaluating the after . In other words, must return an object that implements the context management protocol. This protocol consists of two special methods:\n• is called by the statement to enter the runtime context.\n• is called when the execution leaves the code block. The specifier is optional. If you provide a with , then the return value of calling on the context manager object is bound to that variable. Note: Some context managers return from because they have no useful object to give back to the caller. In these cases, specifying a makes no sense. Here’s how the statement proceeds when Python runs into it:\n• Store the context manager’s and methods for later use.\n• Call on the context manager and bind its return value to if provided.\n• Call on the context manager when the code block finishes. In this case, , typically provides the setup code. The statement is a compound statement that starts a code block, like a conditional statement or a loop. Inside this code block, you can run several statements. Typically, you use the code block to manipulate if applicable. Once the code block finishes, gets called. This method typically provides the teardown logic or cleanup code, such as calling on an open file object. That’s why the statement is so useful. It makes properly acquiring and releasing resources a breeze. Here’s how to open your file for writing using the statement: When you run this statement, returns an object. This object is also a context manager, so the statement calls and assigns its return value to . Then you can manipulate the file inside the code block. When the block ends, automatically gets called and closes the file for you, even if an exception is raised inside the block. This construct is shorter than its … alternative, but it’s also less general, as you already saw. You can only use the statement with objects that support the context management protocol, whereas … allows you to perform cleanup actions for arbitrary objects without the need for supporting the context management protocol. In Python 3.1 and later, the statement supports multiple context managers. You can supply any number of context managers separated by commas: This works like nested statements but without nesting. This might be useful when you need to open two files at a time, the first for reading and the second for writing: In this example, you can add code for reading and transforming the content of . Then you write the final result to in the same code block. Using multiple context managers in a single has a drawback, though. If you use this feature, then you’ll probably break your line length limit. To work around this, you need to use backslashes ( ) for line continuation, so you might end up with an ugly final result. The statement can make the code that deals with system resources more readable, reusable, and concise, not to mention safer. It helps avoid bugs and leaks by making it almost impossible to forget cleaning up, closing, and releasing a resource after you’re done with it. Using allows you to abstract away most of the resource handling logic. Instead of having to write an explicit … statement with setup and teardown code each time, takes care of that for you and avoids repetition.\n\nAs long as Python developers have incorporated the statement into their coding practice, the tool has been shown to have several valuable use cases. More and more objects in the Python standard library now provide support for the context management protocol so you can use them in a statement. In this section, you’ll code some examples that show how to use the statement with several classes both in the standard library and in third-party libraries. So far, you’ve used to provide a context manager and manipulate files in a construct. Opening files using the statement is generally recommended because it ensures that open file descriptors are automatically closed after the flow of execution leaves the code block. As you saw before, the most common way to open a file using is through the built-in : In this case, since the context manager closes the file after leaving the code block, a common mistake might be the following: The first successfully writes into . Note that returns the number of bytes written into the file, . When you try to run a second , however, you get a because your is already closed. Another way to use the statement to open and manage files is by using : is a class that represents concrete paths to physical files in your computer. Calling on a object that points to a physical file opens it just like would do. So, works similarly to , but the file path is automatically provided by the object you call the method on. Since provides an elegant, straightforward, and Pythonic way to manipulate file system paths, you should consider using in your statements as a best practice in Python. Finally, whenever you load an external file, your program should check for possible issues, such as a missing file, writing and reading access, and so on. Here’s a general pattern that you should consider using when you’re working with files: In this example, you wrap the statement in a … statement. If an occurs during the execution of , then you use to log the error with a user-friendly and descriptive message. The module provides a function called , which returns an iterator over objects corresponding to the entries in a given directory. This function is specially designed to provide optimal performance when you’re traversing a directory structure. A call to with the path to a given directory as an argument returns an iterator that supports the context management protocol: In this example, you write a statement with as the context manager supplier. Then you iterate over the entries in the selected directory ( ) and print their name and size on the screen. In this case, calls to close the iterator and release the acquired resources. Note that if you run this on your machine, you’ll get a different output depending on the content of your current directory. Unlike built-in floating-point numbers, the module provides a way to adjust the precision to use in a given calculation that involves numbers. The precision defaults to places, but you can change it to meet your problem requirements. A quick way to perform calculations with a custom precision is using from : Here, provides a context manager that creates a local decimal context and allows you to perform calculations using a custom precision. In the code block, you need to set to the new precision you want to use, which is places in the example above. When the code block finishes, the precision is reset back to its default value, places. Another good example of using the statement effectively in the Python standard library is . This class provides a primitive lock to prevent multiple threads from modifying a shared resource at the same time in a multithreaded application. You can use a object as the context manager in a statement to automatically acquire and release a given lock. For example, say you need to protect the balance of a bank account: # Use the try ... finally pattern The statement in the second example automatically acquires and releases a lock when the flow of execution enters and leaves the statement. This way, you can focus on what really matters in your code and forget about those repetitive operations. In this example, the lock in the statement creates a protected region known as the critical section, which prevents concurrent access to the account balance. So far, you’ve coded a few examples using context managers that are available in the Python standard library. However, several third-party libraries include objects that support the context management protocol. Say you’re testing your code with pytest. Some of your functions and code blocks raise exceptions under certain situations, and you want to test those cases. To do that, you can use . This function allows you to assert that a code block or a function call raises a given exception. Since provides a context manager, you can use it in a statement like this: In the first example, you use to capture the that the expression raises. The second example uses the function to capture the that is raised when you access a key that doesn’t exist in a given dictionary. If your function or code block doesn’t raise the expected exception, then raises a failure exception: Another cool feature of is that you can specify a target variable to inspect the raised exception. For example, if you want to verify the error message, then you can do something like this: You can use all these features to capture the exceptions you raise from your functions and code block. This is a cool and useful tool that you can incorporate into your current testing strategy.\n\nTo implement the context management protocol and create class-based context managers, you need to add both the and the special methods to your classes. The table below summarizes how these methods work, the arguments they take, and the logic you can put in them: This method handles the setup logic and is called when entering a new context. Its return value is bound to the target variable. This method handles the teardown logic and is called when the flow of execution leaves the context. If an exception occurs, then , , and hold the exception type, value, and traceback information, respectively. When the statement executes, it calls on the context manager object to signal that you’re entering into a new runtime context. If you provide a target variable with the specifier, then the return value of is assigned to that variable. When the flow of execution leaves the context, is called. If no exception occurs in the code block, then the three last arguments to are set to . Otherwise, they hold the type, value, and traceback associated with the exception at hand. If the method returns , then any exception that occurs in the block is swallowed and the execution continues at the next statement after . If returns , then exceptions are propagated out of the context. This is also the default behavior when the method doesn’t return anything explicitly. You can take advantage of this feature to encapsulate exception handling inside the context manager. Here’s a sample class-based context manager that implements both methods, and . It also shows how Python calls them in a construct: implements both and . In , you first print a message to signal that the flow of execution is entering a new context. Then you return the string. In , you print a message to signal that the flow of execution is leaving the context. You also print the content of its three arguments. When the statement runs, Python creates a new instance of and calls its method. You know this because you get printed on the screen. Note: A common mistake when you’re using context managers is forgetting to call the object passed to the statement. In this case, the statement can’t get the required context manager, and you get an like this: The exception message doesn’t say too much, and you might feel confused in this kind of situation. So, make sure to call the object in the statement to provide the corresponding context manager. Then Python runs the code block, which prints to the screen. Note that holds the return value of . When the flow of execution exits the code block, Python calls . You know that because you get printed on your screen. The final line in the output confirms that the three arguments to are set to . Note: A common trick when you don’t remember the exact signature of and don’t need to access its arguments is to use and like in . Now, what happens if an exception occurs during the execution of the block? Go ahead and write the following statement: In this case, you try to retrieve the value at index in the string . This raises an , and the arguments to are set to the following: This behavior is quite useful when you want to encapsulate the exception handling in your context managers. As an example of encapsulating exception handling in a context manager, say you expect to be the most common exception when you’re working with . You might want to handle that exception in the context manager so you don’t have to repeat the exception-handling code in every code block. In that case, you can do something like this: \"An exception occurred in your with block: \"Continue normally from here...\" In , you check if is an instance of . If so, then you print a couple of informative messages and finally return with . Returning a truthy value makes it possible to swallow the exception and continue the normal execution after the code block. In this example, if no occurs, then the method returns and the exception propagates out. However, if you want to be more explicit, then you can return from outside the block. If you run from your command line, then you get the following output: python exc_handling.py An exception occurred in your with block: <class 'IndexError'> Continue normally from here... is now able to handle exceptions that occur in the code block. Since you return when an occurs, the flow of execution continues in the next line, right after exiting the code block. Now that you know how to implement the context management protocol, you can get a sense of what this would look like by coding a practical example. Here’s how you can take advantage of to create a context manager that opens files for writing: implements the context management protocol and supports the statement, just like the original does, but it always opens the file for writing using the mode. Here’s how you can use your new context manager: After running this code, your file contains the string. As an exercise, you can write a complementary context manager that opens files for reading, but using functionalities. Go ahead and give it a shot! A subtle detail to consider when you’re writing your own context managers is that sometimes you don’t have a useful object to return from and therefore to assign to the target variable. In those cases, you can return explicitly or you can just rely on Python’s implicit return value, which is as well. For example, say you need to temporarily redirect the standard output, , to a given file on your disk. To do this, you can create a context manager like this: This context manager takes a file object through its constructor. In , you reassign the standard output, , to an instance attribute to avoid losing the reference to it. Then you reassign the standard output to point to the file on your disk. In , you just restore the standard output to its original value. To use , you can do something like this: The outer statement in this example provides the file object that you’re going to use as your new output, . The inner temporarily redirects the standard output to , so the first call to writes directly to that file instead of printing on your screen. Note that when you leave the inner code block, the standard output goes back to its original value. is a quick example of a context manager that doesn’t have a useful value to return from . However, if you’re only redirecting the output, you can get the same functionality without the need for coding a context manager. You just need to provide a argument to like this: In this examples, takes your file as an argument. This causes to write directly into the physical file on your disk instead of printing to your screen. Just like every other class, a context manager can encapsulate some internal state. The following example shows how to create a stateful context manager to measure the execution time of a given code block or function: When you use in a statement, gets called. This method uses to get the time at the beginning of the code block and stores it in . It also initializes and returns a function that computes a time delta. In this case, holds the initial state or time measurement. Note: To take a deeper dive into how to time your code, check out Python Timer Functions: Three Ways to Monitor Your Code. Once the block ends, gets called. The method gets the time at the end of the block and updates the value of so that the function can compute the time required to run the code block. Here’s how you can use this context manager in your code: With , you can measure the execution time of any piece of code. In this example, holds an instance of the function that computes the time delta, so you need to call to get the final result.\n\nPython’s generator functions and the decorator provide an alternative and convenient way to implement the context management protocol. If you decorate an appropriately coded generator function with , then you get a function-based context manager that automatically provides both required methods, and . This can make your life more pleasant by saving you some boilerplate code. The general pattern to create a context manager using along with a generator function goes like this: In this example, you can identify two visible sections in . Before the statement, you have the setup section. There, you can place the code that acquires the managed resources. Everything before the runs when the flow of execution enters the context. After the statement, you have the teardown section, in which you can release the resources and do the cleanup. The code after runs at the end of the block. The statement itself provides the object that will be assigned to the target variable. This implementation and the one that uses the context management protocol are practically equivalent. Depending on which one you find more readable, you might prefer one over the other. A downside of the function-based implementation is that it requires an understanding of advanced Python topics, such as decorators and generators. The decorator reduces the boilerplate required to create a context manager. Instead of writing a whole class with and methods, you just need to implement a generator function with a single that produces whatever you want to return. You can use the to reimplement your context manager. Here’s what rewriting it with this technique looks like: In this case, is a generator function that opens for writing. Then it temporarily suspends its own execution and yields the resource so can bind it to its target variable. When the flow of execution leaves the code block, the function continues to execute and closes correctly. As a final example of how to create custom context managers with , say you’re testing a piece of code that works with time measurements. The code uses to get the current time measurement and do some further computations. Since time measurements vary, you decide to mock so you can test your code. Here’s a function-based context manager that can help you do that: Inside , you use a statement to signal that you’re going to modify the global name . Then you save the original function object in so you can safely restore it later. The next step is to monkey patch using a function that always returns the same value, . The bare statement specifies that this context manager doesn’t have a useful object to send back to the target variable for later use. After , you reset the global to its original content. When the execution enters the block, any calls to return . Once you leave the code block, calls to return the expected current time. That’s it! Now you can test your time-related code.\n\nContext managers are quite flexible, and if you use the statement creatively, then you can define convenient APIs for your classes, modules, and packages. For example, what if the resource you wanted to manage is the text indentation level in some kind of report generator application? In that case, you could write code like this: This almost reads like a domain-specific language (DSL) for indenting text. Also, notice how this code enters and leaves the same context manager multiple times to switch between different indentation levels. Running this code snippet leads to the following output and prints neatly formatted text: How would you implement a context manager to support this functionality? This could be a great exercise to wrap your head around how context managers work. So, before you check out the implementation below, you might take some time and try to solve this by yourself as a learning exercise. Ready? Here’s how you might implement this functionality using a context manager class: Here, increments by every time the flow of execution enters the context. The method also returns the current instance, . In , you decrease so the printed text steps back one indentation level every time you exit the context. The key point in this example is that returning from allows you to reuse the same context manager across several nested statements. This changes the text indentation level every time you enter and leave a given context. A good exercise for you at this point would be to write a function-based version of this context manager. Go ahead and give it a try!"
    },
    {
        "link": "https://geeksforgeeks.org/with-statement-in-python",
        "document": "The with statement in Python is used for resource management and exception handling. It simplifies working with resources like files, network connections and database connections by ensuring they are properly acquired and released. When we open a file, we need to close it ourself using close(). But if something goes wrong before closing, the file might stay open, causing issues. Using with open() automatically closes the file when we’re done, even if an error happens.\n\nExample 1 : Without with (Manual closing)\n\nExplanation: This code opens “example.txt” in read mode, reads its content, prints it and ensures the file is closed using a finally block.\n\nExplanation: with open(…) statement reads and prints the file’s content while automatically closing it, ensuring efficient resource management without a finally block.\n\nAdvantages of the with statement\n• Simplifies Resource Management : with statement ensures that resources are properly acquired and released, reducing the likelihood of resource leaks.\n• Replaces Try-Except-Finally Blocks: Traditionally, resource management required try-except-finally blocks to handle exceptions and ensure proper cleanup. The with statement provides a more concise alternative.\n• Enhances Readability: By reducing boilerplate code, the with statement improves code readability and maintainability.\n\nUsing the with statement for file handling\n\nFile handling is one of the most common use cases for the with statement. When opening files using open(), the with statement ensures that the file is closed automatically after operations are completed.\n\nExplanation: Opens example.txt in read mode (“r”) and with ensures automatic file closure after reading and file.read() reads the entire file content into contents.\n\nExplanation: The file is opened in write mode (“w”). After the with block, the file is automatically closed.\n\nWithout with, you need to explicitly manage resource closure:\n\nExample 1 : Without using with\n\nExplanation: This code opens example.txt in write mode (“w”), creating or clearing it. The try block writes “Hello, Python!” and finally ensures the file closes, preventing resource leaks.\n\nExample 2: using with\n\nExplanation: This code opens example.txt in write mode (“w”) using with, which ensures automatic file closure. It writes “Hello, Python!” to the file, replacing any existing content.\n\nContext Managers and the with statement\n\nThe with statement relies on context managers, which manage resource allocation and deallocation using two special methods:\n• None __enter__(): Acquires the resource and returns it.\n• None __exit__(): Releases the resource when the block exits\n• None __init__() initializes the filename and mode, __enter__() opens the file, and __exit__() ensures it closes automatically.\n• None with FileManager(‘file.txt’, ‘w’) as file: opens “file.txt” in write mode.\n• None file.write(‘Hello, World!’) writes to the file, which closes upon exiting the block.\n\nInstead of creating a full class, Python provides the contextlib module to create context managers using functions.\n• @contextmanager, where open_file() opens a file and yields it for use.\n• None Ensures automatic file closure with a finally block, even if an exception occurs.\n• None Writes “Hello, World!” to “file.txt” and the file closes automatically after the with block.\n\nOther Use Cases of with Statement\n\nThe with statement is not limited to file handling. It is widely used in managing database connections, for example:\n\nIf the users table does not exits:\n• cursor.execute(…) checks if the “users” table exists and cursor.fetchone() gets result None if table not found.\n\nWhat is the with Statement Used for in Python?\n\nHow Does the with Statement Manage Resources in Python?\n\nThe with statement simplifies resource management by abstracting away the setup and teardown processes associated with a resource. It uses context managers to handle the entry and exit points for resource management. When the with block is entered, the resource is acquired, and when the block is exited, the resource is released, even if an error occurs within the block. with open('example.txt', 'r') as file: content = file.read() # The file is automatically closed after the with block is exited.\n\nCan We Use Multiple Contexts in a Single with Statement in Python?\n\nWhat Are Context Managers in Python?\n\nContext managers are objects that define the runtime context to be established when executing a with statement. They implement two methods: __enter__() and __exit__(). The __enter__() method is executed at the start of the with block and the __exit__() method is executed at the end of the block. class MyContextManager: def __enter__(self): print(\"Entering the context\") return self def __exit__(self, exc_type, exc_value, traceback): print(\"Exiting the context\") with MyContextManager() as manager: print(\"Inside the context\") Entering the context Inside the context Exiting the context"
    },
    {
        "link": "https://learndatasci.com/solutions/python-context-managers",
        "document": "Context Managers in Python: Using the \"with\" statement\n\nContext managers are used to set up and tear down temporary contexts, establish and resolve custom settings, and acquire and release resources. The function for opening files is one of the most familiar examples of a context manager. Context managers sandwich code blocks between two distinct pieces of logic:\n• The enter logic - this runs right before the nested code block executes\n• The exit logic - this runs right after the nested code block is done. The most common way you'll work with context managers is by using the statement.\n\nContext managers keep our codebases much cleaner because they encapsulate administrative boilerplate and separate it from the business logic. Additionally, context managers are structured to carry out their exit methods regardless of what happens in the code block they frame. So even if something goes wrong in the managed block, the context manager ensures the deallocations are performed and the default settings are restored. Let's give a solid example. Think about operating on a file without using , like in the following block.\n\nThe first thing to note is that we must always close an open file. The block would perform the close even if an error occurred. If we had to do this try-except-finally logic every time we wanted to work with a file we'd have a lot of duplicate code. Luckily, Python's built-in is a context manager. Therefore, using a statement, we can program the same logic like this:\n\nHere, 's enter method opens the file and returns a file object. The keyword binds the returned value to , and we use to read the contents of . At the end of the execution of the inner code block, the exit method runs and closes the file. We can check whether is actually closed ( does not define a variable scope, we can access the variables it created from outside the statement).\n\nIt's evident from this simple example that context managers allow us to make our code cleaner and more reusable. Python defines several other context managers in the standard library, but it also allows programmers to define context managers of their own. In the next section, we will work on defining custom context managers. We will first work on the simple function-based implementation and later move on to the slightly more complicated class-based definitions.\n\nThe decorator expects a statement in the function body. divides the function into three parts:\n• The expressions above are executed right before the code that is managed.\n• The managed code runs at . Whatever is yielded makes up the context variable— in our case.\n• The expressions below are executed after the managed code is run. Notice that we have placed within a block. This is not enforced, yet, it is good practice. This way, if an error occurs in the managed code the context manager will carry out its exit logic no matter what. Look what happens if we raise a inside the statement:\n\nPython defines a context management protocol that dictates that any class with an and an method can work as a context manager. Double underscore methods are special methods that are not called but instead triggered. They are internally set to run at specific times or after certain events. For example, runs when a statement is entered and runs right before the block is left. We have seen an example of function-based context managers, which work great for quick and simple cases. For more complex use cases, we'll define context management as an additional ability to an existing class. Let's create a context manager class, which will operate on a copy of a list before returning the changes. This way, the original list would be restored unaltered if an error occurred during the operation. Let's see how that looks.\n\nIn the class, we defined two required methods: - this method defines what happens before the logic under the statement runs. If the enter method returns anything, it is bound to the context variable. In our class, we create a clone of the list and returned it as the context variable— in the above examples. - this method defines what happens when the logic is complete or has raised an error. Besides , this method takes three parameters: , , , which can also be shortened to . If no exception occurs in the managee, all these values are None. If we return a truthy value at the end of —as we did in our class—the error is suppressed. Otherwise, if we return a falsy value, such as , , or blank, the error is propagated. In short, 's method first checks whether the exception type was . If so, there were no errors, and it applies the changes to the original list; otherwise, it announces an error occurred."
    },
    {
        "link": "https://llego.dev/posts/practical-guide-using-with-statement-file-handling-python",
        "document": "The statement in Python provides an elegant and pythonic way to safely manage resources like file streams, database connections, and network sockets. By using the statement, we can ensure that these resources are properly initialized before use and cleaned up promptly after use, even in cases where exceptions are raised.\n\nIn this comprehensive guide, we will focus specifically on using the statement for file handling in Python. We will cover the basics of how the statement works, discuss its advantages over manual file management, and provide practical examples of common file handling tasks using the statement.\n\nWhether you are a beginner looking to learn best practices in Python or an experienced developer seeking patterns for more robust and maintainable code, this guide aims to provide actionable insights and sample code to implement the statement for productive file handling.\n\nThe statement simplifies exception handling by encapsulating common preparation and cleanup tasks in objects called context managers. It works by invoking specialized methods on these context managers to safely initialize a resource, execute a block of code, and then automatically clean up the resource:\n\nWhen control enters the block, Python calls the method on the context manager, which returns the initialized resource. This resource gets assigned to the variable after in the statement.\n\nThe code in the block can then safely use the resource. Once the block is exited, Python will automatically call the method on the context manager to clean up the resource.\n\nThis ensures that the resource is properly released regardless of how the block is exited - whether normally or due to an exception.\n\nManually handling opening, usage, and closing of file streams can be tedious and error-prone. Some key advantages of using the statement include:\n• Automatic cleanup: File streams are closed correctly after the indented block inside is executed, even if exceptions occur. There is no need to call explicitly.\n• Prevents resource leaks: The file is closed even if an exception is raised inside the block that causes an abrupt control flow change. The method ensures proper closure.\n• Readability: The statement clearly demarcates the scope and usage of the file stream for easier understanding of code flow.\n• Concurrency safety: Usage of files inside blocks can be safely interleaved with other threads and processes without risk of data corruption or race conditions.\n\nLet’s now look at some common examples of handling files using the statement in Python.\n\nA common file handling task is safely reading and processing the contents of a file. The builtin function returns a file object that can be used as a context manager.\n\nHere is an example of safely reading a text file line-by-line using the statement:\n\nThe function opens the file and returns a file object which is assigned to the context manager variable. The block allows us to safely read the lines of the file into a list. Once the block is exited, Python automatically calls to close the file.\n\nThis helps avoid bugs caused by improper closure of files if exceptions were raised in the middle of processing. It also makes the code cleaner by separating file handling from business logic.\n\nSimilarly, we can use the statement while writing to files as well:\n\nHere, we open file in write mode and assign it to . Inside the block, we iterate over a list of fruits and write each one to the file on a new line. The file is automatically closed after the block, saving us from calling explicitly.\n\nTo add content to the end of an existing file, we can open it in append mode:\n\nThe mode appends any writes to the end of the file. So the statement provides a concise way to safely add content to existing files as well.\n\nIn some cases, we may need more explicit control over managing the file stream’s context. The module provides a method that can convert an object into a context manager:\n\nBy wrapping the file object with , we explicitly control initialization and closing while retaining the safety of the block for reading data. This technique also works for other resources like database connections.\n\nThe statement also supports multiple context managers, allowing us to work with multiple files:\n\nHere, the statement opens two files - and , allowing us to copy from one file to another safely. The files are closed automatically after the operation completes.\n\nWe can abstract out multiple contexts into a separate statement for better readability:\n\nThis ensures each file stream is initialized and released at the right time while keeping the core logic easy to read.\n\nTo fully leverage the power of the statement, we can also create custom context managers by defining and methods.\n\nHere is an example of a custom context manager for safely working with temporary directories:\n\nThe decorator registers the generator function as a context manager. The temporarily pauses execution to enter the block before final cleanup.\n\nThis allows us to safely create and use a temporary directory in our code, without worrying about deleting it manually later. The complexities are abstracted into the context manager.\n\nWhen working with file streams using the statement, here are some recommended best practices:\n• Always open files within a block to manage them safely.\n• Use clauses within blocks for tasks like closing connections that must execute even after exceptions.\n• Leverage multiple contexts effectively to keep related resources together.\n• Abstract out complex context management into custom context managers using .\n• Open files in the appropriate read ( ), write ( ), or append ( ) modes based on intended usage.\n• Wrap legacy code that doesn’t use using to manage contexts explicitly.\n• Avoid side-effects that persist after a block like modifying global state.\n\nThe statement is a very powerful tool for robust file handling in Python. By leveraging it along with best practices around custom contexts and multiple resources, we can write clean and bug-free code for complex file processing tasks.\n\nIn this comprehensive guide, we discussed:\n• How the statement works in Python and its advantages\n• Reading, writing, and appending files using the block\n• Recommended best practices for production use of file streams\n\nThe statement helps avoid resource leaks and makes exception handling seamless when dealing with critical resources like files and connections. Mastering it is a milestone for any intermediate Python programmer.\n\nThere are always new ways to leverage contexts effectively as Python evolves. I hope you found this guide useful! Let me know if you have any other creative examples of using the statement for productive file handling in your applications."
    },
    {
        "link": "https://medium.com/@farihatulmaria/explaining-the-concept-of-context-managers-in-python-using-the-with-statement-907abd730bda",
        "document": "Context managers in Python provide a way to manage resources, such as file operations or database connections, ensuring that setup and teardown actions are properly handled. They are implemented using the statement, which guarantees that the resources will be properly managed even if exceptions occur during execution. Python's context management protocol is defined by two methods: and .\n\nUsing Context Managers with the Statement\n\nThe statement in Python is used to wrap the execution of a block of code within a context manager. The syntax is as follows:\n• evaluates to an object that supports the context management protocol.\n• (optional) captures the result of the method of the context manager.\n\nThe statement automatically calls the method of the context manager before entering the block and calling the method when exiting the block, ensuring proper cleanup of resources.\n\nYou can create a custom context manager in Python by defining a class that implements the context management protocol ( and methods) or by using the decorator.\n\nIn this example:\n• The method opens the specified file in the specified mode and returns the file object.\n• The method closes the file when exiting the block, ensuring proper cleanup.\n\nYou can also create a custom context manager using the decorator, which simplifies the process of defining context managers.\n\nIn this example:\n• Inside the generator function, the resource (file) is acquired ( operation) and ed to the caller of the context manager.\n• The code block within the statement ( ) runs before and after the statement.\n• The block ensures that the file is closed when exiting the block, even if exceptions occur.\n• Resource Management: Ensures proper handling of resources (e.g., file handles, database connections) by automatically performing setup and teardown actions.\n• Error Handling: Facilitates clean error handling and ensures that resources are released even if exceptions occur.\n\nBy leveraging custom context managers in Python, you can simplify resource management and ensure that your code adheres to best practices for handling resources and exceptions in a clean and concise manner. Context managers are an essential feature for writing robust and reliable Python applications."
    }
]