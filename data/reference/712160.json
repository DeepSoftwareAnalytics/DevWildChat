[
    {
        "link": "https://stackoverflow.com/questions/2591098/how-to-parse-json-in-java",
        "document": "I have the following JSON text. How can I parse it to get the values of pageName , pagePic , post_id , etc.?\n\nFor the sake of the example lets assume you have a class with just a . private class Person { public String name; public Person(String name) { this.name = name; } } My personal favourite and probably the most widely used. ObjectMapper mapper = new ObjectMapper(); // De-serialize to an object Person user = mapper.readValue(\"{\\\"name\\\": \\\"John\\\"}\", Person.class); System.out.println(user.name); //John // Read a single attribute JsonNode nameNode = mapper.readTree(\"{\\\"name\\\": \\\"John\\\"}\"); System.out.println(nameNode.get(\"name\").asText()); Gson g = new Gson(); // De-serialize to an object Person person = g.fromJson(\"{\\\"name\\\": \\\"John\\\"}\", Person.class); System.out.println(person.name); //John // Read a single attribute JsonObject jsonObject = new JsonParser().parseString(\"{\\\"name\\\": \\\"John\\\"}\").getAsJsonObject(); System.out.println(jsonObject.get(\"name\").getAsString()); //John This suggestion is listed here simply because it appears to be quite popular due to stackoverflow reference to it. I would not recommend using it as it is more a proof-of-concept project than an actual library.\n\nYou can use Jackson libraries, for binding JSON String into POJO (Plain Old Java Object) instances. POJO is simply a class with only private fields and public getter/setter methods. Jackson is going to traverse the methods (using reflection), and maps the JSON object into the POJO instance as the field names of the class fits to the field names of the JSON object. In your JSON object, which is actually a composite object, the main object consists o two sub-objects. So, our POJO classes should have the same hierarchy. I'll call the whole JSON Object as Page object. Page object consist of a PageInfo object, and a Post object array. So we have to create three different POJO classes;\n• Page Class, a composite of PageInfo Class and array of Post Instances The only package I've used is Jackson ObjectMapper, what we do is binding data; The required dependencies, the jar files is listed below; Here is the required code; I've just copied your JSON sample into this file and put it under the project folder. { \"pageInfo\": { \"pageName\": \"abc\", \"pagePic\": \"http://example.com/content.jpg\" }, \"posts\": [ { \"post_id\": \"123456789012_123456789012\", \"actor_id\": \"1234567890\", \"picOfPersonWhoPosted\": \"http://example.com/photo.jpg\", \"nameOfPersonWhoPosted\": \"Jane Doe\", \"message\": \"Sounds cool. Can't wait to see it!\", \"likesCount\": \"2\", \"comments\": [], \"timeOfPost\": \"1234567890\" } ] } package com.levo.jsonex; import java.io.File; import java.io.IOException; import java.util.Arrays; import com.fasterxml.jackson.databind.ObjectMapper; import com.levo.jsonex.model.Page; import com.levo.jsonex.model.PageInfo; import com.levo.jsonex.model.Post; public class JSONDemo { public static void main(String[] args) { ObjectMapper objectMapper = new ObjectMapper(); try { Page page = objectMapper.readValue(new File(\"sampleJSONFile.json\"), Page.class); printParsedObject(page); } catch (IOException e) { e.printStackTrace(); } } private static void printParsedObject(Page page) { printPageInfo(page.getPageInfo()); System.out.println(); printPosts(page.getPosts()); } private static void printPageInfo(PageInfo pageInfo) { System.out.println(\"Page Info;\"); System.out.println(\"**********\"); System.out.println(\"\\tPage Name : \" + pageInfo.getPageName()); System.out.println(\"\\tPage Pic : \" + pageInfo.getPagePic()); } private static void printPosts(Post[] posts) { System.out.println(\"Page Posts;\"); System.out.println(\"**********\"); for(Post post : posts) { printPost(post); } } private static void printPost(Post post) { System.out.println(\"\\tPost Id : \" + post.getPost_id()); System.out.println(\"\\tActor Id : \" + post.getActor_id()); System.out.println(\"\\tPic Of Person Who Posted : \" + post.getPicOfPersonWhoPosted()); System.out.println(\"\\tName Of Person Who Posted : \" + post.getNameOfPersonWhoPosted()); System.out.println(\"\\tMessage : \" + post.getMessage()); System.out.println(\"\\tLikes Count : \" + post.getLikesCount()); System.out.println(\"\\tComments : \" + Arrays.toString(post.getComments())); System.out.println(\"\\tTime Of Post : \" + post.getTimeOfPost()); } } Page Info; ****(***** Page Name : abc Page Pic : http://example.com/content.jpg Page Posts; ********** Post Id : 123456789012_123456789012 Actor Id : 1234567890 Pic Of Person Who Posted : http://example.com/photo.jpg Name Of Person Who Posted : Jane Doe Message : Sounds cool. Can't wait to see it! Likes Count : 2 Comments : [] Time Of Post : 1234567890\n\nThe below example shows how to read the text in the question, represented as the \"jsonText\" variable. This solution uses the Java EE7 javax.json API (which is mentioned in some of the other answers). The reason I've added it as a separate answer is that the following code shows how to actually access some of the values shown in the question. An implementation of the javax.json API would be required to make this code run. The full package for each of the classes required was included as I didn't want to declare \"import\" statements. javax.json.JsonReader jr = javax.json.Json.createReader(new StringReader(jsonText)); javax.json.JsonObject jo = jr.readObject(); //Read the page info. javax.json.JsonObject pageInfo = jo.getJsonObject(\"pageInfo\"); System.out.println(pageInfo.getString(\"pageName\")); //Read the posts. javax.json.JsonArray posts = jo.getJsonArray(\"posts\"); //Read the first post. javax.json.JsonObject post = posts.getJsonObject(0); //Read the post_id field. String postId = post.getString(\"post_id\"); Now, before anyone goes and downvotes this answer because it doesn't use GSON, org.json, Jackson, or any of the other 3rd party frameworks available, it's an example of \"required code\" per the question to parse the provided text. I am well aware that adherence to the current standard JSR 353 was not being considered for JDK 9 and as such the JSR 353 spec should be treated the same as any other 3rd party JSON handling implementation.\n\nThere are many JSON libraries available in Java. The most notorious ones are: Jackson, GSON, Genson, FastJson and org.json. There are typically three things one should look at for choosing any library:\n• Ease of use (code is simple to write and legible) - that goes with features. Specifically for JSON libraries (and any serialization/deserialization libs), databinding is also usually of interest as it removes the need of writing boiler-plate code to pack/unpack the data. For 1, see this benchmark: https://github.com/fabienrenaud/java-json-benchmark I did using JMH which compares (jackson, gson, genson, fastjson, org.json, jsonp) performance of serializers and deserializers using stream and databind APIs. For 2, you can find numerous examples on the Internet. The benchmark above can also be used as a source of examples... Quick takeaway of the benchmark: Jackson performs 5 to 6 times better than org.json and more than twice better than GSON. For your particular example, the following code decodes your json with jackson: public class MyObj { private PageInfo pageInfo; private List<Post> posts; static final class PageInfo { private String pageName; private String pagePic; } static final class Post { private String post_id; @JsonProperty(\"actor_id\"); private String actorId; @JsonProperty(\"picOfPersonWhoPosted\") private String pictureOfPoster; @JsonProperty(\"nameOfPersonWhoPosted\") private String nameOfPoster; private String likesCount; private List<String> comments; private String timeOfPost; } private static final ObjectMapper JACKSON = new ObjectMapper(); public static void main(String[] args) throws IOException { MyObj o = JACKSON.readValue(args[0], MyObj.class); // assumes args[0] contains your json payload provided in your question. } } Let me know if you have any questions.\n\nIf your data is simple and you don't want external dependencies, use some lines of code: /** * A very simple JSON parser for one level, everything quoted. * @param json the json content. * @return a key => value map. */ public static Map<String, String> simpleParseJson(String json) { Map<String, String> map = new TreeMap<>(); String qs[] = json.replace(\"\\\\\\\"\", \"\\u0001\").replace(\"\\\\\\\\\", \"\\\\\").split(\"\\\"\"); for (int i = 1; i + 3 < qs.length; i += 4) { map.put(qs[i].replace('\\u0001', '\"'), qs[i + 2].replace('\\u0001', '\"')); } return map; } This can be upgraded to work with unquoted values too... /** * A very simple JSON parser for one level, names are quoted. * @param json the json content. * @return a key => value map. */ public static Map<String, String> simpleParseJson(String json) { Map<String, String> map = new TreeMap<>(); String qs[] = json.replace(\"\\\\\\\"\", \"\\u0001\").replace(\"\\\\\\\\\", \"\\\\\").split(\"\\\"\"); for (int i = 1; i + 1 < qs.length; i += 4) { if (qs[i + 1].trim().length() > 1) { String x = qs[i + 1].trim(); map.put(qs[i].replace('\\u0001', '\"'), x.substring(1, x.length() - 1).trim().replace('\\u0001', '\"')); i -= 2; } else { map.put(qs[i].replace('\\u0001', '\"'), qs[i + 2].replace('\\u0001', '\"')); } } return map; } And to solve complex structure, it gets ugly... ... SORRY!!! ... but I could not resist to code it^^ This parses the given JSON in question and way more. It yields nested maps and lists. /** * A very simple JSON parser, names are quoted. * * @param json the json content. * @return a key => value map. */ public static Map<String, Object> simpleParseJson(String json) { Map<String, Object> map = new TreeMap<>(); String qs[] = json.replace(\"\\\\\\\"\", \"\\u0001\").replace(\"\\\\\\\\\", \"\\\\\").split(\"\\\"\"); int index[] = { 1 }; recurse(index, map, qs); return map; } /** * Eierlegende Wollmilchsau. * * @param index index into array. * @param map the current map to fill. * @param qs the data. */ private static void recurse(int[] index, Map<String, Object> map, String[] qs) { int i = index[0]; for (;; i += 4) { String end = qs[i - 1].trim(); // check for termination of an object if (i == qs.length || end.startsWith(\"}\")) { qs[i - 1] = end.substring(1).trim(); i -= 4; break; } String key = qs[i].replace('\\u0001', '\"'); String x = qs[i + 1].trim(); if (x.endsWith(\"{\")) { x = x.substring(0, x.length() - 1).trim(); if (x.endsWith(\"[\")) { List<Object> list = new ArrayList<>(); index[0] = i + 2; for (;;) { Map<String, Object> inner = new TreeMap<>(); list.add(inner); recurse(index, inner, qs); map.put(key, list); i = index[0]; String y = qs[i + 3]; // check for termination of array if (y.startsWith(\"]\")) { qs[i + 3] = y.substring(1).trim(); break; } } continue; } Map<String, Object> inner = new TreeMap<>(); index[0] = i + 2; recurse(index, inner, qs); map.put(key, inner); i = index[0]; continue; } if (x.length() > 1) { // unquoted String value = x.substring(1, x.length() - 1).trim().replace('\\u0001', '\"'); if (\"[]\".equals(value)) // handle empty array map.put(key, new ArrayList<>()); else map.put(key, value); i -= 2; } else { map.put(key, qs[i + 2].replace('\\u0001', '\"')); } } index[0] = i; } yields - if you print the map: {pageInfo={pageName=abc, pagePic=http://example.com/content.jpg}, posts=[{actor_id=1234567890, comments=[], likesCount=2, message=Sounds cool. Can't wait to see it!, nameOfPersonWhoPosted=Jane Doe, picOfPersonWhoPosted=http://example.com/photo.jpg, post_id=123456789012_123456789012, timeOfPost=1234567890}]}"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/jackson-json-java-parser-api-example-tutorial",
        "document": "Jackson JSON Java Parser is very popular and used in Spring framework too. Java JSON Processing API is not very user friendly and doesn’t provide features for automatic transformation from Json to Java object and vice versa. Luckily we have some alternative APIs that we can use for JSON processing. In last article we learned about Google Gson API and saw how easy to use it.\n\nTo use Jackson JSON Java API in our project, we can add it to the project build path or if you are using maven, we can add below dependency.\n\njackson-databind jar depends on jackson-core and jackson-annotations libraries, so if you are adding them directly to build path, make sure you add all three otherwise you will get runtime error. Jackson JSON Parser API provides easy way to convert JSON to POJO Object and supports easy conversion to Map from JSON data. Jackson supports generics too and directly converts them from JSON to object.\n\nFor our example for JSON to POJO/Java object conversion, we will take a complex example with nested object and arrays. We will use arrays, list and Map in java objects for conversion. Our complex json is stored in a file employee.txt with below structure:\n\nWe have following java classes corresponding to the json data.\n\nAddress class corresponds to the inner object in the root json data.\n\nEmployee is the java bean representing the root json object. Now let’s see how can we transform JSON to java object using Jackson JSON parser API.\n\nWhen we run above program, you will get following output.\n\ncom.fasterxml.jackson.databind.ObjectMapper is the most important class in Jackson API that provides readValue() and writeValue() methods to transform JSON to Java Object and Java Object to JSON. ObjectMapper class can be reused and we can initialize it once as Singleton object. There are so many overloaded versions of readValue() and writeValue() methods to work with byte array, File, input/output stream and Reader/Writer objects.\n\nSometimes we have a JSON object like below, in data.txt file:\n\nand we want to convert it to a Map and not to java object with same properties and keys. We can do it very easily in Jackson JSON API with two methods with below code:\n\nOnce we execute above snippet, we get following output:\n\nSometimes we have json data and we are interested in only few of the keys values, so in that case converting whole JSON to object is not a good idea. Jackson JSON API provides option to read json data as tree like DOM Parser and we can read specific elements of JSON object through this. Below code provides snippet to read specific entries from json file.\n\nWe get following output when we execute above code snippet.\n\nJackson JSON Java API provide useful methods to add, edit and remove keys from JSON data and then we can save it as new json file or write it to any stream. Below code shows us how to do this easily.\n\nIf you will execute above code and look for the new file, you will notice that it doesn’t have “role” and “properties” key. You will also notice that “id” value is updated to 500 and a new key “test” is added to updated_emp.txt file.\n\nJackson JSON Java API also provide streaming support that is helpful in working with large json data because it reads the whole file as tokens and uses less memory. The only problem with streaming API is that we need to take care of all the tokens while parsing the JSON data. If we have json data as {“role”:“Manager”} then we will get following tokens in order - { (start object), “role” (key name), “Manager” (key value) and } (end object). Colon (:) is the delimiter in JSON and hence not considered as a token.\n\nJsonParser is the jackson json streaming API to read json data, we are using it to read data from the file and then parseJSON() method is used to loop through the tokens and process them to create our java object. Notice that parseJSON() method is called recursively for “address” because it’s a nested object in the json data. For parsing arrays, we are looping through the json document. We can use JsonGenerator class to generate json data with streaming API.\n\nJsonGenerator is easy to use in comparison to JsonParser. That’s all for quick reference tutorial to Jackson JSON Parser Java API. Jackson JSON Java API is easy to use and provide a lot of options for the ease of developers working with JSON data. Download project from below link and play around with it to explore more options about Jackson Json API."
    },
    {
        "link": "https://stackoverflow.com/questions/5015844/parsing-json-object-in-java",
        "document": "1.) Create an arraylist of appropriate type, in this case i.e\n\n2.) Create a while passing your string to constructor as input\n• As notation is represented by braces i.e\n• Where as notation is represented by square brackets i.e\n\n3.) Retrieve from (created at 2nd step) using as index.\n\n4.) Traverse using loops upto the length of array provided by function\n\n5.) Retrieve your from using function\n\n6.) Fetch the data from using index '\"interestKey\"'.\n\nNote : parsing uses the escape sequence for special nested characters if the json response (usually from other JSON response APIs) contains quotes ( ) like this\n\nshould be like this\n\nso you can use to achieve escaped sequence format for safety as\n\nNote : Sometime you may see some exceptions when the values are not available in appropriate type or is there is no mapping key so in those cases when you are not sure about the presence of value so use , , etc which will simply return the default value if it is not present and even try to convert value to int if it is of string type and vice-versa so Simply No null or NumberFormat exceptions at all in case of missing key or value\n\nor To get empty string i.e if no key found then simply use\n• How to convert String to JSONObject in Java"
    },
    {
        "link": "https://medium.com/@AlexanderObregon/javas-jsonparser-parse-method-explained-76b126f6110e",
        "document": "Java offers several ways to handle JSON data, and while modern applications often lean toward libraries like Jackson or Gson, the class is still relevant, especially when you're working with the standard Java API. The method is key to reading JSON data efficiently, allowing developers to process JSON in a streaming fashion. This article explores the method, focusing on how to use it, where it's applicable, and what performance considerations to keep in mind when working with large JSON files.\n\nThe class in Java, part of the package, is designed to parse JSON-formatted data. The method plays an important role in reading JSON data from various sources, including strings, files, or network responses. However, it is important to note that while this method is still supported, its usage has declined a bit over time in favor of more feature-rich libraries like Jackson and Gson.\n• Streaming JSON parsing: The parser reads JSON data token by token, making it efficient for handling large JSON files or streams.\n• Lightweight: As a part of the standard Java API, it requires no external dependencies, unlike third-party libraries such as Jackson or Gson.\n• Still supported but less used: Although modern Java applications tend to favor stronger libraries, the method remains relevant for lightweight use cases or environments where external libraries are not desirable.\n\nIt’s also worth noting that the API (JSR 353) has been superseded by as part of the transition of Java EE to Jakarta EE, which is now maintained by the Eclipse Foundation. For new projects, it is generally recommended to use the API going forward, as it benefits from ongoing updates and support. However, for existing projects using , it is perfectly fine to continue using it, although migrating to when feasible may be advised to stay up to date with future improvements.\n\nHow to Use for Reading JSON\n\nThe method is versatile and can be used to read JSON data from various sources, such as strings, files, or even network responses. This section will explore how to use effectively by walking through different examples and use cases, showing how it fits into modern Java applications.\n\nThe most common way to use is to handle JSON strings or files and extract values from them. In Java, you can create a using the method, which reads the JSON data and parses it into a or that you can easily work with.\n\nSpecifically, the interface provides low-level access to the JSON stream, while the class provides a higher-level API for reading JSON data as objects and arrays.\n\nLet’s begin with parsing a simple JSON string. This example shows how you can take a JSON-formatted string and access individual elements from it:\n\nIn this example:\n• The reads the JSON data from a .\n• The method processes the string and converts it into a , allowing easy access to its fields.\n\nFor real-world applications, JSON data often comes from files rather than hardcoded strings. Let’s look at an example that shows how to parse a JSON file and retrieve specific data.\n• We use a to open the JSON file.\n• The reads the data from the file stream.\n• Similar to the previous example, processes the file and converts the content into a .\n\nAnother common scenario is reading JSON data from an API response. Here’s a simplified example where you simulate fetching JSON data from a URL (in real-world use cases, you would likely be using a library like or to make the HTTP request).\n\nIn this example:\n• We simulate fetching JSON data from an API using a .\n• Once we get the input stream from the API response, the parses it into a .\n\nJSON often contains arrays, and can easily handle these as well. Let’s extend the previous examples to show how to work with a JSON array.\n\nIn this example, the key contains an array of values. The method is used to extract the array from the JSON object, and you can iterate over the array elements using a simple loop.\n\nJSON data can often contain nested structures, where an object contains other objects or arrays. handles this easily, as shown in this example:\n\nIn this case, the JSON object contains another object . By chaining calls to , you can easily navigate through nested structures to access the data you need.\n\nWhen working with JSON in Java, performance is often a key factor, especially when dealing with large datasets or real-time data processing. The method provides a lightweight, streaming-based solution for reading JSON data, but it comes with some trade-offs, especially compared to modern alternatives like Jackson and Gson.\n\nOne of the primary benefits of using is its streaming nature. Instead of loading the entire JSON document into memory, the parser reads the JSON data token by token, processing it as it comes. This makes it a great choice for memory-constrained environments or situations where the JSON data is too large to fit into memory at once.\n• Memory Efficiency: Because the parser works incrementally, it uses memory more efficiently than libraries that load the entire JSON document into memory before processing. This makes suitable for large JSON files, reducing the risk of running out of memory.\n• Processing Time: The streaming nature of also makes it faster when handling large files or streams. Since it doesn’t need to parse the entire file before returning data, you can start processing parts of the file right away. However, for small to medium-sized JSON files, the difference in speed between and other libraries may not be noticeable.\n• Manual Parsing: One downside of is the need for more manual intervention. Since it works token by token, you’ll need to write additional code to navigate through the JSON structure, especially with more complex or nested data. In comparison, other libraries that map JSON directly to Java objects can simplify this process.\n• Streaming vs Object Mapping: Another point to consider is that while is great for memory efficiency, it doesn't support direct object mapping, meaning you can't automatically convert JSON into Java objects. If your goal is to map JSON data directly to Java classes, you’ll need to do this manually or use a different library.\n\nWhile has its strengths, modern Java applications tend to use libraries like Jackson and Gson due to their ease of use, flexibility, and additional features. Both libraries are widely adopted in the Java ecosystem and offer powerful solutions for working with JSON data.\n• Jackson: Jackson is a popular library that supports both JSON serialization and deserialization. It allows developers to map JSON data directly to Java objects (and vice versa) with minimal effort. One of Jackson’s key strengths is its ability to handle complex data structures and large JSON files without a significant performance penalty.\n\nHere’s an example of how Jackson simplifies the process of converting JSON to a Java object:\n\nIn this example, Jackson takes care of most of the heavy lifting. It reads the JSON file and automatically converts it into a Java object, making it easier to work with structured data.\n• Gson: Gson, developed by Google, is another popular library for working with JSON in Java. Like Jackson, it allows for object mapping, meaning JSON data can be converted into Java objects with minimal code. One of Gson’s strengths is its simplicity and small footprint, making it a lightweight option for developers who need JSON parsing but don’t want the full overhead of a large library.\n\nHere’s an example using Gson to parse JSON:\n\nWith Gson, you get a very clean and simple API to work with, making it ideal for smaller projects or cases where simplicity is key.\n\nDespite the popularity of Jackson and Gson, there are still cases where may be the better choice:\n• Low-memory environments: If your application runs in an environment where memory is limited, or if you are working with very large JSON files, the incremental parsing offered by can be a real benefit.\n• No external dependencies: If you want to avoid adding external libraries to your project and prefer sticking to standard Java APIs, is still a solid option.\n• Simple parsing tasks: If your JSON parsing needs are straightforward and don’t involve complex object mappings or nested structures, the simplicity of might suit your needs without the overhead of larger libraries.\n\nWhen to Use Modern Alternatives\n\nFor most modern Java applications, however, libraries like Jackson and Gson offer more flexibility and power:\n• Ease of Use: Both Jackson and Gson are designed to make JSON parsing simple, with a clean API and the ability to map JSON directly to Java objects. This can save a lot of time and effort compared to manually navigating through JSON tokens.\n• More Features: These libraries offer additional features such as custom serialization/deserialization, support for advanced data types, and better handling of edge cases in JSON parsing (e.g., dealing with missing fields or complex data structures).\n• Active Development: Both Jackson and Gson are actively maintained and widely supported, meaning they are more likely to have improvements, bug fixes, and new features added over time compared to the older API.\n\nThe method from the package remains a useful tool for lightweight JSON parsing, particularly in scenarios where memory efficiency is important. Although it has been overshadowed by more libraries like Jackson and Gson, it still has its place in simpler applications or environments with minimal dependencies. For new projects, however, transitioning to modern alternatives such as , Jackson, or Gson is often recommended to take advantage of better functionality and ongoing support. Understanding the strengths and limitations of each approach allows developers to choose the right tool for the job.\n\nThank you for reading! If you find this article helpful, please consider highlighting, clapping, responding or connecting with me on Twitter/X as it’s very appreciated and helps keeps content like this free!"
    },
    {
        "link": "https://baeldung.com/java-json",
        "document": "Working with JSON data in Java can be easy, but – like most anything in Java – there are a lot of options and libraries we can chose from.\n\nThis guide should make that choice easier and should give you a solid understanding of the ecosystem right now. We’ll discuss the most common JSON processing libraries in Java:\n\nWe’re following a simple structure for each library – first some useful resources to get started (both here on Baeldung as well as external). Then we’re going to go over a basic code example, just to see how working with the library actually looks like.\n\nFirst, let’s start with some statistics as a proxy for the popularity of each library:\n\nNext, let’s have a look at the most popular of these – Jackson. Jackson is a multi-purpose Java library for processing JSON data.\n\nHere are some official resources for the library:\n\nTo use the library – here’s the Maven dependency to add into your pom.xml:\n\nMake sure to get the latest version of Jackson.\n\nNow, let’s see how to use Jackson in a simple example:\n• ObjectMapper.writeValueAsString() is used to serialize Object to JSON string.\n• ObjectMapper.readValue() is used to deserialize JSON string to Java Object.\n\nGson is the next Java JSON library that we’re going to be looking at.\n\nHere are some official resources for the library:\n\nNote that the latest version of Gson right now is 2.8.8.\n\nHere is a simple example clarify how to use Gson to serialize/desrialize JSON:\n• Gson.toJson() is used to serialize Object to JSON\n• Gson.fromJson() is used to desrialize JSON to Java Object\n\nHere are some official resources for the library:\n\nNote that the latest version of json-io right now is 4.13.0.\n\nNow, let’s take a look at a simple example of using json-io:\n• JsonWriter.objectToJson() is used to serialize Object to JSON.\n• JsonReader.jsonToJava() is used to deserialize Json to Java Object.\n\nGenson is a Java and Scala to JSON conversion library, providing full databinding and streaming.\n\nHere are some official resources for the library:\n\nNote that the latest version of Genson right now is 1.6.\n\nHere’s a simple example of working with the library:\n• Genson.serialize() is used to serialize Object to JSON\n• Genson.desrialize() is used to deserialize JSON to Java Object\n\nJSON-P is a Java API for parsing, building, transforming, and querying JSON messages. Java Specification Request (JSR) 353 proposed the API. JSR 353 aims to develop a Java API to process JSON. Most of the popular libraries, like Jackson, Gson, etc., don’t implement the specification directly.\n\nHere are some official resources for the library:\n\nNote that we need the API module and the default provider dependencies. The latest version is 2.1.1 and 2.0.1, respectively.\n\nLet’s take a look at the simple use case of JSON-P:\n• Json.createObjectBuilder() is used to transform an object to JSON.\n• Json.createParser() is used to parse the JSON message.\n• JSON-P API is low-level compared to other JSON processing libraries in Java.\n\nIn this quick overview article, we learned about the most common JSON processing libraries in Java."
    },
    {
        "link": "https://stackoverflow.com/questions/25088730/example-data-in-pojo-for-json-documentation",
        "document": "I'm trying to document my JSON API. My API returns Java POJOs which get serialized by Jackson. I'm writing a service to return example JSON for each service. What I'd like to do is something like this:\n\nI'll need some method to get Jackson to serialize this as:\n\nwhen I need an example.\n\nWhat's the easiest way to make this happen?"
    },
    {
        "link": "https://baeldung.com/java-generate-class-from-json",
        "document": "In some situations, we need to create Java classes, also called POJOs, using JSON files. This is possible without writing the whole class from scratch using a handy jsonschema2pojo library.\n\nIn this tutorial, we’ll see how to create a Java class from a JSON object using this library.\n\nWe can convert a JSON object into a Java class using the jsonschema2pojo-core dependency:\n\nLet’s see how to write a program using the jsonschema2pojo library, which will convert a JSON file into a Java class.\n\nFirst, we’ll create a method convertJsonToJavaClass that converts a JSON file to a POJO class and accepts four parameters:\n• an outputJavaClassDirectory where the POJO would get generated\n• packageName to which the POJO class would belong and\n\nThen, we’ll define the steps in this method:\n• We’ll start with creating an object of JCodeModel class, which will generate the Java class\n• Then, we’ll define the configuration for jsonschema2pojo, which lets the program identify that the input source file is JSON (the getSourceType method)\n• Furthermore, we’ll pass this configuration to a RuleFactory, which will be used to create type generation rules for this mapping\n• We’ll create a SchemaMapper using this factory along with the SchemaGenerator object, which generates the Java type from the provided JSON\n• Finally, we’ll call the build method of the JCodeModel to create the output class\n\nLet’s use this sample JSON for the program execution:\n\nOnce we execute our program, it creates the following Java class in the given directory:\n\nNote that it has consequently created a new Address class for the nested JSON object as well:\n\nWe can also achieve all of this by simply visiting jsonschema2pojo.org. The jsonschema2pojo tool takes a JSON (or YAML) schema document and generates DTO-style Java classes. It provides many options that you can choose to include in the Java class, including constructors as well as hashCode, equals, and toString methods.\n\nIn this tutorial, we covered how to create a Java class from JSON with examples using the jsonschema2pojo library."
    },
    {
        "link": "https://blogs.oracle.com/javamagazine/post/java-json-serialization-jackson",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/48224250/shall-i-use-pojo-or-jsonobject-for-rest-calls",
        "document": "This argument really boils down to whether you want to use POJOs or Maps for the data you are dealing with, as that is the fundamental difference between the 2 styles of handling data.\n\nJsonObject (from jee7) is just a Map (the actual type signature extends ).\n\nUsing POJO's (eg deserialised using Jackson) are real objects.\n\nSo if you dont use domain/model classes for your data normally then I guess a will do. If you do (like most developers would), then it's a good idea to extend this practice to your API contracts.\n\nIt doesn't, both of these JSON API's require serialisation/deserialisation, which is the process of turning wire data into an object. I would bet that Jackson is faster than JsonObject, however as Satyendra Kumar pointed out benchmarking is going to prove it one way or other.\n\nIf you are using the data from the API you are bound to the data model, whether you get the data from a property by or .\n\nFor a really comprehensive discussion on the tradeoffs between classes and maps, check out this SoftwareEngineering post\n\nIt's worth pointing out that using Jackson/POJOs doesn't mean you are tightly coupled to your local model of a REST response. Jackson has excellent support for the Tolerant Reader pattern, which means that new fields in the API response will not break deserialisation, and a bunch of annotations like , , for mapping the API responses back to your local domain model.\n\nIt also provides powerful tools for dealing with collections and generics.\n\nFinally if the service you are interacting with is big and complex, if they provide a swagger/raml spec then you can generate the models based on that spec which should greatly reduce the time taken to curate the POJOs."
    },
    {
        "link": "https://baeldung.com/java-org-json",
        "document": "JSON (JavaScript Object Notation) is a lightweight data-interchange format, and we most commonly use it for client-server communication. Furthermore, it’s both easy to read/write and language-independent. A JSON value can be another JSON object, array, number, string, boolean (true/false) or null.\n\nIn this tutorial, we’ll see how to create, manipulate, and parse JSON using one of the available JSON processing libraries — JSON-Java library, also known as org.json.\n\nFirst, let’s add the following dependency in our pom.xml:\n\nWe can get the latest version from the Maven Central Repository.\n\nHowever, let’s not include the dependency explicitly when using the Android SDK, since it already includes the package.\n\nWe use classes from the JSON-Java library to parse and manipulate JSON in Java. We also know this library as org.json. However, let’s not confuse it with Google’s org.json.simple library.\n\nFurthermore, this library can also convert between JSON, XML, HTTP Headers, Cookies, Comma Delimited List or Text, etc.\n\nIn this tutorial, we’ll have a look at the following classes:\n• JSONArray – an ordered sequence of values similar to Java’s native Vector implementation\n• JSONTokener – a tool that breaks a piece of text into a series of tokens that can be used by JSONObject or JSONArray to parse JSON strings\n• CDL – a tool that provides methods to convert comma delimited text into a JSONArray and vice versa\n• Cookie – converts from JSON String to cookies and vice versa\n• HTTP – used to convert from JSON String to HTTP headers and vice versa\n\nA JSONObject is an unordered collection of key and value pairs, resembling Java’s native Map implementations.\n• Keys are unique Strings that cannot be null.\n• Values can be anything from a Boolean, Number, String, or JSONArray to even a JSONObject.NULL object.\n• A JSONObject can be represented by a String enclosed within curly braces with keys and values separated by a colon, and pairs separated by a comma.\n• It has several constructors with which to construct a JSONObject.\n\nIt also supports the following main methods:\n• get(String key) – gets the object associated with the supplied key, throws JSONException if the key is not found\n• opt(String key) – gets the object associated with the supplied key, null otherwise\n• put(String key, Object value) – inserts or replaces a key-value pair in current JSONObject.\n\nThe put() method is an overloaded method that accepts a key of type String and multiple types for the value.\n\nFor the complete list of methods supported by JSONObject, visit the official documentation.\n\nLet’s now discuss some of the main operations supported by this class.\n\nWe can use the put() method and supply the key and value as an argument:\n\nNow our JSONObject would look like this:\n\nThe JSONObject.put() method provides seven different overloaded signatures. While the key can only be a unique, non-null String, the value can be anything.\n\nInstead of directly putting key and values in a JSONObject, we can construct a custom Map and then pass it as an argument to JSONObject‘s constructor.\n\nThis example will produce same results as above:\n\nTo parse a JSON String to a JSONObject, we can just pass the String to the constructor.\n\nThis example will produce same results as above:\n\nThe passed String argument must be a valid JSON; otherwise, this constructor may throw a JSONException.\n\nOne of JSONObject’s constructors takes a POJO as its argument. In the example below, the package uses the getters from the DemoBean class and creates an appropriate JSONObject for the same.\n\nTo get a JSONObject from a Java Object, we’ll have to use a class that is a valid Java Bean:\n\nAlthough we have a way to serialize a Java object to JSON string, there is no way to convert it back using this library. If we want that kind of flexibility, we can switch to other libraries such as Jackson.\n\nA JSONArray is an ordered collection of values, resembling Java’s native Vector implementation:\n• Values can be anything from a Number, String, Boolean, JSONArray, or JSONObject to even a JSONObject.NULL object\n• It’s represented by a String wrapped within square brackets and consists of a collection of values separated by commas\n• Like JSONObject, it has a constructor that accepts a source String and parses it to construct a JSONArray\n\nThese are the primary methods of the JSONArray class:\n• get(int index) – returns the value at the specified index (between 0 and total length – 1), otherwise throws a JSONException\n• opt(int index) – returns the value associated with an index (between 0 and total length – 1). If there’s no value at that index, then a null is returned.\n• put(Object value) – append an object value to this JSONArray. This method is overloaded and supports a wide range of data types\n\nFor a complete list of methods supported by JSONArray, visit the official documentation.\n\nOnce we’ve initialized a JSONArray object, we can simply add and retrieve elements using the put() and get() methods:\n\nFollowing are the contents of our JSONArray (code is formatted for clarity):\n\nLike JSONObject, the JSONArray also has a constructor that creates a Java object directly from a JSON String:\n\nThis constructor may throw a JSONException if the source String isn’t a valid JSON String.\n\n5.3. Creating JSONArray Directly From a Collection or an Array\n\nThe constructor of JSONArray also supports collection and array objects as arguments.\n\nWe simply pass them as an argument to the constructor, and it will return a JSONArray object:\n\nNow our JSONArray consists of the following:\n\nWe can remove a particular element using the instance method remove(int index). Let’s continue with the example JSONArray called ja for states and remove the “Alaska” state element using the remove(int index) method:\n\nIndeed, it does not list the removed element:\n\nFurther, we can find the element removed from the remove(int index) method call itself since it returns the element that it removes:\n\nIndeed, it lists the removed element:\n\nFurthermore, the JSONArray reduces its size by 1 on removing an element. Notably, the index position in a JSONArray is zero-based. Therefore, the first element is at index 0. Accordingly, if we were to try removing the same element with the method call ja.remove(4), assuming the 4th element to be at index 4, the element won’t get removed. However, the method call with a non-existing index position doesn’t throw an exception/error. Therefore, we should verify the removal of an element, as we did.\n\nA JSONTokener takes a source String as input to its constructor and extracts characters and tokens from it. It’s used internally by classes of this package (like JSONObject, JSONArray) to parse JSON Strings.\n\nThere may not be many situations where we’ll directly use this class since we can achieve the same functionality using other simpler methods (like string.toCharArray()):\n\nNow we can access a JSONTokener like an iterator, using the more() method to check if there are any remaining elements and next() to access the next element.\n\nHere are the tokens received from the previous example:\n\nWe’re provided with a CDL (Comma Delimited List) class to convert comma delimited text into a JSONArray and vice versa.\n\nIn order to produce a JSONArray directly from the comma delimited text, we can use the static method rowToJSONArray(), which accepts a JSONTokener:\n\nHere’s what our JSONArray consists of now:\n\nLet’s see how to reverse of the previous step and get back the comma delimited text from JSONArray:\n\nThe String cdt now contains the following:\n\nTo produce a JSONArray of JSONObjects, we’ll use a text String containing both headers and data separated by commas.\n\nWe separate the different lines using a carriage return (\\r) or line feed (\n\n).\n\nThe first line is interpreted as a list of headers, and all the subsequent lines are treated as data:\n\nThe object JSONArray result now consists of the following (output formatted for the sake of clarity):\n\nNotice that both data and header were supplied within the same String. We have an alternative way of doing this where we can achieve the same functionality by supplying a JSONArray to get the headers and a comma delimited String working as the data.\n\nAgain, we separate different lines using a carriage return (\\r) or line feed (\n\n):\n\nHere we’ll get the contents of object result exactly as before.\n\nThe Cookie class deals with web browser cookies and has methods to convert a browser cookie into a JSONObject and vice versa.\n\nHere are the main methods of the Cookie class:\n• toString(JSONObject jo) – reverse of the previous method, converts a JSONObject into a cookie String\n\nTo convert a cookie String to a JSONObject, we’ll use the static method Cookie.toJSONObject():\n\nNow we’ll convert a JSONObject into cookie String. This is the reverse of the previous step:\n\nThe HTTP class contains static methods that are used to convert HTTP headers to JSONObject and vice versa.\n\nThis class also has two main methods:\n\nWe use the HTTP.toString() method to convert a JSONObject to an HTTP header String:\n\nHere is what our String httpStr will consist of:\n\nNote that while converting an HTTP request header, the JSONObject must contain “Method”, “Request-URI” and “HTTP-Version” keys. And for response header, the object must contain “HTTP-Version”, “Status-Code” and “Reason-Phrase” parameters.\n\nHere we will convert the HTTP string that we got in the previous step back to the very JSONObject we created in that step:\n\nAccordingly, the package-based applications throw the JSONException standard exception whenever any error is encountered.\n\nThe org.json package uses this class across all other classes. Furthermore, when an application throws this exception, it includes a message that states what exactly went wrong.\n\nIn this article, we looked at a JSON using Java — org.json — and we focused on some of the core functionality available here."
    }
]