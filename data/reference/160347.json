[
    {
        "link": "https://man7.org/linux/man-pages/man7/fifo.7.html",
        "document": "Pages that refer to this page: open(2), mkfifo(3), sd_is_fifo(3), systemd.socket(5), pipe(7), signal(7)"
    },
    {
        "link": "https://stackoverflow.com/questions/12582239/named-pipes-linux",
        "document": "I made 2 threads, one has to read the other has to write. But i get undefined behaviour, sometimes i can read 1 line, sometimes 1000. It does not make alot of sense to me.\n\nWhat i do is the following: 1. i create a fifo with mkfifo() in main.cpp 2. i start 2 threads, one that reads, the other writes. reader.cpp, writer.cpp\n\nIn those threads, every loop i open the fifo and i close it, because it wont work if i only do that once outside the loop, which i find also strange.\n\nI have been looking for good examples but i found none.\n\nMy questions is simple, how can i make the fifo (Reader) wait for incoming data and read it when it is available. It should be able to run at 4Mhz.\n\nI hope that somebody can help me out because this is the 3rd day i am breaking my head on this. If it matters im using Qt 4.8.\n\nEDIT: I found the solution to my problem:"
    },
    {
        "link": "https://stackoverflow.com/questions/32149793/what-is-the-naming-convention-for-unix-fifos-named-pipes",
        "document": "There is no official naming convention.\n\nSure, when using FIFOs, you will need some convention, since FIFOs are typically used for process communication between unrelated processes. So the name must be known to the different processes, which implies you have to follow some sort of convention, but it's your call.\n\nThe reason you see directories and files with mysterious names in is usually the result of the corresponding processes calling or . These functions atomically generate a unique name and create the corresponding file / directory.\n\nIf for some reason you want your FIFO to have a similar name, you can generate a unique name with and then pass that name to . But note that there is a window of time between the call to and the call to where another process could create a file with the same name (and then would fail). If that's a problem, you could instead atomically create a temporary directory with and then create the FIFO inside that directory with a name of your choice.\n\nThe reason there is no sure way to atomically generate and create a temporary, uniquely named FIFO is that FIFOs are used as rendezvous points for unrelated processes, so in general the name must be known a priori. Having a FIFO with a unique temporary name would make it harder for other processes to find it, which kind of defeats the purpose."
    },
    {
        "link": "https://geeksforgeeks.org/named-pipe-fifo-example-c-program",
        "document": "Named Pipe or FIFO with example C program\n\nIn computing, a named pipe, also known as a FIFO (First In, First Out), is a powerful mechanism for inter-process communication (IPC). Unlike unnamed pipes, which are temporary and exist only as long as the process that created them is running, named pipes provide a persistent communication channel between processes, surviving beyond the life of the process that created them. This makes named pipes an essential tool for developers who need processes to exchange data reliably and efficiently.\n\nA named pipe is an extension of the traditional pipe concept in Unix. While a traditional pipe is “unnamed” and exists only temporarily, a named pipe can persist as long as the system is up or until it is explicitly deleted. Named pipes appear as special files in the filesystem, and multiple processes can attach to them for reading and writing, facilitating inter-process communication.\n\nA FIFO file allows two or more processes to communicate by reading from and writing to the same file. This file type is created using the ‘mkfifo()’ system call in C. Once created, any process can open the named pipe for reading or writing, similar to how it would handle an ordinary file. However, it is important to note that a named pipe must be opened simultaneously at both ends (for reading and writing) before any input or output operations can occur.\n\nHow to Create a Named Pipe (FIFO) in Unix\n\nTo create a FIFO special file, you use the ‘mkfifo()’ function in C. The function creates a named pipe with the specified pathname and permissions.\n\n\n\n‘mkfifo()’ makes a FIFO special file with name pathname. Here ‘mode’ specifies the FIFO’s permissions. It is modified by the process’s umask in the usual way: the permissions of the created file are (mode & ~umask).\n\nUsing FIFO: As named pipe(FIFO) is a kind of file, we can use all the system calls associated with it i.e. open, read, write, close.\n\nExample Programs to illustrate the named pipe: There are two programs that use the same FIFO. Program 1 writes first, then reads. The program 2 reads first, then writes. They both keep doing it until terminated.\n\n\n\nOutput: Run the two programs simultaneously on two terminals.\n\n\n\nThe Named pipes (FIFOs) are a robust method for the inter-process communication allowing data to be passed between the processes using a named file. This mechanism is useful in the scenarios where processes need to exchange data without direct knowledge of the each other. The example demonstrates a simple producer-consumer model where one process writes data to a FIFO and another reads it showcasing the basic usage of the named pipes in C.\n\nNamed Pipe or FIFO with Example C Program – FAQs\n\nWhat is the primary difference between a named pipe and an unnamed pipe?\n\nHow do I handle errors when working with FIFOs?\n\nCan multiple processes write to or read from the same FIFO?"
    },
    {
        "link": "https://github.com/nojhan/named-pipes-services",
        "document": "Examples (in C++ and Python) of how to design services that use named pipes FIFO as I/O.\n\nInstead of implementing heavy web services or complex low-level network code, just read/write from/to files, and be done with it.\n\nThe problem of making two programs communicate is among the ones that generated the largest litterature and code in all computer science (along with cache invalidation, naming things, and web frameworks).\n\nWhen facing such a problem, a programer immediatly thinks \"I'll use middleware\". If you don't really now what a middleware is, be at ease, nobody really knows. Nowadays, you may have eared of their latest avatar: web services. As our programmer is going to realize, one now have two problems. The burden of writing, using, and maintaining code using middleware is always huge. Because they are made to handle a tremendous number of features and complex situations —most of which involve adversary users, users being bots, or both.\n\nBut most of the time, the actual problem does not really involve these situations. At least not at the beginning (… which means probably never). People familiar with middleware history would argue that their key feature is not just messages passing but remote call, which involves object serialization. But most of the time, the messages are pretty simple anyway, and using a middleware to implement a serialization of a list of instances having three members of fundamental types is not a good use of your time.\n\nIf you are building up (firsts versions of) two communicating programs that will run on a (safe) local network, and for which the exchanged messages are known and simple, then I have good news: you don't have to use web services (or any kind of middleware).\n\nYOU JUST NEED TO KNOW HOW TO READ/WRITE FROM/TO (SPECIAL) FILES.\n\nThe basic idea is that, instead of programming the network interface to your service with low level sockets or any high level library, you can just implement query/answer mechanisms using named pipes.\n\nNamed pipes are special FIFO files that are blocking on I/O and implements a very basic form of message passing, without having to bother with polling. Moreover, they are very easy to use, as they are just files in which you read/write.\n\nOnce you made your service on top of named pipes, it is easy to wrap it within an interface made with other languages/tools. For instance, it is very easy to expose it on the network using common tools like (see below).\n\nBe warned that this is not secure, though, you should only use this for testing purpose in a secured local network.\n\nThe theoretical principle can be represented by this UML sequence diagram:\n• the service is started first and is waiting for the input, but as processes are blocking, the starting order does not always matter.\n• there are two pipes, here (one for the input and one for the output), for the sake of simplicity, but you may just as well use only one.\n\nTo be completely honest, here are a list of cases that —if they are all true— may lead you to consider that maybe it would be a good idea to think about how you may eventually end up looking for a solution that might be something that's close to a middleware:\n• ☒ your service takes time to compute something,\n• ☒ you have one service, but an unknown (large) number of clients,\n• ☒ all clients expect the same interface,\n• ☒ which involves answering to the server,\n• ☒ you absolutely need to serve them all as fast as possible,\n• ☒ and you are certain that no one will want another middleware in the next project.\n\nI your use case don't match all of this checklist but you still want to use a middleware, maybe you should just consider making a side software that will expose/transliterate the data going through the named pipe. That way, your service stays simple and you can easily exchange one middleware for another without even touching it.\n\nPython code does not need to be built.\n\nTo build the C++ code on Linux, just call:\n\nYou may use the scripts to see how to run the examples. For instance, for the most complex one:\n\nTo create the named pipes under Linux or MacOS, use the command, as shown in the script.\n\nCreating named pipes on windows is more complex, you may want to look at the related Stack Overflow question\n\nThe executable implements a service that reads from a named pipe and print its content on the standard output. It's just like a command, but that would not end after the first read, but will continue reading from the pipe instead.\n\nThis kind of service is just a simple loop that iterates over blocking I/O calls on the named pipes, thus having zero CPU cost for polling.\n\nThe file shows how to run the example.\n\nNote: if this example prints \"Hello World!\" multiple times, that's because you did not created the file as a named pipe, but as a regular file. Hence, instead of emptying its content after reading, it keeps reading the same content.\n\nThe is the same example, but in Python instead of C++.\n\nThe first example implements a service that reads from a named pipe and writes to another one .\n\nOnce launched, the service will wait for the pipes to be consummed, for instance with two commands. The first one writes input in the input pipe:\n\nThe second one reads the result:\n\nThe file shows how to run this example.\n\nNote that you can use the same pipe for input and output: .\n\nThe second example shows a service which depends on an initialization phase that set up a \"context\", after which it is possible to consume some \"data\".\n\nThe service use two threads, one to poll the context and one to poll the data and do something with it.\n\nThe script shows how to test it. Run it and it should show as a last line.\n\nUse to close the remaining process.\n\nIf you want to expose such a service as a network server, just use socat.\n\nFor example, to get data query from the network for :\n\n(see for a complete example).\n\nYou can test it by sending something on the connection:\n\nConversely, to send automatically back the answer to some server:\n\nBe aware that will terminate as soon as it receives the end of the message. Thus, if you want to establish a permanent gate, you will have to use the option:\n\nIf you witness strange behavior while debugging your own services (like prints that do not occur in the correct terminal), double check that yo don't have some remaining detached processes that would not have been killed.\n\nreturns anything, you would need to , or else several concurent processes would read the same pipe, which leads to (almost) undefined behavior."
    },
    {
        "link": "https://stackoverflow.com/questions/62611176/best-practice-for-struct-layout-in-c-c",
        "document": "My question here is, are there scenarios where layout L2 has downsides when compared to L1 or any other layout ?\n\nSometimes you need to have members in a different order. Reasons for this may include:\n• The structure is part of a communications protocol and has to be sent byte-by-byte across a network or other communication device. In this case, the layout of the structure may be dictated by the protocol, and you will have to match it exactly (including padding or lack thereof).\n• The structure is part of a family of structures that share initial sequences of members, so those members must be placed first. This is sometimes done to allow structures to be handled in a “generic” way by operating on those initial members only.\n• The structure includes a buffer whose length will vary (by being allocated dynamically according to needs that arise during program execution). Such a buffer is implemented with a flexible array member, which must be the last member in the structure.\n\nAlso, there may be incidental effects of how members are ordered. For example, if member happens to be used much more frequently than other members of the structure, putting it at the front might allow the compiler to access it with simpler address arithmetic, since its offset from the beginning of the structure will be zero. This is rarely a consideration in programming, but I mention it for completeness.\n\nAside such considerations, you are generally free to order members as you desire.\n\nNo. As an example, an eight-byte might have an alignment require of one, two, four, or eight bytes.\n\nThis is not true for members that are aggregates (arrays, structures, and unions). Consider that a member is 13 bytes in size but only requires alignment of one byte. To minimize padding, order members in order of decreasing alignment requirement, not decreasing size."
    },
    {
        "link": "https://simplilearn.com/tutorials/cpp-tutorial/cpp-struct",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/74777376/carving-a-struct-memory-layout-in-stone",
        "document": "Maybe this topic has been beaten to death but I can't find any \"conclusive\" answers. Anyway, I need to specify a plain old data only struct in C++17 that will be read/written to/from an external memory as a \"raw chunk of bytes\". This external memory content must specify it's memory layout \"forever\", regardless of any changing compiler settings, new compiler brands or versions, today and decades from now.\n\nI am currently using the C++ **alignas **keyword and fixed width data types for every struct member but is this really the best approach? Any suggestions and gotchas would be greately appreciated.\n\nFYI, this is an embedded project on an STM32H7xx MCU using ST CubeIDE."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/uk9wto/memory_layout_of_struct_vs_array",
        "document": "Suppose you have a struct that contains all members of the same type:\n\nIs it guaranteed that the memory layout of the allocated object is the same as the corresponding array T[6]?\n\nNote: for background on why this question is relevant, see https://docs.microsoft.com/en-us/windows/win32/api/directmanipulation/nf-directmanipulation-idirectmanipulationcontent-getcontenttransform. It takes an array of 6 floats. Here's what I'd like to write:"
    },
    {
        "link": "https://geeksforgeeks.org/features-of-c17-with-examples",
        "document": "C++17 enables writing simple, clearer, and more expressive code. Some of the features introduced in C++17 are:\n• Variable declaration in if and switch\n\nNamespaces are a very convenient tool to organize and to structure the code base, putting together components like classes and functions that logically belong to the same group.\n\nLet’s consider a hypothetical code base of a video game engine. Here, defined a namespace for the whole game engine, so all the classes and the functions implemented in this Game Engine will be declared under this common namespace. To do more clear definitions you can define another namespace under the global namespace lets say Graphics which is a sub-namespace, now put all classes that perform graphics operations under that namespace and so on.\n• Before C++17:\n\nBelow is the syntax used for nested namespace:\n\nBefore C++17 you have to use this verbose syntax for declaring classes in nested namespaces, but C++17 has introduced a new feature that makes it possible to open nested namespaces without this hectic syntax that require repeated namespace keyword and keeping track of opening and closing braces. In C++17 there a simple and concise syntax using double colons to introduce nested namespaces. The syntax is as follows:\n\nThis makes the code less error-prone as there is no need to pay attention to several levels of braces.\n\nVariable declaration in if and switch\n\nSuppose a vector of strings and you want to replace a string “abc” with “$$$” if it is present in the vector. To do that you can invoke the standard find() function to search for an item in a vector as shown below:\n• The find algorithm will return an iterator pointing to the matched string.\n• Now, if again we want to replace another string with some other string in the same vector, then for this, follow the same approach as shown above, and as you will repeat the same code to just have to change the name of the iterator to something else.\n• As declaring more than two iterators with the same name in the same scope will give a compilation error. The name changing option will work but if there are several strings that need to be replaced, but this approach is not efficient.\n\nWhen C++17: \n\nFor dealing with such cases C++17 gives a better option by declaring variables inside if statements as shown below:\n\nNow the scope of the iterator “it” is within the if statement itself, and the same iterator name can be used to replace other strings too.\n\nThe same thing can be done using a switch statement to using the syntax given below:\n\nBelow is the program that replaces some defined strings in the given vector that runs only in C++17:\n\nThis feature of C++ 17 is very useful when you write template code. The normal if statement condition is executed at run time, so C++17 introduced this new if constexpr statement. The main difference is that if constexpr is evaluated at compile time. Basically, constexpr function is evaluated at compile-time. So why is this important, its main importance goes with template code.\n\nBefore C++17: \n\nSuppose, to compare if an integer variable with a value, then declare and initialize that integer at compile time only before using that variable as shown below:\n\nSuppose you have some template that operates on some generic type T.\n\nSo one aspect of constexpr is that now the compiler knows if T is an integer or not, and the compiler considers only the substatement that satisfies the condition so only that block of code is compiled and the C++ compiler ignores the other substatements.\n\nBelow is the program for the same:\n• In the above code, if the program is compiled then it will give a compilation error because integer has no function called length(), and as we have used only if statement the whole code will be compiled and will give an error.\n• To avoid this kind of error i.e., consider only the code that is important C++17 is for the rescue.\n• So on replacing if with if constexpr, if T is an integer, then only the condition under if constexpr will be compiled (as it satisfies the condition of T to be an integer) and not the else part which contains the length() function (that produced an error).\n• The else block will be considered only when T is not an integer, for example, strings, as it has length() function it will not produce an error and will print length of the string.\n\nBelow is the correct code:\n\nIt basically allows you to declare multiple variables that are initialized with values from pairs, generic tuples or from custom structures and these multiples variable declarations happens in single statements.\n\nBefore C++17, std::tie was used to declare multiple variables that are initialized with values from custom structures.\n\nSuppose you have a dictionary having names as keys and their favorite language as values and this is implemented using standard container map and you want to insert a new entry to it using insert method. This insert method returns an std::pair containing two pieces of information, the first item in the pair is an iterator and the second item is a boolean value.\n\nThere are two cases to consider here:\n• Whether new is not present in the dictionary or it is already present. If the new association (key-value pair) is not present in the dictionary, it gets inserted. So in this case, the returned pair contains an iterator pointing to the new element and the boolean value becomes True.\n• If the new key is already present then the iterator points to the existing key and boolean value becomes False.\n\nNow to write the code to inspect the boolean flag and insertion iterator, first write .first and .second to access elements in pair. C++ 17 can do better for this as:\n• Using C++ 17 structure bindings to declare and initialize two variables with more meaningful names than first and second.\n• Using the names position and success is much clearer than using first and second.\n• The meaning of position and success is very straightforward i.e., position tells about where the iterator is and success tells whether the element is inserted or not.\n\nBelow is the program for the same:\n\nC++11 gave the option of variadic templates to work with variable number of input arguments. Fold expressions are a new way to unpack variadic parameters with operators. The syntax is as follows:\n• (pack op …): This is a right fold that is expanded like pack1 op (… op (packN-1 op packN)).\n• (… op pack): This is a left fold that is expanded like ((pack1 op pack2) op …) op packN.\n• (pack op … op init): This is a binary right fold that is expanded like pack1 op (… op (packN-1 op (packN op init))).\n• (init op … op pack): This is a binary left fold that is expanded like (((init op pack1) op pack2) op …) op packN.\n\nBefore C++17: \n\nTo make a function that takes variable number of arguments and returns the sum of arguments.\n\nWhen C++17:\n\nTo implement a recursive function like sum etc through variadic templates, this becomes efficient with C++17 which is better than C++11 implementations. Below is the template class of the same:\n\nBelow is the program to illustrate the same:\n\nIn C++ 17 initialize initialization of enums using braces is allowed. Below is the syntax for the same:\n\nSome of the library features of C++17:\n• std::byte{b}: It is a unique type that applies the concept of byte as specified in the C++ language definition. A byte is a collection of bits and only bitwise operators can be used in this case. Below is the program to illustrate the same:\n• std::filesystem(): It provides a standard way to manipulate directories and files. In the below example a file a copied to a temporary path if there is available space. Below is the template for the same:\n• std::apply(): Its parameters are a callable object which is to be invoked and a tuple whose elements need to be used as arguments. Below is the template for the same:\n• std::any(): The class any describes a type-safe container for single values of any type.The non-member any cast functions provide type-safe access to the contained object."
    }
]