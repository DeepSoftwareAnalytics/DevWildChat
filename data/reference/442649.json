[
    {
        "link": "https://stackoverflow.com/questions/26107022/how-to-wrap-multiple-select-queries-into-one-query-in-mybatis",
        "document": "How do I return multiple select queries in MyBatis? for example, I want to return a list of 20 users, the total number of users, say 1000. In the following example, I use SQL_CALC_FOUND_ROWS to get the total number before LIMIT applies, and use FOUND_ROWS() to retrieve the cached value in the second select query.\n\nI was thinking of adding another resultMap and didn't find a way to take multiple returns in Java Spring side.\n\nIn the Java side, it was like"
    },
    {
        "link": "https://mybatis.org/mybatis-dynamic-sql/docs/select.html",
        "document": "Select statements are the most complex SQL statements. This library duplicates the syntax of the most common select statements, but purposely does not cover every possibility.\n\nIn general, the following are supported:\n• The typical parts of a select statement including SELECT, DISTINCT, FROM, JOIN, WHERE, GROUP BY, UNION, UNION ALL, ORDER BY, HAVING\n• Tables can be aliased per select statement\n• Columns can be aliased per select statement\n• Equijoins of type INNER, LEFT OUTER, RIGHT OUTER, FULL OUTER\n• Subqueries in where clauses. For example, where foo in (select foo from foos where id < 36)\n• Select from another select. For example select count(*) from (select foo from foos where id < 36)\n\nAt this time, the library does not support the following:\n\nThe user guide page for WHERE Clauses shows examples of many types of SELECT statements with different complexities of the WHERE clause including support for sub-queries. We will just show a single example here, including an ORDER BY clause:\n\nThe WHERE and ORDER BY clauses are optional.\n\nThe library supports the generation of equijoin statements - joins defined by column matching. For example: Notice that you can give an alias to a table if desired. If you don't specify an alias, the full table name will be used in the generated SQL. Multiple tables can be joined in a single statement. For example: Join queries will likely require you to define a MyBatis result mapping in XML. This is the only instance where XML is required. This is due to the limitations of the MyBatis annotations when mapping collections.\n• is an INNER join\n\nThe library supports the generation of UNION and UNION ALL queries. For example: Any number of SELECT statements can be added to a UNION query. Only one ORDER BY phrase is allowed. With this type of union query, the “order by” and paging clauses are applied to the query as a whole. If you need to apply “order by” or paging clauses to the nested queries, use a multi-select query as shown below.\n\nIf you are coding a join, it is likely you will need to code an XML mapper to define the result map. This is due to a MyBatis limitation - the annotations cannot define a collection mapping. If you have to do this, the Java code looks like this: And the corresponding XML looks like this: Notice that the resultMap is the only element in the XML mapper. This is our recommended practice.\n\nWe do not recommend using an XML mapper for select statements, but if you want to do so the SelectStatementProvider object can be used as a parameter to a MyBatis mapper method directly. If you are using an XML mapper, the select method should look like this in the Java interface: The XML element should look like this:\n\nOrder by phrases can be difficult to calculate when there are aliased columns, aliased tables, unions, and joins. This library has taken a relatively simple approach:\n• When specifying an SqlColumn in an ORDER BY phrase the library will either write the column alias or the column name into the ORDER BY phrase. For the ORDER BY phrase, the table alias (if there is one) will be ignored. Use this pattern when the ORDER BY column is a member of the select list. For example . If the column has an alias, then it is easist to use the “arbitrary string” method with the column alias as shown below.\n• It is also possible to explicitly specify a table alias for a column in an ORDER BY phrase. Use this pattern when there is a join, and the ORDER BY column is in two or more tables, and the ORDER BY column is not in the select list. For example .\n• If none of the above use cases meet your needs, then you can specify an arbitrary String to write into the rendered ORDER BY phrase (see below for an example). In our testing, this caused an issue in only one case. When there is an outer join and the select list contains both the left and right join column. In that case, the workaround is to supply a column alias for both columns. When using a column function (lower, upper, etc.), then it is customary to give the calculated column an alias so you will have a predictable result set. In cases like this there will not be a column to use for an alias. The library supports arbitrary values in an ORDER BY expression like this: In this example the function is used in both the select list and the GROUP BY expression. In the ORDER BY expression, we use the function to duplicate the alias given to the column in the select list.\n\nSince version 1.1.1 the select statement supports limit and offset for paging (or slicing) queries. You can specify: It is important to note that the select renderer writes limit and offset clauses into the generated select statement as is. The library does not attempt to normalize those values for databases that don't support limit and offset directly. Therefore, it is very important for users to understand whether or not the target database supports limit and offset. If the target database does not support limit and offset, then it is likely that using this support will create SQL that has runtime errors."
    },
    {
        "link": "https://baeldung.com/mybatis-plus-introduction",
        "document": "MyBatis is a popular open-source persistence framework that provides alternatives to JDBC and Hibernate.\n\nIn this article, we’ll discuss an extension over MyBatis called MyBatis-Plus, loaded with many handy features offering rapid development and better efficiency.\n\nFirst, let’s add the following Maven dependency to our pom.xml.\n\nThe latest version of the Maven dependency can be found here. Since this is the Spring Boot 3-based Maven dependency, we’ll also be required to add the spring-boot-starter dependency to our pom.xml.\n\nAlternatively, we can add the following dependency when using Spring Boot 2:\n\nNext, we’ll add the H2 dependency to our pom.xml for an in-memory database to verify the features and capabilities of MyBatis-Plus.\n\nSimilarly, find the latest version of the Maven dependency here. We can also use MySQL for the integration.\n\nOnce our setup is ready, let’s create the Client entity with a few properties like id, firstName, lastName, and email:\n\nHere, we’ve used MyBatis-Plus’s self-explanatory annotations like @TableName and @TableId for quick integration with the client table in the underlying database.\n\nThen, we’ll create the mapper interface for the Client entity – ClientMapper that extends the BaseMapper interface provided by MyBatis-Plus:\n\nThe BaseMapper interface provides numerous default methods like insert(), selectOne(), updateById(), insertOrUpdate(), deleteById(), and deleteByIds() for CRUD operations.\n\nNext, let’s create the ClientService service interface extending the IService interface:\n\nThe IService interface encapsulates the default implementations of CRUD operations and uses the BaseMapper interface to offer simple and maintainable basic database operations.\n\nIt’s the service implementation for the Client entity, injected with the ClientMapper dependency.\n\nNow that we’ve all the utility interfaces and classes ready, let’s use the ClientService interface to create the Client object:\n\nWe can observe the following logs when saving the client object once we set the logging level to DEBUG for the package com.baeldung.mybatisplus:\n\nThe logs generated by the ClientMapper interface show the insert query with the parameters and final number of rows inserted in the database.\n\nNext, let’s check out a few handy read methods like getById() and list():\n\nSimilarly, we can observe the following SELECT statement in the logs:\n\nAlso, the MyBatis-Plus framework comes with a few handy wrapper classes like QueryWrapper, LambdaQueryWrapper, and QueryChainWrapper:\n\nHere, we’ve used the getBaseMapper() method of the ClientService interface to utilize the wrapper classes to let us write complex queries intuitively.\n\nThen, let’s take a look at a few ways to execute the updates:\n\nFollow the console to check out the following logs:\n\nSimilarly, we can use the LambdaUpdateWrapper class to update the Client objects:\n\nOnce the client objects are updated, we use the QueryWrapper class to confirm the operation.\n\nSimilarly, we can use the removeById() or removeByMap() methods to delete the records:\n\nThe logs for the delete operation would look like this:\n\nSimilar to the update logs, these logs show the delete query with the parameters and total rows deleted from the database.\n\nLet’s discuss a few handy features available in MyBatis-Plus as extensions over MyBatis.\n\nFirst and foremost is the ability to perform common CRUD operations in batches thereby improving performance and efficiency:\n\nLikewise, let’s check out the logs to see the batch inserts in action:\n\nAlso, we’ve got methods like updateBatchById(), saveOrUpdateBatch(), and removeBatchByIds() to perform save, update, or delete operations for a collection of objects in batches.\n\nMyBatis-Plus framework offers an intuitive way to paginate the query results.\n\nAll we need is to declare the MyBatisPlusInterceptor class as a Spring Bean and add the PaginationInnerInterceptor class defined with database type as an inner interceptor:\n\nThen, we can use the Page class to paginate the records. For instance, let’s fetch the second page with three results:\n\nSo, we can observe the following logs for the above operation:\n\nLikewise, these logs show the select query with the parameters and total rows selected from the database.\n\nMyBatis-Plus offers support for streaming queries through methods like selectList(), selectByMap(), and selectBatchIds(), letting us process big data and meet the performance objectives.\n\nFor instance, let’s check out the selectList() method available through the ClientService interface:\n\nHere, we’ve used the getResultObject() method to get every record from the database.\n\nLikewise, we’ve got the getResultCount() method that returns the count of results being processed and the stop() method to halt the processing of the result set.\n\nBeing a fairly opinionated and intelligent framework, MyBatis-Plus also supports automatically filling fields for insert and update operations.\n\nFor example, we can use the @TableField annotation to set the creationDate when inserting a new record and lastModifiedDate in the event of an update:\n\nNow, MyBatis-Plus will fill the creation_date and last_modified_date columns automatically with every insert and update query.\n\nMyBatis-Plus framework offers a simple and efficient strategy to let us logically delete the record by flagging it in the database.\n\nWe can enable the feature by using the @TableLogic annotation over the deleted property:\n\nNow, the framework will automatically handle the logical deletion of the records when performing database operations.\n\nSo, let’s remove the Client object and try to read the same:\n\nObserve the following logs to check out the update query setting the value of the deleted property to 1 and using the 0 value while running the select query on the database:\n\nAlso, it’s possible to modify the default configuration through the application.yml:\n\nThe above configuration lets us to change the name of the delete field with delete and active values.\n\nMyBatis-Plus offers an automatic code generation feature to avoid manually creating redundant code like entity, mapper, and service interfaces.\n\nFirst, let’s add the latest mybatis-plus-generator dependency to our pom.xml:\n\nAlso, we’ll require the support of a template engine like Velocity or Freemarker.\n\nThen, we can use MyBatis-Plus’s FastAutoGenerator class with the FreemarkerTemplateEngine class set as a template engine to connect the underlying database, scan all the existing tables, and generate the utility code:\n\nTherefore, when the above program runs, it’ll generate the output files in the com.baeldung.mybatisplus package:\n\nHere, we’ve asserted that the automatically generated classes/interfaces like Client, ClientMapper, ClientService, and ClientServiceImpl exist at the corresponding paths.\n\nMyBatis-Plus framework allows implementing a custom ID generator using the IdentifierGenerator interface.\n\nFor instance, let’s create the TimestampIdGenerator class and implement the nextId() method of the IdentifierGenerator interface to return the System’s nanoseconds:\n\nNow, we can create the Client object setting the custom ID using the timestampIdGenerator bean:\n\nThe logs will show the custom ID value generated by the TimestampIdGenerator class:\n\nThe long value of id shown in the parameters is the system time in nanoseconds.\n\nWe require to simply extend the SimpleDdl class and override the getSqlFiles() method to return a list of paths of SQL files containing the database migration statements:\n\nThe underlying IdDL interface creates the ddl_history table to keep the history of DDL statements performed on the schema:\n\nNote: this feature works with most databases like MySQL and PostgreSQL, but not H2.\n\nIn this introductory article, we’ve explored MyBatis-Plus – an extension over the popular MyBatis framework, loaded with many developer-friendly opinionated ways to perform CRUD operations on the database.\n\nAlso, we’ve seen a few handy features like batch operations, pagination, ID generation, and DB migration.\n\nThe complete code for this article is available over on GitHub."
    },
    {
        "link": "https://github.com/baomidou/mybatis-plus-samples/blob/master/mybatis-plus-sample-wrapper/src/test/java/com/baomidou/mybatisplus/samples/wrapper/WrapperTest.java",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://mybatis.org/mybatis-3/dynamic-sql.html",
        "document": "One of the most powerful features of MyBatis has always been its Dynamic SQL capabilities. If you have any experience with JDBC or any similar framework, you understand how painful it is to conditionally concatenate strings of SQL together, making sure not to forget spaces or to omit a comma at the end of a list of columns. Dynamic SQL can be downright painful to deal with.\n\nWhile working with Dynamic SQL will never be a party, MyBatis certainly improves the situation with a powerful Dynamic SQL language that can be used within any mapped SQL statement.\n\nThe Dynamic SQL elements should be familiar to anyone who has used JSTL or any similar XML based text processors. In previous versions of MyBatis, there were a lot of elements to know and understand. MyBatis 3 greatly improves upon this, and now there are less than half of those elements to work with. MyBatis employs powerful OGNL based expressions to eliminate most of the other elements:\n\nThe most common thing to do in dynamic SQL is conditionally include a part of a where clause. For example: <select id=\"findActiveBlogWithTitleLike\" resultType=\"Blog\"> SELECT * FROM BLOG WHERE state = ‘ACTIVE’ <if test=\"title != null\"> AND title like #{title} </if> </select> This statement would provide an optional text search type of functionality. If you passed in no title, then all active Blogs would be returned. But if you do pass in a title, it will look for a title like that (for the keen eyed, yes in this case your parameter value would need to include any masking or wildcard characters). What if we wanted to optionally search by title and author? First, I’d change the name of the statement to make more sense. Then simply add another condition. <select id=\"findActiveBlogLike\" resultType=\"Blog\"> SELECT * FROM BLOG WHERE state = ‘ACTIVE’ <if test=\"title != null\"> AND title like #{title} </if> <if test=\"author != null and author.name != null\"> AND author_name like #{author.name} </if> </select>\n\nSometimes we don’t want all of the conditionals to apply, instead we want to choose only one case among many options. Similar to a switch statement in Java, MyBatis offers a choose element. Let’s use the example above, but now let’s search only on title if one is provided, then only by author if one is provided. If neither is provided, let’s only return featured blogs (perhaps a strategically list selected by administrators, instead of returning a huge meaningless list of random blogs). <select id=\"findActiveBlogLike\" resultType=\"Blog\"> SELECT * FROM BLOG WHERE state = ‘ACTIVE’ <choose> <when test=\"title != null\"> AND title like #{title} </when> <when test=\"author != null and author.name != null\"> AND author_name like #{author.name} </when> <otherwise> AND featured = 1 </otherwise> </choose> </select>\n\nThe previous examples have been conveniently dancing around a notorious dynamic SQL challenge. Consider what would happen if we return to our “if” example, but this time we make “ACTIVE = 1” a dynamic condition as well. <select id=\"findActiveBlogLike\" resultType=\"Blog\"> SELECT * FROM BLOG WHERE <if test=\"state != null\"> state = #{state} </if> <if test=\"title != null\"> AND title like #{title} </if> <if test=\"author != null and author.name != null\"> AND author_name like #{author.name} </if> </select> What happens if none of the conditions are met? You would end up with SQL that looked like this: This would fail. What if only the second condition was met? You would end up with SQL that looked like this: SELECT * FROM BLOG WHERE AND title like ‘someTitle’ This would also fail. This problem is not easily solved with conditionals, and if you’ve ever had to write it, then you likely never want to do so again. MyBatis has a simple answer that will likely work in 90% of the cases. And in cases where it doesn’t, you can customize it so that it does. With one simple change, everything works fine: <select id=\"findActiveBlogLike\" resultType=\"Blog\"> SELECT * FROM BLOG <where> <if test=\"state != null\"> state = #{state} </if> <if test=\"title != null\"> AND title like #{title} </if> <if test=\"author != null and author.name != null\"> AND author_name like #{author.name} </if> </where> </select> The where element knows to only insert “WHERE” if there is any content returned by the containing tags. Furthermore, if that content begins with “AND” or “OR”, it knows to strip it off. If the where element does not behave exactly as you like, you can customize it by defining your own trim element. For example, the trim equivalent to the where element is: The prefixOverrides attribute takes a pipe delimited list of text to override, where whitespace relevant. The result is the removal of anything specified in the prefixOverrides attribute, and the insertion of anything in the prefix attribute. There is a similar solution for dynamic update statements called set. The set element can be used to dynamically include columns to update, and leave out others. For example: <update id=\"updateAuthorIfNecessary\"> update Author <set> <if test=\"username != null\">username=#{username},</if> <if test=\"password != null\">password=#{password},</if> <if test=\"email != null\">email=#{email},</if> <if test=\"bio != null\">bio=#{bio}</if> </set> where id=#{id} </update> Here, the set element will dynamically prepend the SET keyword, and also eliminate any extraneous commas that might trail the value assignments after the conditions are applied. Alternatively, you can achieve the same effect by using trim element: Notice that in this case we’re overriding a suffix, while we’re still appending a prefix.\n\nAnother common necessity for dynamic SQL is the need to iterate over a collection, often to build an IN condition. For example: <select id=\"selectPostIn\" resultType=\"domain.blog.Post\"> SELECT * FROM POST P <where> <foreach item=\"item\" index=\"index\" collection=\"list\" open=\"ID in (\" separator=\",\" close=\")\" nullable=\"true\"> #{item} </foreach> </where> </select> The foreach element is very powerful, and allows you to specify a collection, declare item and index variables that can be used inside the body of the element. It also allows you to specify opening and closing strings, and add a separator to place in between iterations. The element is smart in that it won’t accidentally append extra separators. NOTE You can pass any Iterable object (for example List, Set, etc.), as well as any Map or Array object to foreach as collection parameter. When using an Iterable or Array, index will be the number of current iteration and value item will be the element retrieved in this iteration. When using a Map (or Collection of Map.Entry objects), index will be the key object and item will be the value object. This wraps up the discussion regarding the XML configuration file and XML mapping files. The next section will discuss the Java API in detail, so that you can get the most out of the mappings that you’ve created.\n\nStarting from version 3.2 MyBatis supports pluggable scripting languages, so you can plug a language driver and use that language to write your dynamic SQL queries. You can plug a language by implementing the following interface: Once you have your custom language driver you can set it to be the default by configuring it in the mybatis-config.xml file: Instead of changing the default, you can specify the language for an specific statement by adding the attribute as follows: Or, in the case you are using mappers, using the annotation: NOTE You can use Apache Velocity as your dynamic language. Have a look at the MyBatis-Velocity project for the details. All the xml tags you have seen in the previous sections are provided by the default MyBatis language that is provided by the driver which is aliased as ."
    },
    {
        "link": "https://mybatis.org/mybatis-dynamic-sql/docs/select.html",
        "document": "Select statements are the most complex SQL statements. This library duplicates the syntax of the most common select statements, but purposely does not cover every possibility.\n\nIn general, the following are supported:\n• The typical parts of a select statement including SELECT, DISTINCT, FROM, JOIN, WHERE, GROUP BY, UNION, UNION ALL, ORDER BY, HAVING\n• Tables can be aliased per select statement\n• Columns can be aliased per select statement\n• Equijoins of type INNER, LEFT OUTER, RIGHT OUTER, FULL OUTER\n• Subqueries in where clauses. For example, where foo in (select foo from foos where id < 36)\n• Select from another select. For example select count(*) from (select foo from foos where id < 36)\n\nAt this time, the library does not support the following:\n\nThe user guide page for WHERE Clauses shows examples of many types of SELECT statements with different complexities of the WHERE clause including support for sub-queries. We will just show a single example here, including an ORDER BY clause:\n\nThe WHERE and ORDER BY clauses are optional.\n\nThe library supports the generation of equijoin statements - joins defined by column matching. For example: Notice that you can give an alias to a table if desired. If you don't specify an alias, the full table name will be used in the generated SQL. Multiple tables can be joined in a single statement. For example: Join queries will likely require you to define a MyBatis result mapping in XML. This is the only instance where XML is required. This is due to the limitations of the MyBatis annotations when mapping collections.\n• is an INNER join\n\nThe library supports the generation of UNION and UNION ALL queries. For example: Any number of SELECT statements can be added to a UNION query. Only one ORDER BY phrase is allowed. With this type of union query, the “order by” and paging clauses are applied to the query as a whole. If you need to apply “order by” or paging clauses to the nested queries, use a multi-select query as shown below.\n\nIf you are coding a join, it is likely you will need to code an XML mapper to define the result map. This is due to a MyBatis limitation - the annotations cannot define a collection mapping. If you have to do this, the Java code looks like this: And the corresponding XML looks like this: Notice that the resultMap is the only element in the XML mapper. This is our recommended practice.\n\nWe do not recommend using an XML mapper for select statements, but if you want to do so the SelectStatementProvider object can be used as a parameter to a MyBatis mapper method directly. If you are using an XML mapper, the select method should look like this in the Java interface: The XML element should look like this:\n\nOrder by phrases can be difficult to calculate when there are aliased columns, aliased tables, unions, and joins. This library has taken a relatively simple approach:\n• When specifying an SqlColumn in an ORDER BY phrase the library will either write the column alias or the column name into the ORDER BY phrase. For the ORDER BY phrase, the table alias (if there is one) will be ignored. Use this pattern when the ORDER BY column is a member of the select list. For example . If the column has an alias, then it is easist to use the “arbitrary string” method with the column alias as shown below.\n• It is also possible to explicitly specify a table alias for a column in an ORDER BY phrase. Use this pattern when there is a join, and the ORDER BY column is in two or more tables, and the ORDER BY column is not in the select list. For example .\n• If none of the above use cases meet your needs, then you can specify an arbitrary String to write into the rendered ORDER BY phrase (see below for an example). In our testing, this caused an issue in only one case. When there is an outer join and the select list contains both the left and right join column. In that case, the workaround is to supply a column alias for both columns. When using a column function (lower, upper, etc.), then it is customary to give the calculated column an alias so you will have a predictable result set. In cases like this there will not be a column to use for an alias. The library supports arbitrary values in an ORDER BY expression like this: In this example the function is used in both the select list and the GROUP BY expression. In the ORDER BY expression, we use the function to duplicate the alias given to the column in the select list.\n\nSince version 1.1.1 the select statement supports limit and offset for paging (or slicing) queries. You can specify: It is important to note that the select renderer writes limit and offset clauses into the generated select statement as is. The library does not attempt to normalize those values for databases that don't support limit and offset directly. Therefore, it is very important for users to understand whether or not the target database supports limit and offset. If the target database does not support limit and offset, then it is likely that using this support will create SQL that has runtime errors."
    },
    {
        "link": "https://stackoverflow.com/questions/28888375/run-a-query-with-a-limit-offset-and-also-get-the-total-number-of-rows",
        "document": "Be aware that the cost will be substantially higher than without the total number. Postgres has to actually count all qualifying rows either way, which imposes a cost depending on the total number. See:\n• Best way to get result count before LIMIT was applied\n\nTwo separate queries (one for the result set, one for the total count) may or may not be faster. But the overhead of executing two separate queries and processing results often tips the scales. Depends on the nature of the query, indexes, resources, cardinalities ...\n\nHowever, as Dani pointed out, when is at least as great as the number of rows returned from the base query, no rows are returned. So we get no , either. If that's a rare case, just run a second query for the count in this case.\n\n If that's not acceptable, here is a single query always returning the full count, with a CTE and an . This adds more overhead and only makes sense for certain cases (expensive filters, few qualifying rows).\n\n① Typically it does not pay to add (the same) in the CTE. That forces all rows to be sorted. With , typically only a small fraction has to be sorted (with \"top-N heapsort\").\n\nYou get one row of null values, with the appended if is too big. Else, it's appended to every row like in the first query.\n\nIf a row with all null values is a possible valid result you have to check to disambiguate the origin of the empty row.\n\nThis still executes the base query only once. But it adds more overhead to the query and only pays if that's less than repeating the base query for the count.\n\nEither way, the total count is returned with every row (redundantly). Doesn't add much cost. But if that's an issue, you could instead ...\n\nThe added row must match the row type of the query result, and the count must fit into the data type of one of the columns. A bit of a hack. Like:\n\nAgain, sometimes it may be cheaper to just run a separate count (still in a single query!):\n• Is there a shortcut for SELECT * FROM?"
    },
    {
        "link": "https://stackoverflow.com/questions/1400078/is-it-possible-to-specify-condition-in-count",
        "document": "Is it possible to specify a condition in ? I would like to count only the rows that have, for example, \"Manager\" in the Position column.\n\nI want to do it in the count statement, not using ; I'm asking about it because I need to count both Managers and Other in the same (something like so is no use for me in this example."
    },
    {
        "link": "https://duhong2016.medium.com/use-mybatis-plus-to-generate-all-types-of-curd-operation-9c62e0fefdd4",
        "document": "\n• put mybatis plus maven dependency in pom.xml. To avoid any conflict, don't put other mybatis related dependency like mybatis-spring-boot-starter\n• Configure data source and logger (to print out executing sql) in yml\n\nBy extending the BaseMapper, CRUD implementations are by default there so we won’t add more in this demo. We will deep into that part soon.\n\nThe BaseMapper provides the below:\n• select by list of (batch of) ids\n• select with like and less than condition\n• select with between and not null condition\n• select with specified date format and subquery\n• select without certain columns but the rest\n• select with pass-in fields all equal, if the field is null, ignore"
    },
    {
        "link": "https://datacamp.com/tutorial/count-sql-function",
        "document": "Accompanied at every step with hands-on practice queries, this course teaches you everything you need to know to analyze data using your own SQL code today!"
    }
]