[
    {
        "link": "https://realpython.com/python-for-loop",
        "document": "Python’s loop allows you to iterate over the items in a collection, such as lists, tuples, strings, and dictionaries. The loop syntax declares a loop variable that takes each item from the collection in each iteration. This loop is ideal for repeatedly executing a block of code on each item in the collection. You can also tweak loops further with features like , , and .\n\nBy the end of this tutorial, you’ll understand that:\n• Python’s loop iterates over items in a data collection, allowing you to execute code for each item.\n• To iterate from to , you use the construct.\n• To repeat code a number of times without processing the data of an iterable, use the construct.\n• To do index-based iteration, you can use for index, value in enumerate(iterable): to access both index and item.\n\nIn this tutorial, you’ll gain practical knowledge of using loops to traverse various collections and learn Pythonic looping techniques. Additionally, you’ll learn how to handle exceptions and how to use asynchronous iterations to make your Python code more robust and efficient.\n\nGetting Started With the Python Loop In programming, loops are control flow statements that allow you to repeat a given set of operations a number of times. In practice, you’ll find two main types of loops:\n• loops are mostly used to iterate a known number of times, which is common when you’re processing data collections with a specific number of data items.\n• loops are commonly used to iterate an unknown number of times, which is useful when the number of iterations depends on a given condition. Python has both of these loops and in this tutorial, you’ll learn about loops. In Python, you’ll generally use loops when you need to iterate over the items in a data collection. This type of loop lets you traverse different data collections and run a specific group of statements on or with each item in the input collection. In Python, loops are compound statements with a header and a code block that runs a predefined number of times. The basic syntax of a loop is shown below: In this syntax, is the loop variable. In each iteration, this variable takes the value of the current item in , which represents the data collection you need to iterate over. The loop body can consist of one or more statements that must be indented properly. Here’s a more detailed breakdown of this syntax:\n• is the keyword that initiates the loop header.\n• is a variable that holds the current item in the input iterable.\n• is a keyword that connects the loop variable with the iterable.\n• is a data collection that can be iterated over.\n• consists of one or more statements to execute in each iteration. Here’s a quick example of how you can use a loop to iterate over a list: In this example, is the loop variable, while the list is the target collection. Each time through the loop, takes on a successive item from . In this loop, the body consists of a call to that displays the value on the screen. This loop runs once for each item in the target iterable. The way the code above is written is the Pythonic way to write it. However, what’s an iterable anyway? In Python, an iterable is an object—often a data collection—that can be iterated over. Common examples of iterables in Python include lists, tuples, strings, dictionaries, and sets, which are all built-in data types. You can also have custom classes that support iteration. Note: Python has both iterables and iterators. Iterables support the iterable protocol consisting of the special method. Similarly, iterators support the iterator protocol that’s based on the and special methods. Both iterables and iterators can be iterated over. All iterators are iterables, but not all iterables are iterators. Python iterators play a fundamental role in loops because they drive the iteration process. A deeper discussion on iterables and iterators is beyond the scope of this tutorial. However, to learn more about them, check out the Iterators and Iterables in Python: Run Efficient Iterations tutorial. You can also have a loop with multiple loop variables: In this loop, you have two loop variables, and . Note that to use this syntax, you just need to provide a tuple of loop variables. Also, you can have as many loop variables as you need as long as you have the correct number of items to unpack into them. You’ll also find this pattern useful when iterating over dictionary items or when you need to do parallel iteration. Sometimes, the input iterable may be empty. In that case, the loop will run its header once but won’t execute its body: In this example, the target iterable is an empty list. The loop checks whether the iterable has items. If that’s the case, then the loop runs once for each item. If the iterable has no items, then the loop body doesn’t run, and the program’s execution flow jumps onto the statement after the loop. Now that you know the basic syntax of loops, it’s time to dive into some practical examples. In the following section, you’ll learn how to use loops with the most common built-in data collections in Python.\n\nWhen writing Python code, you’ll often need to iterate over built-in data types such as lists, tuples, strings, numeric ranges, dictionaries, and sets. All of them support iteration, and you can feed them into a loop. In the next sections, you’ll learn how to tackle this requirement in a Pythonic way. When it comes to iterating over sequence data types like lists, tuples, strings, and ranges, the iteration happens in the same order that the items appear in the sequence. Consider the following example where you iterate over the numbers in a list: In this example, the iteration goes through the list in the definition order, starting with and ending with . Note that to iterate over a sequence in Python, you don’t need to be aware of the index of each item as in other languages where loops often rely on indices. Often, you use plural nouns to name lists. This naming practice allows you to use singular nouns as the loop variable, making your code descriptive and readable. Note: To learn more about using lists, check out Python’s Data Type: A Deep Dive With Examples. You’ll note the same behavior with other built-in sequences: In these examples, you iterate over a tuple, string, and numeric range. Again, the loop traverses the sequence in the order of definition. Note: For more information about tuples, strings, and ranges, you can check out the following tutorials: Tuples are often used to represent rows of data. In the example above, the tuple holds data about a person. You can iterate over each field using a readable loop. When it comes to iterating over string objects, the loop lets you process the string on a character-by-character basis. Finally, iterating over a numeric range is sometimes a requirement, especially when you need to iterate a given number of times and need control over the consecutive index. When traversing dictionaries with a loop, you’ll find that you can iterate over the keys, values, and items of the dictionary at hand. Note: To learn more about dictionary iteration, check out the How to Iterate Through a Dictionary in Python tutorial. You’ll have two different ways to iterate over the keys of a dictionary. You can either use: The following examples show how to use these two approaches: In these examples, you first iterate over the keys of a dictionary using the dictionary directly in the loop header. In the second loop, you use the method to iterate over the keys. While both approaches are equivalent, the first one is more commonly used, whereas the second might be more readable and explicit. In both loops, you can access the dictionary values using the keys: To access the values in this type of iteration, you can use the original dictionary and a key lookup operation, as shown in the highlighted line. You can use the method to feed the loop when you need to iterate over the values of a dictionary: The method lets you traverse the values in the target dictionary. In this example, you iterate over team names one by one. Note that when you use the method, you can’t access the dictionary keys. Finally, iterating over both keys and values in a Python dictionary is a common requirement. In this case, the recommended and most Pythonic approach is to use the method in a loop like the following: When iterating over keys and values this way, you typically use a tuple of loop variables. The first variable will get the key, while the second will get the associated value. In this example, you have the and variables, which make the code clear and readable. When it comes to iterating over sets, you only have to keep in mind that sets are unordered data types. This means that looping in order isn’t guaranteed: As you can see, the loop goes through the elements of your set in a different order than they were inserted. So, you can’t rely on the order of the elements when traversing sets in Python.\n\nThe Python loop has some advanced features that make it flexible and powerful. These features can be helpful when you need to fine-tune the loop to meet specific execution flows. These features include the and statements and the clause, which you’ll learn about in the following sections. You’ll also learn that loops can be nested inside one another. This feature can be pretty useful in situations where you need to iterate over nested data structures like lists of lists. The statement immediately exits the loop and jumps to the first statement after the loop. For example, say that you want to write a loop to determine whether a number is in a list. To avoid unnecessary work, the loop should terminate once it finds the target value. You can do this with the statement: In this example, the statement jumps out of the loop as soon as the target number is found. The remaining values, and , aren’t processed. You can think of the statement as a way to short-circuit the loop execution once you’ve gotten the desired result. It’s important to note that it makes little sense to have statements outside conditionals. Suppose you include a statement directly in the loop body without wrapping it in a conditional. In that case, the loop will terminate in the first iteration, potentially without running the entire loop body. The statement terminates the current iteration and proceeds to the next one. For example, if you have a list of numbers and only want to process the even ones, you can use a statement to skip the odd numbers: In this example, the code that processes the numbers is only reached if the number is even. Otherwise, the statement skips that code and jumps right into the next iteration. Again, it doesn’t make much sense to have a statement without wrapping it in a conditional. If you do so, the code after the statement will be unreachable and never run. In Python, loops can have an clause at the end. The clause will only run if the loop terminates because of the exhaustion of the input iterable. This feature is useful when you have a statement that can terminate the loop in certain situations. If the loop doesn’t break, then you can run additional code in the clause. To illustrate, say that you want to continue improving the loop that determines whether a number is in a list. You’d like to explicitly inform the user if the number isn’t in the list. You can do this with the clause: The clause won’t run if the loop breaks out with the statement. It only runs if the loop terminates normally, allowing you to inform the user that the target number wasn’t found. It doesn’t make sense to have an clause in a loop that doesn’t have a statement. In that case, placing the block’s content after the loop—without indentation—will work the same and be cleaner. You can also have nested loops. In the example below, you create a multiplication table that shows the products of all combinations of integers up to ten using nested loops. The outer loop iterates over the numbers between and , and the inner loop calculates and prints the products: In this example, you use two nested loops. Together, they create a two-dimensional multiplication table. First, you loop over the numbers from one up to and including ten. These represent the rows in the table, and you can see those numbers at the beginning of each row. In the inner loop, you calculate the products for the current by iterating from the itself up to its tenth multiple. Then, you format each product using the format specifier. This ensures the table is nicely aligned. By setting to an empty string, you skip the newline until the products on the current row are printed. After printing all products for a row, you use without arguments to move to the next row.\n\nWhen people switch from other programming languages to Python, they often write loops like they did in their previous language. This practice makes Python code look odd and hard to read. In the following sections, you’ll explore some looping techniques, practices, and tips that are considered Pythonic. These techniques can make your Python code look clearer, more elegant, and more efficient. Iterating With Indices: The Pythonic Way Sometimes, you need to use the indices of items when you iterate over a sequence with a Python loop. Up to this point, you’ve seen examples where you can access the items but don’t know their corresponding indices. To get both the item and its index, you can end up writing a loop like the one shown in the following example: This loop gets the job done, but it’s not as clean or readable as you’d expect from Python code. Fortunately, there’s a better way—the built-in function: The function takes an iterable as an argument and generates tuples of the form . Note that the loop reads almost like plain English, which makes your code way more Pythonic than the previous version using . Note: To learn more about working with , check out the Python : Simplify Loops That Need Counters tutorial. The function also takes an optional argument called that lets you tweak the initial value. This feature is useful when you need to create counts. Consider the following example that mimics an option menu for a command-line application: In this example, instead of using to produce zero-based indices, you start the count at . From the end user’s perspective, starting the menu at is the natural way to go. Looping Over Several Iterables in Parallel Looping through two or more iterables in parallel may be another common task you encounter in Python programming. To do this, you can use the built-in function, which takes two or more iterables and yields tuples that combine items from each iterable. Note: To learn more about , check out the Using the Python zip() Function for Parallel Iteration tutorial. Consider the following toy example: In this example, you use to create an iterator that produces tuples of the form . In this case, the values are taken from , and the values are taken from . There may be times when you need to iterate over multiple iterables sequentially in a single loop. In such cases, you can use the function from Python’s module. Note: To learn more about the module and the tools it provides, check out the Python By Example tutorial. For example, say that you have several lists of numbers and want to calculate the square of each number in all lists. You can use as follows: This loops over all three lists in sequence and prints the square of each value. You can also use to work through a list of lists. Say that you, again, need to process each value in a sequence and calculate its square: In this example, you use to iterate over the rows of the matrix. To feed the rows into , you use the unpacking operator ( ). Inside the loop, you calculate and print the square of each value. Using , like in this example, essentially flattens the matrix into a single iterable, helping you avoid a nested loop, which can be difficult to read and understand in some contexts. Iteration is all about repeating some fragment of code multiple times. As you’ve learned so far, loops are designed to repeat a given set of actions on the items of an iterable. However, you can also use this type of loop to quickly iterate a specific number of times. This is useful when you need to repeat a bunch of statements, but they don’t operate on the items of an iterable. Here’s a fun example about Penny and Sheldon to illustrate this: This loop runs three times and repeats a series of statements that don’t operate on any iterable. Note that the loop variable is a single underscore character in this example. This variable name communicates that you don’t need to use the loop variable inside the loop. It’s a throwaway variable. With this looping construct that takes advantage of , you have full control over the number of times your code runs. Iterating over the items of an iterable in reverse or sorted order is also a common requirement in programming. To achieve this, you can combine a loop with the built-in or function, respectively. Note: To learn more about and , check out the following tutorials:\n• Reverse Strings in Python: , Slicing, and More\n• How to Use and in Python For example, say that you’re working on a text editor and want to implement a basic Undo option. You can implement it with the function and a loop like the following: In this example, you have a list of hypothetical user actions in a text editor. The actions are stored in a list from oldest to newest. To implement the Undo operation, you need to reverse the actions, which you do with . To iterate in sorted order, say that you have a dictionary that maps student names to their corresponding average grades. You need to create a quick report and want to sort the data from highest to lowest grades. For this, you can do something like the following: The function returns a list of sorted values. In this example, you sort the dictionary by its values in ascending order. To do this, you use a function that takes a two-value tuple as an argument and returns the second item, which has an index of . You also set the argument to so that the function stores the data in reverse order. In this case, this means that the grades are ordered in descending order. The loop iterates over the sorted data and generates a nicely formatted report using an f-string with a custom format specifier.\n\nWhen working with loops in your Python code, you may encounter some issues related to incorrect ways to use this tool. Some of the most common bad practices and incorrect assumptions include:\n• Modifying the loop collection or iterable during iteration\n• Changing the loop variable to affect the underlying collection\n• Ignoring possible exceptions that may occur In the following sections, you’ll explore these pitfalls and how to avoid them in your loops. Python has mutable collections, such as lists and dictionaries, that you can modify in place. You may want to change a list while looping over it. In this situation, you need to distinguish between safe and unsafe changes. For example, say that you have a list of names and want to convert them into uppercase. You may think of doing something like the following: In this example, you only change the existing items in the list without adding or removing any. This operation is safe. However, modifying a mutable iterable like a list while iterating over it always raises a warning. Issues may appear when you add or remove items from a list while iterating over it. To understand why this is best avoided, say that you want to remove all the even numbers from a list. You might write the following code: After running the loop, some even numbers remain, even though you expected the list to be empty. On the first iteration, is removed, and the list shifts left, becoming . The loop then jumps to the next item, skipping and processing instead. Then is removed, and the list shifts again, becoming . The iteration ends before reaching . When you need to resize a list during iteration like in the example above, it’s recommended to create a copy of the list: The slicing operator ( ) with no indices creates a copy of the original list for iteration purposes. The loop traverses the copy while removing values from the original list. In some cases, creating a copy of the input list isn’t enough. Say that on top of removing even numbers, you want to calculate the square of odd numbers. You might modify the previous loop as shown in the following code: This time, you use to generate index-item pairs. Then, you think of using the index to update the value of a given item. However, the code fails with a exception. Creating a copy of the input list isn’t enough in this case. You’d have to make a separate list to store the result: In this new loop implementation, you’re using a new list to store the result. Because of this, you don’t have to remove items anymore. You add the square values to the end of the new list using the method. Python doesn’t allow you to add or remove items from a dictionary while you’re iterating through it: If you try to expand or shrink a dictionary during iteration, you get a exception. Again, you can work around this by creating a copy of the dictionary using the method or by building a new dictionary with the resulting data. Changing the loop variable in the loop body doesn’t have an effect on the original data: In this example, the highlighted line changes the loop variable, . This change doesn’t affect the original data in your list of names. The loop variable is just a temporary reference to the current item in the iterable, and reassigning it doesn’t affect the loop iterable. If an exception occurs in a loop body and isn’t handled, the loop will terminate prematurely, skipping subsequent iterations. This result can generate unexpected issues, especially when you rely on the loop to process data, perform logging, or run cleanup actions in each iteration. As an example, say that you want to process some text files in a loop: : [Errno 2] No such file or directory: 'file1.txt' In this example, none of the files exist in your working directory. The loop tries to process the first file and fails with a exception. Because the exception wasn’t handled properly, the loop terminates in the first iteration, skipping the rest of the files in the list. To avoid this behavior, you need to catch and handle the exception: In this new implementation, the loop catches any exception and prints an error message to the screen. The loop runs entirely without abrupt interruptions."
    },
    {
        "link": "https://geeksforgeeks.org/python-for-loops",
        "document": "Python For Loops are used for iterating over a sequence like lists, tuples, strings, and ranges.\n• None For loop allows you to apply the same operation to every item within loop.\n• None Using For Loop avoid the need of manually managing the index.\n• None For loop can iterate over any iterable object, such as dictionary, list or any custom iterators.\n\nNote: In Python, for loops only implement the collection-based iteration.\n\nThis code uses a for loop to iterate over a string and print each character on a new line. The loop assigns each character to the variable i and continues until all characters in the string have been processed.\n\nUsing range() with For Loop\n\nThe range() function is commonly used with for loops to generate a sequence of numbers. It can take one, two, or three arguments:\n• range(start, stop, step): Generates numbers from start to stop-1, incrementing by step.\n\nLoop control statements change execution from their normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed. Python supports the following control statements.\n\nPython continue Statement returns the control to the beginning of the loop.\n\nPython break statement brings control out of the loop.\n\nThe pass statement to write empty loops. Pass is also used for empty control statements, functions, and classes.\n\nElse Statement with For Loops\n\nPython also allows us to use the else condition for loops. The else block just after for/while is executed only when the loop is NOT terminated by a break statement.\n\nUsing Enumerate with for loop\n\nIn Python, enumerate() function is used with the for loop to iterate over an iterable while also keeping track of index of each item.\n\nThis code uses nested for loops to iterate over two ranges of numbers (1 to 3 inclusive) and prints the value of i and j for each combination of these two loops. \\\n\nThe inner loop is executed for each value of i in outer loop. The output of this code will print the numbers from 1 to 3 three times, as each value of i is combined with each value of j.\n\nBelow are two Exercise Questions on Python for-loops. We have covered continue statement and range() function in these exercise questions.\n\nWhat is syntax of for loop in Python?\n\nHow to iterate with an index in a for loop in Python?\n\nCan you provide examples of for loops in Python?\n\nSure! Here are some examples of for loops in Python: # Example 1: Iterating over a list fruits = ['apple', 'banana', 'cherry'] for fruit in fruits: print(fruit) # Example 2: Iterating over a string for char in 'Python': print(char) # Example 3: Using enumerate to get index and value for index, num in enumerate([10, 20, 30]): print(f'Index {index}: {num}') # Example 4: Iterating over a dictionary person = {'name': 'John', 'age': 30} for key, value in person.items(): print(f'{key}: {value}')\n\nHow to write a for loop in Python?\n\nHow to use for loops in Python?"
    },
    {
        "link": "https://w3schools.com/python/python_iterators.asp",
        "document": "An iterator is an object that contains a countable number of values.\n\nAn iterator is an object that can be iterated upon, meaning that you can traverse through all the values.\n\nTechnically, in Python, an iterator is an object which implements the iterator protocol, which consist of the methods and .\n\nLists, tuples, dictionaries, and sets are all iterable objects. They are iterable containers which you can get an iterator from.\n\nAll these objects have a method which is used to get an iterator:\n\nEven strings are iterable objects, and can return an iterator:\n\nWe can also use a loop to iterate through an iterable object:\n\nThe loop actually creates an iterator object and executes the method for each loop.\n\nTo create an object/class as an iterator you have to implement the methods and to your object.\n\nAs you have learned in the Python Classes/Objects chapter, all classes have a function called , which allows you to do some initializing when the object is being created.\n\nThe method acts similar, you can do operations (initializing etc.), but must always return the iterator object itself.\n\nThe method also allows you to do operations, and must return the next item in the sequence.\n\nThe example above would continue forever if you had enough next() statements, or if it was used in a loop.\n\nTo prevent the iteration from going on forever, we can use the statement.\n\nIn the method, we can add a terminating condition to raise an error if the iteration is done a specified number of times:"
    },
    {
        "link": "https://w3schools.com/python/python_for_loops.asp",
        "document": "A for loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string).\n\nThis is less like the for keyword in other programming languages, and works more like an iterator method as found in other object-orientated programming languages.\n\nWith the for loop we can execute a set of statements, once for each item in a list, tuple, set etc.\n\nThe for loop does not require an indexing variable to set beforehand.\n\nEven strings are iterable objects, they contain a sequence of characters:\n\nWith the break statement we can stop the loop before it has looped through all the items:\n\nWith the continue statement we can stop the current iteration of the loop, and continue with the next:\n\nTo loop through a set of code a specified number of times, we can use thefunction,\n\nThe range() function returns a sequence of numbers, starting from 0 by default, and increments by 1 (by default), and ends at a specified number.\n\nThe range() function defaults to 0 as a starting value, however it is possible to specify the starting value by adding a parameter: range(2, 6), which means values from 2 to 6 (but not including 6):\n\nThe range() function defaults to increment the sequence by 1, however it is possible to specify the increment value by adding a third parameter: range(2, 30, 3):\n\nElse in For Loop\n\nThe keyword in a loop specifies a block of code to be executed when the loop is finished:\n\nThe \"inner loop\" will be executed one time for each iteration of the \"outer loop\":\n\nloops cannot be empty, but if you for some reason have a loop with no content, put in the statement to avoid getting an error."
    },
    {
        "link": "https://stackoverflow.com/questions/29403401/python-for-loop-and-iterator-behavior",
        "document": "We use for statement for looping over a list.\n\nIf we use it with a string, it loops over its characters.\n\nIf we use it with a dictionary, it loops over its keys.\n\nIf we use it with a file, it loops over lines of the file.\n\nSo there are many types of objects which can be used with a for loop. These are called iterable objects.\n\nThere are many functions which consume these iterables.\n\nThe built-in function iter takes an iterable object and returns an iterator.\n\nEach time we call the next method on the iterator gives us the next element. If there are no more elements, it raises a StopIteration.\n\nIterators are implemented as classes. Here is an iterator that works like built-in xrange function.\n\nThe iter method is what makes an object iterable. Behind the scenes, the iter function calls iter method on the given object.\n\nThe return value of iter is an iterator. It should have a next method and raise StopIteration when there are no more elements.\n\nLets try it out:\n\nIn the above case, both the iterable and iterator are the same object. Notice that the iter method returned self. It need not be the case always.\n\nIf both iteratable and iterator are the same object, it is consumed in a single iteration.\n\nGenerators simplifies creation of iterators. A generator is a function that produces a sequence of results instead of a single value.\n\nEach time the yield statement is executed the function generates a new value.\n\nSo a generator is also an iterator. You don’t have to worry about the iterator protocol.\n\nThe word “generator” is confusingly used to mean both the function that generates and what it generates. In this chapter, I’ll use the word “generator” to mean the generated object and “generator function” to mean the function that generates it.\n\nCan you think about how it is working internally?\n\nWhen a generator function is called, it returns a generator object without even beginning execution of the function. When next method is called for the first time, the function starts executing until it reaches yield statement. The yielded value is returned by the next call.\n\nThe following example demonstrates the interplay between yield and call to next method on generator object.\n\nLets see an example:"
    },
    {
        "link": "https://realpython.com/python-while-loop",
        "document": "Python’s loop enables you to execute a block of code repeatedly as long as a given condition remains true. Unlike loops, which iterate a known number of times, loops are ideal for situations where the number of iterations isn’t known upfront.\n\nLoops are a pretty useful construct in Python, so learning how to write and use them is a great skill for you as a Python developer.\n\nBy the end of this tutorial, you’ll understand that:\n• is a Python keyword used to initiate a loop that repeats a block of code as long as a condition is true.\n• A loop works by evaluating a condition at the start of each iteration. If the condition is true, then the loop executes. Otherwise, it terminates.\n• loops are useful when the number of iterations is unknown, such as waiting for a condition to change or continuously processing user input.\n• in Python creates an infinite loop that continues until a statement or external interruption occurs.\n• Python lacks a built-in do-while loop, but you can emulate it using a loop with a statement for conditional termination.\n\nWith this knowledge, you’re prepared to write effective loops in your Python programs, handling a wide range of iteration needs.\n\nIn programming, loops are control flow statements that allow you to repeat a given set of operations a number of times. In practice, you’ll find two main types of loops:\n• loops are mostly used to iterate a known number of times, which is common when you’re processing data collections with a specific number of data items.\n• loops are commonly used to iterate an unknown number of times, which is useful when the number of iterations depends on a given condition. Python has both of these loops and in this tutorial, you’ll learn about loops. In Python, you’ll generally use loops when you need to repeat a series of tasks an unknown number of times. Python loops are compound statements with a header and a code block that runs until a given condition becomes false. The basic syntax of a loop is shown below: In this syntax, is an expression that the loop evaluates for its truth value. If the condition is true, then the loop body runs. Otherwise, the loop terminates. Note that the loop body can consist of one or more statements that must be indented properly. Here’s a more detailed breakdown of this syntax:\n• is the keyword that initiates the loop header.\n• is an expression evaluated for truthiness that defines the exit condition.\n• consists of one or more statements to execute in each iteration. Here’s a quick example of how you can use a loop to iterate over a decreasing sequence of numbers: In this example, is the loop condition. If this condition returns a false value, the loop terminates. The body consists of a call to that displays the value on the screen. Next, you decrease the value of . This change will produce a different result when the loop evaluates the condition in the next iteration. The loop runs while the condition remains true. When the condition turns false, the loop terminates, and the program execution proceeds to the first statement after the loop body. In this example, the loop terminates when reaches a value less than or equal to . If the loop condition doesn’t become false, then you have a potentially infinite loop. Consider the following loop, and keep your fingers near the + key combination to terminate its execution: In this example, the loop condition is . This condition works when you decrease by . However, if you decrease it by 2, the condition may never become false, resulting in a potentially infinite loop. In such cases, you can usually terminate the loop by pressing + , which raises a exception on most operating systems. Note that the loop checks its condition first before anything else happens. If it’s false to start with, then the loop body will never run: In this example, when the loop finds that isn’t greater than , it immediately terminates the execution without entering the loop body. So, the body never executes. Now that you know the basic syntax of loops, it’s time to dive into some practical examples in Python. In the next section, you’ll see how these loops can be applied to real-world scenarios.\n\nThe Python loop has some advanced features that make it flexible and powerful. These features can be helpful when you need to fine-tune the loop to meet specific execution flows. So far, you’ve seen examples where the entire loop body runs on each iteration. Python provides two keywords that let you modify that behavior:\n• : Immediately terminates a loop. The program execution then proceeds with the first statement following the loop body.\n• : Ends only the current iteration. The execution jumps back to the loop header, and the loop condition is evaluated to determine whether the loop will execute again. Python’s loops also have additional syntax. They have an clause that runs when the loop terminates naturally because the condition becomes true. In the following sections, you’ll learn more about how the and statements work, as well as how to use the clause effectively in loops. With the statement, you can terminate the execution of a loop and make your program continue with the first statement immediately after the loop body. Here’s a short script that demonstrates how the statement works: When becomes , the statement is reached, and the loop terminates completely. The program execution jumps to the call to in the final line of the script. Running from the command line produces the following output: The loop prints values normally. When reaches the value of , then runs, terminating the loop and printing to your screen. Note that and aren’t printed at all. It’s important to note that it makes little sense to have statements outside of conditionals. Suppose you include a statement directly in the loop body without wrapping it in a conditional. In that case, the loop will terminate in the first iteration, potentially without running the entire loop body. The Statement: Skipping Tasks in an Iteration Next, you have the statement. With this statement, you can skip some tasks in the current iteration when a given condition is met. The next script is almost identical to the one in the previous section except for the statement in place of : The output of looks like this: This time, when is , the statement terminates that iteration. That’s why isn’t printed. The control then returns to the loop header, where the condition is re-evaluated. The loop continues until reaches , at which point it terminates as before. Python allows an optional clause at the end of loops. The syntax is shown below: The code under the clause will run only if the loop terminates naturally without encountering a statement. In other words, it executes when the loop condition becomes false, and only then. Note that it doesn’t make much sense to have an clause in a loop that doesn’t have a statement. In that case, placing the block’s content after the loop—without indentation—will work the same and be cleaner. When might an clause on a loop be useful? One common use case for is when you need to break out of the loop. Consider the following example: This script simulates the process of connecting to an external server. The loop lets you try to connect a number of times, defined by the constant. If the connection is successful, then the statement terminates the loop. Note: In the example above, you used the module to simulate a successful or unsuccessful connection. You’ll use this module in a few other examples throughout this tutorial. To learn more about random data, check out the Generating Random Data in Python (Guide) tutorial. When all the connection attempts fail, the clause executes, letting you know that the attempts were unsuccessful. Go ahead and run the script several times to check the results.\n\nWhen writing loops in Python, you should ensure that they’re efficient and readable. You also need to make sure that they terminate correctly. Normally, you choose to use a loop when you need to repeat a series of actions until a given condition becomes false or while it remains true. This type of loop isn’t the way to go when you need to process all the items in an iterable. In that case, you should use a loop instead. In the following sections, you’ll learn how to use loops effectively, avoid infinite loops, implement control statements like and , and leverage the clause for handling loop completion gracefully. A general use case for a loop is waiting for a resource to become available before proceeding to use it. This is common in scenarios like the following:\n• Waiting for a file to be created or populated Here’s a loop that continually checks if a given file has been created: \"File not found. Retrying in 1 second...\" The loop in this script uses the method on a object. This method returns if the target file exits. The operator negates the check result, returning if the file doesn’t exit. If that’s the case, then the loop waits for one second to run another iteration and check for the file again. If you run this script, then you’ll get something like the following: python check_file.py Waiting for hello.txt to be created... File not found. Retrying in 1 second... File not found. Retrying in 1 second... File not found. Retrying in 1 second... In the meantime, you can open another terminal and create the file. When the loop finds the newly created file, it’ll terminate. Then, the code after the loop will run, printing the file content to your screen. Using Loops for an Unknown Number of Iterations loops are also great when you need to process a stream of data with an unknown number of items. In this scenario, you don’t know the required number of iterations, so you can use a loop with as its control condition. This technique provides a Pythonic way to write loops that will run an unknown number of iterations. To illustrate, suppose you need to read a temperature sensor that continuously provides data. When the temperature is equal to or greater than 28 degrees Celsius, you should stop monitoring it. Here’s a loop to accomplish this task: In this loop, you use as the loop condition, which generates a continually running loop. Then, you read the temperature sensor and print the current temperature value. If the temperature is equal to or greater than 25 degrees, you break out of the loop. Otherwise, you wait for a second and read the sensor again. Removing Items From an Iterable in a Loop Modifying a collection during iteration can be risky, especially when you need to remove items from the target collection. In some cases, using a loop can be a good solution. For example, say that you need to process a list of values and remove each value after it’s processed. In this situation, you can use a loop like the following: When you evaluate a list in a Boolean context, you get if it contains elements and if it’s empty. In this example, remains true as long as it has elements. Once you remove all the items with the method, becomes false, and the loop terminates. Getting user input from the command line is a common use case for loops in Python. Consider the following loop that takes input using the built-in functions. The loop runs until you type the word : The function asks the user to enter some text. Then, you assign the result to the variable. The loop condition checks whether the content of is different from , in which case, the loop body executes. Inside the loop, you call again. The loop repeats until the user types the word . This example works, but it has the drawback of unnecessarily repeating the call to . You can avoid the repetition using the walrus operator as in the code snippet below: In this updated loop, you get the user input in the variable using an assignment expression. At the same time, the expression returns the user input so that it can be compared to the sentinel value . Using a loop with the built-in function may be a great way to fine-control the iteration process when working with iterators and iterables. To give you an idea of how this works, you’ll rewrite a loop using a loop instead. Consider the following code: The two loops are equivalent. When you run the script, each loop will handle the three requests in turn: Python’s loops are quite flexible and powerful, and you should generally prefer over if you need to iterate over a given collection. However, translating the loop into a loop, like above, gives you even more flexibility in how you handle the iterator. A do-while loop is a control flow statement that executes its code block at least once, regardless of whether the loop condition is true or false. If you come from languages like C, C++, Java, or JavaScript, then you may be wondering where Python’s do-while loop is. The bad news is that Python doesn’t have one. The good news is that you can emulate it using a loop with a statement. Consider the following example, which takes user input in a loop: Again, this loop takes the user input using the built-in function. The input is then converted into an integer number using . If the user enters a number that’s or lower, then the statement runs, and the loop terminates. Note that to emulate a do-while loop in Python, the condition that terminates the loop goes at the end of the loop, and its body is a statement. It’s also important to emphasize that in this type of loop, the body runs at least once.\n\nSometimes, you might write a loop that doesn’t naturally terminate. A loop with this behavior is commonly known as an infinite loop, although the name isn’t quite accurate because, in the end, you’ll have to terminate the loop somehow. You may write an infinite loop either intentionally or unintentionally. Intentional infinite loops are powerful tools commonly used in programs that need to run continuously until an external condition is met, such as game loops, server processes, and event-driven apps like GUI apps or asynchronous code. In contrast, unintentional infinite loops are often the result of some kind of logical issue that prevents the loop condition from ever becoming false. For example, this can happen when the loop: In these cases, the loop erroneously continues to run until it’s terminated externally. In the following sections, you’ll learn about both types of infinite loops and how to approach them in your code. To kick things off, you’ll start with unintentional infinite loops. Suppose you write a loop that never ends due to an internal error. Getting back to the example in the initial section of this tutorial, you have the following loop that runs continuously: To terminate this code, you have to press + , which interrupts the program’s execution from the keyboard. Otherwise, the loop would run indefinitely since its condition never turns false. In real-world code, you’d typically want to have a proper loop condition to prevent unintended infinite execution. In most cases like this, you can prevent the potentially infinite loop by fixing the condition itself or the internal loop logic to make sure the condition becomes false at some point in the loop’s execution. In the example above, you can modify the condition a bit to fix the issue: This time, the loop doesn’t go down the value. Instead, it terminates when has a value that’s equal to or less than . Alternatively, you can use additional conditionals in the loop body to terminate the loop using : This loop has the same original loop condition. However, it includes a failsafe condition in the loop body to terminate it in case the main condition fails. Figuring out how to fix an unintentional infinite loop will largely depend on the logic you’re using in the loop condition and body. So, you should analyze each case carefully to determine the correct solution. Intentionally infinite loops are pretty common and useful. However, writing them correctly requires ensuring proper exit conditions, avoiding performance issues, and preventing unintended infinite execution. For example, you might want to write code for a service that starts up and runs forever, accepting service requests. Forever, in this context, means until you shut it down. The typical way to write an infinite loop is to use the construct. To ensure that the loop terminates naturally, you should add one or more statements wrapped in proper conditions: This syntax works well when you have multiple reasons to end the loop. It’s often cleaner to break out from several different locations rather than try to specify all the termination conditions in the loop header. To see this construct in practice, consider the following infinite loop that asks the user to provide their password: This loop has two exit conditions. The first condition checks whether the password is correct. The second condition checks whether the user has reached the maximum number of attempts to provide a correct password. Both conditions include a statement to finish the loop gracefully."
    },
    {
        "link": "https://geeksforgeeks.org/python-while-loop",
        "document": "Python While Loop is used to execute a block of statements repeatedly until a given condition is satisfied. When the condition becomes false, the line immediately after the loop in the program is executed.\n\nIn this example, the condition for while will be True as long as the counter variable (count) is less than 3.\n\nLet’s take a look at Python While Loop in detail:\n• condition: This is a boolean expression. If it evaluates to True, the code inside the loop will execute.\n• statement(s): These are the statements that will be executed during each iteration of the loop.\n\nThe while loop will continue running the code block as long as the condition evaluates to True. Each time the loop executes, the condition is checked again. If it is True, the loop continues; if it is False, the loop terminates, and the program moves to the next statement after the loop.\n\nHere, the value of the condition is always True. Therefore, the body of the loop is run infinite times until the memory is full.\n\nLoop control statements change execution from their normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed. Python supports the following control statements.\n\nPython Continue Statement returns the control to the beginning of the loop.\n\nPython Break Statement brings control out of the loop.\n\nThe Python pass statement to write empty loops. Pass is also used for empty control statements, functions, and classes.\n\nwhile loop with else\n\nAs discussed above, while loop executes the block until a condition is satisfied. When the condition becomes false, the statement immediately after the loop is executed. The else clause is only executed when your while condition becomes false. If you break out of the loop, or if an exception is raised, it won’t be executed.\n\nNote: The else block just after for/while is executed only when the loop is NOT terminated by a break statement.\n\nHow to write while loop in Python?\n\nWhat are typical use cases for using while loops in Python?\n\nHow to control a while loop with\n\n: Exits the loop immediately, regardless of the condition. \n\n s= input(\"Enter something (or 'quit' to stop): \") \n\n\n\n\n\n : Skips the rest of the code inside the loop for the current iteration and jumps back to the beginning to re-evaluate the condition.\n\nWhat are the dangers of using a while loop in Python?\n\nHow can we use a while loop to read user input in Python?"
    },
    {
        "link": "https://docs.python.org/3/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/loops-in-python",
        "document": "Loops in Python are used to repeat actions efficiently. The main types are For loops (counting through items) and While loops (based on conditions). Additionally, Nested Loops allow looping within loops for more complex tasks. While all the ways provide similar basic functionality, they differ in their syntax and condition-checking time. In this article, we will look at Python loops and understand their working with the help of examples.\n\nIn Python, a while loop is used to execute a block of statements repeatedly until a given condition is satisfied. When the condition becomes false, the line immediately after the loop in the program is executed.\n\nAll the statements indented by the same number of character spaces after a programming construct are considered to be part of a single block of code. Python uses indentation as its method of grouping statements.\n\nExample of Python While Loop:\n\nUsing else statement with While Loop in Python\n\nElse clause is only executed when our while condition becomes false. If we break out of the loop or if an exception is raised then it won’t be executed.\n\nSyntax of While Loop with else statement:\n\nThe code prints “Hello Geek” three times using a ‘while’ loop and then after the loop it prints “In Else Block” because there is an “else” block associated with the ‘while’ loop.\n\nIf we want a block of code to execute infinite number of times then we can use the while loop in Python to do so.\n\nThe code given below uses a ‘while’ loop with the condition (count == 0) and this loop will only run as long as count is equal to 0. Since count is initially set to 0, the loop will execute indefinitely because the condition is always true.\n\nNote: It is suggested not to use this type of loop as it is a never-ending infinite loop where the condition is always true and we have to forcefully terminate the compiler.\n\nFor loops are used for sequential traversal. For example: traversing a list or string or array etc. In Python, there is “for in” loop which is similar to foreach loop in other languages. Let us learn how to use for loops in Python for sequential traversals with examples.\n\nExplanation: This code prints the numbers from 0 to 3 (inclusive) using a for loop that iterates over a range from 0 to n-1 (where n = 4).\n\nExample with List, Tuple, String, and Dictionary Iteration Using for Loops in Python\n\nWe can use for loop to iterate lists, tuples, strings and dictionaries in Python.\n\nIterating by the Index of Sequences\n\nWe can also use the index of elements in the sequence to iterate. The key idea is to first calculate the length of the list and in iterate over the sequence within the range of this length.\n\nExplanation: This code iterates through each element of the list using its index and prints each element one by one. The range(len(list)) generates indices from 0 to the length of the list minus 1.\n\nUsing else Statement with for Loop in Python\n\nWe can also combine else statement with for loop like in while loop. But as there is no condition in for loop based on which the execution will terminate so the else block will be executed immediately after for block finishes execution.\n\nExplanation: The code iterates through the list and prints each element. After the loop ends it prints “Inside Else Block” as the else block executes when the loop completes without a break.\n\nPython programming language allows to use one loop inside another loop which is called nested loop. Following section shows few examples to illustrate the concept.\n\nThe syntax for a nested while loop statement in the Python programming language is as follows:\n\nA final note on loop nesting is that we can put any type of loop inside of any other type of loops in Python. For example, a for loop can be inside a while loop or vice versa.\n\nExplanation: In the above code we use nested loops to print the value of i multiple times in each row, where the number of times it prints i increases with each iteration of the outer loop. The print() function prints the value of i and moves to the next line after each row.\n\nLoop control statements change execution from their normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed. Python supports the following control statements.\n\nThe continue statement in Python returns the control to the beginning of the loop.\n\nExplanation: The continue statement is used to skip the current iteration of a loop and move to the next iteration. It is useful when we want to bypass certain conditions without terminating the loop.\n\nThe break statement in Python brings control out of the loop.\n\nExplanation: break statement is used to exit the loop prematurely when a specified condition is met. In this example, the loop breaks when the letter is either ‘e’ or ‘s’, stopping further iteration.\n\nWe use pass statement in Python to write empty loops. Pass is also used for empty control statements, functions and classes.\n\nExplanation: In this example, the loop iterates over each letter in ‘geeksforgeeks’ but doesn’t perform any operation, and after the loop finishes, the last letter (‘s’) is printed.\n\nHow for loop works internally in Python?\n\nBefore proceeding to this section, we should have a prior understanding of Python Iterators.\n\nFirstly, lets see how a simple for loops in Python looks like.\n\nExample: This Python code iterates through a list called fruits, containing “apple”, “orange” and “kiwi.” It prints each fruit name on a separate line, displaying them in the order they appear in the list.\n\nThis code iterates over each item in the fruits list and prints the item (fruit) on each iteration and the output will display each fruit on a new line.\n\nThis Python code manually iterates through a list of fruits using an iterator. It prints each fruit’s name one by one and stops when there are no more items in the list.\n\nWe can see that under the hood we are calling iter() and next() method.\n• None Difference between for loop and while loop in Python\n• None Use for Loop That Loops Over a Sequence in Python\n\nWhich loop is faster in Python?\n\nWhy is Python slow in loops?\n\nHow many loops are used in Python?\n\nIs for loop bad in Python?"
    },
    {
        "link": "https://programiz.com/python-programming/while-loop",
        "document": "In Python, we use a loop to repeat a block of code until a certain condition is met. For example,\n\nIn the above example, we have used a loop to print the numbers from 1 to 3. The loop runs as long as the condition is .\n• The loop evaluates condition, which is a boolean expression.\n• If the condition is , body of while loop is executed. The condition is evaluated again.\n• This process continues until the condition is .\n• Once the condition evaluates to , the loop terminates.\n\nTip: We should update the variables used in condition inside the loop so that it eventually evaluates to . Otherwise, the loop keeps running, creating an infinite loop.\n\nHere is how the above program works:\n• It asks the user to enter a number.\n• If the user enters a number other than 0, it is printed.\n• If the user enters 0, the loop terminates.\n\nIf the condition of a loop always evaluates to , the loop runs continuously, forming an infinite while loop. For example,\n\nThe above program is equivalent to:\n\nMore on Python while Loop We can use a break statement inside a loop to terminate the loop immediately without checking the test condition. For example, while True: user_input = input('Enter your name: ') # terminate the loop when user enters end if user_input == 'end': print(f'The loop is ended') break print(f'Hi {user_input}') Enter your name: Kevin Hi Kevin Enter your name: end The loop is ended Here, the condition of the while loop is always . However, if the user enters , the loop termiantes because of the statement. loop can have an optional clause - that is executed once the loop condition is . For example, counter = 0 while counter < 2: print('This is inside loop') counter = counter + 1 else: print('This is inside else block') In Python, aloop can have an optionalclause - that is executed once the loop condition is. For example, This is inside loop This is inside loop This is inside else block Here, on the third iteration, the becomes 2 which terminates the loop. It then executes the block and prints This is inside else block . Note: The block will not execute if the loop is terminated by a statement. Python for loop vs while loop The for loop is usually used in the sequence when the number of iterations is known. For example, # loop is iterated 4 times for i in range(4): print(i) The loop is usually used when the number of iterations is unknown. For example, while True: user_input = input(\"Enter password: \") # terminate the loop when user enters exit if user_input == 'exit': print(f'Status: Entry Rejected') break print(f'Status: Entry Allowed')"
    }
]