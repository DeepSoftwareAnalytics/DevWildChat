[
    {
        "link": "https://dev.mysql.com/doc/en/subquery-optimization-with-exists.html",
        "document": "Certain optimizations are applicable to comparisons that use the (or ) operator to test subquery results. This section discusses these optimizations, particularly with regard to the challenges that values present. The last part of the discussion suggests how you can help the optimizer.\n\nConsider the following subquery comparison:\n\nMySQL evaluates queries “from outside to inside.” That is, it first obtains the value of the outer expression , and then runs the subquery and captures the rows that it produces.\n\nA very useful optimization is to “inform” the subquery that the only rows of interest are those where the inner expression is equal to . This is done by pushing down an appropriate equality into the subquery's clause to make it more restrictive. The converted comparison looks like this:\n\nAfter the conversion, MySQL can use the pushed-down equality to limit the number of rows it must examine to evaluate the subquery.\n\nMore generally, a comparison of values to a subquery that returns -value rows is subject to the same conversion. If and represent corresponding outer and inner expression values, this subquery comparison:\n\nFor simplicity, the following discussion assumes a single pair of outer and inner expression values.\n\nThe “pushdown” strategy just described works if either of these conditions is true:\n\nSuppose that is known to be a non- value but the subquery does not produce a row such that = . Then evaluates as follows:\n\nIn this situation, the approach of looking for rows with is no longer valid. It is necessary to look for such rows, but if none are found, also look for rows where is . Roughly speaking, the subquery can be converted to something like this:\n\nThe need to evaluate the extra condition is why MySQL has the access method:\n\nThe and subquery-specific access methods also have “or ” variants.\n\nThe additional condition makes query execution slightly more complicated (and some optimizations within the subquery become inapplicable), but generally this is tolerable.\n\nThe situation is much worse when can be . According to the SQL interpretation of as “unknown value,” should evaluate to:\n\nFor proper evaluation, it is necessary to be able to check whether the has produced any rows at all, so cannot be pushed down into the subquery. This is a problem because many real world subqueries become very slow unless the equality can be pushed down.\n\nEssentially, there must be different ways to execute the subquery depending on the value of .\n\nThe optimizer chooses SQL compliance over speed, so it accounts for the possibility that might be :\n\nTo solve the dilemma of whether or not to push down conditions into the subquery, the conditions are wrapped within “trigger” functions. Thus, an expression of the following form:\n\nMore generally, if the subquery comparison is based on several pairs of outer and inner expressions, the conversion takes this comparison:\n\nAnd converts it to this expression:\n\nEach is a special function that evaluates to the following values:\n\nEqualities that are wrapped within functions are not first class predicates for the query optimizer. Most optimizations cannot deal with predicates that may be turned on and off at query execution time, so they assume any to be an unknown function and ignore it. Triggered equalities can be used by those optimizations:\n\nWhen the optimizer uses a triggered condition to create some kind of index lookup-based access (as for the first two items of the preceding list), it must have a fallback strategy for the case when the condition is turned off. This fallback strategy is always the same: Do a full table scan. In output, the fallback shows up as in the column:\n\nIf you run followed by , you can see the triggered condition:\n\nThe use of triggered conditions has some performance implications. A expression now may cause a full table scan (which is slow) when it previously did not. This is the price paid for correct results (the goal of the trigger-condition strategy is to improve compliance, not speed).\n\nFor multiple-table subqueries, execution of is particularly slow because the join optimizer does not optimize for the case where the outer expression is . It assumes that subquery evaluations with on the left side are very rare, even if there are statistics that indicate otherwise. On the other hand, if the outer expression might be but never actually is, there is no performance penalty.\n\nTo help the query optimizer better execute your queries, use these suggestions:\n\nThe flag of the system variable enables control over the choice between subquery materialization and -to- subquery transformation. See Section 10.9.2, “Switchable Optimizations”."
    },
    {
        "link": "https://stackoverflow.com/questions/40896888/query-speed-issue-with-not-exists-condition",
        "document": "MySQL stinks doing correlated subqueries fast. Try to make your subqueries independent and join them. You can use the pattern to replace .\n\nFirst, if you can change to it makes an index range scan possible on that column.\n\nSecond, when you're optimizing stuff, is considered harmful. Instead, if you can give the names of just the columns you need, things will be quicker. The database server has to sling around all the data you ask for; it can't tell if you're going to ignore some of it.\n\nThird, this query will be helped by a compound index on . That compound index can be used to do the heavy lifing of satisfying your query conditions.\n\nThat's called a covering index; it contains the data needed to satisfy much of your query. If you were to index just the column, then the query handler would have to bounce back to the main table to find the values of and . When those columns appear in the index, it saves that extra operation.\n\nIf you a certain set of columns rather than doing , including those columns in the covering index can dramatically improve query performance. That's one of several reasons is considered harmful."
    },
    {
        "link": "https://dev.mysql.com/doc/refman/9.0/en/subquery-optimization-with-exists.html",
        "document": "Certain optimizations are applicable to comparisons that use the (or ) operator to test subquery results. This section discusses these optimizations, particularly with regard to the challenges that values present. The last part of the discussion suggests how you can help the optimizer.\n\nConsider the following subquery comparison:\n\nMySQL evaluates queries “from outside to inside.” That is, it first obtains the value of the outer expression , and then runs the subquery and captures the rows that it produces.\n\nA very useful optimization is to “inform” the subquery that the only rows of interest are those where the inner expression is equal to . This is done by pushing down an appropriate equality into the subquery's clause to make it more restrictive. The converted comparison looks like this:\n\nAfter the conversion, MySQL can use the pushed-down equality to limit the number of rows it must examine to evaluate the subquery.\n\nMore generally, a comparison of values to a subquery that returns -value rows is subject to the same conversion. If and represent corresponding outer and inner expression values, this subquery comparison:\n\nFor simplicity, the following discussion assumes a single pair of outer and inner expression values.\n\nThe “pushdown” strategy just described works if either of these conditions is true:\n\nSuppose that is known to be a non- value but the subquery does not produce a row such that = . Then evaluates as follows:\n\nIn this situation, the approach of looking for rows with is no longer valid. It is necessary to look for such rows, but if none are found, also look for rows where is . Roughly speaking, the subquery can be converted to something like this:\n\nThe need to evaluate the extra condition is why MySQL has the access method:\n\nThe and subquery-specific access methods also have “or ” variants.\n\nThe additional condition makes query execution slightly more complicated (and some optimizations within the subquery become inapplicable), but generally this is tolerable.\n\nThe situation is much worse when can be . According to the SQL interpretation of as “unknown value,” should evaluate to:\n\nFor proper evaluation, it is necessary to be able to check whether the has produced any rows at all, so cannot be pushed down into the subquery. This is a problem because many real world subqueries become very slow unless the equality can be pushed down.\n\nEssentially, there must be different ways to execute the subquery depending on the value of .\n\nThe optimizer chooses SQL compliance over speed, so it accounts for the possibility that might be :\n\nTo solve the dilemma of whether or not to push down conditions into the subquery, the conditions are wrapped within “trigger” functions. Thus, an expression of the following form:\n\nMore generally, if the subquery comparison is based on several pairs of outer and inner expressions, the conversion takes this comparison:\n\nAnd converts it to this expression:\n\nEach is a special function that evaluates to the following values:\n\nEqualities that are wrapped within functions are not first class predicates for the query optimizer. Most optimizations cannot deal with predicates that may be turned on and off at query execution time, so they assume any to be an unknown function and ignore it. Triggered equalities can be used by those optimizations:\n\nWhen the optimizer uses a triggered condition to create some kind of index lookup-based access (as for the first two items of the preceding list), it must have a fallback strategy for the case when the condition is turned off. This fallback strategy is always the same: Do a full table scan. In output, the fallback shows up as in the column:\n\nIf you run followed by , you can see the triggered condition:\n\nThe use of triggered conditions has some performance implications. A expression now may cause a full table scan (which is slow) when it previously did not. This is the price paid for correct results (the goal of the trigger-condition strategy is to improve compliance, not speed).\n\nFor multiple-table subqueries, execution of is particularly slow because the join optimizer does not optimize for the case where the outer expression is . It assumes that subquery evaluations with on the left side are very rare, even if there are statistics that indicate otherwise. On the other hand, if the outer expression might be but never actually is, there is no performance penalty.\n\nTo help the query optimizer better execute your queries, use these suggestions:\n\nThe flag of the system variable enables control over the choice between subquery materialization and -to- subquery transformation. See Section 10.9.2, “Switchable Optimizations”."
    },
    {
        "link": "https://stackoverflow.com/questions/14190788/subqueries-with-exists-vs-in-mysql",
        "document": "Below two queries are subqueries. Both are the same and both works fine for me. But the problem is Method 1 query takes about 10 secs to execute while Method 2 query takes under 1 sec.\n\nI was able to convert method 1 query to method 2 but I don't understand what's happening in the query. I have been trying to figure it out myself. I would really like to learn what's the difference between below two queries and how does the performance gain happen ? what's the logic behind it ?\n\nI'm new to these advance techniques. I hope someone will help me out here. Given that I read the docs which does not give me a clue."
    },
    {
        "link": "https://dev.mysql.com/doc/refman/en/optimizer-hints.html",
        "document": "One means of control over optimizer strategies is to set the system variable (see Section 10.9.2, “Switchable Optimizations”). Changes to this variable affect execution of all subsequent queries; to affect one query differently from another, it is necessary to change before each one.\n\nAnother way to control the optimizer is by using optimizer hints, which can be specified within individual statements. Because optimizer hints apply on a per-statement basis, they provide finer control over statement execution plans than can be achieved using . For example, you can enable an optimization for one table in a statement and disable the optimization for a different table. Hints within a statement take precedence over flags.\n\nOptimizer hints, described here, differ from index hints, described in Section 10.9.4, “Index Hints”. Optimizer and index hints may be used separately or together.\n\nMySQL supports comments in SQL statements as described in Section 11.7, “Comments”. Optimizer hints must be specified within comments. That is, optimizer hints use a variant of C-style comment syntax, with a character following the comment opening sequence. Examples: Whitespace is permitted after the character. The parser recognizes optimizer hint comments after the initial keyword of , , , , and statements. Hints are permitted in these contexts:\n• None At the beginning of query and data change statements:\n• None At the beginning of query blocks:\n• None In hintable statements prefaced by . For example: The implication is that you can use to see how optimizer hints affect execution plans. Use immediately after to see how hints are used. The extended output displayed by a following indicates which hints were used. Ignored hints are not displayed. A hint comment may contain multiple hints, but a query block cannot contain multiple hint comments. This is valid: When a hint comment contains multiple hints, the possibility of duplicates and conflicts exists. The following general guidelines apply. For specific hint types, additional rules may apply, as indicated in the hint descriptions.\n• None Duplicate hints: For a hint such as , MySQL uses the first hint and issues a warning about the duplicate hint.\n• None Conflicting hints: For a hint such as , MySQL uses the first hint and issues a warning about the second conflicting hint. Query block names are identifiers and follow the usual rules about what names are valid and how to quote them (see Section 11.2, “Schema Object Names”). Hint names, query block names, and strategy names are not case-sensitive. References to table and index names follow the usual identifier case-sensitivity rules (see Section 11.2.3, “Identifier Case Sensitivity”).\n\nJoin-order hints affect the order in which the optimizer joins tables. The syntax refers to these terms:\n• \n• None : Force the optimizer to join tables using the order in which they appear in the clause. This is the same as specifying .\n• None : Instruct the optimizer to join tables using the specified table order. The hint applies to the named tables. The optimizer may place tables that are not named anywhere in the join order, including between specified tables.\n• None : Instruct the optimizer to join tables using the specified table order for the first tables of the join execution plan. The hint applies to the named tables. The optimizer places all other tables after the named tables.\n• None : Instruct the optimizer to join tables using the specified table order for the last tables of the join execution plan. The hint applies to the named tables. The optimizer places all other tables before the named tables.\n• None : The name of a table used in the statement. A hint that names tables applies to all tables that it names. The hint names no tables and applies to all tables in the clause of the query block in which it occurs. If a table has an alias, hints must refer to the alias, not the table name. Table names in hints cannot be qualified with schema names.\n• None : The query block to which the hint applies. If the hint includes no leading , the hint applies to the query block in which it occurs. For syntax, the hint applies to the named table in the named query block. To assign a name to a query block, see Optimizer Hints for Naming Query Blocks. SELECT /*+ JOIN_PREFIX(t2, t5@subq2, t4@subq1) JOIN_ORDER(t4@subq1, t3) JOIN_SUFFIX(t1) */ COUNT(*) FROM t1 JOIN t2 JOIN t3 WHERE t1.f1 IN (SELECT /*+ QB_NAME(subq1) */ f1 FROM t4) AND t2.f1 IN (SELECT /*+ QB_NAME(subq2) */ f1 FROM t5); Hints control the behavior of semijoin tables that are merged to the outer query block. If subqueries and are converted to semijoins, tables and are merged to the outer query block. In this case, the hint specified in the outer query block controls the behavior of , tables. The optimizer resolves join-order hints according to these principles:\n• None Only one and hint of each type are applied. Any later hints of the same type are ignored with a warning. can be specified several times. The second hint is ignored with a warning. Both hints are applicable. No warning occurs. Both hints are applicable. No warning occurs.\n• None In some cases hints can conflict, such as when and have table orders that are impossible to apply at the same time: In this case, the first specified hint is applied and subsequent conflicting hints are ignored with no warning. A valid hint that is impossible to apply is silently ignored with no warning.\n• None A hint is ignored if a table specified in the hint has a circular dependency. The hint sets table dependent on . The hint is ignored because table cannot be dependent on . Ignored hints are not displayed in extended output.\n• None The MySQL optimizer places tables first in the join order, and the position of a table cannot be affected by hints. References to tables in join-order hints are ignored, although the hint is still applicable. For example, these are equivalent: Accepted hints shown in extended output include tables as they were specified.\n• None MySQL supports several type of joins: , , , , . A hint that conflicts with the specified type of join is ignored with no warning. Here a conflict occurs between the requested join order in the hint and the order required by the . The hint is ignored with no warning.\n\nSubquery hints affect whether to use semijoin transformations and which semijoin strategies to permit, and, when semijoins are not used, whether to use subquery materialization or -to- transformations. For more information about these optimizations, see Section 10.2.2, “Optimizing Subqueries, Derived Tables, View References, and Common Table Expressions”. The syntax refers to these terms:\n• None : A semijoin strategy to be enabled or disabled. These strategy names are permitted: , , , . For hints, if no strategies are named, semijoin is used if possible based on the strategies enabled according to the system variable. If strategies are named but inapplicable for the statement, is used. For hints, if no strategies are named, semijoin is not used. If strategies are named that rule out all applicable strategies for the statement, is used. If one subquery is nested within another and both are merged into a semijoin of an outer query, any specification of semijoin strategies for the innermost query are ignored. and hints can still be used to enable or disable semijoin transformations for such nested subqueries. If is disabled, on occasion the optimizer may generate a query plan that is far from optimal. This occurs due to heuristic pruning during greedy search, which can be avoided by setting . SELECT /*+ NO_SEMIJOIN(@subq1 FIRSTMATCH, LOOSESCAN) */ * FROM t2 WHERE t2.a IN (SELECT /*+ QB_NAME(subq1) */ a FROM t3); SELECT /*+ SEMIJOIN(@subq1 MATERIALIZATION, DUPSWEEDOUT) */ * FROM t2 WHERE t2.a IN (SELECT /*+ QB_NAME(subq1) */ a FROM t3); Syntax of hints that affect whether to use subquery materialization or -to- transformations: The hint name is always . For hints, these values are permitted: , . SELECT id, a IN (SELECT /*+ SUBQUERY(MATERIALIZATION) */ a FROM t1) FROM t2; SELECT * FROM t2 WHERE t2.a IN (SELECT /*+ SUBQUERY(INTOEXISTS) */ a FROM t1); For semijoin and hints, a leading specifies the query block to which the hint applies. If the hint includes no leading , the hint applies to the query block in which it occurs. To assign a name to a query block, see Optimizer Hints for Naming Query Blocks. If a hint comment contains multiple subquery hints, the first is used. If there are other following hints of that type, they produce a warning. Following hints of other types are silently ignored.\n\nThe hint sets the session value of a system variable temporarily (for the duration of a single statement). Examples: SELECT /*+ SET_VAR(sort_buffer_size = 16M) */ name FROM people ORDER BY name; INSERT /*+ SET_VAR(foreign_key_checks=OFF) */ INTO t2 VALUES(2); SELECT /*+ SET_VAR(optimizer_switch = 'mrr_cost_based=off') */ 1; names a system variable that has a session value (although not all such variables can be named, as explained later). is the value to assign to the variable; the value must be a scalar. makes a temporary variable change, as demonstrated by these statements: With , there is no need to save and restore the variable value. This enables you to replace multiple statements by a single statement. Consider this sequence of statements: The sequence can be replaced by this single statement: Standalone statements permit any of these syntaxes for naming session variables: SET SESSION var_name = value; SET @@SESSION.var_name = value; SET @@.var_name = value; Because the hint applies only to session variables, session scope is implicit, and , , and are neither needed nor permitted. Including explicit session-indicator syntax results in the hint being ignored with a warning. Not all session variables are permitted for use with . Individual system variable descriptions indicate whether each variable is hintable; see Section 7.1.8, “Server System Variables”. You can also check a system variable at runtime by attempting to use it with . If the variable is not hintable, a warning occurs: mysql> SELECT /*+ SET_VAR(collation_server = 'utf8mb4') */ 1; +---+ | 1 | +---+ | 1 | +---+ 1 row in set, 1 warning (0.00 sec) mysql> SHOW WARNINGS\\G *************************** 1. row *************************** Level: Warning Code: 4537 Message: Variable 'collation_server' cannot be set using SET_VAR hint. syntax permits setting only a single variable, but multiple hints can be given to set multiple variables: If several hints with the same variable name appear in the same statement, the first one is applied and the others are ignored with a warning: In this case, the second hint is ignored with a warning that it is conflicting. A hint is ignored with a warning if no system variable has the specified name or the variable value is incorrect: For the first statement, there is no variable. For the second statement, takes values of or , so attempting to set it to is incorrect. In each case, the hint is ignored with a warning. The hint is permitted only at the statement level. If used in a subquery, the hint is ignored with a warning. Replicas ignore hints in replicated statements to avoid the potential for security issues.\n\nTable-level, index-level, and subquery optimizer hints permit specific query blocks to be named as part of their argument syntax. To create these names, use the hint, which assigns a name to the query block in which it occurs: hints can be used to make explicit in a clear way which query blocks other hints apply to. They also permit all non-query block name hints to be specified within a single hint comment for easier understanding of complex statements. Consider the following statement: SELECT ... FROM (SELECT ... FROM (SELECT ... FROM ...)) ... hints assign names to query blocks in the statement: SELECT /*+ QB_NAME(qb1) */ ... FROM (SELECT /*+ QB_NAME(qb2) */ ... FROM (SELECT /*+ QB_NAME(qb3) */ ... FROM ...)) ... Then other hints can use those names to refer to the appropriate query blocks: SELECT /*+ QB_NAME(qb1) MRR(@qb1 t1) BKA(@qb2) NO_MRR(@qb3t1 idx1, id2) */ ... FROM (SELECT /*+ QB_NAME(qb2) */ ... FROM (SELECT /*+ QB_NAME(qb3) */ ... FROM ...)) ... The resulting effect is as follows:\n• None applies to indexes and in table in query block . Query block names are identifiers and follow the usual rules about what names are valid and how to quote them (see Section 11.2, “Schema Object Names”). For example, a query block name that contains spaces must be quoted, which can be done using backticks: SELECT /*+ BKA(@`my hint name`) */ ... FROM (SELECT /*+ QB_NAME(`my hint name`) */ ...) ... If the SQL mode is enabled, it is also possible to quote query block names within double quotation marks: SELECT /*+ BKA(@\"my hint name\") */ ... FROM (SELECT /*+ QB_NAME(\"my hint name\") */ ...) ..."
    },
    {
        "link": "https://akhil-mathew.medium.com/mysql-indexing-best-practices-779282b0995b",
        "document": "When you should Optimize the MySQL database?\n\nIdeally, query performance tuning should happen regularly.\n\nMySQL indexing is not a one-time process. It is advised to conduct weekly or monthly checks of database performance to prevent issues from adversely affecting your applications.\n\nHow will you recognize which of your queries performing adversely?\n\nLet me introduce two ways that are your friends in identifying the queries that caused the performance bottleneck.\n\nHow will you identify whether the query lacks an index?.\n\nNow you understand which are those troublemakers in the application. But, how will you recognize that they perform adversely only due to a lack of an index? Well, the EXPLAIN statement of MySQL can be your lifesaver.\n\nEXPLAIN works with SELECT, DELETE, REPLACE, and UPDATE (From Mysql version 5.7 onwards) statements. Just like you, MySQL will have plans for each query on how to execute, which index to pick, how to join tables, and which order it should maintain for optimal performance.\n\nCheck out the below table description, I want you to memorize this table as it will be used in most of my examples. The table doesn’t have any index at present.\n\nLet’s take a sample query and analyze what EXPLAIN yields to it.\n\nExplaining the above query gives as…\n\nLet’s break down the EXPLAIN result. As you can see MySQL had traversed through 152685 rows (See the column: rows) of the table to find a matching row and it's equal to a full table scan because the table has 153728 rows in total. EXPLAIN result has two columns with names as possible keys and keys. possible_keys column tells us what are the available indexes in a table or the indexes that may be used for our queries. keys column tells us what indexes MySQL used for the analyzed query. As of now, both are empty. An empty key column provides you with the information that the query lacks an index.\n\nLet’s add one index and examine what happens.\n\nNow you can see that the query is better optimized and MySQL was able to find a matching result without traversing many rows. If you notice, we have our index name present in both of the columns possible_keys and key.\n\nYou optimized a simple query but mine is a complex one!!!\n\nI know that the query optimized just now is a piece of cake for you. Before jumping into more complex queries, I want you to learn the Rule of Thumb in indexing.\n\nKeeping the rule of thumb in mind, you already know that creating two indexes on email and category will not help.\n\nNow, what you will do? A multiple-column (composite) index to the rescue..!\n\nTo optimize such queries, you should create a composite or compound index. A composite index can be described as a compound of multiple columns.\n\nBy adding several columns into an index you can narrow down the number of rows MySQL has to traverse to find matching rows. An index may consist of up to 16 columns.\n\nLet’s see, how you can create a composite index.\n\nDoes the column’s order matter in a compound index?\n\nNow, How will you find the cardinality or number of distinct values of a column? You can just perform a distinctive count query on the column. (It’s advised not to perform such queries mentioned below in a production DB when it is running during the peak time of traffic.)\n\nHere you can see that the cardinality of the category_id column is less than that of the email column so we should create a composite index just as follows.\n\nAs you observe the order in which these columns are indexed, and thus how they are sorted will restrict the usage of our index to some particular queries only.\n\nAs an example, the index we’ve just created (email, category_id) would not be beneficial for a query such as:\n\nWhy? Just now you said that a composite index will be beneficial for my query.\n\nWell, there is a reason for it.\n\nThis means that the MySQL optimizer can’t use an index to perform lookups if the query doesn’t contain the leftmost prefix column of the index. So the left-most column in a composite index is known as the Lookup column.\n\nMySQL can use multiple-column indexes for queries that test all the columns in the index, or queries that test just the first column, the first two columns, the first three columns, and so on. If you specify the columns in the right order in the index definition, a single composite index can speed up several kinds of queries on the same table.\n\nIn the above query, I used category_id as the only WHERE clause term, hence composite index won’t be useful as it lacks a lookup column of the index.\n\nThere is another advantage of the composite index; If an index exists on (col1, col2, col3), the same index can be equivalent to creating multiple indexes like an index on col1, index on (col1, col2) and index on (col1, col2, col3) provided index order matters.\n\nFor example, let’s take an index (email, category_id, status). This index will be useful in the below queries.\n\nBut not in the below queries;\n\nWhat if your query contains an OR operator instead of an AND?\n\nTherefore, it’s recommended to avoid such OR conditions and consider splitting the query into two parts, combined with a UNION DISTINCT (or even better, UNION ALL, in case you know there won’t be any duplicate results)\n• Individual Indexes for OR Conditions: Create separate indexes on columns participating in OR conditions within the WHERE clause. Each index corresponds to one part of the OR condition.\n• Index Merge Optimization: MySQL employs the Index Merge optimization strategy to merge results from multiple indexes efficiently. However, it’s crucial to note that Index Merge is not as optimized as utilizing a compound index.\n\nWhat if your query contains GROUP BY and ORDER BY\n\nlet’s take the same index (email, category_id, status), and you run the query:\n\nThis will use the composite index for the WHERE clause and if you think this will narrow down the records with the status having a value of 1, sadly you now need to perform a sort on these resulting records to get them sorted by category_id. This is because the index didn’t sort the results by category_id in any meaningful way and the ORDER BY clause lacks the lookup column.\n\nThis is known as a File Sort (some of you might have noticed this in an ‘explain’ result). This happens because the index that we created failed to satisfy the ORDER BY clause.\n\nThis also applies even If you only wanted to read 10 rows.\n\nYou’ll still be fetching thousands of records, sorting them, and only after this, returning the top 5 while discarding the rest of the records you spent time processing.\n\nThis query can leverage the usage of the mentioned index because it qualifies for both the WHERE clause and the ORDER BY clause.\n\nConsider another query, which sorts rows by the status in ascending order, and then by the category_id in descending order.\n\nNote: This changed with the release of the reversed indexes functionality in MySQL v8\n\nWhatever you learned against ORDER BY is also applicable to GROUP BY statements. if you run the following query with the composite index on (status, category_id, email):\n\nThe records are already sorted by status, category_id, and email. This allows you to quickly filter down all the records with status=1. After these results are returned they are also then sorted based on category_id. Here the index is used for filtering and grouping.\n\nWhat if your query contains JOINS?\n\nWhat if your query contains RANGE conditions?\n\nA query is treated as a Range query if it uses any or a mix of the following operators;"
    },
    {
        "link": "https://planetscale.com/learn/courses/mysql-for-developers/indexes/composite-indexes",
        "document": "In our previous discussions about indexing, we focused on single column indexes. While they are essential to know, there's something even more interesting to learn about: composite indexes (also known as multi-column or composite indexes). Composite indexes cover multiple columns instead of having individual indexes on each column. Understanding and effectively using composite indexes can elevate you from a decent database user to an advanced one. In this video, we'll discuss what composite indexes are, how to create them, and when they can and can't be used.\n\nLet's start with creating a composite index on our people table. We have been adding single column indexes like this:\n\nNow, we'll create a composite index covering the first_name, last_name, and birthday columns:\n\nWhen you inspect the indexes on the people table, you'll notice the multi index with a sequence in the index column. This sequence indicates the order of the columns in the index, which is crucial for how the index can be used.\n\nThere are two main rules for using composite indexes:\n• Left-to-right, no skipping: MySQL can only access the index in order, starting from the leftmost column and moving to the right. It can't skip columns in the index.\n• Stops at the first range: MySQL stops using the index after the first range condition encountered.\n\nTo understand how MySQL uses composite indexes, you can use the EXPLAIN statement. For example, let's analyze the following query:\n\nThe EXPLAIN output shows that the index is being used, with a key length of 404 bytes. This indicates that MySQL is using both the and parts of the index.\n\nIf we add birthday to the mix, the jumps to 407.\n\nHowever, if you change the query to include a range condition on , then the drops back down to 404.\n\nThe key length remains 404 bytes, meaning MySQL stops using the index at the first range condition ( in this case) and doesn't use the birthday part of the index.\n\nChoosing the right order for columns in a composite index depends on the access patterns of your application. Consider the following tips when defining composite indexes:\n• Equality conditions that are commonly used would be good candidates for being first in a composite index.\n• Range conditions or less frequently used columns would be better candidates for ordering later in the composite index.\n\nComposite indexes can significantly improve the performance of your database queries. Understanding and effectively using them is essential for advanced database users. Remember to consider your access patterns and carefully define the order of your columns to create efficient composite indexes."
    },
    {
        "link": "https://percona.com/blog/understanding-mysql-indexes-types-best-practices",
        "document": "When it comes to MySQL databases, performance is everything. As more activities move online and data volumes grow exponentially, ensuring efficient data retrieval and query execution becomes crucial. Database indexing plays a significant role in this by providing powerful tools to optimize operations in MySQL. Without an index, MySQL must perform a full table scan, reading every row to find the desired data, which becomes increasingly inefficient as the table grows larger. By creating an index on one or more columns, MySQL can quickly locate the relevant rows, significantly reducing the amount of data that needs to be scanned.\n\nHowever, while MySQL indexes offer substantial performance benefits, it’s important to balance their advantages with the overhead associated with index maintenance. Adding, modifying, or removing data in an indexed table requires updating the corresponding index, which can impact write performance. Carefully planning and implementing indexing strategies is crucial to optimizing query performance while minimizing unnecessary overhead.\n\nIn this blog post, we will discuss the different types of indexes in MySQL, when to use them, and how to create them. Additionally, we will provide tips for effective indexing.\n\nHere are some key benefits of using MySQL indexes:\n\nImproved query speed and optimization: MySQL indexes significantly enhance query processing, particularly with extensive datasets. By reducing the need for full table scans, indexes enable MySQL to quickly locate and retrieve necessary data. This optimization improves query response times and overall system performance, making it essential for efficient database operations.\n\nImproved efficiency and resource usage: As stated above, if indexes were not used, MySQL would have to search through every row in a table to locate the necessary data, resulting in significant utilization of system resources like CPU cycles, memory, and disk I/O. By utilizing indexes, the database can swiftly pinpoint the required rows, minimizing the data that needs to be examined and processed to enhance response times for queries and the overall performance and scalability of the system.\n\nOptimized JOIN operations: MySQL indexes can significantly improve the performance of JOIN operations between tables. When you join tables using indexed columns in MySQL, it can use the indexes to find matching rows quickly. This reduces the need for resource-heavy tasks like scanning the entire table or sorting. This optimization becomes increasingly important as the complexity of JOIN queries and the number of tables involved grows.\n\nEnforcing data integrity: In addition to enhancing performance, MySQL indexes also aid in upholding data integrity rules. For instance, unique indexes prevent the insertion of duplicate values into a column, thereby preserving data uniqueness. Likewise, primary key indexes ensure that every row in a table possesses a unique identifier, avoiding unintentional duplicates or isolated data.\n\nImproved sorting and range queries: MySQL indexes can significantly enhance the performance of queries that require sorting or filtering by a range of values. By organizing data in a structured order, indexes allow MySQL to quickly locate and retrieve the necessary rows without having to perform expensive sorting operations or search through unnecessary data.\n\nUnderstanding different types of indexes in MySQL\n\nMySQL offers several types of indexes, each designed to optimize query performance for different use cases. Understanding these MySQL indexes and their purposes can help you select the best one for your needs.\n\nA primary key index ensures each row in a table can be uniquely identified, which is crucial for database integrity. This index enforces the uniqueness of the column(s) it covers and prevents duplicate entries.\n\nA unique index is similar to a primary key but allows for NULL values while ensuring non-NULL values are unique. This type of index helps maintain data uniqueness without the strict constraints of a primary key.\n\nA standard index, also known simply as an index, speeds up searches on frequently queried columns. This type of index can be applied to any column and is beneficial for improving the performance of SELECT queries.\n\nFull-text indexes are specialized for full-text search functionalities, allowing efficient text search and retrieval operations. They are ideal for applications requiring fast and accurate text searches.\n\nComposite indexes cover multiple columns, optimizing queries that filter or sort by more than one column. They provide quick access to combined data and are useful for complex query scenarios.\n\nIn MySQL, InnoDB tables use the primary key as the clustered index, meaning the data is physically organized based on the primary key values. This improves the performance of queries that access large amounts of data. However, MySQL does not have an explicit clustered index type; it is automatically handled by InnoDB.\n\nA secondary or non-clustered index is an additional index separate from the primary (clustered) index. In InnoDB tables, secondary indexes reference the primary key, allowing efficient access to rows based on non-primary key columns.\n\nTo understand how indexes enhance performance, let’s take a look at the underlying data structures MySQL uses to store and organize index data. Understanding how indexes work is essential for maximizing index performance and overall database efficiency.\n\nB-trees (B+ Trees): B+ trees are the primary data structure used for indexing in MySQL, especially with the InnoDB storage engine. These balanced trees are efficient for insertion, deletion, and lookup operations, with data stored in a sorted order. This makes them ideal for range queries and ordered retrievals.\n\nHashes: Hash indexes in MySQL are specific to the MEMORY (HEAP) storage engine. They use a hash table to generate a hash value from the indexed column, which points to the corresponding rows. These indexes are highly efficient for exact-match queries but do not support range queries or ordered retrievals. While InnoDB doesn’t natively support hash indexes, it uses adaptive hash indexing, which dynamically optimizes frequently accessed B+ tree pages by converting them into a hash structure for faster exact-match lookups. This process is automatic and transparent to users.\n\nWhen creating indexes in MySQL, it’s important to strike a balance between the number of indexes and the performance benefits they provide. Too many indexes can slow down data insertion and updates, while too few indexes can result in slow query performance. It’s also important to regularly analyze and optimize indexes to ensure they are still providing the desired performance improvements.\n\nOverall, creating indexes in MySQL is a crucial step in optimizing database performance and improving query speed. By carefully selecting the columns to index and choosing the appropriate index types, users can significantly enhance the efficiency of their database operations.\n\nStorage impact: Indexes are stored as separate data structures within the database, occupying additional disk space. The amount of space required depends on the size of the indexed columns, the number of indexes, and the underlying data structure used (e.g., B-tree, hash). It’s important to balance the performance gains of indexes and the additional storage requirements.\n\nRead performance: Indexes significantly improve read performance by allowing MySQL to quickly locate and retrieve the desired data without performing full table scans. Without indexes, MySQL performs full table scanning, which can be inefficient for large datasets. The performance improvement becomes more evident as the dataset grows larger and queries become more complex.\n\nWrite performance: While indexes enhance read performance, they can negatively impact write performance (INSERT, UPDATE, and DELETE operations). When data is modified in an indexed table, MySQL must update the table data and the corresponding index entries. This additional overhead can slow down write operations, especially for tables with multiple indexes or frequent write workloads.\n\nLet’s look at various scenarios where indexes can significantly enhance query efficiency, strategies for managing large datasets, and techniques for optimizing join operations.\n\nIndexes can drastically improve query performance, especially in scenarios involving frequent searches, joins, range queries, and ORDER BY clauses. Consider a slow query that involves searching for records in a large table without an index. Such queries can take significant time to complete because the database must scan every row. By creating an index on the column used in the WHERE clause, the database can quickly locate the relevant rows, resulting in much faster query execution.\n\nIndexing large datasets requires careful planning to balance the benefits of faster read operations with the additional storage and maintenance overhead. One approach is to index only the most frequently queried columns, such as those used in WHERE clauses or JOIN operations. Additionally, partitioning large tables and creating indexes on each partition can help distribute the workload and improve performance. Regularly monitoring and analyzing query performance is also essential for fine-tuning indexes and ensuring they meet the application’s needs.\n\nJoins are common operations in relational databases, where multiple tables are combined based on related columns. Indexing these columns can significantly optimize join operations. As an example, if two tables are frequently joined on a specific column, creating an index on that column in both tables can reduce the time required to match rows. This is particularly beneficial in complex queries involving multiple joins, as indexed columns allow the database to efficiently retrieve and combine the relevant rows, leading to faster query execution.\n\nWe’ve learned how MySQL indexes work and when certain kinds can be useful, so we’ll now cover some important practices for creating and removing them, monitoring their effectiveness, and dealing with index fragmentation.\n\nRegular analysis and monitoring of indexes are essential for maintaining their effectiveness. Tools like EXPLAIN and SHOW INDEX provide valuable insights into how indexes are used in queries. The EXPLAIN command helps you understand the execution plan of a query, indicating which indexes are being used. SHOW INDEX provides details about the indexes on a table, including their cardinality and uniqueness. By knowing how to analyze this information, you can identify underutilized or redundant indexes and make informed decisions about their management.\n\nBest practices for creating and dropping MySQL indexes\n\nCreating and dropping indexes are fundamental tasks in database management. The commands for creating indexes involve specifying the type of index and the columns to be indexed, while dropping indexes requires identifying the index to be removed. It’s important to carefully consider the impact of these operations, as creating indexes can improve query performance but also increase storage requirements and slow down write operations. On the flip side, dropping an index might reduce storage usage and improve write performance but could slow down read operations.\n\nHow to handle index fragmentation in MySQL\n\nIndex fragmentation occurs when the logical order of index pages no longer matches the physical order, leading to inefficient disk usage and slower query performance. MySQL primarily supports index rebuilding to deal with fragmentation, which reorganizes the table and indexes to improve performance.\n\nOver time, indexes can become redundant or inefficient due to query patterns and data structure changes. Dropping unused or rarely used indexes can reduce storage overhead and improve write performance while combining multiple similar indexes into a single composite index can also streamline index management and enhance performance. Tools and commands like EXPLAIN and SHOW INDEX are invaluable in this process, providing the necessary insights to make data-driven decisions.\n\nBest practices for using MySQL indexes effectively\n\nWhile indexes are a powerful tool for optimizing database performance, their effectiveness depends on careful planning and management. Here are some important considerations and best practices for using indexes effectively:\n• Don’t overuse indexes : While indexes can significantly improve query performance, striking a balance and avoiding indexing every column in a table is essential. Excessive indexing can lead to increased storage requirements, slower write operations (inserts, updates, and deletes), and potential performance degradation. Each index added to a table incurs overhead for maintenance, so it’s important to be cautious and index only the columns frequently used in queries or requiring performance optimization.\n• Choose the right index type : MySQL offers several index types, including B-tree, hash, full-text, and spatial indexes. Selecting the appropriate index type is crucial for maximizing performance gains. For example, B-tree indexes are suitable for a wide range of queries, while hash indexes excel at equality lookups but perform poorly for range queries. Consider the data types, query patterns, and usage scenarios when choosing the appropriate index type.\n• Analyze index usage : MySQL tools like EXPLAIN and other utilities help you identify which indexes are being used, how often they are accessed, and their effectiveness. By analyzing this information, you can locate redundant, unused, or inefficient indexes and make informed decisions about index maintenance, such as dropping or rebuilding indexes as needed.\n• Index selective columns : When creating indexes, focus on columns with a high degree of selectivity, meaning they contain a wide range of unique values. Indexing low-cardinality columns (columns with few distinct values) may not provide significant performance benefits and can even degrade performance in some cases. Analyze your data distribution and indexing requirements to identify the most selective columns.\n• Optimize index length for large columns : For large column values, such as text or binary data, it may be beneficial to create a prefix index, which indexes only the first few characters or bytes of the column. This can reduce the index size and improve performance while providing useful indexing capabilities for queries that rely on prefix matching or partial column values.\n• Use composite indexes for multi-column queries : If your queries frequently involve multiple columns, consider creating a composite index (also known as a multi-column index) that includes all or a subset of those columns. Composite indexes can improve performance for queries that filter or sort on multiple columns simultaneously.\n• Periodically rebuild and reorganize indexes : As data is inserted, updated, and deleted over time, indexes can become fragmented, leading to performance degradation. Consider periodically rebuilding indexes to optimize their structure and improve query performance.\n• Leverage database tools and monitoring : There are various tools available to help you manage and optimize indexes. MySQL Workbench, the Performance Schema, and third-party monitoring solutions like can provide valuable insights into index usage, performance metrics, and potential bottlenecks, enabling you to make informed decisions about indexing strategies.\n\nEffectively using indexes is critical to optimizing your MySQL database performance. For those seeking even greater optimization, we highly recommend our eBook, “MySQL Performance Tuning: Strategies, Best Practices, and Tips from Percona MySQL Experts.” It is filled with advanced techniques and insights from Percona experts to help you take your database performance skills to the next level.\n\nWhat is the best index type for large databases?\n\nComposite indexes can be highly effective for large databases. They allow MySQL to use multiple columns in filtering data, which reduces the amount of data scanned. B-tree indexes (the default index type in MySQL) are efficient for a variety of queries, including range searches and ordered retrieval. For large datasets with complex queries, composite B-tree indexes are commonly used for optimal performance.\n\nHow often should indexes be maintained?\n\nIndex maintenance should be performed regularly, but the frequency depends on your database’s workload and size. For InnoDB tables, regular maintenance tasks like OPTIMIZE TABLE can help reduce fragmentation and reclaim space. While automatic mechanisms like InnoDB’s background operations handle some maintenance, periodic index rebuilding or defragmenting may still be necessary for heavily used tables.\n\nYes, while indexes speed up read operations by reducing the data scanned, they add overhead to write operations such as INSERT, UPDATE, and DELETE. Each write operation must also update the relevant indexes, which can slow down performance. It’s essential to strike a balance by indexing only the most frequently queried columns to optimize both read and write performance.\n\nHow do you decide which columns to index?\n\nColumns that frequently appear in WHERE, JOIN, and ORDER BY clauses are good candidates for indexing. Indexing these columns can significantly improve query performance. Additionally, analyzing slow query logs and query execution plans can provide insights into which columns to index. Indexes should also cover all parts of the AND conditions in WHERE clauses when possible.\n\nWhat tools are available for managing MySQL indexes?\n\nSeveral tools can help manage and optimize MySQL indexes, including:\n• Percona Monitoring and Management: Provides advanced tools for monitoring index usage and optimizing database performance."
    },
    {
        "link": "https://geeksforgeeks.org/mysql-indexing-best-practices",
        "document": "Optimizing a MySQL database is essential for ensuring optimal performance, scalability, and efficiency. By following best practices and employing optimization techniques we can enhance query execution speed reduce resource consumption and improve overall database performance.\n\nThis article explores various aspects of MySQL database optimization and provides insights into when and how to optimize your database effectively.\n\nIn MySQL, an index is a data structure that improves the speed of the data retrieval operations on a database table at the cost of the additional space and decreased performance on the data modification operations such as the INSERT, UPDATE, and DELETE. Indexes are created on one or more columns of the table to facilitate faster data access by providing a quick lookup mechanism.\n\nTo recognize which queries are performing adversely in MySQL, you can use the statement along with your query. Here's how:\n\nThe EXPLAIN statement in MySQL helps us understand how MySQL processes a query and finds potential performance issues. It shows details about the query execution plan, such as:\n• id : Sequence of the SELECT in the query execution plan.\n• table : The table involved in the query.\n• type : The join type or access method used (e.g., ALL, index, range).\n• possible_keys : Potential indexes that could be used.\n• key : The index actually used.\n• key_len : Length of the index used.\n• rows : Estimated number of rows MySQL examines to execute the query.\n• Extra : Additional information about the query execution (e.g., Using temporary, Using filesort).\n\nConsider a table with columns (primary key) and . Suppose you have a query to retrieve all users:\n\nWhen you execute this statement, MySQL provides the query execution plan. For instance, if the ' table has many rows and no indexes other than the primary key, the output might show ' under the ' column, indicating a full table scan. This can be inefficient for large tables.\n\nTo improve performance, you might add an index on frequently queried columns (e.g., ) and then re-run the statement:\n\nNow, the output might show under the column, indicating that MySQL uses the index to efficiently retrieve rows matching the condition.\n\nBest Practices for Indexing in MySQL\n• Identify High-Volume Queries: Start by identifying the queries that are executed frequently and consume a significant amount of resources. These queries often involve filtering sorting joining large datasets. By targeting these queries for optimization we can achieve significant performance improvements.\n• Choose Appropriate Index Columns: Select the columns for the indexing based on their usage in the , and JOIN clauses of queries. Columns frequently used in search conditions or for sorting should be prioritized for indexing to accelerate data retrieval.\n• Avoid Over-Indexing: While indexes can improve query performance excessive indexing can have adverse effects on database performance. Each additional index consumes storage space and imposes overhead on the data modification operations. Therefore, avoid creating indexes on the columns that are seldom used in the queries or have low selectivity.\n• Utilize Composite Indexes: Composite indexes also known as multi-column indexes are indexes created on multiple columns. They are particularly useful for queries that involve multiple filter conditions or sorting criteria. By creating composite indexes on columns frequently used together in queries we can optimize query performance and reduce index overhead.\n• Monitor Index Usage and Performance: Regularly monitor the usage and performance of indexes using MySQL's built-in monitoring tools such as the Performance indexes unused indexes , and indexes causing performance bottlenecks. Adjust index configurations accordingly to optimize query performance.\n• Consider Indexing Data Types Carefully: Choose the appropriate data types for the indexed columns to minimize index size and optimize query performance. Use integer data types for the numeric columns VARCHAR data types for the variable-length strings and DATE DATETIME data types for the date and time columns. Avoid indexing columns with large text or binary data types unless necessary.\n• Regularly Analyze and Optimize Indexes: ANALYZE TABLE OPTIMIZE TABLE commands. These commands help identify and resolve issues such as index fragmentation, outdated statistics, and inefficient index structures thereby optimizing query performance and maintaining database health.\n\nWhen Should You Optimize the MySQL Database?\n• Regular Maintenance: Perform optimization tasks regularly, especially during low-traffic periods to ensure consistent performance.\n• Performance Degradation: Optimize the database when we observe slowdowns in the query execution or increased resource usage.\n• Scaling Requirements: Optimize database structures and queries as your application scales to handle larger data volumes and increase the user loads.\n• Query Execution Plans: EXPLAIN statement to analyze query execution plans and identify queries performing the full table scans.\n• Missing Indexes: Look for the queries accessing large tables without the appropriate indexes leading to inefficient data retrieval.\n• Composite Index: Use composite indexes for queries that involve multiple columns in the WHERE\n• Multiple Columns Index: Create separate indexes on the individual columns if queries frequently access them independently or in different combinations.\n• Index Usage: Ensure that each column referenced in the OR condition has its index to optimize query performance.\n• Query Rewrite: Consider rewriting the query using the UNION or other techniques to separate OR conditions into individual queries each utilizing its index.\n\nQueries with GROUP BY and ORDER BY\n• Indexing Strategy: Create composite indexes on the columns referenced in the GROUP BY ORDER BY\n• Query Optimization: Use covering indexes to satisfy both the GROUP BY ORDER BY clauses reducing the need for the additional sorting operations.\n• Index Optimization: Create indexes on columns involved in the join conditions to improve join performance.\n• Query Structure: selecting appropriate join algorithms and minimizing redundant or unnecessary joins.\n\nEffective indexing is crucial for optimizing query performance in MySQL databases. By following best practices such as identifying high-volume queries, choosing appropriate index columns avoiding over-indexing and regularly monitoring and optimizing indexes we can significantly enhance the efficiency and responsiveness of the MySQL database. Implementing these indexing best practices empowers database administrators and developers to deliver faster and more reliable database applications ultimately improving the overall user experience."
    },
    {
        "link": "https://stackoverflow.com/questions/41304945/best-type-of-indexing-when-there-is-like-clause",
        "document": "Here is my query:\n\nWhich one is the best index?\n\nOr is there any better option?! You know, when comes in, I'm getting confused bout creating indexes. Because would never take any benefit of indexes. Also in query above I have both , and .. That's why I asked this question to know your opinion about it too.\n\nHere is my table structure:\n\nAnd I'm trying to make a autocomplete suggestion query. Something like this:"
    }
]