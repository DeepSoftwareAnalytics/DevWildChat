[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers",
        "document": "All types and type members have an accessibility level. The accessibility level controls whether they can be used from other code in your assembly or other assemblies. An assembly is a .dll or .exe created by compiling one or more .cs files in a single compilation. Use the following access modifiers to specify the accessibility of a type or member when you declare it:\n• public: Code in any assembly can access this type or member. The accessibility level of the containing type controls the accessibility level of public members of the type.\n• private: Only code declared in the same or can access this member.\n• protected: Only code in the same or in a derived can access this type or member.\n• internal: Only code in the same assembly can access this type or member.\n• protected internal: Only code in the same assembly or in a derived class in another assembly can access this type or member.\n• private protected: Only code in the same assembly and in the same class or a derived class can access the type or member.\n• file: Only code in the same file can access the type or member.\n\nThe modifier on a type causes the compiler to synthesize extra members. The modifier doesn't affect the default accessibility for either a or a .\n\nThe following examples demonstrate how to specify access modifiers on a type and member:\n\nNot all access modifiers are valid for all types or members in all contexts. In some cases, the accessibility of the containing type constrains the accessibility of its members.\n\nMultiple declarations of a partial class or partial member must have the same accessibility. If one declaration of the partial class or member doesn't include an access modifier, the other declarations can't declare an access modifier. The compiler generates an error if multiple declarations for the partial class or method declare different accessibilities.\n\nClasses and structs declared directly within a namespace (aren't nested within other classes or structs) can have , or access. is the default if no access modifier is specified.\n\nStruct members, including nested classes and structs, can be declared , , or . Class members, including nested classes and structs, can be , , , , , or . Class and struct members, including nested classes and structs, have access by default.\n\nDerived classes can't have greater accessibility than their base types. You can't declare a public class that derives from an internal class . If allowed, it would have the effect of making public, because all or members of are accessible from the derived class.\n\nYou can enable specific other assemblies to access your internal types by using the . For more information, see Friend Assemblies.\n\nInterfaces declared directly within a namespace can be or and, just like classes and structs, interfaces default to access. Interface members are by default because the purpose of an interface is to enable other types to access a class or struct. Interface member declarations might include any access modifier. You use access modifiers on members to provide a common implementation needed by all implementors of an interface.\n\nA type declared directly in a namespace has access by default.\n\nFor more information about access modifiers, see the Accessibility Levels page.\n\nMembers of a or (including nested classes and structs) can be declared with any of the six types of access. Struct members can't be declared as , , or because structs don't support inheritance.\n\nNormally, the accessibility of a member isn't greater than the accessibility of the type that contains it. However, a member of an class might be accessible from outside the assembly if the member implements interface methods or overrides virtual methods that are defined in a public base class.\n\nThe type of any member field, property, or event must be at least as accessible as the member itself. Similarly, the return type and the parameter types of any method, indexer, or delegate must be at least as accessible as the member itself. For example, you can't have a method that returns a class unless is also . Likewise, you can't have a property of type if is declared as .\n\nUser-defined operators must always be declared as and . For more information, see Operator overloading.\n\nTo set the access level for a or member, add the appropriate keyword to the member declaration, as shown in the following example.\n\nFinalizers can't have accessibility modifiers. Members of an type are always , and no access modifiers can be applied.\n\nThe access modifier is allowed only on top-level (non-nested) type declarations.\n\nFor more information, see the C# Language Specification. The language specification is the definitive source for C# syntax and usage."
    },
    {
        "link": "https://stackoverflow.com/questions/75111412/whats-the-best-practices-in-c-sharp-for-public-members-that-must-be-used-for-in",
        "document": "In a scenario similar to the one described here, I have 2 different assemblies and I need to declare some members in classes of assembly A that must be used only by my classes in assembly B (I mean, who uses a class of the assembly A must be discouraged to call/use those methods/properties/fields).\n\nWhat is the best practice to declare them?\n• Creating an interface for them (so you need to explicitly cast the class of assembly A to the interface to see them)\n• Naming them with a particular prefix (so I can \"train my user\" to avoid calling/using them)\n• Naming them with the first letter lowercase (so Intellisense will put them at the end and they will be \"more hidden\")\n• Assembly A is built against .net6 (cross-platform) and assembly B is built against net6-windows (O.S. Windows specific)\n• I can't use InternalsVisibleTo because Assembly A must be obfuscated and this prevents obfuscation for internal members.\n\nListed below is the code for a better explanation of those cases."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/396734/is-it-good-practice-to-make-everything-internal-in-c",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/165719/practical-uses-for-the-internal-keyword-in-c-sharp",
        "document": "I know that the internal modifier limits access to the current assembly, but when and in which circumstance should I use it?\n\nCould you please explain what the practical usage is for the internal keyword in C#?\n\nUtility or helper classes/methods that you would like to access from many other classes within the same assembly, but that you want to ensure code in other assemblies can't access. A common use of internal access is in component-based development because it enables a group of components to cooperate in a private manner without being exposed to the rest of the application code. For example, a framework for building graphical user interfaces could provide Control and Form classes that cooperate using members with internal access. Since these members are internal, they are not exposed to code that is using the framework. You can also use the internal modifier along with the assembly level attribute to create \"friend\" assemblies that are granted special access to the target assembly internal classes. This can be useful for creation of unit testing assemblies that are then allowed to call internal members of the assembly to be tested. Of course no other assemblies are granted this level of access, so when you release your system, encapsulation is maintained.\n\nIf Bob needs BigImportantClass then Bob needs to get the people who own project A to sign up to guarantee that BigImportantClass will be written to meet his needs, tested to ensure that it meets his needs, is documented as meeting his needs, and that a process will be put in place to ensure that it will never be changed so as to no longer meet his needs. If a class is internal then it doesn't have to go through that process, which saves budget for Project A that they can spend on other things. The point of internal is not that it makes life difficult for Bob. It's that it allows you to control what expensive promises Project A is making about features, lifetime, compatibility, and so on.\n\nI find internal to be far overused. you really should not be exposing certain functionailty only to certain classes that you would not to other consumers. This in my opinion breaks the interface, breaks the abstraction. This is not to say it should never be used, but a better solution is to refactor to a different class or to be used in a different way if possible. However, this may not be always possible. The reasons it can cause issues is that another developer may be charged with building another class in the same assembly that yours is. Having internals lessens the clarity of the abstraction, and can cause problems if being misused. It would be the same issue as if you made it public. The other class that is being built by the other developer is still a consumer, just like any external class. Class abstraction and encapsulation isnt just for protection for/from external classes, but for any and all classes. Another problem is that a lot of developers will think they may need to use it elsewhere in the assembly and mark it as internal anyways, even though they dont need it at the time. Another developer then may think its there for the taking. Typically you want to mark private until you have a definative need. But some of this can be subjective, and I am not saying it should never be used. Just use when needed.\n\nSaw an interesting one the other day, maybe week, on a blog that I can't remember. Basically I can't take credit for this but I thought it might have some useful application. Say you wanted an abstract class to be seen by another assembly but you don't want someone to be able to inherit from it. Sealed won't work because it's abstract for a reason, other classes in that assembly do inherit from it. Private won't work because you might want to declare a Parent class somewhere in the other assembly. namespace Base.Assembly { public abstract class Parent { internal abstract void SomeMethod(); } //This works just fine since it's in the same assembly. public class ChildWithin : Parent { internal override void SomeMethod() { } } } namespace Another.Assembly { //Kaboom, because you can't override an internal method public class ChildOutside : Parent { } public class Test { //Just fine private Parent _parent; public Test() { //Still fine _parent = new ChildWithin(); } } } As you can see, it effectively allows someone to use the Parent class without being able to inherit from.\n\nA very interesting use of internal - with internal member of course being limited only to the assembly in which it is declared - is getting \"friend\" functionality to some degree out of it. A friend member is something that is visible only to certain other assemblies outside of the assembly in which its declared. C# has no built in support for friend, however the CLR does. You can use InternalsVisibleToAttribute to declare a friend assembly, and all references from within the friend assembly will treat the internal members of your declaring assembly as public within the scope of the friend assembly. A problem with this is that all internal members are visible; you cannot pick and choose. A good use for InternalsVisibleTo is to expose various internal members to a unit test assembly thus eliminating the needs for complex reflection work arounds to test those members. All internal members being visible isn't so much of a problem, however taking this approach does muck up your class interfaces pretty heavily and can potentially ruin encapsulation within the declaring assembly."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions",
        "document": "Coding conventions are essential for maintaining code readability, consistency, and collaboration within a development team. Code that follows industry practices and established guidelines is easier to understand, maintain, and extend. Most projects enforce a consistent style through code conventions. The and projects are no exception. In this series of articles, you learn our coding conventions and the tools we use to enforce them. You can take our conventions as-is, or modify them to suit your team's needs.\n\nWe chose our conventions based on the following goals:\n• Correctness: Our samples are copied and pasted into your applications. We expect that, so we need to make code that's resilient and correct, even after multiple edits.\n• Teaching: The purpose of our samples is to teach all of .NET and C#. For that reason, we don't place restrictions on any language feature or API. Instead, those samples teach when a feature is a good choice.\n• Consistency: Readers expect a consistent experience across our content. All samples should conform to the same style.\n• Adoption: We aggressively update our samples to use new language features. That practice raises awareness of new features, and makes them more familiar to all C# developers.\n\nThese guidelines are used by Microsoft to develop samples and documentation. They were adopted from the .NET Runtime, C# Coding Style and C# compiler (roslyn) guidelines. We chose those guidelines because of their adoption over several years of Open Source development. These guidelines help community members participate in the runtime and compiler projects. They're meant to be an example of common C# conventions, and not an authoritative list (see Framework Design Guidelines for detailed guidelines). The teaching and adoption goals are why the docs coding convention differs from the runtime and compiler conventions. Both the runtime and compiler have strict performance metrics for hot paths. Many other applications don't. Our teaching goal mandates that we don't prohibit any construct. Instead, samples show when constructs should be used. We update samples more aggressively than most production applications do. Our adoption goal mandates that we show code you should write today, even when code written last year doesn't need changes.\n\nThis article explains our guidelines. The guidelines evolve over time, and you'll find samples that don't follow our guidelines. We welcome PRs that bring those samples into compliance, or issues that draw our attention to samples we should update. Our guidelines are Open Source and we welcome PRs and issues. However, if your submission would change these recommendations, open an issue for discussion first. You're welcome to use our guidelines, or adapt them to your needs.\n\nTools can help your team enforce your conventions. You can enable code analysis to enforce the rules you prefer. You can also create an editorconfig so that Visual Studio automatically enforces your style guidelines. As a starting point, you can copy the .editorconfig to use our style.\n\nThese tools make it easier for your team to adopt your preferred guidelines. Visual Studio applies the rules in all .editorconfig files in scope to format your code. You can use multiple configurations to enforce corporate-wide conventions, team conventions, and even granular project conventions.\n\nCode analysis produces warnings and diagnostics when it detects rule violations. You configure the rules you want applied to your project. Then, each CI build notifies developers when they violate any of the rules.\n• Choose appropriate diagnostic IDs when building your own analyzers\n\nThe following sections describe practices that the .NET docs team follows to prepare code examples and samples. In general, follow these practices:\n• Utilize modern language features and C# versions whenever possible.\n• Only catch exceptions that can be properly handled; avoid catching general exceptions. For example, sample code shouldn't catch the System.Exception type without an exception filter.\n• Use LINQ queries and methods for collection manipulation to improve code readability.\n• Use asynchronous programming with async and await for I/O-bound operations.\n• Be cautious of deadlocks and use Task.ConfigureAwait when appropriate.\n• Use the language keywords for data types instead of the runtime types. For example, use instead of System.String, or instead of System.Int32. This recommendation includes using the types and .\n• Use rather than unsigned types. The use of is common throughout C#, and it's easier to interact with other libraries when you use . Exceptions are for documentation specific to unsigned data types.\n• Use only when a reader can infer the type from the expression. Readers view our samples on the docs platform. They don't have hover or tool tips that display the type of variables.\n• Write code with clarity and simplicity in mind.\n• None Use string interpolation to concatenate short strings, as shown in the following code.\n• None To append strings in loops, especially when you're working with large amounts of text, use a System.Text.StringBuilder object.\n• var message = \"\"\" This is a long message that spans across multiple lines. It uses raw string literals. This means we can also include characters like \n\n and \\t without escaping them. \"\"\";\n• None Use the expression-based string interpolation rather than positional string interpolation.\n• None Use Pascal case for primary constructor parameters on record types:\n• None Use camel case for primary constructor parameters on class and struct types.\n• None Use properties instead of constructors to force initialization of property values:\n• Use collection expressions to initialize all collection types:\n• Use and instead of defining delegate types. In a class, define the delegate method.\n• Call the method using the signature defined by the or delegate.\n• None If you create instances of a delegate type, use the concise syntax. In a class, define the delegate type and a method that has a matching signature.\n• None Create an instance of the delegate type and call it. The following declaration shows the condensed syntax.\n• None The following declaration uses the full syntax.\n• None Use a try-catch statement for most exception handling. static double ComputeDistance(double x1, double y1, double x2, double y2) { try { return Math.Sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); } catch (System.ArithmeticException ex) { Console.WriteLine($\"Arithmetic overflow or underflow: {ex}\"); throw; } }\n• None Simplify your code by using the C# using statement. If you have a try-finally statement in which the only code in the block is a call to the Dispose method, use a statement instead. In the following example, the statement only calls in the block. You can do the same thing with a statement. Use the new syntax that doesn't require braces:\n• None Use instead of and instead of when you perform comparisons, as shown in the following example. Console.Write(\"Enter a dividend: \"); int dividend = Convert.ToInt32(Console.ReadLine()); Console.Write(\"Enter a divisor: \"); int divisor = Convert.ToInt32(Console.ReadLine()); if ((divisor != 0) && (dividend / divisor) is var result) { Console.WriteLine(\"Quotient: {0}\", result); } else { Console.WriteLine(\"Attempted division by 0 ends up here.\"); }\n\nIf the divisor is 0, the second clause in the statement would cause a run-time error. But the && operator short-circuits when the first expression is false. That is, it doesn't evaluate the second expression. The & operator would evaluate both, resulting in a run-time error when is 0.\n• None Use one of the concise forms of object instantiation when the variable type matches the object type, as shown in the following declarations. This form isn't valid when the variable is an interface type, or a base class of the runtime type. The preceding declarations are equivalent to the following declaration.\n• None Use object initializers to simplify object creation, as shown in the following example. The following example sets the same properties as the preceding example but doesn't use initializers.\n• Use a lambda expression to define an event handler that you don't need to remove later:\n\nThe lambda expression shortens the following traditional definition.\n\nCall static members by using the class name: ClassName.StaticMember. This practice makes code more readable by making static access clear. Don't qualify a static member defined in a base class with the name of a derived class. While that code compiles, the code readability is misleading, and the code might break in the future if you add a static member with the same name to the derived class.\n• None Use meaningful names for query variables. The following example uses for customers who are located in Seattle. var seattleCustomers = from customer in Customers where customer.City == \"Seattle\" select customer.Name;\n• None Use aliases to make sure that property names of anonymous types are correctly capitalized, using Pascal casing. var localDistributors = from customer in Customers join distributor in Distributors on customer.City equals distributor.City select new { Customer = customer, Distributor = distributor };\n• None Rename properties when the property names in the result would be ambiguous. For example, if your query returns a customer name and a distributor name, instead of leaving them as a form of in the result, rename them to clarify is the name of a customer, and is the name of a distributor. var localDistributors2 = from customer in Customers join distributor in Distributors on customer.City equals distributor.City select new { CustomerName = customer.Name, DistributorName = distributor.Name };\n• None Use implicit typing in the declaration of query variables and range variables. This guidance on implicit typing in LINQ queries overrides the general rules for implicitly typed local variables. LINQ queries often use projections that create anonymous types. Other query expressions create results with nested generic types. Implicit typed variables are often more readable. var seattleCustomers = from customer in Customers where customer.City == \"Seattle\" select customer.Name;\n• None Align query clauses under the clause, as shown in the previous examples.\n• None Use clauses before other query clauses to ensure that later query clauses operate on the reduced, filtered set of data. var seattleCustomers2 = from customer in Customers where customer.City == \"Seattle\" orderby customer.Name select customer;\n• None Access inner collections with multiple clauses instead of a clause. For example, a collection of objects might each contain a collection of test scores. When the following query is executed, it returns each score that is over 90, along with the family name of the student who received the score. var scoreQuery = from student in students from score in student.Scores where score > 90 select new { Last = student.LastName, score };\n• None Use implicit typing for local variables when the type of the variable is obvious from the right side of the assignment. var message = \"This is clearly a string.\"; var currentTemperature = 27;\n• None Don't use var when the type isn't apparent from the right side of the assignment. Don't assume the type is clear from a method name. A variable type is considered clear if it's a operator, an explicit cast, or assignment to a literal value.\n• None Don't use variable names to specify the type of the variable. It might not be correct. Instead, use the type to specify the type, and use the variable name to indicate the semantic information of the variable. The following example should use for the type and something like to indicate the meaning of the information read from the console.\n• None Avoid the use of in place of dynamic. Use when you want run-time type inference. For more information, see Using type dynamic (C# Programming Guide).\n• None Use implicit typing for the loop variable in loops. The following example uses implicit typing in a statement.\n• None Don't use implicit typing to determine the type of the loop variable in loops. In most cases, the type of elements in the collection isn't immediately obvious. The collection's name shouldn't be solely relied upon for inferring the type of its elements. The following example uses explicit typing in a statement. foreach (char ch in laugh) { if (ch == 'h') { Console.Write(\"H\"); } else { Console.Write(ch); } } Console.WriteLine();\n• None use implicit type for the result sequences in LINQ queries. The section on LINQ explains that many LINQ queries result in anonymous types where implicit types must be used. Other queries result in nested generic types where is more readable. Be careful not to accidentally change a type of an element of the iterable collection. For example, it's easy to switch from System.Linq.IQueryable to System.Collections.IEnumerable in a statement, which changes the execution of a query.\n\nSome of our samples explain the natural type of an expression. Those samples must use so that the compiler picks the natural type. Even though those examples are less obvious, the use of is required for the sample. The text should explain the behavior.\n\nMost code files declare a single namespace. Therefore, our examples should use the file scoped namespace declarations:\n\nPlace the using directives outside the namespace declaration\n\nWhen a directive is outside a namespace declaration, that imported namespace is its fully qualified name. The fully qualified name is clearer. When the directive is inside the namespace, it could be either relative to that namespace, or its fully qualified name.\n\nAssuming there's a reference (direct, or indirect) to the WaitUntil class.\n\nAnd it compiles today. And tomorrow. But then sometime next week the preceding (untouched) code fails with two errors:\n\nOne of the dependencies introduced this class in a namespace then ends with :\n\nA directive placed inside a namespace is context-sensitive and complicates name resolution. In this example, it's the first namespace that it finds.\n\nAdding a new namespace that matches either or would match before the global namespace. You could resolve it by adding the modifier to the declaration. However, it's easier to place declarations outside the namespace instead.\n\nIn general, use the following format for code samples:\n• Use four spaces for indentation. Don't use tabs.\n• Limit lines to 65 characters to enhance code readability on docs, especially on mobile screens.\n• Improve clarity and user experience by breaking long statements into multiple lines.\n• Use the \"Allman\" style for braces: open and closing brace its own new line. Braces line up with current indentation level.\n• Line breaks should occur before binary operators, if necessary.\n• None Use single-line comments ( ) for brief explanations.\n• None Avoid multi-line comments ( ) for longer explanations.\n\nComments in the code samples aren't localized. That means explanations embedded in the code aren't translated. Longer, explanatory text should be placed in the companion article, so that it can be localized.\n• None For describing methods, classes, fields, and all public members use XML comments.\n• None Place the comment on a separate line, not at the end of a line of code.\n• None Insert one space between the comment delimiter ( ) and the comment text, as shown in the following example. // The following declaration creates a query. It does not run // the query.\n\nGood layout uses formatting to emphasize the structure of your code and to make the code easier to read. Microsoft examples and samples conform to the following conventions:\n• None Use the default Code Editor settings (smart indenting, four-character indents, tabs saved as spaces). For more information, see Options, Text Editor, C#, Formatting.\n• None Write only one statement per line.\n• None Write only one declaration per line.\n• None If continuation lines aren't indented automatically, indent them one tab stop (four spaces).\n• None Add at least one blank line between method definitions and property definitions.\n• None Use parentheses to make clauses in an expression apparent, as shown in the following code. if ((startX > endX) && (startX > previousX)) { // Take appropriate action. }\n\nExceptions are when the sample explains operator or expression precedence."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.console.writeline?view=net-9.0",
        "document": "Writes the text representation of the specified objects, followed by the current line terminator, to the standard output stream using the specified format information. Writes the specified string value, followed by the current line terminator, to the standard output stream. Writes the specified subarray of Unicode characters, followed by the current line terminator, to the standard output stream. Writes the text representation of the specified span of objects, followed by the current line terminator, to the standard output stream using the specified format information. Writes the text representation of the specified array of objects, followed by the current line terminator, to the standard output stream using the specified format information. Writes the text representation of the specified object, followed by the current line terminator, to the standard output stream using the specified format information. Writes the text representation of the specified 64-bit unsigned integer value, followed by the current line terminator, to the standard output stream. Writes the text representation of the specified 32-bit unsigned integer value, followed by the current line terminator, to the standard output stream. Writes the text representation of the specified single-precision floating-point value, followed by the current line terminator, to the standard output stream. Writes the text representation of the specified double-precision floating-point value, followed by the current line terminator, to the standard output stream. Writes the text representation of the specified object, followed by the current line terminator, to the standard output stream. Writes the text representation of the specified 64-bit signed integer value, followed by the current line terminator, to the standard output stream. Writes the text representation of the specified 32-bit signed integer value, followed by the current line terminator, to the standard output stream. Writes the text representation of the specified Decimal value, followed by the current line terminator, to the standard output stream. Writes the specified array of Unicode characters, followed by the current line terminator, to the standard output stream. Writes the specified Unicode character, followed by the current line terminator, value to the standard output stream. Writes the text representation of the specified Boolean value, followed by the current line terminator, to the standard output stream. Writes the current line terminator to the standard output stream. Writes the text representation of the specified objects, followed by the current line terminator, to the standard output stream using the specified format information. Writes the text representation of the specified objects and variable-length parameter list, followed by the current line terminator, to the standard output stream using the specified format information.\n\nThe default line terminator is a string whose value is a carriage return followed by a line feed (\"\\r\n\n\" in C#, or in Visual Basic). You can change the line terminator by setting the TextWriter.NewLine property of the Out property to another string.\n\nWrites the text representation of the specified objects, followed by the current line terminator, to the standard output stream using the specified format information. Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object) The first object to write using . The second object to write using . The format specification in is invalid. The following example demonstrates the standard formatting specifiers for numbers, dates, and enumerations. // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. using namespace System; public enum class Color {Yellow = 1, Blue, Green}; int main() { DateTime thisDate = DateTime::Now; Console::Clear(); // Format a negative integer or floating-point number in various ways. Console::WriteLine(\"Standard Numeric Format Specifiers\"); Console::WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f); // Format the current date in various ways. Console::WriteLine(\"Standard DateTime Format Specifiers\"); Console::WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate); // Format a Color enumeration value in various ways. Console::WriteLine(\"Standard Enumeration Format Specifiers\"); Console::WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color::Green); }; /* This code example produces the following results: Standard Numeric Format Specifiers (C) Currency: . . . . . . . . ($123.00) (D) Decimal:. . . . . . . . . -123 (E) Scientific: . . . . . . . -1.234500E+002 (F) Fixed point:. . . . . . . -123.45 (G) General:. . . . . . . . . -123 (default):. . . . . . . . -123 (default = 'G') (N) Number: . . . . . . . . . -123.00 (P) Percent:. . . . . . . . . -12,345.00 % (R) Round-trip: . . . . . . . -123.45 (X) Hexadecimal:. . . . . . . FFFFFF85 Standard DateTime Format Specifiers (d) Short date: . . . . . . . 6/26/2004 (D) Long date:. . . . . . . . Saturday, June 26, 2004 (t) Short time: . . . . . . . 8:11 PM (T) Long time:. . . . . . . . 8:11:04 PM (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM (g) General date/short time:. 6/26/2004 8:11 PM (G) General date/long time: . 6/26/2004 8:11:04 PM (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') (M) Month:. . . . . . . . . . June 26 (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM (Y) Year: . . . . . . . . . . June, 2004 Standard Enumeration Format Specifiers (G) General:. . . . . . . . . Green (default):. . . . . . . . Green (default = 'G') (F) Flags:. . . . . . . . . . Green (flags or integer) (D) Decimal number: . . . . . 3 (X) Hexadecimal:. . . . . . . 00000003 */ // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. using System; class Sample { enum Color {Yellow = 1, Blue, Green}; static DateTime thisDate = DateTime.Now; public static void Main() { Console.Clear(); // Format a negative integer or floating-point number in various ways. Console.WriteLine(\"Standard Numeric Format Specifiers\"); Console.WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f); // Format the current date in various ways. Console.WriteLine(\"Standard DateTime Format Specifiers\"); Console.WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate); // Format a Color enumeration value in various ways. Console.WriteLine(\"Standard Enumeration Format Specifiers\"); Console.WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color.Green); } } /* This code example produces the following results: Standard Numeric Format Specifiers (C) Currency: . . . . . . . . ($123.00) (D) Decimal:. . . . . . . . . -123 (E) Scientific: . . . . . . . -1.234500E+002 (F) Fixed point:. . . . . . . -123.45 (G) General:. . . . . . . . . -123 (default):. . . . . . . . -123 (default = 'G') (N) Number: . . . . . . . . . -123.00 (P) Percent:. . . . . . . . . -12,345.00 % (R) Round-trip: . . . . . . . -123.45 (X) Hexadecimal:. . . . . . . FFFFFF85 Standard DateTime Format Specifiers (d) Short date: . . . . . . . 6/26/2004 (D) Long date:. . . . . . . . Saturday, June 26, 2004 (t) Short time: . . . . . . . 8:11 PM (T) Long time:. . . . . . . . 8:11:04 PM (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM (g) General date/short time:. 6/26/2004 8:11 PM (G) General date/long time: . 6/26/2004 8:11:04 PM (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') (M) Month:. . . . . . . . . . June 26 (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM (Y) Year: . . . . . . . . . . June, 2004 Standard Enumeration Format Specifiers (G) General:. . . . . . . . . Green (default):. . . . . . . . Green (default = 'G') (F) Flags:. . . . . . . . . . Green (flags or integer) (D) Decimal number: . . . . . 3 (X) Hexadecimal:. . . . . . . 00000003 */ // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. open System type Color = | Yellow = 1 | Blue = 2 | Green = 3 let thisDate = DateTime.Now Console.Clear() // Format a negative integer or floating-point number in various ways. Console.WriteLine \"Standard Numeric Format Specifiers\" Console.WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f) // Format the current date in various ways. Console.WriteLine \"Standard DateTime Format Specifiers\" Console.WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate) // Format a Color enumeration value in various ways. Console.WriteLine \"Standard Enumeration Format Specifiers\" Console.WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color.Green) // This code example produces the following results: // // Standard Numeric Format Specifiers // (C) Currency: . . . . . . . . ($123.00) // (D) Decimal:. . . . . . . . . -123 // (E) Scientific: . . . . . . . -1.234500E+002 // (F) Fixed point:. . . . . . . -123.45 // (G) General:. . . . . . . . . -123 // (default):. . . . . . . . -123 (default = 'G') // (N) Number: . . . . . . . . . -123.00 // (P) Percent:. . . . . . . . . -12,345.00 % // (R) Round-trip: . . . . . . . -123.45 // (X) Hexadecimal:. . . . . . . FFFFFF85 // // Standard DateTime Format Specifiers // (d) Short date: . . . . . . . 6/26/2004 // (D) Long date:. . . . . . . . Saturday, June 26, 2004 // (t) Short time: . . . . . . . 8:11 PM // (T) Long time:. . . . . . . . 8:11:04 PM // (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM // (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM // (g) General date/short time:. 6/26/2004 8:11 PM // (G) General date/long time: . 6/26/2004 8:11:04 PM // (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') // (M) Month:. . . . . . . . . . June 26 // (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT // (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 // (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) // (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM // (Y) Year: . . . . . . . . . . June, 2004 // // Standard Enumeration Format Specifiers // (G) General:. . . . . . . . . Green // (default):. . . . . . . . Green (default = 'G') // (F) Flags:. . . . . . . . . . Green (flags or integer) // (D) Decimal number: . . . . . 3 // (X) Hexadecimal:. . . . . . . 00000003 ' This code example demonstrates the Console.WriteLine() method. ' Formatting for this example uses the \"en-US\" culture. Class Sample Public Enum Color Yellow = 1 Blue = 2 Green = 3 End Enum 'Color Private Shared thisDate As DateTime = DateTime.Now Public Shared Sub Main() Console.Clear() ' Format a negative integer or floating-point number in various ways. Console.WriteLine(\"Standard Numeric Format Specifiers\") Console.WriteLine(\"(C) Currency: . . . . . . . . {0:C}\" & vbCrLf & _ \"(D) Decimal:. . . . . . . . . {0:D}\" & vbCrLf & _ \"(E) Scientific: . . . . . . . {1:E}\" & vbCrLf & _ \"(F) Fixed point:. . . . . . . {1:F}\" & vbCrLf & _ \"(G) General:. . . . . . . . . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(N) Number: . . . . . . . . . {0:N}\" & vbCrLf & _ \"(P) Percent:. . . . . . . . . {1:P}\" & vbCrLf & _ \"(R) Round-trip: . . . . . . . {1:R}\" & vbCrLf & _ \"(X) Hexadecimal:. . . . . . . {0:X}\" & vbCrLf, _ - 123, - 123.45F) ' Format the current date in various ways. Console.WriteLine(\"Standard DateTime Format Specifiers\") Console.WriteLine(\"(d) Short date: . . . . . . . {0:d}\" & vbCrLf & _ \"(D) Long date:. . . . . . . . {0:D}\" & vbCrLf & _ \"(t) Short time: . . . . . . . {0:t}\" & vbCrLf & _ \"(T) Long time:. . . . . . . . {0:T}\" & vbCrLf & _ \"(f) Full date/short time: . . {0:f}\" & vbCrLf & _ \"(F) Full date/long time:. . . {0:F}\" & vbCrLf & _ \"(g) General date/short time:. {0:g}\" & vbCrLf & _ \"(G) General date/long time: . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(M) Month:. . . . . . . . . . {0:M}\" & vbCrLf & _ \"(R) RFC1123:. . . . . . . . . {0:R}\" & vbCrLf & _ \"(s) Sortable: . . . . . . . . {0:s}\" & vbCrLf & _ \"(u) Universal sortable: . . . {0:u} (invariant)\" & vbCrLf & _ \"(U) Universal full date/time: {0:U}\" & vbCrLf & _ \"(Y) Year: . . . . . . . . . . {0:Y}\" & vbCrLf, _ thisDate) ' Format a Color enumeration value in various ways. Console.WriteLine(\"Standard Enumeration Format Specifiers\") Console.WriteLine(\"(G) General:. . . . . . . . . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\" & vbCrLf & _ \"(D) Decimal number: . . . . . {0:D}\" & vbCrLf & _ \"(X) Hexadecimal:. . . . . . . {0:X}\" & vbCrLf, _ Color.Green) End Sub End Class ' 'This code example produces the following results: ' 'Standard Numeric Format Specifiers '(C) Currency: . . . . . . . . ($123.00) '(D) Decimal:. . . . . . . . . -123 '(E) Scientific: . . . . . . . -1.234500E+002 '(F) Fixed point:. . . . . . . -123.45 '(G) General:. . . . . . . . . -123 ' (default):. . . . . . . . -123 (default = 'G') '(N) Number: . . . . . . . . . -123.00 '(P) Percent:. . . . . . . . . -12,345.00 % '(R) Round-trip: . . . . . . . -123.45 '(X) Hexadecimal:. . . . . . . FFFFFF85 ' 'Standard DateTime Format Specifiers '(d) Short date: . . . . . . . 6/26/2004 '(D) Long date:. . . . . . . . Saturday, June 26, 2004 '(t) Short time: . . . . . . . 8:11 PM '(T) Long time:. . . . . . . . 8:11:04 PM '(f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM '(F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM '(g) General date/short time:. 6/26/2004 8:11 PM '(G) General date/long time: . 6/26/2004 8:11:04 PM ' (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') '(M) Month:. . . . . . . . . . June 26 '(R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT '(s) Sortable: . . . . . . . . 2004-06-26T20:11:04 '(u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) '(U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM '(Y) Year: . . . . . . . . . . June, 2004 ' 'Standard Enumeration Format Specifiers '(G) General:. . . . . . . . . Green ' (default):. . . . . . . . Green (default = 'G') '(F) Flags:. . . . . . . . . . Green (flags or integer) '(D) Decimal number: . . . . . 3 '(X) Hexadecimal:. . . . . . . 00000003 ' The following example is a tip calculator that calculates an 18% tip and uses the WriteLine method to display the amount of the original charge, the amount of the tip, and the total amount. The example is a console application that requires the user to supply the amount of the original charge as a command-line parameter. using System; public class TipCalculator { private const double tipRate = 0.18; public static void Main(string[] args) { double billTotal; if (args.Length == 0 || ! Double.TryParse(args[0], out billTotal)) { Console.WriteLine(\"usage: TIPCALC total\"); return; } double tip = billTotal * tipRate; Console.WriteLine(); Console.WriteLine($\"Bill total:\\t{billTotal,8:c}\"); Console.WriteLine($\"Tip total/rate:\\t{tip,8:c} ({tipRate:p1})\"); Console.WriteLine((\"\").PadRight(24, '-')); Console.WriteLine($\"Grand total:\\t{billTotal + tip,8:c}\"); } } /* >tipcalc 52.23 Bill total: $52.23 Tip total/rate: $9.40 (18.0 %) ------------------------ Grand total: $61.63 */ open System let tipRate = 0.18 let args = Environment.GetCommandLineArgs()[1..] if args.Length = 0 then Console.WriteLine \"usage: TIPCALC total\" else match Double.TryParse args[0] with | true, billTotal -> let tip = billTotal * tipRate Console.WriteLine() Console.WriteLine $\"Bill total:\\t{billTotal,8:c}\" Console.WriteLine $\"Tip total/rate:\\t{tip,8:c} ({tipRate:p1})\" Console.WriteLine(\"\".PadRight(24, '-')) Console.WriteLine $\"Grand total:\\t{billTotal + tip,8:c}\" | _ -> Console.WriteLine \"usage: TIPCALC total\" // >tipcalc 52.23 // // Bill total: $52.23 // Tip total/rate: $9.40 (18.0 %) // ------------------------ // Grand total: $61.63 Public Module TipCalculator Private Const tipRate As Double = 0.18 Public Sub Main(args As String()) Dim billTotal As Double If (args.Length = 0) OrElse (Not Double.TryParse(args(0), billTotal)) Then Console.WriteLine(\"usage: TIPCALC total\") Return End If Dim tip As Double = billTotal * tipRate Console.WriteLine() Console.WriteLine($\"Bill total:{vbTab}{billTotal,8:c}\") Console.WriteLine($\"Tip total/rate:{vbTab}{tip,8:c} ({tipRate:p1})\") Console.WriteLine(\"\".PadRight(24, \"-\"c)) Console.WriteLine($\"Grand total:{vbTab}{billTotal + tip,8:c}\") End Sub End Module 'Example Output: '--------------- ' >tipcalc 52.23 ' ' Bill total: $52.23 ' Tip total/rate: $9.40 (18.0 %) ' ------------------------ ' Grand total: $61.63 This method uses the composite formatting feature of .NET to convert the value of an object to its text representation and embed that representation in a string. The resulting string is written to the output stream. The parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to an object in the parameter list of this method. The formatting process replaces each format item with the text representation of the value of the corresponding object. The syntax of a format item is index[ alignment][ formatString] , which specifies a mandatory index, the optional length and alignment of the formatted text, and an optional string of format specifier characters that govern how the value of the corresponding object is formatted. .NET provides extensive formatting support, which is described in greater detail in the following formatting topics.\n• None For more information about the composite formatting feature supported by methods such as Format, AppendFormat, and some overloads of WriteLine, see Composite Formatting.\n• None For more information about numeric format specifiers, see Standard Numeric Format Strings and Custom Numeric Format Strings.\n• None For more information about date and time format specifiers, see Standard Date and Time Format Strings and Custom Date and Time Format Strings.\n• None For more information about enumeration format specifiers, see Enumeration Format Strings.\n• None For more information about formatting, see Formatting Types. For more information about the line terminator, see the Remarks section of the WriteLine method that takes no parameters.\n\nWrites the specified string value, followed by the current line terminator, to the standard output stream. Public Shared Sub WriteLine (value As String) The example changes the line terminator from its default value of \"\\r\n\n\" or to \"\\r\n\n\\r\n\n\" or + . It then calls the WriteLine() and WriteLine(String) methods to display output to the console. using namespace System; void main() { array<String^>^ lines = gcnew array<String^> { \"This is the first line.\", \"This is the second line.\" }; // Output the lines using the default newline sequence. Console::WriteLine(\"With the default new line characters:\"); Console::WriteLine(); for each (String^ line in lines) Console::WriteLine(line); Console::WriteLine(); // Redefine the newline characters to double space. Console::Out->NewLine = \"\\r\n\n\\r\n\n\"; // Output the lines using the new newline sequence. Console::WriteLine(\"With redefined new line characters:\"); Console::WriteLine(); for each (String^ line in lines) Console::WriteLine(line); } // The example displays the following output: // With the default new line characters: // // This is the first line. // This is the second line. // // With redefined new line characters: // // // // This is the first line. // // This is the second line. string[] lines = { \"This is the first line.\", \"This is the second line.\" }; // Output the lines using the default newline sequence. Console.WriteLine(\"With the default new line characters:\"); Console.WriteLine(); foreach (string line in lines) Console.WriteLine(line); Console.WriteLine(); // Redefine the newline characters to double space. Console.Out.NewLine = \"\\r\n\n\\r\n\n\"; // Output the lines using the new newline sequence. Console.WriteLine(\"With redefined new line characters:\"); Console.WriteLine(); foreach (string line in lines) Console.WriteLine(line); // The example displays the following output: // With the default new line characters: // // This is the first line. // This is the second line. // // With redefined new line characters: // // // // This is the first line. // // This is the second line. let lines = [ \"This is the first line.\" \"This is the second line.\" ] // Output the lines using the default newline sequence. Console.WriteLine \"With the default new line characters:\" Console.WriteLine() for line in lines do Console.WriteLine line Console.WriteLine() // Redefine the newline characters to double space. Console.Out.NewLine <- \"\\r\n\n\\r\n\n\" // Output the lines using the new newline sequence. Console.WriteLine \"With redefined new line characters:\" Console.WriteLine() for line in lines do Console.WriteLine line // The example displays the following output: // With the default new line characters: // // This is the first line. // This is the second line. // // With redefined new line characters: // // // // This is the first line. // // This is the second line. Module Example Public Sub Main() Dim lines() As String = { \"This is the first line.\", _ \"This is the second line.\" } ' Output the lines using the default newline sequence. Console.WriteLine(\"With the default new line characters:\") Console.WriteLine() For Each line As String In lines Console.WriteLine(line) Next Console.WriteLine() ' Redefine the newline characters to double space. Console.Out.NewLine = vbCrLf + vbCrLf ' Output the lines using the new newline sequence. Console.WriteLine(\"With redefined new line characters:\") Console.WriteLine() For Each line As String In lines Console.WriteLine(line) Next End Sub End Module ' The example displays the following output: ' With the default new line characters: ' ' This is the first line. ' This is the second line. ' ' With redefined new line characters: ' ' ' ' This is the first line. ' ' This is the second line. If value is , only the line terminator is written to the standard output stream. For more information about the line terminator, see the Remarks section of the WriteLine() method.\n\nWrites the text representation of the specified array of objects, followed by the current line terminator, to the standard output stream using the specified format information. Public Shared Sub WriteLine (format As String, ParamArray arg As Object()) An array of objects to write using . The format specification in is invalid. The following example demonstrates the standard formatting specifiers for numbers, dates, and enumerations. // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. using namespace System; public enum class Color {Yellow = 1, Blue, Green}; int main() { DateTime thisDate = DateTime::Now; Console::Clear(); // Format a negative integer or floating-point number in various ways. Console::WriteLine(\"Standard Numeric Format Specifiers\"); Console::WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f); // Format the current date in various ways. Console::WriteLine(\"Standard DateTime Format Specifiers\"); Console::WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate); // Format a Color enumeration value in various ways. Console::WriteLine(\"Standard Enumeration Format Specifiers\"); Console::WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color::Green); }; /* This code example produces the following results: Standard Numeric Format Specifiers (C) Currency: . . . . . . . . ($123.00) (D) Decimal:. . . . . . . . . -123 (E) Scientific: . . . . . . . -1.234500E+002 (F) Fixed point:. . . . . . . -123.45 (G) General:. . . . . . . . . -123 (default):. . . . . . . . -123 (default = 'G') (N) Number: . . . . . . . . . -123.00 (P) Percent:. . . . . . . . . -12,345.00 % (R) Round-trip: . . . . . . . -123.45 (X) Hexadecimal:. . . . . . . FFFFFF85 Standard DateTime Format Specifiers (d) Short date: . . . . . . . 6/26/2004 (D) Long date:. . . . . . . . Saturday, June 26, 2004 (t) Short time: . . . . . . . 8:11 PM (T) Long time:. . . . . . . . 8:11:04 PM (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM (g) General date/short time:. 6/26/2004 8:11 PM (G) General date/long time: . 6/26/2004 8:11:04 PM (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') (M) Month:. . . . . . . . . . June 26 (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM (Y) Year: . . . . . . . . . . June, 2004 Standard Enumeration Format Specifiers (G) General:. . . . . . . . . Green (default):. . . . . . . . Green (default = 'G') (F) Flags:. . . . . . . . . . Green (flags or integer) (D) Decimal number: . . . . . 3 (X) Hexadecimal:. . . . . . . 00000003 */ // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. using System; class Sample { enum Color {Yellow = 1, Blue, Green}; static DateTime thisDate = DateTime.Now; public static void Main() { Console.Clear(); // Format a negative integer or floating-point number in various ways. Console.WriteLine(\"Standard Numeric Format Specifiers\"); Console.WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f); // Format the current date in various ways. Console.WriteLine(\"Standard DateTime Format Specifiers\"); Console.WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate); // Format a Color enumeration value in various ways. Console.WriteLine(\"Standard Enumeration Format Specifiers\"); Console.WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color.Green); } } /* This code example produces the following results: Standard Numeric Format Specifiers (C) Currency: . . . . . . . . ($123.00) (D) Decimal:. . . . . . . . . -123 (E) Scientific: . . . . . . . -1.234500E+002 (F) Fixed point:. . . . . . . -123.45 (G) General:. . . . . . . . . -123 (default):. . . . . . . . -123 (default = 'G') (N) Number: . . . . . . . . . -123.00 (P) Percent:. . . . . . . . . -12,345.00 % (R) Round-trip: . . . . . . . -123.45 (X) Hexadecimal:. . . . . . . FFFFFF85 Standard DateTime Format Specifiers (d) Short date: . . . . . . . 6/26/2004 (D) Long date:. . . . . . . . Saturday, June 26, 2004 (t) Short time: . . . . . . . 8:11 PM (T) Long time:. . . . . . . . 8:11:04 PM (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM (g) General date/short time:. 6/26/2004 8:11 PM (G) General date/long time: . 6/26/2004 8:11:04 PM (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') (M) Month:. . . . . . . . . . June 26 (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM (Y) Year: . . . . . . . . . . June, 2004 Standard Enumeration Format Specifiers (G) General:. . . . . . . . . Green (default):. . . . . . . . Green (default = 'G') (F) Flags:. . . . . . . . . . Green (flags or integer) (D) Decimal number: . . . . . 3 (X) Hexadecimal:. . . . . . . 00000003 */ // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. open System type Color = | Yellow = 1 | Blue = 2 | Green = 3 let thisDate = DateTime.Now Console.Clear() // Format a negative integer or floating-point number in various ways. Console.WriteLine \"Standard Numeric Format Specifiers\" Console.WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f) // Format the current date in various ways. Console.WriteLine \"Standard DateTime Format Specifiers\" Console.WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate) // Format a Color enumeration value in various ways. Console.WriteLine \"Standard Enumeration Format Specifiers\" Console.WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color.Green) // This code example produces the following results: // // Standard Numeric Format Specifiers // (C) Currency: . . . . . . . . ($123.00) // (D) Decimal:. . . . . . . . . -123 // (E) Scientific: . . . . . . . -1.234500E+002 // (F) Fixed point:. . . . . . . -123.45 // (G) General:. . . . . . . . . -123 // (default):. . . . . . . . -123 (default = 'G') // (N) Number: . . . . . . . . . -123.00 // (P) Percent:. . . . . . . . . -12,345.00 % // (R) Round-trip: . . . . . . . -123.45 // (X) Hexadecimal:. . . . . . . FFFFFF85 // // Standard DateTime Format Specifiers // (d) Short date: . . . . . . . 6/26/2004 // (D) Long date:. . . . . . . . Saturday, June 26, 2004 // (t) Short time: . . . . . . . 8:11 PM // (T) Long time:. . . . . . . . 8:11:04 PM // (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM // (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM // (g) General date/short time:. 6/26/2004 8:11 PM // (G) General date/long time: . 6/26/2004 8:11:04 PM // (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') // (M) Month:. . . . . . . . . . June 26 // (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT // (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 // (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) // (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM // (Y) Year: . . . . . . . . . . June, 2004 // // Standard Enumeration Format Specifiers // (G) General:. . . . . . . . . Green // (default):. . . . . . . . Green (default = 'G') // (F) Flags:. . . . . . . . . . Green (flags or integer) // (D) Decimal number: . . . . . 3 // (X) Hexadecimal:. . . . . . . 00000003 ' This code example demonstrates the Console.WriteLine() method. ' Formatting for this example uses the \"en-US\" culture. Class Sample Public Enum Color Yellow = 1 Blue = 2 Green = 3 End Enum 'Color Private Shared thisDate As DateTime = DateTime.Now Public Shared Sub Main() Console.Clear() ' Format a negative integer or floating-point number in various ways. Console.WriteLine(\"Standard Numeric Format Specifiers\") Console.WriteLine(\"(C) Currency: . . . . . . . . {0:C}\" & vbCrLf & _ \"(D) Decimal:. . . . . . . . . {0:D}\" & vbCrLf & _ \"(E) Scientific: . . . . . . . {1:E}\" & vbCrLf & _ \"(F) Fixed point:. . . . . . . {1:F}\" & vbCrLf & _ \"(G) General:. . . . . . . . . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(N) Number: . . . . . . . . . {0:N}\" & vbCrLf & _ \"(P) Percent:. . . . . . . . . {1:P}\" & vbCrLf & _ \"(R) Round-trip: . . . . . . . {1:R}\" & vbCrLf & _ \"(X) Hexadecimal:. . . . . . . {0:X}\" & vbCrLf, _ - 123, - 123.45F) ' Format the current date in various ways. Console.WriteLine(\"Standard DateTime Format Specifiers\") Console.WriteLine(\"(d) Short date: . . . . . . . {0:d}\" & vbCrLf & _ \"(D) Long date:. . . . . . . . {0:D}\" & vbCrLf & _ \"(t) Short time: . . . . . . . {0:t}\" & vbCrLf & _ \"(T) Long time:. . . . . . . . {0:T}\" & vbCrLf & _ \"(f) Full date/short time: . . {0:f}\" & vbCrLf & _ \"(F) Full date/long time:. . . {0:F}\" & vbCrLf & _ \"(g) General date/short time:. {0:g}\" & vbCrLf & _ \"(G) General date/long time: . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(M) Month:. . . . . . . . . . {0:M}\" & vbCrLf & _ \"(R) RFC1123:. . . . . . . . . {0:R}\" & vbCrLf & _ \"(s) Sortable: . . . . . . . . {0:s}\" & vbCrLf & _ \"(u) Universal sortable: . . . {0:u} (invariant)\" & vbCrLf & _ \"(U) Universal full date/time: {0:U}\" & vbCrLf & _ \"(Y) Year: . . . . . . . . . . {0:Y}\" & vbCrLf, _ thisDate) ' Format a Color enumeration value in various ways. Console.WriteLine(\"Standard Enumeration Format Specifiers\") Console.WriteLine(\"(G) General:. . . . . . . . . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\" & vbCrLf & _ \"(D) Decimal number: . . . . . {0:D}\" & vbCrLf & _ \"(X) Hexadecimal:. . . . . . . {0:X}\" & vbCrLf, _ Color.Green) End Sub End Class ' 'This code example produces the following results: ' 'Standard Numeric Format Specifiers '(C) Currency: . . . . . . . . ($123.00) '(D) Decimal:. . . . . . . . . -123 '(E) Scientific: . . . . . . . -1.234500E+002 '(F) Fixed point:. . . . . . . -123.45 '(G) General:. . . . . . . . . -123 ' (default):. . . . . . . . -123 (default = 'G') '(N) Number: . . . . . . . . . -123.00 '(P) Percent:. . . . . . . . . -12,345.00 % '(R) Round-trip: . . . . . . . -123.45 '(X) Hexadecimal:. . . . . . . FFFFFF85 ' 'Standard DateTime Format Specifiers '(d) Short date: . . . . . . . 6/26/2004 '(D) Long date:. . . . . . . . Saturday, June 26, 2004 '(t) Short time: . . . . . . . 8:11 PM '(T) Long time:. . . . . . . . 8:11:04 PM '(f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM '(F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM '(g) General date/short time:. 6/26/2004 8:11 PM '(G) General date/long time: . 6/26/2004 8:11:04 PM ' (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') '(M) Month:. . . . . . . . . . June 26 '(R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT '(s) Sortable: . . . . . . . . 2004-06-26T20:11:04 '(u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) '(U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM '(Y) Year: . . . . . . . . . . June, 2004 ' 'Standard Enumeration Format Specifiers '(G) General:. . . . . . . . . Green ' (default):. . . . . . . . Green (default = 'G') '(F) Flags:. . . . . . . . . . Green (flags or integer) '(D) Decimal number: . . . . . 3 '(X) Hexadecimal:. . . . . . . 00000003 ' The following example is a tip calculator that calculates an 18% tip and uses the WriteLine method to display the amount of the original charge, the amount of the tip, and the total amount. The example is a console application that requires the user to supply the amount of the original charge as a command-line parameter. using System; public class TipCalculator { private const double tipRate = 0.18; public static void Main(string[] args) { double billTotal; if (args.Length == 0 || ! Double.TryParse(args[0], out billTotal)) { Console.WriteLine(\"usage: TIPCALC total\"); return; } double tip = billTotal * tipRate; Console.WriteLine(); Console.WriteLine($\"Bill total:\\t{billTotal,8:c}\"); Console.WriteLine($\"Tip total/rate:\\t{tip,8:c} ({tipRate:p1})\"); Console.WriteLine((\"\").PadRight(24, '-')); Console.WriteLine($\"Grand total:\\t{billTotal + tip,8:c}\"); } } /* >tipcalc 52.23 Bill total: $52.23 Tip total/rate: $9.40 (18.0 %) ------------------------ Grand total: $61.63 */ open System let tipRate = 0.18 let args = Environment.GetCommandLineArgs()[1..] if args.Length = 0 then Console.WriteLine \"usage: TIPCALC total\" else match Double.TryParse args[0] with | true, billTotal -> let tip = billTotal * tipRate Console.WriteLine() Console.WriteLine $\"Bill total:\\t{billTotal,8:c}\" Console.WriteLine $\"Tip total/rate:\\t{tip,8:c} ({tipRate:p1})\" Console.WriteLine(\"\".PadRight(24, '-')) Console.WriteLine $\"Grand total:\\t{billTotal + tip,8:c}\" | _ -> Console.WriteLine \"usage: TIPCALC total\" // >tipcalc 52.23 // // Bill total: $52.23 // Tip total/rate: $9.40 (18.0 %) // ------------------------ // Grand total: $61.63 Public Module TipCalculator Private Const tipRate As Double = 0.18 Public Sub Main(args As String()) Dim billTotal As Double If (args.Length = 0) OrElse (Not Double.TryParse(args(0), billTotal)) Then Console.WriteLine(\"usage: TIPCALC total\") Return End If Dim tip As Double = billTotal * tipRate Console.WriteLine() Console.WriteLine($\"Bill total:{vbTab}{billTotal,8:c}\") Console.WriteLine($\"Tip total/rate:{vbTab}{tip,8:c} ({tipRate:p1})\") Console.WriteLine(\"\".PadRight(24, \"-\"c)) Console.WriteLine($\"Grand total:{vbTab}{billTotal + tip,8:c}\") End Sub End Module 'Example Output: '--------------- ' >tipcalc 52.23 ' ' Bill total: $52.23 ' Tip total/rate: $9.40 (18.0 %) ' ------------------------ ' Grand total: $61.63 This method uses the composite formatting feature of .NET to convert the value of an object to its text representation and embed that representation in a string. The resulting string is written to the output stream. The parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to an object in the parameter list of this method. The formatting process replaces each format item with the text representation of the value of the corresponding object. The syntax of a format item is index[ alignment][ formatString] , which specifies a mandatory index, the optional length and alignment of the formatted text, and an optional string of format specifier characters that govern how the value of the corresponding object is formatted. .NET provides extensive formatting support, which is described in greater detail in the following formatting topics.\n• None For more information about the composite formatting feature supported by methods such as Format, AppendFormat, and some overloads of WriteLine, see Composite Formatting.\n• None For more information about numeric format specifiers, see Standard Numeric Format Strings and Custom Numeric Format Strings.\n• None For more information about date and time format specifiers, see Standard Date and Time Format Strings and Custom Date and Time Format Strings.\n• None For more information about enumeration format specifiers, see Enumeration Format Strings.\n• None For more information about formatting, see Formatting Types. For more information about the line terminator, see the Remarks section of the WriteLine method that takes no parameters. This method is not called by C++ code. The C++ compiler resolves calls to System.Console.WriteLine that include a string and a list of four or more object parameters as a call to WriteLine(String, Object, Object, Object, Object). It resolves calls to System.Console.WriteLine that include a string and an object array as a call to WriteLine(String, Object).\n\nWrites the current line terminator to the standard output stream. The example changes the line terminator from its default value of \"\\r\n\n\" or to \"\\r\n\n\\r\n\n\" or + . It then calls the WriteLine() and WriteLine(String) methods to display output to the console. using namespace System; void main() { array<String^>^ lines = gcnew array<String^> { \"This is the first line.\", \"This is the second line.\" }; // Output the lines using the default newline sequence. Console::WriteLine(\"With the default new line characters:\"); Console::WriteLine(); for each (String^ line in lines) Console::WriteLine(line); Console::WriteLine(); // Redefine the newline characters to double space. Console::Out->NewLine = \"\\r\n\n\\r\n\n\"; // Output the lines using the new newline sequence. Console::WriteLine(\"With redefined new line characters:\"); Console::WriteLine(); for each (String^ line in lines) Console::WriteLine(line); } // The example displays the following output: // With the default new line characters: // // This is the first line. // This is the second line. // // With redefined new line characters: // // // // This is the first line. // // This is the second line. string[] lines = { \"This is the first line.\", \"This is the second line.\" }; // Output the lines using the default newline sequence. Console.WriteLine(\"With the default new line characters:\"); Console.WriteLine(); foreach (string line in lines) Console.WriteLine(line); Console.WriteLine(); // Redefine the newline characters to double space. Console.Out.NewLine = \"\\r\n\n\\r\n\n\"; // Output the lines using the new newline sequence. Console.WriteLine(\"With redefined new line characters:\"); Console.WriteLine(); foreach (string line in lines) Console.WriteLine(line); // The example displays the following output: // With the default new line characters: // // This is the first line. // This is the second line. // // With redefined new line characters: // // // // This is the first line. // // This is the second line. let lines = [ \"This is the first line.\" \"This is the second line.\" ] // Output the lines using the default newline sequence. Console.WriteLine \"With the default new line characters:\" Console.WriteLine() for line in lines do Console.WriteLine line Console.WriteLine() // Redefine the newline characters to double space. Console.Out.NewLine <- \"\\r\n\n\\r\n\n\" // Output the lines using the new newline sequence. Console.WriteLine \"With redefined new line characters:\" Console.WriteLine() for line in lines do Console.WriteLine line // The example displays the following output: // With the default new line characters: // // This is the first line. // This is the second line. // // With redefined new line characters: // // // // This is the first line. // // This is the second line. Module Example Public Sub Main() Dim lines() As String = { \"This is the first line.\", _ \"This is the second line.\" } ' Output the lines using the default newline sequence. Console.WriteLine(\"With the default new line characters:\") Console.WriteLine() For Each line As String In lines Console.WriteLine(line) Next Console.WriteLine() ' Redefine the newline characters to double space. Console.Out.NewLine = vbCrLf + vbCrLf ' Output the lines using the new newline sequence. Console.WriteLine(\"With redefined new line characters:\") Console.WriteLine() For Each line As String In lines Console.WriteLine(line) Next End Sub End Module ' The example displays the following output: ' With the default new line characters: ' ' This is the first line. ' This is the second line. ' ' With redefined new line characters: ' ' ' ' This is the first line. ' ' This is the second line. The default line terminator is a string whose value is a carriage return followed by a line feed (\"\\r\n\n\" in C#, or in Visual Basic). You can change the line terminator by setting the TextWriter.NewLine property of the Out property to another string. The example provides an illustration.\n\nWrites the text representation of the specified objects, followed by the current line terminator, to the standard output stream using the specified format information. Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object) The first object to write using . The second object to write using . The third object to write using . The format specification in is invalid. The following example demonstrates the standard formatting specifiers for numbers, dates, and enumerations. // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. using namespace System; public enum class Color {Yellow = 1, Blue, Green}; int main() { DateTime thisDate = DateTime::Now; Console::Clear(); // Format a negative integer or floating-point number in various ways. Console::WriteLine(\"Standard Numeric Format Specifiers\"); Console::WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f); // Format the current date in various ways. Console::WriteLine(\"Standard DateTime Format Specifiers\"); Console::WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate); // Format a Color enumeration value in various ways. Console::WriteLine(\"Standard Enumeration Format Specifiers\"); Console::WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color::Green); }; /* This code example produces the following results: Standard Numeric Format Specifiers (C) Currency: . . . . . . . . ($123.00) (D) Decimal:. . . . . . . . . -123 (E) Scientific: . . . . . . . -1.234500E+002 (F) Fixed point:. . . . . . . -123.45 (G) General:. . . . . . . . . -123 (default):. . . . . . . . -123 (default = 'G') (N) Number: . . . . . . . . . -123.00 (P) Percent:. . . . . . . . . -12,345.00 % (R) Round-trip: . . . . . . . -123.45 (X) Hexadecimal:. . . . . . . FFFFFF85 Standard DateTime Format Specifiers (d) Short date: . . . . . . . 6/26/2004 (D) Long date:. . . . . . . . Saturday, June 26, 2004 (t) Short time: . . . . . . . 8:11 PM (T) Long time:. . . . . . . . 8:11:04 PM (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM (g) General date/short time:. 6/26/2004 8:11 PM (G) General date/long time: . 6/26/2004 8:11:04 PM (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') (M) Month:. . . . . . . . . . June 26 (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM (Y) Year: . . . . . . . . . . June, 2004 Standard Enumeration Format Specifiers (G) General:. . . . . . . . . Green (default):. . . . . . . . Green (default = 'G') (F) Flags:. . . . . . . . . . Green (flags or integer) (D) Decimal number: . . . . . 3 (X) Hexadecimal:. . . . . . . 00000003 */ // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. using System; class Sample { enum Color {Yellow = 1, Blue, Green}; static DateTime thisDate = DateTime.Now; public static void Main() { Console.Clear(); // Format a negative integer or floating-point number in various ways. Console.WriteLine(\"Standard Numeric Format Specifiers\"); Console.WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f); // Format the current date in various ways. Console.WriteLine(\"Standard DateTime Format Specifiers\"); Console.WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate); // Format a Color enumeration value in various ways. Console.WriteLine(\"Standard Enumeration Format Specifiers\"); Console.WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color.Green); } } /* This code example produces the following results: Standard Numeric Format Specifiers (C) Currency: . . . . . . . . ($123.00) (D) Decimal:. . . . . . . . . -123 (E) Scientific: . . . . . . . -1.234500E+002 (F) Fixed point:. . . . . . . -123.45 (G) General:. . . . . . . . . -123 (default):. . . . . . . . -123 (default = 'G') (N) Number: . . . . . . . . . -123.00 (P) Percent:. . . . . . . . . -12,345.00 % (R) Round-trip: . . . . . . . -123.45 (X) Hexadecimal:. . . . . . . FFFFFF85 Standard DateTime Format Specifiers (d) Short date: . . . . . . . 6/26/2004 (D) Long date:. . . . . . . . Saturday, June 26, 2004 (t) Short time: . . . . . . . 8:11 PM (T) Long time:. . . . . . . . 8:11:04 PM (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM (g) General date/short time:. 6/26/2004 8:11 PM (G) General date/long time: . 6/26/2004 8:11:04 PM (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') (M) Month:. . . . . . . . . . June 26 (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM (Y) Year: . . . . . . . . . . June, 2004 Standard Enumeration Format Specifiers (G) General:. . . . . . . . . Green (default):. . . . . . . . Green (default = 'G') (F) Flags:. . . . . . . . . . Green (flags or integer) (D) Decimal number: . . . . . 3 (X) Hexadecimal:. . . . . . . 00000003 */ // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. open System type Color = | Yellow = 1 | Blue = 2 | Green = 3 let thisDate = DateTime.Now Console.Clear() // Format a negative integer or floating-point number in various ways. Console.WriteLine \"Standard Numeric Format Specifiers\" Console.WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f) // Format the current date in various ways. Console.WriteLine \"Standard DateTime Format Specifiers\" Console.WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate) // Format a Color enumeration value in various ways. Console.WriteLine \"Standard Enumeration Format Specifiers\" Console.WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color.Green) // This code example produces the following results: // // Standard Numeric Format Specifiers // (C) Currency: . . . . . . . . ($123.00) // (D) Decimal:. . . . . . . . . -123 // (E) Scientific: . . . . . . . -1.234500E+002 // (F) Fixed point:. . . . . . . -123.45 // (G) General:. . . . . . . . . -123 // (default):. . . . . . . . -123 (default = 'G') // (N) Number: . . . . . . . . . -123.00 // (P) Percent:. . . . . . . . . -12,345.00 % // (R) Round-trip: . . . . . . . -123.45 // (X) Hexadecimal:. . . . . . . FFFFFF85 // // Standard DateTime Format Specifiers // (d) Short date: . . . . . . . 6/26/2004 // (D) Long date:. . . . . . . . Saturday, June 26, 2004 // (t) Short time: . . . . . . . 8:11 PM // (T) Long time:. . . . . . . . 8:11:04 PM // (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM // (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM // (g) General date/short time:. 6/26/2004 8:11 PM // (G) General date/long time: . 6/26/2004 8:11:04 PM // (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') // (M) Month:. . . . . . . . . . June 26 // (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT // (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 // (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) // (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM // (Y) Year: . . . . . . . . . . June, 2004 // // Standard Enumeration Format Specifiers // (G) General:. . . . . . . . . Green // (default):. . . . . . . . Green (default = 'G') // (F) Flags:. . . . . . . . . . Green (flags or integer) // (D) Decimal number: . . . . . 3 // (X) Hexadecimal:. . . . . . . 00000003 ' This code example demonstrates the Console.WriteLine() method. ' Formatting for this example uses the \"en-US\" culture. Class Sample Public Enum Color Yellow = 1 Blue = 2 Green = 3 End Enum 'Color Private Shared thisDate As DateTime = DateTime.Now Public Shared Sub Main() Console.Clear() ' Format a negative integer or floating-point number in various ways. Console.WriteLine(\"Standard Numeric Format Specifiers\") Console.WriteLine(\"(C) Currency: . . . . . . . . {0:C}\" & vbCrLf & _ \"(D) Decimal:. . . . . . . . . {0:D}\" & vbCrLf & _ \"(E) Scientific: . . . . . . . {1:E}\" & vbCrLf & _ \"(F) Fixed point:. . . . . . . {1:F}\" & vbCrLf & _ \"(G) General:. . . . . . . . . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(N) Number: . . . . . . . . . {0:N}\" & vbCrLf & _ \"(P) Percent:. . . . . . . . . {1:P}\" & vbCrLf & _ \"(R) Round-trip: . . . . . . . {1:R}\" & vbCrLf & _ \"(X) Hexadecimal:. . . . . . . {0:X}\" & vbCrLf, _ - 123, - 123.45F) ' Format the current date in various ways. Console.WriteLine(\"Standard DateTime Format Specifiers\") Console.WriteLine(\"(d) Short date: . . . . . . . {0:d}\" & vbCrLf & _ \"(D) Long date:. . . . . . . . {0:D}\" & vbCrLf & _ \"(t) Short time: . . . . . . . {0:t}\" & vbCrLf & _ \"(T) Long time:. . . . . . . . {0:T}\" & vbCrLf & _ \"(f) Full date/short time: . . {0:f}\" & vbCrLf & _ \"(F) Full date/long time:. . . {0:F}\" & vbCrLf & _ \"(g) General date/short time:. {0:g}\" & vbCrLf & _ \"(G) General date/long time: . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(M) Month:. . . . . . . . . . {0:M}\" & vbCrLf & _ \"(R) RFC1123:. . . . . . . . . {0:R}\" & vbCrLf & _ \"(s) Sortable: . . . . . . . . {0:s}\" & vbCrLf & _ \"(u) Universal sortable: . . . {0:u} (invariant)\" & vbCrLf & _ \"(U) Universal full date/time: {0:U}\" & vbCrLf & _ \"(Y) Year: . . . . . . . . . . {0:Y}\" & vbCrLf, _ thisDate) ' Format a Color enumeration value in various ways. Console.WriteLine(\"Standard Enumeration Format Specifiers\") Console.WriteLine(\"(G) General:. . . . . . . . . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\" & vbCrLf & _ \"(D) Decimal number: . . . . . {0:D}\" & vbCrLf & _ \"(X) Hexadecimal:. . . . . . . {0:X}\" & vbCrLf, _ Color.Green) End Sub End Class ' 'This code example produces the following results: ' 'Standard Numeric Format Specifiers '(C) Currency: . . . . . . . . ($123.00) '(D) Decimal:. . . . . . . . . -123 '(E) Scientific: . . . . . . . -1.234500E+002 '(F) Fixed point:. . . . . . . -123.45 '(G) General:. . . . . . . . . -123 ' (default):. . . . . . . . -123 (default = 'G') '(N) Number: . . . . . . . . . -123.00 '(P) Percent:. . . . . . . . . -12,345.00 % '(R) Round-trip: . . . . . . . -123.45 '(X) Hexadecimal:. . . . . . . FFFFFF85 ' 'Standard DateTime Format Specifiers '(d) Short date: . . . . . . . 6/26/2004 '(D) Long date:. . . . . . . . Saturday, June 26, 2004 '(t) Short time: . . . . . . . 8:11 PM '(T) Long time:. . . . . . . . 8:11:04 PM '(f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM '(F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM '(g) General date/short time:. 6/26/2004 8:11 PM '(G) General date/long time: . 6/26/2004 8:11:04 PM ' (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') '(M) Month:. . . . . . . . . . June 26 '(R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT '(s) Sortable: . . . . . . . . 2004-06-26T20:11:04 '(u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) '(U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM '(Y) Year: . . . . . . . . . . June, 2004 ' 'Standard Enumeration Format Specifiers '(G) General:. . . . . . . . . Green ' (default):. . . . . . . . Green (default = 'G') '(F) Flags:. . . . . . . . . . Green (flags or integer) '(D) Decimal number: . . . . . 3 '(X) Hexadecimal:. . . . . . . 00000003 ' The following example is a tip calculator that calculates an 18% tip and uses the WriteLine method to display the amount of the original charge, the amount of the tip, and the total amount. The example is a console application that requires the user to supply the amount of the original charge as a command-line parameter. using System; public class TipCalculator { private const double tipRate = 0.18; public static void Main(string[] args) { double billTotal; if (args.Length == 0 || ! Double.TryParse(args[0], out billTotal)) { Console.WriteLine(\"usage: TIPCALC total\"); return; } double tip = billTotal * tipRate; Console.WriteLine(); Console.WriteLine($\"Bill total:\\t{billTotal,8:c}\"); Console.WriteLine($\"Tip total/rate:\\t{tip,8:c} ({tipRate:p1})\"); Console.WriteLine((\"\").PadRight(24, '-')); Console.WriteLine($\"Grand total:\\t{billTotal + tip,8:c}\"); } } /* >tipcalc 52.23 Bill total: $52.23 Tip total/rate: $9.40 (18.0 %) ------------------------ Grand total: $61.63 */ open System let tipRate = 0.18 let args = Environment.GetCommandLineArgs()[1..] if args.Length = 0 then Console.WriteLine \"usage: TIPCALC total\" else match Double.TryParse args[0] with | true, billTotal -> let tip = billTotal * tipRate Console.WriteLine() Console.WriteLine $\"Bill total:\\t{billTotal,8:c}\" Console.WriteLine $\"Tip total/rate:\\t{tip,8:c} ({tipRate:p1})\" Console.WriteLine(\"\".PadRight(24, '-')) Console.WriteLine $\"Grand total:\\t{billTotal + tip,8:c}\" | _ -> Console.WriteLine \"usage: TIPCALC total\" // >tipcalc 52.23 // // Bill total: $52.23 // Tip total/rate: $9.40 (18.0 %) // ------------------------ // Grand total: $61.63 Public Module TipCalculator Private Const tipRate As Double = 0.18 Public Sub Main(args As String()) Dim billTotal As Double If (args.Length = 0) OrElse (Not Double.TryParse(args(0), billTotal)) Then Console.WriteLine(\"usage: TIPCALC total\") Return End If Dim tip As Double = billTotal * tipRate Console.WriteLine() Console.WriteLine($\"Bill total:{vbTab}{billTotal,8:c}\") Console.WriteLine($\"Tip total/rate:{vbTab}{tip,8:c} ({tipRate:p1})\") Console.WriteLine(\"\".PadRight(24, \"-\"c)) Console.WriteLine($\"Grand total:{vbTab}{billTotal + tip,8:c}\") End Sub End Module 'Example Output: '--------------- ' >tipcalc 52.23 ' ' Bill total: $52.23 ' Tip total/rate: $9.40 (18.0 %) ' ------------------------ ' Grand total: $61.63 This method uses the composite formatting feature of .NET to convert the value of an object to its text representation and embed that representation in a string. The resulting string is written to the output stream. The parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to an object in the parameter list of this method. The formatting process replaces each format item with the text representation of the value of the corresponding object. The syntax of a format item is index[ alignment][ formatString] , which specifies a mandatory index, the optional length and alignment of the formatted text, and an optional string of format specifier characters that govern how the value of the corresponding object is formatted. .NET provides extensive formatting support, which is described in greater detail in the following formatting topics.\n• None For more information about the composite formatting feature supported by methods such as Format, AppendFormat, and some overloads of WriteLine, see Composite Formatting.\n• None For more information about numeric format specifiers, see Standard Numeric Format Strings and Custom Numeric Format Strings.\n• None For more information about date and time format specifiers, see Standard Date and Time Format Strings and Custom Date and Time Format Strings.\n• None For more information about enumeration format specifiers, see Enumeration Format Strings.\n• None For more information about formatting, see Formatting Types. For more information about the line terminator, see the Remarks section of the WriteLine method that takes no parameters."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.console.write?view=net-9.0",
        "document": "Writes the text representation of the specified objects and variable-length parameter list to the standard output stream using the specified format information. Writes the text representation of the specified objects to the standard output stream using the specified format information. Writes the specified subarray of Unicode characters to the standard output stream. Writes the text representation of the specified span of objects to the standard output stream using the specified format information. Writes the text representation of the specified array of objects to the standard output stream using the specified format information. Writes the text representation of the specified object to the standard output stream using the specified format information. Writes the text representation of the specified 64-bit unsigned integer value to the standard output stream. Writes the text representation of the specified 32-bit unsigned integer value to the standard output stream. Writes the specified string value to the standard output stream. Writes the text representation of the specified objects to the standard output stream using the specified format information. Writes the text representation of the specified single-precision floating-point value to the standard output stream. Writes the specified Unicode character value to the standard output stream. Writes the specified array of Unicode characters to the standard output stream. Writes the text representation of the specified Decimal value to the standard output stream. Writes the text representation of the specified Boolean value to the standard output stream. Writes the text representation of the specified 32-bit signed integer value to the standard output stream. Writes the text representation of the specified 64-bit signed integer value to the standard output stream. Writes the text representation of the specified object to the standard output stream. Writes the text representation of the specified double-precision floating-point value to the standard output stream.\n\nWrites the text representation of the specified objects to the standard output stream using the specified format information. Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object) The first object to write using . The second object to write using . The third object to write using . The format specification in is invalid. The following example uses the method to demonstrate the standard formatting specifiers for numbers, dates, and enumerations. // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. using namespace System; public enum class Color {Yellow = 1, Blue, Green}; int main() { DateTime thisDate = DateTime::Now; Console::Clear(); // Format a negative integer or floating-point number in various ways. Console::WriteLine(\"Standard Numeric Format Specifiers\"); Console::WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f); // Format the current date in various ways. Console::WriteLine(\"Standard DateTime Format Specifiers\"); Console::WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate); // Format a Color enumeration value in various ways. Console::WriteLine(\"Standard Enumeration Format Specifiers\"); Console::WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color::Green); }; /* This code example produces the following results: Standard Numeric Format Specifiers (C) Currency: . . . . . . . . ($123.00) (D) Decimal:. . . . . . . . . -123 (E) Scientific: . . . . . . . -1.234500E+002 (F) Fixed point:. . . . . . . -123.45 (G) General:. . . . . . . . . -123 (default):. . . . . . . . -123 (default = 'G') (N) Number: . . . . . . . . . -123.00 (P) Percent:. . . . . . . . . -12,345.00 % (R) Round-trip: . . . . . . . -123.45 (X) Hexadecimal:. . . . . . . FFFFFF85 Standard DateTime Format Specifiers (d) Short date: . . . . . . . 6/26/2004 (D) Long date:. . . . . . . . Saturday, June 26, 2004 (t) Short time: . . . . . . . 8:11 PM (T) Long time:. . . . . . . . 8:11:04 PM (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM (g) General date/short time:. 6/26/2004 8:11 PM (G) General date/long time: . 6/26/2004 8:11:04 PM (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') (M) Month:. . . . . . . . . . June 26 (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM (Y) Year: . . . . . . . . . . June, 2004 Standard Enumeration Format Specifiers (G) General:. . . . . . . . . Green (default):. . . . . . . . Green (default = 'G') (F) Flags:. . . . . . . . . . Green (flags or integer) (D) Decimal number: . . . . . 3 (X) Hexadecimal:. . . . . . . 00000003 */ // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. using System; class Sample { enum Color {Yellow = 1, Blue, Green}; static DateTime thisDate = DateTime.Now; public static void Main() { Console.Clear(); // Format a negative integer or floating-point number in various ways. Console.WriteLine(\"Standard Numeric Format Specifiers\"); Console.WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f); // Format the current date in various ways. Console.WriteLine(\"Standard DateTime Format Specifiers\"); Console.WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate); // Format a Color enumeration value in various ways. Console.WriteLine(\"Standard Enumeration Format Specifiers\"); Console.WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color.Green); } } /* This code example produces the following results: Standard Numeric Format Specifiers (C) Currency: . . . . . . . . ($123.00) (D) Decimal:. . . . . . . . . -123 (E) Scientific: . . . . . . . -1.234500E+002 (F) Fixed point:. . . . . . . -123.45 (G) General:. . . . . . . . . -123 (default):. . . . . . . . -123 (default = 'G') (N) Number: . . . . . . . . . -123.00 (P) Percent:. . . . . . . . . -12,345.00 % (R) Round-trip: . . . . . . . -123.45 (X) Hexadecimal:. . . . . . . FFFFFF85 Standard DateTime Format Specifiers (d) Short date: . . . . . . . 6/26/2004 (D) Long date:. . . . . . . . Saturday, June 26, 2004 (t) Short time: . . . . . . . 8:11 PM (T) Long time:. . . . . . . . 8:11:04 PM (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM (g) General date/short time:. 6/26/2004 8:11 PM (G) General date/long time: . 6/26/2004 8:11:04 PM (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') (M) Month:. . . . . . . . . . June 26 (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM (Y) Year: . . . . . . . . . . June, 2004 Standard Enumeration Format Specifiers (G) General:. . . . . . . . . Green (default):. . . . . . . . Green (default = 'G') (F) Flags:. . . . . . . . . . Green (flags or integer) (D) Decimal number: . . . . . 3 (X) Hexadecimal:. . . . . . . 00000003 */ // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. open System type Color = | Yellow = 1 | Blue = 2 | Green = 3 let thisDate = DateTime.Now Console.Clear() // Format a negative integer or floating-point number in various ways. Console.WriteLine \"Standard Numeric Format Specifiers\" Console.WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f) // Format the current date in various ways. Console.WriteLine \"Standard DateTime Format Specifiers\" Console.WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate) // Format a Color enumeration value in various ways. Console.WriteLine \"Standard Enumeration Format Specifiers\" Console.WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color.Green) // This code example produces the following results: // // Standard Numeric Format Specifiers // (C) Currency: . . . . . . . . ($123.00) // (D) Decimal:. . . . . . . . . -123 // (E) Scientific: . . . . . . . -1.234500E+002 // (F) Fixed point:. . . . . . . -123.45 // (G) General:. . . . . . . . . -123 // (default):. . . . . . . . -123 (default = 'G') // (N) Number: . . . . . . . . . -123.00 // (P) Percent:. . . . . . . . . -12,345.00 % // (R) Round-trip: . . . . . . . -123.45 // (X) Hexadecimal:. . . . . . . FFFFFF85 // // Standard DateTime Format Specifiers // (d) Short date: . . . . . . . 6/26/2004 // (D) Long date:. . . . . . . . Saturday, June 26, 2004 // (t) Short time: . . . . . . . 8:11 PM // (T) Long time:. . . . . . . . 8:11:04 PM // (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM // (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM // (g) General date/short time:. 6/26/2004 8:11 PM // (G) General date/long time: . 6/26/2004 8:11:04 PM // (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') // (M) Month:. . . . . . . . . . June 26 // (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT // (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 // (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) // (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM // (Y) Year: . . . . . . . . . . June, 2004 // // Standard Enumeration Format Specifiers // (G) General:. . . . . . . . . Green // (default):. . . . . . . . Green (default = 'G') // (F) Flags:. . . . . . . . . . Green (flags or integer) // (D) Decimal number: . . . . . 3 // (X) Hexadecimal:. . . . . . . 00000003 ' This code example demonstrates the Console.WriteLine() method. ' Formatting for this example uses the \"en-US\" culture. Class Sample Public Enum Color Yellow = 1 Blue = 2 Green = 3 End Enum 'Color Private Shared thisDate As DateTime = DateTime.Now Public Shared Sub Main() Console.Clear() ' Format a negative integer or floating-point number in various ways. Console.WriteLine(\"Standard Numeric Format Specifiers\") Console.WriteLine(\"(C) Currency: . . . . . . . . {0:C}\" & vbCrLf & _ \"(D) Decimal:. . . . . . . . . {0:D}\" & vbCrLf & _ \"(E) Scientific: . . . . . . . {1:E}\" & vbCrLf & _ \"(F) Fixed point:. . . . . . . {1:F}\" & vbCrLf & _ \"(G) General:. . . . . . . . . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(N) Number: . . . . . . . . . {0:N}\" & vbCrLf & _ \"(P) Percent:. . . . . . . . . {1:P}\" & vbCrLf & _ \"(R) Round-trip: . . . . . . . {1:R}\" & vbCrLf & _ \"(X) Hexadecimal:. . . . . . . {0:X}\" & vbCrLf, _ - 123, - 123.45F) ' Format the current date in various ways. Console.WriteLine(\"Standard DateTime Format Specifiers\") Console.WriteLine(\"(d) Short date: . . . . . . . {0:d}\" & vbCrLf & _ \"(D) Long date:. . . . . . . . {0:D}\" & vbCrLf & _ \"(t) Short time: . . . . . . . {0:t}\" & vbCrLf & _ \"(T) Long time:. . . . . . . . {0:T}\" & vbCrLf & _ \"(f) Full date/short time: . . {0:f}\" & vbCrLf & _ \"(F) Full date/long time:. . . {0:F}\" & vbCrLf & _ \"(g) General date/short time:. {0:g}\" & vbCrLf & _ \"(G) General date/long time: . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(M) Month:. . . . . . . . . . {0:M}\" & vbCrLf & _ \"(R) RFC1123:. . . . . . . . . {0:R}\" & vbCrLf & _ \"(s) Sortable: . . . . . . . . {0:s}\" & vbCrLf & _ \"(u) Universal sortable: . . . {0:u} (invariant)\" & vbCrLf & _ \"(U) Universal full date/time: {0:U}\" & vbCrLf & _ \"(Y) Year: . . . . . . . . . . {0:Y}\" & vbCrLf, _ thisDate) ' Format a Color enumeration value in various ways. Console.WriteLine(\"Standard Enumeration Format Specifiers\") Console.WriteLine(\"(G) General:. . . . . . . . . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\" & vbCrLf & _ \"(D) Decimal number: . . . . . {0:D}\" & vbCrLf & _ \"(X) Hexadecimal:. . . . . . . {0:X}\" & vbCrLf, _ Color.Green) End Sub End Class ' 'This code example produces the following results: ' 'Standard Numeric Format Specifiers '(C) Currency: . . . . . . . . ($123.00) '(D) Decimal:. . . . . . . . . -123 '(E) Scientific: . . . . . . . -1.234500E+002 '(F) Fixed point:. . . . . . . -123.45 '(G) General:. . . . . . . . . -123 ' (default):. . . . . . . . -123 (default = 'G') '(N) Number: . . . . . . . . . -123.00 '(P) Percent:. . . . . . . . . -12,345.00 % '(R) Round-trip: . . . . . . . -123.45 '(X) Hexadecimal:. . . . . . . FFFFFF85 ' 'Standard DateTime Format Specifiers '(d) Short date: . . . . . . . 6/26/2004 '(D) Long date:. . . . . . . . Saturday, June 26, 2004 '(t) Short time: . . . . . . . 8:11 PM '(T) Long time:. . . . . . . . 8:11:04 PM '(f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM '(F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM '(g) General date/short time:. 6/26/2004 8:11 PM '(G) General date/long time: . 6/26/2004 8:11:04 PM ' (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') '(M) Month:. . . . . . . . . . June 26 '(R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT '(s) Sortable: . . . . . . . . 2004-06-26T20:11:04 '(u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) '(U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM '(Y) Year: . . . . . . . . . . June, 2004 ' 'Standard Enumeration Format Specifiers '(G) General:. . . . . . . . . Green ' (default):. . . . . . . . Green (default = 'G') '(F) Flags:. . . . . . . . . . Green (flags or integer) '(D) Decimal number: . . . . . 3 '(X) Hexadecimal:. . . . . . . 00000003 ' The following example illustrates the use of the method. int main() { array<String^>^lineInputArr = {\"1 2.2 hello TRUE\",\"2 5.22 bye FALSE\",\"3 6.38 see ya' TRUE\"}; for ( Int32 i = 0; i < 3; i++ ) { String^ lineInput = lineInputArr->GetValue( i )->ToString(); String^ aChar = \"\\t\"; array<String^>^fields = lineInput->Split( aChar->ToCharArray() ); Boolean isFirstField = true; for ( Int32 i = 0; i < fields->Length; i++ ) { if ( isFirstField ) isFirstField = false; else Console::Write( \",\" ); // If the field represents a boolean, replace with a numeric representation. try { Console::Write( Convert::ToByte( Convert::ToBoolean( fields[ i ] ) ) ); } catch ( FormatException^ ) { Console::Write( fields[ i ] ); } } Console::WriteLine(); } } public class FormatConverter { public static void Main(string[] args) { string lineInput; while ((lineInput = Console.ReadLine()) != null) { string[] fields = lineInput.Split(new char[] {'\\t'}); bool isFirstField = true; foreach (var item in fields) { if (isFirstField) isFirstField = false; else Console.Write(','); // If the field represents a boolean, replace with a numeric representation. bool itemBool; if (Boolean.TryParse(item, out itemBool)) Console.Write(Convert.ToByte(itemBool)); else Console.Write(item); } Console.WriteLine(); } } } let mutable lineInput = Console.ReadLine() while lineInput <> null do let fields = lineInput.Split '\\t' let mutable isFirstField = true for item in fields do if isFirstField then isFirstField <- false else Console.Write ',' // If the field represents a boolean, replace with a numeric representation. match Boolean.TryParse item with | true, itemBool -> Console.Write(Convert.ToByte itemBool) | _ -> Console.Write item Console.WriteLine() Public Class FormatConverter Public Shared Sub Main() Dim lineInput As String = Console.ReadLine() While Not lineInput Is Nothing Dim fields As String() = lineInput.Split(ControlChars.Tab) Dim isFirstField As Boolean = True For Each item As String In fields If isFirstField Then isFirstField = False Else Console.Write(\",\") End If ' If the field represents a boolean, replace with a numeric representation. Dim itemBool As Boolean If Boolean.TryParse(item, itemBool) Console.Write(Convert.ToByte(itemBool)) Else Console.Write(item) End If Next Console.WriteLine() lineInput = Console.ReadLine() End While End Sub End Class This method uses the composite formatting feature of .NET to convert the value of an object to its text representation and embed that representation in a string. The resulting string is written to the output stream. The parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to an object in the parameter list of this method. The formatting process replaces each format item with the text representation of the value of the corresponding object. The syntax of a format item is index[ alignment][ formatString] , which specifies a mandatory index, the optional length and alignment of the formatted text, and an optional string of format specifier characters that govern how the value of the corresponding object is formatted. .NET provides extensive formatting support, which is described in greater detail in the following formatting topics.\n• None For more information about the composite formatting feature supported by methods such as Format, AppendFormat, and some overloads of WriteLine, see Composite Formatting.\n• None For more information about numeric format specifiers, see Standard Numeric Format Strings and Custom Numeric Format Strings.\n• None For more information about date and time format specifiers, see Standard Date and Time Format Strings and Custom Date and Time Format Strings.\n• None For more information about enumeration format specifiers, see Enumeration Format Strings.\n• None For more information about formatting, see Formatting Types.\n\nWrites the text representation of the specified array of objects to the standard output stream using the specified format information. Public Shared Sub Write (format As String, ParamArray arg As Object()) An array of objects to write using . The format specification in is invalid. The following example defines a class with a number of properties that provide information about a person. Its method returns an array that contains all of the property values except one. The example then uses the array returned by the method to display the values of the Person object. using System; public class Person { public String Name { get; set; } public DateTime BirthDate { get; set; } public Double Height { get; set; } public Double Weight { get; set; } public Char Gender { get; set; } public String Remarks { get; set; } public object[] GetDescription() { return new object[] { Name, Gender, Height, Weight, BirthDate}; } } public class Example { public static void Main() { var p1 = new Person() { Name = \"John\", Gender = 'M', BirthDate = new DateTime(1992, 5, 10), Height = 73.5, Weight = 207 }; p1.Remarks = \"Client since 1/3/2012\"; Console.Write(\"{0}: {1}, born {4:d} Height {2} inches, Weight {3} lbs \", p1.GetDescription()); if (String.IsNullOrEmpty(p1.Remarks)) Console.WriteLine(); else Console.WriteLine(\"{1}Remarks: {0}\", p1.Remarks, Console.CursorLeft + p1.Remarks.Length + 10 > Console.WindowWidth ? \"\n\n \" : \"\"); } } // The example displays the following output: // John: M, born 5/10/1992 Height 73.5 inches, Weight 207 lbs Remarks: Client since 1/3/2012 open System type Person = { Name: string BirthDate: DateOnly Height: double Weight: double Gender: char Remarks: string } member this.GetDescription(): obj [] = [| this.Name; this.Gender; this.Height; this.Weight; this.BirthDate |] let p1 = { Name = \"John\" Gender = 'M' BirthDate = DateOnly(1992, 5, 10) Height = 73.5 Weight = 207 Remarks = \"Client since 1/3/2012\" } Console.Write(\"{0}: {1}, born {4:d} Height {2} inches, Weight {3} lbs \", p1.GetDescription()) if String.IsNullOrEmpty p1.Remarks then Console.WriteLine() else Console.WriteLine $\"\"\"{if Console.CursorLeft + p1.Remarks.Length + 10 > Console.WindowWidth then \"\n\n \" else \"\"}Remarks: {p1.Remarks}\"\"\" // The example displays the following output: // John: M, born 5/10/1992 Height 73.5 inches, Weight 207 lbs Remarks: Client since 1/3/2012 Public Class Person Public Property Name As String Public Property BirthDate As DateTime Public Property Height As Double Public Property Weight As Double Public Property Gender As Char Public Property Remarks As String Public Function GetDescription() As Object() Return { Name, Gender, Height, Weight, BirthDate} End Function End Class Module Example Public Sub Main() Dim p1 As New Person() With { .Name = \"John\", .Gender = \"M\"c, .BirthDate = New DateTime(1992, 5, 10), .Height = 73.5, .Weight = 207 } p1.Remarks = \"Client since 1/3/2012\" Console.Write(\"{0}: {1}, born {4:d} Height {2} inches, Weight {3} lbs \", p1.GetDescription()) If String.IsNullOrEmpty(p1.Remarks) Then Console.WriteLine() Else Console.WriteLine(\"{1}Remarks: {0}\", p1.Remarks, If(Console.CursorLeft + p1.Remarks.Length + 10 > Console.WindowWidth, vbCrLf + \" \", \"\")) End If End Sub End Module ' The example displays the following output: ' John: M, born 5/10/1992 Height 73.5 inches, Weight 207 lbs Remarks: Client since 1/3/2012 Note that the example calls the Write(String, Object[]) method rather than the WriteLine(String, Object[]) method because it attempts to display the value of the property on the same line. To do this, it examines the value of the CursorLeft and WindowWidth properties to determine whether there is enough space for the remark to fit. If there is, it displays the line. If not, it writes a line, indents three spaces, and displays the remark. The following example is identical to the first, except that it supplies a five-item list as the argument instead of a parameter array. using System; public class Person { public String Name { get; set; } public DateTime BirthDate { get; set; } public Double Height { get; set; } public Double Weight { get; set; } public Char Gender { get; set; } public String Remarks { get; set; } public object[] GetDescription() { return new object[] { Name, Gender, Height, Weight, BirthDate}; } } public class Example { public static void Main() { var p1 = new Person() { Name = \"John\", Gender = 'M', BirthDate = new DateTime(1992, 5, 10), Height = 73.5, Weight = 207 }; p1.Remarks = \"Client since 1/3/2012\"; Console.Write(\"{0}: {1}, born {2:d} Height {3} inches, Weight {4} lbs \", p1.Name, p1.Gender, p1.BirthDate, p1.Height, p1.Weight); if (String.IsNullOrEmpty(p1.Remarks)) Console.WriteLine(); else Console.WriteLine(\"{1}Remarks: {0}\", p1.Remarks, Console.CursorLeft + p1.Remarks.Length + 10 > Console.WindowWidth ? \"\n\n \" : \"\"); } } // The example displays the following output: // John: M, born 5/10/1992 Height 73.5 inches, Weight 207 lbs Remarks: Client since 1/3/2012 open System type Person = { Name: string BirthDate: DateOnly Height: double Weight: double Gender: char Remarks: string } member this.GetDescription(): obj [] = [| this.Name; this.Gender; this.Height; this.Weight; this.BirthDate |] let p1 = { Name = \"John\" Gender = 'M' BirthDate = DateOnly(1992, 5, 10) Height = 73.5 Weight = 207 Remarks = \"Client since 1/3/2012\" } printf $\"{p1.Name}: {p1.Gender}, born {p1.BirthDate:d} Height {p1.Height} inches, Weight {p1.Weight} lbs \" if String.IsNullOrEmpty p1.Remarks then Console.WriteLine() else Console.WriteLine $\"\"\"{if Console.CursorLeft + p1.Remarks.Length + 10 > Console.WindowWidth then \"\n\n \" else \"\"}Remarks: {p1.Remarks}\"\"\" // The example displays the following output: // John: M, born 5/10/1992 Height 73.5 inches, Weight 207 lbs Remarks: Client since 1/3/2012 Public Class Person Public Property Name As String Public Property BirthDate As DateTime Public Property Height As Double Public Property Weight As Double Public Property Gender As Char Public Property Remarks As String Public Function GetDescription() As Object() Return { Name, Gender, Height, Weight, BirthDate} End Function End Class Module Example Public Sub Main() Dim p1 As New Person() With { .Name = \"John\", .Gender = \"M\"c, .BirthDate = New DateTime(1992, 5, 10), .Height = 73.5, .Weight = 207 } p1.Remarks = \"Client since 1/3/2012\" Console.Write(\"{0}: {1}, born {2:d} Height {3} inches, Weight {4} lbs \", p1.Name, p1.Gender, p1.BirthDate, p1.Height, p1.Weight) If String.IsNullOrEmpty(p1.Remarks) Then Console.WriteLine() Else Console.WriteLine(\"{1}Remarks: {0}\", p1.Remarks, If(Console.CursorLeft + p1.Remarks.Length + 10 > Console.WindowWidth, vbCrLf + \" \", \"\")) End If End Sub End Module ' The example displays the following output: ' John: M, born 5/10/1992 Height 73.5 inches, Weight 207 lbs Remarks: Client since 1/3/2012 This method uses the composite formatting feature of .NET to convert the value of an object to its text representation and embed that representation in a string. The resulting string is written to the output stream. The parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to an object in the parameter list of this method. The formatting process replaces each format item with the text representation of the value of the corresponding object. The syntax of a format item is index[ alignment][ formatString] , which specifies a mandatory index, the optional length and alignment of the formatted text, and an optional string of format specifier characters that govern how the value of the corresponding object is formatted. .NET provides extensive formatting support, which is described in greater detail in the following formatting topics.\n• None For more information about the composite formatting feature supported by methods such as Format, AppendFormat, and some overloads of WriteLine, see Composite Formatting.\n• None For more information about numeric format specifiers, see Standard Numeric Format Strings and Custom Numeric Format Strings.\n• None For more information about date and time format specifiers, see Standard Date and Time Format Strings and Custom Date and Time Format Strings.\n• None For more information about enumeration format specifiers, see Enumeration Format Strings.\n• None For more information about formatting, see Formatting Types. The parameter is a parameter array. Arguments can be passed to the method either as an array or as list of five or more items. The examples illustrate both forms of method call. This method is not called by C++ code. The C++ compiler resolves calls to System.Console.Write that include a string and a list of four or more object parameters as a call to Write(String, Object, Object, Object, Object). It resolves calls to System.Console.Write that include a string and an object array as a call to Write(String, Object).\n\nWrites the text representation of the specified object to the standard output stream using the specified format information. Public Shared Sub Write (format As String, arg0 As Object) An object to write using . The format specification in is invalid. The following example uses the method to demonstrate the standard formatting specifiers for numbers, dates, and enumerations. // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. using namespace System; public enum class Color {Yellow = 1, Blue, Green}; int main() { DateTime thisDate = DateTime::Now; Console::Clear(); // Format a negative integer or floating-point number in various ways. Console::WriteLine(\"Standard Numeric Format Specifiers\"); Console::WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f); // Format the current date in various ways. Console::WriteLine(\"Standard DateTime Format Specifiers\"); Console::WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate); // Format a Color enumeration value in various ways. Console::WriteLine(\"Standard Enumeration Format Specifiers\"); Console::WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color::Green); }; /* This code example produces the following results: Standard Numeric Format Specifiers (C) Currency: . . . . . . . . ($123.00) (D) Decimal:. . . . . . . . . -123 (E) Scientific: . . . . . . . -1.234500E+002 (F) Fixed point:. . . . . . . -123.45 (G) General:. . . . . . . . . -123 (default):. . . . . . . . -123 (default = 'G') (N) Number: . . . . . . . . . -123.00 (P) Percent:. . . . . . . . . -12,345.00 % (R) Round-trip: . . . . . . . -123.45 (X) Hexadecimal:. . . . . . . FFFFFF85 Standard DateTime Format Specifiers (d) Short date: . . . . . . . 6/26/2004 (D) Long date:. . . . . . . . Saturday, June 26, 2004 (t) Short time: . . . . . . . 8:11 PM (T) Long time:. . . . . . . . 8:11:04 PM (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM (g) General date/short time:. 6/26/2004 8:11 PM (G) General date/long time: . 6/26/2004 8:11:04 PM (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') (M) Month:. . . . . . . . . . June 26 (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM (Y) Year: . . . . . . . . . . June, 2004 Standard Enumeration Format Specifiers (G) General:. . . . . . . . . Green (default):. . . . . . . . Green (default = 'G') (F) Flags:. . . . . . . . . . Green (flags or integer) (D) Decimal number: . . . . . 3 (X) Hexadecimal:. . . . . . . 00000003 */ // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. using System; class Sample { enum Color {Yellow = 1, Blue, Green}; static DateTime thisDate = DateTime.Now; public static void Main() { Console.Clear(); // Format a negative integer or floating-point number in various ways. Console.WriteLine(\"Standard Numeric Format Specifiers\"); Console.WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f); // Format the current date in various ways. Console.WriteLine(\"Standard DateTime Format Specifiers\"); Console.WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate); // Format a Color enumeration value in various ways. Console.WriteLine(\"Standard Enumeration Format Specifiers\"); Console.WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color.Green); } } /* This code example produces the following results: Standard Numeric Format Specifiers (C) Currency: . . . . . . . . ($123.00) (D) Decimal:. . . . . . . . . -123 (E) Scientific: . . . . . . . -1.234500E+002 (F) Fixed point:. . . . . . . -123.45 (G) General:. . . . . . . . . -123 (default):. . . . . . . . -123 (default = 'G') (N) Number: . . . . . . . . . -123.00 (P) Percent:. . . . . . . . . -12,345.00 % (R) Round-trip: . . . . . . . -123.45 (X) Hexadecimal:. . . . . . . FFFFFF85 Standard DateTime Format Specifiers (d) Short date: . . . . . . . 6/26/2004 (D) Long date:. . . . . . . . Saturday, June 26, 2004 (t) Short time: . . . . . . . 8:11 PM (T) Long time:. . . . . . . . 8:11:04 PM (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM (g) General date/short time:. 6/26/2004 8:11 PM (G) General date/long time: . 6/26/2004 8:11:04 PM (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') (M) Month:. . . . . . . . . . June 26 (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM (Y) Year: . . . . . . . . . . June, 2004 Standard Enumeration Format Specifiers (G) General:. . . . . . . . . Green (default):. . . . . . . . Green (default = 'G') (F) Flags:. . . . . . . . . . Green (flags or integer) (D) Decimal number: . . . . . 3 (X) Hexadecimal:. . . . . . . 00000003 */ // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. open System type Color = | Yellow = 1 | Blue = 2 | Green = 3 let thisDate = DateTime.Now Console.Clear() // Format a negative integer or floating-point number in various ways. Console.WriteLine \"Standard Numeric Format Specifiers\" Console.WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f) // Format the current date in various ways. Console.WriteLine \"Standard DateTime Format Specifiers\" Console.WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate) // Format a Color enumeration value in various ways. Console.WriteLine \"Standard Enumeration Format Specifiers\" Console.WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color.Green) // This code example produces the following results: // // Standard Numeric Format Specifiers // (C) Currency: . . . . . . . . ($123.00) // (D) Decimal:. . . . . . . . . -123 // (E) Scientific: . . . . . . . -1.234500E+002 // (F) Fixed point:. . . . . . . -123.45 // (G) General:. . . . . . . . . -123 // (default):. . . . . . . . -123 (default = 'G') // (N) Number: . . . . . . . . . -123.00 // (P) Percent:. . . . . . . . . -12,345.00 % // (R) Round-trip: . . . . . . . -123.45 // (X) Hexadecimal:. . . . . . . FFFFFF85 // // Standard DateTime Format Specifiers // (d) Short date: . . . . . . . 6/26/2004 // (D) Long date:. . . . . . . . Saturday, June 26, 2004 // (t) Short time: . . . . . . . 8:11 PM // (T) Long time:. . . . . . . . 8:11:04 PM // (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM // (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM // (g) General date/short time:. 6/26/2004 8:11 PM // (G) General date/long time: . 6/26/2004 8:11:04 PM // (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') // (M) Month:. . . . . . . . . . June 26 // (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT // (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 // (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) // (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM // (Y) Year: . . . . . . . . . . June, 2004 // // Standard Enumeration Format Specifiers // (G) General:. . . . . . . . . Green // (default):. . . . . . . . Green (default = 'G') // (F) Flags:. . . . . . . . . . Green (flags or integer) // (D) Decimal number: . . . . . 3 // (X) Hexadecimal:. . . . . . . 00000003 ' This code example demonstrates the Console.WriteLine() method. ' Formatting for this example uses the \"en-US\" culture. Class Sample Public Enum Color Yellow = 1 Blue = 2 Green = 3 End Enum 'Color Private Shared thisDate As DateTime = DateTime.Now Public Shared Sub Main() Console.Clear() ' Format a negative integer or floating-point number in various ways. Console.WriteLine(\"Standard Numeric Format Specifiers\") Console.WriteLine(\"(C) Currency: . . . . . . . . {0:C}\" & vbCrLf & _ \"(D) Decimal:. . . . . . . . . {0:D}\" & vbCrLf & _ \"(E) Scientific: . . . . . . . {1:E}\" & vbCrLf & _ \"(F) Fixed point:. . . . . . . {1:F}\" & vbCrLf & _ \"(G) General:. . . . . . . . . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(N) Number: . . . . . . . . . {0:N}\" & vbCrLf & _ \"(P) Percent:. . . . . . . . . {1:P}\" & vbCrLf & _ \"(R) Round-trip: . . . . . . . {1:R}\" & vbCrLf & _ \"(X) Hexadecimal:. . . . . . . {0:X}\" & vbCrLf, _ - 123, - 123.45F) ' Format the current date in various ways. Console.WriteLine(\"Standard DateTime Format Specifiers\") Console.WriteLine(\"(d) Short date: . . . . . . . {0:d}\" & vbCrLf & _ \"(D) Long date:. . . . . . . . {0:D}\" & vbCrLf & _ \"(t) Short time: . . . . . . . {0:t}\" & vbCrLf & _ \"(T) Long time:. . . . . . . . {0:T}\" & vbCrLf & _ \"(f) Full date/short time: . . {0:f}\" & vbCrLf & _ \"(F) Full date/long time:. . . {0:F}\" & vbCrLf & _ \"(g) General date/short time:. {0:g}\" & vbCrLf & _ \"(G) General date/long time: . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(M) Month:. . . . . . . . . . {0:M}\" & vbCrLf & _ \"(R) RFC1123:. . . . . . . . . {0:R}\" & vbCrLf & _ \"(s) Sortable: . . . . . . . . {0:s}\" & vbCrLf & _ \"(u) Universal sortable: . . . {0:u} (invariant)\" & vbCrLf & _ \"(U) Universal full date/time: {0:U}\" & vbCrLf & _ \"(Y) Year: . . . . . . . . . . {0:Y}\" & vbCrLf, _ thisDate) ' Format a Color enumeration value in various ways. Console.WriteLine(\"Standard Enumeration Format Specifiers\") Console.WriteLine(\"(G) General:. . . . . . . . . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\" & vbCrLf & _ \"(D) Decimal number: . . . . . {0:D}\" & vbCrLf & _ \"(X) Hexadecimal:. . . . . . . {0:X}\" & vbCrLf, _ Color.Green) End Sub End Class ' 'This code example produces the following results: ' 'Standard Numeric Format Specifiers '(C) Currency: . . . . . . . . ($123.00) '(D) Decimal:. . . . . . . . . -123 '(E) Scientific: . . . . . . . -1.234500E+002 '(F) Fixed point:. . . . . . . -123.45 '(G) General:. . . . . . . . . -123 ' (default):. . . . . . . . -123 (default = 'G') '(N) Number: . . . . . . . . . -123.00 '(P) Percent:. . . . . . . . . -12,345.00 % '(R) Round-trip: . . . . . . . -123.45 '(X) Hexadecimal:. . . . . . . FFFFFF85 ' 'Standard DateTime Format Specifiers '(d) Short date: . . . . . . . 6/26/2004 '(D) Long date:. . . . . . . . Saturday, June 26, 2004 '(t) Short time: . . . . . . . 8:11 PM '(T) Long time:. . . . . . . . 8:11:04 PM '(f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM '(F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM '(g) General date/short time:. 6/26/2004 8:11 PM '(G) General date/long time: . 6/26/2004 8:11:04 PM ' (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') '(M) Month:. . . . . . . . . . June 26 '(R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT '(s) Sortable: . . . . . . . . 2004-06-26T20:11:04 '(u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) '(U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM '(Y) Year: . . . . . . . . . . June, 2004 ' 'Standard Enumeration Format Specifiers '(G) General:. . . . . . . . . Green ' (default):. . . . . . . . Green (default = 'G') '(F) Flags:. . . . . . . . . . Green (flags or integer) '(D) Decimal number: . . . . . 3 '(X) Hexadecimal:. . . . . . . 00000003 ' The following example illustrates the use of the Write method. int main() { array<String^>^lineInputArr = {\"1 2.2 hello TRUE\",\"2 5.22 bye FALSE\",\"3 6.38 see ya' TRUE\"}; for ( Int32 i = 0; i < 3; i++ ) { String^ lineInput = lineInputArr->GetValue( i )->ToString(); String^ aChar = \"\\t\"; array<String^>^fields = lineInput->Split( aChar->ToCharArray() ); Boolean isFirstField = true; for ( Int32 i = 0; i < fields->Length; i++ ) { if ( isFirstField ) isFirstField = false; else Console::Write( \",\" ); // If the field represents a boolean, replace with a numeric representation. try { Console::Write( Convert::ToByte( Convert::ToBoolean( fields[ i ] ) ) ); } catch ( FormatException^ ) { Console::Write( fields[ i ] ); } } Console::WriteLine(); } } public class FormatConverter { public static void Main(string[] args) { string lineInput; while ((lineInput = Console.ReadLine()) != null) { string[] fields = lineInput.Split(new char[] {'\\t'}); bool isFirstField = true; foreach (var item in fields) { if (isFirstField) isFirstField = false; else Console.Write(','); // If the field represents a boolean, replace with a numeric representation. bool itemBool; if (Boolean.TryParse(item, out itemBool)) Console.Write(Convert.ToByte(itemBool)); else Console.Write(item); } Console.WriteLine(); } } } let mutable lineInput = Console.ReadLine() while lineInput <> null do let fields = lineInput.Split '\\t' let mutable isFirstField = true for item in fields do if isFirstField then isFirstField <- false else Console.Write ',' // If the field represents a boolean, replace with a numeric representation. match Boolean.TryParse item with | true, itemBool -> Console.Write(Convert.ToByte itemBool) | _ -> Console.Write item Console.WriteLine() Public Class FormatConverter Public Shared Sub Main() Dim lineInput As String = Console.ReadLine() While Not lineInput Is Nothing Dim fields As String() = lineInput.Split(ControlChars.Tab) Dim isFirstField As Boolean = True For Each item As String In fields If isFirstField Then isFirstField = False Else Console.Write(\",\") End If ' If the field represents a boolean, replace with a numeric representation. Dim itemBool As Boolean If Boolean.TryParse(item, itemBool) Console.Write(Convert.ToByte(itemBool)) Else Console.Write(item) End If Next Console.WriteLine() lineInput = Console.ReadLine() End While End Sub End Class This method uses the composite formatting feature of the .NET to convert the value of an object to its text representation and embed that representation in a string. The resulting string is written to the output stream. The parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to an object in the parameter list of this method. The formatting process replaces each format item with the text representation of the value of the corresponding object. The syntax of a format item is index[ alignment][ formatString] , which specifies a mandatory index, the optional length and alignment of the formatted text, and an optional string of format specifier characters that govern how the value of the corresponding object is formatted. .NET provides extensive formatting support, which is described in greater detail in the following formatting topics.\n• None For more information about the composite formatting feature supported by methods such as Format, AppendFormat, and some overloads of WriteLine, see Composite Formatting.\n• None For more information about numeric format specifiers, see Standard Numeric Format Strings and Custom Numeric Format Strings.\n• None For more information about date and time format specifiers, see Standard Date and Time Format Strings and Custom Date and Time Format Strings.\n• None For more information about enumeration format specifiers, see Enumeration Format Strings.\n• None For more information about formatting, see Formatting Types.\n\nWrites the text representation of the specified objects to the standard output stream using the specified format information. Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object) The first object to write using . The second object to write using . The format specification in is invalid. The following example uses the method to demonstrate the standard formatting specifiers for numbers, dates, and enumerations. // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. using namespace System; public enum class Color {Yellow = 1, Blue, Green}; int main() { DateTime thisDate = DateTime::Now; Console::Clear(); // Format a negative integer or floating-point number in various ways. Console::WriteLine(\"Standard Numeric Format Specifiers\"); Console::WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f); // Format the current date in various ways. Console::WriteLine(\"Standard DateTime Format Specifiers\"); Console::WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate); // Format a Color enumeration value in various ways. Console::WriteLine(\"Standard Enumeration Format Specifiers\"); Console::WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color::Green); }; /* This code example produces the following results: Standard Numeric Format Specifiers (C) Currency: . . . . . . . . ($123.00) (D) Decimal:. . . . . . . . . -123 (E) Scientific: . . . . . . . -1.234500E+002 (F) Fixed point:. . . . . . . -123.45 (G) General:. . . . . . . . . -123 (default):. . . . . . . . -123 (default = 'G') (N) Number: . . . . . . . . . -123.00 (P) Percent:. . . . . . . . . -12,345.00 % (R) Round-trip: . . . . . . . -123.45 (X) Hexadecimal:. . . . . . . FFFFFF85 Standard DateTime Format Specifiers (d) Short date: . . . . . . . 6/26/2004 (D) Long date:. . . . . . . . Saturday, June 26, 2004 (t) Short time: . . . . . . . 8:11 PM (T) Long time:. . . . . . . . 8:11:04 PM (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM (g) General date/short time:. 6/26/2004 8:11 PM (G) General date/long time: . 6/26/2004 8:11:04 PM (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') (M) Month:. . . . . . . . . . June 26 (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM (Y) Year: . . . . . . . . . . June, 2004 Standard Enumeration Format Specifiers (G) General:. . . . . . . . . Green (default):. . . . . . . . Green (default = 'G') (F) Flags:. . . . . . . . . . Green (flags or integer) (D) Decimal number: . . . . . 3 (X) Hexadecimal:. . . . . . . 00000003 */ // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. using System; class Sample { enum Color {Yellow = 1, Blue, Green}; static DateTime thisDate = DateTime.Now; public static void Main() { Console.Clear(); // Format a negative integer or floating-point number in various ways. Console.WriteLine(\"Standard Numeric Format Specifiers\"); Console.WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f); // Format the current date in various ways. Console.WriteLine(\"Standard DateTime Format Specifiers\"); Console.WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate); // Format a Color enumeration value in various ways. Console.WriteLine(\"Standard Enumeration Format Specifiers\"); Console.WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color.Green); } } /* This code example produces the following results: Standard Numeric Format Specifiers (C) Currency: . . . . . . . . ($123.00) (D) Decimal:. . . . . . . . . -123 (E) Scientific: . . . . . . . -1.234500E+002 (F) Fixed point:. . . . . . . -123.45 (G) General:. . . . . . . . . -123 (default):. . . . . . . . -123 (default = 'G') (N) Number: . . . . . . . . . -123.00 (P) Percent:. . . . . . . . . -12,345.00 % (R) Round-trip: . . . . . . . -123.45 (X) Hexadecimal:. . . . . . . FFFFFF85 Standard DateTime Format Specifiers (d) Short date: . . . . . . . 6/26/2004 (D) Long date:. . . . . . . . Saturday, June 26, 2004 (t) Short time: . . . . . . . 8:11 PM (T) Long time:. . . . . . . . 8:11:04 PM (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM (g) General date/short time:. 6/26/2004 8:11 PM (G) General date/long time: . 6/26/2004 8:11:04 PM (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') (M) Month:. . . . . . . . . . June 26 (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM (Y) Year: . . . . . . . . . . June, 2004 Standard Enumeration Format Specifiers (G) General:. . . . . . . . . Green (default):. . . . . . . . Green (default = 'G') (F) Flags:. . . . . . . . . . Green (flags or integer) (D) Decimal number: . . . . . 3 (X) Hexadecimal:. . . . . . . 00000003 */ // This code example demonstrates the Console.WriteLine() method. // Formatting for this example uses the \"en-US\" culture. open System type Color = | Yellow = 1 | Blue = 2 | Green = 3 let thisDate = DateTime.Now Console.Clear() // Format a negative integer or floating-point number in various ways. Console.WriteLine \"Standard Numeric Format Specifiers\" Console.WriteLine( \"(C) Currency: . . . . . . . . {0:C}\n\n\" + \"(D) Decimal:. . . . . . . . . {0:D}\n\n\" + \"(E) Scientific: . . . . . . . {1:E}\n\n\" + \"(F) Fixed point:. . . . . . . {1:F}\n\n\" + \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(N) Number: . . . . . . . . . {0:N}\n\n\" + \"(P) Percent:. . . . . . . . . {1:P}\n\n\" + \"(R) Round-trip: . . . . . . . {1:R}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", -123, -123.45f) // Format the current date in various ways. Console.WriteLine \"Standard DateTime Format Specifiers\" Console.WriteLine( \"(d) Short date: . . . . . . . {0:d}\n\n\" + \"(D) Long date:. . . . . . . . {0:D}\n\n\" + \"(t) Short time: . . . . . . . {0:t}\n\n\" + \"(T) Long time:. . . . . . . . {0:T}\n\n\" + \"(f) Full date/short time: . . {0:f}\n\n\" + \"(F) Full date/long time:. . . {0:F}\n\n\" + \"(g) General date/short time:. {0:g}\n\n\" + \"(G) General date/long time: . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(M) Month:. . . . . . . . . . {0:M}\n\n\" + \"(R) RFC1123:. . . . . . . . . {0:R}\n\n\" + \"(s) Sortable: . . . . . . . . {0:s}\n\n\" + \"(u) Universal sortable: . . . {0:u} (invariant)\n\n\" + \"(U) Universal full date/time: {0:U}\n\n\" + \"(Y) Year: . . . . . . . . . . {0:Y}\n\n\", thisDate) // Format a Color enumeration value in various ways. Console.WriteLine \"Standard Enumeration Format Specifiers\" Console.WriteLine( \"(G) General:. . . . . . . . . {0:G}\n\n\" + \" (default):. . . . . . . . {0} (default = 'G')\n\n\" + \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\n\n\" + \"(D) Decimal number: . . . . . {0:D}\n\n\" + \"(X) Hexadecimal:. . . . . . . {0:X}\n\n\", Color.Green) // This code example produces the following results: // // Standard Numeric Format Specifiers // (C) Currency: . . . . . . . . ($123.00) // (D) Decimal:. . . . . . . . . -123 // (E) Scientific: . . . . . . . -1.234500E+002 // (F) Fixed point:. . . . . . . -123.45 // (G) General:. . . . . . . . . -123 // (default):. . . . . . . . -123 (default = 'G') // (N) Number: . . . . . . . . . -123.00 // (P) Percent:. . . . . . . . . -12,345.00 % // (R) Round-trip: . . . . . . . -123.45 // (X) Hexadecimal:. . . . . . . FFFFFF85 // // Standard DateTime Format Specifiers // (d) Short date: . . . . . . . 6/26/2004 // (D) Long date:. . . . . . . . Saturday, June 26, 2004 // (t) Short time: . . . . . . . 8:11 PM // (T) Long time:. . . . . . . . 8:11:04 PM // (f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM // (F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM // (g) General date/short time:. 6/26/2004 8:11 PM // (G) General date/long time: . 6/26/2004 8:11:04 PM // (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') // (M) Month:. . . . . . . . . . June 26 // (R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT // (s) Sortable: . . . . . . . . 2004-06-26T20:11:04 // (u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) // (U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM // (Y) Year: . . . . . . . . . . June, 2004 // // Standard Enumeration Format Specifiers // (G) General:. . . . . . . . . Green // (default):. . . . . . . . Green (default = 'G') // (F) Flags:. . . . . . . . . . Green (flags or integer) // (D) Decimal number: . . . . . 3 // (X) Hexadecimal:. . . . . . . 00000003 ' This code example demonstrates the Console.WriteLine() method. ' Formatting for this example uses the \"en-US\" culture. Class Sample Public Enum Color Yellow = 1 Blue = 2 Green = 3 End Enum 'Color Private Shared thisDate As DateTime = DateTime.Now Public Shared Sub Main() Console.Clear() ' Format a negative integer or floating-point number in various ways. Console.WriteLine(\"Standard Numeric Format Specifiers\") Console.WriteLine(\"(C) Currency: . . . . . . . . {0:C}\" & vbCrLf & _ \"(D) Decimal:. . . . . . . . . {0:D}\" & vbCrLf & _ \"(E) Scientific: . . . . . . . {1:E}\" & vbCrLf & _ \"(F) Fixed point:. . . . . . . {1:F}\" & vbCrLf & _ \"(G) General:. . . . . . . . . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(N) Number: . . . . . . . . . {0:N}\" & vbCrLf & _ \"(P) Percent:. . . . . . . . . {1:P}\" & vbCrLf & _ \"(R) Round-trip: . . . . . . . {1:R}\" & vbCrLf & _ \"(X) Hexadecimal:. . . . . . . {0:X}\" & vbCrLf, _ - 123, - 123.45F) ' Format the current date in various ways. Console.WriteLine(\"Standard DateTime Format Specifiers\") Console.WriteLine(\"(d) Short date: . . . . . . . {0:d}\" & vbCrLf & _ \"(D) Long date:. . . . . . . . {0:D}\" & vbCrLf & _ \"(t) Short time: . . . . . . . {0:t}\" & vbCrLf & _ \"(T) Long time:. . . . . . . . {0:T}\" & vbCrLf & _ \"(f) Full date/short time: . . {0:f}\" & vbCrLf & _ \"(F) Full date/long time:. . . {0:F}\" & vbCrLf & _ \"(g) General date/short time:. {0:g}\" & vbCrLf & _ \"(G) General date/long time: . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(M) Month:. . . . . . . . . . {0:M}\" & vbCrLf & _ \"(R) RFC1123:. . . . . . . . . {0:R}\" & vbCrLf & _ \"(s) Sortable: . . . . . . . . {0:s}\" & vbCrLf & _ \"(u) Universal sortable: . . . {0:u} (invariant)\" & vbCrLf & _ \"(U) Universal full date/time: {0:U}\" & vbCrLf & _ \"(Y) Year: . . . . . . . . . . {0:Y}\" & vbCrLf, _ thisDate) ' Format a Color enumeration value in various ways. Console.WriteLine(\"Standard Enumeration Format Specifiers\") Console.WriteLine(\"(G) General:. . . . . . . . . {0:G}\" & vbCrLf & _ \" (default):. . . . . . . . {0} (default = 'G')\" & vbCrLf & _ \"(F) Flags:. . . . . . . . . . {0:F} (flags or integer)\" & vbCrLf & _ \"(D) Decimal number: . . . . . {0:D}\" & vbCrLf & _ \"(X) Hexadecimal:. . . . . . . {0:X}\" & vbCrLf, _ Color.Green) End Sub End Class ' 'This code example produces the following results: ' 'Standard Numeric Format Specifiers '(C) Currency: . . . . . . . . ($123.00) '(D) Decimal:. . . . . . . . . -123 '(E) Scientific: . . . . . . . -1.234500E+002 '(F) Fixed point:. . . . . . . -123.45 '(G) General:. . . . . . . . . -123 ' (default):. . . . . . . . -123 (default = 'G') '(N) Number: . . . . . . . . . -123.00 '(P) Percent:. . . . . . . . . -12,345.00 % '(R) Round-trip: . . . . . . . -123.45 '(X) Hexadecimal:. . . . . . . FFFFFF85 ' 'Standard DateTime Format Specifiers '(d) Short date: . . . . . . . 6/26/2004 '(D) Long date:. . . . . . . . Saturday, June 26, 2004 '(t) Short time: . . . . . . . 8:11 PM '(T) Long time:. . . . . . . . 8:11:04 PM '(f) Full date/short time: . . Saturday, June 26, 2004 8:11 PM '(F) Full date/long time:. . . Saturday, June 26, 2004 8:11:04 PM '(g) General date/short time:. 6/26/2004 8:11 PM '(G) General date/long time: . 6/26/2004 8:11:04 PM ' (default):. . . . . . . . 6/26/2004 8:11:04 PM (default = 'G') '(M) Month:. . . . . . . . . . June 26 '(R) RFC1123:. . . . . . . . . Sat, 26 Jun 2004 20:11:04 GMT '(s) Sortable: . . . . . . . . 2004-06-26T20:11:04 '(u) Universal sortable: . . . 2004-06-26 20:11:04Z (invariant) '(U) Universal full date/time: Sunday, June 27, 2004 3:11:04 AM '(Y) Year: . . . . . . . . . . June, 2004 ' 'Standard Enumeration Format Specifiers '(G) General:. . . . . . . . . Green ' (default):. . . . . . . . Green (default = 'G') '(F) Flags:. . . . . . . . . . Green (flags or integer) '(D) Decimal number: . . . . . 3 '(X) Hexadecimal:. . . . . . . 00000003 ' The following example illustrates the use of the method. int main() { array<String^>^lineInputArr = {\"1 2.2 hello TRUE\",\"2 5.22 bye FALSE\",\"3 6.38 see ya' TRUE\"}; for ( Int32 i = 0; i < 3; i++ ) { String^ lineInput = lineInputArr->GetValue( i )->ToString(); String^ aChar = \"\\t\"; array<String^>^fields = lineInput->Split( aChar->ToCharArray() ); Boolean isFirstField = true; for ( Int32 i = 0; i < fields->Length; i++ ) { if ( isFirstField ) isFirstField = false; else Console::Write( \",\" ); // If the field represents a boolean, replace with a numeric representation. try { Console::Write( Convert::ToByte( Convert::ToBoolean( fields[ i ] ) ) ); } catch ( FormatException^ ) { Console::Write( fields[ i ] ); } } Console::WriteLine(); } } public class FormatConverter { public static void Main(string[] args) { string lineInput; while ((lineInput = Console.ReadLine()) != null) { string[] fields = lineInput.Split(new char[] {'\\t'}); bool isFirstField = true; foreach (var item in fields) { if (isFirstField) isFirstField = false; else Console.Write(','); // If the field represents a boolean, replace with a numeric representation. bool itemBool; if (Boolean.TryParse(item, out itemBool)) Console.Write(Convert.ToByte(itemBool)); else Console.Write(item); } Console.WriteLine(); } } } let mutable lineInput = Console.ReadLine() while lineInput <> null do let fields = lineInput.Split '\\t' let mutable isFirstField = true for item in fields do if isFirstField then isFirstField <- false else Console.Write ',' // If the field represents a boolean, replace with a numeric representation. match Boolean.TryParse item with | true, itemBool -> Console.Write(Convert.ToByte itemBool) | _ -> Console.Write item Console.WriteLine() Public Class FormatConverter Public Shared Sub Main() Dim lineInput As String = Console.ReadLine() While Not lineInput Is Nothing Dim fields As String() = lineInput.Split(ControlChars.Tab) Dim isFirstField As Boolean = True For Each item As String In fields If isFirstField Then isFirstField = False Else Console.Write(\",\") End If ' If the field represents a boolean, replace with a numeric representation. Dim itemBool As Boolean If Boolean.TryParse(item, itemBool) Console.Write(Convert.ToByte(itemBool)) Else Console.Write(item) End If Next Console.WriteLine() lineInput = Console.ReadLine() End While End Sub End Class This method uses the composite formatting feature of .NET to convert the value of an object to its text representation and embed that representation in a string. The resulting string is written to the output stream. The parameter consists of zero or more runs of text intermixed with zero or more indexed placeholders, called format items, that correspond to an object in the parameter list of this method. The formatting process replaces each format item with the text representation of the value of the corresponding object. The syntax of a format item is index[ alignment][ formatString] , which specifies a mandatory index, the optional length and alignment of the formatted text, and an optional string of format specifier characters that govern how the value of the corresponding object is formatted. .NET provides extensive formatting support, which is described in greater detail in the following formatting topics.\n• None For more information about the composite formatting feature supported by methods such as Format, AppendFormat, and some overloads of WriteLine, see Composite Formatting.\n• None For more information about numeric format specifiers, see Standard Numeric Format Strings and Custom Numeric Format Strings.\n• None For more information about date and time format specifiers, see Standard Date and Time Format Strings and Custom Date and Time Format Strings.\n• None For more information about enumeration format specifiers, see Enumeration Format Strings.\n• None For more information about formatting, see Formatting Types."
    },
    {
        "link": "https://ironsoftware.com/csharp/print/blog/net-help/csharp-print-console",
        "document": "Test in production without watermarks.\n\nWorks wherever you need it to."
    },
    {
        "link": "https://bytehide.com/blog/console-writeline-csharp",
        "document": "Understanding the Basics: What is Console.WriteLine in C#?\n\nSo, let’s get started with the fundamental question. What is Console.WriteLine in C#? Don’t worry, it’s easier than it sounds.\n\nis a method in C# used to display output on the console. It’s like the messenger in the old times who’d shout out messages to the public. In the world of C#, does the same. It shouts out your output to the console!\n\nThis simple line of code will display on the console. Now, I know what you’re thinking: “That was easy!” Well, you’re absolutely right. It’s a piece of cake! But remember, the important part here is understanding how Console.WriteLine works.\n\nThe Importance of Console.WriteLine in C#\n\nConsole.WriteLine in C# works as the communicator between the application and its user. It prints the program output, debugging information, or any necessary details you want to show. It’s like a tour guide making things simpler for you when you’re wandering in the vast aspiration of a C# application.\n\nThe Core of C#: How to Use Console.WriteLine in C#\n\nReady for some action with ? Let’s dive a little deeper.\n\nBeing the basis of C# output, the usage of involves a specific syntax. You could think of it as a superhero with a secret handshake. This secret handshake is mainly the syntax of how you use it.\n\nLet’s look at the typical syntax:\n\nHere, ‘object’ can be string, int, boolean, etc. So if you’re looking to print “Hello, Universe!”, the code line would go:\n\nAnd voilà, displays on your console.\n\nCase Study: Real-Life Example of Using Console.WriteLine\n\nRemember when I said you can also print integers, booleans, and other data types using Console.WriteLine? Well, let’s not just stop at simple strings or integers. Let’s take it up a notch and see how we can print more complex data, such as arrays, lists, and custom objects using Console.WriteLine.\n\nLet’s quickly recap printing a variable. Say, you have an integer:\n\nThis will print on your console. Here, is an integer variable stored in memory, and we’re just calling our trusty to display it.\n\nNow, let’s say you have an array of integers:\n\nOne approach is to iterate over this array and print each score individually:\n\nAs a result, each score will be printed on its own line in the console.\n\nPrinting a list is quite similar to printing an array. For instance, you might have a list of student names:\n\nYou can print this list of students as follows:\n\nOnce again, each student’s name will appear on its own line in the console. So far, so good!\n\nTo print a custom object, you simply call with the object as its parameter. However, the output might not meet your expectations.\n\nFor example, let’s say you have a simple class:\n\nAnd you create a object and try to print it:\n\nYou might expect it to print something like “John Doe, 20”, but instead, you’ll get something along the lines of “Namespace.Student”.\n\nWhat’s happening? Well, when you call with an object, it calls the method on that object. The default implementation of simply returns the name of the type of the object, which isn’t particularly helpful.\n\nHere’s a simple fix: Override the method in the class:\n\nNow if you run the same code:\n\nYou get the expected result: “John Doe, 20”.\n\nIn this extended example, we’ve navigated through printing variables, arrays, lists, and custom objects using Console.WriteLine. These real-life examples should help you understand the versatility of Console.WriteLine and how you can use it to present different types of data in your C# programs.\n\nWhere Does Console.WriteLine Go in C#?\n\nAlright, we learned how to use in C#, but where exactly it goes? Ever thought about it?\n\nThe output of Console.WriteLine goes directly to a window, aka . It’s like sending postcards. You write it (Console.WriteLine), it gets sent and goes straight to the recipient (the console application window).\n\nThink of as the director of a play, controlling where each character (in our case, output) goes on the stage (console window).\n\nHere’s how you get text to appear exactly where it’s supposed to go:\n\nAfter running this, you’d see:\n\nSee how arranged our outputs?\n\nComparing Techniques: C# Console.WriteLine vs Print to Console\n\nOutputting to the console is a fundamental part of C#. Regardless of whether you’re practicing code or debugging a complex program, displaying data in the console is crucial. But how to do this effectively?\n\nIn C#, we do not have a particular ‘print’ keyword, unlike some other languages. Instead, we have methods like and . You might be wondering what’s the difference between them. Let’s quickly understand.\n\nThis will print on a single line. Got it? does not append newline at the end.\n\nNow the same code with ,\n\nSee the difference? appends a newline at the end. So, your next print will be on a new line.\n\nComparing Efficiency: When to Use Console.WriteLine or Print to Console\n\nThe debate about vs. or how to print to console in C# always ignites a spark. The answer, however, depends on the specific requirement.\n\nNow, let’s see how C# offers fantastic control over what and how you print.\n\nThis will output: Hello, my name is John and I am 30 years old.\n\nC# also supports different forms of string interpolation, allowing us to have even more control over our console outputs. Let’s see how:\n\nSee, the character indicates that the string should parse any variables in it, making it cleaner and easier to understand!\n\nAdvantages and Caveats of Using Console.WriteLine in C#\n\nBy now, we have got a fair idea about . But like everything, it also has its pros and cons. Let’s have a look at them:\n\nPros of Using Console.WriteLine in C#\n• Ease of Use: Console.WriteLine is straightforward and easy to use; it’s one of the first things one learns in C# programming.\n• Versatility: The method can display nearly all types of data—string, numbers, booleans, etc.\n\nCons and Common Pitfalls of Using Console.WriteLine in C#\n• Almost invisible output: If you use Console.WriteLine in a console application without a pause at the end (like Console.ReadLine()), the output might fleet away before you can even see it.\n• Cluttered Output: Without proper formatting, the output can become confusing and hard to read, especially when dealing with complex and long messages.\n\nConsole.WriteLine is a humble start to explore the vast realm of C#. It’s as fundamental to C# as superheroes to comic books. Always remember, every super-coder started from the basics. What are you waiting for? Start your C# coding journey now with Console.WriteLine and, before you know it, you’ll be the super-coder!"
    },
    {
        "link": "https://stackoverflow.com/questions/35493534/c-sharp-console-writeline-does-not-showing-the-second-parameter",
        "document": "While working on the C# Basic datatypes when I made 2 bool variables using different methods and as I tried to show them using Console.WriteLine() method, first variable was displayed but 2nd one did't display. I know the alternates to get the desired output by just using the + symbol between variables or using Placeholder syntax in Console.WriteLine,but I just want to know the reason, why the 2nd parameter is not showing ? If someone know the reason do answer.\n\nthis is the code that I'm working on."
    }
]