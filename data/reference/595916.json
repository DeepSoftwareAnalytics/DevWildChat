[
    {
        "link": "https://laravel.com/docs/12.x/requests",
        "document": "Laravel's class provides an object-oriented way to interact with the current HTTP request being handled by your application as well as retrieve the input, cookies, and files that were submitted with the request.\n\nTo obtain an instance of the current HTTP request via dependency injection, you should type-hint the class on your route closure or controller method. The incoming request instance will automatically be injected by the Laravel service container:\n\nAs mentioned, you may also type-hint the class on a route closure. The service container will automatically inject the incoming request into the closure when it is executed:\n\nIf your controller method is also expecting input from a route parameter you should list your route parameters after your other dependencies. For example, if your route is defined like so:\n\nYou may still type-hint the and access your route parameter by defining your controller method as follows:\n\nThe instance provides a variety of methods for examining the incoming HTTP request and extends the class. We will discuss a few of the most important methods below.\n\nThe method returns the request's path information. So, if the incoming request is targeted at , the method will return :\n\nThe method allows you to verify that the incoming request path matches a given pattern. You may use the character as a wildcard when utilizing this method:\n\nUsing the method, you may determine if the incoming request has matched a named route:\n\nTo retrieve the full URL for the incoming request you may use the or methods. The method will return the URL without the query string, while the method includes the query string:\n\nIf you would like to append query string data to the current URL, you may call the method. This method merges the given array of query string variables with the current query string:\n\nIf you would like to get the current URL without a given query string parameter, you may utilize the method:\n\nYou may retrieve the \"host\" of the incoming request via the , , and methods:\n\nThe method will return the HTTP verb for the request. You may use the method to verify that the HTTP verb matches a given string:\n\nYou may retrieve a request header from the instance using the method. If the header is not present on the request, will be returned. However, the method accepts an optional second argument that will be returned if the header is not present on the request:\n\nThe method may be used to determine if the request contains a given header:\n\nFor convenience, the method may be used to retrieve a bearer token from the header. If no such header is present, an empty string will be returned:\n\nThe method may be used to retrieve the IP address of the client that made the request to your application:\n\nIf you would like to retrieve an array of IP addresses, including all of the client IP addresses that were forwarded by proxies, you may use the method. The \"original\" client IP address will be at the end of the array:\n\nIn general, IP addresses should be considered untrusted, user-controlled input and be used for informational purposes only.\n\nLaravel provides several methods for inspecting the incoming request's requested content types via the header. First, the method will return an array containing all of the content types accepted by the request:\n\nThe method accepts an array of content types and returns if any of the content types are accepted by the request. Otherwise, will be returned:\n\nYou may use the method to determine which content type out of a given array of content types is most preferred by the request. If none of the provided content types are accepted by the request, will be returned:\n\nSince many applications only serve HTML or JSON, you may use the method to quickly determine if the incoming request expects a JSON response:\n\nThe PSR-7 standard specifies interfaces for HTTP messages, including requests and responses. If you would like to obtain an instance of a PSR-7 request instead of a Laravel request, you will first need to install a few libraries. Laravel uses the Symfony HTTP Message Bridge component to convert typical Laravel requests and responses into PSR-7 compatible implementations:\n\nOnce you have installed these libraries, you may obtain a PSR-7 request by type-hinting the request interface on your route closure or controller method:\n\nYou may retrieve all of the incoming request's input data as an using the method. This method may be used regardless of whether the incoming request is from an HTML form or is an XHR request:\n\nUsing the method, you may retrieve all of the incoming request's input data as a collection:\n\nThe method also allows you to retrieve a subset of the incoming request's input as a collection:\n\nUsing a few simple methods, you may access all of the user input from your instance without worrying about which HTTP verb was used for the request. Regardless of the HTTP verb, the method may be used to retrieve user input:\n\nYou may pass a default value as the second argument to the method. This value will be returned if the requested input value is not present on the request:\n\nWhen working with forms that contain array inputs, use \"dot\" notation to access the arrays:\n\nYou may call the method without any arguments in order to retrieve all of the input values as an associative array:\n\nWhile the method retrieves values from the entire request payload (including the query string), the method will only retrieve values from the query string:\n\nIf the requested query string value data is not present, the second argument to this method will be returned:\n\nYou may call the method without any arguments in order to retrieve all of the query string values as an associative array:\n\nWhen sending JSON requests to your application, you may access the JSON data via the method as long as the header of the request is properly set to . You may even use \"dot\" syntax to retrieve values that are nested within JSON arrays / objects:\n\nInstead of retrieving the request's input data as a primitive , you may use the method to retrieve the request data as an instance of :\n\nTo retrieve input values as integers, you may use the method. This method will attempt to cast the input value to an integer. If the input is not present or the cast fails, it will return the default value you specify. This is particularly useful for pagination or other numeric inputs:\n\nWhen dealing with HTML elements like checkboxes, your application may receive \"truthy\" values that are actually strings. For example, \"true\" or \"on\". For convenience, you may use the method to retrieve these values as booleans. The method returns for 1, \"1\", true, \"true\", \"on\", and \"yes\". All other values will return :\n\nFor convenience, input values containing dates / times may be retrieved as Carbon instances using the method. If the request does not contain an input value with the given name, will be returned:\n\nThe second and third arguments accepted by the method may be used to specify the date's format and timezone, respectively:\n\nIf the input value is present but has an invalid format, an will be thrown; therefore, it is recommended that you validate the input before invoking the method.\n\nInput values that correspond to PHP enums may also be retrieved from the request. If the request does not contain an input value with the given name or the enum does not have a backing value that matches the input value, will be returned. The method accepts the name of the input value and the enum class as its first and second arguments:\n\nIf the input value is an array of values that correspond to a PHP enum, you may use the method to retrieve the array of values as enum instances:\n\nYou may also access user input using dynamic properties on the instance. For example, if one of your application's forms contains a field, you may access the value of the field like so:\n\nWhen using dynamic properties, Laravel will first look for the parameter's value in the request payload. If it is not present, Laravel will search for the field in the matched route's parameters.\n\nIf you need to retrieve a subset of the input data, you may use the and methods. Both of these methods accept a single or a dynamic list of arguments:\n\nYou may use the method to determine if a value is present on the request. The method returns if the value is present on the request:\n\nWhen given an array, the method will determine if all of the specified values are present:\n\nThe method returns if any of the specified values are present:\n\nThe method will execute the given closure if a value is present on the request:\n\nA second closure may be passed to the method that will be executed if the specified value is not present on the request:\n\nIf you would like to determine if a value is present on the request and is not an empty string, you may use the method:\n\nIf you would like to determine if a value is missing from the request or is an empty string, you may use the method:\n\nWhen given an array, the method will determine if all of the specified values are missing or empty:\n\nThe method returns if any of the specified values is not an empty string:\n\nThe method will execute the given closure if a value is present on the request and is not an empty string:\n\nA second closure may be passed to the method that will be executed if the specified value is not \"filled\":\n\nTo determine if a given key is absent from the request, you may use the and methods:\n\nSometimes you may need to manually merge additional input into the request's existing input data. To accomplish this, you may use the method. If a given input key already exists on the request, it will be overwritten by the data provided to the method:\n\nThe method may be used to merge input into the request if the corresponding keys do not already exist within the request's input data:\n\nLaravel allows you to keep input from one request during the next request. This feature is particularly useful for re-populating forms after detecting validation errors. However, if you are using Laravel's included validation features, it is possible that you will not need to manually use these session input flashing methods directly, as some of Laravel's built-in validation facilities will call them automatically.\n\nThe method on the class will flash the current input to the session so that it is available during the user's next request to the application:\n\nYou may also use the and methods to flash a subset of the request data to the session. These methods are useful for keeping sensitive information such as passwords out of the session:\n\nSince you often will want to flash input to the session and then redirect to the previous page, you may easily chain input flashing onto a redirect using the method:\n\nTo retrieve flashed input from the previous request, invoke the method on an instance of . The method will pull the previously flashed input data from the session:\n\nLaravel also provides a global helper. If you are displaying old input within a Blade template, it is more convenient to use the helper to repopulate the form. If no old input exists for the given field, will be returned:\n\nAll cookies created by the Laravel framework are encrypted and signed with an authentication code, meaning they will be considered invalid if they have been changed by the client. To retrieve a cookie value from the request, use the method on an instance:\n\nBy default, Laravel includes the and middleware in your application's global middleware stack. These middleware will automatically trim all incoming string fields on the request, as well as convert any empty string fields to . This allows you to not have to worry about these normalization concerns in your routes and controllers.\n\nIf you would like to disable this behavior for all requests, you may remove the two middleware from your application's middleware stack by invoking the method in your application's file:\n\nIf you would like to disable string trimming and empty string conversion for a subset of requests to your application, you may use the and middleware methods within your application's file. Both methods accept an array of closures, which should return or to indicate whether input normalization should be skipped:\n\nYou may retrieve uploaded files from an instance using the method or using dynamic properties. The method returns an instance of the class, which extends the PHP class and provides a variety of methods for interacting with the file:\n\nYou may determine if a file is present on the request using the method:\n\nIn addition to checking if the file is present, you may verify that there were no problems uploading the file via the method:\n\nThe class also contains methods for accessing the file's fully-qualified path and its extension. The method will attempt to guess the file's extension based on its contents. This extension may be different from the extension that was supplied by the client:\n\nThere are a variety of other methods available on instances. Check out the API documentation for the class for more information regarding these methods.\n\nTo store an uploaded file, you will typically use one of your configured filesystems. The class has a method that will move an uploaded file to one of your disks, which may be a location on your local filesystem or a cloud storage location like Amazon S3.\n\nThe method accepts the path where the file should be stored relative to the filesystem's configured root directory. This path should not contain a filename, since a unique ID will automatically be generated to serve as the filename.\n\nThe method also accepts an optional second argument for the name of the disk that should be used to store the file. The method will return the path of the file relative to the disk's root:\n\nIf you do not want a filename to be automatically generated, you may use the method, which accepts the path, filename, and disk name as its arguments:\n\nWhen running your applications behind a load balancer that terminates TLS / SSL certificates, you may notice your application sometimes does not generate HTTPS links when using the helper. Typically this is because your application is being forwarded traffic from your load balancer on port 80 and does not know it should generate secure links.\n\nTo solve this, you may enable the middleware that is included in your Laravel application, which allows you to quickly customize the load balancers or proxies that should be trusted by your application. Your trusted proxies should be specified using the middleware method in your application's file:\n\nIn addition to configuring the trusted proxies, you may also configure the proxy headers that should be trusted:\n\nIf you are using Amazon AWS or another \"cloud\" load balancer provider, you may not know the IP addresses of your actual balancers. In this case, you may use to trust all proxies:\n\nBy default, Laravel will respond to all requests it receives regardless of the content of the HTTP request's header. In addition, the header's value will be used when generating absolute URLs to your application during a web request.\n\nTypically, you should configure your web server, such as Nginx or Apache, to only send requests to your application that match a given hostname. However, if you do not have the ability to customize your web server directly and need to instruct Laravel to only respond to certain hostnames, you may do so by enabling the middleware for your application.\n\nTo enable the middleware, you should invoke the middleware method in your application's file. Using the argument of this method, you may specify the hostnames that your application should respond to. Incoming requests with other headers will be rejected:\n\nBy default, requests coming from subdomains of the application's URL are also automatically trusted. If you would like to disable this behavior, you may use the argument:\n\nIf you need to access your application's configuration files or database to determine your trusted hosts, you may provide a closure to the argument:"
    },
    {
        "link": "https://readouble.com/laravel/9.x/en/requests.html",
        "document": "Laravel's class provides an object-oriented way to interact with the current HTTP request being handled by your application as well as retrieve the input, cookies, and files that were submitted with the request.\n\nTo obtain an instance of the current HTTP request via dependency injection, you should type-hint the class on your route closure or controller method. The incoming request instance will automatically be injected by the Laravel service container:\n\nAs mentioned, you may also type-hint the class on a route closure. The service container will automatically inject the incoming request into the closure when it is executed:\n\nIf your controller method is also expecting input from a route parameter you should list your route parameters after your other dependencies. For example, if your route is defined like so:\n\nYou may still type-hint the and access your route parameter by defining your controller method as follows:\n\nThe instance provides a variety of methods for examining the incoming HTTP request and extends the class. We will discuss a few of the most important methods below.\n\nThe method returns the request's path information. So, if the incoming request is targeted at , the method will return :\n\nThe method allows you to verify that the incoming request path matches a given pattern. You may use the character as a wildcard when utilizing this method:\n\nUsing the method, you may determine if the incoming request has matched a named route:\n\nTo retrieve the full URL for the incoming request you may use the or methods. The method will return the URL without the query string, while the method includes the query string:\n\nIf you would like to append query string data to the current URL, you may call the method. This method merges the given array of query string variables with the current query string:\n\nYou may retrieve the \"host\" of the incoming request via the , , and methods:\n\nThe method will return the HTTP verb for the request. You may use the method to verify that the HTTP verb matches a given string:\n\nYou may retrieve a request header from the instance using the method. If the header is not present on the request, will be returned. However, the method accepts an optional second argument that will be returned if the header is not present on the request:\n\nThe method may be used to determine if the request contains a given header:\n\nFor convenience, the method may be used to retrieve a bearer token from the header. If no such header is present, an empty string will be returned:\n\nThe method may be used to retrieve the IP address of the client that made the request to your application:\n\nLaravel provides several methods for inspecting the incoming request's requested content types via the header. First, the method will return an array containing all of the content types accepted by the request:\n\nThe method accepts an array of content types and returns if any of the content types are accepted by the request. Otherwise, will be returned:\n\nYou may use the method to determine which content type out of a given array of content types is most preferred by the request. If none of the provided content types are accepted by the request, will be returned:\n\nSince many applications only serve HTML or JSON, you may use the method to quickly determine if the incoming request expects a JSON response:\n\nThe PSR-7 standard specifies interfaces for HTTP messages, including requests and responses. If you would like to obtain an instance of a PSR-7 request instead of a Laravel request, you will first need to install a few libraries. Laravel uses the Symfony HTTP Message Bridge component to convert typical Laravel requests and responses into PSR-7 compatible implementations:\n\nOnce you have installed these libraries, you may obtain a PSR-7 request by type-hinting the request interface on your route closure or controller method:\n\nYou may retrieve all of the incoming request's input data as an using the method. This method may be used regardless of whether the incoming request is from an HTML form or is an XHR request:\n\nUsing the method, you may retrieve all of the incoming request's input data as a collection:\n\nThe method also allows you to retrieve a subset of the incoming request input as a collection:\n\nUsing a few simple methods, you may access all of the user input from your instance without worrying about which HTTP verb was used for the request. Regardless of the HTTP verb, the method may be used to retrieve user input:\n\nYou may pass a default value as the second argument to the method. This value will be returned if the requested input value is not present on the request:\n\nWhen working with forms that contain array inputs, use \"dot\" notation to access the arrays:\n\nYou may call the method without any arguments in order to retrieve all of the input values as an associative array:\n\nWhile the method retrieves values from the entire request payload (including the query string), the method will only retrieve values from the query string:\n\nIf the requested query string value data is not present, the second argument to this method will be returned:\n\nYou may call the method without any arguments in order to retrieve all of the query string values as an associative array:\n\nWhen sending JSON requests to your application, you may access the JSON data via the method as long as the header of the request is properly set to . You may even use \"dot\" syntax to retrieve values that are nested within JSON arrays / objects:\n\nInstead of retrieving the request's input data as a primitive , you may use the method to retrieve the request data as an instance of :\n\nWhen dealing with HTML elements like checkboxes, your application may receive \"truthy\" values that are actually strings. For example, \"true\" or \"on\". For convenience, you may use the method to retrieve these values as booleans. The method returns for 1, \"1\", true, \"true\", \"on\", and \"yes\". All other values will return :\n\nFor convenience, input values containing dates / times may be retrieved as Carbon instances using the method. If the request does not contain an input value with the given name, will be returned:\n\nThe second and third arguments accepted by the method may be used to specify the date's format and timezone, respectively:\n\nIf the input value is present but has an invalid format, an will be thrown; therefore, it is recommended that you validate the input before invoking the method.\n\nInput values that correspond to PHP enums may also be retrieved from the request. If the request does not contain an input value with the given name or the enum does not have a backing value that matches the input value, will be returned. The method accepts the name of the input value and the enum class as its first and second arguments:\n\nYou may also access user input using dynamic properties on the instance. For example, if one of your application's forms contains a field, you may access the value of the field like so:\n\nWhen using dynamic properties, Laravel will first look for the parameter's value in the request payload. If it is not present, Laravel will search for the field in the matched route's parameters.\n\nIf you need to retrieve a subset of the input data, you may use the and methods. Both of these methods accept a single or a dynamic list of arguments:\n\nYou may use the method to determine if a value is present on the request. The method returns if the value is present on the request:\n\nWhen given an array, the method will determine if all of the specified values are present:\n\nThe method will execute the given closure if a value is present on the request:\n\nA second closure may be passed to the method that will be executed if the specified value is not present on the request:\n\nThe method returns if any of the specified values are present:\n\nIf you would like to determine if a value is present on the request and is not an empty string, you may use the method:\n\nThe method will execute the given closure if a value is present on the request and is not an empty string:\n\nA second closure may be passed to the method that will be executed if the specified value is not \"filled\":\n\nTo determine if a given key is absent from the request, you may use the and methods:\n\nSometimes you may need to manually merge additional input into the request's existing input data. To accomplish this, you may use the method. If a given input key already exists on the request, it will be overwritten by the data provided to the method:\n\nThe method may be used to merge input into the request if the corresponding keys do not already exist within the request's input data:\n\nLaravel allows you to keep input from one request during the next request. This feature is particularly useful for re-populating forms after detecting validation errors. However, if you are using Laravel's included validation features, it is possible that you will not need to manually use these session input flashing methods directly, as some of Laravel's built-in validation facilities will call them automatically.\n\nThe method on the class will flash the current input to the session so that it is available during the user's next request to the application:\n\nYou may also use the and methods to flash a subset of the request data to the session. These methods are useful for keeping sensitive information such as passwords out of the session:\n\nSince you often will want to flash input to the session and then redirect to the previous page, you may easily chain input flashing onto a redirect using the method:\n\nTo retrieve flashed input from the previous request, invoke the method on an instance of . The method will pull the previously flashed input data from the session:\n\nLaravel also provides a global helper. If you are displaying old input within a Blade template, it is more convenient to use the helper to repopulate the form. If no old input exists for the given field, will be returned:\n\nAll cookies created by the Laravel framework are encrypted and signed with an authentication code, meaning they will be considered invalid if they have been changed by the client. To retrieve a cookie value from the request, use the method on an instance:\n\nBy default, Laravel includes the and middleware in your application's global middleware stack. These middleware are listed in the global middleware stack by the class. These middleware will automatically trim all incoming string fields on the request, as well as convert any empty string fields to . This allows you to not have to worry about these normalization concerns in your routes and controllers.\n\nIf you would like to disable this behavior for all requests, you may remove the two middleware from your application's middleware stack by removing them from the property of your class.\n\nIf you would like to disable string trimming and empty string conversion for a subset of requests to your application, you may use the method offered by both middleware. This method accepts a closure which should return or to indicate if input normalization should be skipped. Typically, the method should be invoked in the method of your application's .\n\nYou may retrieve uploaded files from an instance using the method or using dynamic properties. The method returns an instance of the class, which extends the PHP class and provides a variety of methods for interacting with the file:\n\nYou may determine if a file is present on the request using the method:\n\nIn addition to checking if the file is present, you may verify that there were no problems uploading the file via the method:\n\nThe class also contains methods for accessing the file's fully-qualified path and its extension. The method will attempt to guess the file's extension based on its contents. This extension may be different from the extension that was supplied by the client:\n\nThere are a variety of other methods available on instances. Check out the API documentation for the class for more information regarding these methods.\n\nTo store an uploaded file, you will typically use one of your configured filesystems. The class has a method that will move an uploaded file to one of your disks, which may be a location on your local filesystem or a cloud storage location like Amazon S3.\n\nThe method accepts the path where the file should be stored relative to the filesystem's configured root directory. This path should not contain a filename, since a unique ID will automatically be generated to serve as the filename.\n\nThe method also accepts an optional second argument for the name of the disk that should be used to store the file. The method will return the path of the file relative to the disk's root:\n\nIf you do not want a filename to be automatically generated, you may use the method, which accepts the path, filename, and disk name as its arguments:\n\nWhen running your applications behind a load balancer that terminates TLS / SSL certificates, you may notice your application sometimes does not generate HTTPS links when using the helper. Typically this is because your application is being forwarded traffic from your load balancer on port 80 and does not know it should generate secure links.\n\nTo solve this, you may use the middleware that is included in your Laravel application, which allows you to quickly customize the load balancers or proxies that should be trusted by your application. Your trusted proxies should be listed as an array on the property of this middleware. In addition to configuring the trusted proxies, you may configure the proxy that should be trusted:\n\nIf you are using Amazon AWS or another \"cloud\" load balancer provider, you may not know the IP addresses of your actual balancers. In this case, you may use to trust all proxies:\n\nBy default, Laravel will respond to all requests it receives regardless of the content of the HTTP request's header. In addition, the header's value will be used when generating absolute URLs to your application during a web request.\n\nTypically, you should configure your web server, such as Nginx or Apache, to only send requests to your application that match a given host name. However, if you do not have the ability to customize your web server directly and need to instruct Laravel to only respond to certain host names, you may do so by enabling the middleware for your application.\n\nThe middleware is already included in the stack of your application; however, you should uncomment it so that it becomes active. Within this middleware's method, you may specify the host names that your application should respond to. Incoming requests with other value headers will be rejected:\n\nThe helper method will return a regular expression matching all subdomains of your application's configuration value. This helper method provides a convenient way to allow all of your application's subdomains when building an application that utilizes wildcard subdomains."
    },
    {
        "link": "https://laravel.com/docs/11.x/requests",
        "document": "WARNING You're browsing the documentation for an old version of Laravel. Consider upgrading your project to Laravel 12.x .\n\nLaravel's class provides an object-oriented way to interact with the current HTTP request being handled by your application as well as retrieve the input, cookies, and files that were submitted with the request.\n\nTo obtain an instance of the current HTTP request via dependency injection, you should type-hint the class on your route closure or controller method. The incoming request instance will automatically be injected by the Laravel service container:\n\nAs mentioned, you may also type-hint the class on a route closure. The service container will automatically inject the incoming request into the closure when it is executed:\n\nIf your controller method is also expecting input from a route parameter you should list your route parameters after your other dependencies. For example, if your route is defined like so:\n\nYou may still type-hint the and access your route parameter by defining your controller method as follows:\n\nThe instance provides a variety of methods for examining the incoming HTTP request and extends the class. We will discuss a few of the most important methods below.\n\nThe method returns the request's path information. So, if the incoming request is targeted at , the method will return :\n\nThe method allows you to verify that the incoming request path matches a given pattern. You may use the character as a wildcard when utilizing this method:\n\nUsing the method, you may determine if the incoming request has matched a named route:\n\nTo retrieve the full URL for the incoming request you may use the or methods. The method will return the URL without the query string, while the method includes the query string:\n\nIf you would like to append query string data to the current URL, you may call the method. This method merges the given array of query string variables with the current query string:\n\nIf you would like to get the current URL without a given query string parameter, you may utilize the method:\n\nYou may retrieve the \"host\" of the incoming request via the , , and methods:\n\nThe method will return the HTTP verb for the request. You may use the method to verify that the HTTP verb matches a given string:\n\nYou may retrieve a request header from the instance using the method. If the header is not present on the request, will be returned. However, the method accepts an optional second argument that will be returned if the header is not present on the request:\n\nThe method may be used to determine if the request contains a given header:\n\nFor convenience, the method may be used to retrieve a bearer token from the header. If no such header is present, an empty string will be returned:\n\nThe method may be used to retrieve the IP address of the client that made the request to your application:\n\nIf you would like to retrieve an array of IP addresses, including all of the client IP addresses that were forwarded by proxies, you may use the method. The \"original\" client IP address will be at the end of the array:\n\nIn general, IP addresses should be considered untrusted, user-controlled input and be used for informational purposes only.\n\nLaravel provides several methods for inspecting the incoming request's requested content types via the header. First, the method will return an array containing all of the content types accepted by the request:\n\nThe method accepts an array of content types and returns if any of the content types are accepted by the request. Otherwise, will be returned:\n\nYou may use the method to determine which content type out of a given array of content types is most preferred by the request. If none of the provided content types are accepted by the request, will be returned:\n\nSince many applications only serve HTML or JSON, you may use the method to quickly determine if the incoming request expects a JSON response:\n\nThe PSR-7 standard specifies interfaces for HTTP messages, including requests and responses. If you would like to obtain an instance of a PSR-7 request instead of a Laravel request, you will first need to install a few libraries. Laravel uses the Symfony HTTP Message Bridge component to convert typical Laravel requests and responses into PSR-7 compatible implementations:\n\nOnce you have installed these libraries, you may obtain a PSR-7 request by type-hinting the request interface on your route closure or controller method:\n\nYou may retrieve all of the incoming request's input data as an using the method. This method may be used regardless of whether the incoming request is from an HTML form or is an XHR request:\n\nUsing the method, you may retrieve all of the incoming request's input data as a collection:\n\nThe method also allows you to retrieve a subset of the incoming request's input as a collection:\n\nUsing a few simple methods, you may access all of the user input from your instance without worrying about which HTTP verb was used for the request. Regardless of the HTTP verb, the method may be used to retrieve user input:\n\nYou may pass a default value as the second argument to the method. This value will be returned if the requested input value is not present on the request:\n\nWhen working with forms that contain array inputs, use \"dot\" notation to access the arrays:\n\nYou may call the method without any arguments in order to retrieve all of the input values as an associative array:\n\nWhile the method retrieves values from the entire request payload (including the query string), the method will only retrieve values from the query string:\n\nIf the requested query string value data is not present, the second argument to this method will be returned:\n\nYou may call the method without any arguments in order to retrieve all of the query string values as an associative array:\n\nWhen sending JSON requests to your application, you may access the JSON data via the method as long as the header of the request is properly set to . You may even use \"dot\" syntax to retrieve values that are nested within JSON arrays / objects:\n\nInstead of retrieving the request's input data as a primitive , you may use the method to retrieve the request data as an instance of :\n\nTo retrieve input values as integers, you may use the method. This method will attempt to cast the input value to an integer. If the input is not present or the cast fails, it will return the default value you specify. This is particularly useful for pagination or other numeric inputs:\n\nWhen dealing with HTML elements like checkboxes, your application may receive \"truthy\" values that are actually strings. For example, \"true\" or \"on\". For convenience, you may use the method to retrieve these values as booleans. The method returns for 1, \"1\", true, \"true\", \"on\", and \"yes\". All other values will return :\n\nFor convenience, input values containing dates / times may be retrieved as Carbon instances using the method. If the request does not contain an input value with the given name, will be returned:\n\nThe second and third arguments accepted by the method may be used to specify the date's format and timezone, respectively:\n\nIf the input value is present but has an invalid format, an will be thrown; therefore, it is recommended that you validate the input before invoking the method.\n\nInput values that correspond to PHP enums may also be retrieved from the request. If the request does not contain an input value with the given name or the enum does not have a backing value that matches the input value, will be returned. The method accepts the name of the input value and the enum class as its first and second arguments:\n\nIf the input value is an array of values that correspond to a PHP enum, you may use the method to retrieve the array of values as enum instances:\n\nYou may also access user input using dynamic properties on the instance. For example, if one of your application's forms contains a field, you may access the value of the field like so:\n\nWhen using dynamic properties, Laravel will first look for the parameter's value in the request payload. If it is not present, Laravel will search for the field in the matched route's parameters.\n\nIf you need to retrieve a subset of the input data, you may use the and methods. Both of these methods accept a single or a dynamic list of arguments:\n\nYou may use the method to determine if a value is present on the request. The method returns if the value is present on the request:\n\nWhen given an array, the method will determine if all of the specified values are present:\n\nThe method returns if any of the specified values are present:\n\nThe method will execute the given closure if a value is present on the request:\n\nA second closure may be passed to the method that will be executed if the specified value is not present on the request:\n\nIf you would like to determine if a value is present on the request and is not an empty string, you may use the method:\n\nIf you would like to determine if a value is missing from the request or is an empty string, you may use the method:\n\nWhen given an array, the method will determine if all of the specified values are missing or empty:\n\nThe method returns if any of the specified values is not an empty string:\n\nThe method will execute the given closure if a value is present on the request and is not an empty string:\n\nA second closure may be passed to the method that will be executed if the specified value is not \"filled\":\n\nTo determine if a given key is absent from the request, you may use the and methods:\n\nSometimes you may need to manually merge additional input into the request's existing input data. To accomplish this, you may use the method. If a given input key already exists on the request, it will be overwritten by the data provided to the method:\n\nThe method may be used to merge input into the request if the corresponding keys do not already exist within the request's input data:\n\nLaravel allows you to keep input from one request during the next request. This feature is particularly useful for re-populating forms after detecting validation errors. However, if you are using Laravel's included validation features, it is possible that you will not need to manually use these session input flashing methods directly, as some of Laravel's built-in validation facilities will call them automatically.\n\nThe method on the class will flash the current input to the session so that it is available during the user's next request to the application:\n\nYou may also use the and methods to flash a subset of the request data to the session. These methods are useful for keeping sensitive information such as passwords out of the session:\n\nSince you often will want to flash input to the session and then redirect to the previous page, you may easily chain input flashing onto a redirect using the method:\n\nTo retrieve flashed input from the previous request, invoke the method on an instance of . The method will pull the previously flashed input data from the session:\n\nLaravel also provides a global helper. If you are displaying old input within a Blade template, it is more convenient to use the helper to repopulate the form. If no old input exists for the given field, will be returned:\n\nAll cookies created by the Laravel framework are encrypted and signed with an authentication code, meaning they will be considered invalid if they have been changed by the client. To retrieve a cookie value from the request, use the method on an instance:\n\nBy default, Laravel includes the and middleware in your application's global middleware stack. These middleware will automatically trim all incoming string fields on the request, as well as convert any empty string fields to . This allows you to not have to worry about these normalization concerns in your routes and controllers.\n\nIf you would like to disable this behavior for all requests, you may remove the two middleware from your application's middleware stack by invoking the method in your application's file:\n\nIf you would like to disable string trimming and empty string conversion for a subset of requests to your application, you may use the and middleware methods within your application's file. Both methods accept an array of closures, which should return or to indicate whether input normalization should be skipped:\n\nYou may retrieve uploaded files from an instance using the method or using dynamic properties. The method returns an instance of the class, which extends the PHP class and provides a variety of methods for interacting with the file:\n\nYou may determine if a file is present on the request using the method:\n\nIn addition to checking if the file is present, you may verify that there were no problems uploading the file via the method:\n\nThe class also contains methods for accessing the file's fully-qualified path and its extension. The method will attempt to guess the file's extension based on its contents. This extension may be different from the extension that was supplied by the client:\n\nThere are a variety of other methods available on instances. Check out the API documentation for the class for more information regarding these methods.\n\nTo store an uploaded file, you will typically use one of your configured filesystems. The class has a method that will move an uploaded file to one of your disks, which may be a location on your local filesystem or a cloud storage location like Amazon S3.\n\nThe method accepts the path where the file should be stored relative to the filesystem's configured root directory. This path should not contain a filename, since a unique ID will automatically be generated to serve as the filename.\n\nThe method also accepts an optional second argument for the name of the disk that should be used to store the file. The method will return the path of the file relative to the disk's root:\n\nIf you do not want a filename to be automatically generated, you may use the method, which accepts the path, filename, and disk name as its arguments:\n\nWhen running your applications behind a load balancer that terminates TLS / SSL certificates, you may notice your application sometimes does not generate HTTPS links when using the helper. Typically this is because your application is being forwarded traffic from your load balancer on port 80 and does not know it should generate secure links.\n\nTo solve this, you may enable the middleware that is included in your Laravel application, which allows you to quickly customize the load balancers or proxies that should be trusted by your application. Your trusted proxies should be specified using the middleware method in your application's file:\n\nIn addition to configuring the trusted proxies, you may also configure the proxy headers that should be trusted:\n\nIf you are using Amazon AWS or another \"cloud\" load balancer provider, you may not know the IP addresses of your actual balancers. In this case, you may use to trust all proxies:\n\nBy default, Laravel will respond to all requests it receives regardless of the content of the HTTP request's header. In addition, the header's value will be used when generating absolute URLs to your application during a web request.\n\nTypically, you should configure your web server, such as Nginx or Apache, to only send requests to your application that match a given hostname. However, if you do not have the ability to customize your web server directly and need to instruct Laravel to only respond to certain hostnames, you may do so by enabling the middleware for your application.\n\nTo enable the middleware, you should invoke the middleware method in your application's file. Using the argument of this method, you may specify the hostnames that your application should respond to. Incoming requests with other headers will be rejected:\n\nBy default, requests coming from subdomains of the application's URL are also automatically trusted. If you would like to disable this behavior, you may use the argument:\n\nIf you need to access your application's configuration files or database to determine your trusted hosts, you may provide a closure to the argument:"
    },
    {
        "link": "https://stackoverflow.com/questions/22355828/doing-http-requests-from-laravel-to-an-external-api",
        "document": "What I want is get an object from an API with a HTTP (eg, jQuery's AJAX) request to an external api. How do I start? I did research on Mr Google but I can't find anything helping.\n\nIm starting to wonder is this is even possible? In this post Laravel 4 make post request from controller to external url with data it looks like it can be done. But there's no example nor any source where to find some documentation.\n\nPlease help me out?"
    },
    {
        "link": "https://apiato.io/docs/9.x/main-components/requests",
        "document": "\n• Allow a Role to access every endpoint\n• All Requests MUST extend from .\n• A Request MUST have a function, returning an array and function to check for authorization (can return true when no authorization required).\n\nIf you are wondering what are those properties doing on the request! keep reading\n\nBy just injecting the request class you already applied the validation and authorization rules.\n\nWhen you need to pass data to the Action, you should pass the request Object as it is to the Action parameter.\n\napiato adds some new properties to the Request Class. Each of these properties is very useful for some situations, and let you achieve your goals faster and cleaner. Below we'll see description for each property:\n\nThe $decode property is used for decoding Hashed ID's from any Request on the fly\n\nIf you have enabled the HashID feature, that apiato provide out of the box. Most probably you are passing or allowing your users to pass Hashed (encoded) ID's into your application.\n\nThus, these IDs need to be Decoded somewhere, apiato has a property on its Requests Components where you can specify those Hashed ID's in order to decode them before applying the validation rules.\n\nNote: validations rules that relies on your ID like ( ) will not work unless you decode your ID before passing it to the validation.\n\nThe $urlParameters property is used for applying validation rules on the URL parameters:\n\nLaravel by default does not allow validating the URL parameters ( ). In order to be able to apply validation rules on URL parameters you can simply define your URL parameters in the property. This will also allow you to access those parameters form the Controller in the same way you access the Request data.\n\nThe $access property, allows the user to define set of Roles and Permissions than can access this endpoint.\n\nThe property is used by the function defined below in the function, to check if the user has the necessary Roles & Permissions to call this endpoint (basically access the controller function where this request object is injected).\n\nIf you do not like the style with in order to separate the different or (e.g., see the example above), you can also use the . The example from above would look like this (only part that changes):\n\nThe function is calling a function which accepts an array of functions names. Each of those functions returns boolean.\n\nIn the example above we are calling three functions , and .\n\nThe separator between the functions indicates an operation, so if any of the functions or returns true the user will gain access and only when both return false the user will be prevented from accessing this endpoint.\n\nOn the other side if (a custom function could be written by you anywhere) returned false no matter what all other functions returns, the user will be prevented from accessing this endpoint, because the default operation between all functions in the array is .\n\nThe best way to add a custom authorize function is through a Trait, which can be added to your classes. In the example below we create a Trait named with a single method called .\n\nThe method, in turn, calls a Task to verify that the current user is an author (e.g., if the user has the proper assigned).\n\nNow, add the newly created Trait to the Request to use the function in the authorization check.\n\nNow, the Request uses the newly created method to check the proper access rights.\n\nYou can allow some Roles to access every endpoint in the system without having to define that role in each Request object.\n\nThis is useful you want to let users with role access everything.\n\nTo do this, define those roles in as follows:\n\nThis will append the role to all roles access in every request object. Example: this becomes (if the user is manager or admin \"has any of the roles\", will be allowed to access the endpoint function).\n\napiato also provides some helpful functions by default, so you can use them whenever you need them.\n\nfunction, decides if user has Access or not based on the property.\n• If the user has any roles or permissions he will be given access.\n• If you need more or less roles/permissions just add between each permission.\n• If you do not need to set a roles/permissions just set or .\n\nThe function, checks if the passed URL ID is the same as the User ID of the request.\n\nLet's say we have an endpoint that deletes a user, and we only need users to delete their own user accounts.\n\nWith , user of ID 1 can only call and won't be able to call or any other ID.\n\nGet the data from within the by entering the name of the field. This function behaves like , however, it works on the decoded values instead of the original data.\n\nConsider the following Request data in case you are passing data instead of :\n\nCalling would return , however would return the decoded value (e.g., ).\n\nFurthermore, one can define a value to be returned, if the key is not present (or not set), like so:\n\nEspecially for requests, if you like to submit only the fields, to be changed to the API in order to:\n\nChecking for the presence (or absence) of specific keys in the request typically results in huge blocks, like so:\n\nSo to avoid those blocks, use in order to remove fields from the request.\n\nHowever, in PHP and (empty string) are also considered as (which is clearly not what you want).\n\nYou can read more about this problem here.\n\nIn order to simplify sanitizing when using instead of , apiato offers a convenient method.\n\nConsider the following Request data:\n\nThe method lets you specify a list of to be accessed and extracted from the . This is done using the DOT notation. Finally, call the method on the :\n\nThe extracted looks like this:\n\nNote that is not within the array, as it was not present within the . Furthermore, all other fields from the are omitted as they are not specified. So basically, the method creates some kind of on the , only passing the defined values. Furthermore, the DOT Notation allows you to easily specify the fields to would like to pass through. This makes partially updating a resource quite easy!\n\nNote that the of an entity can be easily obtained with !\n\nSometimes you might want to map input from the request to other fields in order to automatically pass it to a or . Of course, you can manually map those fields, but you can also rely on the helper function.\n\nThis helper, in turn, allows to \"redefine\" keys in the request for subsequent processing. Consider the following example request:\n\nYour Task to process this data, however, requests the field as . You can call the helper like this:\n\nThe resulting structure would look like this:\n\nDuring the Request life-cycle you may want to store some data on the request object and pass it to other SubActions (or Tasks).\n\nTo store some data on the request use:\n\nTo retrieve the data back at any time during the request life-cycle use:\n\nSince we're passing Request objects to Actions. When writing unit tests we need to create fake Request just to pass it to the Action with some fake data.\n\nExample Two (With Authenticated User):"
    },
    {
        "link": "https://laravel.com/docs/12.x/logging",
        "document": "To help you learn more about what's happening within your application, Laravel provides robust logging services that allow you to log messages to files, the system error log, and even to Slack to notify your entire team.\n\nLaravel logging is based on \"channels\". Each channel represents a specific way of writing log information. For example, the channel writes log files to a single log file, while the channel sends log messages to Slack. Log messages may be written to multiple channels based on their severity.\n\nUnder the hood, Laravel utilizes the Monolog library, which provides support for a variety of powerful log handlers. Laravel makes it a cinch to configure these handlers, allowing you to mix and match them to customize your application's log handling.\n\nAll of the configuration options that control your application's logging behavior are housed in the configuration file. This file allows you to configure your application's log channels, so be sure to review each of the available channels and their options. We'll review a few common options below.\n\nBy default, Laravel will use the channel when logging messages. The channel is used to aggregate multiple log channels into a single channel. For more information on building stacks, check out the documentation below.\n\nEach log channel is powered by a \"driver\". The driver determines how and where the log message is actually recorded. The following log channel drivers are available in every Laravel application. An entry for most of these drivers is already present in your application's configuration file, so be sure to review this file to become familiar with its contents:\n\nBy default, Monolog is instantiated with a \"channel name\" that matches the current environment, such as or . To change this value, you may add a option to your channel's configuration:\n\nThe and channels have three optional configuration options: , , and .\n\nAdditionally, the retention policy for the channel can be configured via the environment variable or by setting the configuration option.\n\nThe channel requires and configuration options. These may be defined via the and environment variables. You can obtain these values from Papertrail.\n\nThe channel requires a configuration option. This value may be defined via the environment variable. This URL should match a URL for an incoming webhook that you have configured for your Slack team.\n\nBy default, Slack will only receive logs at the level and above; however, you can adjust this using the environment variable or by modifying the configuration option within your Slack log channel's configuration array.\n\nPHP, Laravel, and other libraries often notify their users that some of their features have been deprecated and will be removed in a future version. If you would like to log these deprecation warnings, you may specify your preferred log channel using the environment variable, or within your application's configuration file:\n\nOr, you may define a log channel named . If a log channel with this name exists, it will always be used to log deprecations:\n\nAs mentioned previously, the driver allows you to combine multiple channels into a single log channel for convenience. To illustrate how to use log stacks, let's take a look at an example configuration that you might see in a production application:\n\nLet's dissect this configuration. First, notice our channel aggregates two other channels via its option: and . So, when logging messages, both of these channels will have the opportunity to log the message. However, as we will see below, whether these channels actually log the message may be determined by the message's severity / \"level\".\n\nTake note of the configuration option present on the and channel configurations in the example above. This option determines the minimum \"level\" a message must be in order to be logged by the channel. Monolog, which powers Laravel's logging services, offers all of the log levels defined in the RFC 5424 specification. In descending order of severity, these log levels are: emergency, alert, critical, error, warning, notice, info, and debug.\n\nSo, imagine we log a message using the method:\n\nGiven our configuration, the channel will write the message to the system log; however, since the error message is not or above, it will not be sent to Slack. However, if we log an message, it will be sent to both the system log and Slack since the level is above our minimum level threshold for both channels:\n\nYou may write information to the logs using the facade. As previously mentioned, the logger provides the eight logging levels defined in the RFC 5424 specification: emergency, alert, critical, error, warning, notice, info and debug:\n\nYou may call any of these methods to log a message for the corresponding level. By default, the message will be written to the default log channel as configured by your configuration file:\n\nAn array of contextual data may be passed to the log methods. This contextual data will be formatted and displayed with the log message:\n\nOccasionally, you may wish to specify some contextual information that should be included with all subsequent log entries in a particular channel. For example, you may wish to log a request ID that is associated with each incoming request to your application. To accomplish this, you may call the facade's method:\n\nIf you would like to share contextual information across all logging channels, you may invoke the method. This method will provide the contextual information to all created channels and any channels that are created subsequently:\n\nSometimes you may wish to log a message to a channel other than your application's default channel. You may use the method on the facade to retrieve and log to any channel defined in your configuration file:\n\nIf you would like to create an on-demand logging stack consisting of multiple channels, you may use the method:\n\nIt is also possible to create an on-demand channel by providing the configuration at runtime without that configuration being present in your application's configuration file. To accomplish this, you may pass a configuration array to the facade's method:\n\nYou may also wish to include an on-demand channel in an on-demand logging stack. This can be achieved by including your on-demand channel instance in the array passed to the method:\n\nSometimes you may need complete control over how Monolog is configured for an existing channel. For example, you may want to configure a custom Monolog implementation for Laravel's built-in channel.\n\nTo get started, define a array on the channel's configuration. The array should contain a list of classes that should have an opportunity to customize (or \"tap\" into) the Monolog instance after it is created. There is no conventional location where these classes should be placed, so you are free to create a directory within your application to contain these classes:\n\nOnce you have configured the option on your channel, you're ready to define the class that will customize your Monolog instance. This class only needs a single method: , which receives an instance. The instance proxies all method calls to the underlying Monolog instance:\n\nMonolog has a variety of available handlers and Laravel does not include a built-in channel for each one. In some cases, you may wish to create a custom channel that is merely an instance of a specific Monolog handler that does not have a corresponding Laravel log driver. These channels can be easily created using the driver.\n\nWhen using the driver, the configuration option is used to specify which handler will be instantiated. Optionally, any constructor parameters the handler needs may be specified using the configuration option:\n\nWhen using the driver, the Monolog will be used as the default formatter. However, you may customize the type of formatter passed to the handler using the and configuration options:\n\nIf you are using a Monolog handler that is capable of providing its own formatter, you may set the value of the configuration option to :\n\nMonolog can also process messages before logging them. You can create your own processors or use the existing processors offered by Monolog.\n\nIf you would like to customize the processors for a driver, add a configuration value to your channel's configuration:\n\nIf you would like to define an entirely custom channel in which you have full control over Monolog's instantiation and configuration, you may specify a driver type in your configuration file. Your configuration should include a option that contains the name of the factory class which will be invoked to create the Monolog instance:\n\nOnce you have configured the driver channel, you're ready to define the class that will create your Monolog instance. This class only needs a single method which should return the Monolog logger instance. The method will receive the channels configuration array as its only argument:\n\nOften you may need to tail your application's logs in real time. For example, when debugging an issue or when monitoring your application's logs for specific types of errors.\n\nLaravel Pail is a package that allows you to easily dive into your Laravel application's log files directly from the command line. Unlike the standard command, Pail is designed to work with any log driver, including Sentry or Flare. In addition, Pail provides a set of useful filters to help you quickly find what you're looking for.\n\nTo get started, install Pail into your project using the Composer package manager:\n\nTo increase the verbosity of the output and avoid truncation (…), use the option:\n\nFor maximum verbosity and to display exception stack traces, use the option:\n\nTo stop tailing logs, press at any time.\n\nYou may use the option to filter logs by their type, file, message, and stack trace content:\n\nTo filter logs by only their message, you may use the option:\n\nThe option may be used to filter logs by their log level:\n\nTo only display logs that were written while a given user was authenticated, you may provide the user's ID to the option:"
    },
    {
        "link": "https://laravel.com/docs/11.x/logging",
        "document": ""
    },
    {
        "link": "https://wpwebinfotech.com/blog/laravel-logging-guide",
        "document": "For Laravel developers, ensuring application stability and performance is paramount. However, pinpointing the root cause of errors can often feel like traversing a maze. Enter Laravel logging, a powerful tool that sheds light on your application’s inner workings.\n\nBy using the capabilities of Laravel’s logging system, you gain invaluable insights into application behavior. It enables you to troubleshoot issues swiftly and effectively. This comprehensive guide empowers you to become a logging expert, incorporating practices gathered from the expertise of a top-notch Laravel development company.\n\nWe’ll dive into the core concepts, explore a range of logging strategies, and introduce advanced techniques to improve your application’s observability. By the end of this journey, you’ll be equipped to diagnose issues with precision and ensure your Laravel application runs smoothly.\n\nLaravel provides a logging system built on top of the popular Monolog library. This allows you to record events and information occurring within your application for debugging, monitoring, and analysis purposes. Laravel’s logging offers flexibility in where you send these messages. It enables you to log into files, and databases, or even send notifications to platforms like Slack.\n• Channels. Laravel logging uses channels, which define where log messages are sent. The default configuration includes a single channel that writes to a laravel.log file within the storage/logs directory. You can configure additional channels to send logs to various destinations like Slack, email, or custom log rotation systems.\n• Log Levels. Messages can be logged with different severity levels, including debug, info, warning, error, critical, and alert. These levels help categorize the importance of the logged information. It allows you to focus on critical issues while keeping a record of less urgent events.\n• Contextual Information. In addition to the message itself, you can include contextual data with your log entries. This might involve user IDs, timestamps or request data. It can even include any other relevant details that can provide further insight into the logged event.\n\nUsing Laravel’s logging system, you gain valuable insights into the inner workings of your application. This information can be important for troubleshooting errors, identifying performance bottlenecks, and monitoring overall application health. The flexibility of channels and log levels ensures you capture the data in the right detail, helping you build maintainable Laravel applications.\n\nLaravel logging is an important tool for any Laravel developer. It provides a structured and centralized way to record events and information within your application. It offers significant benefits for development, maintenance, and deployment.\n• Enhanced Debugging. Logging detailed messages throughout your code helps pinpoint the root cause of errors and bugs. You can track variable values, execution flow, and identify specific lines, streamlining the debugging process.\n• Improved Monitoring and Analysis. By logging application activity, you gain insights into user behavior, system performance, and potential bottlenecks. This information helps you optimize your application and ensure a smooth user experience.\n• Centralized Error Tracking. Laravel logging allows you to reduce error messages from various parts of your application into a single location. This centralized view makes it easier to identify recurring issues, track their resolution, and prevent future occurrences.\n\nInvesting in proper logging practices with Laravel is important for building robust and maintainable applications. The ability to debug, monitor, and analyze your application becomes even more important as your project grows in complexity. For complex integration with logging solutions, consider consulting experienced Laravel developers. They can help ensure your application benefits from a comprehensive logging strategy.\n\nHow to Use Laravel Logging?\n\nLaravel’s logging system provides a convenient way to record and manage application events. Here’s a step-by-step guide to get you started:\n\nThe configuration file for Laravel logging (config/logging.php) is the central hub for defining how your application logs messages. Here’s a breakdown of the key elements to understand:\n\n1. Channels. This section defines available channels, each representing a destination for log messages. The default configuration includes a stack channel that combines other channels. You can add custom channels for specific logging needs.\n\n2. Drivers. Drivers determine where log messages from a channel are sent. Options include single (single log file), daily (separate log files per day), slack integration, and more. Each driver has its own configuration options.\n\n3. Log Levels. Messages can be logged with different severity levels, including debug, info, warning, error, and more. These levels help categorize the importance of the information.\n\nBy understanding these core components, you can configure Laravel logging to meet your application’s specific requirements.\n\nChannel drivers in Laravel logging dictate where your log messages are sent. Understanding these drivers empowers you to choose the most suitable destinations for different types of logs.\n\n1. Single Driver. This driver writes all logs to a single file specified by the path configuration option. It’s a simple and convenient option for basic logging needs.\n\n2. Daily Driver. This driver creates a separate log file for each day. It helps manage log volume and simplifies searching for logs on specific dates.\n\n3. Stack Driver. This is a powerful driver that allows you to combine multiple channels into a single stack. This enables you to send logs to different destinations based on their severity or type.\n\n4. Other Drivers. Laravel offers additional built-in drivers for destinations like Slack, Syslog, and email. You can also create custom drivers for integrating with specific logging services.\n\nThese are just a few examples, and Laravel offers additional drivers for various logging destinations. By exploring the available options and their configurations, you can tailor your logging setup to match your project’s requirements.\n\nLaravel’s stack channel driver empowers you to create custom log stacks. These stacks combine multiple channels, allowing you to send logs to different destinations based on their severity or type. Here’s how to build log stacks:\n\n1. Define the Stack. In the config/logging.php file, under the channels section, configure a channel with the driver set to stack. Then, specify the individual channels you want to include within the channels option.\n\n2. Set Minimum Level (Optional). The level option within the stack configuration defines the minimum level required for a message to be logged by any channel. This allows you to filter out lower-level messages from all channels.\n\n3. Channel-Specific Levels. While the stack sets a minimum level, you can further configure individual channels within the stack to have their minimum levels. This enables even finer-grained control over where specific log messages are sent.\n\nWith log stacks, you can achieve a more refined logging setup that routes messages to appropriate destinations based on their importance and type.\n\nLaravel’s Log facade provides convenient methods for writing log messages to configured channels. Here’s how to leverage these methods:\n\n1. Import the Facade. Begin by importing the Log facade at the top of your file where you want to log messages.\n\n2. Choose the Log Level. Select the appropriate log level based on the severity of your message. Laravel offers various levels like debugging, info, warning, error, and more.\n\n3. Write the Message. Call the corresponding method on the Log facade, passing your message string as the first argument.\n\nYou can include contextual data (user IDs, timestamps, etc.) with your log messages by passing an associative array as the second argument to the logging method.\n\nOnce these steps are completed, you can write informative log messages throughout your Laravel application. Consider providing valuable insights for debugging, monitoring, and analysis.\n\nBeyond the core message, Laravel logging allows you to include additional data with your log entries. This contextual information provides valuable insights into the logged event, aiding in debugging and analysis. Here’s how to add context:\n\n1. Prepare the Data. Gather the relevant details you want to include with your log message. This might involve user IDs, timestamps, request data, object properties, or any other information that focuses on the event.\n\n2. Pass as an Array. When calling the Log facade method, provide an associative array as the second argument. This array’s keys represent the data names, and the values contain the actual data.\n\n3. Flexibility and Readability. Contextual data offers flexibility in what information you log. Aim for clear and concise key names that accurately reflect the logged data. This improves readability when reviewing log entries.\n\nIncorporating contextual information into your Laravel logs enriches the data available for troubleshooting and analysis. This makes it easier to understand the circumstances surrounding logged events.\n\nWhat are the Advanced Uses of Laravel Logging?\n\nLaravel’s built-in logging goes beyond basic error messages. By leveraging its advanced features, you can gain deeper insights into your application’s behavior and streamline troubleshooting. You can also consider enlisting a Laravel development agency to help you implement these advanced logging techniques for optimal results.\n\nMove beyond plain text messages. Structured logs include key-value pairs for data like timestamps, user IDs, and request details. This makes logs easier to parse by machines and analyze with logging tools.\n\nLaravel’s default channels are great, but you can extend them. Create custom channels to send logs to specific destinations like Slack, a database, or an external monitoring service. Handlers define how the logs are formatted and delivered within those channels.\n\nTrack database model changes. Laravel allows you to log model events like creation, deletion, and updates. This provides a detailed audit trail of data modifications within your application.\n\nGain visibility into your queued jobs. Log job information like attempts, successes, and failures. This helps identify problematic jobs and optimize your queuing system.\n\nPrevent log files from growing infinitely. Configure logs to rotate automatically, creating new files when they reach a certain size. You can also set retention policies to archive or delete older logs.\n\nWith these advanced logging techniques, you can unlock a wealth of information about your application’s inner workings. This benefits you in diagnosing issues faster, improving application performance, and ensuring data security.\n\nWhat are the Best Practices to Follow in Laravel Logging?\n\nLaravel’s logging system offers a powerful toolkit, but proper configuration is key to maximizing its effectiveness. Here are some best practices to follow for a well-structured and informative logging setup.\n• Logging Levels. Laravel supports various logging levels (debug, info, warning, etc.) Use these levels to categorize the severity of your log messages. This helps prioritize important information and filter out less critical logs during troubleshooting.\n• Contextual Information. Don’t log messages in isolation. Enrich your logs with relevant context, such as user IDs, request data, or timestamps. This additional information paints a clearer picture of the situation when analyzing logs.\n• Structured Logging. Structured logs go beyond plain text. Use key-value pairs to format your log messages. This makes them machine-readable and easier to analyze with logging tools, allowing for more advanced filtering and aggregation.\n• Logging Channels. Laravel offers multiple channels to send logs to different destinations (files, databases, Slack). Choose the appropriate channel based on the type of log message. This keeps your logs organized and allows you to monitor them efficiently.\n• Custom Log Handlers. While default handlers are helpful, consider creating custom handlers. These handlers can tailor the format and delivery of your logs within specific channels. This allows for more granular control over how your logs are presented.\n\nThis will help you to identify and resolve issues swiftly, optimize performance, and ensure the overall health of your application. If you require assistance with implementing these practices, consider hiring Laravel development experts. Their expertise can ensure your logging infrastructure is tailored to your specific needs.\n\nLaravel’s logging system empowers you to gain deep insights into your application’s inner workings. By understanding how to configure logging channels, leverage log levels, and incorporate best practices, you can establish a robust logging infrastructure. This will equip you to troubleshoot issues, optimize application performance, and ensure its overall health.\n\nWith a well-structured logging setup, you can identify and resolve problems faster, leading to a more stable and user-friendly application. Furthermore, advanced techniques like structured logging and custom channels unlock even greater potential for detailed analysis and data security.\n\nKeen to take your Laravel logging to the next level? Let our experienced Laravel development experts help you create a customized logging strategy that perfectly aligns with your application’s needs."
    },
    {
        "link": "https://stackoverflow.com/questions/74396257/best-way-to-log-every-request-response",
        "document": "I have a POST API to create a register on the database. My goal is to be able to log every 4XX request (with the response) for another team to view that list/search the data, with the option to download the request JSON sent in that call.\n\nWhat's the best way to archive that? Its just to create a logs table in the database?"
    },
    {
        "link": "https://sentinelone.com/blog/getting-started-quickly-laravel-logging",
        "document": ""
    }
]