[
    {
        "link": "https://stackoverflow.com/questions/66324426/react-lazy-loading-components-that-use-framer-motion-page-transitions",
        "document": "Looking up, down, and sideways for a solution to this problem.\n\nMy goal is to assign Lazy Loading to nearly all components in my React website. However, these components utilize framer-motion page transitions when these components enter and exit. The combination of page transitions and lazy loading is causing the component to no longer load properly when clicked on as a Route.\n\nI found inspiration from this post (https://github.com/reactjs/react-transition-group/issues/580) and tried to introduce the \"react-lazy-with-preload\" package (https://github.com/ianschmitz/react-lazy-with-preload), however I was unsuccessful in getting it to work.\n\nIs anyone aware of a solution to this issue? I surely can't be the only person trying to data split a React website which uses components that have framer-motion page transitions."
    },
    {
        "link": "https://blog.pixelfreestudio.com/how-to-use-framer-motion-for-advanced-animations-in-react",
        "document": "Animating your React applications can make them more engaging and user-friendly. Framer Motion is a powerful library that simplifies the process of adding advanced animations to your React projects. This article will walk you through everything you need to know about using Framer Motion for advanced animations, from the basics to more complex animations.\n\nFramer Motion is an open-source library that provides a simple and powerful API for creating animations in React. It’s built on top of the Framer library and uses the same principles of animation but is specifically designed for React applications. To get started with Framer Motion, you first need to install it in your React project.\n\nTo install Framer Motion, you can use npm or yarn. Run the following command in your terminal:\n\nOnce installed, you can import it into your React components and start using it to animate your elements.\n\nFramer Motion provides a component that you can use to wrap any element you want to animate. Here’s a simple example:\n\nIn this example, the element will fade in from an opacity of 0 to an opacity of 1 over the course of one second.\n\nBefore diving into more complex animations, it’s important to understand some key concepts in Framer Motion: , , , and .\n\nThe prop sets the starting state of the animation, while the prop defines the end state. These props can accept an object of styles you want to animate.\n\nIn this example, the element will slide in from the left while fading in.\n\nThe prop controls the timing and easing of the animation. You can specify the , , , and more.\n\nThis example uses a spring transition for a more natural, bouncy effect.\n\nVariants allow you to define multiple animation states and switch between them. This is useful for more complex animations.\n\nUsing variants can make your code cleaner and more manageable.\n\nWith the basics covered, let’s move on to creating more advanced animations. We’ll explore staggered animations, keyframes, and using gestures to trigger animations.\n\nStaggered animations involve animating multiple elements one after the other with a delay. This can create a cascading effect.\n\nIn this example, each child element will animate in one after the other with a delay of 0.3 seconds.\n\nKeyframes allow you to define multiple stages of an animation. This can create more complex and interesting effects.\n\nIn this example, the element will move to different positions and change opacity at each stage of the animation.\n\nFramer Motion also supports gesture-based animations, such as dragging, hovering, and tapping.\n\nThis example scales the element when hovered and tapped, and allows it to be dragged within specified constraints.\n\nNow that we have a solid grasp of the basics, let’s delve into more advanced techniques. These techniques include animating presence, using layout animations, and creating custom animations with hooks.\n\nAnimating the presence of elements, such as adding or removing elements from the DOM, can greatly enhance user experience. Framer Motion provides a component that makes this easy.\n\nIn this example, the element animates in and out of the DOM with smooth transitions, controlled by the component.\n\nLayout animations allow elements to animate their position when their layout changes. This can be particularly useful for animating lists or grids of items.\n\nIn this example, the prop is used to animate the position of the list items when they change.\n\nFramer Motion provides several hooks that allow you to create custom animations. The most commonly used hooks are and .\n\nThe hook gives you full control over your animations, allowing you to start, stop, and update animations programmatically.\n\nIn this example, the hook starts the animation when the component mounts.\n\nThe hook allows you to cycle through different animation states. This can be useful for toggling between different animations.\n\nIn this example, clicking the element will toggle between two different animation states.\n\nBy combining various animations and techniques, you can create more complex and sophisticated effects. Let’s explore a few examples.\n\nAnimating a modal window can improve the user experience by providing smooth transitions when the modal appears and disappears.\n\nIn this example, both the modal background and content animate in and out of the view, creating a smooth opening and closing effect.\n\nCreating seamless page transitions can enhance the user experience by providing visual continuity as users navigate between different views or pages.\n\nIn this example, the component is used to animate the transitions between different routes, creating a smooth page transition effect.\n\nAs you integrate animations into your React applications, it’s essential to keep performance in mind. Poorly optimized animations can lead to a sluggish user experience. Here are some tips for optimizing performance when using Framer Motion.\n\nOne of the primary ways to optimize performance is to minimize repaints and reflows. These are processes that the browser undergoes to render your animations, and they can be costly in terms of performance.\n• Use Transform Properties: CSS properties like and are GPU-accelerated and do not trigger reflows. Prefer using , , , and for your animations.\n• Avoid Layout-Triggering Properties: Avoid animating properties that trigger layout changes, such as , , , and .\n\nWhen dealing with animations that are triggered by user interactions, such as scroll or drag, it’s important to throttle the frequency of updates to avoid overwhelming the browser.\n\nIn this example, and are used to create a throttled scroll animation.\n\nWhen animating elements entering or leaving the DOM, use the component to ensure that exiting animations complete before the element is removed from the DOM.\n\nUsing ensures that the exit animation completes smoothly before the DOM updates.\n\nCombining Framer Motion with React hooks can enhance your ability to create dynamic and responsive animations.\n\nand are powerful hooks that allow you to create responsive animations based on state or input values.\n\ncreates a motion value that can be used to drive animations.\n\nIn this example, is used to create a draggable element.\n\nallows you to create derived values from a motion value. This can be used to create complex animations based on a single input.\n\nIn this example, the of the element is derived from its position, creating a dynamic scaling effect.\n\nTo wrap up our guide, let’s look at some real-world examples and best practices for using Framer Motion in production applications.\n\nResponsive navigation menus are a common use case for animations. Here’s how to create a slide-in menu using Framer Motion.\n\nIn this example, the menu slides in and out of view when the toggle button is clicked.\n\nAnimations can provide valuable feedback to users, making interactions feel more responsive and engaging.\n\nThis example uses animations to provide feedback when the button is hovered or clicked.\n• Keep Animations Subtle: Overusing animations can overwhelm users. Keep animations subtle and purposeful.\n• Ensure Accessibility: Make sure that animations do not interfere with accessibility. Provide options to disable animations for users who prefer reduced motion.\n• Test Across Devices: Test your animations across different devices and browsers to ensure they perform well everywhere.\n• Use Easing Functions: Use easing functions to create natural and smooth animations. Avoid linear animations as they can feel robotic.\n\nAdding interactivity to animations can significantly enhance user engagement. Framer Motion allows you to create interactive animations using gestures and events. Let’s explore some advanced interactive animations.\n\nParallax effects create an illusion of depth by moving background and foreground elements at different speeds. This effect can make your website more dynamic and engaging.\n\nIn this example, the background and foreground elements move at different speeds as the user scrolls, creating a parallax effect.\n\nScroll-based animations trigger changes in the UI as the user scrolls through the page. This can be used to animate elements into view or create other dynamic effects.\n\nIn this example, the scale of the element changes based on the scroll position, creating a dynamic scroll-based animation.\n\nCombining React state management with Framer Motion can create powerful interactive experiences. This allows you to animate elements based on user input or other state changes.\n\nAnimating form validation feedback can make forms more user-friendly and engaging.\n\nIn this example, validation feedback is animated, providing a smooth user experience.\n\nDynamic loading indicators can improve user experience by providing visual feedback while data is being loaded.\n\nIn this example, a loading indicator is animated in and out based on the loading state, providing clear feedback to the user.\n\nFramer Motion can significantly enhance user interactions by providing responsive and intuitive animations. Let’s explore a few more use cases where Framer Motion can be utilized effectively.\n\nAnimated tabs can make navigation between different sections of your app smoother and more engaging.\n\nIn this example, the content of the tabs is animated based on the selected tab, providing a smooth transition effect.\n\nAnimating card components can make your UI more interactive and visually appealing.\n\nIn this example, the card component animates on hover and tap, providing a responsive and engaging user experience.\n\nBest Practices for Using Framer Motion\n\nTo make the most out of Framer Motion, here are some best practices to follow:\n\nAnimations should enhance the user experience, not distract from it. Use animations to provide feedback, guide the user’s attention, or add a touch of delight. Avoid excessive or unnecessary animations.\n\nEnsure that your animations perform well across different devices and screen sizes. Test your animations on mobile, tablet, and desktop devices to ensure a smooth experience for all users.\n\nSome users may prefer reduced motion due to accessibility needs. Respect user preferences by providing options to disable or reduce animations. You can use the media query to detect these preferences.\n\nAnimations should not compromise the performance of your application. Use performant CSS properties like and , and minimize layout-triggering properties. Throttle animations triggered by user input to avoid performance bottlenecks.\n\nFramer Motion provides a wide range of features to create complex animations easily. Make use of for exit animations, and for dynamic animations, and for reusable animation states.\n\nFramer Motion is a versatile and powerful tool for adding advanced animations to your React applications. By understanding its core concepts and utilizing its features effectively, you can create engaging, responsive, and visually appealing user experiences.\n\nFrom simple fade-ins to complex interactive animations, Framer Motion provides the tools you need to bring your React projects to life. Remember to keep animations purposeful, test across devices, consider user preferences, and optimize for performance to ensure the best possible experience for your users. Start experimenting with Framer Motion today and discover how it can transform your React applications into dynamic, animated masterpieces.\n• How to Implement SSR in Nuxt.js for Vue Applications\n• How to Use Server-Side Rendering for Dynamic Content\n• How to Use SSR for Real-Time Data Updates\n• How to Optimize SEO with Server-Side Rendering\n• How to Implement SSR with Express.js and React"
    },
    {
        "link": "https://stackoverflow.com/questions/69051279/how-to-animate-on-each-state-change-using-framer-motion",
        "document": "If you just want to remount element use a prop on it, like that:\n\nCodesandbox (please provide Codesandbox with reproduction in the future)\n\nIt looks weird but it works if that is the effect that you want.\n\nFor smoother animation I would use animation controls or probably."
    },
    {
        "link": "https://kodaschool.com/blog/creaing-interactive-ui-elements-with-framer-motion",
        "document": "Have you ever wondered how apps make those delightful transitions that instantly capture your attention? Whether it’s buttons gliding across the screen or elements fading in as you scroll, animations make interfaces engaging. With Framer Motion, you can easily add stunning interactions to your React apps without being an animation expert.\n\n\n\nIn this guide, we’ll walk you through creating eye-catching animations, from simple transitions to complex gestures.\n\nBy the end of this guide, you will:\n• Understand the Basics of Framer Motion: Learn about key concepts such as the component, animation properties, and variants.\n• Implement Advanced Animation Techniques: Use animation controls and gesture animations to enhance user interactions.\n• Optimize Performance and Accessibility: Learn best practices for performance optimization and accessibility considerations.\n• Integrate Error Handling and Loading States: Use and to handle loading and error states gracefully.\n\nFramer Motion is a popular open-source animation library from Framer for React that allows developers to manipulate DOM elements e.g enables them create and manage complex animations and transitions within apps.It's an excellent alternative to making complex CSS or Javascript animations.\n\nGestures: Describes adding interactivity with gestures like drag, hover, and tap, which can trigger animations.\n\n\n\nVariants: Introduces reusable animation states with variants, a powerful tool for applying animations to multiple elements.\n\n\n\nInitial and Animate States: Focuses on how animations are defined through initial and animate props, directly targeting the animation states.\n\n\n\nLayout Animations: Discusses seamless animations during layout changes, providing an advanced concept for dynamic UIs.\n\n\n\nTransitions: Explains the ability to control timing and easing of animations using the transition prop.\n\nThe motion component encapsulates elements in components, eg div, li, h1, ul,button ,p allowing you to animate them using initial and animate props.\n• : How the animation plays out\n\nInitial State: The initial prop defines the starting point of the animation. In this case, the motion.div will start with an opacity of 0 (completely invisible) when it first appears.\n\nAnimation State: The animate prop defines the final state the element will animate to. Here, the motion.div will transition from its initial state (opacity 0) to an opacity of 1 (fully visible).\n\nExit Animation: The exit prop defines how the element will animate out when it’s removed from the DOM. In this case, when the motion.div is unmounted, it will fade out (go back to opacity 0).\n\nTransition Duration: This controls how long the animation takes to complete. The transition prop here specifies that the animation will last 2.3 seconds, whether it's fading in or fading out.\n\nAnimatePresence allows components to animate out when they're removed from the React tree/DOM.\n\nIt works hand in hand with the motion components\n\nvariants define a set of animation states that can be reused across multiple components. Each component has its own animation behavior, and these behaviors are controlled by the initial, animate, and interaction-based properties like whileHover and whileTap.\n\n\n\n\n\nThe A form (motion.div) that fades in from below.\n\n\n\nPurpose: This defines the animation states for the form as a whole.\n\n\n\nHidden State:\n\n\n\n makes the form invisible at first.\n\n shifts the form 50 pixels down, so it starts out off-screen.\n\nVisible State:\n\n\n\n fades the form in, making it fully visible.\n\n moves the form back to its original position, making it appear from below.\n\ntransition:\n\n This controls the time it takes for the animation to complete (0.6 seconds).\n\n This delays the animation of child elements (like input fields) by 0.1 seconds, creating a smooth cascading effect.\n\nThis motion.div will fade in and move up from its starting point when the component is rendered. It will animate over 0.6 seconds, and the children (input fields) will animate in a staggered manner thanks to the staggerChildren property.\n\n\n\nGestures allow you to add interactive animations that respond to user input, like hovering, tapping, dragging, and scrolling.\n\nThis property triggers animations when the user hovers over an element.\n\nThis is commonly provides feedback, like enlarging a button or changing its appearance when a user hovers over it.\n\n~Behavior: The element scales up (enlarges) to 1.1 times its original size when the user hovers\n\nThe property triggers an animation when the user taps or clicks on an element.\n\n~Behavior: The element shrinks (scales down to 0.9) when the user taps or clicks on it, simulating a pressed state.\n\n\n\nscroll-based animations, allows you to animate elements when they come into view as you scroll.\n\n~Behavior: The element fades in as the user scrolls it into view,\n\nYou can easily combine multiple gestures in a single component to create rich interactivity.The button enlarges and changes its background color when hovered and shrinks slightly when clicked\n\nIn the code below we are creating a react hoook named that exposes the conttrols and start\n\nThis hook allows for control animations programmatically e.g creating animation controls that can be used to manually start/stop animations on one or more components,\n\nIt's the control object returned by useAnimationControls\n\nThis function defines the shake animation. It uses the method to start the animation with the specified properties.\n\nThe ternary operator conditionally set the animate\n\nproperty based on the state. If the state is true, it applies a shaking animation to the property, indicating an error.\n\nOtherwise, it sets the to 1 and to 0, ensuring the element is fully visible and stationary, thus enhanced errors indication.\n\nFind the images assets folder of this repo\n\nThe code acts as a fallback ui for any erros within the react-tree.\n\nIn the 'App' component we use Framer Motion to animate the opacity of the content, React Router to handle navigation, Suspense to provide a loading fallback, and ErrorBoundary to catch and handle errors.\n\nShake Animation: Provides a shaking effect when an error occurs during form submission.\n\nHover & Tap Animations: Input fields and the button respond to user actions, growing slightly on hover and shrinking on tap, making interactions feel responsive and dynamic.\n\nMotion.div for Error: Uses Framer Motion to animate the form's appearance and position, improving the overall experience when elements are shown or hidden.\n\nAdd the directives for each of Tailwind’s layers to your input CSS file\n\nHere is our final output\n\nIn this guide, we successfully managed to create a very responsive form and also make the best of signup forms with the help of Framer motion\n\nfeel free to contribute to this repo\n\nHere is the live app https://framer-get-started.vercel.app/ try it now"
    },
    {
        "link": "https://motion.dev/docs/react-transitions",
        "document": "A defines the type of animation used when animating between two values.\n\ncan be set on any animation prop, and that transition will be used when the animation fires.\n\nWhen animating multiple values, each value can be animated with a different transition, with handling all other values:\n\nIt's possible to set default transitions via the prop. Either for specific components:\n\nOr for a group of components via :\n\ndecides the type of animation to use. It can be , or .\n\nTween animations are set with a duration and an easing curve.\n\nSpring animations are either physics-based or duration-based.\n\nPhysics-based spring animations are set via , and , and these incorporate the velocity of any existing gestures or animations for natural feedback.\n\nDuration-based spring animations are set via a and . These don't incorporate velocity but are easier to understand.\n\nInertia animations decelerate a value based on its initial velocity, usually used to implement inertial scrolling.\n\nDefault: (or if multiple keyframes are defined)\n\nThe duration of the animation. Can also be used for animations when is also set.\n\nThe easing function to use with tween animations. Accepts:\n• None An array of four numbers to define a cubic bezier curve. E.g\n• None A JavaScript easing function , that accepts and returns a value - .\n\nThese are the available easing function names:\n\nWhen animating keyframes, can optionally be set as an array of easing functions to set different easings between each value:\n\nWhen animating multiple keyframes, can be used to adjust the position of each keyframe throughout the animation.\n\nEach value in is a value between and , representing the start and end of the animation.\n\nThere must be the same number of as there are keyframes. Defaults to an array of evenly-spread durations.\n\nis no bounce, and is extremely bouncy.\n\nNote: and will be overridden if , or are set.\n\nIf is set, this will override .\n\nThe visual duration is a time, set in seconds, that the animation will take to visually appear to reach its target.\n\nIn other words, the bulk of the transition will occur before this time, and the \"bouncy bit\" will mostly happen after.\n\nThis makes it easier to edit a spring, as well as visually coordinate it with other time-based animations.\n\nStrength of opposing force. If set to 0, spring will oscillate indefinitely.\n\nMass of the moving object. Higher values will result in more lethargic movement.\n\nStiffness of the spring. Higher values will create more sudden movement.\n\nThe initial velocity of the spring.\n\nEnd animation if absolute speed (in units per second) drops below this value and delta is smaller than .\n\nEnd animation if distance is below this value and speed is below . When animation ends, the spring will end.\n\nAn animation that decelerates a value based on its initial velocity. Optionally, and boundaries can be defined, and inertia will snap to these with a spring animation.\n\nThis animation will automatically precalculate a target value, which can be modified with the property.\n\nThis allows you to add snap-to-grid or similar functionality.\n\nInertia is also the animation used for , and can be configured via that prop.\n\nAdjusting the time constant will change the duration of the deceleration, thereby affecting its feel.\n\nA function that receives the automatically-calculated target and returns a new one. Useful for snapping the target to a grid.\n\nMinimum constraint. If set, the value will \"bump\" against this value (or immediately spring to it if the animation starts as less than this value).\n\nMaximum constraint. If set, the value will \"bump\" against this value (or immediately snap to it, if the initial animation value exceeds this value).\n\nIf or is set, this affects the stiffness of the bounce spring. Higher values will create more sudden movement.\n\nIf or is set, this affects the damping of the bounce spring. If set to , spring will oscillate indefinitely.\n\nDelay the animation by this duration (in seconds).\n\nBy setting to a negative value, the animation will start that long into the animation. For instance to start 1 second in, can be set to - .\n\nThe number of times to repeat the transition. Set to for perpetual animation.\n\nHow to repeat the animation. This can be either:\n• None : Repeats the animation from the start.\n• None : Switches animation origin and target on each iteration.\n\nWhen repeating an animation, will set the duration of the time to wait, in seconds, between each repetition.\n\nWith variants, describes when an animation should trigger, relative to that of its children.\n• None : Children animations will play after the parent animation finishes.\n• None : Parent animations will play after the children animations finish.\n\nWith variants, setting on a parent will delay child animations by this duration (in seconds).\n\nWith variants, setting on a parent will stagger children by this duration.\n\nFor example, if is set to , the first child will delayed by seconds, the second by , the third by etc.\n\nThe calculated delay will be additional to .\n\nThe direction in which to stagger children. will stagger from the first to last child, while staggers from last to first."
    },
    {
        "link": "https://medium.com/@AustinMHood/tsparticles-in-react-js-157d10adc8a8",
        "document": "This is from my experience in many personal projects and use in production software.\n\nTSParticles uses a custom-built rendering engine so you can expect it to affect website performance similar to WebGL or Three.JS\n\nThis library can be used in many different frameworks but in this tutorial I will be using React. For more details see the official docs\n\nTSParticles is a lightweight, highly customizable particle animation library written in TypeScript. It allows you to create various particle animations and effects for the web, similar to the discontinued Particles.js library, but with a larger feature set and better performance.\n\nTSParticles supports a wide variety of particle options and interactions, including different shapes, colors, sizes, behaviors, and more. It can be used to create effects like starfields, fireworks, connecting lines, confetti, and much more. The library provides detailed configuration options for controlling every aspect of the particle behavior and appearance, and it also supports responsive designs, adjusting to different viewport sizes.\n\nHow to use TSParticles\n\nI will be using React with TypeScript so the code within this tutorial will slightly differ if you are using another framework or vanilla JavaScript. See the official docs linked above to find these differences.\n\nWe must first initialize our project and for this I will be using Next.js since it is the recommended approach from the react team.\n\nMake sure to select TypeScript in the options and the rest can be configured to your liking\n\nWe must install these dependencies because we will be using components from both.\n\nNow that we have all necessary dependencies we can begin adding the minimal code to get a clean and working component that does not bloat the rest of our code.\n\nInside your src directory create a file that will hold all of the code relevant to TSParticles. It can be named anything you like but I will be calling it particlesComponent.tsx. The reason we do this in a separate file from where you will be calling it is because of how long the options field within the component can get.\n\nOnce inside the newly created file, import all relevant packages and components.\n\nNow we create the skeleton of a React functional component. I personally use a VSCode plugin called ES7 React/Redux/GraphQL/React-Native snippets. I highly recommend this because it eliminates much of the boilerplate code you must write when creating a new component. rfce is the command to generate a react functional component but if you are not using VSCode or do not want any additional complexity the code looks like this\n\nAfter creating the skeleton we can initialize our rendering engine using a callback function. It is fine if you do not understand everything about how this function works, but it is recommended to use this function.\n\nThis function must be defined within our functional component to avoid any errors and for it to be within scope of our particles component.\n\nIn the return statement we can replace the default div with a particles component that we import from react-tsparticles\n\nWithin the particles component we now need a couple of fields, one to call the init function and one to add all of the options\n\nNow we can begin customizing our options, they must follow a specific syntax that is similar to JSON but not identical. You can configure these options however you like and can get very creative with it.\n\nHere is a link to a custom one that I created and your final code should look similar to this\n\nThere are also many resources online with templates or info to configure your own\n\nAfter all the configuration of the options are done we can finally render our particles component in a concise way.\n\nAll that must be done is to call your new component on the page you like it to be rendered on.\n\nIt is possible to change the dimensions of the container if you do not want it to take up the entire page. See this YouTube tutorial for more info"
    },
    {
        "link": "https://legacy.reactjs.org/docs/optimizing-performance.html",
        "document": "Internally, React uses several clever techniques to minimize the number of costly DOM operations required to update the UI. For many applications, using React will lead to a fast user interface without doing much work to specifically optimize for performance. Nevertheless, there are several ways you can speed up your React application.\n\nIf you’re benchmarking or experiencing performance problems in your React apps, make sure you’re testing with the minified production build.\n\nBy default, React includes many helpful warnings. These warnings are very useful in development. However, they make React larger and slower so you should make sure to use the production version when you deploy the app.\n\nIf you aren’t sure whether your build process is set up correctly, you can check it by installing React Developer Tools for Chrome. If you visit a site with React in production mode, the icon will have a dark background:\n\nIf you visit a site with React in development mode, the icon will have a red background:\n\nIt is expected that you use the development mode when working on your app, and the production mode when deploying your app to the users.\n\nYou can find instructions for building your app for production below.\n\nIf your project is built with Create React App, run:\n\nThis will create a production build of your app in the folder of your project.\n\nRemember that this is only necessary before deploying to production. For normal development, use .\n\nWe offer production-ready versions of React and React DOM as single files:\n\nRemember that only React files ending with are suitable for production.\n\nFor the most efficient Brunch production build, install the plugin:\n\nThen, to create a production build, add the flag to the command:\n\nRemember that you only need to do this for production builds. You shouldn’t pass the flag or apply this plugin in development, because it will hide useful React warnings and make the builds much slower.\n\nFor the most efficient Browserify production build, install a few plugins:\n\nTo create a production build, make sure that you add these transforms (the order matters):\n• The transform ensures the right build environment is set. Make it global ( ).\n• The transform removes development imports. Make it global too ( ).\n• Finally, the resulting bundle is piped to for mangling (read why).\n\nRemember that you only need to do this for production builds. You shouldn’t apply these plugins in development because they will hide useful React warnings, and make the builds much slower.\n\nFor the most efficient Rollup production build, install a few plugins:\n\nTo create a production build, make sure that you add these plugins (the order matters):\n• The plugin ensures the right build environment is set.\n• The plugin provides support for CommonJS in Rollup.\n• The plugin compresses and mangles the final bundle.\n\nFor a complete setup example see this gist.\n\nRemember that you only need to do this for production builds. You shouldn’t apply the plugin or the plugin with value in development because they will hide useful React warnings, and make the builds much slower.\n\nWebpack v4+ will minify your code by default in production mode.\n\nYou can learn more about this in webpack documentation.\n\nRemember that you only need to do this for production builds. You shouldn’t apply in development because it will hide useful React warnings, and make the builds much slower.\n\n16.5+ and 0.57+ provide enhanced profiling capabilities in DEV mode with the React DevTools Profiler. An overview of the Profiler can be found in the blog post “Introducing the React Profiler”. A video walkthrough of the profiler is also available on YouTube.\n\nIf you haven’t yet installed the React DevTools, you can find them here:\n\nIf your application renders long lists of data (hundreds or thousands of rows), we recommend using a technique known as “windowing”. This technique only renders a small subset of your rows at any given time, and can dramatically reduce the time it takes to re-render the components as well as the number of DOM nodes created.\n\nreact-window and react-virtualized are popular windowing libraries. They provide several reusable components for displaying lists, grids, and tabular data. You can also create your own windowing component, like Twitter did, if you want something more tailored to your application’s specific use case.\n\nReact builds and maintains an internal representation of the rendered UI. It includes the React elements you return from your components. This representation lets React avoid creating DOM nodes and accessing existing ones beyond necessity, as that can be slower than operations on JavaScript objects. Sometimes it is referred to as a “virtual DOM”, but it works the same way on React Native.\n\nWhen a component’s props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM.\n\nEven though React only updates the changed DOM nodes, re-rendering still takes some time. In many cases it’s not a problem, but if the slowdown is noticeable, you can speed all of this up by overriding the lifecycle function , which is triggered before the re-rendering process starts. The default implementation of this function returns , leaving React to perform the update:\n\nIf you know that in some situations your component doesn’t need to update, you can return from instead, to skip the whole rendering process, including calling on this component and below.\n\nIn most cases, instead of writing by hand, you can inherit from . It is equivalent to implementing with a shallow comparison of current and previous props and state.\n\nHere’s a subtree of components. For each one, indicates what returned, and indicates whether the rendered React elements were equivalent. Finally, the circle’s color indicates whether the component had to be reconciled or not.\n\nSince returned for the subtree rooted at C2, React did not attempt to render C2, and thus didn’t even have to invoke on C4 and C5.\n\nFor C1 and C3, returned , so React had to go down to the leaves and check them. For C6 returned , and since the rendered elements weren’t equivalent React had to update the DOM.\n\nThe last interesting case is C8. React had to render this component, but since the React elements it returned were equal to the previously rendered ones, it didn’t have to update the DOM.\n\nNote that React only had to do DOM mutations for C6, which was inevitable. For C8, it bailed out by comparing the rendered React elements, and for C2’s subtree and C7, it didn’t even have to compare the elements as we bailed out on , and was not called.\n\nIf the only way your component ever changes is when the or the variable changes, you could have check that:\n\nIn this code, is just checking if there is any change in or . If those values don’t change, the component doesn’t update. If your component got more complex, you could use a similar pattern of doing a “shallow comparison” between all the fields of and to determine if the component should update. This pattern is common enough that React provides a helper to use this logic - just inherit from . So this code is a simpler way to achieve the same thing:\n\nMost of the time, you can use instead of writing your own . It only does a shallow comparison, so you can’t use it if the props or state may have been mutated in a way that a shallow comparison would miss.\n\nThis can be a problem with more complex data structures. For example, let’s say you want a component to render a comma-separated list of words, with a parent component that lets you click a button to add a word to the list. This code does not work correctly:\n\nThe problem is that will do a simple comparison between the old and new values of . Since this code mutates the array in the method of , the old and new values of will compare as equal, even though the actual words in the array have changed. The will thus not update even though it has new words that should be rendered.\n\nThe Power Of Not Mutating Data\n\nThe simplest way to avoid this problem is to avoid mutating values that you are using as props or state. For example, the method above could be rewritten using as:\n\nES6 supports a spread syntax for arrays which can make this easier. If you’re using Create React App, this syntax is available by default.\n\nYou can also rewrite code that mutates objects to avoid mutation, in a similar way. For example, let’s say we have an object named and we want to write a function that changes to be . We could write:\n\nTo write this without mutating the original object, we can use Object.assign method:\n\nnow returns a new object, rather than mutating the old one. is in ES6 and requires a polyfill.\n\nObject spread syntax makes it easier to update objects without mutation as well:\n\nThis feature was added to JavaScript in ES2018.\n\nIf you’re using Create React App, both and the object spread syntax are available by default.\n\nWhen you deal with deeply nested objects, updating them in an immutable way can feel convoluted. If you run into this problem, check out Immer or immutability-helper. These libraries let you write highly readable code without losing the benefits of immutability."
    },
    {
        "link": "https://github.com/tsparticles/react",
        "document": ""
    },
    {
        "link": "https://particles.js.org/docs",
        "document": "A lightweight TypeScript library for creating particles. Dependency free (*), browser ready and compatible with React.js, Vue.js (2.x and 3.x), Angular, Svelte, jQuery, Preact, Inferno, Riot.js, Solid.js, and Web Components\n\n⚠️⚠️ _This readme refers to v2 version, read here for v1 documentation* ⚠️⚠️\n• tsParticles - TypeScript Particles\n• Do you want to use it on your website?\n• Official components for some of the most used frameworks\n• Want to see it in action and try it?\n• Dependency Graphs\n• Huge thanks to JetBrains for the 2020-2022 Open Source Licenses!\n\nDo you want to use it on your website?\n\nThis library is available on two of the most popular CDNs and it's easy and ready to use, if you were using particles.js it's even easier.\n\nYou'll find the instructions below, with all the links you need, and don't be scared by TypeScript, it's just the source language.\n\nThe output files are just JavaScript. 🤩\n\nCDNs and have all the sources you need in Javascript, a bundle browser ready (tsparticles.engine.min.js), and all files splitted for syntax.\n\nIf you are interested there are some simple instructions just below to guide you to migrate from the old particles.js library.\n\nPlease use these hosts or your own to load tsParticles on your projects\n\nThe imported is the same instance you have when including the script in the page using the tag.\n\nOfficial components for some of the most used frameworks\n\nYou can find the instructions here\n\nYou can find the instructions here\n\nYou can find the instructions here\n\nThe plugin page hosted on WordPress.org can be found here\n\nActually, an official tsParticles plugin isn't existing, but I have a collaboration with the plugin collection.\n\nThere are some presets ready to be used in this repository, and they also have a bundle file that contains everything needed to run.\n\nYou can find the instructions here\n\nThis preset loads colored bubbles coming from the bottom of the screen on a white background.\n\nYou can find the instructions here\n\nThis preset loads white and red confetti launched from the screen center on a transparent background.\n\nYou can find the instructions here\n\nThis preset loads a faded red to a black background with particles colored like fire and ash sparks.\n\nYou can find the instructions here\n\nThis preset loads a mouse trail made with small fading particles like little fireflies.\n\nYou can find the instructions here\n\nYou can find the instructions here\n\nYou can find the instructions here\n\nYou can find the instructions here\n\nYou can find the instructions here\n\nYou can find the instructions here\n\nYou can find the instructions here\n\nYou can find the instructions here\n\nYou can find some tsParticles related templates here. The templates are created for Vanilla Javascript, ReactJS, VueJS, Angular, SvelteJS, and other frameworks.\n\nThe templates will vary, new ones can be created or older ones updated with the latest features or changed to a better style. Check them out once in a while.\n\nIf you created some good design with tsParticles feel free to submit a pull request with your cool template, you'll be credited as the template author!\n\nYou can find all video tutorials on the website here: https://particles.js.org/video.html\n\nMore videos are coming soon! Check every day if there are some new contents.\n\nYou can find some config samples here 📖\n\nYou can find all options available here 📖\n\nWant to see it in action and try it?\n\nI've created a tsParticles collection on CodePen 😮 or you can check out my profile\n\nOtherwise, there's the demo page link below.\n\nWant to see even more demos? Clone the repository on your computer and follow these instructions\n\nBoom! 💥 http://localhost:3000 and you can check out other demos.\n\nIf you are brave enough you can switch to the branch for trying the features under development.\n\ntsParticles has a package that makes this library 100% compatible with the particles.js configuration.\n\nSeriously, you just need to change the script from particles.js to the bundled compatibility package, et-voilà, you're ready 🧙!\n\nYou can read more here\n\nWant to know 5 reasons to do the switch? Read here\n\nBelow you can find all the information you need to install tsParticles and its new syntax.\n\nYou can create your own plugins\n\nHuge thanks to JetBrains for the 2020-2022 Open Source Licenses!\n\nJetBrains WebStorm is used to maintain this project."
    },
    {
        "link": "https://gcampbell391.medium.com/a-tsparticle-article-9cd8a7ca263d",
        "document": "Today I’m going to write an article about an amazing Javascript library I recently discovered called tsParticles. This library allows you easily implement “floating particles” to your web application, and it comes with so many different customizable options. This is one of those libraries that will make your jaw drop as a developer with how easy it is to implement. Not to mention how cool it looks! I would like to demonstrate how to set up a React app with tsParticles, and then explain some of the customizable options for y’all to see. Feel free to check out the official documentation here at any time. If you check out the homepage you will notice different documentations for a couple different JavaScript frameworks such as React, Vue, and Angular. I’m going to build a React app, so we will focus on that. I’m not going to get into every customizable option available as I’m going to simply break the ice.\n\nFirst and foremost, let’s create a react app. I’m going to name my app “particle-example”. Once the app is created, I will open it. I’m going to open the App.js file and delete everything inside of the div tag in the return. I’m also going to create a new js file called Home.js. Normally, I would create a folder called components to place the new component js file into, but I’m going to skip that step as this will be the only js file/component I will create. I will make the Home.js a functional component and then import the component into my App.js file. Below is a screenshot of my Home.js\n\nAnd here is a screenshot of my App.js where I imported the Home.js\n\nWith all of that currently set up, my browser looks like the screenshot below when my server is running.\n\nNow we can install our JavaScript library for tsParticles and add some particles! I will enter the following command into my terminal.\n\nYou can also check out the documentation specifically for React here. After that command finishes running, we can start our server back up. Then we will go back to our Home.js to add the import and the Particles tag. After doing just such, my Home.js looks like the screenshots below.\n\nI know it may look like a lot, but it isn’t bad once you break it down. I only added one tag, Particles, to the div tag that already contained the header. There are a couple examples you can copy and mess with from the documentation to get a better understanding as well. Once saved, my browser looks like the screenshot below.\n\nPretty sweet right?! That is it! I would like to break down some of options I used here to provide a better explanation. As always you can always check out the official documentation for all the customizable options here."
    }
]