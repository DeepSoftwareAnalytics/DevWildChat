[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
        "document": "objects cannot use arbitrary strings as element indexes (as in an associative array) but must use nonnegative integers (or their respective string form). Setting or accessing via non-integers will not set or retrieve an element from the array list itself, but will set or access a variable associated with that array's object property collection. The array's object properties and list of array elements are separate, and the array's traversal and mutation operations cannot be applied to these named properties. Array elements are object properties in the same way that is a property (to be specific, however, is a method). Nevertheless, trying to access an element of an array as follows throws a syntax error because the property name is not valid: JavaScript syntax requires properties beginning with a digit to be accessed using bracket notation instead of dot notation. It's also possible to quote the array indices (e.g., instead of ), although usually not necessary. The in is coerced into a string by the JavaScript engine through an implicit conversion. As a result, and would refer to two different slots on the object, and the following example could be : Only is an actual array index. is an arbitrary string property that will not be visited in array iteration.\n\nMany array methods take a callback function as an argument. The callback function is called sequentially and at most once for each element in the array, and the return value of the callback function is used to determine the return value of the method. They all share the same signature: The current element being processed in the array. The index of the current element being processed in the array. The array that the method was called upon. What is expected to return depends on the array method that was called. The argument (defaults to ) will be used as the value when calling . The value ultimately observable by is determined according to the usual rules: if is non-strict, primitive values are wrapped into objects, and / is substituted with . The argument is irrelevant for any defined with an arrow function, as arrow functions don't have their own binding. The argument passed to is most useful if you want to read another index during iteration, because you may not always have an existing variable that refers to the current array. You should generally not mutate the array during iteration (see mutating initial array in iterative methods), but you can also use this argument to do so. The argument is not the array that is being built, in the case of methods like , , and — there is no way to access the array being built from the callback function. All iterative methods are copying and generic, although they behave differently with empty slots. The following methods are iterative: , , , , , , , , , and . In particular, , , , , , and do not always invoke on every element — they stop iteration as soon as the return value is determined. The and methods also take a callback function and run it at most once for each element in the array, but they have slightly different signatures from typical iterative methods (for example, they don't accept ). The method also takes a callback function, but it is not an iterative method. It mutates the array in-place, doesn't accept , and may invoke the callback multiple times on an index. Iterative methods iterate the array like the following (with a lot of technical details omitted): function method(callbackFn, thisArg) { const length = this.length; for (let i = 0; i < length; i++) { if (i in this) { const result = callbackFn.call(thisArg, this[i], i, this); // Do something with result; maybe return early } } }\n• Not all methods do the test. The , , , and methods do not, but other methods do.\n• The is memorized before the loop starts. This affects how insertions and deletions during iteration are handled (see mutating initial array in iterative methods).\n• The method doesn't memorize the array contents, so if any index is modified during iteration, the new value might be observed.\n• The code above iterates the array in ascending order of index. Some methods iterate in descending order of index ( ): , , and .\n• and have slightly different signatures and do not always start at the first/last element.\n\nArray methods are always generic — they don't access any internal data of the array object. They only access the array elements through the property and the indexed elements. This means that they can be called on array-like objects as well. The property is converted to an integer and then clamped to the range between 0 and 253 - 1. becomes , so even when is not present or is , it behaves as if it has value . The language avoids setting to an unsafe integer. All built-in methods will throw a if will be set to a number greater than 253 - 1. However, because the property of arrays throws an error if it's set to greater than 232 - 1, the safe integer threshold is usually not reached unless the method is called on a non-array object. Some array methods set the property of the array object. They always set the value after normalization, so always ends as an integer. The term array-like object refers to any object that doesn't throw during the conversion process described above. In practice, such object is expected to actually have a property and to have indexed elements in the range to . (If it doesn't have all indices, it will be functionally equivalent to a sparse array.) Any integer index less than zero or greater than is ignored when an array method operates on an array-like object. Many DOM objects are array-like — for example, and . The object is also array-like. You can call array methods on them even if they don't have these methods themselves.\n\nReturns the array item at the given index. Accepts negative integers, which count back from the last item. Returns a new array that is the calling array joined with other array(s) and/or value(s). Copies a sequence of array elements within an array. Returns a new array iterator object that contains the key/value pairs for each index in an array. Returns if every element in the calling array satisfies the testing function. Fills all the elements of an array from a start index to an end index with a static value. Returns a new array containing all elements of the calling array for which the provided filtering function returns . Returns the value of the first element in the array that satisfies the provided testing function, or if no appropriate element is found. Returns the index of the first element in the array that satisfies the provided testing function, or if no appropriate element was found. Returns the value of the last element in the array that satisfies the provided testing function, or if no appropriate element is found. Returns the index of the last element in the array that satisfies the provided testing function, or if no appropriate element was found. Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth. Returns a new array formed by applying a given callback function to each element of the calling array, and then flattening the result by one level. Calls a function for each element in the calling array. Determines whether the calling array contains a value, returning or as appropriate. Returns the first (least) index at which a given element can be found in the calling array. Joins all elements of an array into a string. Returns a new array iterator that contains the keys for each index in the calling array. Returns the last (greatest) index at which a given element can be found in the calling array, or if none is found. Returns a new array containing the results of invoking a function on every element in the calling array. Removes the last element from an array and returns that element. Adds one or more elements to the end of an array, and returns the new of the array. Executes a user-supplied \"reducer\" callback function on each element of the array (from left to right), to reduce it to a single value. Executes a user-supplied \"reducer\" callback function on each element of the array (from right to left), to reduce it to a single value. Reverses the order of the elements of an array in place. (First becomes the last, last becomes first.) Removes the first element from an array and returns that element. Extracts a section of the calling array and returns a new array. Returns if at least one element in the calling array satisfies the provided testing function. Sorts the elements of an array in place and returns the array. Returns a localized string representing the calling array and its elements. Overrides the method. Returns a new array with the elements in reversed order, without modifying the original array. Returns a new array with the elements sorted in ascending order, without modifying the original array. Returns a new array with some elements removed and/or replaced at a given index, without modifying the original array. Returns a string representing the calling array and its elements. Overrides the method. Adds one or more elements to the front of an array, and returns the new of the array. Returns a new array iterator object that contains the values for each index in the array. Returns a new array with the element at the given index replaced with the given value, without modifying the original array. An alias for the method by default.\n\nIterative methods do not mutate the array on which it is called, but the function provided as can. The key principle to remember is that only indexes between 0 and are visited, where is the length of the array at the time the array method was first called, but the element passed to the callback is the value at the time the index is visited. Therefore:\n• will not visit any elements added beyond the array's initial length when the call to the iterative method began.\n• Changes to already-visited indexes do not cause to be invoked on them again.\n• If an existing, yet-unvisited element of the array is changed by , its value passed to the will be the value at the time that element gets visited. Removed elements are not visited. Warning: Concurrent modifications of the kind described above frequently lead to hard-to-understand code and are generally to be avoided (except in special cases). The following examples use the method as an example, but other methods that visit indexes in ascending order work in the same way. We will first define a helper function: Modification to indexes not visited yet will be visible once the index is reached: Modification to already visited indexes does not change iteration behavior, although the array will be different afterwards: Inserting n elements at unvisited indexes that are less than the initial array length will make them be visited. The last n elements in the original array that now have index greater than the initial array length will not be visited: testSideEffect((arr, index) => { if (index === 1) arr.splice(2, 0, \"new\"); }); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e1, e2, e3, e4], index: 1, elem: e2 // array: [e1, e2, new, e3, e4], index: 2, elem: new // array: [e1, e2, new, e3, e4], index: 3, elem: e3 // Final array: [e1, e2, new, e3, e4] // e4 is not visited because it now has index 4 Inserting n elements with index greater than the initial array length will not make them be visited: testSideEffect((arr) => arr.push(\"new\")); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e1, e2, e3, e4, new], index: 1, elem: e2 // array: [e1, e2, e3, e4, new, new], index: 2, elem: e3 // array: [e1, e2, e3, e4, new, new, new], index: 3, elem: e4 // Final array: [e1, e2, e3, e4, new, new, new, new] Inserting n elements at already visited indexes will not make them be visited, but it shifts remaining elements back by n, so the current index and the n - 1 elements before it are visited again: testSideEffect((arr, index) => arr.splice(index, 0, \"new\")); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [new, e1, e2, e3, e4], index: 1, elem: e1 // array: [new, new, e1, e2, e3, e4], index: 2, elem: e1 // array: [new, new, new, e1, e2, e3, e4], index: 3, elem: e1 // Final array: [new, new, new, new, e1, e2, e3, e4] // e1 keeps getting visited because it keeps getting shifted back Deleting n elements at unvisited indexes will make them not be visited anymore. Because the array has shrunk, the last n iterations will visit out-of-bounds indexes. If the method ignores non-existent indexes (see array methods and empty slots), the last n iterations will be skipped; otherwise, they will receive : testSideEffect((arr, index) => { if (index === 1) arr.splice(2, 1); }); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e1, e2, e3, e4], index: 1, elem: e2 // array: [e1, e2, e4], index: 2, elem: e4 // Final array: [e1, e2, e4] // Does not visit index 3 because it's out-of-bounds // Compare this with find(), which treats nonexistent indexes as undefined: const arr2 = [\"e1\", \"e2\", \"e3\", \"e4\"]; arr2.find((elem, index, arr) => { console.log(`array: [${arr.join(\", \")}], index: ${index}, elem: ${elem}`); if (index === 1) arr.splice(2, 1); return false; }); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e1, e2, e3, e4], index: 1, elem: e2 // array: [e1, e2, e4], index: 2, elem: e4 // array: [e1, e2, e4], index: 3, elem: undefined Deleting n elements at already visited indexes does not change the fact that they were visited before they get deleted. Because the array has shrunk, the next n elements after the current index are skipped. If the method ignores non-existent indexes, the last n iterations will be skipped; otherwise, they will receive : testSideEffect((arr, index) => arr.splice(index, 1)); // array: [e1, e2, e3, e4], index: 0, elem: e1 // Does not visit e2 because e2 now has index 0, which has already been visited // array: [e2, e3, e4], index: 1, elem: e3 // Does not visit e4 because e4 now has index 1, which has already been visited // Final array: [e2, e4] // Index 2 is out-of-bounds, so it's not visited // Compare this with find(), which treats nonexistent indexes as undefined: const arr2 = [\"e1\", \"e2\", \"e3\", \"e4\"]; arr2.find((elem, index, arr) => { console.log(`array: [${arr.join(\", \")}], index: ${index}, elem: ${elem}`); arr.splice(index, 1); return false; }); // array: [e1, e2, e3, e4], index: 0, elem: e1 // array: [e2, e3, e4], index: 1, elem: e3 // array: [e2, e4], index: 2, elem: undefined // array: [e2, e4], index: 3, elem: undefined For methods that iterate in descending order of index, insertion causes elements to be skipped, and deletion causes elements to be visited multiple times. Adjust the code above yourself to see the effects."
    },
    {
        "link": "https://javascript.info/array-methods",
        "document": "Arrays provide a lot of methods. To make things easier, in this chapter, they are split into groups.\n\nWe already know methods that add and remove items from the beginning or the end:\n• – extracts an item from the end,\n• – extracts an item from the beginning,\n\nHere are a few others.\n\nHow to delete an element from the array?\n\nThe arrays are objects, so we can try to use :\n\nThe element was removed, but the array still has 3 elements, we can see that .\n\nThat’s natural, because removes a value by the . It’s all it does. Fine for objects. But for arrays we usually want the rest of the elements to shift and occupy the freed place. We expect to have a shorter array now.\n\nSo, special methods should be used.\n\nThe arr.splice method is a Swiss army knife for arrays. It can do everything: insert, remove and replace elements.\n\nIt modifies starting from the index : removes elements and then inserts at their place. Returns the array of removed elements.\n\nThis method is easy to grasp by examples.\n\nEasy, right? Starting from the index it removed element.\n\nIn the next example, we remove 3 elements and replace them with the other two:\n\nHere we can see that returns the array of removed elements:\n\nThe method is also able to insert the elements without any removals. For that, we need to set to :\n\nThe method arr.slice is much simpler than the similar-looking .\n\nIt returns a new array copying to it all items from index to (not including ). Both and can be negative, in that case position from array end is assumed.\n\nIt’s similar to a string method , but instead of substrings, it makes subarrays.\n\nWe can also call it without arguments: creates a copy of . That’s often used to obtain a copy for further transformations that should not affect the original array.\n\nThe method arr.concat creates a new array that includes values from other arrays and additional items.\n\nIt accepts any number of arguments – either arrays or values.\n\nThe result is a new array containing items from , then , etc.\n\nIf an argument is an array, then all its elements are copied. Otherwise, the argument itself is copied.\n\nNormally, it only copies elements from arrays. Other objects, even if they look like arrays, are added as a whole:\n\n…But if an array-like object has a special property, then it’s treated as an array by : its elements are added instead:\n\nThe arr.forEach method allows to run a function for every element of the array.\n\nFor instance, this shows each element of the array:\n\nAnd this code is more elaborate about their positions in the target array:\n\nThe result of the function (if it returns any) is thrown away and ignored.\n\nNow let’s cover methods that search in an array.\n\nThe methods arr.indexOf and arr.includes have the similar syntax and do essentially the same as their string counterparts, but operate on items instead of characters:\n• – looks for starting from index , and returns the index where it was found, otherwise .\n• – looks for starting from index , returns if found.\n\nUsually, these methods are used with only one argument: the to search. By default, the search is from the beginning.\n\nPlease note that uses the strict equality for comparison. So, if we look for , it finds exactly and not the zero.\n\nIf we want to check if exists in the array and don’t need the index, then is preferred.\n\nThe method arr.lastIndexOf is the same as , but looks for from right to left.\n\nImagine we have an array of objects. How do we find an object with a specific condition?\n\nHere the arr.find(fn) method comes in handy.\n\nThe function is called for elements of the array, one after another:\n• is the array itself.\n\nIf it returns , the search is stopped, the is returned. If nothing is found, is returned.\n\nFor example, we have an array of users, each with the fields and . Let’s find the one with :\n\nIn real life, arrays of objects are a common thing, so the method is very useful.\n\nNote that in the example we provide to the function with one argument. That’s typical, other arguments of this function are rarely used.\n\nThe arr.findIndex method has the same syntax but returns the index where the element was found instead of the element itself. The value of is returned if nothing is found.\n\nThe arr.findLastIndex method is like , but searches from right to left, similar to .\n\nThe method looks for a single (first) element that makes the function return .\n\nIf there may be many, we can use arr.filter(fn).\n\nThe syntax is similar to , but returns an array of all matching elements:\n\nLet’s move on to methods that transform and reorder an array.\n\nThe arr.map method is one of the most useful and often used.\n\nIt calls the function for each element of the array and returns the array of results.\n\nFor instance, here we transform each element into its length:\n\nThe call to arr.sort() sorts the array in place, changing its element order.\n\nIt also returns the sorted array, but the returned value is usually ignored, as itself is modified.\n\nDid you notice anything strange in the outcome?\n\nThe order became . Incorrect. But why?\n\nThe items are sorted as strings by default.\n\nLiterally, all elements are converted to strings for comparisons. For strings, lexicographic ordering is applied and indeed .\n\nTo use our own sorting order, we need to supply a function as the argument of .\n\nThe function should compare two arbitrary values and return:\n\nFor instance, to sort as numbers:\n\nNow it works as intended.\n\nLet’s step aside and think about what’s happening. The can be an array of anything, right? It may contain numbers or strings or objects or whatever. We have a set of some items. To sort it, we need an ordering function that knows how to compare its elements. The default is a string order.\n\nThe method implements a generic sorting algorithm. We don’t need to care how it internally works (an optimized quicksort or Timsort most of the time). It will walk the array, compare its elements using the provided function and reorder them, all we need is to provide the which does the comparison.\n\nBy the way, if we ever want to know which elements are compared – nothing prevents us from alerting them:\n\nThe algorithm may compare an element with multiple others in the process, but it tries to make as few comparisons as possible.\n\nThe method arr.reverse reverses the order of elements in .\n\nIt also returns the array after the reversal.\n\nHere’s the situation from real life. We are writing a messaging app, and the person enters the comma-delimited list of receivers: . But for us an array of names would be much more comfortable than a single string. How to get it?\n\nThe str.split(delim) method does exactly that. It splits the string into an array by the given delimiter .\n\nIn the example below, we split by a comma followed by a space:\n\nThe method has an optional second numeric argument – a limit on the array length. If it is provided, then the extra elements are ignored. In practice it is rarely used though:\n\nThe call arr.join(glue) does the reverse to . It creates a string of items joined by between them.\n\nWhen we need to iterate over an array – we can use , or .\n\nWhen we need to iterate and return the data for each element – we can use .\n\nThe methods arr.reduce and arr.reduceRight also belong to that breed, but are a little bit more intricate. They are used to calculate a single value based on the array.\n\nThe function is applied to all array elements one after another and “carries on” its result to the next call.\n• – is the result of the previous function call, equals the first time (if is provided).\n\nAs the function is applied, the result of the previous function call is passed to the next one as the first argument.\n\nSo, the first argument is essentially the accumulator that stores the combined result of all previous executions. And at the end, it becomes the result of .\n\nThe easiest way to grasp that is by example.\n\nHere we get a sum of an array in one line:\n\nThe function passed to uses only 2 arguments, that’s typically enough.\n\nLet’s see the details of what’s going on.\n• On the first run, is the value (the last argument of ), equals , and is the first array element, equals . So the function result is .\n• On the second run, , we add the second array element ( ) to it and return.\n• On the 3rd run, and we add one more element to it, and so on…\n\nOr in the form of a table, where each row represents a function call on the next array element:\n\nHere we can clearly see how the result of the previous call becomes the first argument of the next one.\n\nWe also can omit the initial value:\n\nThe result is the same. That’s because if there’s no initial, then takes the first element of the array as the initial value and starts the iteration from the 2nd element.\n\nThe calculation table is the same as above, minus the first row.\n\nBut such use requires an extreme care. If the array is empty, then call without initial value gives an error.\n\nSo it’s advised to always specify the initial value.\n\nThe method arr.reduceRight does the same but goes from right to left.\n\nArrays do not form a separate language type. They are based on objects.\n\nSo does not help to distinguish a plain object from an array:\n\n…But arrays are used so often that there’s a special method for that: Array.isArray(value). It returns if the is an array, and otherwise.\n\nAlmost all array methods that call functions – like , , , with a notable exception of , accept an optional additional parameter .\n\nThat parameter is not explained in the sections above, because it’s rarely used. But for completeness, we have to cover it.\n\nHere’s the full syntax of these methods:\n\nThe value of parameter becomes for .\n\nFor example, here we use a method of object as a filter, and passes the context:\n\nIf in the example above we used , then would be called as a standalone function, with , thus leading to an instant error.\n\nA call to can be replaced with , that does the same. The latter is used more often, as it’s a bit easier to understand for most people.\n• \n• – extracts an item from the end,\n• – extracts an item from the beginning,\n• – creates a new array, copies elements from index till (not inclusive) into it.\n• – returns a new array: copies all members of the current one and adds to it. If any of is an array, then its elements are taken.\n• \n• – look for starting from position , and return the index or if not found.\n• – returns if the array has , otherwise .\n• – filter elements through the function, return first/all values that make it return .\n• is like , but returns the index instead of a value.\n• \n• – calls for every element, does not return anything.\n• \n• – creates a new array from results of calling for every element.\n• – sorts the array in-place, then returns it.\n• – reverses the array in-place, then returns it.\n• – calculate a single value over the array by calling for each element and passing an intermediate result between the calls.\n• \n• checks for being an array, if so returns , otherwise .\n\nPlease note that methods , and modify the array itself.\n\nThese methods are the most used ones, they cover 99% of use cases. But there are few others:\n• The function is called on each element of the array similar to . If any/all results are , returns , otherwise . These methods behave sort of like and operators: if returns a truthy value, immediately returns and stops iterating over the rest of items; if returns a falsy value, immediately returns and stops iterating over the rest of items as well. We can use to compare arrays:\n• arr.fill(value, start, end) – fills the array with repeating from index to .\n• arr.copyWithin(target, start, end) – copies its elements from position till position into itself, at position (overwrites existing).\n\nFor the full list, see the manual.\n\nAt first sight, it may seem that there are so many methods, quite difficult to remember. But actually, that’s much easier.\n\nLook through the cheat sheet just to be aware of them. Then solve the tasks of this chapter to practice, so that you have experience with array methods.\n\nAfterwards whenever you need to do something with an array, and you don’t know how – come here, look at the cheat sheet and find the right method. Examples will help you to write it correctly. Soon you’ll automatically remember the methods, without specific efforts from your side."
    },
    {
        "link": "https://w3schools.com/jsref/jsref_obj_array.asp",
        "document": ""
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map",
        "document": "The method is an iterative method. It calls a provided function once for each element in an array and constructs a new array from the results. Read the iterative methods section for more information about how these methods work in general. is invoked only for array indexes which have assigned values. It is not invoked for empty slots in sparse arrays. The method is generic. It only expects the value to have a property and integer-keyed properties. Since builds a new array, calling it without using the returned array is an anti-pattern; use or instead.\n\nIt is common to use the callback with one argument (the element being traversed). Certain functions are also commonly used with one argument, even though they take additional optional arguments. These habits may lead to confusing behaviors. Consider: While one might expect , the actual result is . is often used with one argument, but takes two. The first is an expression and the second is the radix to the callback function, passes 3 arguments: the element, the index, and the array. The third argument is ignored by — but not the second one! This is the source of possible confusion. Here is a concise example of the iteration steps: /* first iteration (index is 0): */ parseInt(\"1\", 0); // 1 /* second iteration (index is 1): */ parseInt(\"2\", 1); // NaN /* third iteration (index is 2): */ parseInt(\"3\", 2); // NaN To solve this, define another function that only takes one argument: You can also use the function, which only takes one argument: [\"1\", \"2\", \"3\"].map(Number); // [1, 2, 3] // But unlike parseInt(), Number() will also return a float or (resolved) exponential notation: [\"1.1\", \"2.2e2\", \"3e300\"].map(Number); // [1.1, 220, 3e+300] // For comparison, if we use parseInt() on the array above: [\"1.1\", \"2.2e2\", \"3e300\"].map((str) => parseInt(str, 10)); // [1, 2, 3] See A JavaScript optional argument hazard by Allen Wirfs-Brock for more discussions.\n\nThe callback can have side effects. This is not recommended, because copying methods are best used with pure functions. In this case, we can choose to iterate the array twice. Sometimes this pattern goes to its extreme and the only useful thing that does is causing side effects. const products = [ { name: \"sports car\" }, { name: \"laptop\" }, { name: \"phone\" }, ]; products.map((product) => { product.price = 100; }); As mentioned previously, this is an anti-pattern. If you don't use the return value of , use or a loop instead. Or, if you want to create a new array instead:\n\nUsing the third argument of callbackFn The argument is useful if you want to access another element in the array, especially when you don't have an existing variable that refers to the array. The following example first uses to extract the positive values and then uses to create a new array where each element is the average of its neighbors and itself. const numbers = [3, -1, 1, 4, 1, 5, 9, 2, 6]; const averaged = numbers .filter((num) => num > 0) .map((num, idx, arr) => { // Without the arr argument, there's no way to easily access the // intermediate array without saving it to a variable. const prev = arr[idx - 1]; const next = arr[idx + 1]; let count = 1; let total = num; if (prev !== undefined) { count++; total += prev; } if (next !== undefined) { count++; total += next; } const average = total / count; // Keep two decimal places return Math.round(average * 100) / 100; }); console.log(averaged); // [2, 2.67, 2, 3.33, 5, 5.33, 5.67, 4] The argument is not the array that is being built — there is no way to access the array being built from the callback function.\n\nThe method reads the property of and then accesses each property whose key is a nonnegative integer less than . const arrayLike = { length: 3, 0: 2, 1: 3, 2: 4, 3: 5, // ignored by map() since length is 3 }; console.log(Array.prototype.map.call(arrayLike, (x) => x ** 2)); // [ 4, 9, 16 ] This example shows how to iterate through a collection of objects collected by . This is because returns a (which is a collection of objects). In this case, we return all the selected s' values on the screen: You can also use to transform to an array, and then access the method."
    },
    {
        "link": "https://w3schools.com/js/js_array_methods.asp",
        "document": "The property returns the length (size) of an array:\n\nThe JavaScript method converts an array to a string of (comma separated) array values.\n\nGet the third element of fruits using at(): Try it Yourself » Get the third element of fruits using []: Try it Yourself »\n\nThe method returns an indexed element from an array.\n\nThe method returns the same as .\n\nThe method is supported in all modern browsers since March 2022:\n\nMany languages allow like [-1] to access elements from the end of an object / array / string. This is not possible in JavaScript, because [] is used for accessing both arrays and objects. obj[-1] refers to the value of key -1, not to the last property of the object. The method was introduced in ES2022 to solve this problem.\n\nThe method also joins all array elements into a string.\n\nIt behaves just like , but in addition you can specify the separator:\n\nWhen you work with arrays, it is easy to remove elements and add new elements.\n\nThis is what popping and pushing is:\n\nPopping items out of an array, or pushing items into an array.\n\nThe method removes the last element from an array:\n\nThe method returns the value that was \"popped out\":\n\nThe method adds a new element to an array (at the end):\n\nThe method returns the new array length:\n\nShifting is equivalent to popping, but working on the first element instead of the last.\n\nThe method removes the first array element and \"shifts\" all other elements to a lower index.\n\nThe method returns the value that was \"shifted out\":\n\nThe method adds a new element to an array (at the beginning), and \"unshifts\" older elements:\n\nThe method returns the new array length:\n\nArray elements are accessed using their index number:\n\nThe property provides an easy way to append a new element to an array:\n\nThe method creates a new array by merging (concatenating) existing arrays:\n\nThe method can also take strings as arguments:\n\nThe method copies array elements to another position in an array:\n\nFlattening an array is the process of reducing the dimensionality of an array.\n\nFlattening is useful when you want to convert a multi-dimensional array into a one-dimensional array.\n\nThe method creates a new array with sub-array elements concatenated to a specified depth.\n\nJavaScript Array is supported in all modern browsers since January 2020:\n\nThe method first maps all elements of an array and then creates a new array by flattening the array.\n\nJavaScript Array is supported in all modern browsers since January 2020:\n\nThe method adds new items to an array.\n\nThe method slices out a piece of an array.\n\nThe method can be used to add new items to an array:\n\nThe first parameter (2) defines the position where new elements should be added (spliced in).\n\nThe second parameter (0) defines how many elements should be removed.\n\nThe rest of the parameters (\"Lemon\" , \"Kiwi\") define the new elements to be added.\n\nThe method returns an array with the deleted items:\n\nWith clever parameter setting, you can use to remove elements without leaving \"holes\" in the array:\n\nThe first parameter (0) defines the position where new elements should be added (spliced in).\n\nThe second parameter (1) defines how many elements should be removed.\n\nThe rest of the parameters are omitted. No new elements will be added.\n\nES2023 added the Array toSpliced() method as a safe way to splice an array without altering the original array.\n\nThe difference between the new toSpliced() method and the old splice() method is that the new method creates a new array, keeping the original array unchanged, while the old method altered the original array.\n\nThe method slices out a piece of an array into a new array:\n\nThe method can take two arguments like .\n\nThe method then selects elements from the start argument, and up to (but not including) the end argument.\n\nIf the end argument is omitted, like in the first examples, the method slices out the rest of the array.\n\nJavaScript automatically converts an array to a comma separated string when a primitive value is expected.\n\nThis is always the case when you try to output an array.\n\nThese two examples will produce the same result:\n\nSearching arrays are covered in the next chapter of this tutorial.\n\nSorting arrays covers the methods used to sort arraysg.\n\nIterating arrays covers methods that operate on all array elements."
    },
    {
        "link": "https://stackoverflow.com/questions/69610405/best-practices-with-nested-arrays-in-javascript",
        "document": "I'm currently working with nested arrays in an API response, and there is some info I need to extract.\n\nIn the example below, I want to extract the values from the \"PaymentTypeName\" obj key, and my code looks like that:\n\nWhere \"data\" is my API response.\n\nI want to know: is there a better/cleaner code approach than this nested \"forEach\" calls? Is it considered a bad practice?"
    },
    {
        "link": "https://medium.com/@kaklotarrahul79/javascript-arrays-and-objects-made-easy-methods-nested-structures-and-best-practices-ce3c9fe59683",
        "document": "An array is a data structure used to store multiple values in a single variable. It allows you to organize and manipulate collections of data efficiently.\n\nYou can access elements using their index (starting from 0).\n• push(): Adds an element to the end of the array.\n• unshift(): Adds an element to the beginning of the array."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-access-and-process-nested-objects-arrays-or-json",
        "document": "How to Access and Process Nested Objects, Arrays, or JSON?\n\nWorking with nested objects, arrays, or JSON in JavaScript involves traversing through multiple levels of data. Here are some effective ways to access and process nested data\n\n1. Using Dot Notation and Bracket Notation – Most Common\n\nDot notation is commonly used for direct access, while bracket notation is useful when keys are variables or contain special characters.\n\nOptional chaining (?.) is used for safely accessing deeply nested properties without causing errors if any part of the path is undefined or null. This helps in preventing runtime errors in complex data structures.\n\n3. Using for…in and for…of Loops for Iteration\n\nThe for…in loops are used for iterating through the properties of objects, while for…of loops are used for arrays. These can be combined to access nested data dynamically.\n\nRecursive functions allow you to access and process deeply nested objects or arrays by repeatedly calling the function on nested items. This is helpful when we don’t know the exact length of the object.\n\n5. Using JSON.parse() and JSON.stringify() Methods for JSON Data\n\nFor JSON data, you can use JSON.parse() to convert JSON strings into JavaScript objects and JSON.stringify() to convert JavaScript objects into JSON strings. This helps when handling JSON data from APIs or storing it locally.\n\nAccessing and processing nested objects, arrays, and JSON is essential for\n• Data handling in complex applications: Often, APIs return nested JSON, and accessing these is important.\n• Error prevention: Methods like optional chaining and recursion help avoid common issues with undefined or null values."
    },
    {
        "link": "https://stackoverflow.com/questions/7942398/nested-objects-in-javascript-best-practices",
        "document": "If you know the settings in advance you can define it in a single statement:\n\nIf you don't know the values in advance you can just define the top level object and then add properties:\n\nOr half-way between the two, define the top level with nested empty objects as properties and then add properties to those nested objects:\n\nYou can nest as deep as you like using the above techniques, and anywhere that you have a string literal in the square brackets you can use a variable:\n\nNote that you can not use variables for key names in the { } literal syntax."
    },
    {
        "link": "https://dev.to/engrsakib/mastering-javascript-arrays-techniques-best-practices-and-advanced-uses-42mb",
        "document": "An array is a special variable, which can hold more than one value:\n\nArrays are a fundamental data structure in JavaScript (and many other programming languages) for several reasons:\n• None Organize Data: Arrays allow you to store multiple values in a single variable, making it easier to manage collections of data. For example, if you need to keep track of a list of user names, you can store them all in an array.\n• None Indexed Access: Arrays provide a convenient way to access elements using indices. This makes it easy to retrieve or modify specific items based on their position.\n• None Iterate Efficiently: JavaScript offers various methods to iterate over arrays, such as , , , , and . These methods enable you to process each element of an array with minimal code.\n• None Dynamic Resizing: Arrays in JavaScript are dynamic, meaning they can grow or shrink in size as needed. You don't need to specify the size in advance, which adds flexibility to how you handle data.\n• None Built-in Methods: JavaScript arrays come with a rich set of built-in methods for manipulating and querying data. Methods like , , , , , , and many others simplify common tasks.\n• None Versatile Data Handling: Arrays can hold various types of data, including numbers, strings, objects, and even other arrays. This versatility makes arrays suitable for a wide range of applications.\n• None Enhanced Performance: Arrays are optimized for performance in JavaScript engines, making them efficient for tasks that involve sequential data processing and manipulation.\n• None Support for Higher-Order Functions: JavaScript arrays are designed to work seamlessly with higher-order functions, which can lead to more expressive and concise code. Functions like , , and enable powerful data transformations and aggregations.\n\nIn summary, arrays are essential for organizing, accessing, and manipulating collections of data efficiently and flexibly in JavaScript.\n\nSpaces and line breaks are not important. A declaration can span multiple lines:\n\nYou can also create an array, and then provide the elements:\n\nUsing the JavaScript Keyword new\n\nAccessing Array Elements\n\n You access an array element by referring to the index number:\n\nConverting an array to a string in JavaScript is a common operation, and there are several methods to achieve this, each serving different needs. Here are the most commonly used methods:\n\nThe method combines all elements of an array into a single string, with a specified separator between elements.\n• Custom Separator: You can specify any string as a separator, such as , , etc.\n\nThe method converts an array to a string, using commas to separate elements.\n• Separator: Always uses (comma) as a separator.\n\nYou can use the constructor to convert an array to a string. This approach is similar to but can be more explicit in certain contexts.\n\nFor custom formatting, you might use template literals to convert an array to a string.\n• Syntax: Use to embed array elements in a template string.\n\nFor more control over the conversion, especially if you need to format each element, you can use in combination with .\n\nAccessing the full contents of an array in JavaScript can be done in various ways depending on the context and the goal. Here are several methods to access and work with all elements of an array:\n\nYou can access individual elements of an array directly using their indices. For example, to access the first element, you use index .\n\nYou can use loops to iterate through each element of the array. Here are a few common looping methods:\n\nThe traditional loop gives you control over the index and can be useful for tasks like modifying elements based on their position.\n\nThe method executes a provided function once for each array element.\n\nThe loop provides a more modern and readable way to iterate through array elements.\n\nThe method creates a new array with the results of calling a provided function on every element.\n\nArray destructuring allows you to unpack elements from arrays into distinct variables.\n\nTo quickly view the entire array, you can use .\n\nSimilar to , but you can specify a separator.\n\nUse the spread operator to create a new array or pass the array elements to a function.\n\nIn JavaScript, arrays are indeed a type of object. This concept is fundamental to understanding how arrays work in JavaScript. Here’s a deeper look into why arrays are considered objects and how that impacts their behavior:\n• None Inheritance from Object: Arrays in JavaScript inherit from the prototype, which means they have all the properties and methods of objects. This includes methods like , , and others.\n• None Prototype Chain: Arrays have their own prototype chain that extends from , which is itself an object. This prototype chain provides arrays with their specific methods, like , , , and more.\n• Length Property: Arrays have a property that automatically updates as elements are added or removed. This is specific to arrays and is not present in general objects.\n• Index-Based Access: Arrays use numeric indices to access elements, whereas objects use string keys. This is a key distinction between arrays and regular objects.\n• None Enumerability: Arrays have numeric indices and are often used in scenarios where the order of elements is important. Objects use string keys and are typically used for key-value pairs where the order is less significant.\n• None Prototype Methods: Arrays come with a set of methods specific to array manipulation, such as , , and . Objects have methods and properties from , such as .\n• Additional Properties: You can add custom properties to arrays just like you can with objects, though it's not common practice. This does not affect array behavior but can lead to unexpected results when using array methods or properties.\n• Array Methods: Methods such as , , and operate on arrays but are not part of the base prototype. They are defined on .\n• None Use Cases: Arrays are best used when you need to store ordered collections of data and perform operations that involve sequence and index-based access. Objects are more suited for storing data with named properties where the order is not a priority.\n• None Performance: Arrays can be optimized for sequential access and manipulation due to their special handling in JavaScript engines. Objects are optimized for key-based access.\n\nThe property in JavaScript is a special property found on arrays and strings, and it plays a crucial role in managing collections of data. Here's a comprehensive overview of how the property works:\n\nThe property of an array returns the number of elements in the array. It is a dynamic property that automatically updates when elements are added or removed from the array.\n• Adding Elements: When you add elements to an array, the property increases.\n• Removing Elements: When you remove elements, the property decreases.\n• Directly Setting Length: You can also set the property manually. This will truncate the array or pad it with empty slots.\n• Truncation: Setting to a smaller number truncates the array to that length.\n• Padding: Setting to a larger number adds empty slots ( values) to the array.\n\nThe property of a string returns the number of characters in the string.\n• Sparse Arrays: Arrays can be sparse, meaning they may have \"holes\" where indices are not explicitly assigned values. The property reflects the highest index plus one, not the number of actual elements.\n\nHere, has a of 3, but only two indices ( and ) have values. The index is \"empty\" but still counts towards the length.\n• Negative Indexes: The property does not support negative indexes. Negative indices are not part of the standard JavaScript array indexing.\n• Iteration: Knowing the length of an array or string is essential for iterating through elements.\n• Validation: Use the property to validate input, such as ensuring a user input string meets minimum length requirements.\n• Padding and Truncation: Adjust the size of arrays and strings to fit specific requirements by setting the property.\n\nAdding elements to an array in JavaScript can be done using several methods, depending on where you want to add the elements and how you want to manipulate the array. Here’s a detailed look at the various techniques for adding elements to arrays:\n\nThe method adds one or more elements to the end of an array and returns the new length of the array.\n\nThe method adds one or more elements to the beginning of an array and returns the new length of the array.\n\nThe method can add elements at any position in the array. It can also be used to remove elements.\n• Syntax:\n• : The index at which to start adding elements.\n• : The number of elements to remove (0 if you are only adding).\n\nThe spread operator ( ) allows you to add elements from one array into another array. This is particularly useful for combining arrays.\n\nThe method creates a new array by combining multiple arrays or values.\n\nYou can use array destructuring with the spread operator to add elements to specific positions in an array.\n\nYou can use to insert multiple elements at a specific index.\n\nWhen using to add elements, be aware that it will add empty slots.\n\nNested arrays and objects in JavaScript are powerful features that allow you to create complex data structures. These can be used to represent multi-dimensional data, hierarchies, or any scenario where data is organized in layers.\n\nA nested array is an array that contains other arrays as its elements. This can be useful for representing matrices, grids, or hierarchical data.\n\nA nested object is an object that contains other objects as its properties. This is useful for representing hierarchical data or entities with multiple attributes.\n\nYou can combine arrays and objects to create more complex structures. For example, you might have an array of objects, where each object contains nested arrays or other objects.\n\nExample of Combining Nested Arrays and Objects\n• None Accessing: Use dot notation or bracket notation for objects, and indices for arrays.\n• None Updating: Assign new values to nested properties or elements.\n• Adding: Add new properties or elements as needed.\n• Deleting: Use for properties and for array elements.\n• None Data Representation: Represent complex data structures such as configuration settings, hierarchical data (e.g., organizational charts), and multi-dimensional datasets.\n• None APIs and Databases: Often used in API responses and database queries to represent complex records.\n• None Form Data: Useful for handling nested form data, such as forms with sections or groups of fields.\n\nJavaScript arrays come with a rich set of built-in methods that help you manipulate and interact with array data. These methods can be broadly categorized into several types, including those for modifying arrays, accessing elements, and iterating over elements. Here’s a comprehensive overview of common array methods:\n• : Adds one or more elements to the end of an array.\n• : Removes the last element from an array and returns it.\n• : Adds one or more elements to the beginning of an array.\n• : Removes the first element from an array and returns it.\n• : Returns the first index at which a given element can be found, or if not found.\n• : Checks if an array contains a specific element.\n• : Returns the first element that satisfies a provided testing function.\n• : Returns the index of the first element that satisfies a provided testing function.\n• : Executes a provided function once for each array element.\n• : Creates a new array with the results of calling a provided function on every element.\n• : Creates a new array with all elements that pass the test implemented by the provided function.\n• : Applies a function against an accumulator and each element to reduce it to a single value.\n• : Similar to , but starts from the right end of the array.\n• : Tests whether at least one element in the array passes the provided function.\n• : Tests whether all elements in the array pass the provided function.\n• : Sorts the elements of an array in place and returns the array.\n• Note: sorts elements as strings by default. For numerical sorting, use a compare function.\n• : Reverses the elements of an array in place.\n• : Merges two or more arrays into a new array.\n• : Returns a shallow copy of a portion of an array into a new array.\n• : Modifies an array by adding, removing, or replacing elements. (Also listed under adding/removing elements.)\n• : Converts an array to a string, with elements separated by commas.\n• : Joins all elements of an array into a string with a specified separator.\n\nJavaScript arrays come with various methods for searching and locating elements. These methods can be used to find specific values, check for the presence of elements, or retrieve indexes. Here's a detailed overview of the key array search methods:\n\nThe method returns the first index at which a given element can be found, or if the element is not found.\n• \n• : The element to search for.\n• (optional): The index to start the search from.\n\nThe method determines whether an array contains a certain element and returns or .\n• \n• : The element to search for.\n• (optional): The index to start the search from.\n\nThe method returns the first element in the array that satisfies a provided testing function. If no elements satisfy the testing function, it returns .\n• \n• (optional): Value to use as when executing .\n\nThe method returns the index of the first element in the array that satisfies a provided testing function. If no elements satisfy the testing function, it returns .\n• \n• (optional): Value to use as when executing .\n\nThe method tests whether at least one element in the array passes the provided testing function. It returns if any elements pass the test, otherwise .\n• \n• (optional): Value to use as when executing .\n\nThe method tests whether all elements in the array pass the provided testing function. It returns if all elements pass the test, otherwise .\n• \n• (optional): Value to use as when executing .\n\nThe method creates a new array with all elements that pass the test implemented by the provided function.\n• \n• (optional): Value to use as when executing .\n\nThe method returns the last element in the array that satisfies a provided testing function. If no elements satisfy the testing function, it returns . Note that this method is experimental and may not be supported in all environments.\n• \n• (optional): Value to use as when executing .\n\nThe method returns the index of the last element in the array that satisfies a provided testing function. If no elements satisfy the testing function, it returns . Note that this method is experimental and may not be supported in all environments.\n• \n• (optional): Value to use as when executing .\n\nSorting arrays in JavaScript can be done using the method. This method allows you to arrange elements in an array according to a specified order. By default, the method sorts the elements as strings, but you can provide a custom comparison function to sort elements in different ways.\n\nThe method sorts the elements of an array in place and returns the sorted array.\n\nTo sort elements in a specific order, you need to pass a comparison function to . The comparison function takes two arguments (let's call them and ) and returns:\n• A negative value if should come before .\n• Zero if and are equal in the sort order.\n• A positive value if should come after .\n\nBy default, the method converts numbers to strings and sorts them lexicographically. To sort numbers correctly, provide a comparison function that performs numerical comparisons.\n\nStrings are sorted lexicographically (dictionary order) by default. For case-insensitive sorting, you can convert strings to the same case (e.g., lowercase) in the comparison function.\n\nTo sort an array of objects, use a comparison function that compares the desired properties of the objects.\n\nWhen sorting multi-dimensional arrays (arrays of arrays), provide a comparison function that compares the relevant elements.\n\nJavaScript's method is stable in modern environments, meaning that elements with equal values retain their relative order. However, this is not guaranteed in all JavaScript engines, so if stability is crucial, consider using a custom stable sorting algorithm or library.\n\nThe method can be useful for sorting strings in a locale-aware manner, accounting for different cultural sorting rules.\n\nJavaScript provides several methods for iterating over arrays, allowing you to execute a function on each element or transform the array in various ways. Here’s a comprehensive overview of the array iteration methods available in JavaScript:\n\nThe method executes a provided function once for each array element. It does not return a value and cannot be stopped or broken out of early.\n• \n• : Function that is executed for each element.\n• (optional): Value to use as when executing .\n\nThe method creates a new array with the results of calling a provided function on every element in the original array. It’s used for transforming elements.\n• \n• : Function that is executed for each element.\n• (optional): Value to use as when executing .\n\nThe method creates a new array with all elements that pass the test implemented by the provided function. It is used for selecting elements that meet certain criteria.\n• \n• : Function that is executed for each element.\n• (optional): Value to use as when executing .\n\nThe method applies a function against an accumulator and each element in the array to reduce it to a single value, such as a sum or a concatenated string.\n• \n• : Function that is executed for each element.\n• (optional): Value to use as the first argument to the first call of the .\n\nThe method is similar to , but it processes the array from right to left.\n• \n• : Function that is executed for each element.\n• (optional): Value to use as the first argument to the first call of the .\n\nThe method tests whether at least one element in the array passes the test implemented by the provided function. It returns if at least one element passes the test, otherwise .\n• \n• : Function that is executed for each element.\n• (optional): Value to use as when executing .\n\nThe method tests whether all elements in the array pass the test implemented by the provided function. It returns if all elements pass the test, otherwise .\n• \n• : Function that is executed for each element.\n• (optional): Value to use as when executing .\n\nThe method returns the first element in the array that satisfies the provided testing function. If no elements satisfy the testing function, it returns .\n• \n• : Function that is executed for each element.\n• (optional): Value to use as when executing .\n\nThe method returns the index of the first element in the array that satisfies the provided testing function. If no elements satisfy the testing function, it returns .\n• \n• : Function that is executed for each element.\n• (optional): Value to use as when executing .\n\nThe loop provides a clean syntax for iterating over iterable objects like arrays. It is especially useful for looping through array values.\n\nThe loop iterates over the enumerable properties of an object. When used with arrays, it iterates over array indices, not values. It is generally not recommended for arrays, as it is intended for objects.\n\nThe method first maps each element using a mapping function, then flattens the result into a new array. This is useful for when you need to map and then flatten the results in one go.\n• \n• : Function that is executed for each element.\n• (optional): Value to use as when executing .\n\nIn JavaScript, is a keyword used to declare variables that are intended to remain constant—i.e., their references cannot be reassigned. However, this does not mean the value or object they point to is immutable. For arrays declared with , the array itself cannot be reassigned, but its elements can still be modified.\n\nHere's a more detailed look at using with arrays:\n\nWhen you declare an array with , you are creating a constant reference to that array. This means you cannot reassign the array to a different value or array, but you can still modify its elements or its structure (such as adding or removing elements).\n\nEven though you cannot reassign the array, you can use array methods to modify its contents:\n• Adding Elements: Use methods like , , or .\n• Removing Elements: Use methods like , , or .\n\nMethods that modify the array in place are allowed:\n• : Sorts the elements of the array. ```javascript\n\nIf you need an immutable array, where changes to the array are not allowed, you need to use additional techniques or libraries to achieve this. JavaScript itself does not provide immutable arrays directly. For example, you could use libraries like Immutable.js for immutability: s a summary of the most common array operations:</p> <h3> <a name=\"1-creation-and-initialization\" href=\"#1-creation-and-initialization\"> </a> 1. <strong>Creation and Initialization</strong> </h3> <ul> <li> <strong>Literal Syntax</strong>: <code>const array = [1, 2, 3];</code></li> <li> <strong>Using <code>Array</code> Constructor</strong>: <code>const array = new Array(3); // Creates an array with 3 empty slots</code></li> </ul> <h3> <a name=\"2-accessing-and-modifying-elements\" href=\"#2-accessing-and-modifying-elements\"> </a> 2. <strong>Accessing and Modifying Elements</strong> </h3> <ul> <li> <strong>Access by Index</strong>: <code>const firstElement = array[0];</code></li> <li> <strong>Modify by Index</strong>: <code>array[0] = 10;</code></li> </ul> <h3> <a name=\"3-array-methods\" href=\"#3-array-methods\"> </a> 3. <strong>Array Methods</strong> </h3> <h4> <a name=\"creation-and-transformation\" href=\"#creation-and-transformation\"> </a> <strong>Creation and Transformation</strong> </h4> <ul> <li> <strong><code>concat()</code></strong>: Combines arrays. <code>const combined = array1.concat(array2);</code></li> <li> <strong><code>flat()</code></strong>: Flattens nested arrays. <code>const flatArray = nestedArray.flat();</code></li> <li> <strong><code>flatMap()</code></strong>: Maps and then flattens. <code>const result = array.flatMap(x => [x, x * 2]);</code></li> </ul> <h4> <a name=\"sorting\" href=\"#sorting\"> </a> <strong>Sorting</strong> </h4> <ul> <li> <strong><code>sort()</code></strong>: Sorts elements. <code>array.sort((a, b) => a - b);</code></li> <li> <strong><code>reverse()</code></strong>: Reverses the order. <code>array.reverse();</code></li> </ul> <h4> <a name=\"adding-and-removing-elements\" href=\"#adding-and-removing-elements\"> </a> <strong>Adding and Removing Elements</strong> </h4> <ul> <li> <strong><code>push()</code></strong>: Adds elements to the end. <code>array.push(4);</code></li> <li> <strong><code>pop()</code></strong>: Removes the last element. <code>const last = array.pop();</code></li> <li> <strong><code>unshift()</code></strong>: Adds elements to the beginning. <code>array.unshift(0);</code></li> <li> <strong><code>shift()</code></strong>: Removes the first element. <code>const first = array.shift();</code></li> <li> <strong><code>splice()</code></strong>: Adds or removes elements at a specified index. <code>array.splice(1, 1, );</code></li> </ul> <h4> <a name=\"iteration\" href=\"#iteration\"> </a> <strong>Iteration</strong> </h4> <ul> <li> <strong><code>forEach()</code></strong>: Executes a function on each element. <code>array.forEach(element => console.log(element));</code></li> <li> <strong><code>map()</code></strong>: Transforms elements and returns a new array. <code>const newArray = array.map(x => x * 2);</code></li> <li> <strong><code>filter()</code></strong>: Returns elements that pass a test. <code>const filtered = array.filter(x => x % 2 === 0);</code></li> <li> <strong><code>reduce()</code></strong>: Reduces array to a single value. <code>const sum = array.reduce((acc, x) => acc + x, 0);</code></li> <li> <strong><code>reduceRight()</code></strong>: Reduces array from right to left. <code>const product = array.reduceRight((acc, x) => acc * x, 1);</code></li> <li> <strong><code>some()</code></strong>: Tests if any elements pass a test. <code>const hasEven = array.some(x => x % 2 === 0);</code></li> <li> <strong><code>every()</code></strong>: Tests if all elements pass a test. <code>const allPositive = array.every(x => x > 0);</code></li> <li> <strong><code>find()</code></strong>: Finds the first element that passes a test. <code>const found = array.find(x => x > 3);</code></li> <li> <strong><code>findIndex()</code></strong>: Finds the index of the first element that passes a test. <code>const index = array.findIndex(x => x > 3);</code></li> <li> <strong><code>flatMap()</code></strong>: Maps and flattens results. <code>const flattened = array.flatMap(x => [x, x * 2]);</code></li> </ul> <h3> <a name=\"4-search-and-indexing\" href=\"#4-search-and-indexing\"> </a> 4. <strong>Search and Indexing</strong> </h3> <ul> <li> <strong><code>indexOf()</code></strong>: Finds the first index of an element. <code>const index = array.indexOf(3);</code></li> <li> <strong><code>includes()</code></strong>: Checks if an element exists. <code>const exists = array.includes(3);</code></li> <li> <strong><code>lastIndexOf()</code></strong>: Finds the last index of an element. <code>const lastIndex = array.lastIndexOf(3);</code></li> </ul> <h3> <a name=\"5-miscellaneous\" href=\"#5-miscellaneous\"> </a> 5. <strong>Miscellaneous</strong> </h3> <ul> <li> <strong><code>slice()</code></strong>: Returns a shallow copy of a portion of an array. <code>const subArray = array.slice(1, 3);</code></li> <li> <strong><code>join()</code></strong>: Joins array elements into a string. <code>const str = array.join( );</code></li> <li> <strong><code>toString()</code></strong>: Converts array to a string. <code>const str = array.toString();</code></li> </ul> <h3> <a name=\"6-array-and-raw-const-endraw-\" href=\"#6-array-and-raw-const-endraw-\"> </a> 6. <strong>Array and <code>const</code></strong> </h3> <ul> <li> <strong><code>const</code> with Arrays</strong>: Prevents reassignment of the array reference, but allows modification of array elements and structure. <code>const array = [1, 2, 3]; array.push(4); // Allowed</code></li> </ul> <h3> <a name=\"7-advanced-iteration\" href=\"#7-advanced-iteration\"> </a> 7. <strong>Advanced Iteration</strong> </h3> <ul> <li> <strong><code>for...of</code></strong>: Iterates over values. <code>for (const value of array) { console.log(value); }</code></li> <li> <strong><code>for...in</code></strong>: Iterates over indices (less recommended for arrays). <code>for (const index in array) { console.log(index); }</code></li> </ul> <h2> <a name=\"in-short\" href=\"#in-short\"> </a> In short </h2> <ul> <li> <strong>Creation</strong>: Use array literals or constructors.</li> <li> <strong>Access/Modify</strong>: Use index-based operations.</li> <li> <strong>Methods</strong>: For transformation, sorting, adding/removing, and iteration.</li> <li> <strong>Search/Index</strong>: For locating elements and indices.</li> <li> <strong><code>const</code></strong>: Use for constant references, allowing modification.</li> <li> <strong>Iteration</strong>: Employ <code>forEach()</code>, <code>map()</code>, <code>filter()</code>, etc., for different iteration needs.</li> </ul> <p>Understanding and utilizing these operations effectively will help you manage and manipulate arrays in JavaScript with greater efficiency and flexibility.</p>"
    }
]