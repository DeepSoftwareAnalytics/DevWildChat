[
    {
        "link": "https://stackoverflow.com/questions/23463088/compare-the-values-of-properties-of-two-objects-in-linq",
        "document": "I have two lists of Student Object in my code and . The student object has the following properties.\n\nI have the following method where I would like to compare the value of the respective property between the objects in the two list using LINQ. I found a few examples in LINQ that showed how to compare two values in a list of integers or string, but could not find any examples that compares the property value of the objects in the List.\n\nHow would I go about doing this? Thanks!"
    },
    {
        "link": "https://stackoverflow.com/questions/17323804/compare-two-lists-via-one-property-using-linq",
        "document": "What you want here is a .\n\ncan be more or less thought of as a special case of where the two sequences are of the same type, and can thus be applied for equality instead of needing a projection for each type to generate a key to compare. Given your case, isn't an option.\n\nIf a particular ID is duplicated in your second set and you don't want the item to be duplicated in the results then you can use a instead of a :"
    },
    {
        "link": "https://reddit.com/r/csharp/comments/gca8io/using_linq_how_to_check_if_value_exist_in_list_of",
        "document": "I have a Class with a \"Name\" property\" . Given a List<string> I want to check if List<Class> contains any objects that match Name with value in List<string>. Hopefully that makes sense."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions",
        "document": "You use a lambda expression to create an anonymous function. Use the lambda declaration operator to separate the lambda's parameter list from its body. A lambda expression can be of any of the following two forms:\n• None Expression lambda that has an expression as its body:\n• None Statement lambda that has a statement block as its body:\n\nTo create a lambda expression, you specify input parameters (if any) on the left side of the lambda operator and an expression or a statement block on the other side.\n\nAny lambda expression can be converted to a delegate type. The types of its parameters and return value define the delegate type to which a lambda expression can be converted. If a lambda expression doesn't return a value, it can be converted to one of the delegate types; otherwise, it can be converted to one of the delegate types. For example, a lambda expression that has two parameters and returns no value can be converted to an Action<T1,T2> delegate. A lambda expression that has one parameter and returns a value can be converted to a Func<T,TResult> delegate. In the following example, the lambda expression , which specifies a parameter named and returns the value of squared, is assigned to a variable of a delegate type:\n\nExpression lambdas can also be converted to the expression tree types, as the following example shows:\n\nYou use lambda expressions in any code that requires instances of delegate types or expression trees. One example is the argument to the Task.Run(Action) method to pass the code that should be executed in the background. You can also use lambda expressions when you write LINQ in C#, as the following example shows:\n\nWhen you use method-based syntax to call the Enumerable.Select method in the System.Linq.Enumerable class, for example in LINQ to Objects and LINQ to XML, the parameter is a delegate type System.Func<T,TResult>. When you call the Queryable.Select method in the System.Linq.Queryable class, for example in LINQ to SQL, the parameter type is an expression tree type . In both cases, you can use the same lambda expression to specify the parameter value. That makes the two calls to look similar although in fact the type of objects created from the lambdas is different.\n\nA lambda expression with an expression on the right side of the operator is called an expression lambda. An expression lambda returns the result of the expression and takes the following basic form:\n\nThe body of an expression lambda can consist of a method call. However, when creating expression trees evaluated by a query provider, limit method calls to those methods recognized by the query provider. Otherwise, the query provider can't replicate the method's function.\n\nA statement lambda resembles an expression lambda except that its statements are enclosed in braces:\n\nThe body of a statement lambda can consist of any number of statements; however, in practice there are typically no more than two or three.\n\nYou can't use statement lambdas to create expression trees.\n\nYou enclose input parameters of a lambda expression in parentheses. Specify zero input parameters with empty parentheses:\n\nIf a lambda expression has only one input parameter, parentheses are optional:\n\nTwo or more input parameters are separated by commas:\n\nThe compiler typically infers the types for parameters to lambda expressions, referred to as an implicitly typed parameter list. You can specify the types explicitly, referred to as an explicitly typed parameter list. An explicitly typed parameter list is shown in the following example. :\n\nInput parameter types must be all explicit or all implicit; otherwise, a CS0748 compiler error occurs. Before C# 14, you must include the explicit type on a parameter if it has any modifiers, such as or . In C# 14, that restriction is removed. However, you must still declare the type if you use the modifier.\n\nYou can use discards to specify two or more input parameters of a lambda expression that aren't used in the expression:\n\nLambda discard parameters can be useful when you use a lambda expression to provide an event handler.\n\nBeginning with C# 12, you can provide default values for explicitly typed parameter lists. The syntax and the restrictions on default parameter values are the same as for methods and local functions. The following example declares a lambda expression with a default parameter, then calls it once using the default and once with two explicit parameters:\n\nYou can also declare lambda expressions with arrays or collections as the last parameter in an explicitly typed parameter list:\n\nAs part of these updates, when a method group that has a default parameter is assigned to a lambda expression, that lambda expression also has the same default parameter. A method group with a collection parameter can also be assigned to a lambda expression.\n\nLambda expressions with default parameters or collections as parameters don't have natural types that correspond to or types. However, you can define delegate types that include default parameter values:\n\nOr, you can use implicitly typed variables with declarations to define the delegate type. The compiler synthesizes the correct delegate type.\n\nFor more information about default parameters on lambda expressions, see the feature spec for default parameters on lambda expressions.\n\nYou can easily create lambda expressions and statements that incorporate asynchronous processing by using the async and await keywords. For example, the following Windows Forms example contains an event handler that calls and awaits an async method, .\n\nYou can add the same event handler by using an async lambda. To add this handler, add an modifier before the lambda parameter list, as the following example shows:\n\nFor more information about how to create and use async methods, see Asynchronous Programming with async and await.\n\nThe C# language provides built-in support for tuples. You can provide a tuple as an argument to a lambda expression, and your lambda expression can also return a tuple. In some cases, the C# compiler uses type inference to determine the types of tuple elements.\n\nYou define a tuple by enclosing a comma-delimited list of its components in parentheses. The following example uses tuple with three components to pass a sequence of numbers to a lambda expression, which doubles each value and returns a tuple with three components that contains the result of the multiplications.\n\nOrdinarily, the fields of a tuple are named , , and so on. You can, however, define a tuple with named components, as the following example does.\n\nFor more information about C# tuples, see Tuple types.\n\nLINQ to Objects, among other implementations, has an input parameter whose type is one of the Func<TResult> family of generic delegates. These delegates use type parameters to define the number and type of input parameters, and the return type of the delegate. delegates are useful for encapsulating user-defined expressions that are applied to each element in a set of source data. For example, consider the Func<T,TResult> delegate type:\n\nThe delegate can be instantiated as a instance where is an input parameter and is the return value. The return value is always specified in the last type parameter. For example, defines a delegate with two input parameters, and , and a return type of . The following delegate, when invoked, returns Boolean value that indicates whether the input parameter is equal to five:\n\nYou can also supply a lambda expression when the argument type is an Expression<TDelegate>, for example in the standard query operators that are defined in the Queryable type. When you specify an Expression<TDelegate> argument, the lambda is compiled to an expression tree.\n\nThe following example uses the Count standard query operator:\n\nThe compiler can infer the type of the input parameter, or you can also specify it explicitly. This particular lambda expression counts those integers ( ) which when divided by two have a remainder of 1.\n\nThe following example produces a sequence that contains all elements in the array that precede the 9, because that's the first number in the sequence that doesn't meet the condition:\n\nThe following example specifies multiple input parameters by enclosing them in parentheses. The method returns all the elements in the array until it finds a number whose value is less than its ordinal position in the array:\n\nYou don't use lambda expressions directly in query expressions, but you can use them in method calls within query expressions, as the following example shows:\n\nWhen writing lambdas, you often don't have to specify a type for the input parameters because the compiler can infer the type based on the lambda body, the parameter types, and other factors as described in the C# language specification. For most of the standard query operators, the first input is the type of the elements in the source sequence. If you're querying an , then the input variable is inferred to be a object, which means you have access to its methods and properties:\n\nThe general rules for type inference for lambdas are as follows:\n• The lambda must contain the same number of parameters as the delegate type.\n• Each input parameter in the lambda must be implicitly convertible to its corresponding delegate parameter.\n• The return value of the lambda (if any) must be implicitly convertible to the delegate's return type.\n\nA lambda expression in itself doesn't have a type because the common type system has no intrinsic concept of \"lambda expression.\" However, it's sometimes convenient to speak informally of the \"type\" of a lambda expression. That informal \"type\" refers to the delegate type or Expression type to which the lambda expression is converted.\n\nA lambda expression can have a natural type. Instead of forcing you to declare a delegate type, such as or for a lambda expression, the compiler can infer the delegate type from the lambda expression. For example, consider the following declaration:\n\nThe compiler can infer to be a . The compiler chooses an available or delegate, if a suitable one exists. Otherwise, it synthesizes a delegate type. For example, the delegate type is synthesized if the lambda expression has parameters. When a lambda expression has a natural type, it can be assigned to a less explicit type, such as System.Object or System.Delegate:\n\nMethod groups (that is, method names without parameter lists) with exactly one overload have a natural type:\n\nIf you assign a lambda expression to System.Linq.Expressions.LambdaExpression, or System.Linq.Expressions.Expression, and the lambda has a natural delegate type, the expression has a natural type of System.Linq.Expressions.Expression<TDelegate>, with the natural delegate type used as the argument for the type parameter:\n\nNot all lambda expressions have a natural type. Consider the following declaration:\n\nThe compiler can't infer a parameter type for . When the compiler can't infer a natural type, you must declare the type:\n\nTypically, the return type of a lambda expression is obvious and inferred. For some expressions that doesn't work:\n\nYou can specify the return type of a lambda expression before the input parameters. When you specify an explicit return type, you must parenthesize the input parameters:\n\nYou can add attributes to a lambda expression and its parameters. The following example shows how to add attributes to a lambda expression:\n\nYou can also add attributes to the input parameters or return value, as the following example shows:\n\nAs the preceding examples show, you must parenthesize the input parameters when you add attributes to a lambda expression or its parameters.\n\nCapture of outer variables and variable scope in lambda expressions\n\nLambdas can refer to outer variables. These outer variables are the variables that are in scope in the method that defines the lambda expression, or in scope in the type that contains the lambda expression. Variables that are captured in this manner are stored for use in the lambda expression even if the variables would otherwise go out of scope and be garbage collected. An outer variable must be definitely assigned before it can be consumed in a lambda expression. The following example demonstrates these rules:\n\nThe following rules apply to variable scope in lambda expressions:\n• A variable that is captured isn't garbage-collected until the delegate that references it becomes eligible for garbage collection.\n• Variables introduced within a lambda expression aren't visible in the enclosing method.\n• A lambda expression can't directly capture an in, ref, or out parameter from the enclosing method.\n• A return statement in a lambda expression doesn't cause the enclosing method to return.\n• A lambda expression can't contain a goto, break, or continue statement if the target of that jump statement is outside the lambda expression block. It's also an error to have a jump statement outside the lambda expression block if the target is inside the block.\n\nYou can apply the modifier to a lambda expression to prevent unintentional capture of local variables or instance state by the lambda:\n\nA static lambda can't capture local variables or instance state from enclosing scopes, but can reference static members and constant definitions.\n\nFor more information, see the Anonymous function expressions section of the C# language specification.\n\nFor more information about these features, see the following feature proposal notes:\n• Use local function instead of lambda (style rule IDE0039)"
    },
    {
        "link": "https://ndepend.com/docs/cqlinq-features",
        "document": "Once you've analyzed your first .NET code base with NDepend, you'll see that the NDepend project created contains around 200 default CQLinq queries and rules, categorized in different groups.\n\nThis set of default queries and rules cover the various CQLinq features in terms of code querying.\n\nThis document is a quick list of these features and informs the reader about what is possible with CQLinq. Keep in mind that these features are available through the well-defined list of types supported by the CQLinq querying model.\n\nFrom the introduction of NDepend v2017.1 CQLinq is not just about code querying but also about querying Debt, Issues, Rules and Quality Gates.\n\nThis feature is useful for in-depth exploration of the technical-debt. Here we demonstrate how a few clicks from the Dashboard can generate queries to explore the debt and the issues.\n\nThis feature is also useful to define :\n\nFor example a Quality Gate that would define thresholds concerning the percentage of technical-debt could look like:\n\nA Trend Metric that would count the number of critical rules violated could look like:\n\nNot only this Trend Metric is useful to follow the trend, but its result can also be browsed for in-depth exploration:\n\nWhen a baseline is available, rules are passed against the baseline in addition to being passed against the actual code base snapshot. As a result NDepend can compare both issues sets: the issues set obtained by passing rules on the baseline and the issues set obtained by passing rules on the actual code base snapshot.\n\nCQLinq can then be used to query the Debt, Issues, Rules and Quality Gates diff. For example a Trend Metric that counts the new issues since baseline could look like:\n\nA Quality Gate that would forbid more than 2 man-days of technical debt since the baseline could look like:\n\nA dozen of Quality Gates are defined by default, and it is easy to customize them and to create new ones. In the screenshot below, this query (generated by a single click on the Dashboard) shows not only the Quality Gates actual status, but also the Quality Gates status on baseline. Quality Gates that rely on diff cannot be passed against the baseline and this is why they have a Not Available N/A value.\n\nIn the same way, many Trend Metrics related to Debt, Issues, Rules and Quality Gates are defined by default and it is easy to customize them and create new ones.\n\nThe dashboard proposes several menus to generate queries to explore the Debt, Issues, Rules and Quality Gates status Any number can be clicked to generate a query that lists the counted items.\n\nSpecialized types are defined by the NDepend.API to specify the debt model, including Debt ; IIssue ; IRule ; IQualityGate ; QualityGateStatus.\n\nHowever the two key types are: IIssuesSet ; IIssuesSetDiff.\n• First NDepend runs the activated rules both on the actual snapshot and on the baseline.\n• Then it populates these issues-set and issues-set-diff objects.\n• Queries that rely on issues-set and issues-set-diff are executed only once these sets are filled. As a consequence a Rule cannot rely on these sets, but a Quality Gate can.\n\nInstead of writing a query like...\n\n...4 domains are proposed by CQLinq: Issues, IssuesOnBaseline, Rules and QualityGates.\n\nThese domains are shortcuts for context.IssuesSet.AllIssues, context.IssuesSetDiff.OlderIssuesSet.AllIssues, context.IssuesSet.AllRules and context.IssuesSet.AllQualityGates.\n\nThese domains can be seen as range variables of type: IEnumerable<IIssue> ; IEnumerable<IRule> ; IEnumerable<IQualityGate>.\n\nWith these domains, simple queries can then be written like...\n\n...or even just:\n\nThe same way instead of constantly referring to issues-set and issues-set-diff to obtain data like for example...\n\n...the types ExtensionMethodsCQLinqIssuesSet and ExtensionMethodsCQLinqIssuesSetDiff propose convenient extension methods which are automatically translated by the CQLinq compiler to calls on the issues-set and the issues-set-diff objects.\n\nDebt value can be formatted to convenient values through extension methods proposed by the type ExtensionMethodsCQLinqDebtFormatter which are translated to calls to members of a IDebtFormatter object, by the CQLinq compiler.\n\nThis facility offers a convenient way for harnessing Debt-formatting project value defined in the NDepend Project Settings.\n\nFinally please note that when modifying a code rule, the issues-set and issues-set-diff are automatically recomputed in a few seconds and all numbers on the Dashboard are refreshed. In the same way, after an NDepend analysis (typically triggered by a Rebuild All in Visual Studio) these sets are automatically recomputed in a few seconds.\n\nFor NDepend, a .NET code base ICodeBase object is made of IAssembly, INamespace, IType, IMethod and IField objects. This object model reflects the hierarchical organization of the code where the code base is made of assemblies that contain namespaces that contain types that contain methods and fields. Notice that if a same namespace is spawned across N assemblies, the hierarchy is preserved and there are N INamespace objects, one contained in each assembly.\n\n\n\nTo navigate across this hierarchy, several parent and child properties are proposed like IMember.ParentType or IType.Methods. Most of the time, instead of using these properties it is more convenient to use the extension methods declared in the class ExtensionMethodsProjection that project a sequence of parent to a sequence of child and vice-versa. For example, see the usage of the extension method ChildMethods() in the query:\n\nTo access these various kind of code elements, CQLinq proposed different predefined domains Assemblies, Namespaces, Types, Methods, Fields, codeBase, Application, ThirdParty and JustMyCode. Before continuing, it is important to click the link above and understand these predefined domains and how they relate to the application, third-party and just-my-code views of the code base.\n\n\n\nSeveral ways are proposed to access the interfaces implementations, they are summarized in this query:\n\nThe same way there are several ways to navigate across the base and derived classes hierarchy:\n\nThe API proposes also facilities to navigate across methods overridden, and overrides:\n\nSometime you might want to resolve concrete methods that override an abstract method called. This is possible by using the NDepend API method FillIterative() this way:\n\nHere is the code sample on which this query is executed:\n\nHere is the query result:\n\nLet's export this query result to the dependency graph. Here overrides of abstract methods are not seen as called but all potentially called methods at runtime are shown.\n\nSeveral facilities are proposed to deal with the visibility of a IMember object. Notice in the default query below the attributes that are related to visibility, and the possibility to obtain the optimal visibility. The optimal visibility is the most restricted visibility that a member can have in the context of the parent code base, without provoking a compilation syntax error. For example an internal method called only by methods defined in the same class could be declared as private.\n\nThe interface IAttributeTarget, implemented by IAssembly, IType, IMethod and IField, defines an attribute target.\n\nThis interface is not implemented by INamespace, because a namespace cannot be tagged by an attribute. The query below illustrates facilities proposed to browse attribute tagging.\n\nNotice that the property IType.IsAttributeClass is equivalent to DeriveFrom(\"System.Attribute\").\n\nIn the previous section, we have seen how to query different usages like interface implementation, class derivation, methods override and attributes tagging.\n\n\n\nThe NDepend code model proposes a general dependency model through the interfaces IUsed and IUser. With this two interfaces it is easy to browse dependency across any kind of code elements.\n\n\n\nThe dependency model is general in the sense that it doesn't rely on the kind of usage (interface implementation, field assignment, method call...). A and B being two code elements, we say that A depends on B if, when B is not available, A cannot be compiled.\n\n\n\nInstead, of using methods of the IUsed and IUser interfaces, you'll often find more convenient to call extension methods from the class ExtensionMethodsCQLinqDependency where user and used code elements are named, like in the following query:\n\nAll sorts of dependency query can be generated with the NDepend right click menus available on code element right click in:\n• The Visual Studio Code Editor: The NDepend menu is available on Namespace, Types, Methods, Fields declaration right click (see the screenshot below)\n• The Visual Studio Solution Explorer: The NDepend menu is available on File, Directory (that represent a namespace), Project, Project Dependencies and Files child elements right click\n• The NDepend menu is available on any code element right click presented in any NDepend panels\n\nWith the NDepend right click dependency menus you can query various dependencies levels like:\n• or methods used by a namespace\n\nA section below details the indirect dependencies querying capabilities (like methods using methods ... using methods using X()).\n\nNotice how such extension methods are used by rules generated from dependency graph or dependency matrix, to forbid some particular dependency:\n\nThe rule generated is shown below. It could be easily adapted to forbid or enforce any dependency in a code base.\n\nThe extension methods of the class ExtensionMethodsSequenceUsage represent also a convenient way to query dependencies of a code base (and often a faster way as well):\n\nEach code element interfaces presents properties to get a sequence of user or used code elements (of the same kind). Here is a query relying on IMethod.MethodsCalled for example. Notes that in general, this facility is slower than the ones presented above.\n\nTo browse all classes dependencies just write this code query. Of course you can refine this query for any special need.\n\nThe class ExtensionMethodsCQLinqDependency presents some extension methods containing the word Indirect in their names, like for example, the extension method IsIndirectlyUsing(). These extension methods deal with indirect usage.\n\nIn other words indirect usage means transitive closure. You can get not only callers (or callees) but also callers of callers recursively (or callees of callees recursively).\n\nFor example if A is using B that is using C, A is not directly using C but A is indirectly using C (with a depth of 2). Here is a query that enumerates methods that are directly or indirectly calling the interface method System.IDisposable.Dispose().\n\nThe extension method DepthOfIsUsing goes further since it returns the depth of usage.\n\nThe depth returned is a Nullable<ushort> value.\n• It is null if m doesn't call indirectly the target method.\n• It is 1 if m calls directly the target method.\n• It is greater than 1 if m calls indirectly the target method.\n\nThis indirect usage possibility is especially useful to generate Call Graphs or Class Inheritance Graphs.\n\nSuch indirect dependency query can be generated by:\n• by right clicking a code element in a NDepend panel\n• by right clicking a code elemnt declaration in the Visual Studio code editor\n• by right clicking an item (file, folder project...) in the Visual Studio solution explorer\n\nOn the screenshot above notice the button Export to that can export the query result to the dependency graph (see below) or to a HTML Excel XML or text document.\n\nSome of the extension methods of the class ExtensionMethodsSequenceUsage also contain the word Indirect or the word Depth to work with indirect usage from a sequence to a code element or even any code elements of a target sequence (suffix Any).\n\nSuch extension method named DepthOf... returns a ICodeMetric<TCodeElement,TNumeric> object. This code metric object represents the code metric that assigns the indirect usage depth (as defined above), to any code element of the input sequence. Code elements that are not in the ICodeMetric<,>.DefinitionDomain have a null depth.\n\nFor example, the following query matches all methods that are calling, directly or indirectly the setter of a property, with the depth of call:\n\nSpecial CQLinq methods like IsIndirectlyUsing() and DepthOfIsUsing() cannot take a ICodeElement as argument.\n\nHowever to obtain the transitive closure of any code element the method FillIterative() can be used this way:\n\nThe method FillIterative() returns a ICodeMetric<TCodeElement,ushort> object, like the method DepthOfIsUsing() shown in the previous section. You can refer to the previous section for explanation on ICodeMetric.\n\nThe method FillIterative() iteratively fills a sequence of code elements, until no new element can be added. The first iteration starts with initialSeq, and the function func is used to compute new elements of the iteration N+1 from new elements computed at iteration N. The method FillIterative() is well suited to obtain a transitive closure in terms of call but it is generic enough to be used for others purposes.\n\nIndirect Usage, Transitive Closure of Virtual and Override Methods with FillIterative()\n\nSometime the query generated by right clicking a method through the menu Select Methods (...) that are Using Me (Directly or Indirectly) doesn't return all expected methods. This is generally because the right-clicked method, or some of its callers methods, are overrides of a virtual method. Only the virtual method is seen as called in the code base and thus, the transitive closure of calls is stopped prematurely because the overrides are not seen as called. It is possible to counter this phenomenon with the FillIterative() API method and a bit of astute.\n\nFor example such query is generated when right clicking a method that overrides a virtual method:\n\nIt can be transformed into this query to obtain also callers of virtual methods overriden, obtained thanks to the property IMethod.OverriddensBase:\n\nThe same pattern can be used for classes that implement some base classes, and/or implement some interfaces. The query generated when right clicking such type looks like:\n\nThat can be transformed into:\n\nNDepend computes more than 80 code metrics. See these code metrics listed and explained here. These code metrics are presented by the interfaces IAssembly, INamespace, IType, IMethod and IField.\n\nNotes that many of these code metrics returns a nullable numeric value because they are not necessarily defined for all code elements. For example the #Lines of Code is not computed for third-party code elements.\n\n\n\nSome of these code metrics are computed from the IL code contained in the application assemblies, some others are computed from the assembly PDB files (if found, else these metrics values are null) some others are computed from the source code itself (if found, else these metrics values are null). The document Understanding NDepend Analysis Inputs explains with details how code metrics are processed, from which sources.\n\nNDepend offers the possibility to import code coverage by tests data , from the result of the most popular .NET code coverage tool.\n\n\n\nAmongst all code metrics, code coverage is certainly the one that tells best if a piece of code is bug prone or not. In this condition, it can be very informative to couple code coverage metrics, with facts like high complexity or code refactored. We know that complex and refactored code are typically bug prone, so we need to cover such code with tests to keep the bug probability low.\n\nNote that complex methods code should be refactored to several simple methods.\n\nNote also that metrics like #Lines of Code and % coverage are presented by the interface ICodeContainer. Only the interface IField doesn't implement ICodeContainer.\n\nThanks to the LINQ flexibility it is easy to compose the default code metrics to create more elaborated code metrics, like for example:\n\nWe saw above in the section Querying the Code Dependencies and Design that a ICodeMetric<TCodeElement,TNumeric> object can be obtained to get a code metric equals to the depth of usage of one or several code elements.\n\nA custom code metric object can also be obtained from the extension method ExtensionMethodsHelpers.FillIterative().\n\nFor example, this possibility is used in the rule to obtain dead types, but also to obtained types only used by dead type (and the depth of usage):\n\nNDepend proposes to compare code changes against a baseline to see what was changed/added/removed. In the NDepend API this feature is presented through the interface ICompareContext. For example, the following query lists methods where code has been changed:\n\nActually, thanks to the extension methods in ExtensionMethodsCQLinqCompare you can just write the shortest query below, and the CQLinq compiler will take care to transform it into the query above:\n\nSome code rules take advantage of this diff querying possibility, like the rules in the groups: API Breaking Changes and Code Smells Regression.\n\nWhen running such queries it is easy to explore code changes through source diff:\n\nThe interfaces ICompareContext methods, and the extension methods in ExtensionMethodsCQLinqCompare takes a code element in argument, and returns a boolean indicating if the code element has been changed/added/removed.\n\nNotice the two methods OlderVersion() and NewerVersion() . As their names suggest, these methods returns the older or newer version of a code element, or null if the code element has been added (hence no older version) or removed (hence no newer version). These methods can be useful for example to write the query below that tracks the evolution in terms of method complexity:\n\nNotice the call to IsPresentInBothBuilds to ensure that we only deal with methods that are both in the older and newer code base snapshot, to prevent any NullReferenceException while running the query!\n\n\n\nAs this last query shows, mixing the diff feature with others CQLinq features like code quality metrics or dependencies, can lead to powerful code queries and rules to track the evolution of a code base.\n\nCQLinq proposes several facilities to query the name of the code elements. This is especially useful to write simple code naming conventions (based on regular expressions)...\n\nThe code elements naming feature is summarized in the CQLinq syntax document, in the section Matching code elements by name string.\n\nThe concept of immutability is becoming more and more popular among C# and VB.NET programmers. (rumors say that post v5 versions of C# and VB.NET will proposes some keywords concerning immutability). Immutability is especially useful when dealing with concurrent accesses into multi-threaded environment.\n\n\n\nA type is considered as immutable if its instance fields cannot be modified once an instance has been built by a constructor.\n\nA static field is considered as immutable if it is private and if it is only assigned by the static constructor.\n\nAn instance field is considered as immutable if it is private and if it is only assigned by its type’s constructor(s) or its type’s static constructor.\n\nNotes that a field declared as readonly is necessarily immutable, but a field can be immutable without being declared as readonly. In this last case, the keyword readonly can be added to the field declaration, without provoking any compilation error.\n\n\n\nAt analysis time, NDepend computes the mutability of types and fields. The result is available through the properties IType.IsImmutable and IField.IsImmutable. It is then easy to write such rule for example:\n\nSince neither C# nor VB.NET proposes yet any keyword to enforce type immutability, it is possible to use an attribute like ImmutableAttribute (or any other custom attribute) coupled with a rule like the one below, to enforce immutability.\n\nThe two properties IMethod.ChangesObjectState and IMethod.ChangesTypeState can be use to enforce or check that a method is pure. A pure method is a method that doesn't assign any instance or static fields.\n\n\n\nAlso, to control the write access to a particular field, you can use the extension method ExtensionMethodsCQLinqDependency.AssignField():\n\nIn addition, the interface IField presents the 3 properties IField.MethodsAssigningMe , IField.MethodsReadingMeButNotAssigningMe and IField.MethodsUsingMe and the interface IMethod presents the method IMethod.AssignField().\n\nThe interface ICodeElement presents the two properties ICodeElement.SourceFileDeclAvailable and ICodeElement.SourceDecls.\n\n For a code element, its source file declaration(s) might not be available for a variety of reasons:\n• Because the source files or assemblies PDB files were not available at analysis time, as explained in details in the document Understanding NDepend Analysis Inputs.\n• Because the code coverage files were not available at analysis time (for code coverage related metrics).\n• Because it is a default constructor not declared in source code.\n• Because it is an abstract method or a field (for which NDepend doesn't gather yet source file declarations).\n\nHaving access to source file declarations opens a range of interesting applications. For example the default query matching methods to discard from the JustMyCode code base view, relies on some patterns on source file name, and can be easily adapted to any situation:\n\nNotice that source files paths are represented through the API NDepend.Path designed to make paths operations convenient (absolute/relative path, directory/file path, navigation...).\n\n\n\nSeveral default rules concerning source files organization are proposed, like the following one. Notice that this rule relies on the property IAssembly.VisualStudioProjectFilePath . The Visual Studio project file path is found by NDepend at analysis time through an heuristic."
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Input.GetKeyDown.html",
        "document": "For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation.\n\nThank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable.\n\nNote: This API is part of the legacy class, and not recommended for new projects. The documentation is provided here to support legacy projects that use the old Input Manager and Input class. For new projects you should use the newer and Input System Package. (read more).\n\n\n\nCall this function from the Update function, since the state gets reset each frame. It will not return true until the user has released the key and pressed it again.\n\n\n\nFor the list of key identifiers see Conventional Game Input. When dealing with input it is recommended to use Input.GetAxis and Input.GetButton instead since it allows end-users to configure the keys."
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/KeyCode.html",
        "document": "Suggest a change Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable. Close For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation. Close\n\nKey codes returned by Event.keyCode. These map directly to a physical key on the keyboard. If \"Use Physical Keys\" is enabled in Input Manager settings, these map directly to a physical key on the keyboard. If \"Use Physical Keys\" is disabled these map to language dependent mapping, different for every platform and cannot be guaranteed to work. \"Use Physical Keys\" is enabled by default from 2022.1\n\nKey codes can be used to detect key down and key up events, using Input.GetKeyDown and Input.GetKeyUp:\n\nFor joystick and gamepad button presses, consider using Input.GetButtonDown and Input.GetButtonUp instead of the KeyCode. These methods allow you to check input state using a descriptive action string, e.g. \"fire\" or \"jump\", instead of the hardware button number.\n\n\n\nThe Input pages provide details about accessing keyboard, mouse and joystick input."
    },
    {
        "link": "https://discussions.unity.com/t/input-getkeydown-works-as-a-condition-but-a-regular-bool-does-not-also-bool-holds-two-values/880700",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/noob-question-methods-and-input/667712",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/how-to-tostring-an-inputted-keycode/901057",
        "document": ""
    }
]