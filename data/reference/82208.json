[
    {
        "link": "https://commons.apache.org/proper/commons-lang/javadocs/api-3.1/index.html?org/apache/commons/lang3/StringUtils.html",
        "document": "This document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. \n\n Link toNon-frame version."
    },
    {
        "link": "https://stackoverflow.com/questions/32567208/best-way-to-verify-string-is-empty-or-null",
        "document": "i am sure this must have been asked before in different ways - as isEmptyOrNull is so common yet people implement it differently. but i have below curious query in terms of best available approach which is good for memory and performance both.\n\n1) Below does not account for all spaces like in case of empty XML tag\n\n2) Below one takes care but trim can eat some performance + memory\n\n3) Combining one and two can save some performance + memory (As Chris suggested in comments)\n\n4) Converted to pattern matcher (invoked only when string is non zero length)\n\n5) Using libraries like - Apache Commons ( ) or Spring ( ) or Guava ( ) or any other option?"
    },
    {
        "link": "https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/23419087/stringutils-isblank-vs-string-isempty",
        "document": "I ran into some code that has the following:\n\nThis appears to be functionally equivalent to the following:\n\nIs a difference between the two ( and )?"
    },
    {
        "link": "https://educative.io/answers/what-is-stringutilsisnotblank-in-java",
        "document": "is a static method of the class that is used to check if a given string is not blank.\n\nIf a string does not satisfy any of the criteria below, then the string is considered to be not blank.\n• The length of the string is zero or the string is empty.\n• The string contains only whitespace characters."
    },
    {
        "link": "https://stackoverflow.com/questions/16539238/public-fields-in-a-data-transfer-object",
        "document": "In my years of programming I've often made classes that simply group a few variables with their setters and getters. I've seen these types of objects referred to as value objects, domain objects or model objects depending on the context in which they are used. The most fitting term for generic usage seems to be Data Transfer Object (DTO). This describes a POJO that only contains accessors and mutators.\n\nI've just written one such object that contains about fifty fields used to set theme parameters on a chart. Now I'm wondering if instead of generating a hundred getters and setters I should just declare these fields as public. Doing so goes against everything my programming instincts tell me yet I can't deny that it would greatly increase my code's legibility and reduce the amount of boilerplate code in the class.\n\nThe only reason I can see not to use public fields would be if I needed to perform any sort of validation on these fields. If we assume that type validation is sufficient for my purposes, is using public fields in this scenario an acceptable break from object-oriented design? Will a public DTO perform better in large batch operations?"
    },
    {
        "link": "https://baeldung.com/java-dto-pattern",
        "document": "In this tutorial, we’ll discuss the DTO pattern, what it is, and how and when to use it. By the end, we’ll know how to use it properly.\n\nDTOs or Data Transfer Objects are objects that carry data between processes in order to reduce the number of methods calls. The pattern was first introduced by Martin Fowler in his book EAA.\n\nFowler explained that the pattern’s main purpose is to reduce roundtrips to the server by batching up multiple parameters in a single call. This reduces the network overhead in such remote operations.\n\nAnother benefit is the encapsulation of the serialization’s logic (the mechanism that translates the object structure and data to a specific format that can be stored and transferred). It provides a single point of change in the serialization nuances. It also decouples the domain models from the presentation layer, allowing both to change independently.\n\n3. How to Use It?\n\nDTOs normally are created as POJOs. They are flat data structures that contain no business logic. They only contain storage, accessors and eventually methods related to serialization or parsing.\n\nThe data is mapped from the domain models to the DTOs, normally through a mapper component in the presentation or facade layer.\n\nThe image below illustrates the interaction between the components:\n\n4. When to Use It?\n\nDTOs come in handy in systems with remote calls, as they help to reduce the number of them.\n\nDTOs also help when the domain model is composed of many different objects and the presentation model needs all their data at once, or they can even reduce roundtrip between client and server.\n\nWith DTOs, we can build different views from our domain models, allowing us to create other representations of the same domain but optimizing them to the clients’ needs without affecting our domain design. Such flexibility is a powerful tool to solve complex problems.\n\nTo demonstrate the implementation of the pattern, we’ll use a simple application with two main domain models, in this case, User and Role. To focus on the pattern, let’s look at two examples of functionality — user retrieval and the creation of new users.\n\nBelow is the definition of both models:\n\nNow let’s look at the DTOs so that we can compare them with the Domain models.\n\nAt this moment, it’s important to notice that the DTO represents the model sent from or to the API client.\n\nTherefore, the small differences are either to pack together the request sent to the server or optimize the response of the client:\n\nThe DTO above provides only the relevant information to the client, hiding the password, for example, for security reasons.\n\nThe next DTO groups all the data necessary to create a user and sends it to the server in a single request, which optimizes the interactions with the API:\n\nNext, the layer that ties both classes uses a mapper component to pass the data from one side to the other and vice versa.\n\nThis normally happens in the presentation layer:\n\nLast, we have the Mapper component that transfers the data, making sure that both DTO and domain model don’t need to know about each other:\n\nAlthough the DTO pattern is a simple design pattern, we can make a few mistakes in applications implementing this technique.\n\nThe first mistake is to create different DTOs for every occasion. That will increase the number of classes and mappers we need to maintain. Try to keep them concise and evaluate the trade-offs of adding one or reusing an existing one.\n\nWe also want to avoid trying to use a single class for many scenarios. This practice may lead to big contracts where many attributes are frequently not used.\n\nAnother common mistake is to add business logic to those classes, which should not happen. The purpose of the pattern is to optimize the data transfer and the structure of the contracts. Therefore, all business logic should live in the domain layer.\n\nLast, we have the so-called LocalDTOs, where DTOs pass data across domains. The problem once again is the cost of maintenance of all the mapping.\n\nOne of the most common arguments in favor of this approach is the encapsulation of the domain model. But the problem here is to have our domain model coupled with the persistence model. By decoupling them, the risk to expose the domain model almost disappears.\n\nOther patterns reach a similar outcome, but they usually are used in more complex scenarios, such as CQRS, Data Mappers, CommandQuerySeparation, etc.\n\nIn this article, we saw the definition of the DTO Pattern, why it exists and how to implement it.\n\nWe also saw some of the common mistakes related to its implementation and ways to avoid them."
    },
    {
        "link": "https://medium.com/@ayoubseddiki132/mastering-dtos-best-practices-and-pitfalls-to-avoid-fda9b3db1eb9",
        "document": "DTOs Done Right: Best Practices and Common Pitfalls\n\nData Transfer Objects (DTOs) are a fundamental part of modern software development. They help decouple layers, optimize data transfer, and improve security. However, like any tool, DTOs can be misused, leading to bloated code, tight coupling, and maintenance nightmares.\n\nIn this article, I’ll walk you through the best practices for working with DTOs and highlight the common pitfalls to avoid. Let’s dive in!"
    },
    {
        "link": "https://stackoverflow.com/questions/43319743/data-transfer-object-dto-where-to-build",
        "document": "DTO may be used to transfert data between the different layers of an application: DAO, Service, Facade, Controller. In my experience DTO is an opinionated topic.\n\nIn my opinion, the later the conversion, the better, it is even better if no conversion is needed. Generally, the later is at the application boundary. DTO is not free, it involves mapping and its support. Hence DTOs will make sense when there is a domain model mismatch or a model technical mismatch accross the boundary. For more information you can have a look at LocalDTO article and the associated link.\n\nIf I focus on the service -> facade -> controller layers:\n• None Services: They are doing services things and they may call each other to do their processing. If your domain models remain consistent across the services boundary it is too early to convert the result into a DTO.\n• None Facades: They may orchestrate services and convert input/output. In my point of view it will be the right place to convert to or from DTO. But only if it is needed to ie. because your domain models have to be transformed accross this boundary (filtering fields, aggregation...)\n• None Gateway/Controllers: They are at the application boundary. Their logics are simple, reduced to the boundary logic. The relation between a facade and a controller is usually . ***\n\nThus in my point of view, your first proposal is more adapted eg. . The most important is to stay pragmatic."
    },
    {
        "link": "https://snyk.io/blog/how-to-use-java-dtos",
        "document": "Data Transfer Objects (DTOs) in Java are objects that transport data between subsystems. It is an enterprise design pattern to aggregate data. The main purpose is to reduce the number of system calls needed between the subsystems, reducing the amount of overhead created.\n\nIn this article, I will explain how DTOs are used in modern Java applications, ways your application can benefit, and how Java DTOs can help you be more secure by preventing accidental data leaks.\n\nWhat is a POJO, Java Bean, and Value Object\n\nAs the name already suggested, a Plain Old Java Object (POJO) is an ordinary Java Object. It can be any class and isn’t bound to any specific restrictions other than the ones prescribed by the Java language. They are created for re-usability and increased readability.\n\nA Java Bean is a POJO according to the JavaBean standard. According to this standard, all properties are private, and will be accessed with getter and setter methods. Additionally a no-arg constructor should be present, along with a few more things.\n\nSo, this means that while all Java Beans are POJOs, not all POJOs are Java Beans.\n\nA Value Object is a small object that represents a simple data entity. However, a value object doesn’t typically have an identity. Value objects are not currently available in Java, but JDK maintainers are working to add them as part of JEP 401. For now, we have to create a POJO to do the work for us.\n\nA DTO can be implemented as a POJO — or a Java Bean for that matter. The most important thing is that a DTO separates concerns between entities like the presentation layer and the domain model, for example.\n\nLet's take a small rest service to explain this. Say we have a coffee store with coffees and customers. Both of these are separate domain entities in the system. If I want to know a customer’s favorite coffee, I’ll create an API that provides the aggregate data represented in the FavoriteCoffeDTO.\n\nThe code looks something like this:\n\nI separated the domain layer from the presentation layer in the implementation above, allowing my controller to now handle mapping the two domain entities to the DTO.\n\nIn this example, I made the fields private, meaning I have to create getter and setter methods to access the fields. Users often choose to follow the JavaBean standard either completely or partially for DTO. This isn’t mandatory of course, you’re free to choose whatever method suits your needs. Other options include making all fields public and accessing them directly (like the example below), or making the object immutable with an all-args constructor and some getter methods.\n\nLastly, if you updated to a more recent version of Java, you might want to use Java records for your DTO’s. Java Records are simple immutable classes that automatically provide you with an all-args constructor, access methods, toString(), and hashCode() without defining them. This makes your code less verbose and more readable. Notice that records do not follow the Java Bean specification, since the access methods do not have a or prefix.\n\nThe purpose of a DTO is to carry data between processes. Therefore, a good DTO only contains the information needed for that specific part of the system. In our API example, we only need to return the name of the customer and their favorite coffee order. There is no need to add anything else, such as business logic. The general advice is to keep your DTOs as simple, small, and straightforward as possible.\n\nAlso after a DTO is initialized, its state shouldn't change or evolve. This means that an immutable data structure would be a great fit for a DTO. As a DTO only carries data that should be unaltered, a Java Record would be a great fit — especially because JSON serialization libraries like Jackson support Java Records.\n\nWe already noticed that we decouple the Domain model from the presentation layer with this DTO pattern. Simple DTOs that only contain the data needed for this subsystem or API, without any business logic, can also improve your security.\n\nWhat we see in many proofs of concepts is that domain entries are fully outputted. This can lead to unnecessary data being available outside of the system and potential data leaks.\n\nSay our API has a function to find all customers, but does not use a DTO:\n\nIf our customer object is the same as in our previous example, we are already displaying too much information. Do we actually need the or the list of favorite ? It gets worse if we decide to attach more information to the customer, like a home address.\n\nIf we don't filter in our endpoint, we suddenly create a data breach, since providing a full name and home address is considered a privacy breach in many countries. Decoupling the API from the data model with a DTO would have prevented this because the mapper controller would only populate necessary fields in the DTO. Even when we decide to add something to our domain model afterwards, using a DTO prevents us from essentially leaking personally identifiable information.\n\nUsing DTOs in Java to decouple subsystems is generally a good idea. From an engineering perspective, it will reduce roundtrips between the different layers and form a security angle it will help prevent accidental data leaks. In terms of security, I would recommend making your DTOs specific and limiting the amount of reuse. If you are reusing your DTOs for different functions, you should clearly understand where these DTO’s are used before changing them.\n\nIn general, keep your DTOs concise, free of business logic if possible, and only provide the data needed for specific functions. Lastly, I believe that immutability is a natural fit for DTOs, making Java Records — which was fully released in Java 16 — a great way to implement DTOs in Java.\n\nCheck out the following resources to learn more about Java security:\n• None Serialization and deserialization in Java: explaining the Java deserialize vulnerability\n• None 10 best practices to build a Java container with Docker\n• None Java logging: what should you log and what not?\n\nYou can also try our free online Java code checker tool to see how the Snyk code engine analyses your code for security and quality issues.\n\nDTO stands for Data Transfer Object. It is an object that transports data between different processes in an application. A DTO is specifically designed to reduce the number of method calls between client and server by aggregating data. It also prevents tight coupling between entities, such as the domain model and presentation layer of an application.\n\nWhat is a DTO in Java?\n\nA Data Transfer Object in Java is typically a POJO (Plain Old Java Object) without any business logic. They usually have a flat data structure that specifically suits the purpose of the transaction between the methods it is used for. DTO’s in Java might follow the JavaBean convention with private fields and getter and setter methods, but it doesn't have too.\n\nIs a DTO the same as a POJO?\n\nIn short, a DTO is a POJO but not every POJO is a DTO. A Data Transfer Object is a specific POJO to transport data between processes.\n\nYes, if DTOs are implemented well, they reduce tight coupling and method calls — which improves security and reduces data leaks.\n\nWhat is the difference between a DAO and DTO?\n\nDAO stands for Data Access Object, and is used in a pattern to decouple business logic from the persistence layer. DAOs are often used for CRUD operations like update, delete, and save. A DTO is an object meant to exclusively transport data between subsystems and should not contain business logic."
    }
]