[
    {
        "link": "https://stackoverflow.com/questions/39140202/restore-sql-database-with-replace-option",
        "document": "The purpose of the REPLACE option is to allow you to overwrite a database name (clobber an existing database with a different name from the backup). Your errors are caused by you trying to overwrite the files of another database from the one you asked to restore over. So restoring over Test2 database but clobbering Test1 database files (Test1.MDB and Test1.LDB). If you don't use the MOVE clause then the RESTORE command will use the same filenames as the BACKUP. Probably not a good idea otherwise things are going to get pretty confusing. (Test2 database pointing to Test1.mdb and Test1.ldb)\n\nMy script below demonstrates the issue. I create database Test1. I Back it up. I try to restore it to Test2 using REPLACE. It fails, because Test1.mdb and Test1.ldb are being used by the Test1 database. I drop the Test1 database. I try to restore it to Test2 using REPLACE and it now works. (But is using Test1.mdb and Test1.ldb).\n\nThis is Microsoft's explanation of the REPLACE option:\n\nREPLACE Option Impact REPLACE should be used rarely and only after careful consideration. Restore normally prevents accidentally overwriting a database with a different database. If the database specified in a RESTORE statement already exists on the current server and the specified database family GUID differs from the database family GUID recorded in the backup set, the database is not restored. This is an important safeguard.\n\nThe REPLACE option overrides several important safety checks that restore normally performs. The overridden checks are as follows:\n\nRestoring over an existing database with a backup taken of another database.\n\nWith the REPLACE option, restore allows you to overwrite an existing database with whatever database is in the backup set, even if the specified database name differs from the database name recorded in the backup set. This can result in accidentally overwriting a database by a different database.\n\nRestoring over a database using the full or bulk-logged recovery model where a tail-log backup has not been taken and the STOPAT option is not used.\n\nWith the REPLACE option, you can lose committed work, because the log written most recently has not been backed up.\n\nFor example, a mistake could allow overwriting files of the wrong type, such as .xls files, or that are being used by another database that is not online. Arbitrary data loss is possible if existing files are overwritten, although the restored database is complete."
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/t-sql/statements/restore-statements-transact-sql?view=sql-server-ver16",
        "document": "Restores SQL database backups taken using the BACKUP command.\n\nIn the following row, select the product name you're interested in, and only that product's information is displayed.\n\nFor more information about the syntax conventions, see Transact-SQL syntax conventions.\n\nThis command enables you to perform the following restore scenarios:\n• Revert a database to the point in time captured by a database snapshot.\n• For more information about SQL Server restore scenarios, see Restore and Recovery Overview.\n• When restoring a database from another instance, consider the information from Manage Metadata When Making a Database Available on Another Server Instance (SQL Server).\n• For more information about restoring from the Microsoft Azure Blob Storage, see SQL Server Backup and Restore with Microsoft Azure Blob Storage.\n• Backup and restore to S3-compatible object storage was introduced in SQL Server 2022 (16.x). For more information about restoring from S3-compatible object storage, see SQL Server backup and restore with S3-compatible object storage. Also review the option for SQL Server backup to URL for S3-compatible object storage.\n• For more information about descriptions of the arguments, see RESTORE Arguments.\n\nFor descriptions of the arguments, see RESTORE Arguments.\n• Restores the entire database, beginning with a full database backup, which may be followed by restoring a differential database backup (and log backups). For more information, see Complete Database Restores - Simple Recovery Model or Complete Database Restores - Full Recovery Model.\n• Restores a file or filegroup in a multi-filegroup database. Under the simple recovery model, the file must belong to a read-only filegroup. After a full file restore, a differential file backup can be restored. For more information, see File Restores - Full Recovery Model and File Restores - Simple Recovery Model.\n• Restores individual pages. Page restore is available only under the full and bulk-logged recovery models. For more information, see Restore Pages - SQL Server.\n• Restores the database in stages, beginning with the primary filegroup and one or more secondary filegroups. A piecemeal restore begins with a RESTORE DATABASE using the PARTIAL option and specifying one or more secondary filegroups to be restored. For more information, see Piecemeal Restores - SQL Server.\n• Recovers data that is already consistent with the database and needs only to be made available. For more information, see Recover a Database Without Restoring Data.\n• Under the full or bulk-logged recovery model, restoring log backups is required to reach the desired recovery point. For more information about restoring log backups, see Apply Transaction Log Backups - SQL Server.\n• None Prepare an availability database for an Always On availability group For more information, see Manually Prepare a Secondary Database for an Availability Group - SQL Server.\n• For more information, see Prepare a Mirror Database for Mirroring - SQL Server.\n• Online restore is allowed only in Enterprise edition of SQL Server.\n\nWhere online restore is supported, if the database is online, file restores and page restores are automatically online restores and, also, restores of secondary filegroup after the initial stage of a piecemeal restore.\n\nFor more information, see Online Restore.\n\nThe following keywords were discontinued in SQL Server 2008 (10.0.x):\n\nRESTORE LOG can include a file list to allow for creation of files during rollforward. This is used when the log backup contains log records written when a file was added to the database.\n\nRollback is controlled by the RESTORE statement through the [ RECOVERY | NORECOVERY ] options:\n• None NORECOVERY specifies that rollback doesn't occur. This allows rollforward to continue with the next statement in the sequence. In this case, the restore sequence can restore other backups and roll them forward.\n• None RECOVERY (the default) indicates that rollback should be performed after rollforward is completed for the current backup. No further backups can be restored. Select this option once you have restored all of the necessary backups. Recovering the database requires that the entire set of data being restored (the rollforward set) is consistent with the database. If the rollforward set has not been rolled forward far enough to be consistent with the database and RECOVERY is specified, the Database Engine issues an error. For more information about the recovery process, see Restore and Recovery Overview (SQL Server).\n\nBackups of , and that were created by using an earlier version of SQL Server cannot be restored by SQL Server.\n\nEach version of SQL Server uses a different default path than earlier versions. Therefore, to restore a database that was created in the default location for earlier version backups, you must use the MOVE option. For information about the new default path, see File Locations for Default and Named Instances of SQL Server.\n\nAfter you restore an earlier version database to SQL Server, the database is automatically upgraded. Typically, the database becomes available immediately. However, if a SQL Server 2005 (9.x) database has full-text indexes, the upgrade process either imports, resets, or rebuilds them, depending on the setting of the upgrade_option server property. If the upgrade option is set to import (upgrade_option = 2) or rebuild (upgrade_option = 0), the full-text indexes will be unavailable during the upgrade. Depending on the amount of data being indexed, importing can take several hours, and rebuilding can take up to ten times longer. Note also that when the upgrade option is set to import, the associated full-text indexes are rebuilt if a full-text catalog is not available. To change the setting of the upgrade_option server property, use sp_fulltext_service.\n\nWhen a database is first attached or restored to a new instance of SQL Server, a copy of the database master key (encrypted by the service master key) is not yet stored in the server. You must use the OPEN MASTER KEY statement to decrypt the database master key (DMK). Once the DMK has been decrypted, you have the option of enabling automatic decryption in the future by using the ALTER MASTER KEY REGENERATE statement to provision the server with a copy of the DMK, encrypted with the service master key (SMK). When a database has been upgraded from an earlier version, the DMK should be regenerated to use the newer AES algorithm. For more information about regenerating the DMK, see ALTER MASTER KEY. The time required to regenerate the DMK key to upgrade to AES depends upon the number of objects protected by the DMK. Regenerating the DMK key to upgrade to AES is only necessary once, and has no impact on future regenerations as part of a key rotation strategy.\n\nDuring an offline restore, if the specified database is in use, RESTORE forces the users off after a short delay. For online restore of a non-primary filegroup, the database can stay in use except when the filegroup being restored is being taken offline. Any data in the specified database is replaced by the restored data.\n\nCross-platform restore operations, even between different processor types, can be performed as long as the collation of the database is supported by the operating system.\n\nRESTORE can be restarted after an error. In addition, you can instruct RESTORE to continue despite errors, and it restores as much data as possible (see the option).\n\nRESTORE is not allowed in an explicit or implicit transaction.\n\nRestoring a damaged database is performed using a special procedure. For more information, see Back Up and Restore of System Databases.\n\nRestoring a database clears the plan cache for the database being restored. Clearing the plan cache causes a recompilation of all subsequent execution plans and can cause a sudden, temporary decrease in query performance.\n\nTo restore an availability database, first restore the database to the instance of SQL Server, and then add the database to the availability group.\n\nIntegrated acceleration and offloading for backup compression and decompression\n\nSQL Server 2022 (16.x) introduces , which identifies a compression algorithm for the operation. For more information, see Backup COMPRESSION.\n\nFor more information, see Restore operations\n\nURL is the format used to specify the location and the file name for Microsoft Azure Blob Storage or S3-compatible object storage. Although Azure Blob Storage is a service, the implementation is similar to disk and tape to allow for a consistent and seamless restore experience for all devices.\n• None For more information about restoring from the Microsoft Azure Blob Storage, see SQL Server Backup and Restore with Microsoft Azure Blob Storage.\n• None Backup and restore to S3-compatible object storage was introduced in SQL Server 2022 (16.x). For more information about restoring from S3-compatible object storage, see SQL Server backup and restore with S3-compatible object storage. Also review the option for SQL Server backup to URL for S3-compatible object storage.\n\nDuring a restore, most of the database options that are settable using ALTER DATABASE are reset to the values in force at the time of the end of backup.\n\nUsing the WITH RESTRICTED_USER option, however, overrides this behavior for the user access option setting. This setting is always set following a RESTORE statement, which includes the WITH RESTRICTED_USER option.\n\nTo restore a database that is encrypted, you must have access to the certificate or asymmetric key that was used to encrypt the database. Without the certificate or asymmetric key, the database cannot be restored. As a result, the certificate that is used to encrypt the database encryption key must be retained as long as the backup is needed. For more information, see SQL Server Certificates and Asymmetric Keys.\n\nBackup and restore work correctly with the vardecimal storage format. For more information about vardecimal storage format, see sp_db_vardecimal_storage_format.\n\nFull-text data is restored together with other database data during a complete restore. Using the regular syntax, the full-text files are restored as part of the database file restore.\n\nThe RESTORE statement also can be used to perform restores to alternate locations, differential restores, file and filegroup restores, and differential file and filegroup restores of full-text data. In addition, RESTORE can restore full-text files only, as well as with database data.\n\nRestore to SQL Server 2022 and the auto drop feature\n\nWhen restoring a database to SQL Server 2022 (16.x) from a previous version, it is recommended to execute on the database, setting the proper metadata for the statistics auto drop feature. For more information, see statistics auto drop option.\n\nCertain operations, including configuring server (instance level) settings, or manually adding a database to an availability group, require a connection to the SQL Server instance. Operations like , , or any DDL command in a database belonging to an availability group require a connection to the SQL Server instance. By default, a big data cluster does not include an endpoint that enables a connection to the instance. You must expose this endpoint manually.\n\nFor instructions, see Connect to databases on the primary replica.\n\nSQL Server includes backup and restore history tables that track the backup and restore activity for each server instance. When a restore is performed, the backup history tables are also modified. For information on these tables, see Backup History and Header Information.\n\nREPLACE should be used rarely and only after careful consideration. Restore normally prevents accidentally overwriting a database with a different database. If the database specified in a RESTORE statement already exists on the current server and the specified database family GUID differs from the database family GUID recorded in the backup set, the database is not restored. This is an important safeguard.\n\nThe REPLACE option overrides several important safety checks that restore normally performs. The overridden checks are as follows:\n• None Restoring over an existing database with a backup taken of another database. With the REPLACE option, restore allows you to overwrite an existing database with whatever database is in the backup set, even if the specified database name differs from the database name recorded in the backup set. This can result in accidentally overwriting a database by a different database.\n• None Restoring over a database using the full or bulk-logged recovery model where a tail-log backup has not been taken and the option is not used. With the REPLACE option, you can lose committed work, because the log written most recently has not been backed up.\n• For example, a mistake could allow overwriting files of the wrong type, such as .xls files, or that are being used by another database that is not online. Arbitrary data loss is possible if existing files are overwritten, although the restored database is complete.\n\nUndoing the effects of a restore is not possible; however, you can negate the effects of the data copy and rollforward by starting over on a per-file basis. To start over, restore the desired file and perform the rollforward again. For example, if you accidentally restored too many log backups and overshot your intended stopping point, you would have to restart the sequence.\n\nA restore sequence can be aborted and restarted by restoring the entire contents of the affected files.\n\nA revert database operation (specified using the DATABASE_SNAPSHOT option) takes a full source database back in time by reverting it to the time of a database snapshot, that is, overwriting the source database with data from the point in time maintained in the specified database snapshot. Only the snapshot to which you are reverting can currently exist. The revert operation then rebuilds the log (therefore, you cannot later roll forward a reverted database to the point of user error).\n\nData loss is confined to updates to the database since the snapshot's creation. The metadata of a reverted database is the same as the metadata at the time of snapshot creation. However, reverting to a snapshot drops all the full-text catalogs.\n\nReverting from a database snapshot is not intended for media recovery. Unlike a regular backup set, the database snapshot is an incomplete copy of the database files. If either the database or the database snapshot is corrupted, reverting from a snapshot is likely to be impossible. Furthermore, even when possible, reverting in the event of corruption is unlikely to correct the problem.\n\nReverting is unsupported under the following conditions:\n• The source database contains any read-only or compressed filegroups.\n• Any files are offline that were online when the snapshot was created.\n• More than one snapshot of the database currently exists.\n\nFor more information, see Revert a Database to a Database Snapshot.\n\nA backup operation may optionally specify passwords for a media set, a backup set, or both. When a password has been defined on a media set or backup set, you must specify the correct password or passwords in the RESTORE statement. These passwords prevent unauthorized restore operations and unauthorized appends of backup sets to media using SQL Server tools. However, password-protected media can be overwritten by the BACKUP statement's FORMAT option.\n• None For information specific to SQL Server backup and restore with the Microsoft Azure Blob Storage, see SQL Server Backup and Restore with Microsoft Azure Blob Storage.\n• None Backup and restore to S3-compatible object storage was introduced in SQL Server 2022 (16.x). For more information about restoring from S3-compatible object storage, see SQL Server backup and restore with S3-compatible object storage. Also review the option for SQL Server backup to URL for S3-compatible object storage.\n\nIf the database being restored does not exist, the user must have permissions to be able to execute RESTORE. If the database exists, RESTORE permissions default to members of the and fixed server roles and the owner ( ) of the database (for the option, the database always exists).\n\nRESTORE permissions are given to roles in which membership information is always readily available to the server. Because fixed database role membership can be checked only when the database is accessible and undamaged, which is not always the case when RESTORE is executed, members of the fixed database role do not have RESTORE permissions.\n\nAll the examples assume that a full database backup has been performed.\n\nThe RESTORE examples include the following:\n\nThe following example restores a full database backup from the logical backup device. For an example of creating this device, see Backup Devices.\n\nThe following example restores a full database backup followed by a differential backup from the backup device, which contains both backups. The full database backup to be restored is the sixth backup set on the device ( ), and the differential database backup is the ninth backup set on the device ( ). As soon as the differential backup is recovered, the database is recovered.\n\nThe following example uses the option to restart a operation interrupted by a server power failure.\n\nThe following example restores a full database and transaction log and moves the restored database into the directory.\n\nThe following example uses both the and statements to make a copy of the database. The statement causes the data and log file to be restored to the specified locations. The statement is used to determine the number and names of the files in the database being restored. The new copy of the database is named . For more information, see RESTORE FILELISTONLY.\n\nThe following example restores a database to its state as of on and shows a restore operation that involves multiple log backups. On the backup device, , the full database backup to be restored is the third backup set on the device ( ), the first log backup is the fourth backup set ( ), and the second log backup is the fifth backup set ( ).\n\nThe following example restores the transaction log to the mark in the marked transaction named .\n\nThe following example restores a full database backup from a backup device.\n\nThe following example restores a database named that has two files, one secondary filegroup, and one transaction log. The database uses the full recovery model.\n\nThe database backup is the ninth backup set in the media set on a logical backup device named . Next, three log backups, which are in the next three backup sets ( , , and ) on the device, are restored by using . After the last log backup is restored with , the database is recovered.\n\nIn the , notice that there are two types of options. The options preceding the backup device name specify the logical file names of the database files that are to be restored from the backup set; for example, . This backup set is not the first database backup in the media set; therefore, its position in the media set is indicated by using the option in the clause, .\n\nThe following example reverts a database to a database snapshot. The example assumes that only one snapshot currently exists on the database. For an example of how to create this database snapshot, see Create a Database Snapshot.\n\nFor more information, see Revert a Database to a Database Snapshot.\n\nThe three examples below involve the use of the Microsoft Azure storage service. The storage Account name is . The container for data files is called . The container for backup files is called . A stored access policy has been created with read, write, delete, and list, rights for each container. SQL Server credentials were created using Shared Access Signatures that are associated with the Stored Access Policies. For information specific to SQL Server backup and restore with the Microsoft Azure Blob Storage, see SQL Server Backup and Restore with Microsoft Azure Blob Storage.\n\nK1. Restore a full database backup from the Microsoft Azure storage service\n\n A full database backup, located at , of will be restored to . does not currently exist on the server.\n\nK2. Restore a full database backup from the Microsoft Azure storage service to local storage A full database backup, located at , of will be restored to local storage. does not currently exist on the server.\n\nK3. Restore a full database backup from local storage to the Microsoft Azure storage service\n\nIntroduced in SQL Server 2022 (16.x). For more information, see Create a Transact-SQL snapshot backup.\n\nL3. Restore from a snapshot backup and place database and log files in a new location\n• Back Up and Restore of SQL Server Databases\n• Back Up and Restore of System Databases (SQL Server)\n• Back Up and Restore Full-Text Catalogs and Indexes"
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/backup-restore/restore-database-options-page?view=sql-server-ver16",
        "document": "Use the Options page of the Restore Database dialog box to modify the behavior and outcome of the restore operation.\n\nTo use SQL Server Management Studio to restore a database backup\n\nTo modify aspects of the behavior of the restore operation, use the options of the Restore options panel.\n\nOverwrite the existing database [WITH REPLACE]\n\n The restore operation will overwrite the files of any database that is currently using the database name that you are specifying in the Restore tofield on the General page of the Restore Database dialog box. The files of the existing database will be overwritten even if you are restoring backups from a different database to the existing database name. Selecting this option is equivalent to using the REPLACE option in a RESTORE statement ( Transact-SQL).\n\nPreserve the replication settings [WITH KEEP_REPLICATION]\n\n Preserves the replication settings when doing a restore using a backup file of a published database to a server other than the server where the database was created. This option is relevant only if the database was replicated when the backup was created.\n\nThis option is available only with the Leave the database ready for use by rolling back the uncommitted transactions option (described later in this table), which is equivalent to restoring a backup with the RECOVERY option.\n\nSelecting this option is equivalent to using the KEEP_REPLICATION option in a RESTORE statement.\n\nWhen doing a restore using a backup file of a published database to the same server where the database was created and with same database name, KEEP_REPLICATION is not needed.\n\nWhen running RESTORE WITH RECOVERY and not restoring from a backup file, add the KEEP_REPLICATION option to preserve replication settings.\n\nFor more information, see Back Up and Restore Replicated Databases.\n\nRestrict access to the restored database [WITH RESTRICTED_USER]\n\n Makes the restored database available only to the members of db_owner, dbcreator, or sysadmin.\n\nSelecting this option is synonymous to using the RESTRICTED_USER option in a RESTORE statement.\n\nTo determine the state of the database after the store operation, you must select one of the options of the Recovery state panel.\n\nRESTORE WITH RECOVERY\n\n Recovers the database after restoring the final backup checked in the Backup sets to restoregrid on the General page. This is the default option and is equivalent to specifying WITH RECOVERY in a RESTORE statement ( Transact-SQL).\n\nRESTORE WITH NORECOVERY\n\n Leaves the database in the restoring state. This allows you to restore additional backups in the current recovery path. To recover the database, you will have to perform a restore operation by using the RESTORE WITH RECOVERY option (see the preceding option).\n\nThis option is equivalent to specifying WITH NORECOVERY in a RESTORE statement.\n\nIf you select this option, the Preserve replication settings option is unavailable.\n\nRESTORE WITH STANDBY\n\n Leaves the database in a standby state, in which the database is available for limited read-only access. This option is equivalent to specifying WITH STANDBY in a RESTORE statement.\n\nChoosing this option requires that you specify a standby file in the Standby file text box. The standby file allows the recovery effects to be undone.\n\nStandby file\n\n Specifies a standby file. You can browse for the standby file or enter its pathname directly in the text box.\n\nAllows you to designate that a tail-log backup be performed along with the database restore.\n\nTake tail-Log backup before restoring\n\n Check this box to designate that a tail-log backup should be performed.\n\nBackup file\n\n Specifies a backup file for the tail of the log. You can browse for the backup file or enter its name directly in the text box.\n\nAllows you to close existing database connections.\n\nClose existing connections\n\n Restore operations may fail if there are active connections to the database. Check the Close existing connections option to ensure that all active connections between Management Studio and the database are closed. This check box sets the database to single user mode before performing the restore operations, and sets the database to multi-user mode when complete.\n\nPrompt before restoring each backup\n\n Specifies that after each backup is restored, the Continue with Restore dialog box will be displayed to inquire whether you want to continue the restore sequence. This dialog box displays the name of the next media set (if known) and the name and description of the next backup set.\n\nThis option allows you to pause a restore sequence after restoring any of the backups. This option is particularly useful when you must swap tapes for different media sets; for example, when your server has only one tape device. When you are ready to proceed, click OK.\n\nYou can interrupt a restore sequence by clicking No. This leaves the database is in the restoring state. At your convenience, you can later continue the restore sequence by resuming with the next backup described in the Continue with Restore dialog box. The procedure restoring the next backup depends on whether it contains data or transaction log, as follows:\n• None If the next backup is a full or differential backup, use the Restore Database task again.\n• None If the next backup is a file backup, use the Restore Files and Filegroups task. For more information, see Restore Files and Filegroups (SQL Server).\n• None If the next backup is a log backup, use the Restore Transaction Log task. For information about resuming a restore sequence by restoring a transaction log, see Restore a Transaction Log Backup (SQL Server)."
    },
    {
        "link": "https://sqlbak.com/blog/complete-guide-to-sql-server-backup-and-restore-using-the-command-line",
        "document": "Creating backups of a SQL Server database is one of the most critical aspects of maintaining a system. There are various tools available for creating backups, such as SQL Server Management Studio, SqlBak, and SQLBackupAndFTP. However, performing backups via the command line interface can provide even more flexibility and customization options.\n\nPowerShell and batch scripts can be used to perform SQL Server backups via the command line interface. PowerShell scripts offer advanced functionality, while batch scripts are simpler and easier to use. Command line backups provide more flexibility and customization options than GUI-based tools.\n\nThis article provides an overview of the process involved in performing SQL Server backups via the command line interface and discusses the advantages of using PowerShell and batch scripts.\n\nTo perform a SQL Server backup via T-SQL, you can use the statement. This statement creates a full database backup of the specified database, which can be used to restore the database to its state at the time the backup was taken.\n\nThe basic syntax for backing up a database using T-SQL is as follows:\n• – The name of the database to be backed up.\n• – The path and filename of the backup file to be created. This can be any valid file path and filename.\n• – This option overwrites any existing backup file with the same name as the one being created.\n\nYou can modify the options in the clause to suit your specific backup needs. For example, you can enable compression to reduce the size of the backup file and display backup progress information using the and options, respectively.\n\nNote that in order to perform a backup using T-SQL, the user must have sufficient permissions to execute the statement and access the specified backup file path.\n\nTo restore a SQL Server database from a backup file, you can use the statement in T-SQL. The basic syntax for restoring a database from a backup file is as follows:\n• – The name of the database to be restored.\n• – The path and filename of the backup file to be restored.\n• – This option specifies that the database should be left in a recovered state, making it available for use.\n\nNote that in order to restore a database using T-SQL, the user must have sufficient permissions to execute the statement and access the specified backup file path.\n\nRestore DB with a Different Name\n\nRestoring a database with a different name can be useful when you need to create a copy of an existing database or restore a database to a different SQL Server instance. In this section, we will explore how to restore a SQL Server database with a different name using T-SQL.\n\nThe basic syntax for restoring a database with a different name is as follows:\n• – The new name of the database to be restored.\n• – The path and filename of the backup file to be restored.\n• – This option maps the logical file names in the backup file to the new physical file names and paths for the database files.\n\nWhen restoring a database with a different name, you need to use the option to specify the new physical file names and paths for the database files. This option maps the logical file names in the backup file to the new physical file names and paths. The option requires two parameters: the original logical file name and the new physical file path.\n\nTo determine the logical file names of the data and log files in the backup file, you can use the following T-SQL statement:\n\nThis statement retrieves a list of the files contained in the backup file, including the logical file names, sizes, and other attributes.\n\nFor example, to restore a database named “AdventureWorks” as “AdventureWorksCopy” with the data file moved to “C:\\Data\\AdventureWorksCopy.mdf” and the log file moved to “C:\\Log\\AdventureWorksCopy.ldf”, you would use the following T-SQL statement:\n\nThis section covers how to perform SQL Server backups using the command line interface. It includes examples of backup scripts and utilities that can help automate the backup process.\n\nIn this article, all connections to the database are made through Windows authentication. If you are using SQL Server authentication, you will need to specify the -U and -P parameters when using sqlcmd. When using the PowerShell module Backup-SqlDatabase for SQL Server authentication, connection data is passed through the -SqlCredential parameter. Be sure to pay attention to avoid errors when executing commands.\n\nis a command-line utility provided by Microsoft for interacting with SQL Server. It allows you to execute SQL statements, stored procedures, and script files, as well as perform various administrative tasks.\n\nTo perform a SQL Server backup using , you can use the option to specify a backup command to be executed. The basic syntax for backing up a database using is as follows:\n• – The name of the SQL Server instance to connect to.\n• – The backup command to be executed.\n\nTo restore a SQL Server database using , you can use the option to specify a restore command to be executed. The basic syntax for restoring a database using is as follows:\n• – The name of the SQL Server instance to connect to.\n• – The restore command to be executed.\n\nPowerShell is a command-line shell and scripting language developed by Microsoft. It includes several modules for interacting with SQL Server, making it a powerful tool for automating SQL Server tasks, including backups. One such module is the SQLServer module, which provides cmdlets for backup and restore operations.\n\nTo use the SQLServer module for backups, you first need to install it. You can install the module using the following command:\n\nOnce the module is installed, you can use the cmdlet to perform backups. The cmdlet allows you to specify the database to back up, the backup file path, and various backup options.\n\nTo backup all databases on a SQL Server instance, you can use the following command:\n\nReplace , , and with the appropriate values for your environment. The cmdlet retrieves all the databases on the specified SQL Server instance and passes them to the cmdlet for backup.\n\nHere’s an example of backing up all databases on a SQL Server instance:\n\nThis command backs up all databases on the “MSI” SQL Server instance to the “c:\\Backups2” folder.\n\nDifferential backups can significantly reduce the time and resources needed for backups, as they only include the changes made to the database since the last full backup. This can make the backup process more efficient and reduce the risk of data loss.\n\nTo perform a differential backup using PowerShell, use the cmdlet with the parameter. Here’s an example:\n\nThis command creates a differential backup of the “AdventureWorks” database and saves it to the “C:\\Backups\\AdventureWorks_diff.bak” file.\n\nIn addition to performing backups, PowerShell can also be used to restore SQL Server databases. The SQLServer module provides the cmdlet for restoring databases from backup files.\n\nThe basic syntax for restoring a database using PowerShell is as follows:\n• – The name of the SQL Server instance to connect to.\n• – The name of the database to be restored.\n• – The path and filename of the backup file to be restored.\n• – This option specifies that the existing database should be replaced by the restored database.\n\nHere’s an example of restoring a database using PowerShell:\n\nThis command restores the “MyDatabase” database from the backup file located at “C:\\Backup\\MyDatabase.bak” to the local SQL Server instance and replaces the existing database if it exists.\n\nTo restore a SQL Server database from a differential backup using PowerShell, you first need to restore the full backup with the option, then restore the differential backup.\n\nTo restore the full backup, use the cmdlet with the and options. Here’s an example:\n\nThis command restores the full backup of the “AdventureWorks” database from the “C:\\Backups\\AdventureWorks_full.bak” backup file to the local SQL Server instance and replaces the existing database if it exists.\n\nOnce the full backup is restored, you can restore the differential backup using the same cmdlet, without the option. Here’s an example:\n\nThis command restores the differential backup of the “AdventureWorks” database from the “C:\\Backups\\AdventureWorks_diff.bak” backup file to the local SQL Server instance.\n\nWhile one-line commands can be useful, backup scripts provide more options and can automate the backup process. Backup scripts can be written in different languages, such as batch, PowerShell, and Bash, depending on your needs and environment.\n\nA batch script can be a convenient way to automate SQL Server backups. The following example batch script creates a full database backup of the specified SQL Server database to a local disk, and deletes any backup files older than the specified number of days. If the backup fails, an error message is written to the Windows event log.\n\nTo use this script, replace the value of the variable with the name of the SQL Server database you want to backup, and replace the value of the variable with the appropriate path for storing the backup files. You can also adjust the value of the variable to change the number of days to keep backup files.\n\nThis section contains a PowerShell script that can be used to backup all SQL databases. The script performs the following tasks:\n• Gets a list of all SQL Server databases\n• Copies the backup file to the network drive\n• Sends an error notification if there was an error\n\nInstead of creating a complex PowerShell or Bash script on your own, you can use the utility.\n\nSqlBak-CLI is a simple command-line tool for creating database backups and sending them to storage. This utility can also restore the backups it creates. It can send backups to network folders, FTP, SFTP, and Backblaze. Documentation and download instructions can be found at this link.\n\nTo get started, simply create a JSON file that describes how to connect to the database and how to connect to the backup storage.\n\nBackup all databases to another server over SSH using SqlBak-CLI\n\nCreate a file called backup-job-settings.json with the connection details for the database and network folder.\n\nTo run the backup, execute the following command:\n\nRestore a database to another server over SSH using SqlBak-CLI\n\nTo run the restore, use the following command:\n\nOnce you have your backup scripts set up using SqlBak-CLI, PowerShell, or Batch, you can automate their execution using the Task Scheduler in Windows. This is particularly useful if you want to run backups on a regular schedule without having to remember to do it manually.\n\nTo set up an automated backup, follow these steps:\n• Open the Task Scheduler by typing “Task Scheduler” in the Start menu and clicking on the appropriate result.\n• Click “Create Basic Task” in the Actions pane on the right-hand side of the Task Scheduler window.\n• Name the task, and then click “Next.”\n• Choose the frequency of the backup, and then click “Next.” For example, if you want to back up your database every day at midnight, choose “Daily” and set the time to 12:00 AM.\n• Choose “Start a program” as the action for the task, and then click “Next.”\n• Enter the path to your backup script in the “Program/script” box. For SqlBak-CLI, it might be “sqlbak-cli.exe”. For PowerShell, it might be “powershell.exe”. For Batch, it might be “cmd.exe”.\n• For SqlBak-CLI:\n\n In the “Program/script” field, enter the path to the sqlbak-cli.exe file. For example: .\n\n In the “Add arguments (optional)” field, enter command and the path to your backup job JSON file: .\n• For PowerShell:\n\n In the “Program/script” field, enter the path to the powershell.exe file. For example: .\n\n In the “Add arguments (optional)” field, enter the path to your PowerShell script file, for example: .\n• For Batch:\n\n In the “Program/script” field, enter the path to the cmd.exe file. For example: .\n\n In the “Add arguments (optional)” field, enter the path to your batch file, for example: .\n• Click “Next,” review the details of the task, and then click “Finish.”\n\nYour backup script will now run automatically according to the schedule you set up.\n\nDatabase backup is not the only task that a DB administrator must perform. Running backups from the command line can be integrated with automated maintenance scripts for other parts of the infrastructure.\n\nUsually, a single command is not enough, and a script needs to be created. Batch scripts are simpler, but PowerShell provides more possibilities. However, a complex solution will require deep knowledge of PowerShell.\n\nInstead of writing a backup script from scratch, you can use the SqlBak-CLI utility. Simply substitute the correct values in the JSON file fields, and it will send the backup over SSH or upload it to FTP. It can also restore on demand.\n\nIf you don’t want to bother with command-line interfaces and scripts, you can check out the following solutions:\n• SQLBackupAndFTP – an application for backing up SQL Server and sending the backup to cloud storage."
    },
    {
        "link": "https://stackoverflow.com/questions/50856658/restore-database-with-replace-always-getting-error",
        "document": "on both servers to check that you are not restoring from a higher version to a lower version of sql server ?\n\nAlso , could you share the results of\n\nBased on the information provided, your restore statement should be :\n\nAlso I have noticed that your RESTORE FILELISTONLY has the backup file name as\n\nWhile in the restore database statement you are restoring from\n\nIs the change in directories and filename intentional ? You should be running both statements on a single backup file\n\nBased on information provided and further information on chat : the backup file being used is a differential backup and cannot be restored on anything else other than a restore of the full backup of the database taken prior to the diff backup."
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/backup-restore/back-up-and-restore-of-sql-server-databases?view=sql-server-ver16",
        "document": "Back Up and Restore of SQL Server Databases\n\nThis article describes the benefits of backing up SQL Server databases, basic backup and restore terms, and introduces backup and restore strategies for SQL Server and security considerations for SQL Server backup and restore.\n\nThe SQL Server backup and restore component provides an essential safeguard for protecting critical data stored in your SQL Server databases. To minimize the risk of catastrophic data loss, you need to back up your databases to preserve modifications to your data on a regular basis. A well-planned backup and restore strategy helps protect databases against data loss caused by a variety of failures. Test your strategy by restoring a set of backups and then recovering your database to prepare you to respond effectively to a disaster.\n\nIn addition to local storage for storing the backups, SQL Server also supports backup to and restore from Azure Blob Storage. For more information, see SQL Server Backup and Restore with Microsoft Azure Blob Storage. For database files stored using Azure Blob Storage, SQL Server 2016 (13.x) provides the option to use Azure snapshots for nearly instantaneous backups and faster restores. For more information, see File-Snapshot Backups for Database Files in Azure. Azure also offers an enterprise-class backup solution for SQL Server running in Azure VMs. A fully managed backup solution, it supports Always On availability groups, long-term retention, point-in-time recovery, and central management and monitoring. For more information, see Azure Backup for SQL Server in Azure VM.\n• None Backing up your SQL Server databases, running test restores procedures on your backups, and storing copies of backups in a safe, off-site location protects you from potentially catastrophic data loss. Backing up is the only way to protect your data. With valid backups of a database, you can recover your data from many failures, such as:\n• User errors, for example, dropping a table by mistake.\n• Hardware failures, for example, a damaged disk drive or permanent loss of a server.\n• Natural disasters. By using SQL Server Backup to Azure Blob Storage, you can create an off-site backup in a different region than your on-premises location, to use in the event of a natural disaster affecting your on-premises location.\n• None Additionally, backups of a database are useful for routine administrative purposes, such as copying a database from one server to another, setting up Always On availability groups or database mirroring, and archiving.\n\nback up [verb]\n\n The process of creating a backup [noun] by copying data records from a SQL Server database, or log records from its transaction log.\n\nbackup [noun]\n\n A copy of data that can be used to restore and recover the data after a failure. Backups of a database can also be used to restore a copy the database to a new location.\n\nbackup device\n\n A disk or tape device to which SQL Server backups are written and from which they can be restored. SQL Server backups can also be written to an Azure Blob Storage, and URL format is used to specify the destination and the name of the backup file. For more information, see SQL Server Backup and Restore with Microsoft Azure Blob Storage.\n\nbackup media\n\n One or more tapes or disk files to which one or more backups have been written.\n\ndata backup\n\n A backup of data in a complete database (a database backup), a partial database (a partial backup), or a set of data files or filegroups (a file backup).\n\ndatabase backup\n\n A backup of a database. Full database backups represent the whole database at the time the backup finished. Differential database backups contain only changes made to the database since its most recent full database backup.\n\ndifferential backup\n\n A data backup that is based on the latest full backup of a complete or partial database or a set of data files or filegroups (the differential base) and that contains only the data that has changed since that base.\n\nfull backup\n\n A data backup that contains all the data in a specific database or set of filegroups or files, and also enough log to allow for recovering that data.\n\nlog backup\n\n A backup of transaction logs that includes all log records that were not backed up in a previous log backup. (full recovery model)\n\nrecover\n\n To return a database to a stable and consistent state.\n\nrecovery\n\n A phase of database startup or of a restore with recovery that brings the database into a transaction-consistent state.\n\nrecovery model\n\n A database property that controls transaction log maintenance on a database. Three recovery models exist: simple, full, and bulk-logged. The recovery model of database determines its backup and restore requirements.\n\nrestore\n\n A multi-phase process that copies all the data and log pages from a specified SQL Server backup to a specified database, and then rolls forward all the transactions that are logged in the backup by applying logged changes to bring the data forward in time.\n\nBacking up and restoring data must be customized to a particular environment and must work with the available resources. Therefore, a reliable use of backup and restore for recovery requires a backup and restore strategy.A well-designed backup and restore strategy balances the business requirements for maximum data availability and minimum data loss, while considering the cost of maintaining and storing backups.\n\nA backup and restore strategy contains a backup portion and a restore portion. The backup part of the strategy defines the type and frequency of backups, the nature, and speed of the hardware that is required for them, how backups are to be tested, and where and how backup media is to be stored (including security considerations). The restore part of the strategy defines who is responsible for performing restores, how restores should be performed to meet your goals for database availability and minimizing data loss, and how restores are tested.\n\nDesigning an effective backup and restore strategy requires careful planning, implementation, and testing. Testing is required: you do not have a backup strategy until you have successfully restored backups in all the combinations that are included in your restore strategy and have tested the restored database for physical consistency. You must consider a variety of factors. These include:\n• None The goals of your organization regarding your production databases, especially the requirements for availability and protection of data from loss or damage.\n• None The nature of each database: its size, its usage patterns, the nature of its content, the requirements for its data, and so on.\n• None Constraints on resources, such as: hardware, personnel, space for storing backup media, the physical security of the stored media, and so on.\n\nThe accounts that perform backup or restore operations should not be granted more privileges than necessary. Review backup and restore for specific permission details. It's recommended that backups are encrypted and, if possible, compressed.\n\nTo ensure security, backup files should have extensions that follow proper conventions:\n• Database backup files should have the extension\n• Log backup files should have the extension.\n\nBackup and restore operations occur within the context of a recovery model. A recovery model is a database property that controls how the transaction log is managed. Thus, the recovery model of a database determines what types of backups and restore scenarios are supported for the database, and what the size of the transaction log backups would be. Typically, a database uses either the simple recovery model or the full recovery model. The full recovery model can be augmented by switching to the bulk-logged recovery model before bulk operations. For an introduction to these recovery models and how they affect transaction log management, see The Transaction Log (SQL Server)\n\nThe best choice of recovery model for the database depends on your business requirements. To avoid transaction log management and simplify backup and restore, use the simple recovery model. To minimize work-loss exposure, at the cost of administrative overhead, use the full recovery model. To minimize impact on log size during bulk-logged operations while at the same time allowing for recoverability of those operations, use bulk-logged recovery model. For information about the effect of recovery models on backup and restore, see Backup Overview (SQL Server).\n\nAfter you have selected a recovery model that meets your business requirements for a specific database, you have to plan and implement a corresponding backup strategy. The optimal backup strategy depends on a variety of factors, of which the following are especially significant:\n• None How many hours a day do applications have to access the database? If there is a predictable off-peak period, we recommend that you schedule full database backups for that period.\n• None How frequently are changes and updates likely to occur? If changes are frequent, consider the following:\n• None Under the simple recovery model, consider scheduling differential backups between full database backups. A differential backup captures only the changes since the last full database backup.\n• None Under the full recovery model, you should schedule frequent log backups. Scheduling differential backups between full backups can reduce restore time by reducing the number of log backups you have to restore after restoring the data.\n• None Are changes likely to occur in only a small part of the database or in a large part of the database? For a large database in which changes are concentrated in a part of the files or filegroups, partial backups and or full file backups can be useful. For more information, see Partial Backups (SQL Server) and Full File Backups (SQL Server).\n• None How much disk space will a full database backup require?\n• None How far in the past does your business require to maintain backups? Make sure you have a proper backup schedule established according to the needs of the application and business requirements. As the backups get old, the risk of data loss is higher unless you have a way to regenerate all the data till the point of failure. Before you choose to dispose of old backups due to storage resource limitations, consider if recoverability is required that far in the past\n\nBefore you implement a backup and restore strategy, you should estimate how much disk space a full database backup will use. The backup operation copies the data in the database to the backup file. The backup contains only the actual data in the database and not any unused space. Therefore, the backup is usually smaller than the database itself. You can estimate the size of a full database backup by using the sp_spaceused system stored procedure. For more information, see sp_spaceused (Transact-SQL).\n\nPerforming a backup operation has minimal effect on transactions that are running; therefore, backup operations can be run during regular operations. You can perform a SQL Server backup with minimal effect on production workloads.\n\nAfter you decide what types of backups you require and how frequently you have to perform each type, we recommend that you schedule regular backups as part of a database maintenance plan for the database. For information about maintenance plans and how to create them for database backups and log backups, see Use the Maintenance Plan Wizard.\n\nYou do not have a restore strategy until you have tested your backups. It is very important to thoroughly test your backup strategy for each of your databases by restoring a copy of the database onto a test system. You must test restoring every type of backup that you intend to use. It is also recommended that once you restore the backup, you perform database consistency checks via DBCC CHECKDB of the database to validate the backup media was not damaged.\n\nUse the verification options provided by the backup utilities (BACKUP T-SQL command, SQL Server Maintenance Plans, your backup software or solution, etc.). For an example, see [RESTORE VERIFYONLY] (../t-sql/statements/restore-statements-verifyonly-transact-sql.md) Use advanced features like BACKUP CHECKSUM to detect problems with the backup media itself. For more information see Possible Media Errors During Backup and Restore (SQL Server)\n\nWe recommend that you document your backup and restore procedures and keep a copy of the documentation in your run book. We also recommend that you maintain an operations manual for each database. This operations manual should document the location of the backups, backup device names (if any), and the amount of time that is required to restore the test backups.\n\nBackup and restore operations can take a considerable amount of time due to the size of a database and the complexity of the operations involved. When issues arise with either operation, you can use the backup_restore_progress_trace extended event to monitor progress live. For more information about extended events, see extended events.\n• None Specify a Disk or Tape As a Backup Destination (SQL Server)\n• None View the Contents of a Backup Tape or File (SQL Server)\n• None View the Data and Log Files in a Backup Set (SQL Server)\n• None View the Properties and Contents of a Logical Backup Device (SQL Server)\n• None Use Resource Governor to Limit CPU Usage by Backup Compression (Transact-SQL)\n• None Back Up the Transaction Log When the Database Is Damaged (SQL Server)\n• None Enable or Disable Backup Checksums During Backup or Restore (SQL Server)\n• None Specify Whether a Backup or Restore Operation Continues or Stops After Encountering an Error (SQL Server)\n• None Restore a Database to the Point of Failure Under the Full Recovery Model (Transact-SQL)\n\nBackup Overview (SQL Server)\n\n Restore and Recovery Overview (SQL Server)\n\n BACKUP (Transact-SQL)\n\n RESTORE (Transact-SQL)\n\n Backup and Restore of Analysis Services Databases\n\n Back Up and Restore Full-Text Catalogs and Indexes\n\n Back Up and Restore Replicated Databases\n\n The Transaction Log (SQL Server)\n\n Recovery Models (SQL Server)\n\n Media Sets, Media Families, and Backup Sets (SQL Server)"
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/relational-databases/backup-restore/restore-and-recovery-overview-sql-server?view=sql-server-ver16",
        "document": "This article provides an overview of the database restore and recovery process for SQL Server.\n\nTo recover a SQL Server database from a failure, a database administrator has to restore a set of SQL Server backups in a logically correct and meaningful restore sequence. The SQL Server restore and recovery process supports restoring data from backups of a whole database, a data file, or a data page, as follows:\n• The whole database is restored and recovered, and the database is offline during the restore and recovery operations.\n• A data file or a set of files is restored and recovered. During a file restore, the filegroups that contain the files are automatically offline during the restore. Any attempt to access an offline filegroup causes an error.\n• Under the full recovery model or bulk-logged recovery model, you can restore individual pages. Page restores can be performed on any database, regardless of the number of filegroups.\n\nSQL Server backup and restore work across all supported operating systems. For information about the supported operating systems, see Hardware and software requirements. For information about support for backups from earlier versions of SQL Server, see the Compatibility Support section of RESTORE.\n\nA restore scenario in SQL Server is the process of restoring data from one or more backups and then recovering the database. The supported restore scenarios depend on the recovery model of the database and the edition of SQL Server.\n\nThe following table introduces the possible restore scenarios that are supported for different recovery models.\n\n1 Online restore is supported only in Enterprise edition.\n\nTo perform a file restore, the Database Engine executes two steps:\n• None Copies the data from the backup devices to the database files.\n\nTo perform a database restore, the Database Engine executes three steps:\n• None Creates the database and transaction log files if they don't already exist.\n• None Copies all the data, log, and index pages from the backup media of a database to the database files.\n• None Applies the transaction log, in what is known as the recovery process.\n\nRegardless of how data is restored, before a database can be recovered, the SQL Server Database Engine guarantees that the whole database is logically consistent. For example, if you restore a file, you can't recover it and bring it online until it rolls forward far enough to be consistent with the database.\n\nRestoring and recovering files or pages, instead of the whole database, provides the following advantages:\n• None Restoring less data reduces the time required to copy and recover it.\n• None On SQL Server restoring files or pages might allow other data in the database to remain online during the restore operation.\n\nFor most restore scenarios, it is necessary to apply a transaction log backup and allow the SQL Server Database Engine to run the recovery process for the database to be brought online. Recovery is the process used by SQL Server for each database to start in a transactionally consistent - or clean - state.\n\nIf there's a failover or other non-clean shutdown, the databases might be left in a state where some modifications were never written from the buffer cache to the data files, and there might be some modifications from incomplete transactions in the data files. When an instance of SQL Server is started, it runs a recovery of each database, which consists of three phases, based on the last database checkpoint:\n• None Phase 1 is the Analysis Phase that analyzes the transaction log to determine what is the last checkpoint, and creates the Dirty Page Table (DPT) and the Active Transaction Table (ATT). The DPT contains records of pages that were dirty at the time the database was shut down. The ATT contains records of transactions that were active at the time the database wasn't cleanly shut down.\n• None Phase 2 is the Redo Phase that rolls forward every modification recorded in the log that might not have been written to the data files at the time the database was shut down. The minimum log sequence number (minLSN) required for a successful database-wide recovery is found in the DPT, and marks the start of the redo operations needed on all dirty pages. At this phase, the SQL Server Database Engine writes to disk all dirty pages belonging to committed transactions.\n• None Phase 3 is the Undo Phase that rolls back incomplete transactions found in the ATT to make sure the integrity of the database is preserved. After rollback, the database goes online, and no more transaction log backups can be applied to the database.\n\nInformation about the progress of each database recovery stage is logged in the SQL Server error log. The database recovery progress can also be tracked using Extended Events. For more information, see the blog post New extended events for database recovery progress.\n\nThe restore operations that are available for a database depend on its recovery model. The following table summarizes whether and to what extent each of the recovery models supports a given restore scenario.\n\n1 Available only in the Enterprise edition of SQL Server\n\n2 For the required conditions, see Restore Restrictions Under the Simple Recovery Model, later in this article.\n\nThe simple recovery model imposes the following restrictions on restore operations:\n• None File restore and piecemeal restore are available only for read-only secondary filegroups. For information about these restore scenarios, see File Restores (Simple Recovery Model) and Piecemeal Restores (SQL Server).\n\nIf any of these restrictions are inappropriate for your recovery needs, we recommend that you consider using the full recovery model. For more information, see Backup overview (SQL Server).\n\nThis section discusses restore considerations that are unique to bulk-logged recovery model, which is intended exclusively as a supplement to the full recovery model.\n\nGenerally, the bulk-logged recovery model is similar to the full recovery model, and the information described for the full recovery model also applies to both. However, point-in-time recovery and online restore are affected by the bulk-logged recovery model.\n\nIf a log backup taken under the bulk-logged recovery model contains bulk-logged changes, point-in-time recovery isn't allowed. Trying to perform point-in-time recovery on a log backup that contains bulk changes, causes the restore operation to fail.\n\nAn online restore sequence works only if the following conditions are met:\n• None All required log backups must have been taken before the restore sequence starts.\n• None Bulk changes must be backed before starting the online restore sequence.\n• None If bulk changes exist in the database, all files must be either online or defunct (that is, no longer part of the database).\n\nIf these conditions aren't met, the online restore sequence fails.\n\nFor information about how to perform an online restore, see Online Restore (SQL Server).\n\nThe Database Recovery Advisor facilitates constructing restore plans that implement optimal correct restore sequences. Many known database restore issues and enhancements requested by customers have been addressed. Major enhancements introduced by the Database Recovery Advisor include:\n• None Restore-plan algorithm: The algorithm used to construct restore plans has improved significantly, particularly for complex restore scenarios. Many edge cases, including forking scenarios in point-in-time restores, are handled more efficiently than in previous versions of SQL Server.\n• None Point-in-time restores: The Database Recovery Advisor greatly simplifies restoring a database to a given point in time. A visual backup timeline significantly enhances support for point-in-time restores. This visual timeline allows you to identify a feasible point in time as the target recovery point for restoring a database. The timeline facilitates traversing a forked recovery path (a path that spans recovery forks). A given point-in-time restore plan automatically includes the backups that are relevant to the restoring to your target point in time (date and time). For more information, see Restore a SQL Server Database to a Point in Time (Full Recovery Model).\n\nFor more information, see about the Database Recovery Advisor, see the following SQL Server Manageability blogs:\n\nAccelerated database recovery (ADR) is available beginning in SQL Server 2019 (15.x). ADR is also available in Azure SQL Database, Azure SQL Managed Instance, Azure Synapse Analytics (dedicated SQL pool only), and SQL database in Microsoft Fabric. Accelerated database recovery greatly improves database availability, especially in the presence of long-running transactions, by redesigning the SQL Server Database Engine recovery process. A database with ADR enabled completes the recovery process significantly faster after a failover or other unexpected shutdown. When ADR is enabled, rollback of canceled long-running transactions completes instantaneously.\n\nYou can enable ADR per-database in SQL Server 2019 (15.x) and later versions using the following syntax:\n• Back Up and Restore of SQL Server Databases"
    },
    {
        "link": "https://sqlshack.com/managing-sql-server-express-databases",
        "document": "If you are not able to spend money on your small databases, SQL Server Express edition is the solution for you. This edition will provide you with a basic storage option and this article is to examine what maintenance tasks you need to perform to manage SQL Express effectively.\n\nThe major limitation in the SQL Express database is that the storage limit which is 10 GB. However, it is important to note that this limitation is on the data file and the log file is excluded from this limitation. This means log files can be in any size.\n\nFollowing is the Disk Usage report of the Express database which describes the limitations on the data and log files.\n\nYou will see that database is 24 GB which is clearly over the 10 GB limitation.\n\nSince there is no limitation for the Express database transaction log file, you can leave the express database recovery model in either full or bulk logged. Most of the users configure the recovery model of the database in Express edition as Simple to reduce the transaction log file size. With this configuration, you are dropping the options of transactional log backup and importantly you will not have the option of point in time recovery. These configurations leave databases in a risk state.\n\nSince log file size will not count towards the database size, you can leave the database recovery model as Full or bulk-logged without impacting important recovery features as shown in the below figure.\n\nWhat data to store in Express\n\nSince you have a limitation of 10 GB for data, at the design stage itself, you need to look at what type of data that you are storing in your database. You need to look at database distribution strategies to maintain the 10 GB limit. You can distribute your data from a functional perspective. For example, if you are running an Accounting system, you can create different databases for Accounts Payable, Accounts Receivable, Inventory and General Ledger domains, etc. Since the upper limit for the number of databases in a SQL Server Express edition is more than 32,000, you can create multiple databases in an express instance.\n\nSimilarly, you can design your database so that data is kept for only a specific time period preferably for a year. Whatever the option that you follow, it must be taken at an earlier stage of the system design in order to design and develop the relevant application.\n\nApart from the design strategies, you need to look at the data archiving strategies. In the standard or enterprise edition, you can simply archive the data into the same database. However, in the SQL Server Express edition, it is essential to archive the data into a different database. When data is in another database, the restoring process is much complex. Therefore, in the Express databases, you need to focus on design as well as for the archiving process of data.\n\nYou need to choose data types very carefully so that you can limit disk usage. For example, if you can use tinyint instead of int, you will be saving 3 bytes per row. Similarly, you should not use Unicode data types such as nvarchar, nchar unnecessary.\n\nIndexes are implemented to improve the database performance of queries. However, indexes will consume disk space. Therefore, you need to manage indexes optimally. If there are no used or less used indexes, it is better to drop those indexes in order to retain the disk space.\n\nThis article, How to identify and monitor unused indexes in SQL Server, explains how to work with unused indexes in SQL Server. However, though indexes are rarely used, that does not say that they should be dropped. Thus, you need to look at what indexes to be dropped with the consultation of the system developers.\n\nIndex fragmentation is another phenomenon that will result in unnecessary disk space. There are two types of fragmentations, those are Internal and External Fragmentations. External fragmentation is the different order of physical and logical ordering of data pages, that will not be accounted for the additional disk space.\n\nOn the other hand, Internal fragmentation means empty spaces in data or index pages. This will account for additional disk spaces. Therefore, it is important to rebuild the indexes regularly in SQL Express databases. Since Index Reorganize will fix the external fragmentation only, it will not have any impact on the disk space. Therefore, it is essential to perform an index rebuild. Since index rebuild is similar to drop and recreate of indexes, rebuild of indexes will consume resources from the database. This means that you need to schedule the index rebuild operation at the least used time of the SQL Server Express database.\n\nFurther, you can reduce the index sizes by removing columns in order to reduce disk usage. However, this will not be a major impact on disk space anyway.\n\nWhen you archive your data or when you perform index rebuild, database space will not be released to the operating system, but it will be shown as an unallocated space in the Disk Usage report. However, this will not be an issue as new data will consume the unallocated space. Even if you want to remove the unallocated space, you can use database shrink in order to remove the unallocated space as shown below\n\nAnother limitation in SQL Server Express is the database memory which is around 1 GB. Though there is nothing much you need to manage on the memory side of the database, you need to limit your query output and better indexes. As you can imagine, memory plays a vital role when it comes to database performance. Therefore, in the SQL Server Express edition, you need to manage your queries efficiently.\n\nEven if it is SQL Server Express, it is your data. Hence you need to maintain proper database backups. Like other databases, you need to perform full database backups. In order to maintain the point time recovery option, you should take log backups. Further, to improve the restoring process, you can implement differential backups as well.\n\nSince the SQL Server express database will have a maximum of 10 GB size, performing a full backup won’t impact server resources. Since the database is not too large, a full backup will not consume much time as well. Considering all these situations, in most of the real-world implementations, you don’t need differential backups and you can maintain only full and transactional log backups in SQL Express databases.\n\nSince SQL Server Express does not have SQL Server Agent capabilities, you will not be able to create scheduled tasks from SQL Server Agent Jobs. Since database backups should be created in a proper schedule, it will be better to include some other means such as customized applications to create database backups on a defined schedule. The same scenario is applicable for index rebuilding as well.\n\nIn this article, we examined how to manage the SQL Express database. Since SQL Server Express does not require any licensing cost, many small scall users tend to use the Express databases. However, due to the main limitation which 10GB for data size, few other tasks need to be done starting from the design stage.\n\nAt the design stage, you need to look at the distributed database design pattern and better data archiving strategies. Since Index maintaining is another important factor, it is important to index rebuild regularly and monitors unused or underused non-clustered indexes.\n\nMemory is another limitation in SQL Server Express edition where it supports only 1.4 GB of database memory. To efficiently handle database memory, you need to write optimal queries and include optimal indexes.\n\nWe also looked at the database backup strategies for the SQL Server Express database and conclude that Express databases do not need differential backups, but it still needs full and transaction log backups."
    },
    {
        "link": "https://reddit.com/r/SQLServer/comments/1glubi1/how_in_practice_should_backups_be_done",
        "document": "Hey! What are best practices to backup the database? Should I introduce: disk mirroring in RAID1, external app like bacula/ rsnapshot, or maybe there is some built in back up mechanism?\n\nWe run critical for us database (ERP, wms) on self hosted mssql server 2022 within docker container, ubuntu sever. Backup's were done everyday (with ERP built into tool) and we thought that one day data loss ain't that much, but in fact it is a lot! So I am looking for some better solutions."
    },
    {
        "link": "https://community.spiceworks.com/t/move-sql-server-2019-to-new-server/929669",
        "document": "So I have SQL Server 2019 on an SBS 2016 server that I can finally move to it’s own server. This SQL server was first SQL Express 2014 and upgraded to 2019 SQL Server. What is the best way to move everything in SQL to the new server? Backup each database and restore them on the new server? Does that work with the System Databases? Also, is there a way to export the SQL Agent Jobs to the new server? Is the Microsoft Database Migration Assistant the way to go to achieve all the above? Last question is when I install SQL Server on the new server can I change the Instance name? Will that mess up the restore?\n\nYou can detach and attach the databases or back up and restore. Doing a restore is a good test of your backup and restore capability as well. I wouldn’t recommend restoring the system db’s to the new server because they are system DB’s. The only one that really matters is msdb as that has all the triggers and so on. If you don’t have any triggers or can move them then leave the new system db’s as si.\n\nMany different ways to do this, and also depends on how your IT resources are set up, and your time constraints.\n\n For example do you use VMs or bare-metal servers? One way to get close to the same on your target SQL is to do a VM copy of the source to a new VM, and then upgrade the target VM to the desired SQL version. This however also copies all of your remnant and ‘garbage’ data (since you state your source SQL was upgraded a few times). SQL upgrades can leave behind lots of unused stuff that is hard to delete. Another way is to create a new VM for your target SQL and then copy over your databases (backup/restore) and other settings (jobs, accounts, etc) using scripts. The PowerSHell DBATools kit can help here as well as many MS SQL tools. This gives you a nice new target SQL system without any older remnants from the older SQL system. Be sure to leave your source SQL system intact and unchanged until you have a working target SQL system. You WILL be doing the source SQL → target SQL transfer a few times since you will surely make some mistakes the first time around.\n\nMany different ways to do this, and also depends on how your IT resources are set up, and your time constraints.\n\n For example do you use VMs or bare-metal servers? One way to get close to the same on your target SQL is to do a VM copy of the source to a new VM, and then upgrade the target VM to the desired SQL version. This however also copies all of your remnant and ‘garbage’ data (since you state your source SQL was upgraded a few times). SQL upgrades can leave behind lots of unused stuff that is hard to delete. Another way is to create a new VM for your target SQL and then copy over your databases (backup/restore) and other settings (jobs, accounts, etc) using scripts. The PowerSHell DBATools kit can help here as well as many MS SQL tools. This gives you a nice new target SQL system without any older remnants from the older SQL system. Be sure to leave your source SQL system intact and unchanged until you have a working target SQL system. You WILL be doing the source SQL → target SQL transfer a few times since you will surely make some mistakes the first time around. Seems like I will be making a backup of the 5 databases once I’m ready and restore those to the new SQL server. Are there problems with use the Data Migration Assistant? Overview of Data Migration Assistant (SQL Server) - SQL Server | Microsoft Learn That says it moves over: Schema of databases, Data and users, Server roles, SQL Server and Windows logins So does changing Instance names depend on the application that is using SQL server?\n\nMany different ways to do this, and also depends on how your IT resources are set up, and your time constraints.\n\n For example do you use VMs or bare-metal servers? One way to get close to the same on your target SQL is to do a VM copy of the source to a new VM, and then upgrade the target VM to the desired SQL version. This however also copies all of your remnant and ‘garbage’ data (since you state your source SQL was upgraded a few times). SQL upgrades can leave behind lots of unused stuff that is hard to delete. Another way is to create a new VM for your target SQL and then copy over your databases (backup/restore) and other settings (jobs, accounts, etc) using scripts. The PowerSHell DBATools kit can help here as well as many MS SQL tools. This gives you a nice new target SQL system without any older remnants from the older SQL system. Be sure to leave your source SQL system intact and unchanged until you have a working target SQL system. You WILL be doing the source SQL → target SQL transfer a few times since you will surely make some mistakes the first time around. Seems like I will be making a backup of the 5 databases once I’m ready and restore those to the new SQL server. Are there problems with use the Data Migration Assistant? Overview of Data Migration Assistant (SQL Server) - SQL Server | Microsoft Learn That says it moves over: Schema of databases, Data and users, Server roles, SQL Server and Windows logins So does changing Instance names depend on the application that is using SQL server? Yes, I have used MS Data Migration Assistant a few times, however not recently. I suggest you do at least one dry run of setting up your new SQL server, and migrating data over to it from your source SQL server.\n\n Too bad you are not using a VM system - that makes it really easy to recover from mistakes or go back to a fresh install.\n\n I would at least do a complete system image backup of your target SQL server AFTER you have installed the Windows OS and SQL Server on it (before you migrate any databases). That way you can then just restore this system image onto your target server to start over again (instead of reformatting and reinstalling). If the instance name changes (ie from default instance on MYSERVER1 to named instance MYSERVER1\\SQL1), yes, you will need to change the application that connects to this SQL server.\n\nI prefer detaching, copying, and attaching the databases to a fresh new SQL instance. That is MUCH quicker than any other option and usually works like a charm. Moreover, this procedure does not impact the source server in any way, so you can clean everything and start again from scratch anytime or just bring the whole production back in seconds if the migration fails entirely. SQL Agent jobs can be exported and imported using SQL Management Studio. SQL native backup and restore routines are much slower."
    }
]