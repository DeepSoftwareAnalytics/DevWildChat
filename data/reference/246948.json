[
    {
        "link": "https://vuejs.org/api/built-in-directives.html",
        "document": "\n• None works by setting the element's textContent property, so it will overwrite any existing content inside the element. If you need to update the part of , you should use mustache interpolations instead.\n• None Contents of are inserted as plain HTML - Vue template syntax will not be processed. If you find yourself trying to compose templates using , try to rethink the solution by using components instead. Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS attacks. Only use on trusted content and never on user-provided content. In Single-File Components, styles will not apply to content inside , because that HTML is not processed by Vue's template compiler. If you want to target content with scoped CSS, you can instead use CSS modules or an additional, global element with a manual scoping strategy such as BEM.\n\nToggle the element's visibility based on the truthy-ness of the expression value.\n• None works by setting the CSS property via inline styles, and will try to respect the initial value when the element is visible. It also triggers transitions when its condition changes.\n\nConditionally render an element or a template fragment based on the truthy-ness of the expression value.\n• None When a element is toggled, the element and its contained directives / components are destroyed and re-constructed. If the initial condition is falsy, then the inner content won't be rendered at all. Can be used on to denote a conditional block containing only text or multiple elements. This directive triggers transitions when its condition changes. When used together, has a higher priority than . We don't recommend using these two directives together on one element — see the list rendering guide for details.\n\nDenote the \"else block\" for or a / chain.\n• None\n• None Restriction: previous sibling element must have or .\n• None Can be used on to denote a conditional block containing only text or multiple elements.\n• None Now you see me\n\nDenote the \"else if block\" for . Can be chained.\n• None\n• None Restriction: previous sibling element must have or .\n• None Can be used on to denote a conditional block containing only text or multiple elements.\n\nRender the element or template block multiple times based on the source data.\n• None The directive's value must use the special syntax to provide an alias for the current element being iterated on: Alternatively, you can also specify an alias for the index (or the key if used on an Object): The default behavior of will try to patch the elements in-place without moving them. To force it to reorder elements, you should provide an ordering hint with the special attribute: can also work on values that implement the Iterable Protocol, including native and .\n\nAttach an event listener to the element.\n• None\n• - only trigger handler if event was dispatched from this element.\n• - only trigger handler on certain keys.\n• - trigger handler at most once.\n• - only trigger handler for right button mouse events.\n• None The event type is denoted by the argument. The expression can be a method name, an inline statement, or omitted if there are modifiers present. When used on a normal element, it listens to native DOM events only. When used on a custom element component, it listens to custom events emitted on that child component. When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special property: . also supports binding to an object of event / listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.\n• None <!-- the click event will be triggered at most once --> Listening to custom events on a child component (the handler is called when \"my-event\" is emitted on the child):\n\nDynamically bind one or more attributes, or a component prop to an expression.\n• None\n• or (when using modifier)\n• Omitting value (when attribute and bound value has the same name, requires 3.4+)\n• None Expects: any (with argument) | Object (without argument)\n• None\n• - transform the kebab-case attribute name into camelCase.\n• - force a binding to be set as a DOM property (3.2+).\n• - force a binding to be set as a DOM attribute (3.2+).\n• None When used to bind the or attribute, supports additional value types such as Array or Objects. See linked guide section below for more details. When setting a binding on an element, Vue by default checks whether the element has the key defined as a property using an operator check. If the property is defined, Vue will set the value as a DOM property instead of an attribute. This should work in most cases, but you can override this behavior by explicitly using or modifiers. This is sometimes necessary, especially when working with custom elements. When used for component prop binding, the prop must be properly declared in the child component. When used without an argument, can be used to bind an object containing attribute name-value pairs.\n• None <!-- prop binding. \"prop\" must be declared in the child component. --> <!-- pass down parent props in common with a child component --> The modifier also has a dedicated shorthand, : The modifier allows camelizing a attribute name when using in-DOM templates, e.g. the SVG attribute: is not needed if you are using string templates, or pre-compiling the template with a build step.\n• None Expects: varies based on value of form inputs element or output of components\n• None\n• - listen to events instead of\n\nDenote named slots or scoped slots that expect to receive props.\n• None Expects: JavaScript expression that is valid in a function argument position, including support for destructuring. Optional - only needed if expecting props to be passed to the slot.\n\nSkip compilation for this element and all its children.\n• None Inside the element with , all Vue template syntax will be preserved and rendered as-is. The most common use case of this is displaying raw mustache tags.\n• None will not be compiled }}</\n\nRender the element and component once only, and skip future updates.\n• None On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance. >This will never change: {{msg}}</ Since 3.2, you can also memoize part of the template with invalidation conditions using .\n• None Memoize a sub-tree of the template. Can be used on both elements and components. The directive expects a fixed-length array of dependency values to compare for the memoization. If every value in the array was the same as last render, then updates for the entire sub-tree will be skipped. For example: When the component re-renders, if both and remain the same, all updates for this and its children will be skipped. In fact, even the Virtual DOM VNode creation will also be skipped since the memoized copy of the sub-tree can be reused. It is important to specify the memoization array correctly, otherwise we may skip updates that should indeed be applied. with an empty dependency array ( ) would be functionally equivalent to . is provided solely for micro optimizations in performance-critical scenarios and should be rarely needed. The most common case where this may prove helpful is when rendering large lists (where ): When the component's state changes, a large amount of VNodes will be created even though most of the items remained exactly the same. The usage here is essentially saying \"only update this item if it went from non-selected to selected, or the other way around\". This allows every unaffected item to reuse its previous VNode and skip diffing entirely. Note we don't need to include in the memo dependency array here since Vue automatically infers it from the item's . When using with , make sure they are used on the same element. does not work inside . can also be used on components to manually prevent unwanted updates in certain edge cases where the child component update check has been de-optimized. But again, it is the developer's responsibility to specify correct dependency arrays to avoid skipping necessary updates.\n\nUsed to hide un-compiled template until it is ready.\n• None This directive is only needed in no-build-step setups. When using in-DOM templates, there can be a \"flash of un-compiled templates\": the user may see raw mustache tags until the mounted component replaces them with rendered content. will remain on the element until the associated component instance is mounted. Combined with CSS rules such as , it can be used to hide the raw templates until the component is ready.\n• None The will not be visible until the compilation is done."
    },
    {
        "link": "https://stackoverflow.com/questions/73805577/how-to-manage-v-on-in-dynamic-components-component-is-currentpage-etc",
        "document": "I am learning dynamic component rendering in Vue 3 Options API and so far I've understood how :is=\"currentPage\" works as well as v-bind=\"currentProps\". But I can't figure out what to do with my event-listeners in the following case:\n\nLet's say I have 3 components: A, B, C. Every component has one or more events, for now for demonstration purposes a button and when it is clicked it renders the next page:\n\nA -> B, B -> C, C -> A etc.\n\nThe static form looks like this:\n\nHere the dynamic version and my problem: I can dynamically pick \"currentPage\" as well as \"currentProps\" but how to bind the right event-listener to \"currentPage\"?"
    },
    {
        "link": "https://vuejs.org/guide/reusability/custom-directives",
        "document": "In addition to the default set of directives shipped in core (like or ), Vue also allows you to register your own custom directives.\n\nWe have introduced two forms of code reuse in Vue: components and composables. Components are the main building blocks, while composables are focused on reusing stateful logic. Custom directives, on the other hand, are mainly intended for reusing logic that involves low-level DOM access on plain elements.\n\nA custom directive is defined as an object containing lifecycle hooks similar to those of a component. The hooks receive the element the directive is bound to. Here is an example of a directive that adds a class to an element when it is inserted into the DOM by Vue:\n\nIn , any camelCase variable that starts with the prefix can be used as a custom directive. In the example above, can be used in the template as . If you are not using , custom directives can be registered using the option:\n\nIt is also common to globally register custom directives at the app level:\n\nWhen to use custom directives ​\n\nCustom directives should only be used when the desired functionality can only be achieved via direct DOM manipulation.\n\nA common example of this is a custom directive that brings an element into focus.\n\nThis directive is more useful than the attribute because it works not just on page load - it also works when the element is dynamically inserted by Vue!\n\nDeclarative templating with built-in directives such as is recommended when possible because they are more efficient and server-rendering friendly.\n\nA directive definition object can provide several hook functions (all optional):\n\n// see below for details on arguments // called right before the element is inserted into the DOM. // and all its children are mounted. // called before the parent component is updated // called after the parent component and // all of its children have updated // called before the parent component is unmounted // called when the parent component is unmounted\n• None : the element the directive is bound to. This can be used to directly manipulate the DOM.\n• None : an object containing the following properties.\n• : The value passed to the directive. For example in , the value would be .\n• : The previous value, only available in and . It is available whether or not the value has changed.\n• : The argument passed to the directive, if any. For example in , the arg would be .\n• : An object containing modifiers, if any. For example in , the modifiers object would be .\n• : The instance of the component where the directive is used.\n• None : the VNode representing the bound element from the previous render. Only available in the and hooks.\n\nAs an example, consider the following directive usage:\n\nThe argument would be an object in the shape of:\n\nSimilar to built-in directives, custom directive arguments can be dynamic. For example:\n\nHere the directive argument will be reactively updated based on property in our component state.\n\nIt's common for a custom directive to have the same behavior for and , with no need for the other hooks. In such cases we can define the directive as a function:\n\nIf your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.\n\nWhen used on components, custom directives will always apply to a component's root node, similar to Fallthrough Attributes.\n\nNote that components can potentially have more than one root node. When applied to a multi-root component, a directive will be ignored and a warning will be thrown. Unlike attributes, directives can't be passed to a different element with ."
    },
    {
        "link": "https://stackoverflow.com/questions/72697797/how-to-use-js-to-dynamically-add-components-and-listen-to-their-events-in-vue3",
        "document": "I've recently been learning Vue3. I want to add components dynamically, and the parent component can listen to the events of the added chirld components. To make it clear what I want to do, I have written the following code. I want a new button to be added when the mouse moves over any of the buttons. But only the first button actually triggers the hello function, which means that the code in line 7 of doesn't work. I would like to know how to modify the code to meet my requirements, or if there is another easy way to implement this functionality.\n\nThanks for the replies. I found that simply changing to works."
    },
    {
        "link": "https://dev.to/sucodelarangela/vue3-directives-cheat-sheet-built-in-and-custom-en-35mh",
        "document": "One of the advantages of Vue is the ease of manipulating the through special attributes called Directives. In addition to having several built-in directives, Vue also allows us to create custom ones.\n\nIf you're tired of using 's and 's, then this article is for you!\n\nDirectives are nothing more than template-manipulating attributes used in HTML tags. With them, we can dynamically alter our DOM, adding or omitting information and elements (Leonardo Vilarinho in Front-end com Vue.js: Da teoria à prática sem complicações).\n\nVue has a large number of built-in directives. To better understand how to use them, we'll walk through some practical examples for each one (you can also directly access some examples in Vue’s documentation).\n\nThe directive is used to and works exactly the same as mustache interpolation ( ). The difference in usage between them is that will replace the entire of the element, while interpolation allows you to replace only parts of the content.\n\nThe directive is used to (equivalent to using in JavaScript). It's a directive that should be used with caution, as it can allow for XSS (Cross-site Scripting) attacks, where malicious code can be injected into your application's DOM.\n\nThe directive dynamically changes the element's property based on the received value. In the example above, when the state is , the paragraph receives (the default display of a element). Clicking the button changes the state to and assigns to the paragraph.\n\nConsidered as some of the most used directives in Vue, , , and , are used for and follow the same logic as , , and in vanilla JavaScript. In the example, if is , we render a paragraph; however, if it's , we render an anchor; and in any other case, we render a component called .\n\nThe directive renders a list of elements or components by iterating over an array or object, similar to a . In our example:\n• we have an array of objects called ;\n• using the directive, we iterate over this array using the syntax to access each element of the iteration;\n• each will be an object from our array. Thus, we will have two , resulting in two paragraphs;\n• each paragraph will render the value of the key of each .\n\nAn important point about is that we need to provide a special attribute, which must receive a unique value. This value can be derived directly from our or we can use the of our array (which is not recommended if you need to manipulate the items in the array, as it can result in errors).\n\n\n\nThe directive (or simply as a shorthand) similar to what we would do with JavaScript's .\n\nAny standard JavaScript event can be used with the directive, which also accepts behavior modifiers and/or key modifiers.\n\nIn the code block above, we have some examples of events, such as (or ) and (or ), and we also show some events with modifiers, like (referring to ) and (which identifies the \"Enter\" key for the event).\n\nThe directive is used to create/bind dynamic HTML attributes to elements or to pass props to child components. The directive can be abbreviated to just as a shorthand.\n\nIn our examples, we have:\n• An state used as the attribute of an image, as well as a state used as a dynamic class;\n• The shortened form , for when the variable name is the same as the attribute name;\n• An example of dynamically assigning a \"myClass\" class if the state is truthy;\n• An example of a prop being passed to a child component.\n\nThe directive creates two-way data bindings, making it easy to synchronize states between inputs, selects, and components.\n\nIn the example above, the state is bound to an via , so when you type in the input, the value of is automatically updated with what was typed. Similarly, if we have a function that changes the value of , for example, the input will reflect that change.\n\nWe can also use to create this two-way binding from parent to child component:\n\n\n\nThe directive is used to define and use slots in components. Slots are a way to pass content to a child component more flexibly than through props and can be named or unnamed, helping you insert elements into the child component in the correct places.\n\nIn the example above, we have a ChildComponent consisting of a that encompasses two named slots: and . When using the child component, we pass two elements ( and ) to it through templates that use the directive with the name of the slot we want each element to receive. The directive can be abbreviated with the symbol.\n\nThe directive ignores the compilation of the element it's used on, as well as all its child elements, rendering the content that would be dynamic as plain text (the first paragraph will render while the second paragraph will render ).\n\nThe directive helps with performance by rendering the content of an element only once, making it static thereafter. Above, the paragraph will render the state only once and will remain static even if the value of changes later.\n\nThe directive is somewhat similar to , but it limits the re-rendering of the element or component to changes in one or more states, which must be passed as dependencies of the directive. In our example, we have a function whose result should be rendered inside the . However, this re-rendering should only occur if the value of is updated, as it is referenced in the directive as a dependency.\n\nThis directive is used for micro-optimizations of rendering, used more commonly in more complex components. However, if your component's logic is following best practices, the need to use becomes almost nonexistent.\n\nFor example, if were a computed property, we wouldn't need , as computed properties do exactly what the directive does: they cache values and only update them again when dependencies change:\n\n\n\nThe directive prevents uncompiled content from being rendered on the screen until Vue finishes its initialization (which typically happens when creating a Vue application directly in an HTML file via CDN). In the example above, the directive will hide the paragraph until the state is initialized and the component is fully mounted.\n\nCustom directives allow you to bind Vue states to HTML elements, manipulating them according to your application's business rules. This way, you'll have greater control over the application's layout.\n\nThese directives are defined as an object that contains lifecycle hooks (the same ones we use in components), and each hook receives the element on which the directive will be used. The Vue documentation offers very easy-to-understand examples.\n\nHere we have a local custom directive called that automatically focuses on an input when the component is mounted. With the Options API, we need to declare our directive inside the object, but in the Composition API, we simply create a variable (which must start with 'v').\n\nImagine that you need to use the directive in multiple components. This would generate a lot of repeated code in your application, as you would have to redeclare the directive in every component where you intend to use it, right?\n\nTo avoid this repetition, we can extract the logic of our new directive to a file in the directives folder:\n\n\n\nNow, just import the directive into the desired component and use it:\n\n\n\nIf you need to use a particular custom directive very often, a more suitable solution might be to declare it globally in your or file:\n\n\n\nSo far, we've learned how to create simple custom directives. But what if you want a more complex directive that has action modifiers, like ?\n\nA directive can have up to four types of attributes that can be used in its declaration, with the most important (and our focus in this article) being the following:\n• : The element on which the directive is being used (as we saw in ); and\n• : Object containing various properties that we can use in our directives, such as (the value passed in the directive) and , which is what we will use to create our modifiers.\n\nFor example, if we have the directive , our object would be:\n\n\n\nLet's see how to create a directive to format text in uppercase, lowercase, or capitalized letters.\n\n1. We create the initial structure of the directive, which will execute actions when the element is mounted in the component. Note that we are using and as parameters of our hook:\n\n\n\n2. We'll create a variable that will identify the modifier used in the directive. When we use a modifier in a directive, they are saved in a object within the object. So, if we use , will be and the value of the variable will be :\n\n\n\n3. Now we'll create the variable, which contains the text formatting functions for our directive. We'll capture the of the element the directive will be used on and format it to uppercase, lowercase, or capitalized:\n\n\n\n4. Finally, let's identify the modifier and execute the function that corresponds to it:\n\n\n\nGreat! Our directive is complete and ready to be used in a component. Let's see an example:\n\n\n\nHow about seeing how this directive would be with the Options API?\n\n\n\nUsing the directive in a component:\n\n\n\nAnd always remember that you can also register the directive globally in the file:\n\n\n\nPhew! I think we've seen enough...\n\nCreating custom directives which are more complet may seem a bit confusing at first, but nothing that practice can't solve!\n\nKnowing how to use Vue's built-in directives will be essential for your Vue application to always have great performance when dealing with component rendering and DOM manipulation, as well as being great for your developer experience, making your work easier and your code more elegant.\n\nHowever, never say never, my young Padawan. In more complex situations, you may realize that a can still be a lifesaver from time to time!\n\nI hope this article is helpful. See you next time!"
    },
    {
        "link": "https://vuejs.org/guide/essentials/lifecycle",
        "document": "Each Vue component instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called lifecycle hooks, giving users the opportunity to add their own code at specific stages.\n\nFor example, the hook can be used to run code after the component has finished the initial rendering and created the DOM nodes:\n\nThere are also other hooks which will be called at different stages of the instance's lifecycle, with the most commonly used being , , and . , , and .\n\nAll lifecycle hooks are called with their context pointing to the current active instance invoking it. Note this means you should avoid using arrow functions when declaring lifecycle hooks, as you won't be able to access the component instance via if you do so.\n\nWhen calling , Vue automatically associates the registered callback function with the current active component instance. This requires these hooks to be registered synchronously during component setup. For example, do not do this: Do note this doesn't mean that the call must be placed lexically inside or . can be called in an external function as long as the call stack is synchronous and originates from within .\n\nBelow is a diagram for the instance lifecycle. You don't need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.\n\nConsult the Lifecycle Hooks API referenceLifecycle Hooks API reference for details on all lifecycle hooks and their respective use cases."
    },
    {
        "link": "https://medium.com/@shanakaprince/a-beginners-guide-to-vue-js-lifecycle-methods-with-practical-examples-d85ff7d96646",
        "document": "Section 3: When to Use Lifecycle Hooks\n\nEach lifecycle hook serves a specific purpose. Here’s a breakdown of when and why you’d use them:\n\nUse this if you need to set up certain initializations before and are available. For example, you might set up a service or handle certain computations that don’t require reactive properties.\n\nThis is useful for fetching data from APIs or services, as the component has access to reactive . It's a good place to initiate state management or global event listeners.\n\nYou rarely need this hook in day-to-day development, but it can be used to examine the virtual DOM before it is mounted.\n\nA popular hook for DOM manipulations. It’s where you might integrate third-party libraries that depend on DOM elements.\n\nThese hooks are helpful if you want to track state changes. You can compare old and new values of reactive properties or manage complex DOM manipulations after updates.\n\nUse these to clean up any listeners, intervals, or other resources to avoid memory leaks."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/vuejs-component-lifecycle",
        "document": "Lifecycle hooks are a window into how the library you are using works behind the scenes. Lifecycle hooks allow you to know when your component is created, added to the DOM, updated, or destroyed.\n\nThis article will introduce you to the creation, mounting, updating, and destruction hooks in Vue.js.\n\nTo follow through this tutorial, you’ll need:\n• Familiarity with Vue.js. Read the How To Develop Websites with Vue.js series to learn more.\n\nCreation hooks are the first hooks that run in your component. They allow you to perform actions before your component has even been added to the DOM. Unlike any of the other hooks, creation hooks are also run during server-side rendering.\n\nUse creation hooks if you need to set things up in your component, both during client rendering and server rendering.\n\nYou will not have access to the DOM or the target mounting element ( ) inside of creation hooks.\n\nThe hook runs at the initialization of your component - has not been made reactive, and have not been set up yet:\n\nIn this example, when the hook is run, this snippet will log the message:\n\nThe hook runs before the templates and Virtual DOM have been mounted or rendered - you are able to access reactive and that are active:\n\nIn this example, the snippet will store as . When the hook is run, it will log a message:\n\nAnd then is changed to .\n\nLater in the lifecycle, will appear as instead of .\n\nIn this step, you reviewed some examples of creation hooks and are ready to move to the next part of the lifecycle, mounting hooks.\n\nMounting hooks are often the most used hooks. They allow you to access your component immediately before and after the first render. They do not, however, run during server-side rendering.\n\nUse mounting hooks if you need to access or modify the DOM of your component immediately before or after the initial render.\n\nDo not use mounting hooks if you need to fetch some data for your component on initialization.\n\nThe hook runs right before the initial render happens and after the template or render functions have been compiled:\n\nIn this example, when the hook is run, this snippet will log the message:\n\nIn the hook, you will have full access to the reactive component, templates, and rendered DOM (via ).\n\nUse for modifying the DOM—particularly when integrating non-Vue libraries:\n\nIn this example, when the hook is run, this snippet will log the message:\n\nIn addition, a message of ( ) will be logged.\n\nIn this section, you explored use-cases for mounting hooks. In the next step, you review some examples that use updating hooks.\n\nUpdating hooks are called whenever a reactive property used by your component changes or something else causes it to re-render. They allow you to hook into the watch-compute-render cycle for your component.\n\nUse updating hooks if you need to know when your component re-renders, perhaps for debugging or profiling.\n\nDo not use updating hooks if you need to know when a reactive property on your component changes. Use computed properties or watchers for that instead.\n\nThe hook runs after data changes on your component and the update cycle begins, right before the DOM is patched and re-rendered.\n\nUse if you need to get the new state of any reactive data on your component before it gets rendered:\n\nFirst, this snippet will store as . When the hook is run, it will increment every ms. When the hook is run, this snippet will log the message:\n\nAnd a number for is also logged.\n\nThe hook runs after data changes on your component and the DOM re-renders.\n\nUse if you need to access the DOM after a property change:\n\nFirst, this snippet will store as . When the hook is run, it will increment every ms. When the hook is run, this snippet will log the message:\n\nAnd a boolean value of is logged because the rendered value and current value are equal.\n\nNow that you’ve explored the use of updating hooks, you are ready to learn about destruction hooks.\n\nDestruction hooks allow you to perform actions when your component is destroyed, such as cleanup or analytics sending. They fire when your component is being torn down and removed from the DOM.\n\nis fired right before teardown. Your component will still be fully present and functional.\n\nUse if you need to clean up events or reactive subscriptions:\n\nThis snippet will first store . When the hook is run, this snippet will log the message:\n\nAnd then is deleted.\n\nBy the time you reach the hook, there’s practically nothing left on your component. Everything that was attached to it has been destroyed.\n\nUse if you need to do any last-minute cleanup or inform a remote server that the component was destroyed:\n\nFirst, this snippet will import . When the hook is run, this snippet will log the message:\n\nWhat remains of the component will be logged to console, and will be passed the message .\n\nWith that, you have completed your general review of the Vue.js lifecycle hooks.\n\nThere are two other hooks, and . These are for components, a topic that is outside the scope of this article.\n\nSuffice it to say that they allow you to detect when a component that is wrapped in a tag is toggled on or off. You might use them to fetch data for your component or handle state changes, effectively behaving as and without the need to do a full component rebuild.\n\nIn this article, you were introduced to different lifecycle hooks available in the Vue.js Instance Lifecycle. You explored the different use cases for creation hooks, mounting hooks, updating hooks, and destruction hooks.\n\nIf you’d like to learn more about Vue.js, check out our Vue.js topic page for exercises and programming projects."
    },
    {
        "link": "https://vuejs.org/guide/essentials/reactivity-fundamentals.html",
        "document": "With the Options API, we use the option to declare reactive state of a component. The option value should be a function that returns an object. Vue will call the function when creating a new component instance, and wrap the returned object in its reactivity system. Any top-level properties of this object are proxied on the component instance ( in methods and lifecycle hooks): // `mounted` is a lifecycle hook which we will explain later // `this` refers to the component instance. // data can be mutated as well These instance properties are only added when the instance is first created, so you need to ensure they are all present in the object returned by the function. Where necessary, use , or some other placeholder value for properties where the desired value isn't yet available. It is possible to add a new property directly to without including it in . However, properties added this way will not be able to trigger reactive updates. Vue uses a prefix when exposing its own built-in APIs via the component instance. It also reserves the prefix for internal properties. You should avoid using names for top-level properties that start with either of these characters. In Vue 3, data is made reactive by leveraging JavaScript Proxies. Users coming from Vue 2 should be aware of the following edge case: When you access after assigning it, the value is a reactive proxy of the original . Unlike in Vue 2, the original is left intact and will not be made reactive: make sure to always access reactive state as a property of .\n\nIn Composition API, the recommended way to declare reactive state is using the function: takes the argument and returns it wrapped within a ref object with a property: To access refs in a component's template, declare and return them from a component's function: // `setup` is a special hook dedicated for the Composition API. // expose the ref to the template Notice that we did not need to append when using the ref in the template. For convenience, refs are automatically unwrapped when used inside templates (with a few caveats). You can also mutate a ref directly in event handlers: For more complex logic, we can declare functions that mutate refs in the same scope and expose them as methods alongside the state: // .value is needed in JavaScript // don't forget to expose the function as well. Exposed methods can then be used as event handlers: Here's the example live on Codepen, without using any build tools. Manually exposing state and methods via can be verbose. Luckily, it can be avoided when using Single-File Components (SFCs). We can simplify the usage with : Top-level imports, variables and functions declared in are automatically usable in the template of the same component. Think of the template as a JavaScript function declared in the same scope - it naturally has access to everything declared alongside it. For the rest of the guide, we will be primarily using SFC + syntax for the Composition API code examples, as that is the most common usage for Vue developers. If you are not using SFC, you can still use Composition API with the option. You might be wondering why we need refs with the instead of plain variables. To explain that, we will need to briefly discuss how Vue's reactivity system works. When you use a ref in a template, and change the ref's value later, Vue automatically detects the change and updates the DOM accordingly. This is made possible with a dependency-tracking based reactivity system. When a component is rendered for the first time, Vue tracks every ref that was used during the render. Later on, when a ref is mutated, it will trigger a re-render for components that are tracking it. In standard JavaScript, there is no way to detect the access or mutation of plain variables. However, we can intercept the get and set operations of an object's properties using getter and setter methods. The property gives Vue the opportunity to detect when a ref has been accessed or mutated. Under the hood, Vue performs the tracking in its getter, and performs triggering in its setter. Conceptually, you can think of a ref as an object that looks like this: Another nice trait of refs is that unlike plain variables, you can pass refs into functions while retaining access to the latest value and the reactivity connection. This is particularly useful when refactoring complex logic into reusable code. The reactivity system is discussed in more details in the Reactivity in Depth section.\n\nTo add methods to a component instance we use the option. This should be an object containing the desired methods: // methods can be called in lifecycle hooks, or other methods! Vue automatically binds the value for so that it always refers to the component instance. This ensures that a method retains the correct value if it's used as an event listener or callback. You should avoid using arrow functions when defining , as that prevents Vue from binding the appropriate value: // BAD: no `this` access here! Just like all other properties of the component instance, the are accessible from within the component's template. Inside a template they are most commonly used as event listeners: In the example above, the method will be called when the is clicked.\n\nRefs can hold any value type, including deeply nested objects, arrays, or JavaScript built-in data structures like . A ref will make its value deeply reactive. This means you can expect changes to be detected even when you mutate nested objects or arrays: // these will work as expected. Non-primitive values are turned into reactive proxies via , which is discussed below. It is also possible to opt-out of deep reactivity with shallow refs. For shallow refs, only access is tracked for reactivity. Shallow refs can be used for optimizing performance by avoiding the observation cost of large objects, or in cases where the inner state is managed by an external library.\n\nWhen you mutate reactive state, the DOM is updated automatically. However, it should be noted that the DOM updates are not applied synchronously. Instead, Vue buffers them until the \"next tick\" in the update cycle to ensure that each component updates only once no matter how many state changes you have made.\n\nTo wait for the DOM update to complete after a state change, you can use the nextTick() global API:\n\nThere is another way to declare reactive state, with the API. Unlike a ref which wraps the inner value in a special object, makes an object itself reactive: Reactive objects are JavaScript Proxies and behave just like normal objects. The difference is that Vue is able to intercept the access and mutation of all properties of a reactive object for reactivity tracking and triggering. converts the object deeply: nested objects are also wrapped with when accessed. It is also called by internally when the ref value is an object. Similar to shallow refs, there is also the API for opting-out of deep reactivity. It is important to note that the returned value from is a Proxy of the original object, which is not equal to the original object: // proxy is NOT equal to the original. Only the proxy is reactive - mutating the original object will not trigger updates. Therefore, the best practice when working with Vue's reactivity system is to exclusively use the proxied versions of your state. To ensure consistent access to the proxy, calling on the same object always returns the same proxy, and calling on an existing proxy also returns that same proxy: // calling reactive() on the same object returns the same proxy This rule applies to nested objects as well. Due to deep reactivity, nested objects inside a reactive object are also proxies: The API has a few limitations:\n• None Limited value types: it only works for object types (objects, arrays, and collection types such as and ). It cannot hold primitive types such as , or .\n• None Cannot replace entire object: since Vue's reactivity tracking works over property access, we must always keep the same reference to the reactive object. This means we can't easily \"replace\" a reactive object because the reactivity connection to the first reference is lost: // the above reference ({ count: 0 }) is no longer being tracked\n• None Not destructure-friendly: when we destructure a reactive object's primitive type property into local variables, or when we pass that property into a function, we will lose the reactivity connection: // count is disconnected from state.count when destructured. // won't be able to track changes to state.count // we have to pass the entire object in to retain reactivity Due to these limitations, we recommend using as the primary API for declaring reactive state. A ref is automatically unwrapped when accessed or mutated as a property of a reactive object. In other words, it behaves like a normal property: If a new ref is assigned to a property linked to an existing ref, it will replace the old ref: // original ref is now disconnected from state.count Ref unwrapping only happens when nested inside a deep reactive object. It does not apply when it is accessed as a property of a shallow reactive object. Unlike reactive objects, there is no unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like : Ref unwrapping in templates only applies if the ref is a top-level property in the template render context. In the example below, and are top-level properties, but is not: Therefore, this expression works as expected: ...while this one does NOT: The rendered result will be because is not unwrapped when evaluating the expression and remains a ref object. To fix this, we can destructure into a top-level property: Now the render result will be . Another thing to note is that a ref does get unwrapped if it is the final evaluated value of a text interpolation (i.e. a tag), so the following will render : This is just a convenience feature of text interpolation and is equivalent to ."
    },
    {
        "link": "https://medium.com/@emperorbrains/exploring-vue-3-lifecycle-hooks-a-hands-on-guide-with-real-time-examples-cccff27f76d3",
        "document": "In the vast landscape of JavaScript frameworks, one name stands out as a favorite among developers — Vue.js, the framework that has captured the hearts of many with its simplicity and flexibility. And at the core of Vue.js lies a powerful feature: Lifecycle Hooks.\n\nLifecycle hooks in Vue.js provide developers with the ability to perform specific actions at crucial moments in a component’s existence. As a Vue component, essentially a view file in Vue.js, takes shape, it undergoes a sequence of essential initialization steps. These steps involve processes such as data observation, template compilation, mounting the instance to the DOM, and updating the DOM dynamically as the underlying data changes.\n\nEvery Vue component is, in essence, a Vue instance, and understanding how to leverage lifecycle hooks allows developers to tailor the component’s behavior at distinct stages of its lifecycle.\n\nIn this blog post, we will unravel the intricacies of Vue 3 lifecycle hooks, accompanied by a real-time example that will shed light on their practical application.\n\nTo add a touch of relatability to this exploration, let’s draw a parallel between the workings of Vue 3 lifecycle hooks and Bob’s morning routine. By comparing the meticulous steps Bob takes each morning with the meticulous treatment each lifecycle hook bestows upon our Vue component instances, we aim to demystify and simplify the understanding of these hooks.\n\nSo, buckle up as we dive deep into the world of Vue 3 lifecycle hooks and embark on a journey to comprehend how they sculpt the behavior of our Vue components.\n\nThe hook is a lifecycle hook in Vue.js that is triggered immediately when a component instance is initialized. This occurs after the resolution of props but before the execution of other lifecycle hooks such as or . This hook provides an early entry point to perform actions or setups before the component fully initializes.\n\nIt’s important to note that in the Composition API, specifically in the function, hooks are executed even before the hook. This means that any logic or operations defined in the function will run before the hook is triggered. Below is an example to illustrate this sequencing:\n\nIn this example, the code within the function is executed before the hook. This demonstrates the order of execution and emphasizes the role of in the component's lifecycle.\n\nThe hook is a lifecycle hook in Vue.js that is called after the component instance has finished processing all state-related options, including the and hooks. At this point, the component has been fully initialized, and reactive data, computed properties, and methods are available for use.\n\nThis hook is commonly used to perform actions that require access to the component’s state and configurations, making it a suitable place for additional setup, data fetching, or any logic that depends on the initialized state of the component.\n\nHere’s an example illustrating the use of the hook:\n\nIn this example, the hook is used to log information about the reactive data and computed properties, as well as initiate a data fetching operation. This showcases how the hook can be employed for post-initialization tasks in a Vue.js component.\n\nThe hook is a lifecycle hook in Vue.js that is called right before the component is about to be mounted to the DOM. At this stage, the component has completed the setup of its reactive state, including data, computed properties, and methods. However, no DOM nodes associated with the component have been created yet. The hook provides an opportunity to perform actions or setup tasks just before the component's initial render.\n\nWhen the hook is triggered, the component is on the verge of executing its DOM render effect for the first time. This makes it a suitable point to make final adjustments or execute logic that needs to be performed prior to the component becoming visible in the DOM.\n\nHere’s an example demonstrating the use of the hook:\n\nIn this example, the hook is used to log information about the reactive data and to initialize a chart library just before the component is mounted. This illustrates the role of the hook in facilitating pre-mount setup tasks.\n\nThe hook is a lifecycle hook in Vue.js that is called after the component or instance has been successfully mounted to the DOM. At this stage, the component's template has been rendered, and its associated DOM elements are now part of the document. The hook is commonly used for performing side effects, initialization tasks, or any operations that require access to the component's rendered DOM.\n\n1. DOM Accessibility: Since the hook is called after the component is attached to the DOM, it provides a suitable point for accessing and manipulating the DOM elements associated with the component.\n\n2 . Initialization Tasks: It is often used to trigger actions that should occur once the component is fully visible in the document. This includes setting up event listeners, fetching additional data, or initializing third-party libraries.\n\nHere’s an example illustrating the use of the hook:\n\nIn this example, the hook is utilized to access the DOM elements after the component has been mounted and to set up an event listener on a button. This demonstrates how the hook is commonly used for tasks that require interaction with the rendered DOM.\n\nThe hook is a lifecycle hook in Vue.js that is called right before the component is about to update its DOM tree due to a reactive state change. It provides a useful opportunity to access and modify the component's state or the DOM state before the actual update takes place.\n• DOM State Access: This hook allows you to access both the component’s state and the DOM state just before Vue updates the DOM. It is particularly useful for making modifications or performing actions that should occur before the visual representation of the component is updated.\n• Safe State Modification: Unlike some lifecycle hooks, it is safe to modify the component’s state within the hook. This makes it a suitable place to adjust data or perform calculations based on the current state before the update.\n• Conditional Updates: Use cases include conditional updates, where certain modifications to the DOM or component state need to happen based on specific conditions before the update is applied.\n\nHere’s an example demonstrating the use of the hook:\n\nIn this example, the hook is used to access and modify the image width before the component updates. This demonstrates how the hook can be valuable for scenarios where pre-update adjustments are necessary.\n\nThe hook is a lifecycle hook in Vue.js that is called after the component has successfully updated its DOM tree due to a reactive state change. It signals that the component's state and the corresponding DOM elements have been synchronized.\n• DOM Synchronization: This hook is triggered after any DOM update caused by reactive state changes in the component. It provides confirmation that the component’s template has been re-rendered to reflect the updated state.\n• No Information on Cause: While the hook informs you that an update has occurred, it doesn't provide specific details about what caused the update. For understanding the cause of changes, watchers are more appropriate.\n• Caution on DOM Updates: It is generally not recommended to perform direct DOM updates within the hook, as this hook can be triggered multiple times during the component's lifecycle. For DOM manipulations, it's often more appropriate to use other lifecycle hooks or directives.\n\nHere’s an example illustrating the use of the hook:\n\nIn this example, the hook is utilized to log a message indicating that the component has been updated. It emphasizes the caution against performing direct DOM updates inside this hook, redirecting such operations to more appropriate lifecycle hooks or directives.\n\nThe hook is a lifecycle hook in Vue.js that is called right before a component instance is about to be unmounted, providing an opportunity for cleanup tasks before the component is destroyed.\n• Cleanup Operations: This hook is particularly useful for performing cleanup operations, such as clearing intervals, deregistering event listeners, or releasing resources, before the component is permanently removed from the DOM.\n• Replacement for Vue 2’s : In Vue 2, the equivalent hook was named . In Vue 3, the naming was changed to to better align with the updated component lifecycle terminology.\n\nHere’s an example demonstrating the use of the hook:\n\nIn this example, the hook is used to clean up resources (clearing an interval) before the component is unmounted. This illustrates the importance of this hook in managing cleanup tasks just before the component is removed from the DOM.\n\nThe hook is the final lifecycle hook in Vue.js, called after the component has been successfully unmounted and destroyed. At this stage, the component's DOM elements have been removed, and any resources or event listeners associated with the component should be released.\n• Final Cleanup: The hook provides a final opportunity for cleanup operations that should be performed after the component is no longer part of the DOM. This is the last stop in the component's lifecycle.\n• No Access to Component State: It’s important to note that variables or state initialized within the component are not accessible within the hook. Any resources or data specific to the component should be handled and cleaned up in earlier hooks, such as .\n\nHere’s an example illustrating the use of the hook:\n\nIn this example, the hook is used to log a message indicating that the component has been successfully unmounted. The cleanup operations are handled in the hook, emphasizing the separation of concerns between cleanup and the final acknowledgment of unmounting.\n\nEmperor Brains stands as a beacon of innovation and expertise in the realm of technology solutions. Through a deep dive into the intricacies of Vue.js 3 lifecycle hooks, we’ve demonstrated not only a commitment to understanding cutting-edge technologies but also a dedication to simplifying complex concepts for developers.\n\nEmperor Brains recognizes the pivotal role that Vue.js lifecycle hooks play in shaping dynamic and responsive web applications. Our exploration, coupled with real-time examples, serves as a testament to our mission of empowering developers with practical insights and knowledge.\n\nAs a technology-focused company, Emperor Brains encourages developers to harness the potential of Vue.js and its lifecycle hooks for efficient and tailored web development. We take pride in our ability to bridge the gap between intricate technical details and real-world applications.\n\nFor more information, resources, and to explore how Emperor Brains can elevate your technological endeavors, visit our website at Emperor Brains At Emperor Brains, we are not just navigating the tech landscape; we are shaping it, pushing boundaries, and redefining what is possible. Join us in this journey of innovation and discover the limitless possibilities that technology holds under the guidance of Emperor Brains."
    }
]