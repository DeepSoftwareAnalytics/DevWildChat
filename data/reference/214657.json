[
    {
        "link": "https://reddit.com/r/Python/comments/bxx0ua/automating_ms_office_w_python_programming_via",
        "document": "Has anyone here had experience automating office applications using the Win32 COM library. If so, how was the learning curve to become proficient with it? How have projects been panning out w/ it?\n\nWith Python being available in the App store for users, I now have the chance to distribute Python scripts to automate MS office related tasks as I've previously been limited to VBA. I know there are options such as openpyxl, xlwings etc., however it looks like Win32 COM offers the best flexibility if you already have a good understanding of VBA. I'm planning on going through \"Python Programming on Win32\" by Mark Hammond but would appreciate any other resources others have used. There's also a great Youtube Series by Sigma Coding that I've been going through."
    },
    {
        "link": "https://learn.microsoft.com/en-us/answers/questions/1183617/how-to-fill-form-fields-in-word-automatically-with",
        "document": "Office: A suite of Microsoft productivity software that supports common business tasks, including word processing, email, presentations, and data management and analysis. Development: The process of researching, productizing, and refining new or existing technologies."
    },
    {
        "link": "https://stackoverflow.com/questions/47212459/automating-comparison-of-word-documents-using-python",
        "document": "I am trying to use win32com(pywin32) and Microsoft Word's Object Model to Compare two Word Documents(Automating the task of Comparing two documents in Microsoft word under Review->Compare). Following is the code I have written for this:\n\nBut I am getting the following error:\n\nI am not able to understand why this error is being thrown. I really want to resolve this issue.Please help."
    },
    {
        "link": "https://pbpython.com/windows-com.html",
        "document": "The pywin32 package has been around for a very long time. In fact, the book that covers this topic was published in 2000 by Mark Hammond and Andy Robinson. Despite being 18 years old (which make me feel really old :), the underlying technology and concepts still work today. Pywin32 is basically a very thin wrapper of python that allows us to interact with COM objects and automate Windows applications with python. The power of this approach is that you can pretty much do anything that a Microsoft Application can do through python. The downside is that you have to run this on a Windows system with Microsoft Office installed. Before we go through some examples, make sure you have pywin32 installed on your system using or One other recommendation I would make is that you keep a link to Tim Golden’s page handy. This resource has many more details on how to use python on Windows for automation and other administration tasks.\n\nAll of these applications start with similar imports and process for activating an application. Here is a very short example of opening up Excel: Once you run this from the command line, you should see Excel open up. When you press ENTER, the application will close. There are a few key concepts to go through before we actually make this a more useful application. The first step is to import the win32 client. I’ve used the convention of importing it as to make the actual dispatch code a little shorter. The magic of this code is using to launch Excel. In this example, I use to create a static proxy. I recommend reading this article if you want to know more details about static vs. dynamic proxies. I have had good luck using this approach for the types of examples included in this article but will be honest - I have not widely experimented with the various dispatch approaches. Now that the excel object is launched, we need to explicitly make it visible by setting The win32 code is pretty smart and will close down excel once the program is done running. This means that if we just leave the code to run on its own, you probably won’t see Excel. I include the dummy prompt to keep Excel visible on the screen until the user presses ENTER. I include the final line of as a bit of a belt and suspenders approach. Strictly speaking win32 should close out Excel when the program is done but I decided to include to show how to force the application to close. This is the most basic approach to using COM. We can extend this in a number of more useful ways. The rest of this article will go through some examples that might be useful for your own needs.\n\nIn my day-to-day work, I frequently use pandas to analyze and manipulate data, then output the results in Excel. The next step in the process is to open up the Excel and review the results. In this example, we can automate the file opening process which can make it simpler than trying to navigate to the right directory and open a file. # Define the full path for the output file # In the real world, this would likely be much more involved # Open up Excel and make it visible This simple example expands on the earlier one by showing how to use the object to open up a file.\n\nAnother simple scenario where COM is helpful is when you want to attach a file to an email and send to a distribution list. This example shows how to do some data manipulation, open up a Outlook email, attach a file and leave it open for additional text before sending. # Define the full path for the output file # In the real world, this would likely be much more involved # The file needs to be a string not a path object This example gets a little more involved but the basic concepts are the same. We need to create our object (Outlook in this case) and create a new email. One of the challenging aspects of working with COM is that there is not a very consistent API. It is not intuitive that you create an email like this: It generally takes a little searching to figure out the exact API for the specific problem. Google and stackoverflow are your friends. Once the email object is created, you can add the recipient and CC list as well as attach the file. When it is all said and done, it looks like this: The email is open and you can add additional information and send it. In this example, I chose not to close out Outlook and let python handle those details.\n\nThe final example is the most involved but illustrates a powerful approach for blending the data analysis of python with the user interface of Excel. It is possible to build complex excel with pandas but that approach can be very laborious. An alternative approach would be to build up the complex file in Excel, then do the data manipulation and copy the data tab to the final Excel output. Here is an example of the Excel dashboard we want to create: Yes, I know that pie charts are awful but I can almost guarantee that someone is going to ask you to put one in the dashboard at some point in time! Also, this template had a pie chart and I decided to keep it in the final output instead of trying to figure out another chart. It might be helpful to take a step back and look at the basic process the code will follow: Let’s get started with the code. # Define the full path for the data file file # Define the full path for the final output file In the section we performed our imports, read in the data and defined all three files. Of note is that this process includes the step of summarizing the data with pandas and saving the data in an Excel file. We then re-open that file and copy the data into the template. It is a bit convoluted but this is the best approach I could figure out for this scenario. Next we perform the analysis and save the temp Excel file: # In the real world, this would likely be much more involved Now we use COM to merge the temp output file into our Excel dashboard tab and save a new copy: # Use com to copy the files around # Copy from the data file (select all data in A:D columns) # Must convert the path file object to a string for the save to work The code opens up Excel and makes sure it is not visible. Then it opens up the dashboard template and data files. It uses the to select all the data and then copies it into the template file. The final step is to save the template as a new file. This approach can be a very convenient shortcut when you have a situation where you want to use python for data manipulation but need a complex Excel output. You may not have an apparent need for it now but if you ever build up a complex Excel report, this approach is much simpler than trying to code the spreadsheet by hand with python.\n\nMy preference is to try to stick with python as much as possible for my day-to-day data analysis. However, it is important to know when other technologies can streamline the process or make the results have a bigger impact. Microsoft’s COM technology is a mature technology and can be used effectively through python to do tasks that might be too difficult to do otherwise. Hopefully this article has given you some ideas on how to incorporate this technique into your own workflow. If you have any tasks you like to use pywin32 for, let us know in the comments."
    },
    {
        "link": "https://blog.pythonlibrary.org/2010/07/16/python-and-microsoft-office-using-pywin32",
        "document": "Most typical users have used Microsoft Office. While Office may be the bane of tech support, we still have to deal with it. Python can be used to script (AKA automate) Office and make it easier for us or our users to use. It may not be as easy as recording a macro, but it’s close. For this article, you will learn how to use the PyWin32 module to access some of the Office programs and manipulate them with Python. Some forums say that you need to run PythonWin’s makepy utility on Microsoft Word (and Excel) before you can access Office applications. I don’t think I needed to do that to make it work though (at least, not with the 2007 version). However, PythonWin comes with the PyWin32, so if you do run into trouble, you can try it.\n\nIf you’ve looked for examples of using Python and Office, you’ll usually find that the most often hacked component is Excel. In fact, there are several non-PyWin32 modules specifically created to read and write Excel files. They are called xlrd and xlwt, respectively. But that’s a topic for another article. Here we’ll see how to mess with Excel using the PyWin32 interface. Note that the following scripts only work on Windows. One advantage of xlrd and xlwt is that you can use them on any platform.\n\nLet’s take a look at a simple example, shall we?\n\nThe example above is similar to what you will normally find on the web. It is actually based on an example I saw in Wesley Chun’s excellent book, Core Python Programming. Let’s take some time and unpack the code. To gain access to Excel, we import win32com.client and then call its gencache.EnsureDispatch, passing in the application name that we want to open. In this case, the string to pass is “Excel.Application”. All that does is open Excel in the background. At this point, the user won’t even know Excel is open unless they have Task Manager running. The next line is adds a new workbook to Excel by calling that Excel instance’s “Workbooks.Add()” method. This returns a sheets object (I think). To get the ActiveSheet, we call ss.ActiveSheet. Finally, we make the Excel program itself visible by setting that property to True.\n\nTo set a specific cell’s value, call something like this: sh.Cells(row,col).Value = “some value”. Note that our instance is NOT zero-based and will actually put the value in the correct row/col combo. If we want to extract a value, we just remove the equals sign. What if we want the formula? To figure this our, I recorded a macro in Excel and did a Paste Special command that only pasted the Formula. Using the code generated, I figured out that to get the formula in Python, you just do this:\n\nWhat if you need to change which sheet you’re on? Recording a macro also showed me how to accomplish this feat. Here’s the VBA code from Excel:\n\nFrom this code, I gathered that I needed to call my sheets object’s “Sheets” method and after a little fiddling, I got it to work by doing the following:\n\nNow we have a handle on the second sheet in the workbook. If you want to edit or retrieve values, just prepend the same methods you used above with whatever you called the sheet2 instance (i.e. sheet2.Cells(1,1).Value). The last two lines from the original program will close the sheets and then quit the entire Excel instance.\n\nYou may be thinking that so far all I’ve shown is how to create a new document. What if you want to open an existing file? Just do something like this at the beginning of the code:\n\nAnd there you have it! You now know the basics of hacking Excel with Python using Excel’s COM object model. If you need to learn more, I recommend trying to record a macro and than translating the result into Python. Note: I was unable to find an example that could save the spreadsheet…there are several examples that claim they work, but they didn’t for me.\n\nAccessing Microsoft Word with Python follows the same syntax that we used for Excel. Let’s take a quick look at how to access Word.\n\nThis particular example is also based on something from Chun’s book as well. However, there are lots of other examples on the web that look almost exactly like this too. Let’s unpack this code now. To get a handle on the Microsoft Word application, we call win32.gencache.EnsureDispatch(‘Word.Application’); then we add a new document by calling the word instance’s Documents.Add(). If you want to show the user what you’re up to, you can set the visibility of Word to True.\n\nIf you want to add text to the document, then you’ll want to tell Word where you want the text to go. That’s where the Range method comes in. While you can’t see it, there is a “grid” of sorts that tells Word how to layout the text onscreen. So if we want to insert text at the very top of the document, we tell it to start at (0,0). To add a new line in Word, we need to append “\\r\n\n” to the end of our string. If you don’t know about the annoyances of line endings on different platforms, you should spend some time with Google and learn about it so you don’t get bit by weird bugs!\n\nThe rest of the code is pretty self-explanatory and will be left to the reader to interpret. We’ll move on to opening and saving documents now:\n\nHere we show how to open an existing Word document and save it as text. I haven’t tested this one fully, so your mileage may vary. If you want to read the text in the document, you can do the following:\n\nAnd that ends the Python hacking lesson on Word documents. Since a lot of the information I was finding on Microsoft Word and Python was old and crusty and didn’t seem to work half the time, I don’t add to the mess of bad information. Hopefully this will get you started on your own journey into the wild wonders of Word manipulation."
    },
    {
        "link": "https://docs.wxpython.org/events_overview.html",
        "document": "Like with all the other GUI frameworks, the control of flow in wxPython applications is event-based: the program normally performs most of its actions in response to the events generated by the user. These events can be triggered by using the input devices (such as keyboard, mouse, joystick) directly or, more commonly, by a standard control which synthesizes such input events into higher level events: for example, a wx.Button can generate a click event when the user presses the left mouse button on it and then releases it without pressing in the meanwhile. There are also events which don’t directly correspond to the user actions, such as wx.TimerEvent.\n\nBut in all cases wxPython represents these events in a uniform way and allows you to handle them in the same way wherever they originate from. And while the events are normally generated by wxPython itself, you can also do this, which is especially useful when using custom events (see Custom Event Summary).\n\nTo be more precise, each event is described by:\n• None Event type: this is simply a value of type EventType which uniquely identifies the type of the event. For example, clicking on a button, selecting an item from a list box and pressing a key on the keyboard all generate events with different event types.\n• None Event class: carried by the event: each event has some information associated with it and this data is represented by an object of a class derived from wx.Event. Events of different types can use the same event class, for example both button click and listbox selection events use wx.CommandEvent class (as do all the other simple control events), but the key press event uses wx.KeyEvent as the information associated with it is different.\n• None Event source: wx.Event stores the object which generated the event and, for windows, its identifier (see Window Identifiers). As it is common to have more than one object generating events of the same type (e.g. a typical window contains several buttons, all generating the same button click event), checking the event source object or its id allows to distinguish between them.\n\nLet us start by looking at the syntax: in any place in your code, but usually in the code of the class defining the handler itself, call its method like this: Event handlers can be bound at any moment. For example, it’s possible to do some initialization first and only bind the handlers if and when it succeeds. This can avoid the need to test that the object was properly initialized in the event handlers themselves. With they simply won’t be called if it wasn’t correctly initialized. As a slight extension of the above, the handlers can also be unbound at any time with (and maybe rebound later). Almost last but very, very far from least is the flexibility which allows to bind an event to:\n• None An ordinary function like a static method or a global function. Let us now look at more examples of how to use different event handlers using the two overloads of function: first one for the object methods and the other one for arbitrary functors (callable objects, including simple functions). In addition to using a method of the object generating the event itself, you can use a method from a completely different object as an event handler: Note that MyFrameHandler doesn’t need to derive from wx.EvtHandler.\n\nThe previous sections explain how to define event handlers but don’t address the question of how exactly wxPython finds the handler to call for the given event. This section describes the algorithm used in detail. When an event is received from the windowing system, wxPython calls on the first event handler object belonging to the window generating the event. The normal order of event table searching by is as follows, with the event processing stopping as soon as a handler is found (unless the handler calls in which case it doesn’t count as having handled the event and the search continues):\n• None Before anything else happens, is called. If it returns anything but -1 (default), the event handling stops immediately.\n• None If this event handler is disabled via a call to the next three steps are skipped and the event handler resumes at step (5).\n• None If the object is a wx.Window and has an associated validator, wx.Validator gets a chance to process the event.\n• None The list of dynamically bound event handlers, i.e., those for which was called, is consulted.\n• None The event table containing all the handlers defined using the event table macros in this class and its base classes is examined. Notice that this means that any event handler defined in a base class will be executed at this step.\n• None The event is passed to the next event handler, if any, in the event handler chain, i.e., the steps (1) to (4) are done for it. Usually there is no next event handler so the control passes to the next step but see Event Handlers Chain for how the next handler may be defined.\n• None If the object is a wx.Window and the event is set to propagate (by default only event types derived from wx.CommandEvent are set to propagate), then the processing restarts from the step (1) (and excluding the step (7)) for the parent window. If this object is not a window but the next handler exists, the event is passed to its parent if it is a window. This ensures that in a common case of (possibly several) non-window event handlers pushed on top of a window, the event eventually reaches the window parent.\n• None Finally, i.e., if the event is still not processed, the wx.App object itself (which derives from wx.EvtHandler) gets a last chance to process it. Please pay close attention to step 6! People often overlook or get confused by this powerful feature of the wxPython event processing system. The details of event propagation up the window hierarchy are described in the next section. As mentioned above, the events of the classes deriving from wx.CommandEvent are propagated by default to the parent window if they are not processed in this window itself. But although by default only the command events are propagated like this, other events can be propagated as well because the event handling code uses to check whether an event should be propagated. It is also possible to propagate the event only a limited number of times and not until it is processed (or a top level parent window is reached). Finally, there is another additional complication (which, in fact, simplifies life of wxPython programmers significantly): when propagating the command events up to the parent window, the event propagation stops when it reaches the parent dialog, if any. This means that you don’t risk getting unexpected events from the dialog controls (which might be left unprocessed by the dialog itself because it doesn’t care about them) when a modal dialog is popped up. The events do propagate beyond the frames, however. The rationale for this choice is that there are only a few frames in a typical application and their parent-child relation are well understood by the programmer while it may be difficult, if not impossible, to track down all the dialogs that may be popped up in a complex program (remember that some are created automatically by wxPython). If you need to specify a different behaviour for some reason, you can use ( ) explicitly to prevent the events from being propagated beyond the given window or unset this flag for the dialogs that have it on by default. Typically events that deal with a window as a window (size, motion, paint, mouse, keyboard, etc.) are sent only to the window. Events that have a higher level of meaning or are generated by the window itself (button click, menu select, tree expand, etc.) are command events and are sent up to the parent to see if it is interested in the event. More precisely, as said above, all event classes not deriving from wx.CommandEvent (see the wx.Event inheritance diagram) do not propagate upward. In some cases, it might be desired by the programmer to get a certain number of system events in a parent window, for example all key events sent to, but not used by, the native controls in a dialog. In this case, a special event handler will have to be written that will override in order to pass all events (or any selection of them) to the parent window. Step 4 of the event propagation algorithm checks for the next handler in the event handler chain. This chain can be formed using : (Referring to the image, if is called and it doesn’t handle the event, will be called and so on…). Additionally, in the case of wx.Window you can build a stack (implemented using wx.EvtHandler double-linked list) using : (Referring to the image, if is called, it immediately calls ; if nor A nor B handle the event, then the wx.Window itself is used – i.e. the dynamically bind event handlers and static event table entries of wx.Window are looked as the last possibility, after all pushed event handlers were tested). By default the chain is empty, i.e. there is no next handler."
    },
    {
        "link": "https://docs.wxpython.org/4.0.4/events_overview.html",
        "document": "Like with all the other GUI frameworks, the control of flow in wxPython applications is event-based: the program normally performs most of its actions in response to the events generated by the user. These events can be triggered by using the input devices (such as keyboard, mouse, joystick) directly or, more commonly, by a standard control which synthesizes such input events into higher level events: for example, a wx.Button can generate a click event when the user presses the left mouse button on it and then releases it without pressing in the meanwhile. There are also events which don’t directly correspond to the user actions, such as wx.TimerEvent.\n\nBut in all cases wxPython represents these events in a uniform way and allows you to handle them in the same way wherever they originate from. And while the events are normally generated by wxPython itself, you can also do this, which is especially useful when using custom events (see Custom Event Summary).\n\nTo be more precise, each event is described by:\n• Event type: this is simply a value of type EventType which uniquely identifies the type of the event. For example, clicking on a button, selecting an item from a list box and pressing a key on the keyboard all generate events with different event types.\n• Event class: carried by the event: each event has some information associated with it and this data is represented by an object of a class derived from . Events of different types can use the same event class, for example both button click and listbox selection events use class (as do all the other simple control events), but the key press event uses as the information associated with it is different.\n• Event source: stores the object which generated the event and, for windows, its identifier (see ). As it is common to have more than one object generating events of the same type (e.g. a typical window contains several buttons, all generating the same button click event), checking the event source object or its id allows to distinguish between them.\n\nLet us start by looking at the syntax: in any place in your code, but usually in the code of the class defining the handler itself, call its method like this: Event handlers can be bound at any moment. For example, it’s possible to do some initialization first and only bind the handlers if and when it succeeds. This can avoid the need to test that the object was properly initialized in the event handlers themselves. With they simply won’t be called if it wasn’t correctly initialized. As a slight extension of the above, the handlers can also be unbound at any time with (and maybe rebound later). Almost last but very, very far from least is the flexibility which allows to bind an event to:\n• An ordinary function like a static method or a global function. Let us now look at more examples of how to use different event handlers using the two overloads of function: first one for the object methods and the other one for arbitrary functors (callable objects, including simple functions). In addition to using a method of the object generating the event itself, you can use a method from a completely different object as an event handler: Note that MyFrameHandler doesn’t need to derive from wx.EvtHandler.\n\nThe previous sections explain how to define event handlers but don’t address the question of how exactly wxPython finds the handler to call for the given event. This section describes the algorithm used in detail. When an event is received from the windowing system, wxPython calls on the first event handler object belonging to the window generating the event. The normal order of event table searching by is as follows, with the event processing stopping as soon as a handler is found (unless the handler calls in which case it doesn’t count as having handled the event and the search continues):\n• Before anything else happens, is called. If it returns anything but -1 (default), the event handling stops immediately.\n• If this event handler is disabled via a call to the next three steps are skipped and the event handler resumes at step (5).\n• If the object is a and has an associated validator, gets a chance to process the event.\n• The list of dynamically bound event handlers, i.e., those for which was called, is consulted.\n• The event table containing all the handlers defined using the event table macros in this class and its base classes is examined. Notice that this means that any event handler defined in a base class will be executed at this step.\n• The event is passed to the next event handler, if any, in the event handler chain, i.e., the steps (1) to (4) are done for it. Usually there is no next event handler so the control passes to the next step but see for how the next handler may be defined.\n• If the object is a and the event is set to propagate (by default only event types derived from are set to propagate), then the processing restarts from the step (1) (and excluding the step (7)) for the parent window. If this object is not a window but the next handler exists, the event is passed to its parent if it is a window. This ensures that in a common case of (possibly several) non-window event handlers pushed on top of a window, the event eventually reaches the window parent.\n• Finally, i.e., if the event is still not processed, the object itself (which derives from ) gets a last chance to process it. Please pay close attention to step 6! People often overlook or get confused by this powerful feature of the wxPython event processing system. The details of event propagation up the window hierarchy are described in the next section. As mentioned above, the events of the classes deriving from wx.CommandEvent are propagated by default to the parent window if they are not processed in this window itself. But although by default only the command events are propagated like this, other events can be propagated as well because the event handling code uses to check whether an event should be propagated. It is also possible to propagate the event only a limited number of times and not until it is processed (or a top level parent window is reached). Finally, there is another additional complication (which, in fact, simplifies life of wxPython programmers significantly): when propagating the command events up to the parent window, the event propagation stops when it reaches the parent dialog, if any. This means that you don’t risk getting unexpected events from the dialog controls (which might be left unprocessed by the dialog itself because it doesn’t care about them) when a modal dialog is popped up. The events do propagate beyond the frames, however. The rationale for this choice is that there are only a few frames in a typical application and their parent-child relation are well understood by the programmer while it may be difficult, if not impossible, to track down all the dialogs that may be popped up in a complex program (remember that some are created automatically by wxPython). If you need to specify a different behaviour for some reason, you can use ( ) explicitly to prevent the events from being propagated beyond the given window or unset this flag for the dialogs that have it on by default. Typically events that deal with a window as a window (size, motion, paint, mouse, keyboard, etc.) are sent only to the window. Events that have a higher level of meaning or are generated by the window itself (button click, menu select, tree expand, etc.) are command events and are sent up to the parent to see if it is interested in the event. More precisely, as said above, all event classes not deriving from wx.CommandEvent (see the wx.Event inheritance diagram) do not propagate upward. In some cases, it might be desired by the programmer to get a certain number of system events in a parent window, for example all key events sent to, but not used by, the native controls in a dialog. In this case, a special event handler will have to be written that will override in order to pass all events (or any selection of them) to the parent window. Step 4 of the event propagation algorithm checks for the next handler in the event handler chain. This chain can be formed using : (Referring to the image, if is called and it doesn’t handle the event, will be called and so on...). Additionally, in the case of wx.Window you can build a stack (implemented using wx.EvtHandler double-linked list) using : (Referring to the image, if is called, it immediately calls ; if nor A nor B handle the event, then the wx.Window itself is used – i.e. the dynamically bind event handlers and static event table entries of wx.Window are looked as the last possibility, after all pushed event handlers were tested). By default the chain is empty, i.e. there is no next handler.\n\nCustom event classes allow you to create more polished-seeming controls by allowing the control’s user to process updates without needing to sub-class the control. However, to effectively use events, you normally need to create custom event classes. This recipe gives you some boilerplate code for creating your own custom event classes: You can bind the events normally via either binding syntax: You can also attach arbitrary data to the event during its creation, then post it to whatever window you choose: When handling events with such arbitrary data, you can fetch the data via attributes, named the same as the names passed in during the event instance creation. That is, given the two keyword arguments passed to above: # Given the above constructed event, the following is true\n\nWhile generically a wx.Event can be generated both by user actions (e.g., resize of a wx.Window) and by calls to functions (e.g., ), wxPython controls normally send wx.CommandEvent -derived events only for the user-generated events. The only exceptions to this rule are:\n• : Use instead, as is deprecated can be used instead of but the other functions, such as or don’t have event-free equivalents. Window identifiers are integers, and are used to uniquely determine window identity in the event system (though you can use it for other purposes). In fact, identifiers do not need to be unique across your entire application as long they are unique within the particular context you’re interested in, such as a frame and its children. You may use the identifier, for example, on any number of dialogs as long as you don’t have several within the same dialog. If you pass or -1 to a window constructor, an identifier will be generated for you automatically by wxPython. This is useful when you don’t care about the exact identifier either because you’re not going to process the events from the control being created or because you process the events from all controls in one place (in which case you should specify in the call as well). The automatically generated identifiers are always negative and so will never conflict with the user-specified identifiers which must be always positive. See Standard event identifiers for the list of standard identifiers available. You can use to determine the number above which it is safe to define your own identifiers. Or, you can use identifiers below . Finally, you can allocate identifiers dynamically using function too. If you use consistently in your application, you can be sure that your identifiers don’t conflict accidentally."
    },
    {
        "link": "https://stackoverflow.com/questions/11399489/event-handling-in-wxpython",
        "document": "Resource intensity is not your issue here, but you would definitely want to use one big event loop for this. Due to the Global Interpreter Lock, many event handlers in python have annoying ways of dealing the event queue, and in some event handlers it may even be impossible to check the event without removing it from the stack (VPython for example), and so in these cases you may well run into strange and hard to track errors if you use multiple checks within your code. If you use one large event this won't happen, or if it does, will be much easier to track down.\n\nRavenspoint is correct in that the resource intensity of either approach is trivial, and based on resource intensity alone you shouldn't worry about it, but a single event loop is significantly easier to maintain."
    },
    {
        "link": "https://wxpython.org/Phoenix/docs/html/events_overview.html",
        "document": "Like with all the other GUI frameworks, the control of flow in wxPython applications is event-based: the program normally performs most of its actions in response to the events generated by the user. These events can be triggered by using the input devices (such as keyboard, mouse, joystick) directly or, more commonly, by a standard control which synthesizes such input events into higher level events: for example, a wx.Button can generate a click event when the user presses the left mouse button on it and then releases it without pressing in the meanwhile. There are also events which don’t directly correspond to the user actions, such as wx.TimerEvent.\n\nBut in all cases wxPython represents these events in a uniform way and allows you to handle them in the same way wherever they originate from. And while the events are normally generated by wxPython itself, you can also do this, which is especially useful when using custom events (see Custom Event Summary).\n\nTo be more precise, each event is described by:\n• None Event type: this is simply a value of type EventType which uniquely identifies the type of the event. For example, clicking on a button, selecting an item from a list box and pressing a key on the keyboard all generate events with different event types.\n• None Event class: carried by the event: each event has some information associated with it and this data is represented by an object of a class derived from wx.Event. Events of different types can use the same event class, for example both button click and listbox selection events use wx.CommandEvent class (as do all the other simple control events), but the key press event uses wx.KeyEvent as the information associated with it is different.\n• None Event source: wx.Event stores the object which generated the event and, for windows, its identifier (see Window Identifiers). As it is common to have more than one object generating events of the same type (e.g. a typical window contains several buttons, all generating the same button click event), checking the event source object or its id allows to distinguish between them.\n\nLet us start by looking at the syntax: in any place in your code, but usually in the code of the class defining the handler itself, call its method like this: Event handlers can be bound at any moment. For example, it’s possible to do some initialization first and only bind the handlers if and when it succeeds. This can avoid the need to test that the object was properly initialized in the event handlers themselves. With they simply won’t be called if it wasn’t correctly initialized. As a slight extension of the above, the handlers can also be unbound at any time with (and maybe rebound later). Almost last but very, very far from least is the flexibility which allows to bind an event to:\n• None An ordinary function like a static method or a global function. Let us now look at more examples of how to use different event handlers using the two overloads of function: first one for the object methods and the other one for arbitrary functors (callable objects, including simple functions). In addition to using a method of the object generating the event itself, you can use a method from a completely different object as an event handler: Note that MyFrameHandler doesn’t need to derive from wx.EvtHandler.\n\nThe previous sections explain how to define event handlers but don’t address the question of how exactly wxPython finds the handler to call for the given event. This section describes the algorithm used in detail. When an event is received from the windowing system, wxPython calls on the first event handler object belonging to the window generating the event. The normal order of event table searching by is as follows, with the event processing stopping as soon as a handler is found (unless the handler calls in which case it doesn’t count as having handled the event and the search continues):\n• None Before anything else happens, is called. If it returns anything but -1 (default), the event handling stops immediately.\n• None If this event handler is disabled via a call to the next three steps are skipped and the event handler resumes at step (5).\n• None If the object is a wx.Window and has an associated validator, wx.Validator gets a chance to process the event.\n• None The list of dynamically bound event handlers, i.e., those for which was called, is consulted.\n• None The event table containing all the handlers defined using the event table macros in this class and its base classes is examined. Notice that this means that any event handler defined in a base class will be executed at this step.\n• None The event is passed to the next event handler, if any, in the event handler chain, i.e., the steps (1) to (4) are done for it. Usually there is no next event handler so the control passes to the next step but see Event Handlers Chain for how the next handler may be defined.\n• None If the object is a wx.Window and the event is set to propagate (by default only event types derived from wx.CommandEvent are set to propagate), then the processing restarts from the step (1) (and excluding the step (7)) for the parent window. If this object is not a window but the next handler exists, the event is passed to its parent if it is a window. This ensures that in a common case of (possibly several) non-window event handlers pushed on top of a window, the event eventually reaches the window parent.\n• None Finally, i.e., if the event is still not processed, the wx.App object itself (which derives from wx.EvtHandler) gets a last chance to process it. Please pay close attention to step 6! People often overlook or get confused by this powerful feature of the wxPython event processing system. The details of event propagation up the window hierarchy are described in the next section. As mentioned above, the events of the classes deriving from wx.CommandEvent are propagated by default to the parent window if they are not processed in this window itself. But although by default only the command events are propagated like this, other events can be propagated as well because the event handling code uses to check whether an event should be propagated. It is also possible to propagate the event only a limited number of times and not until it is processed (or a top level parent window is reached). Finally, there is another additional complication (which, in fact, simplifies life of wxPython programmers significantly): when propagating the command events up to the parent window, the event propagation stops when it reaches the parent dialog, if any. This means that you don’t risk getting unexpected events from the dialog controls (which might be left unprocessed by the dialog itself because it doesn’t care about them) when a modal dialog is popped up. The events do propagate beyond the frames, however. The rationale for this choice is that there are only a few frames in a typical application and their parent-child relation are well understood by the programmer while it may be difficult, if not impossible, to track down all the dialogs that may be popped up in a complex program (remember that some are created automatically by wxPython). If you need to specify a different behaviour for some reason, you can use ( ) explicitly to prevent the events from being propagated beyond the given window or unset this flag for the dialogs that have it on by default. Typically events that deal with a window as a window (size, motion, paint, mouse, keyboard, etc.) are sent only to the window. Events that have a higher level of meaning or are generated by the window itself (button click, menu select, tree expand, etc.) are command events and are sent up to the parent to see if it is interested in the event. More precisely, as said above, all event classes not deriving from wx.CommandEvent (see the wx.Event inheritance diagram) do not propagate upward. In some cases, it might be desired by the programmer to get a certain number of system events in a parent window, for example all key events sent to, but not used by, the native controls in a dialog. In this case, a special event handler will have to be written that will override in order to pass all events (or any selection of them) to the parent window. Step 4 of the event propagation algorithm checks for the next handler in the event handler chain. This chain can be formed using : (Referring to the image, if is called and it doesn’t handle the event, will be called and so on…). Additionally, in the case of wx.Window you can build a stack (implemented using wx.EvtHandler double-linked list) using : (Referring to the image, if is called, it immediately calls ; if nor A nor B handle the event, then the wx.Window itself is used – i.e. the dynamically bind event handlers and static event table entries of wx.Window are looked as the last possibility, after all pushed event handlers were tested). By default the chain is empty, i.e. there is no next handler.\n\nWhile generically a wx.Event can be generated both by user actions (e.g., resize of a wx.Window) and by calls to functions (e.g., ), wxPython controls normally send wx.CommandEvent -derived events only for the user-generated events. The only exceptions to this rule are:\n• None : Use instead, as is deprecated can be used instead of but the other functions, such as or don’t have event-free equivalents. Window identifiers are integers, and are used to uniquely determine window identity in the event system (though you can use it for other purposes). In fact, identifiers do not need to be unique across your entire application as long they are unique within the particular context you’re interested in, such as a frame and its children. You may use the identifier, for example, on any number of dialogs as long as you don’t have several within the same dialog. If you pass or -1 to a window constructor, an identifier will be generated for you automatically by wxPython. This is useful when you don’t care about the exact identifier either because you’re not going to process the events from the control being created or because you process the events from all controls in one place (in which case you should specify in the call as well). The automatically generated identifiers are always negative and so will never conflict with the user-specified identifiers which must be always positive. See Standard event identifiers for the list of standard identifiers available. You can use to determine the number above which it is safe to define your own identifiers. Or, you can use identifiers below . Finally, you can allocate identifiers dynamically using function too. If you use consistently in your application, you can be sure that your identifiers don’t conflict accidentally."
    },
    {
        "link": "https://stackoverflow.com/questions/69276871/wxpython-event-handling-button",
        "document": "When I'm running the following code, I received the error (image attached) I have a button called and when I add it to my right panel I cannot move its position, does anyone knows how can I do that? And another issue is that I'd like to call that specific button when I click on on the left panel, however I have no clue how to do this, I tried to put the button on the method but I wasn't able to make it work.\n\nThe whole code is down below so it's easier to copy-paste it.\n\nOne last question would be, do you know any resources other than the documentation to understand more in depth about this library? (Youtube videos, Udemy, etc)"
    },
    {
        "link": "https://stackoverflow.com/questions/20227014/pulling-data-out-of-ms-word-with-pywin32",
        "document": "I am running python 3.3 in Windows and I need to pull strings out of Word documents. I have been searching far and wide for about a week on the best method to do this. Originally I tried to save the .docx files as .txt and parse through using RE's, but I had some formatting problems with hidden characters - I was using a script to open a .docx and save as .txt. I am wondering if I did a proper File>SaveAs>.txt would it strip out the odd formatting and then I could properly parse through? I don't know but I gave up on this method.\n\nI tried to use the docx module but I've been told it is not compatible with python 3.3. So I am left with using pywin32 and the COM. I have used this successfully with Excel to get the data I need but I am having trouble with Word because there is FAR less documentation and reading through the object model on Microsoft's website is over my head.\n\nHere is what I have so far to open the document(s):\n\nSo at this point I can do something like\n\nAnd see the contents of the files, but it still looks like there is some odd formatting in there and I have no idea how to actually parse through to grab the data I need. I can create RE's that will successfully find the strings that I'm looking for, I just don't know how to implement them into the program using the COM.\n\nThe code I have so far was mostly found through Google. I don't even think this is that hard, it's just that reading through the object model on Microsoft's website is like reading a foreign language. Any help is MUCH appreciated. Thank you.\n\nEdit: code I was using to save the files from docx to txt:"
    },
    {
        "link": "https://stackoverflow.com/questions/15274601/opening-a-ms-word-file-in-pywin32",
        "document": "You need to open the file from the correct location.\n\nYou might try this:\n\nof course, remember to close the doc with doc.Close() and quit Word with Word.Quit() later."
    },
    {
        "link": "https://fortes-arthur.medium.com/handling-with-doc-extension-with-python-b6491792311e",
        "document": "\n• If you are using Anaconda, please skip this step.\n\nFor more information about installation, you could access win32com Github.\n\nHere’s a script to save Word documents in and below a given directory to text.\n\nTo get other elements of the document, you ca use the follow command:\n\nWhen using win32com, bear in mind that you are talking to the Word object model. You don’t need to know a lot of VBA or other languages to apply the samples to using Python; you just need to figure out which parts of the object model are being used. Here, we have a simple example of how create a Word Document with content.\n\nHere you will find a simple example how to create a small Table in Word and to fill it with date.\n\nTo copy the contents of a Word document and paste it into an Outlook application, just follow the code below.\n\nFile handling in Python is pretty easy because most of the basic operations just take a single line of code to do the job, as we have seen in this article. However, when you need to handling with a proprietary software some difficulties begin to appear. In this article, I introduced the win32com lib, which is capable of manipulating .doc extension, the mainly Microsoft Word format. I hope this content be useful for you."
    },
    {
        "link": "https://discuss.python.org/t/printing-hard-copies/3471",
        "document": "There’s some information on printing PDF documents here. http://timgolden.me.uk/python/win32_how_do_i/print.html#shellexecute\n\n Have you already tried this?\n\nThe win32print module’s api documentation is here: http://timgolden.me.uk/pywin32-docs/win32print.html"
    },
    {
        "link": "https://community.esri.com/t5/python-questions/import-text-files-into-preformatted-word-document/td-p/328166",
        "document": "I have this incredibly long python script that ultimately ends up with several text files (generated using ArcGIS 10.1) that I would like to import into a pre-formatted MS Word document/template. I want the files imported into the document and then displayed within MS Word for review. \n\n\n\n Can this be done? And if so, what approaches would you, the python gurus, recommend? \n\n\n\n I attached some very small dummy sample files (Lou Gehrig speech for those baseball fans) in hopes that I could get some specific code examples to go by and then modify as I progress through the text file generation scripting process, which is on-going. Let???s assume files are kept in C:\\Test. Using python 2.7. MS Word 2007. \n\n\n\n Thank you all in advance. \n\n\n\n \n\n\n\n \n\n SampleResult.docx - A sample of the resulting word document after scripting \n\n textfile1.txt - sample of 1st paragraph to be imported \n\n textfile2.txt - sample of 2nd paragraph to be imported \n\n textfile2.txt - sample of 3rd paragraph to be imported \n\n textfile2.txt - sample of 4th paragraph to be imported"
    }
]