[
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/fundamentals/startup?view=aspnetcore-9.0",
        "document": "This information relates to a pre-release product that may be substantially modified before it's commercially released. Microsoft makes no warranties, express or implied, with respect to the information provided here. For the current release, see the .NET 9 version of this article.\n\nASP.NET Core apps created with the web templates contain the application startup code in the file. var builder = WebApplication.CreateBuilder(args); // Add services to the container. builder.Services.AddRazorPages(); builder.Services.AddControllersWithViews(); var app = builder.Build(); // Configure the HTTP request pipeline. if (!app.Environment.IsDevelopment()) { app.UseExceptionHandler(\"/Error\"); app.UseHsts(); } app.UseHttpsRedirection(); app.UseStaticFiles(); app.UseAuthorization(); app.MapGet(\"/hi\", () => \"Hello!\"); app.MapDefaultControllerRoute(); app.MapRazorPages(); app.Run(); For more information on application startup, see ASP.NET Core fundamentals overview.\n• To configure middleware at the beginning or end of an app's middleware pipeline without an explicit call to . Use to add defaults to the beginning of the pipeline without explicitly registering the default middleware. allows a different component to call on behalf of the app author.\n• To create a pipeline of methods. IStartupFilter.Configure can set a middleware to run before or after middleware added by libraries. implements Configure, which receives and returns an . An IApplicationBuilder defines a class to configure an app's request pipeline. For more information, see Create a middleware pipeline with IApplicationBuilder. Each can add one or more middlewares in the request pipeline. The filters are invoked in the order they were added to the service container. Filters may add middleware before or after passing control to the next filter, thus they append to the beginning or end of the app pipeline. The following example demonstrates how to register a middleware with . The middleware sets an options value from a query string parameter: public class RequestSetOptionsMiddleware { private readonly RequestDelegate _next; public RequestSetOptionsMiddleware(RequestDelegate next) { _next = next; } // Test with https://localhost:5001/Privacy/?option=Hello public async Task Invoke(HttpContext httpContext) { var option = httpContext.Request.Query[\"option\"]; if (!string.IsNullOrWhiteSpace(option)) { httpContext.Items[\"option\"] = WebUtility.HtmlEncode(option); } await _next(httpContext); } } The is configured in the class: The is registered in : When a query string parameter for is provided, the middleware processes the value assignment before the ASP.NET Core middleware renders the response: Middleware execution order is set by the order of registrations:\n• None Multiple implementations may interact with the same objects. If ordering is important, order their service registrations to match the order that their middlewares should run.\n• None Libraries may add middleware with one or more implementations that run before or after other app middleware registered with . To invoke an middleware before a middleware added by a library's :\n• Position the service registration before the library is added to the service container.\n• To invoke afterward, position the service registration after the library is added. Note: You can't extend the ASP.NET Core app when you override . For more information, see this GitHub issue. Add configuration at startup from an external assembly An IHostingStartup implementation allows adding enhancements to an app at startup from an external assembly outside of the app's file. For more information, see Use hosting startup assemblies in ASP.NET Core."
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/fundamentals?view=aspnetcore-9.0",
        "document": ""
    },
    {
        "link": "https://canro91.github.io/2024/09/25/MigratingStartupClass",
        "document": "How to Handle the Startup Class When Migrating ASP.NET Core Projects\n\n.NET 6.0 replaced the Startup class with a new hosting model and a simplified Program.cs file.\n\nThe Startup class is still available in newer versions. If we’re migrating a pre-.NET 6.0 project, the .NET upgrade assistant tool does the work while keeping the Startup class.\n\nHere are 3 alternatives to handle with the Startup class when migrating to newer versions:\n\nNewer versions of ASP.NET Core work perfectly fine with the old Program.cs file and Startup class, we can choose to do nothing and keep them.\n\nIf we want to keep the Startup class, here’s what Microsoft official docs show to make the Startup class work with the new hosting model and the simplified Program.cs:\n\nWe created a new instance of Startup inside the new Program.cs file.\n\nIf we really want to ditch the Startup class, Andrew Lock recommends a hybrid approach in his blog:\n\nTurn the methods from the Startup class into private methods in the new Program.cs file.\n\nAnd if we want our Program.cs to look like the newer ones, there’s no automatic tool for that (at least I couldn’t find one in my Googling session). We have to copy the contents of the Startup class into the Program.cs file, by hand:\n\nWe cut and pasted the content of Startup inside the right sections of the new Program.cs. This time, we get some warnings about deprecated methods and their alternatives.\n\nVoilà! If you’re a lazy developer like me, do nothing or go with the approach from the official docs. Otherwise, go with any of the other two options."
    },
    {
        "link": "https://medium.com/@iamcesaraguirre/three-alternatives-for-the-startup-class-when-migrating-asp-net-core-projects-fbba269623e5",
        "document": "Three Alternatives for the Startup Class When Migrating ASP.NET Core Projects\n\n.NET 6.0 replaced the Startup class with a new hosting model and a simplified Program.cs file.\n\nThe Startup class is still available in newer versions. If we’re migrating a pre-.NET 6.0 project, the .NET upgrade assistant tool does the work while keeping the Startup class.\n\nHere are 3 alternatives to handle the Startup class when migrating to newer versions:\n\nNewer versions of ASP.NET Core work perfectly fine with the old Program.cs file and Startup class, we can choose to do nothing and keep them.\n\nIf we want to keep the Startup class, here’s what Microsoft official docs show to make the Startup class work with the new hosting model and the simplified Program.cs:\n\nWe created a new instance of Startup inside the new Program.cs file.\n\nIf we really want to ditch the Startup class, Andrew Lock recommends a hybrid approach in his blog:\n\nTurn the methods from the Startup class into private methods in the new Program.cs file.\n\nAnd if we want our Program.cs to look like the newer ones, there’s no automatic tool for that (at least I couldn’t find one in my Googling session).\n\nWe have to copy the contents of the Startup class into the Program.cs file, by hand:\n\nWe cut and pasted the content of Startup inside the right sections of the new Program.cs. This time, we get some warnings about deprecated methods and their alternatives.\n\nVoilà! If you’re a lazy developer like me, do nothing or go with the approach from the official docs. Otherwise, go with any of the other two options."
    },
    {
        "link": "https://itnext.io/a-cleaner-startup-for-net-6s-minimal-approach-c1c05a672c6a",
        "document": "After reading the .NET Migration Documentation in the past week, I have formulated an alternative to the suggested methods from Microsoft. To be honest, I created this approach last year and recently refined it, to make it ready to share with others.\n\nThe starting point was finding some posts about using the file in the new .NET 6 minimal hosting model. I know I'm not alone in finding Microsoft's format more annoying than anything. With Microsoft removing the file as the default, this lead me to assume they were proposing that Program.cs would be a heavy and long mess. In reading the posts and Microsoft's documentation I've come to realise that they have a suggested implementation. Problem is I think the implementation is a little messy."
    },
    {
        "link": "https://stackoverflow.com/questions/76859173/how-to-merge-startup-cs-into-program-cs",
        "document": "Not exactly. ASP.NET Core 6 introduced a new so called minimal hosting model (which is used by the default template). But you are free to keep the generic hosting model if you want.\n\nIn short - move everything from to before call and everything from - after it (check out code generated by the default template). To setup services you can use , configuration is accessible from both and via correspondingly named property and use to perform the calls from .\n• Code samples migrated to the new minimal hosting model in ASP.NET Core 6.0\n• ASP.NET Core 6 how to access Configuration during startup"
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/core/migration/50-to-60-samples?view=aspnetcore-9.0",
        "document": "Code samples migrated to the new minimal hosting model in ASP.NET Core 6.0\n\nThis article provides samples of code migrated to ASP.NET Core 6.0. ASP.NET Core 6.0 uses a new minimal hosting model. For more information, see New hosting model.\n\nThe following code adds the Static File Middleware to an ASP.NET Core 5 app:\n\nThe following code adds the Static File Middleware to an ASP.NET Core 6 app:\n\nWebApplication.CreateBuilder initializes a new instance of the WebApplicationBuilder class with preconfigured defaults. For more information, see ASP.NET Core Middleware\n\nThe following code adds an endpoint to an ASP.NET Core 5 app:\n\nIn .NET 6, routes can be added directly to the WebApplication without an explicit call to UseEndpoints or UseRouting. The following code adds an endpoint to an ASP.NET Core 6 app:\n\nNote: Routes added directly to the WebApplication execute at the end of the pipeline.\n\nChange the content root, app name, and environment\n\nFor more information, see ASP.NET Core fundamentals overview\n\nChange the content root, app name, and environment by environment variables or command line\n\nThe following table shows the environment variable and command-line argument used to change the content root, app name, and environment:\n\nFor detailed information, see File configuration providers in Configuration in ASP.NET Core.\n\nFor more information, see Logging in .NET Core and ASP.NET Core.\n\nFor more information, see Dependency injection in ASP.NET Core.\n\nBy default, the web root is relative to the content root in the folder. Web root is where the static files middleware looks for static files. Web root can be changed by setting the WebRootPath property on WebApplicationOptions:\n\nThe following .NET 5 and .NET 6 samples use Autofac\n\ncan inject any service added via the IServiceCollection.\n• There are a few common services available as top level properties on WebApplication.\n• Additional services need to be manually resolved from the via WebApplication.Services.\n\nIn the following samples, the test project uses and WebApplicationFactory<TEntryPoint>. These ship as separate packages that require explicit reference:\n\nThe project file can contain one of the following:\n\nAn alternative solution is to make the class public. can be made public with Top-level statements by defining a class in the project or in :\n\nThe .NET 5 version and .NET 6 version with the are identical by design."
    },
    {
        "link": "https://gist.github.com/davidfowl/0e0372c3c1d895c3ce195ba983b1e03d?permalink_comment_id=3991955",
        "document": ".NET 6 introduces a new hosting model for ASP.NET Core applications. This model is streamlined and reduces the amount of boilerplate code required to get a basic ASP.NET Core application up and running.\n\nThis model unifies and into a single file experience that takes advantage of top level statements to remove any boilerplate. There should be a mostly mechanical translation from .NET 5 projects using a class to the new hosting model:\n\nThe above shows that can be configured using and can be configured by using .\n• The developer exception page middleware is enabled when the environment is .\n• The application name always defaults to the entry point assembly's name . When using the in a library, you will need to explicitly change the application name to the library's assembly to allow MVC's application part discovery to work (finding controllers, views etc) (see the Cheatsheet for instructions on how to do this).\n• The endpoint routing middleware wraps the entire middleware pipeline. This means there's no need to have explicit calls to to register routes. can still be used to move where route matching happens.\n• The final pipeline is created before any runs. This means that exceptions caused while building the main pipeline won't be visible to the call chain.\n• Some tools (like EF migrations) use to access the application's to execute custom logic in the context of the application, these tools have been updated to use a new technique to achieve the same thing. We will work with the ecosystem to make sure tools are all updated to use the new model.\n• It is not possible to change any host settings (application name, environment or the content root) after the creation of the (see the Cheatsheet for instructions on how to do this). The following APIs will throw an exception:\n• It is not possible to use the class via the or . The following will throw an exception:\n• The implementation on ( ), does not defer execution of , or methods. This allows code using to observe changes made to the and . The below example will only add as an .\n\nThe existing .NET ecosystem has built extensibility around , and . These properties are available on the as , and .\n\nThe implements both and .\n\nWe expect library authors to continue targeting , , and when building ASP.NET Core specific components. This will ensure that your middleware, route handler, or other extensibility points continue to work across different hosting models.\n\nNo, it should be functionally equivalent for 98% to what you can do with the and the . There are more advanced scenarios (the 2%) that will require specific knobs on but we expect those to be extremely rare.\n\nNo, it's not. It's an alternative model that will keep working forever. The generic host still underpins the new hosting model and is still the primary way to host worker-based applications.\n\nNo, you don't have to. It's the preferred way to host ASP.NET Core applications from .NET 6 and onwards but you aren't forced to change your project layout. This means you can upgrade from .NET 5 to .NET 6.0 by changing the target framework in your project file from to .\n\nThe new project templates all use top-level statements, but these new hosting APIs can be used in any .NET 6 application to host a webserver/web application.\n\nThere are 2 solutions to this problem:\n• You can store the state on another class. Assuming this was static state that you were accessing from anywhere in the application.\n• There's a class generated by top level statements that you can put this state on if you wish to keep that semantic.\n\nThis is an example of #2:\n\nThis would make it possible to use in your .NET 6 application.\n\nNOTE: We recommend using dependency injection to flow state in your ASP.NET Core applications.\n\nis the way to test the new hosting model. See the Cheatsheet for an example.\n\nThis is still supported, see the Cheatsheet for an example.\n\nYes, you can. Here's a shim you can use to keep it working as is with the new hosting model:\n\nThere are a few differences here:\n• You control the instantiation and lifetime of the class.\n• Any additional services injected into the method need to be manually resolved by your class.\n\nIn .NET 6, routes can be added directly to the without an explicit call to .\n\nNOTE: Routes added directly to the will execute at the end of the pipeline.\n\nExisting extension methods on can be accessed using the property.\n\nExisting extension methods on can be accessed using the property.\n\nBy default, the web root is relative to the content root in the folder. This is where the static files middleware expects to find static files. You can change this by using the method on the property:\n\nThis example uses Autofac\n\nIn you can inject any service added via the .\n\nIn .NET 6, there are a few common services available as top level properties on and additional services need to be manually resolved from the via .\n\nIn the below samples, the test project uses and . These ship as separate packages that need to explicit referenced:\n\nThis sample is using xUnit and will be shared between both examples:\n\nIn .NET 6, is used to test application using new hosting model. The compiler produces an class applications that use top level statements. We need to make this available to the test project by using . This can be done using the project file or in any other .cs file:\n\nThe other solution is to make the class public. You can do this with top level statements by defining a class anywhere in the project (or in ):\n\nThe .NET 5 version and .NET 6 version with the WebApplicationFactory are identical. This is by design."
    },
    {
        "link": "https://stackoverflow.com/questions/69722872/asp-net-core-6-how-to-access-configuration-during-startup",
        "document": "In earlier versions, we had Startup.cs class and we get configuration object as follows in the Startup file.\n\nNow in .NET 6 and above (With Visual Studio 2022), we don't see the Startup.cs class. Looks like its days are numbered. So how do we get these objects like Configuration(IConfiguration) and Hosting Environment(IHostEnvironment)\n\nHow do we get these objects, to say read the configuration from appsettings? Currently the Program.cs file looks like this.\n\nI want to know how to read the configuration from appsettings.json ?"
    },
    {
        "link": "https://gist.github.com/davidfowl/0e0372c3c1d895c3ce195ba983b1e03d",
        "document": ".NET 6 introduces a new hosting model for ASP.NET Core applications. This model is streamlined and reduces the amount of boilerplate code required to get a basic ASP.NET Core application up and running.\n\nThis model unifies and into a single file experience that takes advantage of top level statements to remove any boilerplate. There should be a mostly mechanical translation from .NET 5 projects using a class to the new hosting model:\n\nThe above shows that can be configured using and can be configured by using .\n• The developer exception page middleware is enabled when the environment is .\n• The application name always defaults to the entry point assembly's name . When using the in a library, you will need to explicitly change the application name to the library's assembly to allow MVC's application part discovery to work (finding controllers, views etc) (see the Cheatsheet for instructions on how to do this).\n• The endpoint routing middleware wraps the entire middleware pipeline. This means there's no need to have explicit calls to to register routes. can still be used to move where route matching happens.\n• The final pipeline is created before any runs. This means that exceptions caused while building the main pipeline won't be visible to the call chain.\n• Some tools (like EF migrations) use to access the application's to execute custom logic in the context of the application, these tools have been updated to use a new technique to achieve the same thing. We will work with the ecosystem to make sure tools are all updated to use the new model.\n• It is not possible to change any host settings (application name, environment or the content root) after the creation of the (see the Cheatsheet for instructions on how to do this). The following APIs will throw an exception:\n• It is not possible to use the class via the or . The following will throw an exception:\n• The implementation on ( ), does not defer execution of , or methods. This allows code using to observe changes made to the and . The below example will only add as an .\n\nThe existing .NET ecosystem has built extensibility around , and . These properties are available on the as , and .\n\nThe implements both and .\n\nWe expect library authors to continue targeting , , and when building ASP.NET Core specific components. This will ensure that your middleware, route handler, or other extensibility points continue to work across different hosting models.\n\nNo, it should be functionally equivalent for 98% to what you can do with the and the . There are more advanced scenarios (the 2%) that will require specific knobs on but we expect those to be extremely rare.\n\nNo, it's not. It's an alternative model that will keep working forever. The generic host still underpins the new hosting model and is still the primary way to host worker-based applications.\n\nNo, you don't have to. It's the preferred way to host ASP.NET Core applications from .NET 6 and onwards but you aren't forced to change your project layout. This means you can upgrade from .NET 5 to .NET 6.0 by changing the target framework in your project file from to .\n\nThe new project templates all use top-level statements, but these new hosting APIs can be used in any .NET 6 application to host a webserver/web application.\n\nThere are 2 solutions to this problem:\n• You can store the state on another class. Assuming this was static state that you were accessing from anywhere in the application.\n• There's a class generated by top level statements that you can put this state on if you wish to keep that semantic.\n\nThis is an example of #2:\n\nThis would make it possible to use in your .NET 6 application.\n\nNOTE: We recommend using dependency injection to flow state in your ASP.NET Core applications.\n\nis the way to test the new hosting model. See the Cheatsheet for an example.\n\nThis is still supported, see the Cheatsheet for an example.\n\nYes, you can. Here's a shim you can use to keep it working as is with the new hosting model:\n\nThere are a few differences here:\n• You control the instantiation and lifetime of the class.\n• Any additional services injected into the method need to be manually resolved by your class.\n\nIn .NET 6, routes can be added directly to the without an explicit call to .\n\nNOTE: Routes added directly to the will execute at the end of the pipeline.\n\nExisting extension methods on can be accessed using the property.\n\nExisting extension methods on can be accessed using the property.\n\nBy default, the web root is relative to the content root in the folder. This is where the static files middleware expects to find static files. You can change this by using the method on the property:\n\nThis example uses Autofac\n\nIn you can inject any service added via the .\n\nIn .NET 6, there are a few common services available as top level properties on and additional services need to be manually resolved from the via .\n\nIn the below samples, the test project uses and . These ship as separate packages that need to explicit referenced:\n\nThis sample is using xUnit and will be shared between both examples:\n\nIn .NET 6, is used to test application using new hosting model. The compiler produces an class applications that use top level statements. We need to make this available to the test project by using . This can be done using the project file or in any other .cs file:\n\nThe other solution is to make the class public. You can do this with top level statements by defining a class anywhere in the project (or in ):\n\nThe .NET 5 version and .NET 6 version with the WebApplicationFactory are identical. This is by design."
    }
]