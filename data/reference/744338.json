[
    {
        "link": "https://pytorch.org/docs/stable/generated/torch.nn.LSTM.html",
        "document": "Apply a multi-layer long short-term memory (LSTM) RNN to an input sequence. For each element in the input sequence, each layer computes the following function:\n\n\\begin{array}{ll} \\\\ i_t = \\sigma(W_{ii} x_t + b_{ii} + W_{hi} h_{t-1} + b_{hi}) \\\\ f_t = \\sigma(W_{if} x_t + b_{if} + W_{hf} h_{t-1} + b_{hf}) \\\\ g_t = \\tanh(W_{ig} x_t + b_{ig} + W_{hg} h_{t-1} + b_{hg}) \\\\ o_t = \\sigma(W_{io} x_t + b_{io} + W_{ho} h_{t-1} + b_{ho}) \\\\ c_t = f_t \\odot c_{t-1} + i_t \\odot g_t \\\\ h_t = o_t \\odot \\tanh(c_t) \\\\ \\end{array}\n\nwhere ht​ is the hidden state at time , ct​ is the cell state at time , xt​ is the input at time , ht−1​ is the hidden state of the layer at time or the initial hidden state at time , and it​, ft​, gt​, ot​ are the input, forget, cell, and output gates, respectively. σ is the sigmoid function, and ⊙ is the Hadamard product.\n\nIn a multilayer LSTM, the input xt(l)​ of the l -th layer ( l≥2) is the hidden state ht(l−1)​ of the previous layer multiplied by dropout δt(l−1)​ where each δt(l−1)​ is a Bernoulli random variable which is 0 with probability .\n\nIf is specified, LSTM with projections will be used. This changes the LSTM cell in the following way. First, the dimension of ht​ will be changed from to (dimensions of Whi​ will be changed accordingly). Second, the output hidden state of each layer will be multiplied by a learnable projection matrix: ht​=Whr​ht​. Note that as a consequence of this, the output of LSTM network will be of different shape as well. See Inputs/Outputs sections below for exact dimensions of all variables. You can find more details in https://arxiv.org/abs/1402.1128.\n• None input: tensor of shape (L,Hin​) for unbatched input, (L,N,Hin​) when or (N,L,Hin​) when containing the features of the input sequence. The input can also be a packed variable length sequence. See or for details.\n• None h_0: tensor of shape (D∗num_layers,Hout​) for unbatched input or (D∗num_layers,N,Hout​) containing the initial hidden state for each element in the input sequence. Defaults to zeros if (h_0, c_0) is not provided.\n• None c_0: tensor of shape (D∗num_layers,Hcell​) for unbatched input or (D∗num_layers,N,Hcell​) containing the initial cell state for each element in the input sequence. Defaults to zeros if (h_0, c_0) is not provided. \\begin{aligned} N ={} & \\text{batch size} \\\\ L ={} & \\text{sequence length} \\\\ D ={} & 2 \\text{ if bidirectional=True otherwise } 1 \\\\ H_{in} ={} & \\text{input\\_size} \\\\ H_{cell} ={} & \\text{hidden\\_size} \\\\ H_{out} ={} & \\text{proj\\_size if } \\text{proj\\_size}>0 \\text{ otherwise hidden\\_size} \\\\ \\end{aligned}\n• None output: tensor of shape (L,D∗Hout​) for unbatched input, (L,N,D∗Hout​) when or (N,L,D∗Hout​) when containing the output features from the last layer of the LSTM, for each . If a has been given as the input, the output will also be a packed sequence. When , will contain a concatenation of the forward and reverse hidden states at each time step in the sequence.\n• None h_n: tensor of shape (D∗num_layers,Hout​) for unbatched input or (D∗num_layers,N,Hout​) containing the final hidden state for each element in the sequence. When , will contain a concatenation of the final forward and reverse hidden states, respectively.\n• None c_n: tensor of shape (D∗num_layers,Hcell​) for unbatched input or (D∗num_layers,N,Hcell​) containing the final cell state for each element in the sequence. When , will contain a concatenation of the final forward and reverse cell states, respectively.\n\nThere are known non-determinism issues for RNN functions on some versions of cuDNN and CUDA. You can enforce deterministic behavior by setting the following environment variables: On CUDA 10.1, set environment variable . This may affect performance. On CUDA 10.2 or later, set environment variable (note the leading colon symbol) or . See the cuDNN 8 Release Notes for more information."
    },
    {
        "link": "https://pytorch.org/docs/stable/nn.html",
        "document": "These are the basic building blocks for graphs:\n\nApplies a 1D convolution over an input signal composed of several input planes. Applies a 2D convolution over an input signal composed of several input planes. Applies a 3D convolution over an input signal composed of several input planes. Applies a 1D transposed convolution operator over an input image composed of several input planes. Applies a 2D transposed convolution operator over an input image composed of several input planes. Applies a 3D transposed convolution operator over an input image composed of several input planes. A module with lazy initialization of the argument. A module with lazy initialization of the argument. A module with lazy initialization of the argument. A module with lazy initialization of the argument. A module with lazy initialization of the argument. A module with lazy initialization of the argument. Combines an array of sliding local blocks into a large containing tensor.\n\nApplies a 1D max pooling over an input signal composed of several input planes. Applies a 2D max pooling over an input signal composed of several input planes. Applies a 3D max pooling over an input signal composed of several input planes. Applies a 1D average pooling over an input signal composed of several input planes. Applies a 2D average pooling over an input signal composed of several input planes. Applies a 3D average pooling over an input signal composed of several input planes. Applies a 2D fractional max pooling over an input signal composed of several input planes. Applies a 3D fractional max pooling over an input signal composed of several input planes. Applies a 1D power-average pooling over an input signal composed of several input planes. Applies a 2D power-average pooling over an input signal composed of several input planes. Applies a 3D power-average pooling over an input signal composed of several input planes. Applies a 1D adaptive max pooling over an input signal composed of several input planes. Applies a 2D adaptive max pooling over an input signal composed of several input planes. Applies a 3D adaptive max pooling over an input signal composed of several input planes. Applies a 1D adaptive average pooling over an input signal composed of several input planes. Applies a 2D adaptive average pooling over an input signal composed of several input planes. Applies a 3D adaptive average pooling over an input signal composed of several input planes.\n\nPads the input tensor using the reflection of the input boundary. Pads the input tensor using the reflection of the input boundary. Pads the input tensor using the reflection of the input boundary. Pads the input tensor using replication of the input boundary. Pads the input tensor using replication of the input boundary. Pads the input tensor using replication of the input boundary. Pads the input tensor boundaries with zero. Pads the input tensor boundaries with zero. Pads the input tensor boundaries with zero. Pads the input tensor boundaries with a constant value. Pads the input tensor boundaries with a constant value. Pads the input tensor boundaries with a constant value. Pads the input tensor using circular padding of the input boundary. Pads the input tensor using circular padding of the input boundary. Pads the input tensor using circular padding of the input boundary.\n\nCreates a criterion that measures the mean absolute error (MAE) between each element in the input x and target y. Creates a criterion that measures the mean squared error (squared L2 norm) between each element in the input x and target y. This criterion computes the cross entropy loss between input logits and target. Creates a criterion that measures the Binary Cross Entropy between the target and the input probabilities: This loss combines a layer and the in one single class. Creates a criterion that measures the loss given inputs x1, x2, two 1D mini-batch or 0D , and a label 1D mini-batch or 0D y (containing 1 or -1). Measures the loss given an input tensor x and a labels tensor y (containing 1 or -1). Creates a criterion that optimizes a multi-class multi-classification hinge loss (margin-based loss) between input x (a 2D mini-batch ) and output y (which is a 2D of target class indices). Creates a criterion that uses a squared term if the absolute element-wise error falls below delta and a delta-scaled L1 term otherwise. Creates a criterion that uses a squared term if the absolute element-wise error falls below beta and an L1 term otherwise. Creates a criterion that optimizes a two-class classification logistic loss between input tensor x and target tensor y (containing 1 or -1). Creates a criterion that optimizes a multi-label one-versus-all loss based on max-entropy, between input x and target y of size (N,C). Creates a criterion that measures the loss given input tensors x1​, x2​ and a label y with values 1 or -1. Creates a criterion that optimizes a multi-class classification hinge loss (margin-based loss) between input x (a 2D mini-batch ) and output y (which is a 1D tensor of target class indices, 0≤y≤x.size(1)−1): Creates a criterion that measures the triplet loss given an input tensors x1, x2, x3 and a margin with a value greater than 0. Creates a criterion that measures the triplet loss given input tensors a, p, and n (representing anchor, positive, and negative examples, respectively), and a nonnegative, real-valued function (\"distance function\") used to compute the relationship between the anchor and positive example (\"positive distance\") and the anchor and negative example (\"negative distance\").\n\nClip the gradient norm of an iterable of parameters. Clip the gradient norm of an iterable of parameters. Clip the gradients of an iterable of parameters at specified value. Compute the norm of an iterable of tensors. Scale the gradients of an iterable of parameters given a pre-calculated total norm and desired max norm. Utility functions to flatten and unflatten Module parameters to and from a single vector. Flatten an iterable of parameters into a single vector. Copy slices of a vector into an iterable of parameters. Fuse a convolutional module and a BatchNorm module into a single, new convolutional module. Fuse convolutional module parameters and BatchNorm module parameters into new convolutional module parameters. Fuse a linear module and a BatchNorm module into a single, new linear module. Fuse linear module parameters and BatchNorm module parameters into new linear module parameters. Convert of to The conversion recursively applies to nested , including . Utility functions to apply and remove weight normalization from Module parameters. Apply weight normalization to a parameter in the given module. Apply spectral normalization to a parameter in the given module. Given a module class object and args / kwargs, instantiate the module without initializing parameters / buffers. Abstract base class for creation of new pruning techniques. Utility pruning method that does not prune any units but generates the pruning parametrization with a mask of ones. Prune (currently unpruned) units in a tensor at random. Prune (currently unpruned) units in a tensor by zeroing out the ones with the lowest L1-norm. Prune entire (currently unpruned) channels in a tensor at random. Prune entire (currently unpruned) channels in a tensor based on their L -norm. Prune tensor by removing units with the lowest L1-norm. Prune tensor by removing random channels along the specified dimension. Prune tensor by removing channels with the lowest L -norm along the specified dimension. Globally prunes tensors corresponding to all parameters in by applying the specified . Prune tensor corresponding to parameter called in by applying the pre-computed mask in . Remove the pruning reparameterization from a module and the pruning method from the forward hook. Check if a module is pruned by looking for pruning pre-hooks. Parametrizations implemented using the new parametrization functionality in . Apply an orthogonal or unitary parametrization to a matrix or a batch of matrices. Apply weight normalization to a parameter in the given module. Apply spectral normalization to a parameter in the given module. Utility functions to parametrize Tensors on existing Modules. Note that these functions can be used to parametrize a given Parameter or Buffer given a specific function that maps from an input space to the parametrized space. They are not parameterizations that would transform an object into a parameter. See the Parametrizations tutorial for more information on how to implement your own parametrizations. Remove the parametrizations on a tensor in a module. Context manager that enables the caching system within parametrizations registered with . A sequential container that holds and manages the original parameters or buffers of a parametrized . Utility functions to call a given Module in a stateless manner. Perform a functional call on the module by replacing the module parameters and buffers with the provided ones. Holds the data and list of of a packed sequence."
    },
    {
        "link": "https://pytorch.org/blog/pytorch-1.12-released",
        "document": "We are excited to announce the release of PyTorch 1.12 (release note)! This release is composed of over 3124 commits, 433 contributors. Along with 1.12, we are releasing beta versions of AWS S3 Integration, PyTorch Vision Models on Channels Last on CPU, Empowering PyTorch on Intel® Xeon® Scalable processors with Bfloat16 and FSDP API. We want to sincerely thank our dedicated community for your contributions.\n• Functional APIs to functionally apply module computation with a given set of parameters\n• Changes to float32 matrix multiplication precision on Ampere and later CUDA hardware\n• TorchArrow, a new beta library for machine learning preprocessing over batch data\n\nWe’ve got a new Beta release ready for you to try and use: TorchArrow. This is a library for machine learning preprocessing over batch data. It features a performant and Pandas-style, easy-to-use API in order to speed up your preprocessing workflows and development.\n\nCurrently, it provides a Python DataFrame interface with the following features:\n• Seamless handoff with PyTorch or other model authoring, such as Tensor collation and easily plugging into PyTorch DataLoader and DataPipes\n• Zero copy for external readers via Arrow in-memory columnar format\n\nFor more details, please find our 10-min tutorial, installation instructions, API documentation, and a prototype for data preprocessing in TorchRec.\n\nPyTorch 1.12 introduces a new beta feature to functionally apply Module computation with a given set of parameters. Sometimes, the traditional PyTorch Module usage pattern that maintains a static set of parameters internally is too restrictive. This is often the case when implementing algorithms for meta-learning, where multiple sets of parameters may need to be maintained across optimizer steps.\n\nThe new API allows for:\n• Module computation with full flexibility over the set of parameters used\n• No need to reimplement your module in a functional way\n• Any parameter or buffer present in the module can be swapped with an externally-defined value for use in the call. Naming for referencing parameters / buffers follows the fully-qualified form in the module’s\n\nPyTorch today natively supports complex numbers, complex autograd, complex modules, and numerous complex operations, including linear algebra and Fast Fourier Transform (FFT) operators. Many libraries, including torchaudio and ESPNet, already make use of complex numbers in PyTorch, and PyTorch 1.12 further extends complex functionality with complex convolutions and the experimental complex32 (“complex half”) data type that enables half precision FFT operations. Due to the bugs in CUDA 11.3 package, we recommend using CUDA 11.6 package from wheels if you are using complex numbers.\n\nForward-mode AD allows the computation of directional derivatives (or equivalently, Jacobian-vector products) eagerly in the forward pass. PyTorch 1.12 significantly improves the operator coverage for forward-mode AD. See our tutorial for more information.\n\n`DataPipe` from TorchData becomes fully backward compatible with the existing `DataLoader` regarding shuffle determinism and dynamic sharding in both multiprocessing and distributed environments.\n\nDataPipes based on AWSSDK have been integrated into TorchData. It provides the following features backed by native AWSSDK:\n• Retrieve list of urls from each S3 bucket based on prefix\n\nAWS native DataPipes are still in the beta phase. And, we will keep tuning them to improve their performance.\n\nDataLoader2 became available in prototype mode. We are introducing new ways to interact between DataPipes, DataLoading API, and backends (aka ReadingServices). Feature is stable in terms of API, but functionally not complete yet. We welcome early adopters and feedback, as well as potential contributors.\n\nFor more details, please checkout the link.\n\nInspired by Google JAX, functorch is a library that offers composable vmap (vectorization) and autodiff transforms. It enables advanced autodiff use cases that would otherwise be tricky to express in PyTorch. Examples of these include:\n\nWe’re excited to announce functorch 0.2.0 with a number of improvements and new experimental features.\n\nWe significantly improved coverage for (our forward-mode autodiff API) and other APIs that rely on it ( ).\n\nGiven a function f, returns a new function without mutations (with caveats). This is useful for constructing traces of PyTorch functions without in-place operations. For example, you can use to construct a mutation-free trace of a pytorch function. To learn more, please see the documentation.\n\nFor more details, please see our installation instructions, documentation, tutorials, and release notes.\n\nIn PyTorch 1.12, Torchscript is updating its default fuser (for Volta and later CUDA accelerators) to nvFuser, which supports a wider range of operations and is faster than NNC, the previous fuser for CUDA devices. A soon to be published blog post will elaborate on nvFuser and show how it speeds up training on a variety of networks.\n\nSee the nvFuser documentation for more details on usage and debugging.\n\nChanges to float32 matrix multiplication precision on Ampere and later CUDA hardware\n\nPyTorch supports a variety of “mixed precision” techniques, like the torch.amp (Automated Mixed Precision) module and performing float32 matrix multiplications using the TensorFloat32 datatype on Ampere and later CUDA hardware for faster internal computations. In PyTorch 1.12 we’re changing the default behavior of float32 matrix multiplications to always use full IEEE fp32 precision, which is more precise but slower than using the TensorFloat32 datatype for internal computation. For devices with a particularly high ratio of TensorFloat32 to float32 throughput such as A100, this change in defaults can result in a large slowdown.\n\nIf you’ve been using TensorFloat32 matrix multiplications then you can continue to do so by setting\n\nwhich is supported since PyTorch 1.7. Starting in PyTorch 1.12 the new matmul precision API can be used, too:\n\nTo reiterate, PyTorch’s new default is “highest” precision for all device types. We think this provides better consistency across device types for matrix multiplications. Documentation for the new precision API can be found here. Setting the “high” or “medium” precision types will enable TensorFloat32 on Ampere and later CUDA devices. If you’re updating to PyTorch 1.12 then to preserve the current behavior and faster performance of matrix multiplications on Ampere devices, set precision to “high”.\n\nUsing mixed precision techniques is essential for training many modern deep learning networks efficiently, and if you’re already using torch.amp this change is unlikely to affect you. If you’re not familiar with mixed precision training then see our soon to be published “What Every User Should Know About Mixed Precision Training in PyTorch” blogpost.\n\n(Beta) Accelerating PyTorch Vision Models with Channels Last on CPU\n\nMemory formats have a significant impact on performance when running vision models, generally Channels Last is more favorable from a performance perspective due to better data locality. 1.12 includes fundamental concepts of memory formats and demonstrates performance benefits using Channels Last on popular PyTorch vision models on Intel® Xeon® Scalable processors.\n• Enables Channels Last memory format support for the commonly used operators in CV domain on CPU, applicable for both inference and training\n• Provides native level optimization on Channels Last kernels from ATen, applicable for both AVX2 and AVX512\n• Delivers 1.3x to 1.8x inference performance gain over Channels First for TorchVision models on Intel® Xeon® Ice Lake (or newer) CPUs\n\nReduced precision numeric formats like bfloat16 improves PyTorch performance across multiple deep learning training workloads. PyTorch 1.12 includes the latest software enhancements on bfloat16 which applies to a broader scope of user scenarios and showcases even higher performance gains. The main improvements include:\n• 2x hardware compute throughput vs. float32 with the new bfloat16 native instruction VDPBF16PS, introduced on Intel® Xeon® Cooper Lake CPUs\n• 1.4x to 2.2x inference performance gain over float32 for TorchVision models on Intel® Xeon® Cooper Lake (or newer) CPUs\n\nWith the PyTorch 1.12 release, developers and researchers can now take advantage of Apple silicon GPUs for significantly faster model training. This unlocks the ability to perform machine learning workflows like prototyping and fine-tuning locally, right on Mac. Accelerated GPU training is enabled using Apple’s Metal Performance Shaders (MPS) as a backend. The benefits include performance speedup from accelerated GPU training and the ability to train larger networks or batch sizes locally. Learn more here.\n\nAlongside the new MPS device support, the M1 binaries for Core and Domain libraries that have been available for the last few releases are now an official prototype feature. These binaries can be used to run PyTorch natively on Apple Silicon.\n\nPyTorch now supports CPU and GPU fastpath implementations (“BetterTransformer”) for several Transformer Encoder modules including TransformerEncoder, TransformerEncoderLayer, and MultiHeadAttention (MHA). The BetterTransformer fastpath architecture Better Transformer is consistently faster – 2x for many common execution scenarios, depending on model and input characteristics. The new BetterTransformer-enabled modules are API compatible with previous releases of the PyTorch Transformer API and will accelerate existing models if they meet fastpath execution requirements, as well as read models trained with previous versions of PyTorch. PyTorch 1.12 includes:\n• Torchtext which builds on the PyTorch Transformer API\n• Fastpath execution for improved performance by reducing execution overheads with fused kernels which combines multiple operators into a single kernel\n• Option to achieve additional speedups by taking advantage of data sparsity during the processing of padding tokens in natural-language processing (by setting enable_nested_tensor=True when creating a TransformerEncoder)\n• Diagnostics to help users understand why fastpath execution did not occur\n\nFSDP API helps easily scale large model training by sharding a model’s parameters, gradients and optimizer states across data parallel workers while maintaining the simplicity of data parallelism. The prototype version was released in PyTorch 1.11 with a minimum set of features that helped scaling tests of models with up to 1T parameters.\n\nIn this beta release, FSDP API added the following features to support various production workloads. Highlights of the the newly added features in this beta release include:\n• Universal sharding strategy API - Users can easily change between sharding strategies with a single line change, and thus compare and use DDP (only data sharding), FSDP (full model and data sharding), or Zero2 (only sharding of optimizer and gradients) to optimize memory and performance for their specific training needs\n• Fine grained mixed precision policies - Users can specify a mix of half and full data types (bfloat16, fp16 or fp32) for model parameters, gradient communication, and buffers via mixed precision policies. Models are automatically saved in fp32 to allow for maximum portability\n• Transformer auto wrapping policy - allows for optimal wrapping of Transformer based models by registering the models layer class, and thus accelerated training performance\n• Faster model initialization using device_id init - initialization is performed in a streaming fashion to avoid OOM issues and optimize init performance vs CPU init\n• Rank0 streaming for full model saving of larger models - Fully sharded models can be saved by all GPU’s streaming their shards to the rank 0 GPU, and the model is built in full state on the rank 0 CPU for saving\n\nFor more details and example code, please checkout the documentation and the tutorial.\n\nThanks for reading, If you’re interested in these updates and want to join the PyTorch community, we encourage you to join the discussion forums and open GitHub issues. To get the latest news from PyTorch, follow us on Twitter, Medium, YouTube, and LinkedIn."
    },
    {
        "link": "https://pytorch.org/docs/stable/generated/torch.nn.GRU.html",
        "document": "Apply a multi-layer gated recurrent unit (GRU) RNN to an input sequence. For each element in the input sequence, each layer computes the following function:\n\nwhere ht​ is the hidden state at time , xt​ is the input at time , h(t−1)​ is the hidden state of the layer at time or the initial hidden state at time , and rt​, zt​, nt​ are the reset, update, and new gates, respectively. σ is the sigmoid function, and ⊙ is the Hadamard product.\n\nIn a multilayer GRU, the input xt(l)​ of the l -th layer ( l≥2) is the hidden state ht(l−1)​ of the previous layer multiplied by dropout δt(l−1)​ where each δt(l−1)​ is a Bernoulli random variable which is 0 with probability .\n• None input_size – The number of expected features in the input\n• None hidden_size – The number of features in the hidden state\n• None num_layers – Number of recurrent layers. E.g., setting would mean stacking two GRUs together to form a , with the second GRU taking in outputs of the first GRU and computing the final results. Default: 1\n• None bias – If , then the layer does not use bias weights and . Default:\n• None batch_first – If , then the input and output tensors are provided as instead of . Note that this does not apply to hidden or cell states. See the Inputs/Outputs sections below for details. Default:\n• None dropout – If non-zero, introduces a layer on the outputs of each GRU layer except the last layer, with dropout probability equal to . Default: 0\n• None input: tensor of shape (L,Hin​) for unbatched input, (L,N,Hin​) when or (N,L,Hin​) when containing the features of the input sequence. The input can also be a packed variable length sequence. See or for details.\n• None h_0: tensor of shape (D∗num_layers,Hout​) or (D∗num_layers,N,Hout​) containing the initial hidden state for the input sequence. Defaults to zeros if not provided.\n• None output: tensor of shape (L,D∗Hout​) for unbatched input, (L,N,D∗Hout​) when or (N,L,D∗Hout​) when containing the output features from the last layer of the GRU, for each . If a has been given as the input, the output will also be a packed sequence.\n• None h_n: tensor of shape (D∗num_layers,Hout​) or (D∗num_layers,N,Hout​) containing the final hidden state for the input sequence.\n\nThe calculation of new gate nt​ subtly differs from the original paper and other frameworks. In the original implementation, the Hadamard product (⊙) between rt​ and the previous hidden state h(t−1)​ is done before the multiplication with the weight matrix and addition of bias: This is in contrast to PyTorch implementation, which is done after Whn​h(t−1)​ This implementation differs on purpose for efficiency."
    },
    {
        "link": "https://github.com/pytorch/pytorch/releases",
        "document": "We are excited to announce the release of PyTorch® 2.6 (release notes)! This release features multiple improvements for PT2: can now be used with Python 3.13; new performance-related knob ; several AOTInductor enhancements. Besides the PT2 improvements, another highlight is FP16 support on X86 CPUs.\n\nNOTE: Starting with this release we are not going to publish on Conda, please see [Announcement] Deprecating PyTorch’s official Anaconda channel for the details.\n\nFor this release the experimental Linux binaries shipped with CUDA 12.6.3 (as well as Linux Aarch64, Linux ROCm 6.2.4, and Linux XPU binaries) are built with CXX11_ABI=1 and are using the Manylinux 2.28 build platform. If you build PyTorch extensions with custom C++ or CUDA extensions, please update these builds to use CXX_ABI=1 as well and report any issues you are seeing. For the next PyTorch 2.7 release we plan to switch all Linux builds to Manylinux 2.28 and CXX11_ABI=1, please see [RFC] PyTorch next wheel build platform: manylinux-2.28 for the details and discussion.\n\nAlso in this release as an important security improvement measure we have changed the default value for parameter of . This is a backward compatibility-breaking change, please see this forum post for more details.\n\nThis release is composed of 3892 commits from 520 contributors since PyTorch 2.5. We want to sincerely thank our dedicated community for your contributions. As always, we encourage you to try these out and report any issues as we improve PyTorch. More information about how to get started with the PyTorch 2-series can be found at our Getting Started page.\n\n*To see a full list of public feature submissions click here.\n\nThis feature enables the user to specify different behaviors (“stances”) that can take between different invocations of compiled functions. One of the stances, for example, is\n\n“eager_on_recompile”, that instructs PyTorch to code eagerly when a recompile is necessary, reusing cached compiled code when possible.\n\nFor more information please refer to the set_stance documentation and the Dynamic Compilation Control with torch.compiler.set_stance tutorial.\n\noffers a standard way of creating custom operators that are backed by user-defined triton kernels.\n\nWhen users turn user-defined triton kernels into custom operators, allows to peek into the implementation, enabling to optimize the triton kernel inside it.\n\nFor more information please refer to the triton_op documentation and the Using User-Defined Triton Kernels with torch.compile tutorial.\n\npreviously only supported Python up to version 3.12. Users can now optimize models with in Python 3.13.\n\nA new package format, “PT2 archive”, has been introduced. This essentially contains a zipfile of all the files that need to be used by AOTInductor, and allows users to send everything needed to other environments. There is also functionality to package multiple models into one artifact, and to store additional metadata inside of the package.\n\nFor more details please see the updated torch.export AOTInductor Tutorial for Python runtime.\n\nIf a user encounters an error while using AOTInductor APIs, AOTInductor Minifier allows creation of a minimal nn.Module that reproduces the error.\n\nFor more information please see the AOTInductor Minifier documentation.\n\nAOTInductor-generated model code has dependency on Pytorch cpp libraries. As Pytorch evolves quickly, it’s important to make sure previously AOTInductor compiled models can continue to run on newer Pytorch versions, i.e. AOTInductor is backward compatible.\n\nIn order to guarantee application binary interface (ABI) backward compatibility, we have carefully defined a set of stable C interfaces in libtorch and make sure AOTInductor generates code that only refers to the specific set of APIs and nothing else in libtorch. We will keep the set of C APIs stable across Pytorch versions and thus provide backward compatibility guarantees for AOTInductor-compiled models.\n\n[Beta] FP16 support for X86 CPUs (both eager and Inductor modes)\n\nFloat16 datatype is commonly used for reduced memory usage and faster computation in AI inference and training. CPUs like the recently launched Intel® Xeon® 6 with P-Cores support Float16 datatype with native accelerator AMX. Float16 support on X86 CPUs was introduced in PyTorch 2.5 as a prototype feature, and now it has been further improved for both eager mode and Torch.compile + Inductor mode, making it Beta level feature with both functionality and performance verified with a broad scope of workloads.\n\nPyTorch user experience on Intel GPUs is further improved with simplified installation steps, Windows release binary distribution and expanded coverage of supported GPU models including the latest Intel® Arc™ B-Series discrete graphics. Application developers and researchers seeking to fine-tune, inference and develop with PyTorch models on Intel® Core™ Ultra AI PCs and Intel® Arc™ discrete graphics will now be able to directly install PyTorch with binary releases for Windows, Linux and Windows Subsystem for Linux 2.\n• Simplified Intel GPU software stack setup to enable one-click installation of the torch-xpu PIP wheels to run deep learning workloads in an out of the box fashion, eliminating the complexity of installing and activating Intel GPU development software bundles.\n• Windows binary releases for torch core, torchvision and torchaudio have been made available for Intel GPUs, and the supported GPU models have been expanded from Intel® Core™ Ultra Processors with Intel® Arc™ Graphics, Intel® Core™ Ultra Series 2 with Intel® Arc™ Graphics and Intel® Arc™ A-Series Graphics to the latest GPU hardware Intel® Arc™ B-Series graphics.\n• Further enhanced coverage of Aten operators on Intel GPUs with SYCL* kernels for smooth eager mode execution, as well as bug fixes and performance optimizations for torch.compile on Intel GPUs.\n\nFor more information regarding Intel GPU support, please refer to Getting Started Guide.\n\nFlexAttention was initially introduced in PyTorch 2.5 to provide optimized implementations for Attention variants with a flexible API. In PyTorch 2.6, X86 CPU support for FlexAttention was added through TorchInductor CPP backend. This new feature leverages and extends current CPP template abilities to support..."
    },
    {
        "link": "https://doc.qt.io/qt-6/designer-creating-custom-widgets.html",
        "document": "Qt Widgets Designer's plugin-based architecture allows user-defined and third party custom widgets to be edited just like you do with standard Qt widgets. All of the custom widget's features are made available to Qt Widgets Designer, including widget properties, signals, and slots. Since Qt Widgets Designer uses real widgets during the form design process, custom widgets will appear the same as they do when previewed.\n\nThe QtDesigner module provides you with the ability to create custom widgets in Qt Widgets Designer.\n\nTo integrate a custom widget with Qt Widgets Designer, you require a suitable description for the widget and an appropriate project file.\n\nTo inform Qt Widgets Designer about the type of widget you want to provide, create a subclass of QDesignerCustomWidgetInterface that describes the various properties your widget exposes. Most of these are supplied by functions that are pure virtual in the base class, because only the author of the plugin can provide this information.\n\nTwo other virtual functions can also be reimplemented:\n\nThe function returns a UI file snippet that is used by Qt Widgets Designer's widget factory to create a custom widget and its applicable properties.\n\nSince Qt 4.4, Qt Widgets Designer's widget box allows for a complete UI file to describe one custom widget. The UI file can be loaded using the tag. Specifying the <ui> tag allows for adding the <customwidget> element that contains additional information for custom widgets. The tag is sufficient if no additional information is required\n\nIf the custom widget does not provide a reasonable size hint, it is necessary to specify a default geometry in the string returned by the function in your subclass. For example, the provided by the Custom Widget Plugin example, defines a default widgetgeometry in the following way:\n\nAn additional feature of the function is that, if it returns an empty string, the widget will not be installed in Qt Widgets Designer's widget box. However, it can still be used by other widgets in the form. This feature is used to hide widgets that should not be explicitly created by the user, but are required by other widgets.\n\nThe tag tells Qt Widgets Designer and uic which method should be used to add pages to a container widget. This applies to container widgets that require calling a particular method to add a child rather than adding the child by passing the parent. In particular, this is relevant for containers that are not a a subclass of the containers provided in Qt Widgets Designer, but are based on the notion of Current Page. In addition, you need to provide a container extension for them.\n\nThe element can contain a list of property meta information.\n\nThe tag may be used to specify a tool tip to be shown in Property Editor when hovering over the property. The property name is given in the attribute and the element text is the tooltip. This functionality was added in Qt 5.6.\n\nFor properties of type string, the tag can be used. This tag has the following attributes:\n\nValues of the attribute of the string property:\n\nIn order for plugins to work correctly on all platforms, you need to ensure that they export the symbols needed by Qt Widgets Designer.\n\nFirst of all, the plugin class must be exported in order for the plugin to be loaded by Qt Widgets Designer. Use the Q_PLUGIN_METADATA() macro to do this. Also, the QDESIGNER_WIDGET_EXPORT macro must be used to define each custom widget class within a plugin, that Qt Widgets Designer will instantiate.\n\nSome custom widgets have special user interface features that may make them behave differently to many of the standard widgets found in Qt Widgets Designer. Specifically, if a custom widget grabs the keyboard as a result of a call to QWidget::grabKeyboard(), the operation of Qt Widgets Designer will be affected.\n\nTo give custom widgets special behavior in Qt Widgets Designer, provide an implementation of the initialize() function to configure the widget construction process for Qt Widgets Designer specific behavior. This function will be called for the first time before any calls to createWidget() and could perhaps set an internal flag that can be tested later when Qt Widgets Designer calls the plugin's createWidget() function.\n\nThe project file for a plugin must specify the headers and sources for both the custom widget and the plugin interface. Typically, this file only has to specify that the plugin's project will be built as a library, but with specific plugin support for Qt Widgets Designer. For , this is done with the following declarations:\n\nThe link libraries list specifies . This indicates that the plugin uses the abstract interfaces QDesignerCustomWidgetInterface and QDesignerCustomWidgetCollectionInterface only and has no linkage to the Qt Widgets Designer libraries. When accessing other interfaces of Qt Widgets Designer that have linkage, should be used instead; this ensures that the plugin dynamically links to the Qt Widgets Designer libraries and has a run-time dependency on them.\n\nIt is also necessary to ensure that the plugin is installed together with other Qt Widgets Designer widget plugins:\n\nThe variable contains the keyword , which is the equivalent of the library.\n\nIt is also necessary to ensure that the plugin is installed together with other Qt Widgets Designer widget plugins:\n\nThe variable is a placeholder to the location of the installed Qt plugins. You can configure Qt Widgets Designer to look for plugins in other locations by setting the environment variable before running the application.\n\nSee QCoreApplication::libraryPaths() for more information about customizing paths for libraries and plugins with Qt applications.\n\nIf plugins are built in a mode that is incompatible with Qt Widgets Designer, they will not be loaded and installed. For more information about plugins, see the Plugins HOWTO document.\n\nThe simple approach explained above introduces a problem particularly when using the other interfaces of Qt Widgets Designer that have linkage: The application using the custom widget will then depend on Qt Widgets Designer headers and libraries. In a real world scenario, this is not desired.\n\nThe following sections describe how to resolve this.\n\nLinking the Widget into the Application\n\nWhen using , the source and header file of the custom widget can be shared between the application and Qt Widgets Designer by creating a file for inclusion:\n\nThis file would then be included by the file of the plugin and the application:\n\nWhen using , the source files of the widget can similarly be added to the application project.\n\nAnother approach is to put the widget into a library that is linked to the Qt Widgets Designer plugin as well as to the application. It is recommended to use static libraries to avoid problems locating the library at run-time.\n\nUsing the Plugin with QUiLoader\n\nThe preferred way of adding custom widgets to QUiLoader is to subclass it reimplementing QUiLoader::createWidget().\n\nHowever, it is also possible to use Qt Widgets Designer custom widget plugins (see QUiLoader::pluginPaths() and related functions). To avoid having to deploy the Qt Widgets Designer libraries onto the target device, those plugins should have no linkage to the Qt Widgets Designer libraries ( , see Creating Custom Widgets for Qt Widgets Designer#BuildingandInstallingthePlugin).\n\nFor more information on using custom widgets in Qt Widgets Designer, refer to the Custom Widget Plugin and Task Menu Extension examples for more information about using custom widgets in Qt Widgets Designer. Also, you can use the QDesignerCustomWidgetCollectionInterface class to combine several custom widgets into a single library."
    },
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtWidgets/QWidget.html",
        "document": "QWidget has many member functions, but some of them have little direct functionality; for example, QWidget has a font property, but never uses this itself. There are many subclasses which provide real functionality, such as QLabel , QPushButton , QListWidget , and QTabWidget .\n\nQt::WindowFlags f = { } (where available) sets the window flags; the default is suitable for almost all widgets, but to get, for example, a window without a window system frame, you must use special flags.\n\nQWidget *parent = nullptr is the parent of the new widget. If it is None (the default), the new widget will be a window. If not, it will be a child of parent, and be constrained by parent’s geometry (unless you specify Window as window flag).\n\nEvery widget’s constructor accepts one or two standard arguments:\n\nA widget that is not embedded in a parent widget is called a window. Usually, windows have a frame and a title bar, although it is also possible to create windows without such decoration using suitable window flags ). In Qt, QMainWindow and the various subclasses of QDialog are the most common window types.\n\nThe widget is the atom of the user interface: it receives mouse, keyboard and other events from the window system, and paints a representation of itself on the screen. Every widget is rectangular, and they are sorted in a Z-order. A widget is clipped by its parent and by the widgets in front of it.\n\nIf you want to use a QWidget to hold child widgets you will usually want to add a layout to the parent QWidget . See Layout Management for more information.\n\nThe diagram above shows a QGroupBox widget being used to hold various child widgets in a layout provided by QGridLayout . The QLabel child widgets have been outlined to indicate their full sizes.\n\nNon-window widgets are child widgets, displayed within their parent widgets. Most widgets in Qt are mainly useful as child widgets. For example, it is possible to display a button as a top-level window, but most people prefer to put their buttons inside other widgets, such as QDialog .\n\nA widget without a parent widget is always an independent window (top-level widget). For these widgets, setWindowTitle() and setWindowIcon() set the title bar and icon respectively.\n\nComposite widgets can also be created by subclassing a standard widget, such as QWidget or QFrame , and adding the necessary layout and child widgets in the constructor of the subclass. Many of the examples provided with Qt use this approach, and it is also covered in the Qt Tutorials .\n\nWhen a widget is used as a container to group a number of child widgets, it is known as a composite widget. These can be created by constructing a widget with the required visual properties - a QFrame , for example - and adding child widgets to it, usually managed by a layout. The above diagram shows such a composite widget that was created using Qt Designer.\n\nThe Analog Clock example shows how a simple widget can handle paint events.\n\nEach widget performs all painting operations from within its paintEvent() function. This is called whenever the widget needs to be redrawn, either as a result of some external change or when requested by the application.\n\nSince QWidget is a subclass of QPaintDevice , subclasses can be used to display custom content that is composed using a series of painting operations with an instance of the QPainter class. This approach contrasts with the canvas-style approach used by the Graphics View Framework where items are added to a scene by the application and are rendered by the framework itself.\n\nThe size of top-level widgets are constrained to 2/3 of the desktop’s height and width. You can resize() the widget manually if these bounds are inadequate.\n\nThe size policy lets you supply good default behavior for the layout management system, so that other widgets can contain and manage yours easily. The default size policy indicates that the size hint represents the preferred size of the widget, and this is often good enough for many widgets.\n\nBy default, composite widgets which do not provide a size hint will be sized according to the space requirements of their child widgets.\n\nWhen implementing a new widget, it is almost always useful to reimplement sizeHint() to provide a reasonable default size for the widget and to set the correct size policy with setSizePolicy() .\n\nEvents and the mechanism used to deliver them are covered in The Event System .\n\nThe default implementation of event() handles Tab and Shift+Tab (to move the keyboard focus), and passes on most of the other events to one of the more specialized handlers above.\n\nThere are also some rather obscure events described in the documentation for Type . To handle these events, you need to reimplement event() directly.\n\ncloseEvent() is called when the user closes the widget (or when close() is called).\n\nmoveEvent() is called when the widget has been moved relative to its parent.\n\nleaveEvent() is called when the mouse leaves the widget’s screen space. If the mouse enters a child widget it will not cause a leaveEvent() .\n\nenterEvent() is called when the mouse enters the widget’s screen space. (This excludes screen space owned by any of the widget’s children.)\n\nwheelEvent() is called whenever the user turns the mouse wheel while the widget has the focus.\n\nkeyReleaseEvent() is called whenever a key is released and while it is held down (if the key is auto-repeating). In that case, the widget will receive a pair of key release and key press event for every repeat. The Tab and Shift+Tab keys are only passed to the widget if they are not used by the focus-change mechanisms. To force those keys to be processed by your widget, you must reimplement event() .\n\nmouseMoveEvent() is called whenever the mouse moves while a mouse button is held down. This can be useful during drag and drop operations. If you call setMouseTracking (true), you get mouse move events even when no buttons are held down. (See also the Drag and Drop guide.)\n\nYou may be required to also reimplement some of the less common event handlers:\n\nfocusInEvent() is called when the widget gains keyboard focus (assuming you have called setFocusPolicy() ). Well-behaved widgets indicate that they own the keyboard focus in a clear but discreet way.\n\nkeyPressEvent() is called whenever a key is pressed, and again when a key has been held down long enough for it to auto-repeat. The Tab and Shift+Tab keys are only passed to the widget if they are not used by the focus-change mechanisms. To force those keys to be processed by your widget, you must reimplement event() .\n\nWidgets that accept keyboard input need to reimplement a few more event handlers:\n\nmouseDoubleClickEvent() is called when the user double-clicks in the widget. If the user double-clicks, the widget receives a mouse press event, a mouse release event, (a mouse click event,) a second mouse press, this event and finally a second mouse release event. (Some mouse move events may also be received if the mouse is not held steady during this operation.) It is not possible to distinguish a click from a double-click until the second click arrives. (This is one reason why most GUI books recommend that double-clicks be an extension of single-clicks, rather than trigger a different action.)\n\nmouseReleaseEvent() is called when a mouse button is released. A widget receives mouse release events when it has received the corresponding mouse press event. This means that if the user presses the mouse inside your widget, then drags the mouse somewhere else before releasing the mouse button, your widget receives the release event. There is one exception: if a popup menu appears while the mouse button is held down, this popup immediately steals the mouse events.\n\nmousePressEvent() is called when a mouse button is pressed while the mouse cursor is inside the widget, or when the widget has grabbed the mouse using grabMouse() . Pressing the mouse without releasing it is effectively the same as calling grabMouse() .\n\nresizeEvent() is called when the widget has been resized.\n\npaintEvent() is called whenever the widget needs to be repainted. Every widget displaying custom content must implement it. Painting using a QPainter can only take place in a paintEvent() or a function called by a paintEvent() .\n\nYou will need to supply the behavior and content for your own widgets, but here is a brief overview of the events that are relevant to QWidget , starting with the most common ones:\n\nThe Scribble example implements a wider set of events to handle mouse movement, button presses, and window resizing.\n\nIf your widget only contains child widgets, you probably do not need to implement any event handlers. If you want to detect a mouse click in a child widget call the child’s underMouse() function inside the widget’s mousePressEvent() .\n\nWidgets respond to events that are typically caused by user actions. Qt delivers events to widgets by calling specific event handler functions with instances of QEvent subclasses containing information about each event.\n\nThe use of widget style sheets is described in more detail in the Qt Style Sheets document.\n\nIn addition to the standard widget styles for each platform, widgets can also be styled according to rules specified in a style sheet . This feature enables you to customize the appearance of specific widgets to provide visual cues to users about their purpose. For example, a button could be styled in a particular way to indicate that it performs a destructive action.\n\nThe scope for customizing the painting behavior of standard Qt widgets, without resorting to subclassing, is slightly less than that possible for custom widgets. Usually, the desired appearance of a standard widget can be achieved by setting its autoFillBackground property.\n\nSince Qt 4.1, the contents of parent widgets are also propagated to standard Qt widgets. This can lead to some unexpected results if the parent widget is decorated in a non-standard way, as shown in the diagram below.\n\nIf a widget has both the WA_OpaquePaintEvent widget attribute and the autoFillBackground property set, the WA_OpaquePaintEvent attribute takes precedence. Depending on your requirements, you should choose either one of them.\n\nTo rapidly update custom widgets that constantly paint over their entire areas with opaque content, e.g., video streaming widgets, it is better to set the widget’s WA_OpaquePaintEvent , avoiding any unnecessary overhead associated with repainting the widget’s background.\n\nTo rapidly update custom widgets with simple background colors, such as real-time plotting or graphing widgets, it is better to define a suitable background color (using setBackgroundRole() with the Window role), set the autoFillBackground property, and only implement the necessary drawing functionality in the widget’s paintEvent() .\n\nThe right widget has the WA_OpaquePaintEvent widget attribute set. This indicates that the widget will paint over its entire area with opaque colors. The widget’s area will initially be uninitialized, represented in the diagram with a red diagonal grid pattern that shines through the overpainted area. The Qt::WA_OpaquePaintArea attribute is useful for widgets that need to paint their own specialized contents quickly and do not need a default filled background.\n\nThe center widget has the autoFillBackground property set. This property is used with custom widgets that rely on the widget to supply a default background, and do not paint over their entire area with an opaque brush.\n\nThe left widget has no additional properties or widget attributes set. This default state suits most custom widgets using transparency, are irregularly-shaped, or do not paint over their entire area with an opaque brush.\n\nIn the above diagram, a semi-transparent rectangular child widget with an area removed is constructed and added to a parent widget (a QLabel showing a pixmap). Then, different properties and widget attributes are set to achieve different effects:\n\nSince Qt 4.1, the contents of parent widgets are propagated by default to each of their children as long as WA_PaintOnScreen is not set. Custom widgets can be written to take advantage of this feature by updating irregular regions (to create non-rectangular child widgets), or painting with colors that have less than full alpha component. The following diagram shows how attributes and properties of a custom widget can be fine-tuned to achieve different effects.\n\nSince Qt 4.0, QWidget automatically double-buffers its painting, so there is no need to write double-buffering code in paintEvent() to avoid flicker.\n\nmacOS: The widget needs to have the FramelessWindowHint window flag set for the translucency to work.\n\nWindows: The widget needs to have the FramelessWindowHint window flag set for the translucency to work.\n\nX11: This feature relies on the use of an X server that supports ARGB visuals and a compositing window manager.\n\nTo enable this feature in a top-level widget, set its WA_TranslucentBackground attribute with setAttribute() and ensure that its background is painted with non-opaque colors in the regions you want to be partially transparent.\n\nSince Qt 4.5, it has been possible to create windows with translucent regions on window systems that support compositing."
    },
    {
        "link": "https://pythonguis.com/tutorials/pyqt-basic-widgets",
        "document": "In Qt, like in most GUI frameworks, widget is the name given to a component of the UI that the user can interact with. User interfaces are made up of multiple widgets, arranged within the window.\n\nQt comes with a large selection of widgets available and even allows you to create your own custom and customized widgets. In this tutorial, you'll learn the basics of some of the most commonly used widgets in Qt GUI applications.\n\nFirst, let's have a look at some of the most common PyQt widgets. The following code creates a range of PyQt widgets and adds them to a window layout so you can see them together:\n\nRun it! You'll see a window appear containing all the widgets we've created:\n\nWe'll cover how layouts work in Qt in the next tutorial.\n\nLet's have a look at all the example widgets, from top to bottom:\n\nThere are far more widgets than this, but they don’t fit so well! You can see them all by checking the Qt documentation.\n\nNext, we'll step through some of the most commonly used widgets and look at them in more detail. To experiment with the widgets, we'll need a simple application to put them in. Save the following code to a file named and run it to make sure it's working:\n\nIn the code above, we've imported a number of Qt widgets. Now we'll step through each of those widgets in turn, adding them to our application and seeing how they behave.\n\nWe'll start the tour with , arguably one of the simplest widgets available in the Qt toolbox. This is a simple one-line piece of text that you can position in your application. You can set the text by passing in a string as you create it:\n\nYou can also set the text of a label dynamically, by using the method:\n\nYou can also adjust font parameters, such as the size of the font or the alignment of text in the widget:\n\nFont tip Note that if you want to change the properties of a widget font it is usually better to get the current font, update it, and then apply it back. This ensures the font face remains in keeping with the desktop conventions.\n\nThe alignment is specified by using a flag from the namespace. The flags available for horizontal alignment are listed in the following table:\n\nSimilarly, the flags available for vertical alignment are:\n\nYou can combine flags together using pipes ( ). However, note that you can only use vertical or horizontal alignment flags at a time:\n\nNote that you use an OR pipe ( ) to combine the two flags (not ). This is because the flags are non-overlapping bitmasks. For example, has the hexadecimal value , while is . By ORing them together, we get the value , representing 'bottom left'. This principle applies to all other combinatorial Qt flags. If this is gibberish to you, then feel free to ignore it and move on. Just remember to use the pipe ( ) symbol.\n\nFinally, there is also a shorthand flag that centers in both directions simultaneously:\n\nWeirdly, you can also use to display an image using . This accepts a pixmap, which you can create by passing an image filename to the class.\n\nBelow is an image which you can download for this example.\n\nPlace the file in the same folder as your code, and then display it in your window as follows:\n\nWhat a lovely face. By default, the image scales while maintaining its aspect ratio. If you want it to stretch and scale to fit the window completely, then you can call on the object:\n\nThis way, your image will stretch and scale to fit the window completely.\n\nThe next widget to look at is , which, as the name suggests, presents a checkable box to the user. However, as with all Qt widgets, there are a number of configurable options to change the widget's default behaviors:\n\nYou can set a checkbox state programmatically using the or methods. The former accepts either or , which correspond to the checked or unchecked states, respectively. However, with , you also specify a particular checked state using a namespace flag:\n\nA checkbox that supports a partially-checked ( ) state is commonly referred to as 'tri-state', which is being neither on nor off. A checkbox in this state is commonly shown as a greyed-out checkbox, and is commonly used in hierarchical checkbox arrangements where sub-items are linked to parent checkboxes.\n\nIf you set the value to the checkbox will become tristate. You can also set a checkbox to be tri-state without setting the current state to partially checked by using\n\nYou may notice that when the script is running, the current state number is displayed as an with checked = , unchecked = , and partially checked = . You don’t need to remember these values, the namespace variable , for example. This is the value of these state's respective flags. This means you can test state using .\n\nThe is a drop-down list, closed by default with an arrow to open it. You can select a single item from the list, with the currently selected item being shown as a label on the widget. The combo box is suited for the selection of a choice from a long list of options.\n\nYou have probably seen the combo box used for the selection of font face, or size, in word processing applications. Although Qt actually provides a specific font-selection combo box as .\n\nYou can add items to a by passing a list of strings to . Items will be added in the order they are provided:\n\nThe signal is triggered when the currently selected item is updated, by default passing the index of the selected item in the list. There is also a signal, which instead provides the label of the currently selected item, which is often more useful.\n\ncan also be editable, allowing users to enter values not currently in the list and either have them inserted or simply used as a value. To make the box editable, use the method:\n\nYou can also set a flag to determine how the insertion is handled. These flags are stored on the class itself and are listed below:\n\nTo use these, apply the flag as follows:\n\nYou can also limit the number of items allowed in the box by using the method:\n\nFor a more in-depth look at the , check out our QComboBox documentation.\n\nThis widget is similar to , except options are presented as a scrollable list of items. It also supports the selection of multiple items at once. A offers a signal, which sends the (the element of the list widget), and a signal, which sends the text of the current item:\n\nThe widget is a single-line text editing box, into which users can type input. These are used for form fields, or settings where there is no restricted list of valid inputs. For example, when entering an email address, or computer name:\n\nAs demonstrated in the above code, you can set a maximum length for the text in a line edit using the method.\n\nThe has a number of signals available for different editing events, including when the Enter key is pressed (by the user), and when the user selection is changed. There are also two edit signals, one for when the text in the box has been edited and one for when it has been changed. The distinction here is between user edits and programmatic changes. The signal is only sent when the user edits text.\n\nAdditionally, it is possible to perform input validation using an input mask to define which characters are supported and where. This can be applied to the field as follows:\n\nThe above would allow a series of 3-digit numbers separated with periods, and could therefore be used to validate IPv4 addresses.\n\nprovides a small numerical input box with arrows to increase and decrease the value. supports integers, while the related widget, , supports floats:\n\nRun it, and you'll see a numeric entry box. The value shows pre and post-fix units and is limited to the range 3 to -10.\n\nThe demonstration code above shows the various features that are available for the widget.\n\nTo set the range of acceptable values, you can use the and methods. Alternatively, use to set both simultaneously. Annotation of value types is supported with both prefixes and suffixes that can be added to the number (e.g. for currency markers or units) using the and methods, respectively.\n\nClicking the up and down arrows on the widget will increase or decrease the value in the widget by an amount, which can be set using the method. Note that this has no effect on the values that are acceptable to the widget.\n\nBoth and have a signal, which fires whenever their value is altered. The raw signal sends the numeric value (either an or a ), while sends the value as a string, including both the prefix and suffix characters.\n\nYou can optionally disable text input on the spin box's line edit, by setting it to read-only. With this setting, the value can only be changed using the controls:\n\nThis setting also has the side effect of disabling the flashing cursor.\n\nprovides a slide-bar widget, which internally works like a . Rather than display the current value numerically, that value is represented by the position of the slider's handle along the length of the widget. This is often useful when providing adjustment between two extremes, but when absolute accuracy is not required. The most common use case of this type of widget is for volume controls in audio playback.\n\nThere is an additional signal that is triggered whenever the slider moves position and a signal that is emitted whenever the slider is clicked:\n\nRun this, and you'll see a slider widget. Drag the slider to change the value:\n\nYou can also construct a slider with a vertical or horizontal orientation by providing the orientation as you create it. The orientation flags are defined in the namespace:\n\nFinally, the widget is a rotatable widget that works just like the slider but appears as an analog dial. This widget looks nice, but from a UI perspective, it is not particularly user-friendly. However, dials are often used in audio applications as a representation of real-world analog dials:\n\nRun this, and you'll see a circular dial. Rotate it to select a number from the range:\n\nThe signals are the same as for the widget and retain the same names (e.g. ).\n\nThis concludes our brief tour of the common widgets used in PyQt applications. To see the full list of available widgets, including all their signals and attributes, check out the Qt documentation."
    },
    {
        "link": "https://realpython.com/qt-designer-python",
        "document": "To create a GUI for your windows and dialogs in PyQt, you can take two main paths: you can use Qt Designer, or you can hand code the GUI in plain Python code. The first path can dramatically improve your productivity, whereas the second path puts you in full control of your application’s code.\n\nGUI applications often consist of a main window and several dialogs. If you’re looking to create these graphical components in an efficient and user-friendly way, then Qt Designer is the tool for you. In this tutorial, you’ll learn how to use Qt Designer to create your GUIs productively.\n• What Qt Designer is and how to install it on your system\n• When to use Qt Designer vs hand coding for building your GUIs\n• How to build and lay out the GUI of an application’s main window using Qt Designer\n• How to create and lay out the GUI of your dialogs with Qt Designer\n• How to use Qt Designer’s files in your GUI applications\n\nFor a better understanding of the topics in this tutorial, you can check out the following resources:\n\nYou’ll put all this knowledge together by using the GUIs that you’ll build with Qt Designer in a sample text editor application. You can get the code and all the required resources to build this application by clicking the link below:\n\nQt Designer is a Qt tool that provides you with a what-you-see-is-what-you-get (WYSIWYG) user interface to create GUIs for your PyQt applications productively and efficiently. With this tool, you create GUIs by dragging and dropping objects on an empty form. After that, you can arrange them into a coherent GUI using different layout managers. Qt Designer also allows you to preview your GUIs using different styles and resolutions, connect signals and slots, create menus and toolbars, and more. Qt Designer is platform and programming language independent. It doesn’t produce code in any particular programming language, but it creates files. These files are files with detailed descriptions of how to generate Qt-based GUIs. You can translate the content of files into Python code with , which is a command-line tool that comes with PyQt. Then you can use this Python code in your GUI applications. You can also read files directly and load their content to generate the associated GUI. There are several ways to get and install Qt Designer depending on your current platform. If you use Windows or Linux, then you can run the following commands from your terminal or command line: Here, you create a Python virtual environment, activate it, and install and . installs PyQt and a copy of the required Qt libraries, while installs a set of Qt tools that includes Qt Designer. The installation will place the Qt Designer executable in a different directory according to your platform: On Linux systems, such as Debian and Ubuntu, you can also install Qt Designer by using the system package manager with the following command: This command downloads and installs Qt Designer and other Qt tools on your system. In other words, you’ll have a system-wide installation and you’ll be able to run Qt Designer by clicking its icon in a file manager or system menu. On macOS, if you’ve installed Qt from Homebrew using the command, then you should have Qt Designer already installed on your system. Finally, you can download the Qt installer for your current platform from the official download site and then follow the on-screen instructions. In this case, to complete the installation process, you need to register a Qt account. If you’ve already installed Qt Designer using one of the options discussed so far, then go ahead and launch the application. You should get the following two windows on your screen: The window in the foreground is Qt Designer’s New Form dialog. The window in the background is Qt Designer’s main window. In the next two sections, you’ll learn the basics of how to use these components of the Qt Designer interface. When you run Qt Designer, you’re presented with the application’s main window and the New Form dialog. In this dialog, you can select from five available GUI templates. These templates include options to create dialogs, main windows, and custom widgets: OK and Cancel buttons laid out horizontally on the bottom-right corner OK and Cancel buttons laid out vertically on the top-right corner A menu bar at the top and a status bar at the bottom By default, when you run Qt Designer, the New Form dialog appears in the foreground. If it doesn’t, then you can click New on Qt Designer’s toolbar. You can also click File → New in the main menu or press + on your keyboard. In the New Form dialog, you can select the form template that you want to start with and then click Create to generate a new form: To create a new and empty form using a Qt Designer template, you just need to select the desired template from the New Form dialog and then click Create or press + on your keyboard. Note that the first two dialog templates have their own default buttons. These are standard buttons included in a . This class automatically handles the position or order of buttons across different platforms. For example, if you use a Cancel button and an OK button, then the standard on Linux and macOS is to display those buttons in this same order. But on Windows, the order of buttons will be swapped, with OK appearing first, followed by Cancel. handles this issue for you automatically. Qt Designer’s main window provides a menu bar with options for saving and managing forms, editing forms and changing the edit mode, laying out and previewing forms, and also for tuning the application’s settings and accessing its help documentation: The main window also provides a toolbar that displays commonly used options. You’ll use most of these options when you’re editing and laying out your forms. These options are also available in the main menu, especially in the File, Edit, and Form menus: Qt Designer’s main window also includes a few dock windows that provide a rich set of features and tools: The Widget Box provides a selection of layout managers, spacers, standard widgets, and other objects that you can use to create a GUI for your dialogs and windows: The Widget Box provides a filter option at the top of the window. You can type the name of a given object or widget and get quick access to it. The objects are grouped into categories that reflect their specific use. You can show or hide all the available objects in a category by clicking the handle next to the category label. When you’re creating your forms, you can take objects from the Widget Box with your mouse pointer and then drag and drop them onto the form to build its GUI. The Widget Box also provides a Scratchpad section at the bottom of the window. In this section, you can group frequently used objects in a separate category. You can fill the Scratchpad category with any widget currently placed on a form by dragging and dropping them back onto the Widget Box. You can remove widgets from the Scratchpad category by right-clicking them and selecting Remove in the context menu. The Object Inspector provides a tree view of all the objects on the current form. The Object Inspector also has a filter box at the top to allow you to find objects in the tree. You can use the Object Inspector to set the name and other properties of the form and its widgets. You can also right-click any widget to access a context menu with additional options: With the Object Inspector, you can manage the widgets on your form. You can rename them, update some of their properties, remove them from the form, and so on. The tree view in the Object Inspector reflects the parent-child relationship of the widgets and objects on the current form. The Property Editor is another dock window that appears in Qt Designer’s main window. This window holds a two-column table with the active object’s properties and their values. You can use the Property Editor to edit the value of an object’s properties, as the name implies: The Property Editor provides a user-friendly way to access and edit the values of the active object’s properties, such as its name, size, font, icon, and so on. The properties listed on the editor will change depending on which object you select on your form. The properties are listed from top to bottom according to class hierarchy. For example, if you select a on the form, then the Property Editor shows the properties of , followed by the properties of , and finally the properties of itself. Note that the rows on the editor show different colors to visually differentiate the underlying class. Finally, you have three dock windows that commonly appear as tabs in the bottom-right corner:\n• Resource Browser provides a quick way of adding resources, such as icons, translation files, images, and other binary files to your applications.\n• Action Editor provides a way to create actions and add them to your forms.\n• Signal/Slot Editor provides a way to connect signals and slots in your forms. Here are some of the options that these tools provide: That’s it! These three dock windows round out the set of tools and options that Qt Designer provides for you to create and customize the GUIs for your dialogs and windows. Using Qt Designer vs Hand Coding Your GUIs With PyQt, you have at least two options for creating the GUI of a window or dialog: You can use Qt Designer, or you can hand code the GUI in plain Python code. Both options have their pros and cons. Sometimes it’s hard to decide when to use one or the other. Qt Designer provides a user-friendly graphical interface that allows you to quickly create GUIs. This can boost your productivity as a developer and shorten your development cycles. Hand coding your GUIs, on the other hand, can give you much more control over them. With this approach, adding new components and features doesn’t require any extra tools beyond your code editor or IDE, which can be quite convenient in some development environments. Whether you use Qt Designer or hand code your GUIs is a personal decision. Here are some general considerations on both approaches: High if you’re familiar with PyQt, but low otherwise Beyond these concerns, if you’re just starting with PyQt, then Qt Designer can help you discover available widgets, layout managers, base classes, properties and their typical values, and so on. One last difference between using Qt Designer and hand coding a GUI is that you need to run an extra step when using Qt Designer: translating files into Python code.\n\nWith PyQt, you can build main window–style and dialog-style applications. Main window–style applications often consist of a main window with a menu bar, one or more toolbars, a central widget, and a status bar. They can also include several dialogs, but those are independent of the main window. Qt Designer enables you to quickly build the GUI of your main windows using the predefined Main Window template. Once you’ve created a form based on that template, you’ll have tools to perform the following actions: Qt Designer’s Main Window template also provides a default central widget and a status bar at the bottom of the window: Qt Designer saves its forms in files. These are files that contain all the information you’ll need to later recreate the GUI in your applications. To save your forms, go to File → Save, enter in the Save Form As dialog, select a directory to save the file in, and click Save. You can also get access to the Save Form As dialog by pressing + on your keyboard. Don’t close your Qt Designer session—stay there to continue adding menus and toolbars to the main window you just created. Qt Designer’s Main Window template provides an empty menu bar at the top of the form. You can add menus to that menu bar using the Menu Editor. Menus are pull-down lists of options that provide quick access to the application’s options. Go back to Qt Designer and your newly created main window. At the top of the form, you’ll see a menu bar with the placeholder text Type Here. If you double-click or press on this placeholder text, then you can type the name of your first menu. To confirm the menu name, just press . Say you want to create your own text editor. Typically, this kind of application has a File menu with at least some of the following options:\n• New for creating a new document Here’s how you can use Qt Designer to create this menu: Qt Designer’s Menu Editor allows you to add menus to the menu bar in a user-friendly way. When you enter the name of a menu or menu option, you can use an ampersand symbol ( ) before a given letter to provide a keyboard accelerator. For example, if you add an ampersand before the F in the File menu, then you can access this menu by pressing + . Likewise, if you add an ampersand before the N in New, then once you’ve launched the File menu, you can access the New option by pressing . With the Menu Editor, you can also add separators to your menus. This is a good way to visually separate menu options and group them logically. To add a separator, double-click the Add Separator option at the end of the active menu in the Menu Editor. You can remove an existing separator by right-clicking it and then selecting Remove Separator in the context menu. This menu also allows you to add new separators. If you need to move a separator to another place in a given menu, then you can drag the separator to the desired position and drop it there. A red line will indicate the position where the separator will be placed. You can also add a submenu to a given menu option. To do this, click the icon on the right side of the menu option to which you want to attach the submenu, just like you did with the Open Recent option in the above example. To run a preview of your form, go to Form → Preview, or hit the key combination + on your keyboard. When you create a menu like the File menu in your sample text editor, a new object is automatically added to your menu bar. When you add a menu option to a given menu, you create an action. Qt Designer provides an Action Editor for creating, customizing, and managing actions. The tool provides a few handy options that you can use to fine-tune your actions: With the Action Editor, you can fine-tune, update, or set the following options:\n• The text of the action, which will be shown on menu options and toolbar buttons\n• The object name, which you’ll use in your code to reference the action object\n• The icons that will be shown on your menu options and toolbar buttons\n• The checkable property of the action\n• The keyboard shortcuts, which will provide the user with a quick way to access the action The final ellipsis ( ) in the text of your menu options is a widely used convention for naming options that don’t perform an immediate action but launch a pop-up dialog for performing further actions. In the case of the icons, you need to pack those icons with your application as independent files, or you can create a resources file, also known as a file. For this example, you can download the required icons and other resources by clicking the link below: Get the Source Code: Click here to get the source code you’ll use to learn about creating Python GUI applications with Qt Designer in this tutorial. Once you’ve downloaded the icons, create a directory beside your file and copy the icons there. Then get back to the Action Editor and add icons to your actions like this: Note that your menu options now display an icon on the left margin. This provides extra visual information to your users and helps them find the desired option. Now go ahead and add an Edit menu with the following options:\n• Find and Replace for finding and replacing text Next, add a Help menu with an About option for launching a dialog with general information about your text editor. Finally, go to the Property Editor and set the title of your window to . After these additions, your main window should look something like this: With these additions, your sample text editor’s main menu is starting to look like the menu of a real text editor! You can add as many toolbars as you need to your main window’s GUI using Qt Designer. To do that, right-click on the form and select Add Tool Bar from the context menu. This adds an empty toolbar at the top of the window. Alternatively, you can predefine the toolbar area where you want to place a given toolbar by selecting Add Tool Bar to Other Area: Once you have your toolbars in place, you can populate them with buttons. To do this, you use actions rather than specific toolbar buttons from the Widget Box. To add actions to your toolbars, you can use the Action Editor: Actions can be shared between menu options and toolbar buttons, so in this case, you reuse the actions that you created when you populated your menus in the preceding section. To populate the toolbar, click on an action on the Action Editor, then drag and drop it onto the toolbar. Note that by right-clicking on the toolbar, you can add separators to visually separate the tool buttons. Qt Designer uses for building its Main Window template. This class provides a default layout that allows you to create a menu bar, one or more toolbars, one or more dock widgets, a status bar, and a central widget. By default, Qt Designer uses a object as the central widget on the Main Window template. Using a bare-bones object as the central widget on a main window’s GUI is a good choice because, on top of that widget, you can place either a single widget or multiple widgets in a coherent layout. For example, in your sample text editor, you might want to use a single widget that provides your users with a work area to type, copy, paste, and edit their text. For this purpose, you can use a object and then add a vertical (or horizontal) layout as the central widget’s layout: In this example, you first drag a onto the form. Then you click on the form to select your central widget. Finally, you apply a vertical layout to your central widget by clicking Lay Out Vertically on Qt Designer’s toolbar. Since the spacing around the doesn’t look right, you use the Object Inspector to change the margins of the layout from pixels to pixel. With Qt Designer, you can use different layout managers to arrange your widgets quickly. Arguably, the most accessible way of laying out your GUIs with Qt Designer is using the layout-related section on the main toolbar: From left to right, you’ll find the following options to create different types of layouts: Horizontally in one row and several columns Vertically in one column and several rows Tabularly in a grid with several rows and columns The last two options in the toolbar are related to layouts but don’t create them:\n• Break Layout allows you to break an existing layout. Once widgets are arranged in a layout, you can’t move or resize them individually because their geometry is controlled by the layout. To modify individual widgets, you might need to break the layout and redo it later. To access this option, you can press + on your keyboard.\n• Adjust Size adjusts the size of the layout to accommodate contained widgets and to ensure that each has enough space to be visible. To access this option, you can press + on your keyboard. You can also access all these layout-related options through Qt Designer’s main menu bar, under the Form menu: In the Form menu, you have access to all the layout-related options, with a complete reference of the keyboard shortcuts to access them. You can also access these options through the form’s context menu, under the Lay Out option. When you’re creating your main windows, you might face situations in which you need to use multiple widgets in a given layout as your central widget. Since Qt Designer’s Main Window template ships with a object as its central widget, you can take advantage of this to create your own custom arrangement of widgets and then set it as the top-level layout of that central widget. With Qt Designer, you can lay out your widgets using layout managers, as you already saw in the above section. If you need a compound layout of widgets for your main window’s GUI, then you can build it by running the following steps:\n• Drag and drop the widgets onto your form and try to place them near their desired position.\n• Select the widgets that should be managed together by a given layout.\n• Apply the appropriate layout using Qt Designer’s toolbar or main menu, or with the form’s context menu. Although you can drag layouts onto a form and then drag widgets onto the layouts, the best practice is to drag all the widgets and spacers first and then repeatedly select related widgets and spacers to apply layouts to them. For example, suppose you’re building a calculator application. You need a object on the top of your form to display the operations and their results. Under the line edit, you need a few objects for the numbers and operations. That gives you a window like this: This looks something like a calculator, but the GUI is messy and cluttered. To arrange this into a more polished calculator GUI, you can use a grid layout for the buttons and a vertical box layout as the calculator’s top-level layout: Your calculator still needs some extra polishing, but it looks a lot better now. To get a more finished version, you can use the Property Editor to tweak the values of some properties on your buttons, such as their maximum and minimum size. You can also set a fixed size for your calculator’s main window, and so on. Go ahead and give it a try! Qt Designer’s Main Window template provides a status bar by default. A status bar is a horizontal panel that’s usually placed at the bottom of the main window in a GUI application. Its primary purpose is to display information about the current status of the application. You can divide a status bar into several sections and show different information on each section. The information on the status bar can be temporary or permanent, and most of the time it comes as text messages. The purpose of the information displayed on the status bar is to keep your users updated about what the application is currently doing and what its general status is at a given time. You can also use the status bar to display help tips, which are short help messages that describe what a given button or menu option does. This kind of message appears on the status bar when the user hovers the mouse pointer over a toolbar button or menu option.\n\nDialogs are small-sized windows that you commonly use to provide auxiliary functionalities, such as a Preferences dialog, or to communicate with your users by showing error messages or general information about a given operation. You can also use dialogs to ask the user for some required information or to confirm an operation that’s about to take place. PyQt offers a rich set of built-in dialog that you can use in your applications directly. You just need to import them from . Here’s a summary: Selecting and setting a font of a given text Specifying the settings of a printer Getting a single value from the user Displaying messages such as errors, general information, warnings, and questions All these built-in dialogs are ready for you to use in your code directly. Most of them provide class methods to build specific types of dialogs depending on your needs. Along with these dialogs, PyQt provides the class. You can use this class to create your own dialogs in code, but you can also use Qt Designer to create your dialogs quickly. In the next few sections, you’ll learn how to create, lay out, and customize your dialogs using Qt Designer and its dialog templates. To create a custom dialog with Qt Designer, select the appropriate template for the dialog from the New Form dialog. Drag and drop the required widgets onto the form, lay out them correctly, and save the form in a file for later use in your application. Go back to your sample text editor and suppose you want to add a Find and Replace dialog like this: To create this dialog, start with the Dialog without Buttons template and add the required widgets to the form: Here, you first create an empty dialog using the Dialog without Buttons template and set the window title to Find and Replace in the Object Inspector. Then you drag and drop two objects onto the form using the Widget Box. These labels ask the users for the words they need to find and replace. Those words will be entered in the corresponding objects near the labels. Next, you drag and drop three objects onto the form. These buttons will allow your users to find and replace words in their current document. Finally, you add two objects to provide Match Case and Match Whole Word options. Once you have all the widgets on the form, make sure to place them in a position that’s similar to what you want to achieve in your final dialog. Now it’s time to lay out the widgets. As you saw before, to arrange the widgets in a form, you can use several layout managers. To lay out your Find and Replace dialog, use a grid layout for the labels, line edits, and checkboxes. For the buttons, use a vertical layout. Finally, use a horizontal layout as your dialog’s top-level layout manager: Here, you select the labels, line edits, and checkboxes with your mouse pointer and apply a grid layout to them. After that, you add a vertical spacer between the Replace and Cancel buttons to keep them visually separated. The final step is to set the dialog’s top-level layout. In this case, you use a horizontal layout manager. That’s it! You’ve built the GUI of your Find and Replace dialog with Qt Designer. Save it with the filename . There are a bunch of other properties and features that you can tweak in your dialogs using Qt Designer. For example, you can set the tab order of your input widget to improve the experience of users navigating your dialogs with their keyboard. You can also provide keyboard accelerators, connect signals and slots, and so on. So far, you’ve used Qt Designer in the Edit Widgets mode, which is its default mode. In this mode, you can add widgets to your forms, edit widget’s properties, lay out the widgets on the form, and so on. However, Qt Designer has up to four different modes to allow you to work on different features of your forms: Setting up the tab order of widgets You can also access these modes by clicking their corresponding buttons in the mode-related section of Qt Designer’s toolbar, which looks like this: To be able to edit the built-in signals and slots of your widgets and forms, you first need to switch to the Edit Signals/Slots mode. Note: In Qt, the term buddies refers to a special relationship between a label and a widget in which the label provides a keyboard accelerator or shortcut that allows you to access the buddy widget using your keyboard. User actions on widgets and forms, such as a click or a keypress, are known as events in PyQt. When an event occurs, the widget at hand emits a signal. This mechanism allows you to run actions in response to events. These actions are known as slots, which are methods or functions. To execute a slot in response to an event, you need to select one of the signals emitted by the widget in response to an event and connect it to the desired slot. Most widgets, including dialogs and windows, implement built-in signals that are emitted when a given event occurs on the widget. Widgets also provide built-in slots that allow you to perform certain standardized actions. To establish a signal-and-slot connection between two widgets using Qt Designer, you need to select the signal-provider widget with your mouse and then drag and drop it over the slot-provider widget. This launches Qt Designer’s Configure Connection dialog. Now go back to the Find and Replace dialog and switch to Qt Designer’s Edit Signals/Slots mode. Then drag and drop the Cancel button onto the form: The Configure Connection dialog has two panels. On the left panel, you can select a signal from the signal-provider widget, and on the right panel, you can select a slot from the slot-provider widget. To create the connection, press OK: The connection appears as an arrow from the signal-provider widget to the slot-provider widget, indicating that the connection is established. You’ll also see the name of the signal and the slot that you just connected. In this case, you connected the signal of the Cancel button with the slot of the dialog. Now when you click Cancel, your action will be ignored, and the dialog will close. To modify a connection, double-click the arrow or one of the labels. This displays the Configure Connection dialog, in which you can change the signal or the slot involved in the connection according to your needs. To delete a connection, select the arrow that represents the connection or one of the labels that identify the signal and slot, then press . To improve the usability of your dialogs, you can set a coherent tab order for your input widgets. The tab order is the order in which the widgets on your form come into focus when you press or + on your keyboard. If you’re using Qt Designer to create your forms, then the default tab order of your widgets is based on the order in which you place each widget on the form. Sometimes this order isn’t right, and when you hit or + , the focus jumps to an unexpected widget. Take a look at the tab order behavior in your Find and Replace dialog: The focus starts on the Find line edit, then it goes through the Replace line edit, then through the checkboxes, and finally through the buttons. What if you want the focus to jump from the Find line edit to the Replace line edit and then to the Find button? In this case, you can change the tab order of the input widgets on the dialog. Switch to Edit Tab Order mode in Qt Designer. You’ll see something like this: In Edit Tab Order mode, each input widget in the form shows a number that identifies its position in the tab-order chain. You can change that order by clicking on the numbers in the desired order: You change the tab order of the input widgets by clicking the numbers in the desired order. Note that when you select a number, it changes to red, indicating that this is the currently edited position in the tab-order chain. Numbers you haven’t set are shown in blue, and the numbers you have set are shown in green. If you make a mistake, then you can restart the ordering by choosing Restart from the form’s context menu. A keyboard accelerator is a key combination that you can press on your keyboard to quickly move the focus onto a given widget on a dialog or window. Normally, keyboard accelerators consist of the key and a letter that identifies the widget or option that you want to access. This can help you improve the usability of your applications. To define a keyboard accelerator on a widget that includes a label, such as a button or a checkbox, you just need to place an ampersand symbol ( ) before the letter in the label text that you want to use in the accelerator. For example, place an ampersand before the C on the Cancel button of your Find and Replace dialog, run a preview, and press + like in the following example: By placing an ampersand before the letter C in the text of the Cancel button, you create a keyboard accelerator. If you press + on your keyboard, then the Cancel button is selected and the dialog closes. To define a keyboard accelerator on a widget that doesn’t include a label, such as a line edit, you need to make that widget a buddy of a label object. There are four steps that you need to take if you want to create a buddy connection:\n• Select a letter in the text of the label to identify the buddy connection and provide the keyboard accelerator.\n• Place an ampersand ( ) before the selected letter in the text of the label.\n• Drag and drop the label onto the buddy widget. Here’s how you can create a buddy relationship between the Find label and its related line edit: To create a buddy relationship between a label and a widget, select the label with your mouse and drag it onto the input widget that you want to set as its buddy. The label and the input widget will become buddies. From this point on, you can press plus the selected letter in the label text to move the focus to the related widget. It’s important to note that you shouldn’t have two widgets with the same keyboard accelerator in a given form. This means that you need to select a unique letter for each keyboard accelerator. Go ahead and use Qt Designer to set keyboard accelerators for the widgets on your Find and Replace dialog. The final result should look like the dialog you saw at the beginning of the section Creating a Dialog GUI.\n\nIntegrating Windows and Dialogs in an Application Up to this point, you’ve learned how to create a GUI for your main windows and dialogs with Qt Designer. In this section, you’ll learn how to integrate those GUIs into your Python code and build a real application. There are two main approaches to do that in PyQt:\n• Translating the content of your files into Python code using\n• Loading the content of the files dynamically using The first approach uses , which is a tool included in the PyQt installation that allows you to translate the content of a file into Python code. This approach is widely used because of its efficiency. However, it has one drawback: every time you modify the GUI with Qt Designer, you need to generate the code again. The second approach takes advantage of to dynamically load the content of a file into your application. This approach is suitable when you’re working with small GUIs that don’t involve substantial loading time. Setting Up Windows and Dialogs for Use Now it’s time to set up your windows and dialogs for use in a real application (in this case, a sample text editor). If you’ve been following this tutorial, then you should have at least two files:\n• with the GUI of a sample text editor application\n• with the GUI of a Find and Replace dialog Go ahead and create a new directory called . Inside this directory, create another directory called and copy your files into it. Also, copy the directory that contains the icons for your menu options and toolbar buttons to the directory. So far, the structure of your application should look like this: Since the main-window GUI is relatively complex, you can use to translate the content of into Python code. You can download all the required code and resources to build your sample text editor by clicking the link below: Get the Source Code: Click here to get the source code you’ll use to learn about creating Python GUI applications with Qt Designer in this tutorial. Now open a terminal and navigate to the directory. Once you’re there, run the following command: This command generates a Python module called from the file and places it in your directory. This module contains the Python code for your main window’s GUI. Here’s a small sample of the code: # WARNING: Any manual changes made to this file will be lost when pyuic5 is # run again. Do not edit this file unless you know what you are doing. has all the code for generating the GUI of the sample editor’s main window. Note that contains the code to create all the required widgets and lay them out on the GUI. contains code for internationalization and localization, but this topic is beyond the scope of this tutorial. Note: If doesn’t work for you, then you need to check out your current PyQt installation. If you installed PyQt in a Python virtual environment, then you might need to activate the environment. You can also move to your virtual environment directory and run from there. Typically, you’ll find the application under the directory. If you have a system-wide installation of PyQt, then you should be able to run directly from your command line without needing to activate a virtual environment. Now your working directory should look like this: Since your Find and Replace dialog is quite small, you can load its GUI directly from your file using . This function takes a string with the path to a file as an argument and returns a subclass that implements the GUI. This way of loading files dynamically is rarely used in practice. You can use it with small dialogs that don’t require too much effort to load. With this approach, you don’t need to generate the Python code for the dialog’s GUI every time you modify the file with Qt Designer, which can be a productivity and maintainability win in some cases. Now that you’ve chosen a strategy for building each of your GUIs, it’s time to put everything together in a real application. Putting Everything Together in an Application With all the pieces in place for your sample text editor, you can create the application and write the required code to use the main window and the Find and Replace dialog. Fire up your favorite code editor or IDE in your directory and create a new file called . Add the following code to it: Here’s what this code does:\n• Line 3 imports the required PyQt classes to build the application and the GUI.\n• Line 6 imports from the module. This function provides a way of loading the content of a file dynamically.\n• Line 8 imports , which contains the GUI for your main window.\n• Line 10 defines , which will provide your application’s main window. In this case, the class uses multiple inheritance. It inherits the main window functionality from and the GUI functionality from .\n• Line 13 calls , which creates the whole GUI for your main window.\n• Line 16 defines , which connects the required signals and slots.\n• Line 21 defines . This method creates an instance of your Find and Replace dialog and execute it.\n• Line 25 defines , which creates and launches a small dialog to provide information about the application. In this case, you use a built-in dialog based on .\n• Line 35 defines , which provides the Find and Replace dialog.\n• Line 38 calls to load the dialog’s GUI from the files . Finally, on lines 41 to 44, you create the application, create and show the main window, and run the application’s main loop by calling on the application object. It’s important to note that Qt Designer can name your actions a bit differently from what you saw in the above code. For example, you might find the name instead of to refer to the Exit action. So, for this example to work properly, you need to make sure you’re using the right names. If you want to use your own names instead of the names that Qt Designer generates, then you can go to the Property Editor and change the property to the name that seems right for you. Note: You can also create using composition instead of multiple inheritance. For example, you can define and its initializer like this: In this case, you create , which is an instance of . From this point on, you need to use to access the widgets and objects on your main window’s GUI. If you run this application, then you’ll get the following window on your screen: That’s it! You’ve created a sample text editor with minimal functionality using Qt Designer. Note that to code this application, you wrote only forty-four lines of Python code, which is substantially less than what you’d need to write to hand code the GUI of an equivalent application from scratch."
    },
    {
        "link": "https://pythonguis.com/tutorials/creating-your-own-custom-widgets",
        "document": "In the previous tutorial we introduced and looked at some basic bitmap drawing operations which you can used to draw dots, lines, rectangles and circles on a surface such as a .\n\nThis process of drawing on a surface with is in fact the basis by which all widgets in Qt are drawn. Now you know how to use you know how to draw your own custom widgets!\n\nIn this article we'll take what we've learnt so far and use it to construct a completely new custom GUI widget. For a working example we'll be building the following widget — a customisable PowerBar meter with a dial control.\n\nThis widget is actually a mix of a compound widget and custom widget in that we are using the built-in Qt component for the dial, while drawing the power bar ourselves. We then assemble these two parts together into a parent widget which can be dropped into place seamlessly in any application, without needing to know how it's put together. The resulting widget provides the common interface with some additions for configuring the bar display.\n\nAfter following this example you will be able to make your very own custom GUI widgets — whether they are compounds of built-ins or completely novel self-drawn wonders.\n\nAs we've previously seen compound widgets are simply widgets with a layout applied, which itself contains >1 other widget. The resulting \"widget\" can then be used as any other, with the internals hidden/exposed as you like.\n\nThe outline for our PowerBar widget is given below — we'll build our custom widget up gradually from this outline stub.\n\nThis simply defines our custom power bar is defined in the object — here just unaltered subclass of . The widget (which is the complete widget) combines this, using a with the built in to display them together.\n\nWe also need a little demo application to display the widget.\n\nWe don't need to create a since any widget without a parent is a window in it's own right. Our custom widget will appear as any normal window.\n\nThis is all you need, just save it in the same folder as the previous file, under something like . You can run this file at any time to see your widget in action. Run it now and you should see something like this:\n\nOur widget, a QDial with an invisible empty widget above it (trust me).\n\nIf you stretch the window down you'll see the dial has more space above it than below — this is being taken up by our (currently invisible) widget.\n\nThe handler is the core of all widget drawing in PyQt.\n\nEvery complete and partial re-draw of a widget is triggered through a which the widget handles to draw itself. A can be triggered by —\n• the widget was obscured and has now been uncovered\n• the widget has been resized\n\n— but it can also occur for many other reasons. What is important is that when a is triggered your widget is able to redraw it.\n\nIf a widget is simple enough (like ours is) you can often get away with simply redrawing the entire thing any time anything happens. But for more complicated widgets this can get very inefficient. For these cases the includes the specific region that needs to be updated. We'll make use of this in later, more complicated examples.\n\nFor now we'll do something very simple, and just fill the entire widget with a single color. This will allow us to see the area we're working with to start drawing the bar. Add the following code to the class.\n\nUsing the draw instructions we introduced in the previous part you can completely customise the style, look and feel of your custom widget.\n\nNow we can see the widget we can tweak its positioning and size. If you drag around the shape of the window you'll see the two widgets changing shape to fit the space available. This is what we want, but the is also expanding vertically more than it should, and leaving empty space we could use for the bar.\n\nWe can use on our widget to make sure it expands as far as possible. By using the the provided will be used as a minimum, and the widget will expand as much as possible.\n\nIt's still not perfect as the widget resizes itself a bit awkwardly, but our bar is now expanding to fill all the available space.\n\nWith the positioning sorted we can now move on to define our paint methods to draw our PowerBar meter in the top part (currently black) of the widget.\n\nWe now have our canvas completely filled in black, next we'll use draw commands to actually draw something on the widget.\n\nBefore we start on the bar, we've got a bit of testing to do to make sure we can update the display with the values of our dial. Replace the with the following code.\n\nThis draws the black background as before, then uses to access our parent widget and through that the via . From there we get the current value, as well as the allowed range minimum and maximum values. Finally we draw those using the painter, just like we did in the previous part.\n\nT> We're leaving handling of the current value, min and max values to the here, but we could also store that value ourselves and use signals to/from the dial to keep things in sync.\n\nRun this, wiggle the dial around and …..nothing happens. Although we've defined the handler we're not triggering a repaint when the dial changes.\n\nT> You can force a refresh by resizing the window, as soon as you do this you should see the text appear. Neat, but terrible UX — \"just resize your app to see your settings!\"\n\nTo fix this we need to hook up our widget to repaint itself in response to changing values on the dial. We can do this using the signal, hooking it up to a custom slot method which calls — triggering a full-repaint.\n\nAdd the following method to the widget.\n\n…and add the following to the block for the parent widget.\n\nIf you re-run the code now, you will see the display updating automatically as you turn the dial (click and drag with your mouse). The current value is displayed as text.\n\nDisplaying the current QDial value in text.\n\nNow we have the display updating and displaying the current value of the dial, we can move onto drawing the actual bar display. This is a little complicated, with a bit of maths to calculate bar positions, but we'll step through it to make it clear what's going on.\n\nThe sketch below shows what we are aiming for — a series of N boxes, inset from the edges of the widget, with spaces between them.\n\nWhat we're aiming for with this widget.\n\nThe number of boxes to draw is determined by the current value — and how far along it is between the minimum and maximum value configured for the . We already have that information in the example above.\n\nIf is half way between and then we want to draw half of the boxes (if we have 4 boxes total, draw 2). If is at we want to draw them all.\n\nTo do this we first convert our into a number between 0 and 1, where and . We first subtract from to adjust the range of possible values to start from zero — i.e. from to . Dividing this value by (the new maximum) then gives us a number between 0 and 1.\n\nThe trick then is to multiply this value (called below) by the number of steps and that gives us a number between 0 and 5 — the number of boxes to draw.\n\nWe're wrapping the result in to convert it to a whole number (rounding down) to remove any partial boxes.\n\nUpdate the method in your paint event to write out this number instead.\n\nAs you turn the dial you will now see a number between 0 and 5.\n\nNext we want to convert this number 0…5 to a number of bars drawn on the canvas. Start by removing the and font and pen settings, as we no longer need those.\n\nTo draw accurately we need to know the size of our canvas — i.e the size of the widget. We will also add a bit of padding around the edges to give space around the edges of the blocks against the black background.\n\nAll measurements in the `QPainter` are in pixels.\n\nWe take the height and width and subtract from each — it's 2x because we're padding both the left and right (and top and bottom) edges. This gives us our resulting active canvas area in and .\n\nThe widget canvas, padding and inner draw area.\n\nWe need to break up our into 5 equal parts, one for each block — we can calculate that height simply by . Additionally, since we want spaces between the blocks we need to calculate how much of this step size is taken up by space (top and bottom, so halved) and how much is actual block.\n\nThese values are all we need to draw our blocks on our canvas. To do this we count up to the number of steps-1 starting from 0 using and then draw a over a region for each block.\n\nThe fill is set to a red brush to begin with but we will customise this later.\n\nThe box to draw with is defined as a object to which we pass, in turn, the left x, top y, width and height.\n\nThe width is the full canvas width minus the padding, which we previously calculated and stored in . The left x is similarly just the value (5px) from the left hand side of the widget.\n\nThe height of the bar we calculated as 0.6 times the .\n\nThis leaves parameter 2 which gives the top y position of the rectangle to draw. This is the only calculation that changes as we draw the blocks.\n\nA key fact to remember here is that y coordinates in start at the top and increase down the canvas. This means that plotting at will be plotting at the very bottom of the canvas. When we draw a rectangle from a point it is drawn to the right and down from the starting position.\n\nTo draw a block at the very bottom we must start drawing at i.e. one block up to leave space to draw downwards.\n\nIn our bar meter we're drawing blocks, in turn, starting at the bottom and working upwards. So our very first block must be placed at and the second at . Our loop iterates from 0 upwards, so we can achieve this with the following formula —\n\nThe final adjustment is to account for our blocks only taking up part of each (currently 0.6). We add a little padding to move the block away from the edge of the box and into the middle, and finally add the padding for the bottom edge. That gives us the final formula —\n\nThis produces the following layout.\n\nIn the picture below the current value of has been printed over the box, and a blue box has been drawn around the complete so you can see the padding and spacers in effect.\n\nSpacing between bars in the layout, and block draw order.\n\nPutting this all together gives the following code, which when run will produce a working power-bar widget with blocks in red. You can drag the wheel back and forth and the bars will move up and down in response.\n\nThat already does the job, but we can go further to provide more customisation, add some UX improvements and improve the API for working with our widget.\n\nWe now have a working power bar, controllable with a dial. But it's nice when creating widgets to provide options to configure the behaviour and style of your widget to make it more flexible. In this part we'll add methods to set customisable numbers of segments, colors, padding and spacing.\n\nThe elements we're going to provide customisation of are as follows —\n\nWe can store each of these as attributes on the object, and use them from the method to change its behaviour.\n\nThe is updated to accept an initial argument for either the number of bars (as an integer) or the colors of the bars (as a list of , hex values or names). If a number is provided, all bars will be colored red. If the a list of colors is provided the number of bars will be determined from the length of the color list. Default values for , , are also set.\n\nLikewise we update the to accept the steps parameter, and pass it through.\n\nWe now have the parameters in place to update the method. The modified code is shown below.\n\nYou can now experiment with passing in different values for the init to , e.g. increasing the number of bars, or providing a color list. Some examples are shown below — a good source of hex palettes is the Bokeh source.\n\nYou could fiddle with the padding settings through the variables e.g. but it'd be nicer to provide proper methods to set these.\n\nWe're following the Qt standard of camelCase method names for these external methods for consistency with the others inherited from .\n\nIn each case we set the private variable on the object and then call to trigger a redraw of the widget. The method support changing the color to a single color, or updating a list of them — setting a list of colors can also be used to change the number of bars.\n\nThere is no method to set the bar count, since expanding a list of colors would be faffy. But feel free to try adding this yourself!\n\nHere's an example using 25px padding, a fully solid bar and a grey background.\n\nWith these settings you get the following result.\n\nWe've added methods to configure the behaviour of the power bar. But we currently provide no way to configure the standard methods — for example, setting the min, max or step size — from our widget. We could work through and add wrapper methods for all of these, but it would get very tedious very quickly.\n\nInstead we can add a little handler onto our outer widget to automatically look for methods (or attributes) on the instance, if they don't exist on our class directly. This way we can implement our own methods, yet still get all the goodness for free.\n\nThe wrapper is shown below, implemented as a custom method.\n\nWhen accessing a property (or method) — e.g. when when call Python internally uses to get the property from the current object. This handler does this through the object dictionary . We've overridden this method to provide our custom handling logic.\n\nNow, when we call , this handler first looks on our current object (a instance) to see if exists and if it does uses it. If not it then calls on instead returning what it finds there. This gives us access to all the methods of from our custom widget.\n\nIf doesn't have the attribute either, and raises an we catch it and raise it again from our custom widget, where it belongs.\n\nThis works for any properties or methods, including signals. So the standard signals such as are available too.\n\nCurrently you can update the current value of the PowerBar meter by twiddling with the dial. But it would be nicer UX if you could also update the value by clicking a position on the power bar, or by dragging you mouse up and down. To do this we can update our widget to handle mouse events.\n\nIn the block for the widget we can connect to the signal and send the values to to set the current value on the dial.\n\nIf you run the widget now, you'll be able to click around in the bar area and the value will update, and the dial rotate in sync.\n\nBelow is the complete final code for our PowerBar meter widget, called . You can save this over the previous file (e.g. named ) and then use it in any of your own projects, or customise it further to your own requirements.\n\nYou should be able to use many of these ideas in creating your own custom widgets.\n\nWant to see some more examples of custom widgets? Check out our Widget library which has free PyQt5 compatible widgets for you to drop into your own GUI projects."
    },
    {
        "link": "https://huggingface.co/transformers/v4.10.0/model_doc/gpt2.html",
        "document": "OpenAI GPT-2 model was proposed in Language Models are Unsupervised Multitask Learners by Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei and Ilya Sutskever. It’s a causal (unidirectional) transformer pretrained using language modeling on a very large corpus of ~40 GB of text data. The abstract from the paper is the following: GPT-2 is a large transformer-based language model with 1.5 billion parameters, trained on a dataset[1] of 8 million web pages. GPT-2 is trained with a simple objective: predict the next word, given all of the previous words within some text. The diversity of the dataset causes this simple goal to contain naturally occurring demonstrations of many tasks across diverse domains. GPT-2 is a direct scale-up of GPT, with more than 10X the parameters and trained on more than 10X the amount of data.\n• None GPT-2 is a model with absolute position embeddings so it’s usually advised to pad the inputs on the right rather than the left.\n• None GPT-2 was trained with a causal language modeling (CLM) objective and is therefore powerful at predicting the next token in a sequence. Leveraging this feature allows GPT-2 to generate syntactically coherent text as it can be observed in the example script.\n• None The PyTorch models can take the as input, which is the previously computed key/value attention pairs. Using this value prevents the model from re-computing pre-computed values in the context of text generation. See reusing the past in generative models for more information on the usage of this argument. Write With Transformer is a webapp created and hosted by Hugging Face showcasing the generative capabilities of several models. GPT-2 is one of them and is available in five different sizes: small, medium, large, xl and a distilled version of the small checkpoint: . This model was contributed by thomwolf. The original code can be found here.\n\nThe GPT2 Model transformer with a sequence classification head on top (linear layer). uses the last token in order to do the classification, as other causal models (e.g. GPT-1) do. Since it does classification on the last token, it requires to know the position of the last token. If a is defined in the configuration, it finds the last token that is not a padding token in each row. If no is defined, it simply takes the last value in each row of the batch. Since it cannot guess the padding tokens when are passed instead of , it does the same (take the last value in each row of the batch). This model inherits from . Check the superclass documentation for the generic methods the library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads etc.) This model is also a tf.keras.Model subclass. Use it as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and behavior.\n• None having all inputs as keyword arguments (like PyTorch models), or\n• None having all inputs as a list, tuple or dict in the first positional arguments. This second option is useful when using method which currently requires having all the tensors in the first argument of the model call function: . If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the first positional argument :\n• None a single Tensor with only and nothing else:\n• None a list of varying length with one or several input Tensors IN THE ORDER given in the docstring: or\n• None a dictionary with one or several input Tensors associated to the input names given in the docstring: config ( ) – Model configuration class with all the parameters of the model. Initializing with a config file does not load the weights associated with the model, only the configuration. Check out the method to load the model weights. Although the recipe for forward pass needs to be defined within this function, one should call the instance afterwards instead of this since the former takes care of running the pre and post processing steps while the latter silently ignores them.\n• None = if is else ( of input past key value states). Indices of input sequence tokens in the vocabulary. If is used, only input IDs that do not have their past calculated should be passed as . Indices can be obtained using . See and for details.\n• None past ( of length ) – Contains pre-computed hidden-states (key and values in the attention blocks) as computed by the model (see output below). Can be used to speed up sequential decoding. The token ids which have their past given to this model should not be passed as input ids as they have already been computed.\n• None Mask to avoid performing attention on padding token indices. Mask values selected in :\n• None 1 for tokens that are not masked,\n• None 0 for tokens that are masked.\n• None Segment token indices to indicate first and second portions of the inputs. Indices are selected in :\n• None Indices of positions of each input sequence tokens in the position embeddings. Selected in the range .\n• None head_mask ( or of shape or , ) – Mask to nullify selected heads of the self-attention modules. Mask values selected in :\n• None 1 indicates the head is not masked,\n• None 0 indicates the head is masked.\n• None inputs_embeds ( of shape , ) – Optionally, instead of passing you can choose to directly pass an embedded representation. This is useful if you want more control over how to convert indices into associated vectors than the model’s internal embedding lookup matrix.\n• None output_attentions ( , ) – Whether or not to return the attentions tensors of all attention layers. See under returned tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the config will be used instead.\n• None output_hidden_states ( , ) – Whether or not to return the hidden states of all layers. See under returned tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the config will be used instead.\n• None return_dict ( , ) – Whether or not to return a instead of a plain tuple. This argument can be used in eager mode, in graph mode the value will always be set to True.\n• None training ( , , defaults to ) – Whether or not to use the model in training mode (some modules like dropout modules have different behaviors between training and evaluation).\n• None labels ( of shape , ) – Labels for computing the cross entropy classification loss. Indices should be in . A or a tuple of (if is passed or when ) comprising various elements depending on the configuration ( ) and inputs.\n• None loss ( of shape , , returned when is provided) – Classification (or regression if config.num_labels==1) loss.\n• None logits ( of shape ) – Classification (or regression if config.num_labels==1) scores (before SoftMax).\n• None past_key_values ( , , returned when is passed or when ) – List of of length , with each tensor of shape ). Contains pre-computed hidden-states (key and values in the attention blocks) that can be used (see input) to speed up sequential decoding.\n• None hidden_states ( , , returned when is passed or when ) – Tuple of (one for the output of the embeddings + one for the output of each layer) of shape . Hidden-states of the model at the output of each layer plus the initial embedding outputs.\n• None attentions ( , , returned when is passed or when ) – Tuple of (one for each layer) of shape . Attentions weights after the attention softmax, used to compute the weighted average in the self-attention heads."
    },
    {
        "link": "https://huggingface.co/transformers/v4.10.0/index.html",
        "document": "🤗 Transformers (formerly known as and ) provides general-purpose architectures (BERT, GPT-2, RoBERTa, XLM, DistilBert, XLNet…) for Natural Language Understanding (NLU) and Natural Language Generation (NLG) with over 32+ pretrained models in 100+ languages and deep interoperability between Jax, PyTorch and TensorFlow.\n\nThis is the documentation of our repository transformers. You can also follow our online course that teaches how to use this library, as well as the other libraries developed by Hugging Face and the Hub.\n• None Low barrier to entry for educators and practitioners\n• None Researchers can share trained models instead of always retraining\n• None 8 architectures with over 30 pretrained models, some in more than 100 languages Choose the right framework for every part of a model’s lifetime:\n• None Move a single model between Jax/PyTorch/TensorFlow frameworks at will\n• None Seamlessly pick the right framework for training, evaluation, production The support for Jax is still experimental (with a few models right now), expect to see it grow in the coming months! All the model checkpoints are seamlessly integrated from the huggingface.co model hub where they are uploaded directly by users and organizations."
    },
    {
        "link": "https://pypi.org/project/transformers/2.1.0",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://pytorch.org/hub/huggingface_pytorch-transformers",
        "document": "PyTorch-Transformers (formerly known as ) is a library of state-of-the-art pre-trained models for Natural Language Processing (NLP).\n\nThe library currently contains PyTorch implementations, pre-trained model weights, usage scripts and conversion utilities for the following models:\n• BERT (from Google) released with the paper BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding by Jacob Devlin, Ming-Wei Chang, Kenton Lee and Kristina Toutanova.\n• GPT (from OpenAI) released with the paper Improving Language Understanding by Generative Pre-Training by Alec Radford, Karthik Narasimhan, Tim Salimans and Ilya Sutskever.\n• GPT-2 (from OpenAI) released with the paper Language Models are Unsupervised Multitask Learners by Alec Radford, Jeffrey Wu, Rewon Child, David Luan, Dario Amodei** and Ilya Sutskever**.\n• Transformer-XL (from Google/CMU) released with the paper Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context by Zihang Dai, Zhilin Yang, Yiming Yang, Jaime Carbonell, Quoc V. Le, Ruslan Salakhutdinov.\n• XLNet (from Google/CMU) released with the paper ​XLNet: Generalized Autoregressive Pretraining for Language Understanding by Zhilin Yang, Zihang Dai, Yiming Yang, Jaime Carbonell, Ruslan Salakhutdinov, Quoc V. Le.\n• XLM (from Facebook) released together with the paper Cross-lingual Language Model Pretraining by Guillaume Lample and Alexis Conneau.\n• RoBERTa (from Facebook), released together with the paper a Robustly Optimized BERT Pretraining Approach by Yinhan Liu, Myle Ott, Naman Goyal, Jingfei Du, Mandar Joshi, Danqi Chen, Omer Levy, Mike Lewis, Luke Zettlemoyer, Veselin Stoyanov.\n• DistilBERT (from HuggingFace), released together with the blogpost Smaller, faster, cheaper, lighter: Introducing DistilBERT, a distilled version of BERT by Victor Sanh, Lysandre Debut and Thomas Wolf.\n\nThe components available here are based on the and classes of the library.\n\nUnlike most other PyTorch Hub models, BERT requires a few additional Python packages to be installed.\n\nThe available methods are the following:\n• : returns a configuration item corresponding to the specified model or pth.\n• : returns a tokenizer corresponding to the specified model or path\n• : returns a model corresponding to the specified model or path\n• : returns a model with a language modeling head corresponding to the specified model or path\n• : returns a model with a sequence classifier corresponding to the specified model or path\n• : returns a model with a question answering head corresponding to the specified model or path\n\nAll these methods share the following argument: , which is a string identifying a pre-trained model or path from which an instance will be returned. There are several checkpoints available for each model, which are detailed below:\n\nThe available models are listed on the transformers documentation, models page.\n\nHere are a few examples detailing the usage of each available method.\n\nThe tokenizer object allows the conversion from character strings to tokens understood by the different models. Each model has its own tokenizer, and some tokenizing methods are different across tokenizers. The complete documentation can be found here.\n\nThe model object is a model instance inheriting from a . Each model is accompanied by their saving/loading methods, either from a local file or directory, or from a pre-trained configuration (see previously described ). Each model works differently, a complete overview of the different models can be found in the documentation.\n\nThe configuration is optional. The configuration object holds information concerning the model, such as the number of heads/layers, if the model should output attentions or hidden states, or if it should be adapted for TorchScript. Many parameters are available, some specific to each model. The complete documentation can be found here.\n\nHere is an example on how to tokenize the input text to be fed as input to a BERT model, and then get the hidden states computed by such a model or predict masked tokens using language modeling BERT model.\n\nUsing to encode the input sentence in a sequence of last layer hidden-states\n\nUsing to predict a masked token with BERT\n\nUsing to do question answering with BERT\n\n# The format is paragraph first and then question # Or get the total loss which is the sum of the CrossEntropy loss for the start and end token positions (set model to train mode before if used for training)\n\nUsing to do paraphrase classification with BERT"
    },
    {
        "link": "https://pypi.org/project/transformers/2.0.0",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    }
]