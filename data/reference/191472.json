[
    {
        "link": "https://developer.android.com/guide/fragments/dialogs",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nA is a special fragment subclass that is designed for creating and hosting dialogs. Although you don't need to host your dialog within a fragment, doing so lets the manage the state of the dialog and automatically restore the dialog when a configuration change occurs.\n\nTo create a , create a class that extends and override , as shown in the following example.\n\nSimilar to how creates a root in an ordinary fragment, creates a to display as part of the . The handles displaying the at appropriate states in the fragment's lifecycle.\n\nAs with , you can return any subclass of from and aren't limited to using .\n\nYou don't have to manually create a to display your . Instead, use the method to display your dialog. You can pass a reference to a and a to use as a tag.\n\nWhen creating a from within a , use the fragment's child so that the state properly restores after configuration changes. A non-null tag lets you use to retrieve the at a later time.\n\nFor more control over the , you can use the overload that accepts an existing .\n\nA follows the standard fragment lifecycle, with a few additional lifecycle callbacks. The most common ones are as follows:\n• : override this callback to provide a for the fragment to manage and display.\n• : override this callback if you need to perform any custom logic when your is dismissed, such as releasing resources or unsubscribing from observable resources.\n• : override this callback if you need to perform any custom logic when your is canceled.\n\nalso contains methods to dismiss or set the cancelability of your :\n• : dismiss the fragment and its dialog. If the fragment was added to the back stack, all back stack state up to and including this entry are popped. Otherwise, a new transaction is committed to remove the fragment.\n• : control whether the shown is cancelable. Use this method instead of directly calling .\n\nYou don't override or when using a with a . Dialogs aren't only views—they have their own window. As such, it's not enough to override . Moreover, is never called on a custom unless you've overridden and provided a non-null view.\n\nYou can create a and display a dialog by overriding . You can either give it a , as with a typical fragment, or use the constructor.\n\nThe returned by is automatically added to the dialog. In most cases, this means that you don't need to override , as the default empty dialog is populated with your view.\n\nCertain subclasses of , such as , embed your view in a dialog that is styled as a bottom sheet."
    },
    {
        "link": "https://developer.android.com/guide/components/activities/activity-lifecycle",
        "document": "As a user navigates through, out of, and back to your app, the instances in your app transition through different states in their lifecycle. The class provides a number of callbacks that let the activity know when a state changes or that the system is creating, stopping, or resuming an activity or destroying the process the activity resides in.\n\nWithin the lifecycle callback methods, you can declare how your activity behaves when the user leaves and re-enters the activity. For example, if you're building a streaming video player, you might pause the video and terminate the network connection when the user switches to another app. When the user returns, you can reconnect to the network and let the user resume the video from the same spot.\n\nEach callback lets you perform specific work that's appropriate to a given change of state. Doing the right work at the right time and handling transitions properly make your app more robust and performant. For example, good implementation of the lifecycle callbacks can help your app avoid the following:\n• Crashing if the user receives a phone call or switches to another app while using your app.\n• Consuming valuable system resources when the user is not actively using it.\n• Losing the user's progress if they leave your app and return to it at a later time.\n• Crashing or losing the user's progress when the screen rotates between landscape and portrait orientation.\n\nThis document explains the activity lifecycle in detail. The document begins by describing the lifecycle paradigm. Next, it explains each of the callbacks: what happens internally while they execute and what you need to implement during them.\n\nIt then briefly introduces the relationship between activity state and a process’s vulnerability to being killed by the system. Finally, it discusses several topics related to transitions between activity states.\n\nFor information about handling lifecycles, including guidance about best practices, see Handling Lifecycles with Lifecycle-Aware Components and Save UI states. To learn how to architect a robust, production-quality app using activities in combination with architecture components, see Guide to app architecture.\n\nTo navigate transitions between stages of the activity lifecycle, the class provides a core set of six callbacks: , , , , , and . The system invokes each of these callbacks as the activity enters a new state.\n\nAs the user begins to leave the activity, the system calls methods to dismantle the activity. In some cases, the activity is only partially dismantled and still resides in memory, such as when the user switches to another app. In these cases, the activity can still come back to the foreground.\n\nIf the user returns to the activity, it resumes from where the user left off. With a few exceptions, apps are restricted from starting activities when running in the background.\n\nThe system’s likelihood of killing a given process, along with the activities in it, depends on the state of the activity at the time. For more information on the relationship between state and vulnerability to ejection, see the section about activity state and ejection from memory.\n\nDepending on the complexity of your activity, you probably don't need to implement all the lifecycle methods. However, it's important that you understand each one and implement those that make your app behave the way users expect.\n\nThis section provides conceptual and implementation information about the callback methods used during the activity lifecycle.\n\nSome actions belong in the activity lifecycle methods. However, place code that implements the actions of a dependent component in the component, rather than the activity lifecycle method. To achieve this, you need to make the dependent component lifecycle-aware. To learn how to make your dependent components lifecycle-aware, see Handling Lifecycles with Lifecycle-Aware Components.\n\nYou must implement this callback, which fires when the system first creates the activity. On activity creation, the activity enters the Created state. In the method, perform basic application startup logic that happens only once for the entire life of the activity.\n\nFor example, your implementation of might bind data to lists, associate the activity with a , and instantiate some class-scope variables. This method receives the parameter , which is a object containing the activity's previously saved state. If the activity has never existed before, the value of the object is null.\n\nIf you have a lifecycle-aware component that is hooked up to the lifecycle of your activity, it receives the event. The method annotated with is called so your lifecycle-aware component can perform any setup code it needs for the created state.\n\nThe following example of the method shows fundamental setup for the activity, such as declaring the user interface (defined in an XML layout file), defining member variables, and configuring some of the UI. In this example, the XML layout file passes the file’s resource ID to .\n\nAs an alternative to defining the XML file and passing it to , you can create new objects in your activity code and build a view hierarchy by inserting new objects into a . You then use that layout by passing the root to . For more information about creating a user interface, see the user interface documentation.\n\nYour activity does not remain in the Created state. After the method finishes execution, the activity enters the Started state and the system calls the and methods in quick succession.\n\nWhen the activity enters the Started state, the system invokes . This call makes the activity visible to the user as the app prepares for the activity to enter the foreground and become interactive. For example, this method is where the code that maintains the UI is initialized.\n\nWhen the activity moves to the Started state, any lifecycle-aware component tied to the activity's lifecycle receives the event.\n\nThe method completes quickly and, as with the Created state, the activity does not remain in the Started state. Once this callback finishes, the activity enters the Resumed state and the system invokes the method.\n\nWhen the activity enters the Resumed state, it comes to the foreground, and the system invokes the callback. This is the state in which the app interacts with the user. The app stays in this state until something happens to take focus away from the app, such as the device receiving a phone call, the user navigating to another activity, or the device screen turning off.\n\nWhen the activity moves to the Resumed state, any lifecycle-aware component tied to the activity's lifecycle receives the event. This is where the lifecycle components can enable any functionality that needs to run while the component is visible and in the foreground, such as starting a camera preview.\n\nWhen an interruptive event occurs, the activity enters the Paused state and the system invokes the callback.\n\nIf the activity returns to the Resumed state from the Paused state, the system once again calls the method. For this reason, implement to initialize components that you release during and to perform any other initializations that must occur each time the activity enters the Resumed state.\n\nHere is an example of a lifecycle-aware component that accesses the camera when the component receives the event:\n\nThe preceding code initializes the camera once the receives the event. In multi-window mode, however, your activity might be fully visible even when it is in the Paused state. For example, when the app is in multi-window mode and the user taps the window that does not contain your activity, your activity moves to the Paused state.\n\nIf you want the camera active only when the app is Resumed (visible and active in the foreground), then initialize the camera after the event demonstrated previously. If you want to keep the camera active while the activity is Paused but visible, such as in multi-window mode, then initialize the camera after the event.\n\nHowever, having the camera active while your activity is Paused might deny access to the camera to another Resumed app in multi-window mode. Sometimes it is necessary to keep the camera active while your activity is Paused, but it might actually degrade the overall user experience if you do.\n\nFor this reason, think carefully about where in the lifecycle it is most appropriate to take control of shared system resources in the context of multi-window mode. To learn more about supporting multi-window mode, see Multi-window support.\n\nRegardless of which build-up event you choose to perform an initialization operation in, make sure to use the corresponding lifecycle event to release the resource. If you initialize something after the event, release or terminate it after the event. If you initialize after the event, release after the event.\n\nThe preceding code snippet places camera initialization code in a lifecycle-aware component. You can instead put this code directly into the activity lifecycle callbacks, such as and , but we don't recommend this. Adding this logic to an independent, lifecycle-aware component lets you reuse the component across multiple activities without having to duplicate code. To learn how to create a lifecycle-aware component, see Handling Lifecycles with Lifecycle-Aware Components.\n\nThe system calls this method as the first indication that the user is leaving your activity, though it does not always mean the activity is being destroyed. It indicates that the activity is no longer in the foreground, but it is still visible if the user is in multi-window mode. There are several reasons why an activity might enter this state:\n• An event that interrupts app execution, as described in the section about the onResume() callback, pauses the current activity. This is the most common case.\n• In multi-window mode, only one app has focus at any time, and the system pauses all the other apps.\n• The opening of a new, semi-transparent activity, such as a dialog, pauses the activity it covers. As long as the activity is partially visible but not in focus, it remains paused.\n\nWhen an activity moves to the Paused state, any lifecycle-aware component tied to the activity's lifecycle receives the event. This is where the lifecycle components can stop any functionality that does not need to run while the component is not in the foreground, such as stopping a camera preview.\n\nUse the method to pause or adjust operations that can't continue, or might continue in moderation, while the is in the Paused state, and that you expect to resume shortly.\n\nYou can also use the method to release system resources, handles to sensors (like GPS), or any resources that affect battery life while your activity is Paused and the user does not need them.\n\nHowever, as mentioned in the section about , a Paused activity might still be fully visible if the app is in multi-window mode. Consider using instead of to fully release or adjust UI-related resources and operations to better support multi-window mode.\n\nThe following example of a reacting to the event is the counterpart to the preceding event example, releasing the camera that initializes after the event is received:\n\nThis example places the camera release code after the event is received by the .\n\nexecution is very brief and does not necessarily offer enough time to perform save operations. For this reason, don't use to save application or user data, make network calls, or execute database transactions. Such work might not complete before the method completes.\n\nInstead, perform heavy-load shutdown operations during . For more information about suitable operations to perform during , see the next section. For more information about saving data, see the section about saving and restoring state.\n\nCompletion of the method does not mean that the activity leaves the Paused state. Rather, the activity remains in this state until either the activity resumes or it becomes completely invisible to the user. If the activity resumes, the system once again invokes the callback.\n\nIf the activity returns from the Paused state to the Resumed state, the system keeps the instance resident in memory, recalling that instance when the system invokes . In this scenario, you don’t need to re-initialize components created during any of the callback methods leading up to the Resumed state. If the activity becomes completely invisible, the system calls .\n\nWhen your activity is no longer visible to the user, it enters the Stopped state, and the system invokes the callback. This can occur when a newly launched activity covers the entire screen. The system also calls when the activity finishes running and is about to be terminated.\n\nWhen the activity moves to the Stopped state, any lifecycle-aware component tied to the activity's lifecycle receives the event. This is where the lifecycle components can stop any functionality that does not need to run while the component is not visible on the screen.\n\nIn the method, release or adjust resources that are not needed while the app is not visible to the user. For example, your app might pause animations or switch from fine-grained to coarse-grained location updates. Using instead of means that UI-related work continues, even when the user is viewing your activity in multi-window mode.\n\nAlso, use to perform relatively CPU-intensive shutdown operations. For example, if you can't find a better time to save information to a database, you might do so during . The following example shows an implementation of that saves the contents of a draft note to persistent storage:\n\nThe preceding code sample uses SQLite directly. However, we recommend using Room, a persistence library that provides an abstraction layer over SQLite. To learn more about the benefits of using Room and how to implement Room in your app, see the Room Persistence Library guide.\n\nWhen your activity enters the Stopped state, the object is kept resident in memory: it maintains all state and member information, but is not attached to the window manager. When the activity resumes, it recalls this information.\n\nYou don’t need to re-initialize components created during any of the callback methods leading up to the Resumed state. The system also keeps track of the current state for each object in the layout, so if the user enters text into an widget, that content is retained so you don't need to save and restore it.\n\nNote: Once your activity is stopped, the system might destroy the process that contains the activity if the system needs to recover memory. Even if the system destroys the process while the activity is stopped, the system still retains the state of the objects, such as text in an widget, in a —a blob of key-value pairs—and restores them if the user navigates back to the activity. For more information about restoring an activity to which a user returns, see the section about saving and restoring state.\n\nFrom the Stopped state, the activity either comes back to interact with the user, or the activity is finished running and goes away. If the activity comes back, the system invokes . If the is finished running, the system calls .\n\nis called before the activity is destroyed. The system invokes this callback for one of two reasons:\n• The activity is finishing, due to the user completely dismissing the activity or due to being called on the activity.\n• The system is temporarily destroying the activity due to a configuration change, such as device rotation or entering multi-window mode.\n\nWhen the activity moves to the destroyed state, any lifecycle-aware component tied to the activity's lifecycle receives the event. This is where the lifecycle components can clean up anything they need to before the is destroyed.\n\nInstead of putting logic in your to determine why it is being destroyed, use a object to contain the relevant view data for your . If the is recreated due to a configuration change, the does not have to do anything, since it is preserved and given to the next instance.\n\nIf the isn't recreated, then the has the method called, where it can clean up any data it needs to before being destroyed. You can distinguish between these two scenarios with the method.\n\nIf the activity is finishing, is the final lifecycle callback the activity receives. If is called as the result of a configuration change, the system immediately creates a new activity instance and then calls on that new instance in the new configuration.\n\nThe callback releases all resources not released by earlier callbacks, such as .\n\nThe system kills processes when it needs to free up RAM. The likelihood of the system killing a given process depends on the state of the process at the time. Process state, in turn, depends on the state of the activity running in the process. Table 1 shows the correlations among process state, activity state, and the likelihood of the system killing the process. This table only applies if a process is not running other types of application components.\n\nThe system never kills an activity directly to free up memory. Instead, it kills the process the activity runs in, destroying not only the activity but everything else running in the process as well. To learn how to preserve and restore your activity's UI state when system-initiated process death occurs, see the section about saving and restoring state.\n\nThe user can also kill a process by using the Application Manager, under Settings, to kill the corresponding app.\n\nFor more information about processes, see Processes and threads overview.\n\nA user expects an activity’s UI state to remain the same throughout a configuration change, such as rotation or switching into multi-window mode. However, the system destroys the activity by default when such a configuration change occurs, wiping away any UI state stored in the activity instance.\n\nSimilarly, a user expects UI state to remain the same if they temporarily switch away from your app to a different app and then come back to your app later. However, the system can destroy your application’s process while the user is away and your activity is stopped.\n\nWhen system constraints destroy the activity, preserve the user’s transient UI state using a combination of , , and/or local storage. To learn more about user expectations compared to system behavior and how to best preserve complex UI state data across system-initiated activity and process death, see Save UI states.\n\nThis section outlines what instance state is and how to implement the method, which is a callback on the activity itself. If your UI data is lightweight, you can use alone to persist the UI state across both configuration changes and system-initiated process death. But because incurs serialization/deserialization costs, in most cases you use both and , as outlined in Save UI states.\n\nNote: To learn more about configuration changes, how to restrict Activity recreation if needed, and how to react to those configuration changes from the View system and Jetpack Compose, check out the Handle configuration changes page.\n\nThere are a few scenarios in which your activity is destroyed due to normal app behavior, such as when the user presses the Back button or your activity signals its own destruction by calling the method.\n\nWhen your activity is destroyed because the user presses Back or the activity finishes itself, both the system's and the user's concept of that instance is gone forever. In these scenarios, the user's expectation matches the system's behavior, and you do not have any extra work to do.\n\nHowever, if the system destroys the activity due to system constraints (such as a configuration change or memory pressure), then although the actual instance is gone, the system remembers that it existed. If the user attempts to navigate back to the activity, the system creates a new instance of that activity using a set of saved data that describes the state of the activity when it was destroyed.\n\nThe saved data that the system uses to restore the previous state is called the instance state. It's a collection of key-value pairs stored in a object. By default, the system uses the instance state to save information about each object in your activity layout, such as the text value entered into an widget.\n\nSo, if your activity instance is destroyed and recreated, the state of the layout is restored to its previous state with no code required by you. However, your activity might have more state information that you'd like to restore, such as member variables that track the user's progress in the activity.\n\nNote: In order for the Android system to restore the state of the views in your activity, each view must have a unique ID, supplied by the attribute.\n\nA object isn't appropriate for preserving more than a trivial amount of data, because it requires serialization on the main thread and consumes system-process memory. To preserve more than a very small amount of data, take a combined approach to preserving data, using persistent local storage, the method, and the class, as outlined in Save UI states.\n\nAs your activity begins to stop, the system calls the method so your activity can save state information to an instance state bundle. The default implementation of this method saves transient information about the state of the activity's view hierarchy, such as the text in an widget or the scroll position of a widget.\n\nTo save additional instance state information for your activity, override and add key-value pairs to the object that is saved in the event that your activity is destroyed unexpectedly. When you override , you need to call the superclass implementation if you want the default implementation to save the state of the view hierarchy. This is shown in the following example:\n\nNote: is not called when the user explicitly closes the activity or in other cases when is called.\n\nTo save persistent data, such as user preferences or data for a database, take appropriate opportunities when your activity is in the foreground. If no such opportunity arises, save persistent data during the method.\n\nWhen your activity is recreated after it was previously destroyed, you can recover your saved instance state from the that the system passes to your activity. Both the and callback methods receive the same that contains the instance state information.\n\nBecause the method is called whether the system is creating a new instance of your activity or recreating a previous one, you need to check whether the state is null before you attempt to read it. If it is null, then the system is creating a new instance of the activity, instead of restoring a previous one that was destroyed.\n\nThe following code snippet shows how you can restore some state data in :\n\nInstead of restoring the state during , you can choose to implement , which the system calls after the method. The system calls only if there is a saved state to restore, so you do not need to check whether the is null.\n\nCaution: Always call the superclass implementation of so the default implementation can restore the state of the view hierarchy.\n\nAn app is likely to enter and exit an activity, perhaps many times, during the app’s lifetime, such as when the user taps the device’s Back button or the activity launches a different activity.\n\nThis section covers topics you need to know to implement successful activity transitions. These topics include starting an activity from another activity, saving activity state, and restoring activity state.\n\nStarting one activity from another\n\nAn activity often needs to start another activity at some point. This need arises, for instance, when an app needs to move from the current screen to a new one.\n\nDepending on whether or not your activity wants a result back from the new activity it’s about to start, you start the new activity using either the method or the method. In either case, you pass in an object.\n\nThe object specifies either the exact activity you want to start or describes the type of action you want to perform. The system selects the appropriate activity for you, which can even be from a different application. An object can also carry small amounts of data to be used by the activity that is started. For more information about the class, see Intents and Intent Filters.\n\nIf the newly started activity does not need to return a result, the current activity can start it by calling the method.\n\nWhen working within your own application, you often need to simply launch a known activity. For example, the following code snippet shows how to launch an activity called .\n\nYour application might also want to perform some action, such as send an email, text message, or status update, using data from your activity. In this case, your application might not have its own activities to perform such actions, so you can instead leverage the activities provided by other applications on the device, which can perform the actions for you.\n\nThis is where intents are really valuable. You can create an intent that describes an action you want to perform, and the system launches the appropriate activity from another application. If there are multiple activities that can handle the intent, then the user can select which one to use. For example, if you want to let the user send an email message, you can create the following intent:\n\nThe extra added to the intent is a string array of email addresses the email is to be sent to. When an email application responds to this intent, it reads the string array provided in the extra and places the addresses in the \"to\" field of the email composition form. In this situation, the email application's activity starts, and when the user is done, your activity resumes.\n\nSometimes you want to get a result back from an activity when it ends. For example, you might start an activity that lets the user pick a person in a list of contacts. When it ends, it returns the person that was selected. To do this, you call the method, where the integer parameter identifies the call.\n\nThis identifier is meant to distinguish between multiple calls to from the same activity. It's not a global identifier and is not at risk of conflicting with other apps or activities. The result comes back through your method.\n\nWhen a child activity exits, it can call to return data to its parent. The child activity must supply a result code, which can be the standard results , , or any custom values starting at .\n\nIn addition, the child activity can optionally return an object containing any additional data it wants. The parent activity uses the method, along with the integer identifier the parent activity originally supplied, to receive the information.\n\nIf a child activity fails for any reason, such as crashing, the parent activity receives a result with the code .\n\nWhen one activity starts another, they both experience lifecycle transitions. The first activity stops operating and enters the Paused or Stopped state, while the other activity is created. In case these activities share data saved to disc or elsewhere, it's important to understand that the first activity is not completely stopped before the second one is created. Rather, the process of starting the second one overlaps with the process of stopping the first one.\n\nThe order of lifecycle callbacks is well defined, particularly when the two activities are in the same process—in other words, the same app—and one is starting the other. Here's the order of operations that occur when Activity A starts Activity B:\n• Activity B's , , and methods execute in sequence. Activity B now has user focus.\n• If Activity A is no longer visible on screen, its method executes.\n\nThis sequence of lifecycle callbacks lets you manage the transition of information from one activity to another."
    },
    {
        "link": "https://stackoverflow.com/questions/31454223/fragment-and-dialogfragment-lifecycle-relationship",
        "document": "I have \"A\" where I have an in place. Upon clicking this button a \"B\" is called to the foreground where \"A\" is partially visible in the background. \"B\" presents the user with a list of choices. Upon clicking a specific choice \"B\" is dismissed via and \"A\" becomes fully visible again.\n\nDuring this action I need to update the on \"A\" to represent the user's choice made on \"B\" (basically a new image for the ).\n\nAm I correct in thinking the right place to update the on Fragment \"A\" is during ? Does Fragment \"A\" go into while \"B\" is being shown? Therefore upon returning from \"B\", \"A\" would trigger its and that's where I should make the update changes to the being presented to the user?\n\nI hope my explanation is clear. Any detailed help on where and how I should be updating the would be highly appreciated."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/android-dialogfragment",
        "document": "In this tutorial, we’ll be discussing what are DialogFragments. We’ll see how they are different from the Dialogs too with the help of a simple android application.\n\nDialogFragment is a utility class which extends the Fragment class. It is a part of the v4 support library and is used to display an overlay modal window within an activity that floats on top of the rest of the content. Essentially a DialogFragment displays a Dialog but inside a Fragment.\n\nGoogle recommends that we use DialogFragment instead of a simple Alert Dialog builder in the activity.\n• DialogFragments have their own lifecycle methods. So the Activity is free from the responsibility of telling the Dialog what to do.\n• No more IllegalStateExceptions and leaked window crashes. This was pretty common when the activity was destroyed with the Alert Dialog still there.\n\nBecause DialogFragment is a fragment, it integrates into the activity’s lifecycle and ensures that what’s happening in the dialog window remains consistent. It’s a good practice to use DialogFragments to create dialogs in your android application. Your class must extend DialogFragment with at least and/or implemented. You can create Dialogs using DialogFragment in two ways:\n• - Here you can create the AlertDialog using the AlertDialog.Builder class.\n• - Here you can create a Dialog using a custom view defined.\n\nIn order to create a DialogFragment that shows a Dialog, we need to call the method show() on the DialogFragment instance as:\n\nWe can set any tag as the second argument of . In order to create a DialogFragment that embeds the dialog in a fragment, we just the Fragment to the Framelayout as we do it with any Fragment.\n\nDo you know? You can show the custom views in Fragments as well instead of just Dialogs.\n\nWhen a DialogFragment class is instantiated. Methods are called in the following order:\n\nPassing Data to and From the DialogFragment\n\nIn order to pass the data to the DialogFragment class, we can simply set the data using setArguments on the instance of the class. In order to return the data from the DialogFragments to the Activity/another fragment, we need to create our custom interface. In the following section, we’ll be creating an android application that does the following things:\n\nThe code for the activity_main.xml class is given below:\n\nEach of the Buttons would start a different type of DialogFragment. The xml layout for the custom view for a DialogFragment is defined in fragment_sample_dialog.xml file as shown below:\n\nSo our Dialog would show a basic Login form. The code for the MainActivity.java is given below:\n\nThe above class implements an interface which triggers the method whenever the button of the DialogFragment is clicked. It displays the data entered in the Dialog on the Activity. The code for the MyDialogFragment.java class is given below:\n\nInside we create a normal AlertDialog. function closes the Dialog. The output of the above application in action is given below: Notice that in the full screen Dialog, the data for the input field was already passed. That brings an end to this tutorial. You can download the project from the link below:"
    },
    {
        "link": "https://developer.android.com/topic/libraries/architecture/lifecycle",
        "document": "Save and categorize content based on your preferences.\n\nLifecycle-aware components perform actions in response to a change in the lifecycle status of another component, such as activities and fragments. These components help you produce better-organized, and often lighter-weight code, that is easier to maintain.\n\nA common pattern is to implement the actions of the dependent components in the lifecycle methods of activities and fragments. However, this pattern leads to a poor organization of the code and to the proliferation of errors. By using lifecycle-aware components, you can move the code of dependent components out of the lifecycle methods and into the components themselves.\n\nThe package provides classes and interfaces that let you build lifecycle-aware components—which are components that can automatically adjust their behavior based on the current lifecycle state of an activity or fragment.\n\nMost of the app components that are defined in the Android Framework have lifecycles attached to them. Lifecycles are managed by the operating system or the framework code running in your process. They are core to how Android works and your application must respect them. Not doing so may trigger memory leaks or even application crashes.\n\nImagine we have an activity that shows the device location on the screen. A common implementation might be like the following:\n\nEven though this sample looks fine, in a real app, you end up having too many calls that manage the UI and other components in response to the current state of the lifecycle. Managing multiple components places a considerable amount of code in lifecycle methods, such as and , which makes them difficult to maintain.\n\nMoreover, there's no guarantee that the component starts before the activity or fragment is stopped. This is especially true if we need to perform a long-running operation, such as some configuration check in . This can cause a race condition where the method finishes before the , keeping the component alive longer than it's needed.\n\nThe package provides classes and interfaces that help you tackle these problems in a resilient and isolated way.\n\nis a class that holds the information about the lifecycle state of a component (like an activity or a fragment) and allows other objects to observe this state.\n\nuses two main enumerations to track the lifecycle status for its associated component:\n\nThink of the states as nodes of a graph and events as the edges between these nodes.\n\nA class can monitor the component's lifecycle status by implementing and overriding corresponding methods such as , , etc. Then you can add an observer by calling the method of the class and passing an instance of your observer, as shown in the following example:\n\nIn the example above, the object implements the interface, which is explained in the following section.\n\nis a single method interface that denotes that the class has a . It has one method, , which must be implemented by the class. If you're trying to manage the lifecycle of a whole application process instead, see .\n\nThis interface abstracts the ownership of a from individual classes, such as and , and allows writing components that work with them. Any custom application class can implement the interface.\n\nComponents that implement work seamlessly with components that implement because an owner can provide a lifecycle, which an observer can register to watch.\n\nFor the location tracking example, we can make the class implement and then initialize it with the activity's in the method. This allows the class to be self-sufficient, meaning that the logic to react to changes in lifecycle status is declared in instead of the activity. Having the individual components store their own logic makes the activities and fragments logic easier to manage.\n\nA common use case is to avoid invoking certain callbacks if the isn't in a good state right now. For example, if the callback runs a fragment transaction after the activity state is saved, it would trigger a crash, so we would never want to invoke that callback.\n\nTo make this use case easy, the class allows other objects to query the current state.\n\nWith this implementation, our class is completely lifecycle-aware. If we need to use our from another activity or fragment, we just need to initialize it. All of the setup and teardown operations are managed by the class itself.\n\nIf a library provides classes that need to work with the Android lifecycle, we recommend that you use lifecycle-aware components. Your library clients can easily integrate those components without manual lifecycle management on the client side.\n\nFragments and Activities in Support Library 26.1.0 and later already implement the interface.\n\nIf you have a custom class that you would like to make a , you can use the LifecycleRegistry class, but you need to forward events into that class, as shown in the following code example:\n• Keep your UI controllers (activities and fragments) as lean as possible. They should not try to acquire their own data; instead, use a to do that, and observe a object to reflect the changes back to the views.\n• Try to write data-driven UIs where your UI controller’s responsibility is to update the views as data changes, or notify user actions back to the .\n• Put your data logic in your class. should serve as the connector between your UI controller and the rest of your app. Be careful though, it isn't 's responsibility to fetch data (for example, from a network). Instead, should call the appropriate component to fetch the data, then provide the result back to the UI controller.\n• Use Data Binding to maintain a clean interface between your views and the UI controller. This allows you to make your views more declarative and minimize the update code you need to write in your activities and fragments. If you prefer to do this in the Java programming language, use a library like Butter Knife to avoid boilerplate code and have a better abstraction.\n• If your UI is complex, consider creating a presenter class to handle UI modifications. This might be a laborious task, but it can make your UI components easier to test.\n• Avoid referencing a or context in your . If the outlives the activity (in case of configuration changes), your activity leaks and isn't properly disposed by the garbage collector.\n• Use Kotlin coroutines to manage long-running tasks and other operations that can run asynchronously.\n\nLifecycle-aware components can make it much easier for you to manage lifecycles in a variety of cases. A few examples are:\n• Switching between coarse and fine-grained location updates. Use lifecycle-aware components to enable fine-grained location updates while your location app is visible and switch to coarse-grained updates when the app is in the background. , a lifecycle-aware component, allows your app to automatically update the UI when your user changes locations.\n• Stopping and starting video buffering. Use lifecycle-aware components to start video buffering as soon as possible, but defer playback until app is fully started. You can also use lifecycle-aware components to terminate buffering when your app is destroyed.\n• Starting and stopping network connectivity. Use lifecycle-aware components to enable live updating (streaming) of network data while an app is in the foreground and also to automatically pause when the app goes into the background.\n• Pausing and resuming animated drawables. Use lifecycle-aware components to handle pausing animated drawables when the app is in the background and resume drawables after the app is in the foreground.\n\nWhen a belongs to an or , the 's state changes to and the event is dispatched when the or 's is called.\n\nWhen a or 's state is saved via , it's UI is considered immutable until is called. Trying to modify the UI after the state is saved is likely to cause inconsistencies in the navigation state of your application which is why throws an exception if the app runs a after state is saved. See for details.\n\nprevents this edge case out of the box by refraining from calling its observer if the observer's associated isn't at least . Behind the scenes, it calls before deciding to invoke its observer.\n\nUnfortunately, 's method is called after , which leaves a gap where UI state changes are not allowed but the has not yet been moved to the state.\n\nTo prevent this issue, the class in version and lower mark the state as without dispatching the event so that any code that checks the current state gets the real value even though the event isn't dispatched until is called by the system.\n\nUnfortunately, this solution has two major problems:\n• On API level 23 and lower, the Android system actually saves the state of an activity even if it is partially covered by another activity. In other words, the Android system calls but it doesn't necessarily call . This creates a potentially long interval where the observer still thinks that the lifecycle is active even though its UI state can't be modified.\n• Any class that wants to expose a similar behavior to the class has to implement the workaround provided by version and lower.\n\nTo learn more about handling lifecycles with lifecycle-aware components, consult the following additional resources."
    },
    {
        "link": "https://developer.android.com/reference/android/app/DatePickerDialog",
        "document": "[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2025-02-10 UTC.\"],[],[]]"
    },
    {
        "link": "https://geeksforgeeks.org/datepickerdialog-in-android",
        "document": "Android DatePicker is a user interface control that is used to select the date by day, month, and year in the android application. DatePicker is used to ensure that the users will select a valid date. In android DatePicker having two modes, the first one shows the complete calendar and the second one shows the dates in the spinner view. One can create a DatePicker control in two ways either manually in the XML file or create it in the Activity file programmatically. We are going to do it programmatically by using Java.\n\nTo create a new project in Android Studio please refer to How to Create/Start a New Project in Android Studio. Note that select Java as the programming language.\n\nIn the activity_main.xml file add only a TextView to display the selected date and a Button to select the date from the DatePickerDialog. Below is the complete code for the activity_main.xml file.\n\nStep 3: Create a new class and names as DatePicker\n\nNow create a new class by going to the package and right-click on it and select new and then Java Class. Name the class as DatePicker and its superclass as DialogFragment (androidx.fragment.app.DialogFragment) and click OK.\n\nNow override a method onCreateDialog and instead of returning super.onCreateDialog return an instance of DatePickerDialog.\n\nNow pass parameters to the constructor of DatePickerDialog which requires context, OnDateSetListener, year, month, dayOfMonth.\n• Pass the getActivity method for the context.\n• For OnDateSetListener typecast the getActivity method to OnDateSetListener.\n• For the year, month, and dayOfMonth create an instance of calendar class and assign the year, month, and dayOfMonth to variables of type int.\n• Pass year and month and dayOfMonth so that when the DatePickerDialog opens it has the current date.\n\nThe complete code for the DatePicker.java class is given below.\n\nNow In the MainActivity.java file, create an object of both TextView and Button and map the components(TextView and Button) with their ids.\n\nImplement OnDateSetListener of DatePickerDialog class and override onDateSet() method. The onDateSet() method will set the date after selection in the tvDate TextView.\n\nIn the onClick() method implement setOnClickListener of btPickDate. Create an instance of DatePicker(our class). Use the show method of the instance and pass getSupportFragmentManager() and a Tag. The complete code for the MainActivity.java file is given below."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/components/pickers",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nAndroid provides controls for the user to pick a time or date as ready-to-use dialogs. These pickers provide controls for selecting each part of the time (hour, minute, AM/PM) or date (month, day, year).\n\nUsing these pickers helps ensure that your users can pick a time or date that is valid, formatted correctly, and adjusted to the user's locale.\n\nWe recommend you use to host each time or date picker. The manages the dialog lifecycle for you and lets you display pickers in different layout configurations, such as in a basic dialog on handsets or as an embedded part of the layout on large screens.\n\nTo display a using , define a fragment class that extends and return a from the fragment's method.\n\nTo define a for a , do the following:\n• Define the method to return an instance of .\n• Implement the interface to receive a callback when the user sets the time.\n\nSee the class for information about the constructor arguments.\n\nNow you just need an event that adds an instance of this fragment to your activity.\n\nAfter you define a like the one in the preceding example, you can display the time picker by creating an instance of the and calling the method.\n\nFor example, here's a button that, when tapped, calls a method to show the dialog:\n\nWhen the user taps this button, the system calls the following method:\n\nThis method calls on a new instance of the defined in the preceding example. The method requires an instance of and a unique tag name for the fragment.\n\nCreating a is like creating a . The difference is the dialog you create for the fragment.\n\nTo display a using , define a fragment class that extends and return a from the fragment's method.\n\nTo define a for a , do the following:\n• Define the method to return an instance of .\n• Implement the interface to receive a callback when the user sets the date.\n\nSee the class for information about the constructor arguments.\n\nYou just need an event that adds an instance of this fragment to your activity.\n\nAfter you define a like the preceding example, you can display the date picker by creating an instance of the and calling .\n\nFor example, here's a button that, when tapped, calls a method to show the dialog:\n\nWhen the user taps this button, the system calls the following method:\n\nThis method calls on a new instance of the defined in the preceding example. The method requires an instance of and a unique tag name for the fragment.\n\nIn 2017, Android introduced the Autofill framework, which lets users save data that can be used to fill out forms in different apps. Pickers can be useful in autofill scenarios by providing a UI that lets users change the value of a field that stores date or time data. For example, in a credit card form, a date picker lets users enter or change the expiration date of their credit card.\n\nBecause pickers are dialogs, they aren't displayed in an activity along with other fields. To display the picker data when the picker isn't visible, you can use another view, such as an , which can display the value when the picker isn't visible.\n\nAn object natively expects autofill data of type . In contrast, autofill services save the data as to create an appropriate representation of it. To solve the inconsistency in types, we recommended that you create a custom view that inherits from and implements the methods required to correctly handle values of type .\n\nTake the following steps to create a subclass of that can handle values of type :\n• Implement the method, which returns an object that represents the date in milliseconds. To create the return object, use the method to generate an object.\n• Implement the method. This method provides the logic to handle the parameter, which is of type . To handle the parameter, create a proper string representation of it, such as . Use the string representation to set the property of your view.\n• Implement functionality that displays a picker when the user wants to edit the date in the custom subclass of . The view updates the property with a string representation of the value that the user selects on the picker.\n\nFor an example of a subclass of that handles values, see the Autofill Framework sample in Java or Kotlin.\n\nTo learn more about proving autofill support for your custom views, see Autofill framework."
    },
    {
        "link": "https://medium.com/@mrizqi070502/quick-and-easy-a-basic-guide-to-implementing-date-picker-in-android-114b36394953",
        "document": "When it comes to developing Android apps that involve dates, implementing a date picker is often a necessary feature. A date picker allows users to select a specific date from a calendar view, making it a user-friendly way to input dates. If you’re new to Android development or simply want to refresh your knowledge on implementing a date picker, this guide is for you. In this blog post, we’ll cover the basics of implementing a date picker in Android. So, let’s get started!\n\nAndroid came up with that can fulfill your need to get a date from a user. Basically, you just have to create the dialog by passing a context, listener, and initial date then show it.\n\nThe listener we used is an interface . By implementing the listener, you can get the year, month, and day that the user selected. Then use it in whatever you want. In this example, I formatted the date using\n\n🧐2 — What If I Want To Customize The Style\n\nWhen you instantiate , you will notice that there are several possible constructors. Some of them have the option to pass the theme id. So, we can just create a new style that has a parent to a Dialog style. Like this code below, its parent is (I tried using a default style like Theme.MaterialComponents.DayNight.DarkActionBar, but it make the dialog not float, fills fullscreen, and the alignment of the date picker is not centered).\n\nThe customization is applied to view and of course, it has xml attributes like you code the view in xml layout. There are a bunch of attributes, you can browse them here.\n\n😲3 — Is There Any Other Date Picker Library?\n\nYes, There is. One I know that commonly used is Material Design. To use it is quite easy.\n\nDeclare the Material Dependency in (Commonly, it’s already added by Android Studio when you create a new project). Make sure the section includes Google's Maven Repository .\n\nNext, construct the using the builder. You can set the title, the initially selected date, positive button text, negative button text, etc.\n\nIf you want to get the selected date after the user clicks the positive button, add a listener to the . You will get the date in the type of . Use any date API you want (I use ) to format the data you got.\n\n😃4 — Can I Set the Minimum and Maximum Date That Can Be Selected?\n\nOf course you can, In Android , set the min and max date by using the object.\n\nIn , you have to create the and you can just set the min and max date in level of month, not date like previous example.\n\n😀5 — Is It Possible to Pick Range of Date? How?\n\nIf you want to pick a range of dates, you can use . It has component. The instantiation process is quite similar to date picker. The difference is, when you set the initially selected date, you have to pass a Pair of dates (start date and end date). And, in the positive listener, you will have a pair of dates (start and end date)."
    },
    {
        "link": "https://abhiandroid.com/ui/datepicker",
        "document": "DatePicker Tutorial With Example In Android Studio\n\nIn Android, DatePicker is a widget used to select a date. It allows to select date by day, month and year in your custom UI (user interface). If we need to show this view as a dialog then we have to use a DatePickerDialog class. For selecting time Android also provides timepicker to select time.\n\nLet’s discuss some common methods of a datepicker which are used to configure a DatePicker in our application.\n\nThis method is used to set whether the spinner of the date picker in shown or not. In this method you have to set a Boolean value either true or false. True indicates spinner is shown, false value indicates spinner is not shown. Default value for this function is true.\n\nBelow we show the use of setSpinnerShown() function by setting false value.\n\nThis method is used to get the selected day of the month from a date picker. This method returns an integer value.\n\nBelow we get the selected day of the month from a date picker.\n\nThis method is used to get the selected month from a date picker. This method returns an integer value.\n\nBelow we get the selected month from a date picker.\n\nThis method is used to get the selected year from a date picker. This method returns an integer value.\n\nBelow code is used to get the selected year from a date picker.\n\nThis method is used to get the first day of the week. This method returns an integer value.\n\nBelow code is used to get the first day of the week.\n\nNow let’s we discuss some important attributes that helps us to configure a DatePicker in your XML file (layout).\n\nid is an attribute used to uniquely identify a date picker.\n\nThis attribute is used to set the Date Picker in mode either spinner or calendar. Default mode is calendar but this mode is not used after api level 21, so from api level 21 you have to set the mode to spinner.\n\nBelow is an example code in which we set the mode to spinner for a date picker.\n\nBelow we set the red color for the background of a date picker.\n\npadding attribute is used to set the padding from left, right, top or bottom for a date picker.\n• paddingRight: set the padding from the right side of the date picker.\n• paddingLeft: set the padding from the left side of the date picker.\n• paddingTop: set the padding from the top side of the date picker.\n• paddingBottom: set the padding from the bottom side of the date picker.\n• Padding: set the padding from the all side’s of the date picker.\n\nBelow code of padding attribute set the 40dp padding from all the side’s of the date picker.\n\nIn the first example of DatePicker we show simple date picker and a Button in our xml file and perform click event on button. So whenever a user clicks on a button the day of the month, month and year will be displayed by using a Toast. Below is the final output, download code and step by step explanation:\n\nOpen res -> layout -> activity_main.xml (or) main.xml and add following code:\n\nIn this step we open an xml file and add the code for displaying a datepicker with spinner mode and a button for getting the date from the datepicker.\n\nIn this step we open MainActivity where we add the code to initiate the datepicker & a button and then perform onClickListener() event on button so whenever a user clicks on the button the day of the month, month and year will be displayed by using a Toast.\n\nNow run the App in AVD and you will see datepicker will appear on the screen. Choose the date, month & year and click submit. The date you selected will appear on Screen.\n\nExample of DatePickerDialog in Android Studio\n\nIn the second example we show the use of date picker dialog in our application, for that we display edittext in our xml file and perform a onClickListener() event on it. So whenever a user click on it date picker dialog is appeared and from there user can adjust the date and after selecting the date it will be displayed in the edit text. Below is the final output, download code and step by step tutorial:\n\nOpen res – > layout – > activity_main.xml (or) main.xml and add following code:\n\nIn this step we open xml file and add the code for displaying edittext which will be used to display the date of datepicker.\n\nIn this step we open MainActivity where we add the code to initiate the edittext to display date(day of month, month and year) from a date picker and perform click event on edit text so whenever a user clicks on edit text a date picker dialog is appeared from there user can set the date by choosing day of month , month and year , after setting the date will be displayed in the edit text.\n\nNow run the App in Emulator and fill the date in EditText option."
    }
]