[
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    },
    {
        "link": "https://docs.python.org/3/tutorial/index.html",
        "document": "Python is an easy to learn, powerful programming language. It has efficient high-level data structures and a simple but effective approach to object-oriented programming. Python’s elegant syntax and dynamic typing, together with its interpreted nature, make it an ideal language for scripting and rapid application development in many areas on most platforms.\n\nThe Python interpreter and the extensive standard library are freely available in source or binary form for all major platforms from the Python web site, https://www.python.org/, and may be freely distributed. The same site also contains distributions of and pointers to many free third party Python modules, programs and tools, and additional documentation.\n\nThe Python interpreter is easily extended with new functions and data types implemented in C or C++ (or other languages callable from C). Python is also suitable as an extension language for customizable applications.\n\nThis tutorial introduces the reader informally to the basic concepts and features of the Python language and system. It helps to have a Python interpreter handy for hands-on experience, but all examples are self-contained, so the tutorial can be read off-line as well.\n\nFor a description of standard objects and modules, see The Python Standard Library. The Python Language Reference gives a more formal definition of the language. To write extensions in C or C++, read Extending and Embedding the Python Interpreter and Python/C API Reference Manual. There are also several books covering Python in depth.\n\nThis tutorial does not attempt to be comprehensive and cover every single feature, or even every commonly used feature. Instead, it introduces many of Python’s most noteworthy features, and will give you a good idea of the language’s flavor and style. After reading it, you will be able to read and write Python modules and programs, and you will be ready to learn more about the various Python library modules described in The Python Standard Library.\n\nThe Glossary is also worth going through."
    },
    {
        "link": "https://docs.python.org",
        "document": "What's new in Python 3.13?\n\n Or all \"What's new\" documents since Python 2.0\n\nTutorial\n\n Start here: a tour of Python's syntax and features\n\nPython setup and usage\n\n How to install, configure, and use Python"
    },
    {
        "link": "https://realpython.com/documenting-python-code",
        "document": "Welcome to your complete guide to documenting Python code. Whether you’re documenting a small script or a large project, whether you’re a beginner or a seasoned Pythonista, this guide will cover everything you need to know.\n\nWe’ve broken up this tutorial into four major sections:\n• Why Documenting Your Code Is So Important: An introduction to documentation and its importance\n• Commenting vs Documenting Code: An overview of the major differences between commenting and documenting, as well as the appropriate times and ways to use commenting\n• Documenting Your Python Code Base Using Docstrings: A deep dive into docstrings for classes, class methods, functions, modules, packages, and scripts, as well as what should be found within each one\n• Documenting Your Python Projects: The necessary elements and what they should contain for your Python projects\n\nFeel free to read through this tutorial from beginning to end or jump to a section you’re interested in. It was designed to work both ways.\n\nWhy Documenting Your Code Is So Important Hopefully, if you’re reading this tutorial, you already know the importance of documenting your code. But if not, then let me quote something Guido mentioned to me at a recent PyCon: “Code is more often read than written.” When you write code, you write it for two primary audiences: your users and your developers (including yourself). Both audiences are equally important. If you’re like me, you’ve probably opened up old codebases and wondered to yourself, “What in the world was I thinking?” If you’re having a problem reading your own code, imagine what your users or other developers are experiencing when they’re trying to use or contribute to your code. Conversely, I’m sure you’ve run into a situation where you wanted to do something in Python and found what looks like a great library that can get the job done. However, when you start using the library, you look for examples, write-ups, or even official documentation on how to do something specific and can’t immediately find the solution. After searching, you come to realize that the documentation is lacking or even worse, missing entirely. This is a frustrating feeling that deters you from using the library, no matter how great or efficient the code is. Daniele Procida summarized this situation best: “It doesn’t matter how good your software is, because if the documentation is not good enough, people will not use it.“ In this guide, you’ll learn from the ground up how to properly document your Python code from the smallest of scripts to the largest of Python projects to help prevent your users from ever feeling too frustrated to use or contribute to your project.\n\nBefore we can go into how to document your Python code, we need to distinguish documenting from commenting. In general, commenting is describing your code to/for developers. The intended main audience is the maintainers and developers of the Python code. In conjunction with well-written code, comments help to guide the reader to better understand your code and its purpose and design: “Code tells you how; Comments tell you why.” Documenting code is describing its use and functionality to your users. While it may be helpful in the development process, the main intended audience is the users. The following section describes how and when to comment your code. Comments are created in Python using the pound sign ( ) and should be brief statements no longer than a few sentences. Here’s a simple example: According to PEP 8, comments should have a maximum length of 72 characters. This is true even if your project changes the max line length to be greater than the recommended 80 characters. If a comment is going to be greater than the comment char limit, using multiple lines for the comment is appropriate: # A very long statement that just goes on and on and on and on and # never ends until after it's reached the 80 char limit\n• Planning and Reviewing: When you are developing new portions of your code, it may be appropriate to first use comments as a way of planning or outlining that section of code. Remember to remove these comments once the actual coding has been implemented and reviewed/tested:\n• Code Description: Comments can be used to explain the intent of specific sections of code:\n• Algorithmic Description: When algorithms are used, especially complicated ones, it can be useful to explain how the algorithm works or how it’s implemented within your code. It may also be appropriate to describe why a specific algorithm was selected over another.\n• Tagging: The use of tagging can be used to label specific sections of code where known issues or areas of improvement are located. Some examples are: , , and . # TODO: Add condition for when val is None Comments to your code should be kept brief and focused. Avoid using long comments when possible. Additionally, you should use the following four essential rules as suggested by Jeff Atwood:\n• Keep comments as close to the code being described as possible. Comments that aren’t near their describing code are frustrating to the reader and easily missed when updates are made.\n• Don’t use complex formatting (such as tables or ASCII figures). Complex formatting leads to distracting content and can be difficult to maintain over time.\n• Don’t include redundant information. Assume the reader of the code has a basic understanding of programming principles and language syntax.\n• Design your code to comment itself. The easiest way to understand code is by reading it. When you design your code using clear, easy-to-understand concepts, the reader will be able to quickly conceptualize your intent. Remember that comments are designed for the reader, including yourself, to help guide them in understanding the purpose and design of the software. Type hinting was added to Python 3.5 and is an additional form to help the readers of your code. In fact, it takes Jeff’s fourth suggestion from above to the next level. It allows the developer to design and explain portions of their code without commenting. Here’s a quick example: From examining the type hinting, you can immediately tell that the function expects the input to be of a type , or string. You can also tell that the expected output of the function will be of a type , or string, as well. While type hinting helps reduce comments, take into consideration that doing so may also make extra work when you are creating or updating your project documentation. You can learn more about type hinting and type checking from this video created by Dan Bader.\n\nNow that we’ve learned about commenting, let’s take a deep dive into documenting a Python code base. In this section, you’ll learn about docstrings and how to use them for documentation. This section is further divided into the following sub-sections:\n• Docstrings Background: A background on how docstrings work internally within Python\n• Docstring Types: The various docstring “types” (function, class, class method, module, package, and script)\n• Docstring Formats: The different docstring “formats” (Google, NumPy/SciPy, reStructuredText, and Epytext) Documenting your Python code is all centered on docstrings. These are built-in strings that, when configured correctly, can help your users and yourself with your project’s documentation. Along with docstrings, Python also has the built-in function that prints out the objects docstring to the console. Here’s a quick example: Help on class str in module builtins: | Create a new string object from the given object. If encoding or | errors are specified, then the object must expose a data buffer | that will be decoded using the given encoding and error handler. | Otherwise, returns the result of object.__str__() (if defined) How is this output generated? Since everything in Python is an object, you can examine the directory of the object using the command. Let’s do that and see what find: Within that directory output, there’s an interesting property, . If you examine that property, you’ll discover this: Create a new string object from the given object. If encoding or errors are specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) Voilà! You’ve found where docstrings are stored within the object. This means that you can directly manipulate that property. However, there are restrictions for builtins: \"I'm a little string doc! Short and stout; here is my input and print me for my out\" File , line , in : Any other custom object can be manipulated: , is it me you're looking for?\" \"A simple function that says hello... Richie style\" Help on function say_hello in module __main__: A simple function that says hello... Richie style Python has one more feature that simplifies docstring creation. Instead of directly manipulating the property, the strategic placement of the string literal directly below the object will automatically set the value. Here’s what happens with the same example as above: \"\"\"A simple function that says hello... Richie style\"\"\" , is it me you're looking for?\" Help on function say_hello in module __main__: A simple function that says hello... Richie style There you go! Now you understand the background of docstrings. Now it’s time to learn about the different types of docstrings and what information they should contain. Docstring conventions are described within PEP 257. Their purpose is to provide your users with a brief overview of the object. They should be kept concise enough to be easy to maintain but still be elaborate enough for new users to understand their purpose and how to use the documented object. In all cases, the docstrings should use the triple-double quote ( ) string format. This should be done whether the docstring is multi-lined or not. At a bare minimum, a docstring should be a quick summary of whatever is it you’re describing and should be contained within a single line: \"\"\"This is a quick summary line used as a description of the object.\"\"\" Multi-lined docstrings are used to further elaborate on the object beyond the summary. All multi-lined docstrings have the following parts:\n• Any further elaboration for the docstring \"\"\"This is the summary line This is the further elaboration of the docstring. Within this section, you can elaborate further on details as appropriate for the situation. Notice that the summary and the elaboration is separated by a blank new # Notice the blank line above. Code should continue on this line. All docstrings should have the same max character length as comments (72 characters). Docstrings can be further broken up into three major categories: Class Docstrings are created for the class itself, as well as any class methods. The docstrings are placed immediately following the class or class method indented by one level: Class docstrings should contain the following information:\n• A brief summary of its purpose and behavior\n• Any public methods, along with a brief description\n• Anything related to the interface for subclassers, if the class is intended to be subclassed The class constructor parameters should be documented within the class method docstring. Individual methods should be documented using their individual docstrings. Class method docstrings should contain the following:\n• A brief description of what the method is and what it’s used for\n• Any arguments (both required and optional) that are passed including keyword arguments\n• Label any arguments that are considered optional or have a default value\n• Any side effects that occur when executing the method\n• Any exceptions that are raised\n• Any restrictions on when the method can be called Let’s take a simple example of a data class that represents an Animal. This class will contain a few class properties, instance properties, a , and a single instance method: A class used to represent an Animal a formatted string to print out what the animal says the sound that the animal makes the number of legs the animal has (default 4) Prints the animals name and what sound it makes The number of legs the animal (default is 4) \"\"\"Prints what the animals name is and what sound it makes. If the argument `sound` isn't passed in, the default Animal The sound the animal makes (default is None) If no sound is set for the animal or passed in as a Package docstrings should be placed at the top of the package’s file. This docstring should list the modules and sub-packages that are exported by the package. Module docstrings are similar to class docstrings. Instead of classes and class methods being documented, it’s now the module and any functions found within. Module docstrings are placed at the top of the file even before any imports. Module docstrings should include the following:\n• A brief description of the module and its purpose\n• A list of any classes, exception, functions, and any other objects exported by the module The docstring for a module function should include the same items as a class method:\n• A brief description of what the function is and what it’s used for\n• Any arguments (both required and optional) that are passed including keyword arguments\n• Label any arguments that are considered optional\n• Any side effects that occur when executing the function\n• Any exceptions that are raised\n• Any restrictions on when the function can be called Scripts are considered to be single file executables run from the console. Docstrings for scripts are placed at the top of the file and should be documented well enough for users to be able to have a sufficient understanding of how to use the script. It should be usable for its “usage” message, when the user incorrectly passes in a parameter or uses the option. If you use , then you can omit parameter-specific documentation, assuming it’s correctly been documented within the parameter of the function. It is recommended to use the for the parameter within ’s constructor. Check out our tutorial on Command-Line Parsing Libraries for more details on how to use and other common command line parsers. Finally, any custom or third-party imports should be listed within the docstrings to allow users to know which packages may be required for running the script. Here’s an example of a script that is used to simply print out the column headers of a spreadsheet: This script allows the user to print to the console all columns in the spreadsheet. It is assumed that the first row of the spreadsheet is the This tool accepts comma separated value files (.csv) as well as excel This script requires that `pandas` be installed within the Python environment you are running this script in. This file can also be imported as a module and contains the following * get_spreadsheet_cols - returns the column headers of the file * main - the main function of the script \"\"\"Gets and prints the spreadsheet's header columns The file location of the spreadsheet A flag used to print the columns to the console (default is a list of strings used that are the header columns \"The spreadsheet file to pring the columns of\" You may have noticed that, throughout the examples given in this tutorial, there has been specific formatting with common elements: , , and . There are specific docstrings formats that can be used to help docstring parsers and users have a familiar and known format. The formatting used within the examples in this tutorial are NumPy/SciPy-style docstrings. Some of the most common formats are the following: Official Python documentation standard; Not beginner friendly but feature rich The selection of the docstring format is up to you, but you should stick with the same format throughout your document/project. The following are examples of each type to give you an idea of how each documentation format looks. \"\"\"Gets and prints the spreadsheet's header columns file_loc (str): The file location of the spreadsheet print_cols (bool): A flag used to print the columns to the console \"\"\"Gets and prints the spreadsheet's header columns :param file_loc: The file location of the spreadsheet :param print_cols: A flag used to print the columns to the console \"\"\"Gets and prints the spreadsheet's header columns The file location of the spreadsheet A flag used to print the columns to the console (default is False) \"\"\"Gets and prints the spreadsheet's header columns @param file_loc: The file location of the spreadsheet @param print_cols: A flag used to print the columns to the console"
    },
    {
        "link": "https://w3schools.com/python/python_functions.asp",
        "document": "A function is a block of code which only runs when it is called.\n\nYou can pass data, known as parameters, into a function.\n\nIn Python a function is defined using the def keyword:\n\nTo call a function, use the function name followed by parenthesis:\n\nInformation can be passed into functions as arguments.\n\nArguments are specified after the function name, inside the parentheses. You can add as many arguments as you want, just separate them with a comma.\n\nThe following example has a function with one argument (fname). When the function is called, we pass along a first name, which is used inside the function to print the full name:\n\nThe terms parameter and argument can be used for the same thing: information that are passed into a function.\n\nBy default, a function must be called with the correct number of arguments. Meaning that if your function expects 2 arguments, you have to call the function with 2 arguments, not more, and not less.\n\nIf you try to call the function with 1 or 3 arguments, you will get an error:\n\nIf you do not know how many arguments that will be passed into your function, add a before the parameter name in the function definition.\n\nThis way the function will receive a tuple of arguments, and can access the items accordingly:\n\nYou can also send arguments with the key = value syntax.\n\nThis way the order of the arguments does not matter.\n\nIf you do not know how many keyword arguments that will be passed into your function, add two asterisk: before the parameter name in the function definition.\n\nThis way the function will receive a dictionary of arguments, and can access the items accordingly:\n\nThe following example shows how to use a default parameter value.\n\nIf we call the function without argument, it uses the default value:\n\nYou can send any data types of argument to a function (string, number, list, dictionary etc.), and it will be treated as the same data type inside the function.\n\nE.g. if you send a List as an argument, it will still be a List when it reaches the function:\n\nTo let a function return a value, use the statement:\n\ndefinitions cannot be empty, but if you for some reason have a definition with no content, put in the statement to avoid getting an error.\n\nYou can specify that a function can have ONLY positional arguments, or ONLY keyword arguments.\n\nTo specify that a function can have only positional arguments, add after the arguments:\n\nWithout the you are actually allowed to use keyword arguments even if the function expects positional arguments:\n\nBut when adding the you will get an error if you try to send a keyword argument:\n\nTo specify that a function can have only keyword arguments, add before the arguments:\n\nWithout the you are allowed to use positionale arguments even if the function expects keyword arguments:\n\nBut with the you will get an error if you try to send a positional argument:\n\nYou can combine the two argument types in the same function.\n\nAny argument before the are positional-only, and any argument after the are keyword-only.\n\nPython also accepts function recursion, which means a defined function can call itself.\n\nRecursion is a common mathematical and programming concept. It means that a function calls itself. This has the benefit of meaning that you can loop through data to reach a result.\n\nThe developer should be very careful with recursion as it can be quite easy to slip into writing a function which never terminates, or one that uses excess amounts of memory or processor power. However, when written correctly recursion can be a very efficient and mathematically-elegant approach to programming.\n\nIn this example, tri_recursion() is a function that we have defined to call itself (\"recurse\"). We use the k variable as the data, which decrements (-1) every time we recurse. The recursion ends when the condition is not greater than 0 (i.e. when it is 0).\n\nTo a new developer it can take some time to work out how exactly this works, best way to find out is by testing and modifying it."
    },
    {
        "link": "https://stackoverflow.com/questions/22287100/how-to-create-patterns-in-python-using-nested-loops",
        "document": "I am trying to create this pattern in Python:\n\nI have to use a nested loop, and this is my program so far:\n\nThe problem is the first column doesn't show up, so this is what is displayed when I run it:\n\nThis is the modified program:\n\nbut the result is:\n\nHow do I get them on the same row?"
    },
    {
        "link": "https://mardiyyah.medium.com/creating-patterns-in-python-learnpythonthroughprojects-series-7-3e78db1b3a04",
        "document": "This project is all about creating some fun shapes in Python using nested for loops and conditional if-else statements. In this series, we will be creating several patterns, then I will share links to resources and source codes for further exploration.\n\nThe first pattern is a “Multiplication Table”. Let’s dive in!\n\nAs always, create a new python file, save as “multiplication.py”\n• Define a variable ‘num’. Use the input function and the int function.\n• Create an iterative condition using a “for loop”. Use the range function for a start and end at 1 and 13.\n• Print the value of ‘i’ alongside iterative.\n\nA ‘num’ variable is defined to accept input from a user. The ‘int’ function is used to enclose the ‘input’ function here such that whatever input is entered by the user, is converted to an integer so that arithmetic operations(in this case multiplication) can be carried out effectively.\n\nThe “for loop” is used here for a finite iterative process, not an infinite program i. the program starts and ends within the limit set by the range function. Also, take note that the ‘X’ here does not represent multiplication, it is used as a string. You will understand better when you see the code working. The single ‘=’ sign there is also a string because we enclosed it in quotes. You remember that’s how Python recognizes strings right? Finally, num*i, says whatever number is entered, keep multiplying by ‘i’ until, ‘i’ gets to 12, Then stop.\n\nSo the range function works in such a way that it generates a set of output or numbers, starting at a defined start point(usually zero by default unless otherwise changed) and ends at a step behind the endpoint. So in this example, the start point was 1, and the endpoint although set at 13, ended at 12(a step behind). More explanation as we create more patterns.\n\nii. Set a start and endpoint for the shape as desired.\n\ni. Use range for the variable defined in the first loop.\n\nSo the logic here is as follows:\n• The first ‘for’ loop defines a variable(pattern)(you can call it whatever you choose to, i, k, j,p, etc). Then using the range function, a start, and an endpoint for the number of (*) to print was defined(i.e 1 -9).\n• The nested ‘for’ loop defines a variable(‘stars’), again it can be called whatever, I used patterns and stars here just for ease of understanding.i.e the first loop is where the pattern and the length of the pattern were defined, the second loop is for the stars, i.e what is to be printed in the patterns. You can simply see these as rows and columns and the loops define what is to be in each row and columns. So while the first loop was used to initiate the rows and how many should be printed, the second loop represents the columns, what is to be printed in the columns. Did you notice here that the range function only had one value? Automatically, this is assumed to be the endpoint(the value for pattern), and the default start point is used here(0).\n• The print statement was defined, stating what is to printed in the shapes, and a parameter(end= “”) was included. What this parameter simply does is that, although the stars are meant to be printed in separate lines and not all in the same line, we want it printed in such a way that a pattern is created. This was used to indicate the presence of an empty string. By default, in the print statement, this parameter returns a new line. However, we clearly defined that for every iteration, the output should all be in the same line. To understand the function of this better, go back to the program and eliminate this parameter, run, and see the difference in output.\n\nDid you see that? Definitely not what we wanted right.\n\nThe Pseudocode is the same as above. The only difference here is adding a reverse step to the range function such that the printed shape is the reverse of what was printed previously. Let’s see how it works:\n\nSo the code is the same as what was used for the left pyramid above, the difference here is changing the start point(which indicates the top/base of the same), the endpoint(which is always a step behind, hence it was set as 0, meaning stop at 1 here), finally adding a reverse point(-1)- which indicates the subtraction of 1, each time the loop runs, from the start point till it gets to the endpoint. Just as can be seen in the same(10,9,8,7,6……1).\n\nSo for this pattern, we will use the combination of a nested for loop and conditional(if-else) statements.\n• Create a for loop to display six lines of rows for stars.\n• Initiate a second for loop to display seven columns to be used in the heart shape.\n• Use an “if” condition to determine where stars will be printed. Use logical ‘and’ and ‘or’.\n• Use an ‘else’ statement to print empty strings where stars will not be printed.\n\nSo the ideal thing to do here is to draw out the shape in a piece of paper. Coding works with sequence and logic control, to be able to translate the desired output into proper coding language, first, picture the problem, write it out, draw out a plan, understand how the desired results should be, develop a step by step plan for it, then translate into code. This just makes it easier, and most times with fewer bugs.\n\nHere, the first ‘for loop’ defines the length of the shape(in rows), and the second ‘for loop’ defines the length of the columns i.e the width of the shape. Take a look at the code output again, divide the shape into lines/grids. Now take a look at the first line, in reality, we have just 4 stars printed there, the number of columns is 7, so how did that happen? The ‘if’ statement was used to initiate some set of conditions for the top part of the shape(which looks like two separate mini triangles), and the bottom part(which has the shape of a larger triangle), separately. Take a close look at the ‘if’ statement and the conditions placed inside. The first condition says “ if i == 0 and j%3!=0” . Let’s break that down.\n\nDo you remember that the logical operators are used to link two or more conditions together? Recall that the logical ‘and’ operator checks that both conditions are true i.e both conditions must return True for it to be valid. So ‘ i’ here represents the row and this code simply says, where we have the first row(index position 0), and the ‘column modulus division 3’ is not equal to 0(i.e the remainder from dividing the column number by 3 is not equal to zero. So at column index position 0, no star is printed(0%3=0), whereas at index position 1 and 2 respectively a star is printed(1%3=1, 2%3=2). Same for index positions 3 and 6(3%3=0, 6%3=0), index positions 4 and 5 respectively(4%3=1, 5%3=2). , can display stars as a horizontal line of the top two lines (four-star and three-star) of heart shape.\n\nThe second condition in the if statement (i==1 and j%3==0), deals with the bottom part of the mini triangles at the top of the shape. So at row 1, and where modulus division between ‘column position and 3 == 0’, a star is printed. Simply the opposite of the first condition.\n\nFinally, the last two conditions are for the bigger upside down triangle which forms the bottom shape ((i-j==2) or (i+j==8)). So where column index position subtracted from the row index position equals 2, the left side of the triangle is printed, and where column index position added to the row index position equals 8, the right side of the triangle is printed. You might want to ask why the mix of the ‘and’ and ‘ or’ logical operators here. So while the ‘and operator’ matches two conditions we want to work simultaneously, the ‘or’ is used in such a way that we have a condition that defines how the shape will be printed for every line/row. The first condition for topmost part of the shape(the sharp edges), the second condition for the bottom part of the first two mini triangles at the top, also defining the sharp steep ‘v-shape’ for the heart, and the last two conditions for the bottom-most part of the shape, which looks like and upperside down triangle.\n\nGreat! This brings us to the end of another awesome project. I encourage you to explore further on how to nest loops and create more exciting patterns. Find the link to the repository for the codes used below. The programs can be identified in the repository with titles: “multiplication.py, leftpyramid.py, reversepyramid.py, heart.py”\n\nThank you for reading!"
    },
    {
        "link": "https://stackoverflow.com/questions/46802371/python-using-nested-loops-to-create-a-pattern",
        "document": "Using python I am attempting to use nested loops to create this pattern:\n\nMy code so far has many issues and doesn't work as intended here it is so far\n\nCan you tell me what should I do?"
    },
    {
        "link": "https://pynative.com/print-pattern-python-examples",
        "document": "This Python lesson includes over 35+ coding programs for printing Numbers, Pyramids, Stars, triangles, Diamonds, and alphabet patterns, ensuring you gain hands-on experience and confidence in your Python skills.\n\nPrinting numbers, stars (asterisk), or other characters in different shapes (patterns) is a frequently asked interview question for freshers. Creating these number and pyramid patterns allows you to test your logical ability and coding skills.\n\nIn this lesson, you’ll learn how to print patterns using the for loop, while loop, and the range() function.\n\nThis article teaches you how to print the following patterns in Python.\n\nI have created various programs that print different styles of number patterns. Let’s see them one by one. Let’s print the following number pattern using a for loop.\n\nIn this number pattern, we display a single digit on the first row, two digits on the second row, and three digits on the third row. This process will repeat until the number of rows is reached.\n• The count of numbers on each row is equal to the current row number.\n• Also, each number is separated by space.\n• We used a nested loop to print the pattern\n\nLet’s see how to print the following half-pyramid pattern of numbers\n\nNote: In each row, every next number is incremented by 1.\n\nAn inverted pyramid is a downward pattern where numbers get reduced in each iteration, and on the last row, it shows only one number. Use reverse for loop to print this pattern.\n\nInverted Pyramid pattern with the same digit\n\nLet’s see how to use the while loop to print the number pattern.\n\nLet’s see how to display the pattern of descending order of numbers\n\nThis pattern is also called as a inverted pyramid of descending numbers.\n\nNote: It is a downward increment pattern where numbers get increased in each iteration. At each row, the amount of number is equal to the current row number.\n\nLet’s see how to print the right-angled triangle pattern of numbers\n\nTo build the pascal triangle, start with “1” at the top, then continue placing numbers below it in a triangular pattern.\n\nEach number is the numbers directly above it added together.\n\nThis section will see how to print pyramid and Star (asterisk) patterns in Python. Here we will print the following pyramid pattern with Star (asterisk).\n\n\n\nThis pattern is also known as a right angle triangle pyramid.\n\nThis pattern is also called as mirrored right triangle\n\nNote: We need to use the reverse nested loop to print the downward pyramid pattern of stars\n\nLet’s see how to print reversed pyramid pattern in Python.\n\nIn this pattern, we need to use two nested loops.\n\nWe also call this pattern as a right pascal’s triangle.\n\nTo print this pattern we need to use two set of three while loops.\n\nIn Python, there are ASCII values for each letter. To print the patterns of letters and alphabets, we need to convert them to their ASCII values.\n• Iterate a loop and in nested loop use the function to convert ASCII number to its equivalent letter.\n\nLet’ see now how to print alphabets and letters patterns in Python.\n\nThis pattern is knows as right-angled pattern with characters.\n\nPattern to display letter of the word\n\nLet’s see how to print word ‘Python’ in Pattern: –\n\nLet’s see some more miscellaneous patterns\n\nNote: In each column, every number is double it’s the preceding number.\n\nPyramid of numbers less than 10\n\nPyramid of numbers up to 10\n\nPattern with a combination of numbers and stars\n\nAlso, see how to calculate the sum and average in Python.\n\nIf you don’t find the pattern you are looking for, let me know by leaving a comment and questions below."
    },
    {
        "link": "https://geeksforgeeks.org/nested-for-loop-to-print-a-pattern",
        "document": "A nested for loop in R is used when we want to iterate through multiple dimensions, such as rows and columns of a matrix, or for creating patterns. we will discuss how to print multiplication tables up to a certain number with its working example in the R Programming Language using R for loop conditions. Everyone found an easy way for pattern printing in other programming languages. But it’s a tough task using the R language\n• None Start the first loop for the number of lines\n• None Start the second loop for the item to be displayed\n• None Increment the second loop until a condition is reached\n• None Increment the first loop until the condition is true\n• None Initialize n=5, indicating the number of rows in the pattern.\n• None The outer loop iterates over the range of i from 1 to n (inclusive), controlling the number of rows in the pattern.\n• None Inside the outer loop, the inner loop iterates over the range of j from 1 to the value of i (inclusive). This loop controls the number of asterisks to be printed in each row.\n• None Inside the inner loop, cat(“* “) prints an asterisk followed by a space, generating the pattern elements.\n• None After the inner loop, cat(“\n\n”) is used to print a newline character, moving to the next line after printing the pattern for each row.\n• None Initialize n=4, indicating the number of rows in the pattern.\n• None The outer loop iterates over the range of i from 1 to n (inclusive), controlling the number of rows in the pattern.\n• None Inside the outer loop, the inner loop iterates over the range of j from 1 to the value of i (inclusive). This loop controls the number of asterisks to be printed in each row.\n• None Inside the inner loop, cat(“* “) prints an asterisk followed by a space, generating the pattern elements.\n• None After the inner loop, cat(“\n\n”) is used to print a newline character, moving to the next line after printing the pattern for each row.\n• None to store the stars for each row.\n• None : Initializes the column counter to 5 (this represents the number of stars in the first row).\n• None : This is the outer\n• None : This is the inner loop that iterates through the stars within a row.\n• None vector to prepare for the next row.\n• None : Increments the row counter for the next iteration.\n• None : Reduce the number of stars for the next row."
    }
]