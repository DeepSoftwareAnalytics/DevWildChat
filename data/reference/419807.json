[
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    },
    {
        "link": "https://docs.python.org/3/tutorial/inputoutput.html",
        "document": "There are several ways to present the output of a program; data can be printed in a human-readable form, or written to a file for future use. This chapter will discuss some of the possibilities.\n\nSo far we’ve encountered two ways of writing values: expression statements and the function. (A third way is using the method of file objects; the standard output file can be referenced as . See the Library Reference for more information on this.) Often you’ll want more control over the formatting of your output than simply printing space-separated values. There are several ways to format output.\n• None To use formatted string literals, begin a string with or before the opening quotation mark or triple quotation mark. Inside this string, you can write a Python expression between and characters that can refer to variables or literal values.\n• None The method of strings requires more manual effort. You’ll still use and to mark where a variable will be substituted and can provide detailed formatting directives, but you’ll also need to provide the information to be formatted. In the following code block there are two examples of how to format variables: Notice how the are padded with spaces and a negative sign only for negative numbers. The example also prints multiplied by 100, with 2 decimal places and followed by a percent sign (see Format Specification Mini-Language for details).\n• None Finally, you can do all the string handling yourself by using string slicing and concatenation operations to create any layout you can imagine. The string type has some methods that perform useful operations for padding strings to a given column width. When you don’t need fancy output but just want a quick display of some variables for debugging purposes, you can convert any value to a string with the or functions. The function is meant to return representations of values which are fairly human-readable, while is meant to generate representations which can be read by the interpreter (or will force a if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, will return the same value as . Many values, such as numbers or structures like lists and dictionaries, have the same representation using either function. Strings, in particular, have two distinct representations. The value of x is 32.5, and y is 40000... # The repr() of a string adds string quotes and backslashes: # The argument to repr() may be any Python object: The module contains a class that offers yet another way to substitute values into strings, using placeholders like and replacing them with values from a dictionary, but offers much less control of the formatting. Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside a string by prefixing the string with or and writing expressions as . An optional format specifier can follow the expression. This allows greater control over how the value is formatted. The following example rounds pi to three places after the decimal: 'The value of pi is approximately The value of pi is approximately 3.142. Passing an integer after the will cause that field to be a minimum number of characters wide. This is useful for making columns line up. Other modifiers can be used to convert the value before it is formatted. applies , applies , and applies : 'My hovercraft is full of My hovercraft is full of eels. 'My hovercraft is full of My hovercraft is full of 'eels'. The specifier can be used to expand an expression to the text of the expression, an equal sign, then the representation of the evaluated expression: See self-documenting expressions for more information on the specifier. For a reference on these format specifications, see the reference guide for the Format Specification Mini-Language. Basic usage of the method looks like this: We are the knights who say \"Ni!\" The brackets and characters within them (called format fields) are replaced with the objects passed into the method. A number in the brackets can be used to refer to the position of the object passed into the method. If keyword arguments are used in the method, their values are referred to by using the name of the argument. Positional and keyword arguments can be arbitrarily combined: The story of Bill, Manfred, and Georg. If you have a really long format string that you don’t want to split up, it would be nice if you could reference the variables to be formatted by name instead of by position. This can be done by simply passing the dict and using square brackets to access the keys. This could also be done by passing the dictionary as keyword arguments with the notation. This is particularly useful in combination with the built-in function , which returns a dictionary containing all local variables: __name__: __main__; __doc__: None; __package__: None; __loader__: ... As an example, the following lines produce a tidily aligned set of columns giving integers and their squares and cubes: For a complete overview of string formatting with , see Format String Syntax. Here’s the same table of squares and cubes, formatted manually: # Note use of 'end' on previous line The method of string objects right-justifies a string in a field of a given width by padding it with spaces on the left. There are similar methods and . These methods do not write anything, they just return a new string. If the input string is too long, they don’t truncate it, but return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative, which would be lying about a value. (If you really want truncation you can always add a slice operation, as in .) There is another method, , which pads a numeric string on the left with zeros. It understands about plus and minus signs: The % operator (modulo) can also be used for string formatting. Given (where format is a string), conversion specifications in format are replaced with zero or more elements of values. This operation is commonly known as string interpolation. For example: 'The value of pi is approximately The value of pi is approximately 3.142. More information can be found in the printf-style String Formatting section.\n\nreturns a file object, and is most commonly used with two positional arguments and one keyword argument: The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be when the file will only be read, for only writing (an existing file with the same name will be erased), and opens the file for appending; any data written to the file is automatically added to the end. opens the file for both reading and writing. The mode argument is optional; will be assumed if it’s omitted. Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see ). Because UTF-8 is the modern de-facto standard, is recommended unless you know that you need to use a different encoding. Appending a to the mode opens the file in binary mode. Binary mode data is read and written as objects. You can not specify encoding when opening file in binary mode. In text mode, the default when reading is to convert platform-specific line endings ( on Unix, on Windows) to just . When writing in text mode, the default is to convert occurrences of back to platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will corrupt binary data like that in or files. Be very careful to use binary mode when reading and writing such files. It is good practice to use the keyword when dealing with file objects. The advantage is that the file is properly closed after its suite finishes, even if an exception is raised at some point. Using is also much shorter than writing equivalent - blocks: # We can check that the file has been automatically closed. If you’re not using the keyword, then you should call to close the file and immediately free up any system resources used by it. Calling without using the keyword or calling might result in the arguments of not being completely written to the disk, even if the program exits successfully. After a file object is closed, either by a statement or by calling , attempts to use the file object will automatically fail. The rest of the examples in this section will assume that a file object called has already been created. To read a file’s contents, call , which reads some quantity of data and returns it as a string (in text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as large as your machine’s memory. Otherwise, at most size characters (in text mode) or size bytes (in binary mode) are read and returned. If the end of the file has been reached, will return an empty string ( ). 'This is the entire file.\n\n' reads a single line from the file; a newline character ( ) is left at the end of the string, and is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value unambiguous; if returns an empty string, the end of the file has been reached, while a blank line is represented by , a string containing only a single newline. 'This is the first line of the file.\n\n' 'Second line of the file\n\n' For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to simple code: This is the first line of the file. If you want to read all the lines of a file in a list you can also use or . writes the contents of string to the file, returning the number of characters written. Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary mode) – before writing them: returns an integer giving the file object’s current position in the file represented as number of bytes from the beginning of the file when in binary mode and an opaque number when in text mode. To change the file object’s position, use . The position is computed from adding offset to a reference point; the reference point is selected by the whence argument. A whence value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the file as the reference point. whence can be omitted and defaults to 0, using the beginning of the file as the reference point. # Go to the 6th byte in the file # Go to the 3rd byte before the end In text files (those opened without a in the mode string), only seeks relative to the beginning of the file are allowed (the exception being seeking to the very file end with ) and the only valid offset values are those returned from the , or zero. Any other offset value produces undefined behaviour. File objects have some additional methods, such as and which are less frequently used; consult the Library Reference for a complete guide to file objects. Strings can easily be written to and read from a file. Numbers take a bit more effort, since the method only returns strings, which will have to be passed to a function like , which takes a string like and returns its numeric value 123. When you want to save more complex data types like nested lists and dictionaries, parsing and serializing by hand becomes complicated. Rather than having users constantly writing and debugging code to save complicated data types to files, Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation). The standard module called can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called deserializing. Between serializing and deserializing, the string representing the object may have been stored in a file or data, or sent over a network connection to some distant machine. The JSON format is commonly used by modern applications to allow for data exchange. Many programmers are already familiar with it, which makes it a good choice for interoperability. If you have an object , you can view its JSON string representation with a simple line of code: Another variant of the function, called , simply serializes the object to a text file. So if is a text file object opened for writing, we can do this: To decode the object again, if is a binary file or text file object which has been opened for reading: JSON files must be encoded in UTF-8. Use when opening JSON file as a text file for both of reading and writing. This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances in JSON requires a bit of extra effort. The reference for the module contains an explanation of this. Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects. As such, it is specific to Python and cannot be used to communicate with applications written in other languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can execute arbitrary code, if the data was crafted by a skilled attacker."
    },
    {
        "link": "https://python-reference.readthedocs.io/en/latest/docs/functions/print.html",
        "document": "All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end.\n\nThe file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Output buffering is determined by file. Use file.flush() to ensure, for instance, immediate appearance on a screen."
    },
    {
        "link": "https://learnpython.com/blog/python-print-function",
        "document": "Let’s explore the Python print() function in detail with some examples. There is more to it than you realize!\n\nThere’s a reasonable chance one of your first encounters with Python included , possibly in the form of a “Hello, World!” program. The Python function is a basic one you can understand and start using very quickly.\n\nBut there’s more to it than meets the eye. In this article, we explore this function in detail by explaining how all the arguments work and showing you some examples.\n\nA good reference for how the Python function works is in the official documentation. The function accepts several arguments as shown below with their default values:\n\nWe have touched on the function in another article. In the sections below, we’ll go through the arguments one by one and show you everything you need to know to use this function to its full potential. For those of you who are new to Python, take a look at this mini track, which includes interactive coding challenges to accelerate your learning.\n\nThe thing to be printed is represented by the first argument and can be basically anything. It is commonly a string but may be an integer, a float, a variable, a list, or a dictionary, among others. The function can also take more than one object.\n\nSince it’s common to print strings, it’s worth mentioning that strings may be defined with either single quotes ('string') or double quotes (\"string\"). Your personal preference and the use case determine which to use. To demonstrate this, consider the following two examples:\n\nIf you’re interested in learning more about working with strings, check out this course. We also have an article where we show you how to index and slice strings.\n\nThe most basic use of the Python function is for simply printing a string:\n\nUnspecified keywords take on their default values, which are listed above in the introduction.\n\nNormal string operations may be used within the function. As an example, you can multiply a string by an integer as shown here:\n\nAt this point, it’s important to touch on string formatting. The old-school way is with %-formatting; however, this isn’t recommended because it gets a little cumbersome with longer strings.\n\nThe better way is to use , where the replacement fields are indicated with curly braces. Let’s define some variables and print them in a string:\n\nFor more examples of string formatting, the official documentation is a good reference. You can also use this method to print tabular data – we have written a separate article on the topic.\n\nAnother formatting method is known as f-string formatting. It’s similar to the above example, but it’s a little more compact. Using the same variables from the above, we can write:\n\nIf you want to print an iterable object like a list or an array, using a starred expression helps unpack the iterable and print it nicely:\n\nTry printing the same list without the star and see what you get. Also, try printing the sequence given by the built-in function with and without the star. We’ll see some more examples with starred expressions in the next section.\n\nThe second argument of the Python function defines the separator. If more than one object is given as the first argument, then sep defines what delimiter to place between them. Building on the previous example, we define the separator to be the newline character:\n\nAnother use case for this argument is for printing some results nicely. We can define a variable and print its value in a human-readable sentence like this:\n\nHere, the string and the variable both together are the argument, and the value of sep is printed between them.\n\nThe end keyword allows you to define something to be printed automatically at the end of the output. It defaults to the newline character (\"\n\n\").\n\nNone of the arguments of the Python function are required, strictly speaking. If no arguments are given, the end keyword is printed, which is the newline character by default. It’s pretty straightforward, but for the sake of completeness, let’s build on the previous example by adding an exclamation point at the end:\n\nNot specifying this keyword writes to the terminal in Python by default. The documentation linked above says the default value is , which means “write to standard output” in Python. This is a built-in file object that displays anything written to it (with the method) to the console. If you want to write to a file in Python, specify your own file object with the keyword.\n\nIn anticipation of the final example, let’s define the following string, and save it to the file “flush_demo.py” (don’t worry – this’ll all make sense soon):\n\nNow, go to your current working directory, and you see the new file we have created. The string is in fact a program, which we’ll use shortly.\n\nIt’s important to note you need to define the file object in write mode then close it at the end. If you want more details about writing to file in Python, we have an article covering that.\n\nThe keyword is a recent addition to the function. It accepts a Boolean, either or .\n\nNormally, the output to a file or the console is buffered. The buffer is \"flushed\" (or printed) only when it is full or when a newline is reached. Setting this keyword to True forcibly flushes the buffer before it is full or before a newline character is encountered.\n\nTo see this in action, we need to use the file we just created in the previous example. To run this script, open the terminal, navigate to the correct directory, and run:\n\nYou see we have created a countdown clock. With , the buffer is flushed after every individual number is printed in the loop, then the program sleeps for 1 second. With , the program sleeps for 10 seconds and the buffer is only flushed at the end of the program, printing the sequence of numbers all at once.\n\nTo You, From the Python Function\n\nTo wrap up this article on the Python print() function, here’s a personalized thank you message. Just copy and paste this into your console:"
    },
    {
        "link": "https://docs.python.org",
        "document": "What's new in Python 3.13?\n\n Or all \"What's new\" documents since Python 2.0\n\nTutorial\n\n Start here: a tour of Python's syntax and features\n\nPython setup and usage\n\n How to install, configure, and use Python"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-write-your-first-python-3-program",
        "document": "The “Hello, World!” program is a classic and time-honored tradition in computer programming. Serving as a simple and complete first program for beginners, as well as a good program to test systems and programming environments, “Hello, World!” illustrates the basic syntax of programming languages.\n\nThis tutorial will walk you through writing a “Hello, World” program in Python 3.\n\nYou should have Python 3 installed and a programming environment set up on your computer or server. If you don’t have a programming environment set up, you can refer to the installation and setup guides for a local programming environment or for a programming environment on your server appropriate for your operating system (Ubuntu, CentOS, Debian, etc.)\n\nTo write the “Hello, World!” program, let’s open up a command-line text editor such as nano and create a new file:\n\nOnce the text file opens up in the terminal window we’ll type out our program:\n\nLet’s break down the different components of the code.\n\nis a function that tells the computer to perform an action. We know it is a function because it uses parentheses. tells Python to display or output whatever we put in the parentheses. By default, this will output to the current terminal window.\n\nSome functions, like the function, are built-in functions included in Python by default. These built-in functions are always available for us to use in programs that we create. We can also define our own functions that we construct ourselves through other elements.\n\nInside the parentheses of the function is a sequence of characters — — that is enclosed in quotation marks. Any characters that are inside of quotation marks are called a string.\n\nOnce we are done writing our program, we can exit nano by typing the and keys, and when prompted to save the file press .\n\nOnce you exit out of nano you’ll return to your shell.\n\nWith our “Hello, World!” program written, we are ready to run the program. We’ll use the command along with the name of our program file. Let’s run the program:\n\nThe hello.py program that you created will cause your terminal to produce the following output:\n\nLet’s go over what the program did in more detail.\n\nPython executed the line by calling the function. The string value of was passed to the function.\n\nIn this example, the string is also called an argument since it is a value that is passed to a function.\n\nThe quotes that are on either side of were not printed to the screen because they are used to tell Python that they contain a string. The quotation marks delineate where the string begins and ends.\n\nSince the program ran, you can now confirm that Python 3 is properly installed and that the program is syntactically correct.\n\nCongratulations! You have written the “Hello, World!” program in Python 3.\n\nFrom here, you can continue to work with the function by writing your own strings to display, and can also create new program files.\n\nKeep learning about programming in Python by reading our full tutorial series How To Code in Python 3."
    },
    {
        "link": "https://datacamp.com/tutorial/python-hello-world-a-beginners-guide-to-programming",
        "document": "The first step in learning any programming language is often to print \"Hello World!\" This tradition helps you understand the language's basic syntax and structure. In Python, this is done using the function.\n\nThe function is one of the most frequently used functions in Python. It outputs text. Let's see it in action:\n\nWhen you run this line of code, Python will output:\n\nWhile running Python code in an IDE is convenient, you can also create a script file and run it. This is useful for saving and running larger programs. Here’s how you can do it:\n\n1. Open a text editor (like Notepad on Windows or TextEdit on MacOS).\n\n3. Save the file with a extension, for example, .\n\n4. Open your command line interface (CLI) or terminal. On Windows computers, press the Windows key, type \"Command Prompt,\" and hit Enter. This will open the Command Prompt (CLI). For macOS, press Command + Space, type \"Terminal,\" and hit Enter. This will open the Terminal application.\n\n5. In the command line, use the command (short for \"change directory\") to navigate to the folder where you saved your file. For example, if you saved your file on the Desktop, you would type:\n\nCongratulations! You've just run your first Python script.\n\nOne of the beauties of Python, and programming in general, is the ability to create systems that automate tasks. Functions are the building blocks of these systems in Python. A function is a reusable block of code that performs a specific task.\n\nLet's create a function that takes a person's name as an argument and prints a personalized greeting.\n• is a keyword that tells Python we are defining a function.\n• is the name of our function.\n• inside the parentheses is a parameter—a variable that the function can receive as input.\n• is the function's action. Here, we use commas to separate between the different elements of the print statement.\n\nFor more on functions, check out this interactive course on Writing Functions in Python from scratch, where you’ll build Python functions right in the browser!\n\nLearning Python is an exciting journey that opens up many possibilities in the programming world. Here are some steps and resources to help you get started:\n• Start with the basics: Learn the basic syntax and structure of Python. Understand variables, data types, and simple operations.\n• Practice coding: The best way to learn programming is by doing. Write small programs, experiment with different functions, and try to solve simple problems.\n• Use online resources: There are numerous free and paid resources available online. Check out DataCamp’s Python curriculum for more!\n• Read Python documentation: Familiarize yourself with the official Python documentation. It’s a comprehensive resource for understanding Python's capabilities and features.\n• Join a community: Engage with other learners and experienced developers. Communities like Stack Overflow, Reddit’s r/learnpython, and Python Discord servers are great places to ask questions, share knowledge, and get support.\n• Build projects: Apply what you've learned by working on small projects. This could be anything from a simple calculator to a web scraper. Projects help solidify your knowledge and provide practical experience.\n• Explore advanced topics: Once you're comfortable with the basics, explore more advanced topics like object-oriented programming, web development with frameworks like Django or Flask, and data analysis with libraries like Pandas and NumPy.\n\nFor more detailed guidance, read our comprehensive guide on how to learn Python from scratch.\n\nNow that you've written your first Python program and created a function, you’ve taken the first step to mastering this powerful language. Keep experimenting with Python, try out new ideas, and don't hesitate to explore more advanced topics as you grow more comfortable."
    },
    {
        "link": "https://programiz.com/python-programming/examples/hello-world",
        "document": "In this program, we have used the built-in print() function to print the string on our screen.\n\nBy the way, a string is a sequence of characters. In Python, strings are enclosed inside single quotes, double quotes, or triple quotes."
    },
    {
        "link": "https://learnpython.org/en/Hello,_World!",
        "document": "Get started learning Python with DataCamp's free Intro to Python tutorial. Learn Data Science by completing interactive coding challenges and watching videos by expert instructors. Start Now! This site is generously supported by DataCamp. DataCamp offers online interactive Python Tutorials for Data Science. Join 11 million other learners and get started learning Python for data science today! Good news! You can save 25% off your Datacamp annual subscription with the code LEARNPYTHON23ALE25 - Click here to redeem your discount\n\nPython is a very simple language, and has a very straightforward syntax. It encourages programmers to program without boilerplate (prepared) code. The simplest directive in Python is the \"print\" directive - it simply prints out a line (and also includes a newline, unlike in C). There are two major Python versions, Python 2 and Python 3. Python 2 and 3 are quite different. This tutorial uses Python 3, because it more semantically correct and supports newer features. For example, one difference between Python 2 and 3 is the statement. In Python 2, the \"print\" statement is not a function, and therefore it is invoked without parentheses. However, in Python 3, it is a function, and must be invoked with parentheses. To print a string in Python 3, just write: Python uses indentation for blocks, instead of curly braces. Both tabs and spaces are supported, but the standard indentation requires standard Python code to use four spaces. For example: x = 1 if x == 1: # indented four spaces print(\"x is 1.\") Use the \"print\" function to print the line \"Hello, World!\"."
    },
    {
        "link": "https://ithy.com/article/python-hello-world-guide-imbq3xf5",
        "document": "The \"Hello World\" program is traditionally the first program that beginners write when learning a new programming language. It serves as a simple way to understand the basic syntax and structure of the language. In Python, creating a \"Hello World\" program is straightforward and concise, making it an excellent starting point for newcomers.\n\nThe simplest way to display \"Hello World\" in Python is by using the function. Here's how you can do it:\n\nThis single line of code tells Python to output the string \"Hello, World!\" to the console. The function is a built-in Python function used to display information to the user.\n\nLet's break down the components of the \"Hello World\" program:\n• print: This is a built-in Python function that outputs data to the standard output device, typically the screen.\n• \"Hello, World!\": This is a string literal, enclosed in double quotes, that represents the text to be displayed.\n• Parentheses (): In Python 3, the function requires parentheses to enclose its arguments.\n\nTo run the \"Hello World\" program, follow these steps:\n• Write the Code: Use a text editor or an integrated development environment (IDE) to write the Python code. Save the file with a extension, for example, .\n• Run the Program: Open a terminal or command prompt, navigate to the directory containing the Python file, and execute the following command: Ensure that Python is installed and properly configured in your system's PATH.\n\nUpon execution, the program will display:\n\nVariations of the \"Hello World\" Program\n\nWhile the basic structure remains the same, there are slight variations in how the \"Hello World\" message can be formatted:\n\nThe message within the function can vary in capitalization and punctuation based on preference:\n\nEach variation is syntactically correct in Python. The choice depends on the desired output format.\n\nPython allows the use of single quotes for string literals as well. The same program can be written using single quotes:\n\nBoth single and double quotes are interchangeable in Python, allowing flexibility in string declarations.\n\nFor those looking to explore beyond the basic example, here are some advanced variations:\n\nYou can store the message in a variable before printing it:\n\nThis approach introduces the concept of variables, which are fundamental in programming for storing and manipulating data.\n\nCombining multiple strings into one is another way to generate the \"Hello World\" message:\n\nThis method demonstrates string concatenation using the operator, allowing for dynamic creation of messages.\n\nPython offers several ways to format strings, enhancing readability and flexibility:\n• f-strings (Python 3.6+):\n\n f-strings provide a concise and readable way to include variables and expressions inside string literals.\n• str.format() method:\n\n This method allows placeholders within the string to be replaced by variable values.\n• Percentage (%) formatting:\n\n An older method for string formatting, using the % operator to inject variables into the string.\n\nWhen writing your first Python program, it's easy to make small errors. Here are some common mistakes and how to avoid them:\n\nPython is sensitive to syntax. Missing quotation marks, parentheses, or incorrect indentation can lead to errors:\n• Missing Quotes: will raise a because the string is not enclosed in quotes.\n• Missing Parentheses: In Python 3, will cause a because is a function and requires parentheses.\n\nPython is case-sensitive. Using instead of will result in a because is not defined.\n\nAdding extra characters or incorrect punctuation can lead to unexpected behavior or errors. Ensure that your strings are properly closed and that your syntax aligns with Python's rules.\n\nTo effectively run Python programs, understanding the execution environment is essential. Here are the primary methods to run your Python scripts:\n\nThe command line is a powerful tool for running Python scripts:\n• Navigate to the directory containing your Python file using the command.\n• Run the program by typing and pressing Enter.\n\nIDEs provide a more user-friendly interface for writing and running Python code. Some popular IDEs include:\n\nThese environments often include built-in terminals, code completion, and other utilities that streamline the development process.\n\nFor quick tests or when installing Python is not feasible, online interpreters offer an alternative:\n• Google Colab: Ideal for data science and machine learning projects, providing free access to computing resources.\n\nNext Steps After \"Hello World\"\n\nOnce you've successfully created and run your \"Hello World\" program, you can continue your Python learning journey by exploring more advanced topics:\n\nUnderstanding how to store and manipulate data using variables and different data types (e.g., integers, strings, lists) is fundamental in programming.\n\nLearning about conditional statements ( , , ) and loops ( , ) enables you to control the flow of your programs.\n\nFunctions allow you to encapsulate reusable code blocks, making your programs more organized and efficient.\n\nPython's extensive standard library and third-party modules provide a wealth of tools for virtually any application, from web development to data analysis.\n\nEmbracing OOP principles, such as classes and objects, can help in designing complex and scalable software systems.\n\nAdhering to Python best practices improves code readability, maintainability, and efficiency:\n\nPEP 8 provides guidelines on how to write Python code cleanly and consistently. Key recommendations include:\n• Use four spaces per indentation level.\n• Separate top-level function and class definitions with two blank lines.\n\nReadable code is easy to understand and maintain. Practices that enhance readability include:\n• Using descriptive names for variables and functions.\n\nAnticipating and handling errors gracefully prevents program crashes and improves user experience. Utilize try-except blocks to manage exceptions effectively.\n\nExpanding your Python knowledge can be facilitated through various resources:\n• Official Python Documentation: Comprehensive and authoritative source for Python's features and standard library.\n• Online Tutorials and Courses: Platforms like Coursera, edX, and Udemy offer structured Python courses.\n• Books: Readers such as \"Automate the Boring Stuff with Python\" and \"Python Crash Course\" are highly recommended for beginners.\n• Community Forums: Engaging with communities on Stack Overflow, Reddit's r/learnpython, and Python Discord can provide support and insights.\n\nCrafting a \"Hello World\" program in Python is an essential first step in your programming journey. It not only familiarizes you with the basic syntax but also sets the foundation for more complex endeavors. By understanding the components, executing the program, avoiding common mistakes, and adhering to best practices, you pave the way for effective and efficient Python programming. Leveraging the plethora of available resources will further enhance your skills, enabling you to tackle increasingly challenging projects with confidence."
    }
]