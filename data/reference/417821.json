[
    {
        "link": "https://digitalocean.com/community/tutorials/arrays-in-shell-scripts",
        "document": "Knowing how to work with arrays in shell scripts will help you work with larger datasets in a much efficient manner. But what are arrays and how can you create arrays? Let’s find out!\n\nIf you already have a basic understanding of any programming language, you know what arrays are. But for the uninitiated, let’s go over the basics of arrays and learn how to work with them.\n\nVariables store single data elements. Arrays, on the other hand, can store a virtually unlimited number of data elements. When working with a large amount of data, variables can prove to be very inefficient and it’s very helpful to get hands-on with arrays.\n\nLet’s learn how to create arrays in shell scripts.\n\nThere are two types of arrays that we can work with, in shell scripts.\n• Indexed Arrays - Store elements with an index starting from 0\n\nThe default array that’s created is an indexed array. If you specify the index names, it becomes an associative array and the elements can be accessed using the index names instead of numbers.\n\nNotice the uppercase and lowercase letter a. Uppercase is used to declare an associative array while lowercase is used to declare an indexed array.\n\nThe keyword is used to explicitly declare arrays but you do not really need to use them. When you’re creating an array, you can simply initialize the values based on the type of array you want without explicitly declaring the arrays.\n\nNow that you know how to create arrays, let’s learn how to work with arrays. Since these are collections of data elements, we can work with loops and arrays at the same time to extract the required data points.\n\nSince we know that each data point is being indexed individually, we can access all the array elements by specifying the array index as shown below:\n\nSimilarly, let’s access some indexed array elements. We can specify all the elements for the index array by delimiting with spaces because the index is automatically generated for each of those elements.\n\nAs you can see, the first element is automatically printed based on index 0.\n\nThis is going to be an easy task if you know for loops already. If you don’t we’ll cover them in a future tutorial. We’ll make use of the while or for loops in shell scripts to work through the array elements. Copy the script below and save it as <filename>.sh\n\nThe above script will output the following:\n\nNow you might have noticed the index_array[@] and if you’re wondering what the @ symbol is for, we’re going to go over the same right now.\n\nNow that you learned how to access elements individually and using for loops, let’s learn the different operations that are available by default for arrays.\n\n1. Access All Elements of an Array\n\nWe learned how to access elements by providing the index or the key of the array. But if we want to print all the elements at the same time or work with all the elements, we can use another operator which is the symbol.\n\nAs you noticed in the example above, I used this symbol when I wanted to loop through all the array elements using the for loop.\n\nThe above will print all the elements that are stored within the assoc array.\n\n2. Count the Number of Elements in an Array\n\nSimilar to the symbol above, we have the symbol which can be prefixed to an array name to provide us the count of the elements stored in the array. Let’s see how it works.\n\nIf you want to count the number of characters used for a particular element, we can simply replace the symbol with the index.\n\nWe know how to add array elements and print them too. Let’s learn how to delete specific elements. For this purpose, we’ll use the keyword.\n\nReplace the array name and the index ID in the above code example and you’ve removed the array element that you desire. Pretty simple isn’t it?\n\nShell scripts are pretty vast and can replace any function that you can perform on the terminal with the right person writing the script. Some additional functionalities of arrays in shell scripts also include being able to work with regex (Regular Expressions). We can use various regular expressions to manipulate array elements within shell scripts.\n\nFor now, we hope you have a good understanding of creating and working with arrays and will be able to use arrays in your scripting. Comment below to let us know what you think, and if you have any questions about this topic."
    },
    {
        "link": "https://freecodecamp.org/news/bash-array-how-to-declare-an-array-of-strings-in-a-bash-script",
        "document": "Bash scripts give you a convenient way to automate command line tasks.\n\nWith Bash, you can do many of the same things you would do in other scripting or programming languages. You can create and use variables, execute loops, use conditional logic, and store data in arrays.\n\nWhile the functionality may be very familiar, the syntax of Bash can be tricky. In this article, you will learn how to declare arrays and then how to use them in your code.\n\nHow to Declare an Array in Bash\n\nDeclaring an array in Bash is easy, but pay attention to the syntax. If you are used to programming in other languages, the code might look familiar, but there are subtle differences that are easy to miss.\n\nTo declare your array, follow these steps:\n• Follow that variable name with an equal sign. The equal sign should not have any spaces around it\n• Enclose the array in parentheses (not brackets like in JavaScript)\n• Type your strings using quotes, but with no commas between them\n\nYour array declaration will look something like this:\n\nThat's it! It's that simple.\n\nHow to Access an Array in Bash\n\nThere are a couple different ways to loop through your array. You can either loop through the elements themselves, or loop through the indices.\n\nHow to Loop Through Array Elements\n\nTo loop through the array elements, your code will need to look something like this:\n\nTo break that down: this is somewhat like using in JavaScript. For each string (str) in the array (myArray), print that string.\n\nThe output of this loop looks like this:\n\nNote: The symbol in the square brackets indicates that you are looping through all of the elements in the array. If you were to leave that out and just write , only the first string in the array would be printed.\n\nHow to Loop Through Array Indices\n\nAlternatively, you can loop through the indices of the array. This is like a loop in JavaScript, and is useful for when you want to be able to access the index of each element.\n\nTo use this method, your code will need to look something like the following:\n\nThe output will look like this:\n\nNote: The exclamation mark at the beginning of the variable indicates that you are accessing the indices of the array and not the elements themselves. This can be confusing if you are used to the exclamation mark indicating negation, so pay careful attention to that.\n\nAnother note: Bash does not typically require curly braces for variables, but it does for arrays. So you will notice that when you reference an array, you do so with the syntax , but when you reference a string or number, you simply use a dollar sign: .\n\nBash scripts are useful for creating automated command line behavior, and arrays are a great tool that you can use to store multiple pieces of data.\n\nDeclaring and using them is not hard, but it is different from other languages, so pay close attention to avoid making mistakes."
    },
    {
        "link": "https://geeksforgeeks.org/array-basics-shell-scripting-set-1",
        "document": "Consider a situation if we want to store 1000 numbers and perform operations on them. If we use a simple variable concept then we have to create 1000 variables and perform operations on them. But it is difficult to handle a large number of variables. So, it is good to store the same type of values in the array and then access via index number.\n\nAn array is a structured arrangement of similar data elements. Within shell scripting, an array is a variable that holds multiple values, whether they are of the same type or different types. It’s important to note that in shell scripting, everything is treated as a string. Arrays adhere to a zero-based index, which signifies that indexing initiates from 0.\n\nHow to Declare Array in Shell Scripting?\n\nArrays can be declared in a shell script using various approaches:\n\nIn this method, you assign a value to a specific index of the array variable. There’s no need to declare the array beforehand.\n\nWith explicit declaration, you first declare the array and then assign values to it.\n\nThis method involves declaring the array along with its initial set of values. You can later add additional values to the array.\n\nAlternatively, you can use index numbers to assign values explicitly:\n\nTo display array elements, you have several options:\n\nHere is a `array_test.sh`script explaining multiple options. (You can create script with any name)\n\n# To print all elements of the array\n\necho “All elements of the array:”\n\necho “${arr[@]}”\n\necho “${arr[*]}” # To print the first element\n\necho “The first element:”\n\necho “${arr[0]}” # To print elements from a particular index\n\necho “Elements from a particular index:”\n\necho “${arr[@]:2}” # Prints elements starting from index 2\n\necho “${arr[*]:2}” # Prints elements starting from index 2 # To print elements in a range\n\necho “Elements in a range:”\n\necho “${arr[@]:1:3}” # Prints elements from index 1 to 3\n\necho “${arr[*]:1:3}” # Prints elements from index 1 to 3\n• Array Declaration: is declared, containing six elements. These elements are strings: “prakhar”, “ankit”, “1”, “rishabh”, “manish”, and “abhinav”.\n• Printing All Elements:\n• None echo \"All elements of the array:\" : A message is printed to indicate that all elements of the array are being displayed.\n• None : This syntax is used to print each element of the array separately. It displays all elements in the array.\n• None : Similar to the previous line, this syntax prints all elements of the array as a single string.\n• Printing the First Element:\n• None : A message is printed to indicate that the first element of the array is being displayed.\n• None : This syntax retrieves and displays the first element of the array. In Bash, array indexing starts at 0.\n• Printing a Selected Index Element:\n• None is assigned the value 3. This variable represents the desired index in the array.\n• None : A message is printed to indicate the selected index.\n• None : Using the value stored in , this syntax retrieves and displays the element at the specified index (index 3 in this case).\n• Printing Elements from a Particular Index:\n• None : A message is printed to indicate that elements from a specific index are being displayed.\n• None : This syntax extracts and displays all elements starting from index 2 in the array. It prints each element separately.\n• None : Similar to the previous line, this syntax displays the elements as a single string, starting from index 2.\n• Printing Elements in a Range:\n• None : A message is printed to indicate that elements within a specified range are being displayed.\n• None : This syntax extracts and displays elements starting from index 1 up to index 3 (inclusive). It prints each element separately.\n• None : Similar to the previous line, this syntax displays the extracted elements as a single string.\n\nHere is a `array_test2.sh` script with few other examples. (you can create script with any name)\n\n# Count the length of a particular element in the array\n\nelement_length=${#arr[2]}\n\necho “Length of element at index 2: $element_length” # Count the length of the entire array\n\narray_length=${#arr[@]}\n\necho “Length of the array: $array_length” # Search in the array\n\nsearch_result=$(echo “${arr[@]}” | grep -c “Jayesh”)\n\necho “Search result for ‘Jayesh’: $search_result” # Search and replace in the array\n\nreplaced_element=$(echo “${arr[@]/Shivang/SHIVANG}”)\n\necho “Array after search & replace: ${replaced_element[*]}” # Delete an element in the array (index 3)\n\nunset arr[3]\n• Array Declaration:\n• None is declared, containing six elements.\n• None These elements are strings: “Jayesh”, “Shivang”, “1”, “rishabh”, “Vipul”, and “Nishtan”.\n• Printing Element Length:\n• None The length of the element at index 2 of the array is calculated using\n• None This length is stored in the variable\n• Printing Array Length:\n• None The length of the entire array is calculated using\n• None This length is stored in the variable\n• Searching in the Array:\n• None command is used to search for occurrences of the string “Jayesh” in the array\n• None flag is used to count the number of occurrences.\n• None The count is stored in the variable\n• Searching and Replacing in the Array:\n• None A search and replace operation is performed on the array\n• None The string “Shivang” is replaced with “SHIVANG”.\n• None The updated array is stored in the variable\n• Deleting an Element from the Array:\n• None command is used to delete the element at index 3 (which is “rishabh”) from the array\n• Printing All Elements:\n• None The message “All elements of the array:” is echoed.\n• None syntax is used to print each element of the array separately. This displays all elements in the array.\n\nIn this article we discussed about utility of arrays in shell scripting. It underlines how arrays efficiently handle a multitude of values, replacing numerous variables. The concept of array declaration is explained through three methods: indirect, explicit, and compound assignment. The article further illustrates printing array elements using practical script examples. This discussion not only demystifies array usage but also underscores its significance in managing and manipulating data within shell scripts."
    },
    {
        "link": "https://stackoverflow.com/questions/1878882/how-do-i-create-an-array-in-unix-shell-scripting",
        "document": "Your question asks about \"unix shell scripting\", but is tagged . Those are two different answers.\n\nThe POSIX specification for shells does not have anything to say about arrays, as the original Bourne shell did not support them. Even today, on FreeBSD, Ubuntu Linux, and many other systems, does not have array support. So if you want your script to work in different Bourne-compatible shells, you shouldn't use them. Alternatively, if you are assuming a specific shell, then be sure to put its full name in the shebang line, e.g. .\n\nIf you are using bash or zsh, or a modern version of ksh, you can create an array like this:\n\nand access elements like this\n\nYou can get all the elements via . You can use the slice notation ${array[@]:start:length} to restrict the portion of the array referenced, e.g. to leave off the first element.\n\nThe length of the array is , which can be simplified to just in zsh. In bash and ksh, you can get a new array containing all the indexes from an existing array with ; in zsh you have to construct the range manually, but works since it also does parameter expansion before brace expansion.\n\nOlder versions of ksh before ksh93 also had arrays, but not the parenthesis-based notation, nor did they support slicing. You could create an array like this, though:"
    },
    {
        "link": "https://shell-tips.com/bash/arrays",
        "document": "What is the Right Way to do Bash Loops?"
    },
    {
        "link": "https://stackoverflow.com/questions/17622106/variable-interpolation-in-the-shell",
        "document": "To access the variable, I know that I can do this:\n\nIn my shell script I attempted to do something like this (the backticks are intended)\n\nThis line fails, duuh!, because the variable is not called\n\nHow do I append to the variable name?\n\nPlease note that backticks are intended for the expression evaluation."
    },
    {
        "link": "https://stackoverflow.com/questions/26559617/bash-variable-interpolation-separate-variables-by-a-hyphen-or-underscore",
        "document": "This is a simple script just to see if the file has been downloaded. On this script the find command always evaluated to zero - even if it didn't find anything. So I commented it out.\n\non the I had to add an underscore to the end of the filename.\n\nUsing an underscore to separate the two did not work. - I had to take out the underscore, add it to the filename and then combine the variables to make it work like this - .\n\nHow could I get it to work without adding the underscore to the end of the variable ?"
    },
    {
        "link": "https://unix.stackexchange.com/questions/289217/variable-interpolation-in-shell-script",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://unix.stackexchange.com/questions/435482/how-to-deal-with-multiline-strings-and-string-interpolation",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "http://compciv.org/topics/bash/variables-and-substitution",
        "document": "An essential feature of programming is the ability to use a name or a label to refer to some other quantity: such as a value, or a command. This is commonly referred to as variables.\n\nVariables can be used, at the very least, to make code more readable for humans:\n\nHowever, variables really come into use in more advanced programming, when we're in a situation in which the actual values aren't known before executing a program. A variable acts as a placeholder that gets resolved upon actual execution time.\n\nFor example, imagine that contains a list of website addresses. The following routine reads each line (via , which isn't best practice…but will do for now) into a loop, which then downloads each URL:\n\nThe following command assigns to the variable named , and to\n\nUnlike most modern languages, Bash is pretty picky about the syntax for setting variables. In particular, no whitespace is allowed between the variable name, the equals sign, and the value.\n\nAll of these examples would cause Bash to throw an error:\n\nReferencing the value of a variable\n\nWhenever Bash encounters a dollar-sign, immediately followed by a word, within a command or in a double-quoted string, it will attempt to replace that token with the value of the named variable. This is sometimes referred to as expanding the variable, or parameter substitution:\n\nWhen a dollar-sign doesn't precede a variable name, or a variable reference is within single-quotes, Bash will interpret the string literally:\n\nVariables can be very useful for text-patterns that will be repeatedly used:\n\nIf your variable name butts up against a literal alphanumeric character, you can use this more verbose form, involving curly braces, to reference a variable's value:\n\nVariable names can contain a sequence of alphanumeric characters and underscores. For variables created by you, the user, they should start with either an alphabetical letter or an underscore (i.e. not a number):\n\nWhen we write functions and shell scripts, in which arguments are passed in to be processed, the arguments will be passed int numerically-named variables, e.g. , ,\n\nInside , commands will use to refer to , to , and for\n\nThe variable reference, , will expand to the current script's name, e.g.\n\nThe standard output of a command can be encapsulated, much like a value can be stored in a value, and then expanded by the shell.\n\nThis is known as command substitution. From the Bash documentation:\n\nAs an example, consider the seq command, which will print a sequence of numbers starting from the first argument to the second argument:\n\nWith command substitution, we can encapsulate the result of into a variable by enclosing the command with and , and pass it as an argument to another command:\n\nWhen a command is replaced by its standard output, that output, presumably just text, can be assigned to a variable like any other value:\n\nThe loss of newlines in command substitution\n\nEarlier, I quoted from the Bash documentation on command expansion. Here's an emphasized version of the excerpt:\n\nWhat does that mean? Consider being called normally, and then, via command substitution, and note the change in formatting:\n\nWhy do the newlines get removed during the command expansion? It's something we'll encounter later (and there's a section on it at the end of this tutorial) and deals with how Bash interprets space and newline characters during expansion. Anyway, it's worth noting the behavior for now, as it may be new to you if you're coming from another programming language.\n\nTo do basic calculations, you can enclose an expression inside :\n\nCheck the Bash documentation for the full set of arithmetic operators. Math at the command-line can be a bit clunky so we won't be focusing too much on it.\n\nAn aside: if you want to do more advanced math from the command line, use bc, which reads in from stdout and evaluates the expression:\n\nThis section covers more technical details of how Bash handles space characters when it does an exapansion. It's not necessary to memorize for the specific assignments in this class. However, as many of you are wont to copy and paste code directly from things you've seen on the Internet, it might be worth knowing all the different ways you could accidentally harm yourself, due to the way Bash handles spaces and newline characters.\n\nHere's the Bash documentation for the concept known as \"word-splitting\"\n\nThe global variable is what Bash uses to split a string of expanded into separate words…think of it as how Excel knows to split a CSV (comma-separated-values) text file into a spreadsheet: it assumes the commas separate the columns.\n\nLet's pretend that has been set to something arbitrary, like a capital . When Bash expands a variable that happens to contain a , the value of that variable will be split into separate words (and the literal will disappear):\n\nBy default, the variable is set to three characters: newline, space, and the tab. If you , you won't see anything because those characters…well, how do you see a space character if there aren't any visible characters?\n\nThe upshot is that you may see code snippets online in which the variable is changed to something like (which stands for the newline character).\n\nImagine a textfile that contains a bunch of lines of text that, for example, may refer to filenames:\n\nWhen Bash reads each line of the file, the default value of , which includes a space character, will cause Bash to treat the file named as two files, and , because the space character is used to split words.\n\nWith set to just the newline character, is treated as a single filename.\n\nThis concept will make sense when it comes to reading text files and operating on each line. I don't expect you to fully understand this, but only to be aware of it, just in case you are haphazardly copy-pasting code from the Internet.\n\nIn an ideal world, everyone would keep their string values short and without space/newline, or any other special characters. In that ideal world, the following unquoted variable reference would work just fine:\n\nBut when people start adding special characters to filenames, such as spaces, expanding variables, without the use of double quotes, can be dangerous.\n\nIn the following example, the programmer intends the file named to be deleted:\n\nHowever, when referenced without double-quotes, Bash sees as containing two separate values, and . The subsequent command will attempt to delete those two files, and not :\n\nAh, no harm done, you say, because those files didn't exist in the first place. OK, but what happens when someone puts a star (i.e. asterisk) into a filename? You're aware of what happens when you do and – the star acts as a wildcard, grabbing every file.\n\nSo you'll see the previous errors, since and don't exist. But in between those attempted deletions, will run on …so say bye-bye to every file in that directory.\n\nNotice how affects only the file that is named, .\n\nSo the main takeaway here is: double-quote your variable references whenever possible.\n\nExpanding a variable can lead to unexpected and sometimes catastrophic results if the variable contains special characters:\n\nExpanding a variable within double-quotes can prevent such problems:\n\nWho would do such a thing?\n\nYou might think, Who the hell puts star characters in their filenames? Well, besides people who really enjoy star-shaped symbols, malicious hackers and pranksters. And variables usually aren't just manually assigned by the result of human typing. As you've read above, sometimes the result of commands are stored in a variable. And if such commands are processing raw data, it's not unimaginable that the raw data, quite innocently, contains special characters that are destructive to certain Bash programs.\n\nFor the purposes of the CompCiv course, the assignments will try to stay far from untrusted sources of data. But keep in mind the dangers of just pasting in seemingly safe-looking code. Bash's syntax and behavior in handling strings is hard to fully comprehend, which is why developers use other languages for more complex applications.\n\nYou can read more about quoting variables. There's a lot of minutiae, but the main takeaway, besides general safety, is to have a general understanding how Bash, and any other programming environment, uses certain conventions and syntax rules to deal with the myriad ways that users want to pass around values in their programs."
    },
    {
        "link": "https://stackoverflow.com/questions/17029902/using-curl-post-with-variables-defined-in-bash-script-functions",
        "document": "We can assign a variable for curl using single quote and wrap some other variables in\n\nLets test each case, but first watch out for this catch that if we use a single quote for variable assignment, that variable is not evaluated.\n\nPlease notice the assignment is done by a single quote\n• The value of a variable is evaluated\n• neither single quote nor applies double one\n• will be surrounded by a double quote\n• will be surrounded by a single quote\n\nwhich one we should use?\n\nSince needs a double quote for its key or value we can use :\n\nNOTE:\n\n The equivalent of for a variable evaluation is which means instead of using we can use and it gives us neither with a single quote nor a double quote , but it gets more confusing if we needed to apply for curl since we need a double quoted result and would have to wrap it in another double quote =>\n\nThis code works well, but the above is more readable\n\nWe can use either of:"
    },
    {
        "link": "https://stackoverflow.com/questions/53943485/sending-post-request-from-bash-script",
        "document": "I want to execute a script after i make a request.So far i am using for sending the request , but i was wondering if i can somehow do it from a script as well with a file as parameter.\n\nI have looked into so far but it does not work:\n\nI just get the error :"
    },
    {
        "link": "https://reqbin.com/req/curl/c-d2nzjn3z/curl-post-body",
        "document": "Curl is a command-line utility for transferring data to or from a remote server using one of the supported protocols. Developers use Curl to test APIs, send requests to the server, view server response headers, and load-test APIs. Curl supports over 25+ protocols, including HTTP, HTTPS, FTP, FTPS, and SFTP, has built-in support for SSL certificates, supports HTTP POST, HTTP PUT, FTP file upload, web form submission, user authentication, HTTP Cookies, and more.\n\nWhat is an HTTP body?\n\nThe HTTP body is the data sent in an HTTP message to the other side during client-server communication. The HTTP body can be divided into two types: single resource bodies, which contain a single file identified by the Content-Length and Content-Type headers, and multi-resource bodies, which contain multiple parts of different types, typically used for HTML form multiple file uploads. Not all HTTP messages have a body; for example, GET, HEAD, DELETE, and OPTIONS methods cannot have a body.\n\nCan I send data in the body of an HTTP POST request?\n\nYes, you can send any data to a server in the body of the HTTP POST request. HTTP POST requests need a Content-Type header that identifies the data type in the POST request body to allow the server to interpret and process this data correctly. For example, when submitting an HTML form to a web server, the Content-Type is usually application/x-www-form-urlencoded. When uploading files to the server, the Content-Type is usually multipart/form-data.\n\nHow to post the message body with Curl?\n\nYou can pass the body of the POST message to Curl with the -d (or --data command-line) option. Curl will send data to the server in the same format as the browser when submitting an HTML form. To send binary data in the body of a POST message with Curl, use the --data-binary command-line option. To send a file from the disk using Curl, start the data with the @ symbol; the rest of the parameter should be the file's name from which data will be read.\n\nHow to pass the Content-Type header using Curl?\n\nWhen sending data, you must also pass the Content-Type header, which identifies the data type in the HTTP message's body. This is important for the correct interpretation and processing of the message by servers and clients. The Content-Type header can be passed to Curl using the -H command-line option.\n\nThe following are examples of sending a Curl POST body:\n\nSending JSON in the body of a POST message\n\nThe following is an example of sending JSON in the body of a POST message:\n\nSending HTML form in the body of a POST message\n\nThe following is an example of submitting an HTML form in the body of a POST message:\n\nSending XML in the body of a POST message\n\nThe following is an example of sending XML in the body of a POST message:\n\nSending File in the body of a POST message\n\nThe following is an example of sending a file in the body of a POST message:"
    },
    {
        "link": "https://warp.dev/terminus/curl-post-request",
        "document": "cURL (curl) is an open source command-line tool used for transferring data over a network. POST is an HTTP request method which is used to send data to the server. (Read more on POST requests here.)\n\nThe format of a POST request with curl is: curl -X POST [options] [URL].\n\nAn example POST request to submit a todo list task to a REST API might look like:\n\nThree options provided here are:\n• None -X was used to provide the HTTP method we use to send the request. In this case, the method is POST\n• None -d was used to provide the associated data in the body of the HTTP request\n• None -H was used to specify headers for the request\n\nEach of these options also have associated aliases. For example, for -X you can instead provide --request, and for -H you can provide --headers.\n\nThese are just some of the possible options, but there are many others, enumerated below.\n\nThere are two common ways to send form data with POST requests, each with different content-types, demonstrated below:\n\nAs we can see from the image, to use multipart/form-data content-type, we send data with the -F (or --form option). To use application/x-www-form-urlencoded content-type, we use the -d (or --data) option.\n\nGenerally speaking, multipart/form-data is more often used to send binary data like images, while application/x-www-form-urlencoded is used to send text data.\n\nBy default, HTML forms will send data using the content-type of application/x-www-form-urlencoded when submitted.\n\nTo send image data in a POST request, include the image in the form data by prefixing the filename with an @ symbol as follows:\n\nThe @ symbol forces the content part of the form to be a file, which is then uploaded to the server.\n\nAlternatively, we could base64 encode the image and send it as a field in a form field or JSON body field of your request, but this is far less ergonomic:\n• None Argument names are case sensitive. For example, -F corresponds to the argument for form data, while -f is a flag indicating whether we want to fail fast with no output\n• None When passing content of type application/json, be sure to wrap the JSON body in single quotes - e.g. -d \"{ \"title\":\"foo\" }\" would be invalid\n• None You can only use breaklines if you include \\ a backslash character. There can be no trailing spaces after the backslash\n\nArguments available for the options field of the curl POST format (curl -X POST [options] [URL]) are enumerated below:\n\nRead more on the official curl docs."
    },
    {
        "link": "https://oxylabs.io/blog/curl-post-requests",
        "document": "First, install cURL if you haven’t installed it already. You can find the installation instructions in our How to Use cURL With Proxy blog post. Next, take a look at the below table:\n\nIn this tutorial, you’re going to learn how to send POST requests with cURL. cURL is a powerful command-line tool for transferring data over various network protocols, including HTTP, HTTPS, FTP, and more. Since POST is a request method of HTTP & HTTPS protocols, cURL makes sending POST requests a one-line command that you can run in your terminal easily.\n\nThis table represents all the necessary command-line options of cURL command that you’ll be using in the next few sections. You don’t need to memorize all of them right away, just briefly go over them. Once you start to use cURL daily, they’ll become part of your muscle memory. And whenever you need, you can always access all the available cURL options including the above using the --help option:\n\nThe basic syntax for sending a POST request using cURL is as below:\n\nNotice the -X flag followed by POST, it tells cURL to make a request using the HTTP protocol’s POST method, and the -d flag sets request data as Hello and sends it to the website https://example.com/api. The -X flag is the short form of the command line option --request. Check out the above table for learning all the long forms of the various command line options.\n\nLike any HTTP request, POST requests created using cURL can also have custom headers. For specifying the Content-Type header, you’ll have to set it using the header flag.\n\nIn the above command, there’s an additional -H flag which lets users send custom HTTP request headers via cURL. In this case, by specifying the Content-Type header as text/plain you’re letting the web server know that the request body data is in TEXT format.\n\nIt’s also possible to send JSON data in the request body. All you need to do is set the appropriate Content-Type header and pass the JSON data with the -d flag. cURL will make a POST request with the JSON data specified in the argument.\n\nIf you need a straightforward way to create a JSON code from a cURL command, use this cURL to JSON converter.\n\nSimilar to JSON, you can also send XML in the request body. You’ll have to make changes to the request header and set it to application/xml.\n\nTo send a file via cURL POST, you’ll have to use the -F flag. Pay attention to the capitalization of the letter “F”. All of the cURL flags or command line options are case-sensitive.\n\nAs you can see, the above command is uploading an image file. Right after the -F the file path of the image was given. You can also use multiple -F flags to send multiple files to the server as below:\n\nYou can use the -u flag or the --user option to specify the username & password for basic authentication. cURL will automatically create the Authorization header based on your input.\n\nYou’ll have to replace username and password with the actual authentication credentials. Also, don’t forget to replace the example URL with your own.\n\ncURL is a lightweight yet powerful tool for sending POST requests from CLI. With just a single line of command, you can easily transmit data in various formats such as JSON, XML, or file uploads. cURL's simplicity and flexibility make it a popular choice for developers. While it may not offer a graphical interface, cURL provides a versatile and efficient way to interact with servers. Whether you're a seasoned developer or a complete beginner, mastering cURL is a valuable skill that’ll help you in various stages of your career. If you're new to cURL, we recommend reading our article on how to send GET requests with cURL or trying our cURL converter tool.\n\nYou can also check out the How to Use cURL With REST API and How to Use cURL With Python articles available on our blog. Additionally, you can learn how to use cURL OPTIONS requests for web scraping. As usual, if you have any questions, please contact us at hello@oxylabs.io or via the live chat – our professional team is always ready to provide you with the needed assistance."
    }
]