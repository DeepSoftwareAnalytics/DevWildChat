[
    {
        "link": "https://sqlite.org/cintro.html",
        "document": "The following two objects and eight methods comprise the essential elements of the SQLite interface:\n• None sqlite3 → The database connection object. Created by sqlite3_open() and destroyed by sqlite3_close().\n• None sqlite3_stmt → The prepared statement object. Created by sqlite3_prepare() and destroyed by sqlite3_finalize().\n• None sqlite3_open() → Open a connection to a new or existing SQLite database. The constructor for sqlite3.\n• None sqlite3_prepare() → Compile SQL text into byte-code that will do the work of querying or updating the database. The constructor for sqlite3_stmt.\n• None sqlite3_bind() → Store application data into parameters of the original SQL.\n• None sqlite3_step() → Advance an sqlite3_stmt to the next result row or to completion.\n• None sqlite3_column() → Column values in the current result row for an sqlite3_stmt.\n• None sqlite3_exec() → A wrapper function that does sqlite3_prepare(), sqlite3_step(), sqlite3_column(), and sqlite3_finalize() for a string of one or more SQL statements.\n\nSQLite has more than 225 APIs. However, most of the APIs are optional and very specialized and can be ignored by beginners. The core API is small, simple, and easy to learn. This article summarizes the core API.\n\nA separate document, The SQLite C/C++ Interface, provides detailed specifications for all C/C++ APIs for SQLite. Once the reader understands the basic principles of operation for SQLite, that document should be used as a reference guide. This article is intended as introduction only and is neither a complete nor authoritative reference for the SQLite API.\n\nThe principal task of an SQL database engine is to evaluate SQL statements of SQL. To accomplish this, the developer needs two objects:\n\nStrictly speaking, the prepared statement object is not required since the convenience wrapper interfaces, sqlite3_exec or sqlite3_get_table, can be used and these convenience wrappers encapsulate and hide the prepared statement object. Nevertheless, an understanding of prepared statements is needed to make full use of SQLite.\n\nThe database connection and prepared statement objects are controlled by a small set of C/C++ interface routine listed below.\n\nNote that the list of routines above is conceptual rather than actual. Many of these routines come in multiple versions. For example, the list above shows a single routine named sqlite3_open() when in fact there are three separate routines that accomplish the same thing in slightly different ways: sqlite3_open(), sqlite3_open16() and sqlite3_open_v2(). The list mentions sqlite3_column() when in fact no such routine exists. The \"sqlite3_column()\" shown in the list is a placeholder for an entire family of routines that extract column data in various datatypes.\n\nHere is a summary of what the core interfaces do:\n• None This routine opens a connection to an SQLite database file and returns a database connection object. This is often the first SQLite API call that an application makes and is a prerequisite for most other SQLite APIs. Many SQLite interfaces require a pointer to the database connection object as their first parameter and can be thought of as methods on the database connection object. This routine is the constructor for the database connection object.\n• None This routine converts SQL text into a prepared statement object and returns a pointer to that object. This interface requires a database connection pointer created by a prior call to sqlite3_open() and a text string containing the SQL statement to be prepared. This API does not actually evaluate the SQL statement. It merely prepares the SQL statement for evaluation. Think of each SQL statement as a small computer program. The purpose of sqlite3_prepare() is to compile that program into object code. The prepared statement is the object code. The sqlite3_step() interface then runs the object code to get a result. New applications should always invoke sqlite3_prepare_v2() instead of sqlite3_prepare(). The older sqlite3_prepare() is retained for backwards compatibility. But sqlite3_prepare_v2() provides a much better interface.\n• None This routine is used to evaluate a prepared statement that has been previously created by the sqlite3_prepare() interface. The statement is evaluated up to the point where the first row of results are available. To advance to the second row of results, invoke sqlite3_step() again. Continue invoking sqlite3_step() until the statement is complete. Statements that do not return results (ex: INSERT, UPDATE, or DELETE statements) run to completion on a single call to sqlite3_step().\n• None This routine returns a single column from the current row of a result set for a prepared statement that is being evaluated by sqlite3_step(). Each time sqlite3_step() stops with a new result set row, this routine can be called multiple times to find the values of all columns in that row. As noted above, there really is no such thing as a \"sqlite3_column()\" function in the SQLite API. Instead, what we here call \"sqlite3_column()\" is a place-holder for an entire family of functions that return a value from the result set in various data types. There are also routines in this family that return the size of the result (if it is a string or BLOB) and the number of columns in the result set.\n• None This routine destroys a prepared statement created by a prior call to sqlite3_prepare(). Every prepared statement must be destroyed using a call to this routine in order to avoid memory leaks.\n• None This routine closes a database connection previously opened by a call to sqlite3_open(). All prepared statements associated with the connection should be finalized prior to closing the connection.\n\nAn application will typically use sqlite3_open() to create a single database connection during initialization. Note that sqlite3_open() can be used to either open existing database files or to create and open new database files. While many applications use only a single database connection, there is no reason why an application cannot call sqlite3_open() multiple times in order to open multiple database connections - either to the same database or to different databases. Sometimes a multi-threaded application will create separate database connections for each thread. Note that a single database connection can access two or more databases using the ATTACH SQL command, so it is not necessary to have a separate database connection for each database file.\n\nMany applications destroy their database connections using calls to sqlite3_close() at shutdown. Or, for example, an application that uses SQLite as its application file format might open database connections in response to a File/Open menu action and then destroy the corresponding database connection in response to the File/Close menu.\n\nTo run an SQL statement, the application follows these steps:\n• Evaluate the prepared statement by calling sqlite3_step() one or more times.\n• For queries, extract results by calling sqlite3_column() in between two calls to sqlite3_step().\n\nThe foregoing is all one really needs to know in order to use SQLite effectively. All the rest is optimization and detail.\n\nThe sqlite3_exec() interface is a convenience wrapper that carries out all four of the above steps with a single function call. A callback function passed into sqlite3_exec() is used to process each row of the result set. The sqlite3_get_table() is another convenience wrapper that does all four of the above steps. The sqlite3_get_table() interface differs from sqlite3_exec() in that it stores the results of queries in heap memory rather than invoking a callback.\n\nIt is important to realize that neither sqlite3_exec() nor sqlite3_get_table() do anything that cannot be accomplished using the core routines. In fact, these wrappers are implemented purely in terms of the core routines.\n\nIn prior discussion, it was assumed that each SQL statement is prepared once, evaluated, then destroyed. However, SQLite allows the same prepared statement to be evaluated multiple times. This is accomplished using the following routines:\n\nAfter a prepared statement has been evaluated by one or more calls to sqlite3_step(), it can be reset in order to be evaluated again by a call to sqlite3_reset(). Think of sqlite3_reset() as rewinding the prepared statement program back to the beginning. Using sqlite3_reset() on an existing prepared statement rather than creating a new prepared statement avoids unnecessary calls to sqlite3_prepare(). For many SQL statements, the time needed to run sqlite3_prepare() equals or exceeds the time needed by sqlite3_step(). So avoiding calls to sqlite3_prepare() can give a significant performance improvement.\n\nIt is not commonly useful to evaluate the exact same SQL statement more than once. More often, one wants to evaluate similar statements. For example, you might want to evaluate an INSERT statement multiple times with different values. Or you might want to evaluate the same query multiple times using a different key in the WHERE clause. To accommodate this, SQLite allows SQL statements to contain parameters which are \"bound\" to values prior to being evaluated. These values can later be changed and the same prepared statement can be evaluated a second time using the new values.\n\nSQLite allows a parameter wherever a string literal, blob literal, numeric constant, or NULL is allowed in queries or data modification statements. (DQL or DML) (Parameters may not be used for column or table names, or as values for constraints or default values. (DDL)) A parameter takes one of the following forms:\n\nIn the examples above, NNN is an integer value and AAA is an identifier. A parameter initially has a value of NULL. Prior to calling sqlite3_step() for the first time or immediately after sqlite3_reset(), the application can invoke the sqlite3_bind() interfaces to attach values to the parameters. Each call to sqlite3_bind() overrides prior bindings on the same parameter.\n\nAn application is allowed to prepare multiple SQL statements in advance and evaluate them as needed. There is no arbitrary limit to the number of outstanding prepared statements. Some applications call sqlite3_prepare() multiple times at start-up to create all of the prepared statements they will ever need. Other applications keep a cache of the most recently used prepared statements and then reuse prepared statements out of the cache when available. Another approach is to only reuse prepared statements when they are inside of a loop.\n\nThe default configuration for SQLite works great for most applications. But sometimes developers want to tweak the setup to try to squeeze out a little more performance, or take advantage of some obscure feature.\n\nThe sqlite3_config() interface is used to make global, process-wide configuration changes for SQLite. The sqlite3_config() interface must be called before any database connections are created. The sqlite3_config() interface allows the programmer to do things like:\n• Adjust how SQLite does memory allocation, including setting up alternative memory allocators appropriate for safety-critical real-time embedded systems and application-defined memory allocators.\n• Adjust the use of mutexes so that they are appropriate for various threading models, or substitute an application-defined mutex system.\n\nAfter process-wide configuration is complete and database connections have been created, individual database connections can be configured using calls to sqlite3_limit() and sqlite3_db_config().\n\nSQLite includes interfaces that can be used to extend its functionality. Such routines include:\n\nThe sqlite3_create_collation() interface is used to create new collating sequences for sorting text. The sqlite3_create_module() interface is used to register new virtual table implementations. The sqlite3_vfs_register() interface creates new VFSes.\n\nThe sqlite3_create_function() interface creates new SQL functions - either scalar or aggregate. The new function implementation typically makes use of the following additional interfaces:\n\nAll of the built-in SQL functions of SQLite are created using exactly these same interfaces. Refer to the SQLite source code, and in particular the date.c and func.c source files for examples.\n\nShared libraries or DLLs can be used as loadable extensions to SQLite.\n\nThis article only mentions the most important and most commonly used SQLite interfaces. The SQLite library includes many other APIs implementing useful features that are not described here. A complete list of functions that form the SQLite application programming interface is found at the C/C++ Interface Specification. Refer to that document for complete and authoritative information about all SQLite interfaces.\n\nThis page last modified on 2023-10-10 17:29:48 UTC"
    },
    {
        "link": "https://sqlite.org/capi3ref.html",
        "document": "This page is intended to be a precise and detailed specification. For a tutorial introductions, see instead:\n• SQLite In 3 Minutes Or Less and/or\n• the Introduction To The SQLite C/C++ Interface.\n\nSQLite interfaces can be subdivided into three categories:\n\nStable interfaces will be maintained indefinitely in a backwards compatible way. An application that uses only stable interfaces should always be able to relink against a newer version of SQLite without any changes.\n\nExperimental interfaces are subject to change. Applications that use experimental interfaces may need to be modified when upgrading to a newer SQLite release, though this is rare. When new interfaces are added to SQLite, they generally begin as experimental interfaces. After an interface has been in use for a while and the developers are confident that the design of the interface is sound and worthy of long-term support, the interface is marked as stable.\n\nDeprecated interfaces have been superceded by better methods of accomplishing the same thing and should be avoided in new applications. Deprecated interfaces continue to be supported for the sake of backwards compatibility. At some point in the future, it is possible that deprecated interfaces may be removed.\n• Experimental interfaces are subject to change and/or removal at any time.\n• Deprecated interfaces should not be used in new code and might be removed in some future release.\n\nAlso available: list of error codes\n\nNote: Functions marked with \"(exp)\" are experimental and functions whose names are are deprecated.\n\nZero or more of the following constants can be OR-ed together for the F argument to sqlite3_serialize(D,S,P,F).\n\nSQLITE_SERIALIZE_NOCOPY means that sqlite3_serialize() will return a pointer to contiguous in-memory database that it is currently using, without making a copy of the database. If SQLite is not currently using a contiguous in-memory database, then this option causes sqlite3_serialize() to return a NULL pointer. SQLite will only be using a contiguous in-memory database if it has been initialized by a prior call to sqlite3_deserialize().\n\nThe xShmLock method on sqlite3_io_methods may use values between 0 and this upper bound as its \"offset\" argument. The SQLite core will never attempt to acquire or release a lock outside of this range\n\nA pointer to the opaque sqlite3_api_routines structure is passed as the third parameter to entry points of loadable extensions. This structure must be typedefed in order to work around compiler warnings on some platforms.\n\nThe sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to sqlite3_backup_init() and is destroyed by a call to sqlite3_backup_finish().\n\nSee Also: Using the SQLite Online Backup API\n\nThe context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to application-defined SQL functions. The application-defined SQL function implementation will pass this pointer through into calls to sqlite3_result(), sqlite3_aggregate_context(), sqlite3_user_data(), sqlite3_context_db_handle(), sqlite3_get_auxdata(), and/or sqlite3_set_auxdata().\n\nName Of The Folder Holding Database Files\n\nIf this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all database files specified with a relative pathname and created or accessed by SQLite when using a built-in windows VFS will be assumed to be relative to that directory. If this variable is a NULL pointer, then SQLite assumes that all database files specified with a relative pathname are relative to the current directory for the process. Only the windows VFS makes use of this global variable; it is ignored by the unix VFS.\n\nChanging the value of this variable while a database connection is open can result in a corrupt database.\n\nIt is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a database connection is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.\n\nThe data_store_directory pragma may modify this variable and cause it to point to memory obtained from sqlite3_malloc. Furthermore, the data_store_directory pragma always assumes that any string that this variable points to is held in memory obtained from sqlite3_malloc and the pragma may attempt to free that memory using sqlite3_free. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from sqlite3_malloc or else the use of the data_store_directory pragma should be avoided.\n\nAn sqlite3_file object represents an open file in the OS interface layer. Individual OS interface implementations will want to subclass this object by appending additional fields for their own use. The pMethods entry is a pointer to an sqlite3_io_methods object that defines methods for performing I/O operations on the open file.\n\nType sqlite3_filename is used by SQLite to pass filenames to the xOpen method of a VFS. It may be cast to (const char*) and treated as a normal, nul-terminated, UTF-8 buffer containing the filename, but may also be passed to special APIs such as:\n\nThe sqlite3_index_info structure and its substructures is used as part of the virtual table interface to pass information into and receive the reply from the xBestIndex method of a virtual table module. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.\n\nThe aConstraint[] array records WHERE clause constraints of the form:\n\nwhere OP is =, <, <=, >, or >=. The particular operator is stored in aConstraint[].op using one of the SQLITE_INDEX_CONSTRAINT_ values. The index of the column is stored in aConstraint[].iColumn. aConstraint[].usable is TRUE if the expr on the right-hand side can be evaluated (and thus the constraint is usable) and false if it cannot.\n\nThe optimizer automatically inverts terms of the form \"expr OP column\" and makes other simplifications to the WHERE clause in an attempt to get as many WHERE clause terms into the form shown above as possible. The aConstraint[] array only reports WHERE clause terms that are relevant to the particular virtual table being queried.\n\nInformation about the ORDER BY clause is stored in aOrderBy[]. Each term of aOrderBy records a column of the ORDER BY clause.\n\nThe colUsed field indicates which columns of the virtual table may be required by the current scan. Virtual table columns are numbered from zero in the order in which they appear within the CREATE TABLE statement passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62), the corresponding bit is set within the colUsed mask if the column may be required by SQLite. If the table has at least 64 columns and any column to the right of the first 63 is required, then bit 63 of colUsed is also set. In other words, column iCol may be required if the expression (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to non-zero.\n\nThe xBestIndex method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex>0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and might not be checked again by the byte code. The aConstraintUsage[].omit flag is an optimization hint. When the omit flag is left in its default setting of false, the constraint will always be checked separately in byte code. If the omit flag is change to true, then the constraint may or may not be checked in byte code. In other words, when the omit flag is true there is no guarantee that the constraint will not be checked again using byte code.\n\nThe idxNum and idxStr values are recorded and passed into the xFilter method. sqlite3_free() is used to free idxStr if and only if needToFreeIdxStr is true.\n\nThe orderByConsumed means that output from xFilter/xNext will occur in the correct order to satisfy the ORDER BY clause so that no separate sorting step is required.\n\nThe estimatedCost value is an estimate of the cost of a particular strategy. A cost of N indicates that the cost of the strategy is similar to a linear scan of an SQLite table with N rows. A cost of log(N) indicates that the expense of the operation is similar to that of a binary search on a unique indexed field of an SQLite table with N rows.\n\nThe estimatedRows value is an estimate of the number of rows that will be returned by the strategy.\n\nThe xBestIndex method may optionally populate the idxFlags field with a mask of SQLITE_INDEX_SCAN_* flags. One such flag is SQLITE_INDEX_SCAN_HEX, which if set causes the EXPLAIN QUERY PLAN output to show the idxNum has hex instead of as decimal. Another flag is SQLITE_INDEX_SCAN_UNIQUE, which if set indicates that the query plan will return at most one row.\n\nAdditionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then SQLite also assumes that if a call to the xUpdate() method is made as part of the same statement to delete or update a virtual table row and the implementation returns SQLITE_CONSTRAINT, then there is no need to rollback any database changes. In other words, if the xUpdate() returns SQLITE_CONSTRAINT, the database contents must be exactly as they were before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by the xUpdate method are automatically rolled back by SQLite.\n\nIMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite version 3.8.2 (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to include crashing the application). The estimatedRows field should therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for version 3.9.0 (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.\n\nEvery file opened by the sqlite3_vfs.xOpen method populates an sqlite3_file object (or, more commonly, a subclass of the sqlite3_file object) with a pointer to an instance of this object. This object defines the methods used to perform various operations against the open file represented by the sqlite3_file object.\n\nIf the sqlite3_vfs.xOpen method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the sqlite3_vfs.xOpen reported that it failed. The only way to prevent a call to xClose following a failed sqlite3_vfs.xOpen is for the sqlite3_vfs.xOpen to set the sqlite3_file.pMethods element to NULL.\n\nThe flags argument to xSync may be one of SQLITE_SYNC_NORMAL or SQLITE_SYNC_FULL. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The SQLITE_SYNC_DATAONLY flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.\n\nThe integer values to xLock() and xUnlock() are one of\n\nThe xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the sqlite3_file_control() interface. The second \"op\" argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A list of opcodes less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return SQLITE_NOTFOUND for file control opcodes that they do not recognize.\n\nThe xSectorSize() method returns the sector size of the device that underlies the file. The sector size is the minimum write that can be performed without disturbing other bytes in the file. The xDeviceCharacteristics() method returns a bit vector describing behaviors of the underlying device:\n\nThe SQLITE_IOCAP_ATOMIC property means that all writes of any size are atomic. The SQLITE_IOCAP_ATOMICnnn values mean that writes of blocks that are nnn bytes in size and are aligned to an address which is an integer multiple of nnn are atomic. The SQLITE_IOCAP_SAFE_APPEND value means that when data is appended to a file, the data is appended first then the size of the file is extended, never the other way around. The SQLITE_IOCAP_SEQUENTIAL property means that information is written to disk in the same order as calls to xWrite().\n\nIf xRead() returns SQLITE_IOERR_SHORT_READ it must also fill in the unread portions of the buffer with zeros. A VFS that fails to zero-fill short reads might seem to work. However, failure to zero-fill short reads will eventually lead to database corruption.\n\nAn instance of this object defines the interface between SQLite and low-level memory allocation routines.\n\nThis object is used in only one place in the SQLite interface. A pointer to an instance of this object is the argument to sqlite3_config() when the configuration option is SQLITE_CONFIG_MALLOC or SQLITE_CONFIG_GETMALLOC. By creating an instance of this object and passing it to sqlite3_config(SQLITE_CONFIG_MALLOC) during configuration, an application can specify an alternative memory allocation subsystem for SQLite to use for all of its dynamic memory needs.\n\nNote that SQLite comes with several built-in memory allocators that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.\n\nThe xMalloc, xRealloc, and xFree methods must work like the malloc(), realloc() and free() functions from the standard C library. SQLite guarantees that the second argument to xRealloc is always a value returned by a prior call to xRoundup.\n\nxSize should return the allocated size of a memory allocation previously obtained from xMalloc or xRealloc. The allocated size is always at least as big as the requested size but may be larger.\n\nThe xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through sqlite3_malloc() or sqlite3_realloc() first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.\n\nThe xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by sqlite3_shutdown() and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.\n\nSQLite holds the SQLITE_MUTEX_STATIC_MAIN mutex when it invokes the xInit method, so the xInit method need not be threadsafe. The xShutdown method is only called from sqlite3_shutdown() so it does not need to be threadsafe either. For all other methods, SQLite holds the SQLITE_MUTEX_STATIC_MEM mutex as long as the SQLITE_CONFIG_MEMSTATUS configuration option is turned on (which it is by default) and so the methods are automatically serialized. However, if SQLITE_CONFIG_MEMSTATUS is disabled, then the other methods must be threadsafe or else make their own arrangements for serialization.\n\nSQLite will never invoke xInit() more than once without an intervening call to xShutdown().\n\nThe mutex module within SQLite defines sqlite3_mutex to be an abstract type for a mutex object. The SQLite core never looks at the internal representation of an sqlite3_mutex. It only deals with pointers to the sqlite3_mutex object.\n\nAn instance of this structure defines the low-level routines used to allocate and use mutexes.\n\nUsually, the default mutex implementations provided by SQLite are sufficient, however the application has the option of substituting a custom implementation for specialized deployments or systems for which SQLite does not provide a suitable implementation. In this case, the application creates and populates an instance of this structure to pass to sqlite3_config() along with the SQLITE_CONFIG_MUTEX option. Additionally, an instance of this structure can be used as an output variable when querying the system for the current mutex implementation, using the SQLITE_CONFIG_GETMUTEX option.\n\nThe xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to sqlite3_initialize().\n\nThe xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to sqlite3_shutdown().\n\nThe remaining seven methods defined by this structure (xMutexAlloc, xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and xMutexNotheld) implement the following interfaces (respectively):\n\nThe only difference is that the public sqlite3_XXX functions enumerated above silently ignore any invocations that pass a NULL pointer instead of a valid mutex handle. The implementations of the methods defined by this structure are not required to handle this case. The results of passing a NULL pointer instead of a valid mutex handle are undefined (i.e. it is acceptable to provide an implementation that segfaults if it is passed a NULL pointer).\n\nThe xMutexInit() method must be threadsafe. It must be harmless to invoke xMutexInit() multiple times within the same process and without intervening calls to xMutexEnd(). Second and subsequent calls to xMutexInit() must be no-ops.\n\nxMutexInit() must not use SQLite memory allocation (sqlite3_malloc() and its associates). Similarly, xMutexAlloc() must not use SQLite memory allocation for a static mutex. However xMutexAlloc() may use SQLite memory allocation for a fast or recursive mutex.\n\nSQLite will invoke the xMutexEnd() method when sqlite3_shutdown() is called, but only if the prior call to xMutexInit returned SQLITE_OK. If xMutexInit fails in any way, it is expected to clean up after itself prior to returning.\n\nThe sqlite3_pcache type is opaque. It is implemented by the pluggable module. The SQLite core has no knowledge of its size or internal structure and never deals with the sqlite3_pcache object except by holding and passing pointers to the object.\n\nThe sqlite3_pcache_page object represents a single page in the page cache. The page cache will allocate instances of this object. Various methods of the page cache use pointers to instances of this object as parameters or as their return value.\n\nName Of The Folder Holding Temporary Files\n\nIf this global variable is made to point to a string which is the name of a folder (a.k.a. directory), then all temporary files created by SQLite when using a built-in VFS will be placed in that directory. If this variable is a NULL pointer, then SQLite performs a search for an appropriate temporary file directory.\n\nApplications are strongly discouraged from using this global variable. It is required to set a temporary folder on Windows Runtime (WinRT). But for all other platforms, it is highly recommended that applications neither read nor write this variable. This global variable is a relic that exists for backwards compatibility of legacy applications and should be avoided in new projects.\n\nIt is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a database connection is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.\n\nThe temp_store_directory pragma may modify this variable and cause it to point to memory obtained from sqlite3_malloc. Furthermore, the temp_store_directory pragma always assumes that any string that this variable points to is held in memory obtained from sqlite3_malloc and the pragma may attempt to free that memory using sqlite3_free. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from sqlite3_malloc or else the use of the temp_store_directory pragma should be avoided. Except when requested by the temp_store_directory pragma, SQLite does not free the memory that sqlite3_temp_directory points to. If the application wants that memory to be freed, it must do so itself, taking care to only do so after all database connection objects have been destroyed.\n\nNote to Windows Runtime users: The temporary directory must be set prior to calling sqlite3_open or sqlite3_open_v2. Otherwise, various features that require the use of temporary files may fail. Here is an example of how to do this using C++ with the Windows Runtime:\n\nAn instance of the sqlite3_vfs object defines the interface between the SQLite core and the underlying operating system. The \"vfs\" in the name of the object stands for \"virtual file system\". See the VFS documentation for further information.\n\nThe VFS interface is sometimes extended by adding new methods onto the end. Each time such an extension occurs, the iVersion field is incremented. The iVersion value started out as 1 in SQLite version 3.5.0 on 2007-09-04, then increased to 2 with SQLite version 3.7.0 on 2010-07-21, and then increased to 3 with SQLite version 3.7.6 on 2011-04-12. Additional fields may be appended to the sqlite3_vfs object and the iVersion value may increase again in future versions of SQLite. Note that due to an oversight, the structure of the sqlite3_vfs object changed in the transition from SQLite version 3.5.9 to version 3.6.0 on 2008-07-16 and yet the iVersion field was not increased.\n\nThe szOsFile field is the size of the subclassed sqlite3_file structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.\n\nRegistered sqlite3_vfs objects are kept on a linked list formed by the pNext pointer. The sqlite3_vfs_register() and sqlite3_vfs_unregister() interfaces manage this list in a thread-safe way. The sqlite3_vfs_find() interface searches the list. Neither the application code nor the VFS implementation should use the pNext pointer.\n\nThe pNext field is the only field in the sqlite3_vfs structure that SQLite will ever modify. SQLite will only access or modify this field while holding a particular static mutex. The application should never modify anything within the sqlite3_vfs object once the object has been registered.\n\nThe zName field holds the name of the VFS module. The name must be unique across all VFS modules.\n\nSQLite guarantees that the zFilename parameter to xOpen is either a NULL pointer or string obtained from xFullPathname() with an optional suffix added. If a suffix is added to the zFilename parameter, it will consist of a single \"-\" character followed by no more than 11 alphanumeric and/or \"-\" characters. SQLite further guarantees that the string will be valid and unchanged until xClose() is called. Because of the previous sentence, the sqlite3_file can safely store a pointer to the filename if it needs to remember the filename for some reason. If the zFilename parameter to xOpen is a NULL pointer then xOpen must invent its own temporary name for the file. Whenever the xFilename parameter is NULL it will also be the case that the flags parameter will include SQLITE_OPEN_DELETEONCLOSE.\n\nThe flags argument to xOpen() includes all bits set in the flags argument to sqlite3_open_v2(). Or if sqlite3_open() or sqlite3_open16() is used, then flags includes at least SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE. If xOpen() opens a file read-only then it sets *pOutFlags to include SQLITE_OPEN_READONLY. Other bits in *pOutFlags may be set.\n\nSQLite will also add one of the following flags to the xOpen() call, depending on the object being opened:\n\nThe file I/O implementation can use the object type flags to change the way it deals with files. For example, an application that does not care about crash recovery or rollback might make the open of a journal file a no-op. Writes to this journal would also be no-ops, and any attempt to read the journal would return SQLITE_IOERR. Or the implementation might recognize that a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly.\n\nSQLite might also add one of the following flags to the xOpen method:\n\nThe SQLITE_OPEN_DELETEONCLOSE flag means the file should be deleted when it is closed. The SQLITE_OPEN_DELETEONCLOSE will be set for TEMP databases and their journals, transient databases, and subjournals.\n\nThe SQLITE_OPEN_EXCLUSIVE flag is always used in conjunction with the SQLITE_OPEN_CREATE flag, which are both directly analogous to the O_EXCL and O_CREAT flags of the POSIX open() API. The SQLITE_OPEN_EXCLUSIVE flag, when paired with the SQLITE_OPEN_CREATE, is used to indicate that file should always be created, and that it is an error if it already exists. It is not used to indicate the file should be opened for exclusive access.\n\nAt least szOsFile bytes of memory are allocated by SQLite to hold the sqlite3_file structure passed as the third argument to xOpen. The xOpen method does not have to allocate the structure; it should just fill it in. Note that the xOpen method must set the sqlite3_file.pMethods to either a valid sqlite3_io_methods object or to NULL. xOpen must do this even if the open fails. SQLite expects that the sqlite3_file.pMethods element will be valid after xOpen returns regardless of the success or failure of the xOpen call.\n\nThe flags argument to xAccess() may be SQLITE_ACCESS_EXISTS to test for the existence of a file, or SQLITE_ACCESS_READWRITE to test whether a file is readable and writable, or SQLITE_ACCESS_READ to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns SQLITE_OK on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.\n\nSQLite will always allocate at least mxPathname+1 bytes for the output buffer xFullPathname. The exact size of the output buffer is also passed as a parameter to both methods. If the output buffer is not large enough, SQLITE_CANTOPEN should be returned. Since this is handled as a fatal error by SQLite, vfs implementations should endeavor to prevent this by setting mxPathname to a sufficiently large value.\n\nThe xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64() interfaces are not strictly a part of the filesystem, but they are included in the VFS structure for completeness. The xRandomness() function attempts to return nBytes bytes of good-quality randomness into zOut. The return value is the actual number of bytes of randomness obtained. The xSleep() method causes the calling thread to sleep for at least the number of microseconds given. The xCurrentTime() method returns a Julian Day Number for the current date and time as a floating point value. The xCurrentTimeInt64() method returns, as an integer, the Julian Day Number multiplied by 86400000 (the number of milliseconds in a 24-hour day). SQLite will use the xCurrentTimeInt64() method to get the current date and time if that method is available (if iVersion is 2 or greater and the function pointer is not NULL) and will fall back to xCurrentTime() if xCurrentTimeInt64() is unavailable.\n\nThe xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces are not used by the SQLite core. These optional interfaces are provided by some VFSes to facilitate testing of the VFS code. By overriding system calls with functions under its control, a test program can simulate faults and error conditions that would otherwise be difficult or impossible to induce. The set of system calls that can be overridden varies from one VFS to another, and from one version of the same VFS to the next. Applications that use these interfaces must be prepared for any or all of these interfaces to be NULL or for their behavior to change from one release to the next. Applications must not attempt to access any of these methods if the iVersion of the VFS is less than 3.\n\nEvery virtual table module implementation uses a subclass of this object to describe a particular instance of the virtual table. Each subclass will be tailored to the specific needs of the module implementation. The purpose of this superclass is to define certain fields that are common to all module implementations.\n\nVirtual tables methods can set an error message by assigning a string obtained from sqlite3_mprintf() to zErrMsg. The method should take care that any prior string is freed by a call to sqlite3_free() prior to assigning a new string to zErrMsg. After the error message is delivered up to the client application, the string will be automatically freed by sqlite3_free() and the zErrMsg field will be zeroed.\n\nImplementations of aggregate SQL functions use this routine to allocate memory for storing their state.\n\nThe first time the sqlite3_aggregate_context(C,N) routine is called for a particular aggregate function, SQLite allocates N bytes of memory, zeroes out that memory, and returns a pointer to the new memory. On second and subsequent calls to sqlite3_aggregate_context() for the same aggregate function instance, the same buffer is returned. Sqlite3_aggregate_context() is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked. When no rows match an aggregate query, the xStep() callback of the aggregate function implementation is never called and xFinal() is called exactly once. In those cases, sqlite3_aggregate_context() might be called for the first time from within xFinal().\n\nThe sqlite3_aggregate_context(C,N) routine returns a NULL pointer when first called if N is less than or equal to zero or if a memory allocation error occurs.\n\nThe amount of space allocated by sqlite3_aggregate_context(C,N) is determined by the N parameter on first successful call. Changing the value of N in any subsequent call to sqlite3_aggregate_context() within the same aggregate function instance will not resize the memory allocation. Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.\n\nSQLite automatically frees the memory allocated by sqlite3_aggregate_context() when the aggregate query concludes.\n\nThe first parameter must be a copy of the SQL function context that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.\n\nThis routine must be called from the same thread in which the aggregate SQL function is running.\n\nThis interface causes the xEntryPoint() function to be invoked for each new database connection that is created. The idea here is that xEntryPoint() is the entry point for a statically linked SQLite extension that is to be automatically loaded into all new database connections.\n\nEven though the function prototype shows that xEntryPoint() takes no arguments and returns void, SQLite invokes xEntryPoint() with three arguments and expects an integer result as if the signature of the entry point where as follows:\n\nIf the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from sqlite3_mprintf()) and return an appropriate error code. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke sqlite3_free() on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the sqlite3_open(), sqlite3_open16(), or sqlite3_open_v2() call that provoked the xEntryPoint() will fail.\n\nCalling sqlite3_auto_extension(X) with an entry point X that is already on the list of automatic extensions is a harmless no-op. No entry point will be called more than once for each database connection that is opened.\n\nSee also: sqlite3_reset_auto_extension() and sqlite3_cancel_auto_extension()\n\nThe sqlite3_autovacuum_pages(D,C,P,X) interface registers a callback function C that is invoked prior to each autovacuum of the database file. The callback is passed a copy of the generic data pointer (P), the schema-name of the attached database that is being autovacuumed, the size of the database file in pages, the number of free pages, and the number of bytes per page, respectively. The callback should return the number of free pages that should be removed by the autovacuum. If the callback returns zero, then no autovacuum happens. If the value returned is greater than or equal to the number of free pages, then a complete autovacuum happens.\n\nIf there are multiple ATTACH-ed database files that are being modified as part of a transaction commit, then the autovacuum pages callback is invoked separately for each file.\n\nThe callback is not reentrant. The callback function should not attempt to invoke any other SQLite interface. If it does, bad things may happen, including segmentation faults and corrupt database files. The callback function should be a simple function that does some arithmetic on its input parameters and returns a result.\n\nThe X parameter to sqlite3_autovacuum_pages(D,C,P,X) is an optional destructor for the P parameter. If X is not NULL, then X(P) is invoked whenever the database connection closes or when the callback is overwritten by another invocation of sqlite3_autovacuum_pages().\n\nThere is only one autovacuum pages callback per database connection. Each call to the sqlite3_autovacuum_pages() interface overrides all previous invocations for that database connection. If the callback argument (C) to sqlite3_autovacuum_pages(D,C,P,X) is a NULL pointer, then the autovacuum steps callback is canceled. The return value from sqlite3_autovacuum_pages() is normally SQLITE_OK, but might be some other error code if something goes wrong. The current implementation will only return SQLITE_OK or SQLITE_MISUSE, but other return codes might be added in future releases.\n\nIf no autovacuum pages callback is specified (the usual case) or a NULL pointer is provided for the callback, then the default behavior is to vacuum all free pages. So, in other words, the default behavior is the same as if the callback function were something like this:\n\nThis routine can be used to find the number of SQL parameters in a prepared statement. SQL parameters are tokens of the form \"?\", \"?NNN\", \":AAA\", \"$AAA\", or \"@AAA\" that serve as placeholders for values that are bound to the parameters at a later time.\n\nThis routine actually returns the index of the largest (rightmost) parameter. For all forms except ?NNN, this will correspond to the number of unique parameters. If parameters of the ?NNN form are used, there may be gaps in the list.\n\nSee also: sqlite3_bind(), sqlite3_bind_parameter_name(), and sqlite3_bind_parameter_index().\n\nIndex Of A Parameter With A Given Name\n\nReturn the index of an SQL parameter given its name. The index value returned is suitable for use as the second parameter to sqlite3_bind(). A zero is returned if no matching parameter is found. The parameter name must be given in UTF-8 even if the original statement was prepared from UTF-16 text using sqlite3_prepare16_v2() or sqlite3_prepare16_v3().\n\nSee also: sqlite3_bind(), sqlite3_bind_parameter_count(), and sqlite3_bind_parameter_name().\n\nThe sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively. In other words, the initial \":\" or \"$\" or \"@\" or \"?\" is included as part of the name. Parameters of the form \"?\" without a following integer have no name and are referred to as \"nameless\" or \"anonymous parameters\".\n\nThe first host parameter has an index of 1, not 0.\n\nIf the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in sqlite3_prepare16(), sqlite3_prepare16_v2(), or sqlite3_prepare16_v3().\n\nSee also: sqlite3_bind(), sqlite3_bind_parameter_count(), and sqlite3_bind_parameter_index().\n\nReturn The Size Of An Open BLOB\n\nReturns the size in bytes of the BLOB accessible via the successfully opened BLOB handle in its only argument. The incremental blob I/O routines can only read or overwriting existing blob content; they cannot change the size of a blob.\n\nThis routine only works on a BLOB handle which has been created by a prior successful call to sqlite3_blob_open() and which has not been closed by sqlite3_blob_close(). Passing any other pointer in to this routine results in undefined and probably undesirable behavior.\n\nThis function closes an open BLOB handle. The BLOB handle is closed unconditionally. Even if this routine returns an error code, the handle is still closed.\n\nIf the blob handle being closed was opened for read-write access, and if the database is in auto-commit mode and there are no other open read-write blob handles or active write statements, the current transaction is committed. If an error occurs while committing the transaction, an error code is returned and the transaction rolled back.\n\nCalling this function with an argument that is not a NULL pointer or an open blob handle results in undefined behavior. Calling this routine with a null pointer (such as would be returned by a failed call to sqlite3_blob_open()) is a harmless no-op. Otherwise, if this function is passed a valid open blob handle, the values returned by the sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.\n\nThis interfaces opens a handle to the BLOB located in row iRow, column zColumn, table zTable in database zDb; in other words, the same BLOB that would be selected by:\n\nParameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the ATTACH statement. For the main database file, the database name is \"main\". For TEMP tables, the database name is \"temp\".\n\nIf the flags parameter is non-zero, then the BLOB is opened for read and write access. If the flags parameter is zero, the BLOB is opened for read-only access.\n\nOn success, SQLITE_OK is returned and the new BLOB handle is stored in *ppBlob. Otherwise an error code is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call sqlite3_blob_close() on *ppBlob after this function it returns.\n\nThis function fails with SQLITE_ERROR if any of the following are true:\n• Table zTable does not exist within database zDb,\n• Row iRow is not present in the table,\n• The specified column of row iRow contains a value that is not a TEXT or BLOB value,\n• Column zColumn is part of an index, PRIMARY KEY or UNIQUE constraint and the blob is being opened for read/write access,\n• Foreign key constraints are enabled, column zColumn is part of a child key definition and the blob is being opened for read/write access.\n\nUnless it returns SQLITE_MISUSE, this function sets the database connection error code and message accessible via sqlite3_errcode() and sqlite3_errmsg() and related functions.\n\nA BLOB referenced by sqlite3_blob_open() may be read using the sqlite3_blob_read() interface and modified by using sqlite3_blob_write(). The BLOB handle can be moved to a different row of the same table using the sqlite3_blob_reopen() interface. However, the column, table, or database of a BLOB handle cannot be changed after the BLOB handle is opened.\n\nIf the row that a BLOB handle points to is modified by an UPDATE, DELETE, or by ON CONFLICT side-effects then the BLOB handle is marked as \"expired\". This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to sqlite3_blob_read() and sqlite3_blob_write() for an expired BLOB handle fail with a return code of SQLITE_ABORT. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.\n\nUse the sqlite3_blob_bytes() interface to determine the size of the opened blob. The size of a blob may not be changed by this interface. Use the UPDATE SQL command to change the size of a blob.\n\nThe sqlite3_bind_zeroblob() and sqlite3_result_zeroblob() interfaces and the built-in zeroblob SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.\n\nTo avoid a resource leak, every open BLOB handle should eventually be released by a call to sqlite3_blob_close().\n\nThis function is used to read data from an open BLOB handle into a caller-supplied buffer. N bytes of data are copied into buffer Z from the open BLOB, starting at offset iOffset.\n\nIf offset iOffset is less than N bytes from the end of the BLOB, SQLITE_ERROR is returned and no data is read. If N or iOffset is less than zero, SQLITE_ERROR is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the sqlite3_blob_bytes() interface.\n\nAn attempt to read from an expired BLOB handle fails with an error code of SQLITE_ABORT.\n\nOn success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an error code or an extended error code is returned.\n\nThis routine only works on a BLOB handle which has been created by a prior successful call to sqlite3_blob_open() and which has not been closed by sqlite3_blob_close(). Passing any other pointer in to this routine results in undefined and probably undesirable behavior.\n\nThis function is used to move an existing BLOB handle so that it points to a different row of the same database table. The new row is identified by the rowid value passed as the second argument. Only the row can be changed. The database, table and column on which the blob handle is open remain the same. Moving an existing BLOB handle to a new row is faster than closing the existing handle and opening a new one.\n\nThe new row must meet the same criteria as for sqlite3_blob_open() - it must exist and there must be either a blob or text value stored in the nominated column. If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code is returned and the blob handle is considered aborted. All subsequent calls to sqlite3_blob_read(), sqlite3_blob_write() or sqlite3_blob_reopen() on an aborted blob handle immediately return SQLITE_ABORT. Calling sqlite3_blob_bytes() on an aborted blob handle always returns zero.\n\nThis function sets the database handle error code and message.\n\nThis function is used to write data into an open BLOB handle from a caller-supplied buffer. N bytes of data are copied from the buffer Z into the open BLOB, starting at offset iOffset.\n\nOn success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an error code or an extended error code is returned. Unless SQLITE_MISUSE is returned, this function sets the database connection error code and message accessible via sqlite3_errcode() and sqlite3_errmsg() and related functions.\n\nIf the BLOB handle passed as the first argument was not opened for writing (the flags parameter to sqlite3_blob_open() was zero), this function returns SQLITE_READONLY.\n\nThis function may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API. If offset iOffset is less than N bytes from the end of the BLOB, SQLITE_ERROR is returned and no data is written. The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the sqlite3_blob_bytes() interface. If N or iOffset are less than zero SQLITE_ERROR is returned and no data is written.\n\nAn attempt to write to an expired BLOB handle fails with an error code of SQLITE_ABORT. Writes to the BLOB that occurred before the BLOB handle expired are not rolled back by the expiration of the handle, though of course those changes might have been overwritten by the statement that expired the BLOB handle or by other independent statements.\n\nThis routine only works on a BLOB handle which has been created by a prior successful call to sqlite3_blob_open() and which has not been closed by sqlite3_blob_close(). Passing any other pointer in to this routine results in undefined and probably undesirable behavior.\n\nThis routine sets a busy handler that sleeps for a specified amount of time when a table is locked. The handler will sleep multiple times until at least \"ms\" milliseconds of sleeping have accumulated. After at least \"ms\" milliseconds of sleeping, the handler returns 0 which causes sqlite3_step() to return SQLITE_BUSY.\n\nCalling this routine with an argument less than or equal to zero turns off all busy handlers.\n\nThere can only be a single busy handler for a particular database connection at any given moment. If another busy handler was defined (using sqlite3_busy_handler()) prior to calling this routine, that other busy handler is cleared.\n\nThe sqlite3_cancel_auto_extension(X) interface unregisters the initialization routine X that was registered using a prior call to sqlite3_auto_extension(X). The sqlite3_cancel_auto_extension(X) routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.\n\nContrary to the intuition of many, sqlite3_reset() does not reset the bindings on a prepared statement. Use this routine to reset all host parameters to NULL.\n\nReturn the number of columns in the result set returned by the prepared statement. If this routine returns 0, that means the prepared statement returns no data (for example an UPDATE). However, just because this routine returns a positive number does not mean that one or more rows of data will be returned. A SELECT statement will always have a positive sqlite3_column_count() but depending on the WHERE clause constraints and the table content, it might return no rows.\n\nThe sqlite3_config() interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application. The default configuration is recommended for most applications and so this routine is usually not necessary. It is provided to support rare applications with unusual needs.\n\nThe sqlite3_config() interface is not threadsafe. The application must ensure that no other SQLite interfaces are invoked by other threads while sqlite3_config() is running.\n\nThe first argument to sqlite3_config() is an integer configuration option that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the configuration option in the first argument.\n\nFor most configuration options, the sqlite3_config() interface may only be invoked prior to library initialization using sqlite3_initialize() or after shutdown by sqlite3_shutdown(). The exceptional configuration options that may be invoked at any time are called \"anytime configuration options\". If sqlite3_config() is called after sqlite3_initialize() and before sqlite3_shutdown() with a first argument that is not an anytime configuration option, then the sqlite3_config() call will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined sqlite3_os_init().\n\nWhen a configuration option is set, sqlite3_config() returns SQLITE_OK. If the option is unknown or SQLite is unable to set the option then this routine returns a non-zero error code.\n\nThe sqlite3_context_db_handle() interface returns a copy of the pointer to the database connection (the 1st parameter) of the sqlite3_create_function() and sqlite3_create_function16() routines that originally registered the application defined function.\n\nThe sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of prepared statement P. If prepared statement P does not have results ready to return (via calls to the sqlite3_column() family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to sqlite3_step(P) returned SQLITE_DONE. The sqlite3_data_count(P) will return non-zero if previous call to sqlite3_step(P) returned SQLITE_ROW, except in the case of the PRAGMA incremental_vacuum where it always returns zero since each step of that multi-step pragma returns 0 columns of data.\n\nIf X is the name of a rollback or WAL-mode journal file that is passed into the xOpen method of sqlite3_vfs, then sqlite3_database_file_object(X) returns a pointer to the sqlite3_file object that represents the main database file.\n\nThis routine is intended for use in custom VFS implementations only. It is not a general-purpose interface. The argument sqlite3_file_object(X) must be a filename pointer that has been passed into sqlite3_vfs.xOpen method where the flags parameter to xOpen contains one of the bits SQLITE_OPEN_MAIN_JOURNAL or SQLITE_OPEN_WAL. Any other use of this routine results in undefined and probably undesirable behavior.\n\nIf a write-transaction is open on database connection D when the sqlite3_db_cacheflush(D) interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always \"in use\"). The sqlite3_db_cacheflush(D) interface flushes caches for all schemas - \"main\", \"temp\", and any attached databases.\n\nIf this function needs to obtain extra database locks before dirty pages can be flushed to disk, it does so. If those locks cannot be obtained immediately and there is a busy-handler callback configured, it is invoked in the usual manner. If the required lock still cannot be obtained, then the database is skipped and an attempt made to flush any dirty pages belonging to the next (if any) database. If any databases are skipped because locks cannot be obtained, but no other error occurs, this function returns SQLITE_BUSY.\n\nIf any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite error code is returned to the caller immediately.\n\nOtherwise, if no error occurs, sqlite3_db_cacheflush() returns SQLITE_OK.\n\nThis function does not set the database handle error code or message returned by the sqlite3_errcode() and sqlite3_errmsg() functions.\n\nThe sqlite3_db_config() interface is used to make configuration changes to a database connection. The interface is similar to sqlite3_config() except that the changes apply to a single database connection (specified in the first argument).\n\nThe second argument to sqlite3_db_config(D,V,...) is the configuration verb - an integer code that indicates what aspect of the database connection is being configured. Subsequent arguments vary depending on the configuration verb.\n\nCalls to sqlite3_db_config() return SQLITE_OK if and only if the call is considered successful.\n\nThe sqlite3_db_filename(D,N) interface returns a pointer to the filename associated with database N of connection D. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.\n\nThe string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is DETACH-ed or until the database connection closes.\n\nThe filename returned by this function is the output of the xFullPathname method of the VFS. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.\n\nIf the filename pointer returned by this routine is not NULL, then it can be used as the filename input parameter to these routines:\n\nThe sqlite3_db_handle interface returns the database connection handle to which a prepared statement belongs. The database connection returned by sqlite3_db_handle is the same database connection that was the first argument to the sqlite3_prepare_v2() call (or its variants) that was used to create the statement in the first place.\n\nThis interface returns a pointer the sqlite3_mutex object that serializes access to the database connection given in the argument when the threading mode is Serialized. If the threading mode is Single-thread or Multi-thread then this routine returns a NULL pointer.\n\nReturn The Schema Name For A Database Connection\n\nThe sqlite3_db_name(D,N) interface returns a pointer to the schema name for the N-th database on database connection D, or a NULL pointer of N is out of range. An N value of 0 means the main database file. An N of 1 is the \"temp\" schema. Larger values of N correspond to various ATTACH-ed databases.\n\nSpace to hold the string that is returned by sqlite3_db_name() is managed by SQLite itself. The string might be deallocated by any operation that changes the schema, including ATTACH or DETACH or calls to sqlite3_serialize() or sqlite3_deserialize(), even operations that occur on a different thread. Applications that need to remember the string long-term should make their own copy. Applications that are accessing the same database connection simultaneously on multiple threads should mutex-protect calls to this API and should make their own private copy of the result prior to releasing the mutex.\n\nThe sqlite3_db_readonly(D,N) interface returns 1 if the database N of connection D is read-only, 0 if it is read/write, or -1 if N is not the name of a database on connection D.\n\nThe sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the sqlite3_release_memory() interface, this interface is in effect even when the SQLITE_ENABLE_MEMORY_MANAGEMENT compile-time option is omitted.\n\nThis interface is used to retrieve runtime status information about a single database connection. The first argument is the database connection object to be interrogated. The second argument is an integer constant, taken from the set of SQLITE_DBSTATUS options, that determines the parameter to interrogate. The set of SQLITE_DBSTATUS options is likely to grow in future releases of SQLite.\n\nThe current value of the requested parameter is written into *pCur and the highest instantaneous value is written into *pHiwtr. If the resetFlg is true, then the highest instantaneous value is reset back down to the current value.\n\nThe sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero error code on failure.\n\nSee also: sqlite3_status() and sqlite3_stmt_status().\n\nThe xCreate and xConnect methods of a virtual table module call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.\n\nThe sqlite3_deserialize(D,S,P,N,M,F) interface causes the database connection D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.\n\nIf the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in F, then SQLite will invoke sqlite3_free() on the serialization buffer when the database connection closes. If the SQLITE_DESERIALIZE_RESIZEABLE bit is set, then SQLite will try to increase the buffer size using sqlite3_realloc64() if writes on the database cause it to grow larger than M bytes.\n\nApplications must not modify the buffer P or invalidate it before the database connection D is closed.\n\nThe sqlite3_deserialize() interface will fail with SQLITE_BUSY if the database is currently in a read transaction or is involved in a backup operation.\n\nIt is not possible to deserialized into the TEMP database. If the S argument to sqlite3_deserialize(D,S,P,N,M,F) is \"temp\" then the function returns SQLITE_ERROR.\n\nThe deserialized database should not be in WAL mode. If the database is in WAL mode, then any attempt to use the database file will result in an SQLITE_CANTOPEN error. The application can set the file format version numbers (bytes 18 and 19) of the input database P to 0x01 prior to invoking sqlite3_deserialize(D,S,P,N,M,F) to force the database file into rollback mode and work around this limitation.\n\nIf sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then sqlite3_free() is invoked on argument P prior to returning.\n\nThis interface is omitted if SQLite is compiled with the SQLITE_OMIT_DESERIALIZE option.\n\nThe sqlite3_drop_modules(D,L) interface removes all virtual table modules from database connection D except those named on list L. The L parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer. If the L parameter is NULL, then all virtual table modules are removed.\n\nSo as not to open security holes in older applications that are unprepared to deal with extension loading, and as a means of disabling extension loading while evaluating user-entered SQL, the following API is provided to turn the sqlite3_load_extension() mechanism on and off.\n\nExtension loading is off by default. Call the sqlite3_enable_load_extension() routine with onoff==1 to turn extension loading on and call it with onoff==0 to turn it back off again.\n\nThis interface enables or disables both the C-API sqlite3_load_extension() and the SQL function load_extension(). Use sqlite3_db_config(db,SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION,..) to enable or disable only the C-API.\n\nSecurity warning: It is recommended that extension loading be enabled using the SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION method rather than this interface, so the load_extension() SQL function remains disabled. This will prevent SQL injections from giving attackers access to extension loading capabilities.\n\nThis routine enables or disables the sharing of the database cache and schema data structures between connections to the same database. Sharing is enabled if the argument is true and disabled if the argument is false.\n\nThis interface is omitted if SQLite is compiled with -DSQLITE_OMIT_SHARED_CACHE. The -DSQLITE_OMIT_SHARED_CACHE compile-time option is recommended because the use of shared cache mode is discouraged.\n\nCache sharing is enabled and disabled for an entire process. This is a change as of SQLite version 3.5.0 (2007-09-04). In prior versions of SQLite, sharing was enabled or disabled for each thread separately.\n\nThe cache sharing mode set by this interface effects all subsequent calls to sqlite3_open(), sqlite3_open_v2(), and sqlite3_open16(). Existing database connections continue to use the sharing mode that was in effect at the time they were opened.\n\nThis routine returns SQLITE_OK if shared cache was enabled or disabled successfully. An error code is returned otherwise.\n\nShared cache is disabled by default. It is recommended that it stay that way. In other words, do not use this routine. This interface continues to be provided for historical compatibility, but its use is discouraged. Any use of shared cache is discouraged. If shared cache must be used, it is recommended that shared cache only be enabled for individual database connections using the sqlite3_open_v2() interface with the SQLITE_OPEN_SHAREDCACHE flag.\n\nNote: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via sqlite3_open_v2() with SQLITE_OPEN_SHAREDCACHE.\n\nThis interface is threadsafe on processors where writing a 32-bit integer is atomic.\n\nThe sqlite3_exec() interface is a convenience wrapper around sqlite3_prepare_v2(), sqlite3_step(), and sqlite3_finalize(), that allows an application to run multiple statements of SQL without having to use a lot of C code.\n\nThe sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the database connection passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.\n\nIf an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from sqlite3_malloc() and passed back through the 5th parameter. To avoid memory leaks, the application should invoke sqlite3_free() on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.\n\nIf an sqlite3_exec() callback returns non-zero, the sqlite3_exec() routine returns SQLITE_ABORT without invoking the callback again and without running any subsequent SQL statements.\n\nThe 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from sqlite3_column_text(), one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from sqlite3_column_name().\n\nIf the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer to an empty string, or a pointer that contains only whitespace and/or SQL comments, then no SQL statements are evaluated and the database is not changed.\n• The application must ensure that the 1st parameter to sqlite3_exec() is a valid and open database connection.\n• The application must not close the database connection specified by the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.\n• The application must not modify the SQL statement text passed into the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.\n• The application must not dereference the arrays or string pointers passed as the 3rd and 4th callback parameters after it returns.\n\nThe sqlite3_extended_result_codes() routine enables or disables the extended result codes feature of SQLite. The extended result codes are disabled by default for historical compatibility.\n\nThe sqlite3_finalize() function is called to delete a prepared statement. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate error code or extended error code.\n\nThe sqlite3_finalize(S) routine can be called at any point during the life cycle of prepared statement S: before statement S is ever evaluated, after one or more calls to sqlite3_reset(), or after any call to sqlite3_step() regardless of whether or not the statement has completed execution.\n\nThe application must finalize every prepared statement in order to avoid resource leaks. It is a grievous error for the application to try to use a prepared statement after it has been finalized. Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.\n\nEach entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\". The rowid is always available as an undeclared column named ROWID, OID, or _ROWID_ as long as those names are not also used by explicitly declared columns. If the table has a column of type INTEGER PRIMARY KEY then that column is another alias for the rowid.\n\nThe sqlite3_last_insert_rowid(D) interface usually returns the rowid of the most recent successful INSERT into a rowid table or virtual table on database connection D. Inserts into WITHOUT ROWID tables are not recorded. If no successful INSERTs into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.\n\nAs well as being set automatically as rows are inserted into database tables, the value returned by this function may be set explicitly by sqlite3_set_last_insert_rowid()\n\nSome virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g. to flush data accumulated in memory to disk). In this case subsequent calls to this function return the rowid associated with these internal INSERT operations, which leads to unintuitive results. Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using sqlite3_set_last_insert_rowid() before returning control to the user.\n\nIf an INSERT occurs within a trigger then this routine will return the rowid of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.\n\nAn INSERT that fails due to a constraint violation is not a successful INSERT and does not change the value returned by this routine. Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK, and INSERT OR ABORT make no changes to the return value of this routine when their insertion fails. When INSERT OR REPLACE encounters a constraint violation, it does not fail. The INSERT continues to completion after deleting rows that caused the constraint problem so INSERT OR REPLACE will always change the return value of this interface.\n\nFor the purposes of this routine, an INSERT is considered to be successful even if it is subsequently rolled back.\n\nThis function is accessible to SQL statements via the last_insert_rowid() SQL function.\n\nIf a separate thread performs a new INSERT on the same database connection while the sqlite3_last_insert_rowid() function is running and thus changes the last insert rowid, then the value returned by sqlite3_last_insert_rowid() is unpredictable and might not equal either the old or the new last insert rowid.\n\nThis interface allows the size of various constructs to be limited on a connection by connection basis. The first parameter is the database connection whose limit is to be set or queried. The second parameter is one of the limit categories that define a class of constructs to be size limited. The third parameter is the new limit for that construct.\n\nIf the new limit is a negative number, the limit is unchanged. For each limit category SQLITE_LIMIT_NAME there is a hard upper bound set at compile-time by a C preprocessor macro called SQLITE_MAX_NAME. (The \"_LIMIT_\" in the name is changed to \"_MAX_\".) Attempts to increase a limit above its hard upper bound are silently truncated to the hard upper bound.\n\nRegardless of whether or not the limit was changed, the sqlite3_limit() interface returns the prior value of the limit. Hence, to find the current value of a limit without changing it, simply invoke this interface with the third parameter set to -1.\n\nRun-time limits are intended for use in applications that manage both their own internal database and also databases that are controlled by untrusted external sources. An example application might be a web browser that has its own databases for storing history and separate databases controlled by JavaScript applications downloaded off the Internet. The internal databases can be given the large, default limits. Databases managed by external sources can be given much smaller limits designed to prevent a denial of service attack. Developers might also want to use the sqlite3_set_authorizer() interface to further control untrusted SQL. The size of the database created by an untrusted script can be contained using the max_page_count PRAGMA.\n\nNew run-time limit categories may be added in future releases.\n\nThis interface loads an SQLite extension library from the named file.\n\nThe sqlite3_load_extension() interface attempts to load an SQLite extension library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if \"samplelib\" cannot be loaded, then names like \"samplelib.so\" or \"samplelib.dylib\" or \"samplelib.dll\" might be tried also.\n\nThe entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries \"sqlite3_extension_init\". If that does not work, it constructs a name \"sqlite3_X_init\" where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last \"/\" to the first following \".\" and omitting any initial \"lib\". The sqlite3_load_extension() interface returns SQLITE_OK on success and SQLITE_ERROR if something goes wrong. If an error occurs and pzErrMsg is not 0, then the sqlite3_load_extension() interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from sqlite3_malloc(). The calling function should free this memory by calling sqlite3_free().\n\nExtension loading must be enabled using sqlite3_enable_load_extension() or sqlite3_db_config(db,SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION,1,NULL) prior to calling this API, otherwise an error will be returned.\n\nSecurity warning: It is recommended that the SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION method be used to enable only this interface. The use of the sqlite3_enable_load_extension() interface should be avoided. This will keep the SQL function load_extension() disabled and prevent SQL injections from giving attackers access to extension loading capabilities.\n\nSee also the load_extension() SQL function.\n\nThe sqlite3_log() interface writes a message into the error log established by the SQLITE_CONFIG_LOG option to sqlite3_config(). If logging is enabled, the zFormat string and subsequent arguments are used with sqlite3_snprintf() to generate the final output string.\n\nThe sqlite3_log() interface is intended for use by extensions such as virtual tables, collating functions, and SQL functions. While there is nothing to prevent an application from calling sqlite3_log(), doing so is considered bad form.\n\nThe zFormat string must not be NULL.\n\nTo avoid deadlocks and other threading problems, the sqlite3_log() routine will not use dynamically allocated memory. The log message is stored in a fixed-length buffer on the stack. If the log message is longer than a few hundred characters, it will be truncated to the length of the buffer.\n\nThis interface returns a pointer to the next prepared statement after pStmt associated with the database connection pDb. If pStmt is NULL then this interface returns a pointer to the first prepared statement associated with the database connection pDb. If no prepared statement satisfies the conditions of this routine, it returns NULL.\n\nThe database connection pointer D in a call to sqlite3_next_stmt(D,S) must refer to an open database connection and in particular must not be a NULL pointer.\n\nVirtual tables can provide alternative implementations of functions using the xFindFunction method of the virtual table module. But global versions of those functions must exist in order to be overloaded.\n\nThis API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a virtual table.\n\nThe sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to sqlite3_step() and sqlite3_prepare() and similar for database connection D. An example use for this interface is to keep a GUI updated during a large query.\n\nThe parameter P is passed through as the only parameter to the callback function X. The parameter N is the approximate number of virtual machine instructions that are evaluated between successive invocations of the callback X. If N is less than one then the progress handler is disabled.\n\nOnly a single progress handler may be defined at one time per database connection; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.\n\nIf the progress callback returns non-zero, the operation is interrupted. This feature can be used to implement a \"Cancel\" button on a GUI progress dialog box.\n\nThe progress handler callback must not do anything that will modify the database connection that invoked the progress handler. Note that sqlite3_prepare_v2() and sqlite3_step() both modify their database connections for the meaning of \"modify\" in this paragraph.\n\nThe progress handler callback would originally only be invoked from the bytecode engine. It still might be invoked during sqlite3_prepare() and similar because those routines might force a reparse of the schema which involves running the bytecode engine. However, beginning with SQLite version 3.41.0, the progress handler callback might also be invoked directly from sqlite3_prepare() while analyzing and generating code for complex queries.\n\nSQLite contains a high-quality pseudo-random number generator (PRNG) used to select random ROWIDs when inserting new records into a table that already uses the largest possible ROWID. The PRNG is also used for the built-in random() and randomblob() SQL functions. This interface allows applications to access the same PRNG for other purposes.\n\nA call to this routine stores N bytes of randomness into buffer P. The P parameter can be a NULL pointer.\n\nIf this routine has not been previously called or if the previous call had N less than one or a NULL pointer for P, then the PRNG is seeded using randomness obtained from the xRandomness method of the default sqlite3_vfs object. If the previous call to this routine had an N of 1 or more and a non-NULL P then the pseudo-randomness is generated internally and without recourse to the sqlite3_vfs xRandomness method.\n\nThe sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with SQLITE_ENABLE_MEMORY_MANAGEMENT.\n\nThe sqlite3_reset() function is called to reset a prepared statement object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the sqlite3_bind_*() API retain their values. Use sqlite3_clear_bindings() to reset the bindings.\n\nThe sqlite3_reset(S) interface resets the prepared statement S back to the beginning of its program.\n\nThe return code from sqlite3_reset(S) indicates whether or not the previous evaluation of prepared statement S completed successfully. If sqlite3_step(S) has never before been called on S or if sqlite3_step(S) has not been called since the previous call to sqlite3_reset(S), then sqlite3_reset(S) will return SQLITE_OK.\n\nIf the most recent call to sqlite3_step(S) for the prepared statement S indicated an error, then sqlite3_reset(S) returns an appropriate error code. The sqlite3_reset(S) interface might also return an error code if there were no prior errors but the process of resetting the prepared statement caused a new error. For example, if an INSERT statement with a RETURNING clause is only stepped one time, that one call to sqlite3_step(S) might return SQLITE_ROW but the overall statement might still fail and the sqlite3_reset(S) call might return SQLITE_BUSY if locking constraints prevent the database change from committing. Therefore, it is important that applications check the return code from sqlite3_reset(S) even if no prior call to sqlite3_step(S) indicated a problem.\n\nThe sqlite3_reset(S) interface does not change the values of any bindings on the prepared statement S.\n\nThis interface disables all automatic extensions previously registered using sqlite3_auto_extension().\n\nSetting The Subtype Of An SQL Function\n\nThe sqlite3_result_subtype(C,T) function causes the subtype of the result from the application-defined SQL function with sqlite3_context C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.\n\nEvery application-defined SQL function that invokes this interface should include the SQLITE_RESULT_SUBTYPE property in its text encoding argument when the SQL function is registered. If the SQLITE_RESULT_SUBTYPE property is omitted from the function that invokes sqlite3_result_subtype(), then in some cases the sqlite3_result_subtype() might fail to set the result subtype.\n\nIf SQLite is compiled with -DSQLITE_STRICT_SUBTYPE=1, then any SQL function that invokes the sqlite3_result_subtype() interface and that does not have the SQLITE_RESULT_SUBTYPE property will raise an error. Future versions of SQLite might enable -DSQLITE_STRICT_SUBTYPE=1 by default.\n\nThe sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on database connection D. If S is a NULL pointer, the main database is used. If P is not a NULL pointer, then the size of the database in bytes is written into *P.\n\nFor an ordinary on-disk database file, the serialization is just a copy of the disk file. For an in-memory database or a \"TEMP\" database, the serialization is the same sequence of bytes which would be written to disk if that database where backed up to disk.\n\nThe usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from sqlite3_malloc64() and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to sqlite3_deserialize(D,S,...) with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.\n\nAfter the call, if the SQLITE_SERIALIZE_NOCOPY bit had been set, the returned buffer content will remain accessible and unchanged until either the next write operation on the connection or when the connection is closed, and applications must not modify the buffer. If the bit had been clear, the returned buffer will not be accessed by SQLite after the call.\n\nA call to sqlite3_serialize(D,S,P,F) might return NULL even if the SQLITE_SERIALIZE_NOCOPY bit is omitted from argument F if a memory allocation error occurs.\n\nThis interface is omitted if SQLite is compiled with the SQLITE_OMIT_DESERIALIZE option.\n\nSet the Last Insert Rowid value.\n\nThe sqlite3_set_last_insert_rowid(D, R) method allows the application to set the value returned by calling sqlite3_last_insert_rowid(D) to R without inserting a row into the database.\n\nThe sqlite3_sleep() function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.\n\nIf the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second. The number of milliseconds of sleep actually requested from the operating system is returned.\n\nSQLite implements this interface by calling the xSleep() method of the default sqlite3_vfs object. If the xSleep() method of the default VFS is not implemented correctly, or not implemented at all, then the behavior of sqlite3_sleep() may deviate from the description in the previous paragraphs.\n\nIf a negative argument is passed to sqlite3_sleep() the results vary by VFS and operating system. Some system treat a negative argument as an instruction to sleep forever. Others understand it to mean do not sleep at all. In SQLite version 3.42.0 and later, a negative argument passed into sqlite3_sleep() is changed to zero before it is relayed down into the xSleep method of the VFS.\n\nCompare the ages of two snapshot handles.\n\nThe sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.\n\nIf the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.\n\nAdditionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get() since the last time the wal file was deleted. The wal file is deleted when the database is changed back to rollback mode or when the number of database clients drops to zero. If either snapshot handle was obtained before the wal file was last deleted, the value returned by this function is undefined.\n\nOtherwise, this API returns a negative value if P1 refers to an older snapshot than P2, zero if the two handles refer to the same database snapshot, and a positive value if P1 is a newer snapshot than P2.\n\nThis interface is only available if SQLite is compiled with the SQLITE_ENABLE_SNAPSHOT option.\n\nThe sqlite3_snapshot_free(P) interface destroys sqlite3_snapshot P. The application must eventually free every sqlite3_snapshot object using this routine to avoid a memory leak.\n\nThe sqlite3_snapshot_free() interface is only available when the SQLITE_ENABLE_SNAPSHOT compile-time option is used.\n\nThe sqlite3_snapshot_get(D,S,P) interface attempts to make a new sqlite3_snapshot object that records the current state of schema S in database connection D. On success, the sqlite3_snapshot_get(D,S,P) interface writes a pointer to the newly created sqlite3_snapshot object into *P and returns SQLITE_OK. If there is not already a read-transaction open on schema S when this function is called, one is opened automatically.\n\nIf a read-transaction is opened by this function, then it is guaranteed that the returned snapshot object may not be invalidated by a database writer or checkpointer until after the read-transaction is closed. This is not guaranteed if a read-transaction is already open when this function is called. In that case, any subsequent write or checkpoint operation on the database may invalidate the returned snapshot handle, even while the read-transaction remains open.\n\nThe following must be true for this function to succeed. If any of the following statements are false when sqlite3_snapshot_get() is called, SQLITE_ERROR is returned. The final value of *P is undefined in this case.\n• The database handle must not be in autocommit mode.\n• Schema S of database connection D must be a WAL mode database.\n• There must not be a write transaction open on schema S of database connection D.\n• One or more transactions must have been written to the current wal file since it was created on disk (by any connection). This means that a snapshot cannot be taken on a wal mode database with no wal file immediately after it is first opened. At least one transaction must be written to it first.\n\nThis function may also return SQLITE_NOMEM. If it is called with the database handle in autocommit mode but fails for some other reason, whether or not a read transaction is opened on schema S is undefined.\n\nThe sqlite3_snapshot object returned from a successful call to sqlite3_snapshot_get() must be freed using sqlite3_snapshot_free() to avoid a memory leak.\n\nThe sqlite3_snapshot_get() interface is only available when the SQLITE_ENABLE_SNAPSHOT compile-time option is used.\n\nThe sqlite3_snapshot_open(D,S,P) interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database. The sqlite3_snapshot_open() interface returns SQLITE_OK on success or an appropriate error code if it fails.\n\nIn order to succeed, the database connection must not be in autocommit mode when sqlite3_snapshot_open(D,S,P) is called. If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step() but not sqlite3_reset() or sqlite3_finalize()). SQLITE_ERROR is returned if either of these conditions is violated, or if schema S does not exist, or if the snapshot object is invalid.\n\nA call to sqlite3_snapshot_open() will fail to open if the specified snapshot has been overwritten by a checkpoint. In this case SQLITE_ERROR_SNAPSHOT is returned.\n\nIf there is already a read transaction open when this function is invoked, then the same read transaction remains open (on the same database snapshot) if SQLITE_ERROR, SQLITE_BUSY or SQLITE_ERROR_SNAPSHOT is returned. If another error code - for example SQLITE_PROTOCOL or an SQLITE_IOERR error code - is returned, then the final state of the read transaction is undefined. If SQLITE_OK is returned, then the read transaction is now open on database snapshot P.\n\nA call to sqlite3_snapshot_open(D,S,P) will fail if the database connection D does not know that the database file for schema S is in WAL mode. A database connection might not know that the database file is in WAL mode if there has been no prior I/O on that database connection, or if the database entered WAL mode after the most recent I/O on the database connection. (Hint: Run \"PRAGMA application_id\" against a newly opened database connection in order to make it ready to use snapshots.)\n\nThe sqlite3_snapshot_open() interface is only available when the SQLITE_ENABLE_SNAPSHOT compile-time option is used.\n\nIf a WAL file remains on disk after all database connections close (either through the use of the SQLITE_FCNTL_PERSIST_WAL file control or because the last process to have the database opened exited without calling sqlite3_close()) and a new connection is subsequently opened on that database and WAL file, the sqlite3_snapshot_open() interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.\n\nThis function attempts to scan the WAL file associated with database zDb of database handle db and make all valid snapshots available to sqlite3_snapshot_open(). It is an error if there is already a read transaction open on the database, or if the database is not a WAL mode database.\n\nSQLITE_OK is returned if successful, or an SQLite error code otherwise.\n\nThis interface is only available if SQLite is compiled with the SQLITE_ENABLE_SNAPSHOT option.\n\nThis is a deprecated version of the sqlite3_soft_heap_limit64() interface. This routine is provided for historical compatibility only. All new applications should use the sqlite3_soft_heap_limit64() interface rather than this one.\n\nAfter a prepared statement has been prepared using any of sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), or sqlite3_prepare16_v3() or one of the legacy interfaces sqlite3_prepare() or sqlite3_prepare16(), this function must be called one or more times to evaluate the statement.\n\nThe details of the behavior of the sqlite3_step() interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3(), sqlite3_prepare_v2(), sqlite3_prepare16_v3(), sqlite3_prepare16_v2() or the older legacy interfaces sqlite3_prepare() and sqlite3_prepare16(). The use of the new \"vX\" interface is recommended for new applications but the legacy interface will continue to be supported.\n\nIn the legacy interface, the return value will be either SQLITE_BUSY, SQLITE_DONE, SQLITE_ROW, SQLITE_ERROR, or SQLITE_MISUSE. With the \"v2\" interface, any of the other result codes or extended result codes might be returned as well.\n\nSQLITE_BUSY means that the database engine was unable to acquire the database locks it needs to do its job. If the statement is a COMMIT or occurs outside of an explicit transaction, then you can retry the statement. If the statement is not a COMMIT and occurs within an explicit transaction then you should rollback the transaction before continuing.\n\nSQLITE_DONE means that the statement has finished executing successfully. sqlite3_step() should not be called again on this virtual machine without first calling sqlite3_reset() to reset the virtual machine back to its initial state.\n\nIf the SQL statement being executed returns any data, then SQLITE_ROW is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the column access functions. sqlite3_step() is called again to retrieve the next row of data.\n\nSQLITE_ERROR means that a run-time error (such as a constraint violation) has occurred. sqlite3_step() should not be called again on the VM. More information may be found by calling sqlite3_errmsg(). With the legacy interface, a more specific error code (for example, SQLITE_INTERRUPT, SQLITE_SCHEMA, SQLITE_CORRUPT, and so forth) can be obtained by calling sqlite3_reset() on the prepared statement. In the \"v2\" interface, the more specific error code is returned directly by sqlite3_step().\n\nSQLITE_MISUSE means that the this routine was called inappropriately. Perhaps it was called on a prepared statement that has already been finalized or on one that had previously returned SQLITE_ERROR or SQLITE_DONE. Or it could be the case that the same database connection is being used by two or more threads at the same moment in time.\n\nFor all versions of SQLite up to and including 3.6.23.1, a call to sqlite3_reset() was required after sqlite3_step() returned anything other than SQLITE_ROW before any subsequent invocation of sqlite3_step(). Failure to reset the prepared statement using sqlite3_reset() would result in an SQLITE_MISUSE return from sqlite3_step(). But after version 3.6.23.1 (2010-03-26, sqlite3_step() began calling sqlite3_reset() automatically in this circumstance rather than returning SQLITE_MISUSE. This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE error is broken by definition. The SQLITE_OMIT_AUTORESET compile-time option can be used to restore the legacy behavior.\n\nGoofy Interface Alert: In the legacy interface, the sqlite3_step() API always returns a generic error code, SQLITE_ERROR, following any error other than SQLITE_BUSY and SQLITE_MISUSE. You must call sqlite3_reset() or sqlite3_finalize() in order to find one of the specific error codes that better describes the error. We admit that this is a goofy design. The problem has been fixed with the \"v2\" interface. If you prepare all of your SQL statements using sqlite3_prepare_v3() or sqlite3_prepare_v2() or sqlite3_prepare16_v2() or sqlite3_prepare16_v3() instead of the legacy sqlite3_prepare() and sqlite3_prepare16() interfaces, then the more specific error codes are returned directly by sqlite3_step(). The use of the \"vX\" interfaces is recommended.\n\nDetermine If A Prepared Statement Has Been Reset\n\nThe sqlite3_stmt_busy(S) interface returns true (non-zero) if the prepared statement S has been stepped at least once using sqlite3_step(S) but has neither run to completion (returned SQLITE_DONE from sqlite3_step(S)) nor been reset using sqlite3_reset(S). The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid prepared statement object, then the behavior is undefined and probably undesirable.\n\nThis interface can be used in combination sqlite3_next_stmt() to locate all prepared statements associated with a database connection that are in need of being reset. This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.\n\nThe sqlite3_stmt_explain(S,E) interface changes the EXPLAIN setting for prepared statement S. If E is zero, then S becomes a normal prepared statement. If E is 1, then S behaves as if its SQL text began with \"EXPLAIN\". If E is 2, then S behaves as if its SQL text began with \"EXPLAIN QUERY PLAN\".\n\nCalling sqlite3_stmt_explain(S,E) might cause S to be reprepared. SQLite tries to avoid a reprepare, but a reprepare might be necessary on the first transition into EXPLAIN or EXPLAIN QUERY PLAN mode.\n\nBecause of the potential need to reprepare, a call to sqlite3_stmt_explain(S,E) will fail with SQLITE_ERROR if S cannot be reprepared because it was created using sqlite3_prepare() instead of the newer sqlite3_prepare_v2() or sqlite3_prepare_v3() interfaces and hence has no saved SQL text with which to reprepare.\n\nChanging the explain setting for a prepared statement does not change the original SQL text for the statement. Hence, if the SQL text originally began with EXPLAIN or EXPLAIN QUERY PLAN, but sqlite3_stmt_explain(S,0) is called to convert the statement into an ordinary statement, the EXPLAIN or EXPLAIN QUERY PLAN keywords will still appear in the sqlite3_sql(S) output, even though the statement now acts like a normal SQL statement.\n\nThis routine returns SQLITE_OK if the explain mode is successfully changed, or an error code if the explain mode could not be changed. The explain mode cannot be changed while a statement is active. Hence, it is good practice to call sqlite3_reset(S) immediately prior to calling sqlite3_stmt_explain(S,E).\n\nThe sqlite3_stmt_isexplain(S) interface returns 1 if the prepared statement S is an EXPLAIN statement, or 2 if the statement S is an EXPLAIN QUERY PLAN. The sqlite3_stmt_isexplain(S) interface returns 0 if S is an ordinary statement or a NULL pointer.\n\nDetermine If An SQL Statement Writes The Database\n\nThe sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the prepared statement X makes no direct changes to the content of the database file.\n\nNote that application-defined SQL functions or virtual tables might change the database indirectly as a side effect. For example, if an application defines a function \"eval()\" that calls sqlite3_exec(), then the following SQL statement would change the database file through side-effects:\n\nBut because the SELECT statement does not change the database file directly, sqlite3_stmt_readonly() would still return true.\n\nTransaction control statements such as BEGIN, COMMIT, ROLLBACK, SAVEPOINT, and RELEASE cause sqlite3_stmt_readonly() to return true, since the statements themselves do not actually modify the database but rather they control the timing of when other statements modify the database. The ATTACH and DETACH statements also cause sqlite3_stmt_readonly() to return true since, while those statements change the configuration of a database connection, they do not make changes to the content of the database files on disk. The sqlite3_stmt_readonly() interface returns true for BEGIN since BEGIN merely sets internal flags, but the BEGIN IMMEDIATE and BEGIN EXCLUSIVE commands do touch the database and so sqlite3_stmt_readonly() returns false for those commands.\n\nThis routine returns false if there is any possibility that the statement might change the database file. A false return does not guarantee that the statement will change the database file. For example, an UPDATE statement might have a WHERE clause that makes it a no-op, but the sqlite3_stmt_readonly() result would still be false. Similarly, a CREATE TABLE IF NOT EXISTS statement is a read-only no-op if the table already exists, but sqlite3_stmt_readonly() still returns false for such a statement.\n\nIf prepared statement X is an EXPLAIN or EXPLAIN QUERY PLAN statement, then sqlite3_stmt_readonly(X) returns the same value as if the EXPLAIN or EXPLAIN QUERY PLAN prefix were omitted.\n\nThis API is only available if the library is built with pre-processor symbol SQLITE_ENABLE_STMT_SCANSTATUS defined.\n\nEach prepared statement maintains various SQLITE_STMTSTATUS counters that measure the number of times it has performed specific operations. These counters can be used to monitor the performance characteristics of the prepared statements. For example, if the number of table steps greatly exceeds the number of table searches or result rows, that would tend to indicate that the prepared statement is using a full table scan rather than an index.\n\nThis interface is used to retrieve and reset counter values from a prepared statement. The first argument is the prepared statement object to be interrogated. The second argument is an integer code for a specific SQLITE_STMTSTATUS counter to be interrogated. The current value of the requested counter is returned. If the resetFlg is true, then the counter is reset to zero after this interface call returns.\n\nSee also: sqlite3_status() and sqlite3_db_status().\n\nThe sqlite3_str_finish(X) interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from sqlite3_malloc64() that contains the constructed string. The calling application should pass the returned value to sqlite3_free() to avoid a memory leak. The sqlite3_str_finish(X) interface may return a NULL pointer if any errors were encountered during construction of the string. The sqlite3_str_finish(X) interface will also return a NULL pointer if the string in sqlite3_str object X is zero bytes long.\n\nThe sqlite3_str_new(D) interface allocates and initializes a new sqlite3_str object. To avoid memory leaks, the object returned by sqlite3_str_new() must be freed by a subsequent call to sqlite3_str_finish(X).\n\nThe sqlite3_str_new(D) interface always returns a pointer to a valid sqlite3_str object, though in the event of an out-of-memory error the returned object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM from sqlite3_str_errcode(), always return 0 for sqlite3_str_length(), and always return NULL from sqlite3_str_finish(X). It is always safe to use the value returned by sqlite3_str_new(D) as the sqlite3_str parameter to any of the other sqlite3_str methods.\n\nThe D parameter to sqlite3_str_new(D) may be NULL. If the D parameter in sqlite3_str_new(D) is not NULL, then the maximum length of the string contained in the sqlite3_str object will be the value set for sqlite3_limit(D,SQLITE_LIMIT_LENGTH) instead of SQLITE_MAX_LENGTH.\n\nThe sqlite3_strglob(P,X) interface returns zero if and only if string X matches the GLOB pattern P. The definition of GLOB pattern matching used in sqlite3_strglob(P,X) is the same as for the \"X GLOB P\" operator in the SQL dialect understood by SQLite. The sqlite3_strglob(P,X) function is case sensitive.\n\nNote that this routine returns zero on a match and non-zero if the strings do not match, the same as sqlite3_stricmp() and sqlite3_strnicmp().\n\nThe sqlite3_strlike(P,X,E) interface returns zero if and only if string X matches the LIKE pattern P with escape character E. The definition of LIKE pattern matching used in sqlite3_strlike(P,X,E) is the same as for the \"X LIKE P ESCAPE E\" operator in the SQL dialect understood by SQLite. For \"X LIKE P\" without the ESCAPE clause, set the E parameter of sqlite3_strlike(P,X,E) to 0. As with the LIKE operator, the sqlite3_strlike(P,X,E) function is case insensitive - equivalent upper and lower case ASCII characters match one another.\n\nThe sqlite3_strlike(P,X,E) function matches Unicode characters, though only ASCII characters are case folded.\n\nNote that this routine returns zero on a match and non-zero if the strings do not match, the same as sqlite3_stricmp() and sqlite3_strnicmp().\n\nAttempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file. The return value is OS-dependent. For example, on unix systems, after sqlite3_open_v2() returns SQLITE_CANTOPEN, this interface could be called to get back the underlying \"errno\" that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.\n\nThe sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.\n\nThe column is identified by the second, third and fourth parameters to this function. The second parameter is either the name of the database (i.e. \"main\", \"temp\", or an attached database) containing the specified table or NULL. If it is NULL, then all attached databases are searched for the table using the same algorithm used by the database engine to resolve unqualified table references.\n\nThe third and fourth parameters to this function are the table and column name of the desired column, respectively.\n\nMetadata is returned by writing to the memory locations passed as the 5th and subsequent parameters to this function. Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted.\n\nThe memory pointed to by the character pointers returned for the declaration type and collation sequence is valid until the next call to any SQLite API function.\n\nIf the specified table is actually a view, an error code is returned.\n\nIf the specified column is \"rowid\", \"oid\" or \"_rowid_\" and the table is not a WITHOUT ROWID table and an INTEGER PRIMARY KEY column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no INTEGER PRIMARY KEY column, then the outputs for the rowid are set as follows:\n\nThis function causes all database schemas to be read from disk and parsed, if that has not already been done, and returns an error if any errors are encountered while loading the schema.\n\nThe sqlite3_test_control() interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes. The first parameter is an operation code that determines the number, meaning, and operation of all subsequent parameters.\n\nThis interface is not for use by applications. It exists solely for verifying the correct operation of the SQLite library. Depending on how the SQLite library is compiled, this interface might not exist.\n\nThe details of the operation codes, their meanings, the parameters they take, and what they do are all subject to change without notice. Unlike most of the SQLite API, this function is not guaranteed to operate consistently from one release to the next.\n\nTest To See If The Library Is Threadsafe\n\nThe sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.\n\nSQLite can be compiled with or without mutexes. When the SQLITE_THREADSAFE C preprocessor macro is 1 or 2, mutexes are enabled and SQLite is threadsafe. When the SQLITE_THREADSAFE macro is 0, the mutexes are omitted. Without the mutexes, it is not safe to use SQLite concurrently from more than one thread.\n\nEnabling mutexes incurs a measurable performance penalty. So if speed is of utmost importance, it makes sense to disable the mutexes. But for maximum safety, mutexes should be enabled. The default behavior is for mutexes to be enabled.\n\nThis interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the SQLITE_THREADSAFE macro.\n\nThis interface only reports on the compile-time mutex setting of the SQLITE_THREADSAFE flag. If SQLite is compiled with SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but can be fully or partially disabled using a call to sqlite3_config() with the verbs SQLITE_CONFIG_SINGLETHREAD, SQLITE_CONFIG_MULTITHREAD, or SQLITE_CONFIG_SERIALIZED. The return value of the sqlite3_threadsafe() function shows only the compile-time setting of thread safety, not any run-time changes to that setting made by sqlite3_config(). In other words, the return value from sqlite3_threadsafe() is unchanged by calls to sqlite3_config().\n\nSee the threading mode documentation for additional information.\n\nThe sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against database connection D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more SQLITE_TRACE constants.\n\nEach call to either sqlite3_trace(D,X,P) or sqlite3_trace_v2(D,M,X,P) overrides (cancels) all prior calls to sqlite3_trace(D,X,P) or sqlite3_trace_v2(D,M,X,P) for the database connection D. Each database connection may have at most one trace callback.\n\nThe X callback is invoked whenever any of the events identified by mask M occur. The integer return value from the callback is currently ignored, though this may change in future releases. Callback implementations should return zero to ensure future compatibility.\n\nA trace callback is invoked with four arguments: callback(T,C,P,X). The T argument is one of the SQLITE_TRACE constants to indicate why the callback was invoked. The C argument is a copy of the context pointer. The P and X arguments are pointers whose meanings depend on T.\n\nThe sqlite3_trace_v2() interface is intended to replace the legacy interfaces sqlite3_trace() and sqlite3_profile(), both of which are deprecated.\n\nThe sqlite3_txn_state(D,S) interface returns the current transaction state of schema S in database connection D. If S is NULL, then the highest transaction state of any schema on database connection D is returned. Transaction states are (in order of lowest to highest):\n\nWhen running in shared-cache mode, a database operation may fail with an SQLITE_LOCKED error if the required locks on the shared-cache or individual tables within the shared-cache cannot be obtained. See SQLite Shared-Cache Mode for a description of shared-cache locking. This API may be used to register a callback that SQLite will invoke when the connection currently holding the required lock relinquishes it. This API is only available if the library was compiled with the SQLITE_ENABLE_UNLOCK_NOTIFY C-preprocessor symbol defined.\n\nSee Also: Using the SQLite Unlock Notification Feature.\n\nShared-cache locks are released when a database connection concludes its current transaction, either by committing it or rolling it back.\n\nWhen a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the sqlite3_step or sqlite3_close call that concludes the blocking connection's transaction.\n\nIf sqlite3_unlock_notify() is called in a multi-threaded application, there is a chance that the blocking connection will have already concluded its transaction by the time sqlite3_unlock_notify() is invoked. If this happens, then the specified callback is invoked immediately, from within the call to sqlite3_unlock_notify().\n\nIf the blocked connection is attempting to obtain a write-lock on a shared-cache table, and more than one other connection currently holds a read-lock on the same table, then SQLite arbitrarily selects one of the other connections to use as the blocking connection.\n\nThere may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using sqlite3_close().\n\nThe unlock-notify callback is not reentrant. If an application invokes any sqlite3_xxx API functions from within an unlock-notify callback, a crash or deadlock may be the result.\n\nUnless deadlock is detected (see below), sqlite3_unlock_notify() always returns SQLITE_OK.\n\nWhen an unlock-notify callback is registered, the application provides a single void* pointer that is passed to the callback when it is invoked. However, the signature of the callback function allows SQLite to pass it an array of void* context pointers. The first argument passed to an unlock-notify callback is a pointer to an array of void* pointers, and the second is the number of entries in the array.\n\nWhen a blocking connection's transaction is concluded, there may be more than one blocked connection that has registered for an unlock-notify callback. If two or more such blocked connections have specified the same callback function, then instead of invoking the callback function multiple times, it is invoked once with the set of void* context pointers specified by the blocked connections bundled together into an array. This gives the application an opportunity to prioritize any actions related to the set of unblocked database connections.\n\nAssuming that after registering for an unlock-notify callback a database waits for the callback to be issued before taking any further action (a reasonable assumption), then using this API may cause the application to deadlock. For example, if connection X is waiting for connection Y's transaction to be concluded, and similarly connection Y is waiting on connection X's transaction, then neither connection will proceed and the system may remain deadlocked indefinitely.\n\nTo avoid this scenario, the sqlite3_unlock_notify() performs deadlock detection. If a given call to sqlite3_unlock_notify() would put the system in a deadlocked state, then SQLITE_LOCKED is returned and no unlock-notify callback is registered. The system is said to be in a deadlocked state if connection A has registered for an unlock-notify callback on the conclusion of connection B's transaction, and connection B has itself registered for an unlock-notify callback when connection A's transaction is concluded. Indirect deadlock is also detected, so the system is also considered to be deadlocked if connection B has registered for an unlock-notify callback on the conclusion of connection C's transaction, where connection C is waiting on connection A. Any number of levels of indirection are allowed.\n\nWhen a call to sqlite3_step() returns SQLITE_LOCKED, it is almost always appropriate to call sqlite3_unlock_notify(). There is however, one exception. When executing a \"DROP TABLE\" or \"DROP INDEX\" statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection. If there are, SQLITE_LOCKED is returned. In this case there is no \"blocking connection\", so invoking sqlite3_unlock_notify() results in the unlock-notify callback being invoked immediately. If the application then re-attempts the \"DROP TABLE\" or \"DROP INDEX\" query, an infinite loop might be the result.\n\nOne way around this problem is to check the extended error code returned by an sqlite3_step() call. If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the special \"DROP TABLE/INDEX\" case, the extended error code is just SQLITE_LOCKED.\n\nThe sqlite3_update_hook() interface registers a callback function with the database connection identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a rowid table. Any callback set by a previous call to this function for the same database connection is overridden.\n\nThe second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of SQLITE_INSERT, SQLITE_DELETE, or SQLITE_UPDATE, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the rowid of the row. In the case of an update, this is the rowid after the update takes place.\n\nThe update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when WITHOUT ROWID tables are modified.\n\nIn the current implementation, the update hook is not invoked when conflicting rows are deleted because of an ON CONFLICT REPLACE clause. Nor is the update hook invoked when rows are deleted using the truncate optimization. The exceptions defined in this paragraph might change in a future release of SQLite.\n\nWhether the update hook is invoked before or after the corresponding change is currently unspecified and may differ depending on the type of change. Do not rely on the order of the hook call with regards to the final result of the operation which triggers the hook.\n\nThe update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the sqlite3_step() call that triggered the update hook. Note that sqlite3_prepare_v2() and sqlite3_step() both modify their database connections for the meaning of \"modify\" in this paragraph.\n\nThe sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same database connection D, or NULL for the first call on D.\n\nSee also the sqlite3_commit_hook(), sqlite3_rollback_hook(), and sqlite3_preupdate_hook() interfaces.\n\nThe sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the sqlite3_create_function() and sqlite3_create_function16() routines that originally registered the application defined function.\n\nThis routine must be called from the same thread in which the application-defined function is running.\n\nReport the internal text encoding state of an sqlite3_value object\n\nThe sqlite3_value_encoding(X) interface returns one of SQLITE_UTF8, SQLITE_UTF16BE, or SQLITE_UTF16LE according to the current text encoding of the value X, assuming that X has type TEXT. If sqlite3_value_type(X) returns something other than SQLITE_TEXT, then the return value from sqlite3_value_encoding(X) is meaningless. Calls to sqlite3_value_text(X), sqlite3_value_text16(X), sqlite3_value_text16be(X), sqlite3_value_text16le(X), sqlite3_value_bytes(X), or sqlite3_value_bytes16(X) might change the encoding of the value X and thus change the return from subsequent calls to sqlite3_value_encoding(X).\n\nThis routine is intended for used by applications that test and validate the SQLite implementation. This routine is inquiring about the opaque internal state of an sqlite3_value object. Ordinary applications should not need to know what the internal state of an sqlite3_value object is and hence should not need to use this interface.\n\nThe sqlite3_value_subtype(V) function returns the subtype for an application-defined SQL function argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the sqlite3_result_subtype() routine to set the subtype for the return value of an SQL function.\n\nEvery application-defined SQL function that invokes this interface should include the SQLITE_SUBTYPE property in the text encoding argument when the function is registered. If the SQLITE_SUBTYPE property is omitted, then sqlite3_value_subtype() might return zero instead of the upstream subtype in some corner cases.\n\nThis function may only be called from within a call to the xBestIndex method of a virtual table. This function returns a pointer to a string that is the name of the appropriate collation sequence to use for text comparisons on the constraint identified by its arguments.\n\nThe first argument must be the pointer to the sqlite3_index_info object that is the first parameter to the xBestIndex() method. The second argument must be an index into the aConstraint[] array belonging to the sqlite3_index_info structure passed to xBestIndex.\n\nImportant: The first parameter must be the same pointer that is passed into the xBestMethod() method. The first parameter may not be a pointer to a different sqlite3_index_info object, even an exact copy.\n\nThe return value is computed as follows:\n• None If the constraint comes from a WHERE clause expression that contains a COLLATE operator, then the name of the collation specified by that COLLATE operator is returned.\n• None If there is no COLLATE operator, but the column that is the subject of the constraint specifies an alternative collating sequence via a COLLATE clause on the column definition within the CREATE TABLE statement that was passed into sqlite3_declare_vtab(), then the name of that alternative collating sequence is returned.\n\nThis function may be called by either the xConnect or xCreate method of a virtual table implementation to configure various facets of the virtual table interface.\n\nIf this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined.\n\nIn the call sqlite3_vtab_config(D,C,...) the D parameter is the database connection in which the virtual table is being created and which is passed in as the first argument to the xConnect or xCreate method that is invoking sqlite3_vtab_config(). The C parameter is one of the virtual table configuration options. The presence and meaning of parameters after C depend on which virtual table configuration option is used.\n\nThis API may only be used from within an xBestIndex method of a virtual table implementation. The result of calling this interface from outside of xBestIndex() is undefined and probably harmful.\n\nThe sqlite3_vtab_distinct() interface returns an integer between 0 and 3. The integer returned by sqlite3_vtab_distinct() gives the virtual table additional information about how the query planner wants the output to be ordered. As long as the virtual table can meet the ordering requirements of the query planner, it may set the \"orderByConsumed\" flag.\n• None If the sqlite3_vtab_distinct() interface returns 0, that means that the query planner needs the virtual table to return all rows in the sort order defined by the \"nOrderBy\" and \"aOrderBy\" fields of the sqlite3_index_info object. This is the default expectation. If the virtual table outputs all rows in sorted order, then it is always safe for the xBestIndex method to set the \"orderByConsumed\" flag, regardless of the return value from sqlite3_vtab_distinct().\n• None If the sqlite3_vtab_distinct() interface returns 1, that means that the query planner does not need the rows to be returned in sorted order as long as all rows with the same values in all columns identified by the \"aOrderBy\" field are adjacent. This mode is used when the query planner is doing a GROUP BY.\n• None If the sqlite3_vtab_distinct() interface returns 2, that means that the query planner does not need the rows returned in any particular order, as long as rows with the same values in all columns identified by \"aOrderBy\" are adjacent. Furthermore, when two or more rows contain the same values for all columns identified by \"colUsed\", all but one such row may optionally be omitted from the result. The virtual table is not required to omit rows that are duplicates over the \"colUsed\" columns, but if the virtual table can do that without too much extra effort, it could potentially help the query to run faster. This mode is used for a DISTINCT query.\n• None If the sqlite3_vtab_distinct() interface returns 3, that means the virtual table must return rows in the order defined by \"aOrderBy\" as if the sqlite3_vtab_distinct() interface had returned 0. However if two or more rows in the result have the same values for all columns identified by \"colUsed\", then all but one such row may optionally be omitted. Like when the return value is 2, the virtual table is not required to omit rows that are duplicates over the \"colUsed\" columns, but if the virtual table can do that without too much extra effort, it could potentially help the query to run faster. This mode is used for queries that have both DISTINCT and ORDER BY clauses.\n\nThe following table summarizes the conditions under which the virtual table is allowed to set the \"orderByConsumed\" flag based on the value returned by sqlite3_vtab_distinct(). This table is a restatement of the previous four paragraphs:\n\nFor the purposes of comparing virtual table output values to see if the values are same value for sorting purposes, two NULL values are considered to be the same. In other words, the comparison operator is \"IS\" (or \"IS NOT DISTINCT FROM\") and not \"==\".\n\nIf a virtual table implementation is unable to meet the requirements specified above, then it must not set the \"orderByConsumed\" flag in the sqlite3_index_info object or an incorrect answer may result.\n\nA virtual table implementation is always free to return rows in any order it wants, as long as the \"orderByConsumed\" flag is not set. When the the \"orderByConsumed\" flag is unset, the query planner will add extra bytecode to ensure that the final results returned by the SQL query are ordered correctly. The use of the \"orderByConsumed\" flag and the sqlite3_vtab_distinct() interface is merely an optimization. Careful use of the sqlite3_vtab_distinct() interface and the \"orderByConsumed\" flag might help queries against a virtual table to run faster. Being overly aggressive and setting the \"orderByConsumed\" flag when it is not valid to do so, on the other hand, might cause SQLite to return incorrect results.\n\nIdentify and handle IN constraints in xBestIndex\n\nThis interface may only be used from within an xBestIndex() method of a virtual table implementation. The result of invoking this interface from any other context is undefined and probably harmful.\n\nA constraint on a virtual table of the form \"column IN (...)\" is communicated to the xBestIndex method as a SQLITE_INDEX_CONSTRAINT_EQ constraint. If xBestIndex wants to use this constraint, it must set the corresponding aConstraintUsage[].argvIndex to a positive integer. Then, under the usual mode of handling IN operators, SQLite generates bytecode that invokes the xFilter() method once for each value on the right-hand side of the IN operator. Thus the virtual table only sees a single value from the right-hand side of the IN operator at a time.\n\nIn some cases, however, it would be advantageous for the virtual table to see all values on the right-hand of the IN operator all at once. The sqlite3_vtab_in() interfaces facilitates this in two ways:\n• None A call to sqlite3_vtab_in(P,N,-1) will return true (non-zero) if and only if the P->aConstraint[N] constraint is an IN operator that can be processed all at once. In other words, sqlite3_vtab_in() with -1 in the third argument is a mechanism by which the virtual table can ask SQLite if all-at-once processing of the IN operator is even possible.\n• None A call to sqlite3_vtab_in(P,N,F) with F==1 or F==0 indicates to SQLite that the virtual table does or does not want to process the IN operator all-at-once, respectively. Thus when the third parameter (F) is non-negative, this interface is the mechanism by which the virtual table tells SQLite how it wants to process the IN operator.\n\nThe sqlite3_vtab_in(P,N,F) interface can be invoked multiple times within the same xBestIndex method call. For any given P,N pair, the return value from sqlite3_vtab_in(P,N,F) will always be the same within the same xBestIndex call. If the interface returns true (non-zero), that means that the constraint is an IN operator that can be processed all-at-once. If the constraint is not an IN operator or cannot be processed all-at-once, then the interface returns false.\n\nAll-at-once processing of the IN operator is selected if both of the following conditions are met:\n• None The P->aConstraintUsage[N].argvIndex value is set to a positive integer. This is how the virtual table tells SQLite that it wants to use the N-th constraint.\n• None The last call to sqlite3_vtab_in(P,N,F) for which F was non-negative had F>=1.\n\nIf either or both of the conditions above are false, then SQLite uses the traditional one-at-a-time processing strategy for the IN constraint. If both conditions are true, then the argvIndex-th parameter to the xFilter method will be an sqlite3_value that appears to be NULL, but which can be passed to sqlite3_vtab_in_first() and sqlite3_vtab_in_next() to find all values on the right-hand side of the IN constraint.\n\nDetermine If Virtual Table Column Access Is For UPDATE\n\nIf the sqlite3_vtab_nochange(X) routine is called within the xColumn method of a virtual table, then it might return true if the column is being fetched as part of an UPDATE operation during which the column value will not change. The virtual table implementation can use this hint as permission to substitute a return value that is less expensive to compute and that the corresponding xUpdate method understands as a \"no-change\" value.\n\nIf the xColumn method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the sqlite3_result_xxxxx() interfaces. In that case, sqlite3_value_nochange(X) will return true for the same column in the xUpdate method.\n\nThe sqlite3_vtab_nochange() routine is an optimization. Virtual table implementations should continue to give a correct answer even if the sqlite3_vtab_nochange() interface were to always return false. In the current implementation, the sqlite3_vtab_nochange() interface does always returns false for the enhanced UPDATE FROM statement.\n\nThis function may only be called from within a call to the xUpdate method of a virtual table implementation for an INSERT or UPDATE operation. The value returned is one of SQLITE_ROLLBACK, SQLITE_IGNORE, SQLITE_FAIL, SQLITE_ABORT, or SQLITE_REPLACE, according to the ON CONFLICT mode of the SQL statement that triggered the call to the xUpdate method of the virtual table.\n\nThis API may only be used from within the xBestIndex method of a virtual table implementation. The result of calling this interface from outside of an xBestIndex method are undefined and probably harmful.\n\nWhen the sqlite3_vtab_rhs_value(P,J,V) interface is invoked from within the xBestIndex method of a virtual table implementation, with P being a copy of the sqlite3_index_info object pointer passed into xBestIndex and J being a 0-based index into P->aConstraint[], then this routine attempts to set *V to the value of the right-hand operand of that constraint if the right-hand operand is known. If the right-hand operand is not known, then *V is set to a NULL pointer. The sqlite3_vtab_rhs_value(P,J,V) interface returns SQLITE_OK if and only if *V is set to a value. The sqlite3_vtab_rhs_value(P,J,V) inteface returns SQLITE_NOTFOUND if the right-hand side of the J-th constraint is not available. The sqlite3_vtab_rhs_value() interface can return an result code other than SQLITE_OK or SQLITE_NOTFOUND if something goes wrong.\n\nThe sqlite3_vtab_rhs_value() interface is usually only successful if the right-hand operand of a constraint is a literal value in the original SQL statement. If the right-hand operand is an expression or a reference to some other column or a host parameter, then sqlite3_vtab_rhs_value() will probably return SQLITE_NOTFOUND.\n\nSome constraints, such as SQLITE_INDEX_CONSTRAINT_ISNULL and SQLITE_INDEX_CONSTRAINT_ISNOTNULL, have no right-hand operand. For such constraints, sqlite3_vtab_rhs_value() always returns SQLITE_NOTFOUND.\n\nThe sqlite3_value object returned in *V is a protected sqlite3_value and remains valid for the duration of the xBestIndex method call. When xBestIndex returns, the sqlite3_value object returned by sqlite3_vtab_rhs_value() is automatically deallocated.\n\nThe \"_rhs_\" in the name of this routine is an abbreviation for \"Right-Hand Side\".\n\nThe sqlite3_wal_autocheckpoint(D,N) is a wrapper around sqlite3_wal_hook() that causes any database on database connection D to automatically checkpoint after committing a transaction if there are N or more frames in the write-ahead log file. Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.\n\nThe callback registered by this function replaces any existing callback registered using sqlite3_wal_hook(). Likewise, registering a callback using sqlite3_wal_hook() disables the automatic checkpoint mechanism configured by this function.\n\nThe wal_autocheckpoint pragma can be used to invoke this interface from SQL.\n\nCheckpoints initiated by this mechanism are PASSIVE.\n\nEvery new database connection defaults to having the auto-checkpoint enabled with a threshold of 1000 or SQLITE_DEFAULT_WAL_AUTOCHECKPOINT pages. The use of this interface is only necessary if the default setting is found to be suboptimal for a particular application.\n\nThe sqlite3_wal_checkpoint(D,X) is equivalent to sqlite3_wal_checkpoint_v2(D,X,SQLITE_CHECKPOINT_PASSIVE,0,0).\n\nIn brief, sqlite3_wal_checkpoint(D,X) causes the content in the write-ahead log for database X on database connection D to be transferred into the database file and for the write-ahead log to be reset. See the checkpointing documentation for addition information.\n\nThis interface used to be the only way to cause a checkpoint to occur. But then the newer and more powerful sqlite3_wal_checkpoint_v2() interface was added. This interface is retained for backwards compatibility and as a convenience for applications that need to manually start a callback but which do not need the full power (and corresponding complication) of sqlite3_wal_checkpoint_v2().\n\nThe sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of database connection D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:\n\nIf pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.\n\nAll calls obtain an exclusive \"checkpoint\" lock on the database file. If any other process is running a checkpoint operation at the same time, the lock cannot be obtained and SQLITE_BUSY is returned. Even if there is a busy-handler configured, it will not be invoked in this case.\n\nThe SQLITE_CHECKPOINT_FULL, RESTART and TRUNCATE modes also obtain the exclusive \"writer\" lock on the database file. If the writer lock cannot be obtained immediately, and a busy-handler is configured, it is invoked and the writer lock retried until either the busy-handler returns 0 or the lock is successfully obtained. The busy-handler is also invoked while waiting for database readers as described above. If the busy-handler returns 0 before the writer lock is obtained or while waiting for database readers, the checkpoint operation proceeds from that point in the same way as SQLITE_CHECKPOINT_PASSIVE - checkpointing as many frames as possible without blocking any further. SQLITE_BUSY is returned in this case.\n\nIf parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases attached to database connection db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.\n\nIf database zDb is the name of an attached database that is not in WAL mode, SQLITE_OK is returned and both *pnLog and *pnCkpt set to -1. If zDb is not NULL (or a zero length string) and is not the name of any attached database, SQLITE_ERROR is returned to the caller.\n\nUnless it returns SQLITE_MISUSE, the sqlite3_wal_checkpoint_v2() interface sets the error information that is queried by sqlite3_errcode() and sqlite3_errmsg().\n\nThe PRAGMA wal_checkpoint command can be used to invoke this interface from SQL.\n\nThe sqlite3_wal_hook() function is used to register a callback that is invoked each time data is committed to a database in wal mode.\n\nThe callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or checkpoint the database as required.\n\nThe first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either \"main\" or the name of an ATTACH-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.\n\nThe callback function should normally return SQLITE_OK. If an error code is returned, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred. If the callback returns SQLITE_ROW or SQLITE_DONE, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.\n\nA single database handle may have at most a single write-ahead log callback registered at one time. Calling sqlite3_wal_hook() replaces any previously registered write-ahead log callback. The return value is a copy of the third parameter from the previous call, if any, or 0. Note that the sqlite3_wal_autocheckpoint() interface and the wal_autocheckpoint pragma both invoke sqlite3_wal_hook() and will overwrite any prior sqlite3_wal_hook() settings.\n\nMany SQLite functions return an integer result code from the set shown here in order to indicate success or failure.\n\nNew error codes may be added in future versions of SQLite.\n\nIn its default configuration, SQLite API routines return one of 30 integer result codes. However, experience has shown that many of these result codes are too coarse-grained. They do not provide as much information about problems as programmers might like. In an effort to address this, newer versions of SQLite (version 3.3.8 2006-10-09 and later) include support for additional result codes that provide more detailed information about errors. These extended result codes are enabled or disabled on a per database connection basis using the sqlite3_extended_result_codes() API. Or, the extended code for the most recent error can be obtained using sqlite3_extended_errcode().\n\nThese integer constants can be used as the third parameter to the xAccess method of an sqlite3_vfs object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the temp_store_directory pragma, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.\n\nThe sqlite3_set_authorizer() interface registers a callback function that is invoked to authorize certain SQL statement actions. The second parameter to the callback is an integer code that specifies what action is being authorized. These are the integer action codes that the authorizer callback may be passed.\n\nThese action code values signify what kind of operation is to be authorized. The 3rd and 4th parameters to the authorization callback function will be parameters or NULL depending on which of these codes is used as the second parameter. The 5th parameter to the authorizer callback is the name of the database (\"main\", \"temp\", etc.) if applicable. The 6th parameter to the authorizer callback is the name of the inner-most trigger or view that is responsible for the access attempt or NULL if this access attempt is directly from top-level SQL code.\n\nThese constant define integer codes that represent the various text encodings supported by SQLite.\n\nEvery value in SQLite has one of five fundamental datatypes:\n\nThese constants are codes for each of those types.\n\nNote that the SQLITE_TEXT constant was also used in SQLite version 2 for a completely different meaning. Software that links against both SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not SQLITE_TEXT.\n\nThese constants define all valid values for the \"checkpoint mode\" passed as the third parameter to the sqlite3_wal_checkpoint_v2() interface. See the sqlite3_wal_checkpoint_v2() documentation for details on the meaning of each of these checkpoint modes.\n\nThese constants are the available integer configuration options that can be passed as the first argument to the sqlite3_config() interface.\n\nMost of the configuration options for sqlite3_config() will only work if invoked prior to sqlite3_initialize() or after sqlite3_shutdown(). The few exceptions to this rule are called \"anytime configuration options\". Calling sqlite3_config() with a first argument that is not an anytime configuration option in between calls to sqlite3_initialize() and sqlite3_shutdown() is a no-op that returns SQLITE_MISUSE.\n\nThe set of anytime configuration options can change (by insertions and/or deletions) from one release of SQLite to the next. As of SQLite version 3.42.0, the complete set of anytime configuration options is:\n\nNew configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from sqlite3_config() to make sure that the call worked. The sqlite3_config() interface will return a non-zero error code if a discontinued or unsupported configuration option is invoked.\n\nThese constants are the available integer configuration options that can be passed as the second parameter to the sqlite3_db_config() interface.\n\nThe sqlite3_db_config() interface is a var-args functions. It takes a variable number of parameters, though always at least two. The number of parameters passed into sqlite3_db_config() depends on which of these constants is given as the second parameter. This documentation page refers to parameters beyond the second as \"arguments\". Thus, when this page says \"the N-th argument\" it means \"the N-th parameter past the configuration option\" or \"the (N+2)-th parameter to sqlite3_db_config()\".\n\nNew configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from sqlite3_db_config() to make sure that the call worked. The sqlite3_db_config() interface will return a non-zero error code if a discontinued or unsupported configuration option is invoked.\n\nMost of the SQLITE_DBCONFIG options take two arguments, so that the overall call to sqlite3_db_config() has a total of four parameters. The first argument (the third parameter to sqlite3_db_config()) is a integer. The second argument is a pointer to an integer. If the first argument is 1, then the option becomes enabled. If the first integer argument is 0, then the option is disabled. If the first argument is -1, then the option setting is unchanged. The second argument, the pointer to an integer, may be NULL. If the second argument is not NULL, then a value of 0 or 1 is written into the integer to which the second argument points, depending on whether the setting is disabled or enabled after applying any changes specified by the first argument.\n\nWhile most SQLITE_DBCONFIG options use the argument format described in the previous paragraph, the SQLITE_DBCONFIG_MAINDBNAME and SQLITE_DBCONFIG_LOOKASIDE options are different. See the documentation of those exceptional options for details.\n\nThe authorizer callback function must return either SQLITE_OK or one of these two constants in order to signal SQLite whether or not the action is permitted. See the authorizer documentation for additional information.\n\nNote that SQLITE_IGNORE is also used as a conflict resolution mode returned from the sqlite3_vtab_on_conflict() interface.\n\nThe following are allowed values for 6th argument (the F argument) to the sqlite3_deserialize(D,S,P,N,M,F) interface.\n\nThe SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization in the P argument is held in memory obtained from sqlite3_malloc64() and that SQLite should take ownership of this memory and automatically free it when it has finished using it. Without this flag, the caller is responsible for freeing any dynamically allocated memory.\n\nThe SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to grow the size of the database using calls to sqlite3_realloc64(). This flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used. Without this flag, the deserialized database cannot increase in size beyond the number of bytes specified by the M parameter.\n\nThe SQLITE_DESERIALIZE_READONLY flag means that the deserialized database should be treated as read-only.\n\nThese constants may be ORed together with the preferred text encoding as the fourth argument to sqlite3_create_function(), sqlite3_create_function16(), or sqlite3_create_function_v2().\n\nThese constants are returned by sqlite3_vtab_on_conflict() to inform a virtual table implementation what the ON CONFLICT mode is for the SQL statement being evaluated.\n\nNote that the SQLITE_IGNORE constant is also used as a potential return value from the sqlite3_set_authorizer() callback and that SQLITE_ABORT is also a result code.\n\nThese integer constants are opcodes for the xFileControl method of the sqlite3_io_methods object and for the sqlite3_file_control() interface.\n• The SQLITE_FCNTL_LOCKSTATE opcode is used for debugging. This opcode causes the xFileControl method to write the current state of the lock (one of SQLITE_LOCK_NONE, SQLITE_LOCK_SHARED, SQLITE_LOCK_RESERVED, SQLITE_LOCK_PENDING, or SQLITE_LOCK_EXCLUSIVE) into an integer that the pArg argument points to. This capability is only available if SQLite is compiled with SQLITE_DEBUG.\n• The SQLITE_FCNTL_SIZE_HINT opcode is used by SQLite to give the VFS layer a hint of how large the database file will grow to be during the current transaction. This hint is not guaranteed to be accurate but it is often close. The underlying VFS might choose to preallocate database file space based on this hint in order to help writes to the database file run faster.\n• The SQLITE_FCNTL_SIZE_LIMIT opcode is used by in-memory VFS that implements sqlite3_deserialize() to set an upper bound on the size of the in-memory database. The argument is a pointer to a sqlite3_int64. If the integer pointed to is negative, then it is filled in with the current limit. Otherwise the limit is set to the larger of the value of the integer pointed to and the current database size. The integer pointed to is set to the new limit.\n• The SQLITE_FCNTL_CHUNK_SIZE opcode is used to request that the VFS extends and truncates the database file in chunks of a size specified by the user. The fourth argument to sqlite3_file_control() should point to an integer (type int) containing the new chunk-size to use for the nominated database. Allocating database file space in large chunks (say 1MB at a time), may reduce file-system fragmentation and improve performance on some systems.\n• The SQLITE_FCNTL_FILE_POINTER opcode is used to obtain a pointer to the sqlite3_file object associated with a particular database connection. See also SQLITE_FCNTL_JOURNAL_POINTER.\n• The SQLITE_FCNTL_JOURNAL_POINTER opcode is used to obtain a pointer to the sqlite3_file object associated with the journal file (either the rollback journal or the write-ahead log) for a particular database connection. See also SQLITE_FCNTL_FILE_POINTER.\n• No longer in use.\n• The SQLITE_FCNTL_SYNC opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with PRAGMA synchronous=OFF it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions super-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call sqlite3_file_control() with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.\n• The SQLITE_FCNTL_COMMIT_PHASETWO opcode is generated internally by SQLite and sent to the VFS after a transaction has been committed immediately but before the database is unlocked. VFSes that do not need this signal should silently ignore this opcode. Applications should not call sqlite3_file_control() with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.\n• The SQLITE_FCNTL_WIN32_AV_RETRY opcode is used to configure automatic retry counts and intervals for certain disk I/O operations for the windows VFS in order to provide robustness in the presence of anti-virus programs. By default, the windows VFS will retry file read, file write, and file delete operations up to 10 times, with a delay of 25 milliseconds before the first retry and with the delay increasing by an additional 25 milliseconds with each subsequent retry. This opcode allows these two values (10 retries and 25 milliseconds of delay) to be adjusted. The values are changed for all database connections within the same process. The argument is a pointer to an array of two integers where the first integer is the new retry count and the second integer is the delay. If either integer is negative, then the setting is not changed but instead the prior value of that setting is written into the array entry, allowing the current retry settings to be interrogated. The zDbName parameter is ignored.\n• The SQLITE_FCNTL_PERSIST_WAL opcode is used to set or query the persistent Write Ahead Log setting. By default, the auxiliary write ahead log (WAL file) and shared memory files used for transaction control are automatically deleted when the latest connection to the database closes. Setting persistent WAL mode causes those files to persist after close. Persisting the files is useful when other processes that do not have write permission on the directory containing the database file want to read the database file, as the WAL and shared memory files must exist in order for the database to be readable. The fourth parameter to sqlite3_file_control() for this opcode should be a pointer to an integer. That integer is 0 to disable persistent WAL mode or 1 to enable persistent WAL mode. If the integer is -1, then it is overwritten with the current WAL persistence setting.\n• The SQLITE_FCNTL_POWERSAFE_OVERWRITE opcode is used to set or query the persistent \"powersafe-overwrite\" or \"PSOW\" setting. The PSOW setting determines the SQLITE_IOCAP_POWERSAFE_OVERWRITE bit of the xDeviceCharacteristics methods. The fourth parameter to sqlite3_file_control() for this opcode should be a pointer to an integer. That integer is 0 to disable zero-damage mode or 1 to enable zero-damage mode. If the integer is -1, then it is overwritten with the current zero-damage mode setting.\n• The SQLITE_FCNTL_OVERWRITE opcode is invoked by SQLite after opening a write transaction to indicate that, unless it is rolled back for some reason, the entire database file will be overwritten by the current transaction. This is used by VACUUM operations.\n• The SQLITE_FCNTL_VFSNAME opcode can be used to obtain the names of all VFSes in the VFS stack. The names are of all VFS shims and the final bottom-level VFS are written into memory obtained from sqlite3_malloc() and the result is stored in the char* variable that the fourth parameter of sqlite3_file_control() points to. The caller is responsible for freeing the memory when done. As with all file-control actions, there is no guarantee that this will actually do anything. Callers should initialize the char* variable to a NULL pointer in case this file-control is not implemented. This file-control is intended for diagnostic use only.\n• The SQLITE_FCNTL_VFS_POINTER opcode finds a pointer to the top-level VFSes currently in use. The argument X in sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be of type \"sqlite3_vfs **\". This opcodes will set *X to a pointer to the top-level VFS. When there are multiple VFS shims in the stack, this opcode finds the upper-most shim only.\n• Whenever a PRAGMA statement is parsed, an SQLITE_FCNTL_PRAGMA file control is sent to the open sqlite3_file object corresponding to the database file to which the pragma statement refers. The argument to the SQLITE_FCNTL_PRAGMA file control is an array of pointers to strings (char**) in which the second element of the array is the name of the pragma and the third element is the argument to the pragma or NULL if the pragma has no argument. The handler for an SQLITE_FCNTL_PRAGMA file control can optionally make the first element of the char** argument point to a string obtained from sqlite3_mprintf() or the equivalent and that string will become the result of the pragma or the error message if the pragma fails. If the SQLITE_FCNTL_PRAGMA file control returns SQLITE_NOTFOUND, then normal PRAGMA processing continues. If the SQLITE_FCNTL_PRAGMA file control returns SQLITE_OK, then the parser assumes that the VFS has handled the PRAGMA itself and the parser generates a no-op prepared statement if result string is NULL, or that returns a copy of the result string if the string is non-NULL. If the SQLITE_FCNTL_PRAGMA file control returns any result code other than SQLITE_OK or SQLITE_NOTFOUND, that means that the VFS encountered an error while handling the PRAGMA and the compilation of the PRAGMA fails with an error. The SQLITE_FCNTL_PRAGMA file control occurs at the beginning of pragma statement analysis and so it is able to override built-in PRAGMA statements.\n• The SQLITE_FCNTL_BUSYHANDLER file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connection's busy-handler callback. The argument is of type (void**) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connection's busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.\n• Applications can invoke the SQLITE_FCNTL_TEMPFILENAME file-control to have SQLite generate a temporary filename using the same algorithm that is followed to generate temporary filenames for TEMP tables and other internal uses. The argument should be a char** which will be filled with the filename written into memory obtained from sqlite3_malloc(). The caller should invoke sqlite3_free() on the result to avoid a memory leak.\n• The SQLITE_FCNTL_MMAP_SIZE file control is used to query or set the maximum number of bytes that will be used for memory-mapped I/O. The argument is a pointer to a value of type sqlite3_int64 that is an advisory maximum number of bytes in the file to memory map. The pointer is overwritten with the old value. The limit is not changed if the value originally pointed to is negative, and so the current limit can be queried by passing in a pointer to a negative number. This file-control is used internally to implement PRAGMA mmap_size.\n• The SQLITE_FCNTL_TRACE file control provides advisory information to the VFS about what the higher layers of the SQLite stack are doing. This file control is used by some VFS activity tracing shims. The argument is a zero-terminated string. Higher layers in the SQLite stack may generate instances of this file control if the SQLITE_USE_FCNTL_TRACE compile-time option is enabled.\n• The SQLITE_FCNTL_HAS_MOVED file control interprets its argument as a pointer to an integer and it writes a boolean into that integer depending on whether or not the file has been renamed, moved, or deleted since it was first opened.\n• The SQLITE_FCNTL_WIN32_GET_HANDLE opcode can be used to obtain the underlying native file handle associated with a file handle. This file control interprets its argument as a pointer to a native file handle and writes the resulting value there.\n• The SQLITE_FCNTL_WIN32_SET_HANDLE opcode is used for debugging. This opcode causes the xFileControl method to swap the file handle with the one pointed to by the pArg argument. This capability is used during testing and only needs to be supported when SQLITE_TEST is defined.\n• The SQLITE_FCNTL_NULL_IO opcode sets the low-level file descriptor or file handle for the sqlite3_file object such that it will no longer read or write to the database file.\n• The SQLITE_FCNTL_WAL_BLOCK is a signal to the VFS layer that it might be advantageous to block on the next WAL lock if the lock is not immediately available. The WAL subsystem issues this signal during rare circumstances in order to fix a problem with priority inversion. Applications should not use this file-control.\n• The SQLITE_FCNTL_ZIPVFS opcode is implemented by zipvfs only. All other VFS should return SQLITE_NOTFOUND for this opcode.\n• The SQLITE_FCNTL_RBU opcode is implemented by the special VFS used by the RBU extension only. All other VFS should return SQLITE_NOTFOUND for this opcode.\n• If the SQLITE_FCNTL_BEGIN_ATOMIC_WRITE opcode returns SQLITE_OK, then the file descriptor is placed in \"batch write mode\", which means all subsequent write operations will be deferred and done atomically at the next SQLITE_FCNTL_COMMIT_ATOMIC_WRITE. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing SQLITE_FCNTL_COMMIT_ATOMIC_WRITE or SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE, SQLite will make no VFS interface calls on the same sqlite3_file file descriptor except for calls to the xWrite method and the xFileControl method with SQLITE_FCNTL_SIZE_HINT.\n• The SQLITE_FCNTL_COMMIT_ATOMIC_WRITE opcode causes all write operations since the previous successful call to SQLITE_FCNTL_BEGIN_ATOMIC_WRITE to be performed atomically. This file control returns SQLITE_OK if and only if the writes were all performed successfully and have been committed to persistent storage. Regardless of whether or not it is successful, this file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without a prior successful call to SQLITE_FCNTL_BEGIN_ATOMIC_WRITE.\n• The SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE opcode causes all write operations since the previous successful call to SQLITE_FCNTL_BEGIN_ATOMIC_WRITE to be rolled back. This file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without a prior successful call to SQLITE_FCNTL_BEGIN_ATOMIC_WRITE.\n• The SQLITE_FCNTL_LOCK_TIMEOUT opcode is used to configure a VFS to block for up to M milliseconds before failing when attempting to obtain a file lock using the xLock or xShmLock methods of the VFS. The parameter is a pointer to a 32-bit signed integer that contains the value that M is to be set to. Before returning, the 32-bit signed integer is overwritten with the previous value of M.\n• The SQLITE_FCNTL_DATA_VERSION opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The \"data version\" for the pager is written into the pointer. The \"data version\" changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The sqlite3_total_changes() interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the sqlite3_total_changes() interface responds to internal changes only and omits changes made by other database connections. The PRAGMA data_version command provides a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.\n• The SQLITE_FCNTL_CKPT_START opcode is invoked from within a checkpoint in wal mode before the client starts to copy pages from the wal file to the database file.\n• The SQLITE_FCNTL_CKPT_DONE opcode is invoked from within a checkpoint in wal mode after the client has finished copying pages from the wal file to the database file, but before the *-shm file is updated to record the fact that the pages have been checkpointed.\n• The EXPERIMENTAL SQLITE_FCNTL_EXTERNAL_READER opcode is used to detect whether or not there is a database client in another process with a wal-mode transaction open on the database or not. It is only available on unix.The (void*) argument passed with this file-control should be a pointer to a value of type (int). The integer value is set to 1 if the database is a wal mode database and there exists at least one client in another process that currently has an SQL transaction open on the database. It is set to 0 if the database is not a wal-mode db, or if there is no such connection in any other process. This opcode cannot be used to detect transactions opened by clients within the current process, only within other processes.\n• The SQLITE_FCNTL_CKSM_FILE opcode is for use internally by the checksum VFS shim only.\n• If there is currently no transaction open on the database, and the database is not a temp db, then the SQLITE_FCNTL_RESET_CACHE file-control purges the contents of the in-memory page cache. If there is an open transaction, or if the db is a temp-db, this opcode is a no-op, not an error.\n\nThese macros define the allowed values for the sqlite3_index_info.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the WHERE clause of a query that uses a virtual table.\n\nThe left-hand operand of the operator is given by the corresponding aConstraint[].iColumn field. An iColumn of -1 indicates the left-hand operand is the rowid. The SQLITE_INDEX_CONSTRAINT_LIMIT and SQLITE_INDEX_CONSTRAINT_OFFSET operators have no left-hand operand, and so for those operators the corresponding aConstraint[].iColumn is meaningless and should not be used.\n\nAll operator values from SQLITE_INDEX_CONSTRAINT_FUNCTION through value 255 are reserved to represent functions that are overloaded by the xFindFunction method of the virtual table implementation.\n\nThe right-hand operands for each constraint might be accessible using the sqlite3_vtab_rhs_value() interface. Usually the right-hand operand is only available if it appears as a single constant literal in the input SQL. If the right-hand operand is another column or an expression (even a constant expression) or a parameter, then the sqlite3_vtab_rhs_value() probably will not be able to extract it. The SQLITE_INDEX_CONSTRAINT_ISNULL and SQLITE_INDEX_CONSTRAINT_ISNOTNULL operators have no right-hand operand and hence calls to sqlite3_vtab_rhs_value() for those operators will always return SQLITE_NOTFOUND.\n\nThe collating sequence to be used for comparison can be found using the sqlite3_vtab_collation() interface. For most real-world virtual tables, the collating sequence of constraints does not matter (for example because the constraints are numeric) and so the sqlite3_vtab_collation() interface is not commonly needed.\n\nVirtual table implementations are allowed to set the sqlite3_index_info.idxFlags field to some combination of these bits.\n\nThe xDeviceCharacteristics method of the sqlite3_io_methods object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the sqlite3_io_methods refers to.\n\nThe SQLITE_IOCAP_ATOMIC property means that all writes of any size are atomic. The SQLITE_IOCAP_ATOMICnnn values mean that writes of blocks that are nnn bytes in size and are aligned to an address which is an integer multiple of nnn are atomic. The SQLITE_IOCAP_SAFE_APPEND value means that when data is appended to a file, the data is appended first then the size of the file is extended, never the other way around. The SQLITE_IOCAP_SEQUENTIAL property means that information is written to disk in the same order as calls to xWrite(). The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that after reboot following a crash or power loss, the only bytes in a file that were written at the application level might have changed and that adjacent bytes, even bytes within the same sector are guaranteed to be unchanged. The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN flag indicates that a file cannot be deleted when open. The SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on read-only media and cannot be changed even by processes with elevated privileges.\n\nThe SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying filesystem supports doing multiple write operations atomically when those write operations are bracketed by SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and SQLITE_FCNTL_COMMIT_ATOMIC_WRITE.\n\nThe SQLITE_IOCAP_SUBPAGE_READ property means that it is ok to read from the database file in amounts that are not a multiple of the page size and that do not begin at a page boundary. Without this property, SQLite is careful to only do full-page reads and write on aligned pages, with the one exception that it will do a sub-page read of the first page to access the database header.\n\nSQLite uses one of these integer values as the second argument to calls it makes to the xLock() and xUnlock() methods of an sqlite3_io_methods object. These values are ordered from lest restrictive to most restrictive.\n\nThe argument to xLock() is always SHARED or higher. The argument to xUnlock is either SHARED or NONE.\n\nThe sqlite3_mutex_alloc() interface takes a single argument which is one of these integer constants.\n\nThe set of static mutexes may change from one SQLite release to the next. Applications that override the built-in mutex logic must be prepared to accommodate additional static mutexes.\n\nThese bit values are intended for use in the 3rd parameter to the sqlite3_open_v2() interface and in the 4th parameter to the sqlite3_vfs.xOpen method.\n\nOnly those flags marked as \"Ok for sqlite3_open_v2()\" may be used as the third argument to the sqlite3_open_v2() interface. The other flags have historically been ignored by sqlite3_open_v2(), though future versions of SQLite might change so that an error is raised if any of the disallowed bits are passed into sqlite3_open_v2(). Applications should not depend on the historical behavior.\n\nNote in particular that passing the SQLITE_OPEN_EXCLUSIVE flag into sqlite3_open_v2() does *not* cause the underlying database file to be opened using O_EXCL. Passing SQLITE_OPEN_EXCLUSIVE into sqlite3_open_v2() has historically be a no-op and might become an error in future versions of SQLite.\n\nThese constants define various flags that can be passed into \"prepFlags\" parameter of the sqlite3_prepare_v3() and sqlite3_prepare16_v3() interfaces.\n\nNew flags may be added in future releases of SQLite.\n\nThe following constants can be used for the T parameter to the sqlite3_stmt_scanstatus(S,X,T,V) interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.\n\nWhen the value returned to V is a string, space to hold that string is managed by the prepared statement S and will be automatically freed when S is finalized.\n\nNot all values are available for all query elements. When a value is not available, the output variable is set to -1 if the value is numeric, or to NULL if it is a string (SQLITE_SCANSTAT_NAME).\n\nThese integer constants define the various locking operations allowed by the xShmLock method of sqlite3_io_methods. The following are the only legal combinations of flags to the xShmLock method:\n\nWhen unlocking, the same SHARED or EXCLUSIVE flag must be supplied as was given on the corresponding lock.\n\nThe xShmLock method can transition between unlocked and SHARED or between unlocked and EXCLUSIVE. It cannot transition between SHARED and EXCLUSIVE.\n\nThe SQLITE_VERSION C preprocessor macro in the sqlite3.h header evaluates to a string literal that is the SQLite version in the format \"X.Y.Z\" where X is the major version number (always 3 for SQLite3) and Y is the minor version number and Z is the release number. The SQLITE_VERSION_NUMBER C preprocessor macro resolves to an integer with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same numbers used in SQLITE_VERSION. The SQLITE_VERSION_NUMBER for any given release of SQLite will also be larger than the release from which it is derived. Either Y will be held constant and Z will be incremented or else Y will be incremented and Z will be reset to zero.\n\nSince version 3.6.18 (2009-09-11), SQLite source code has been stored in the Fossil configuration management system. The SQLITE_SOURCE_ID macro evaluates to a string which identifies a particular check-in of SQLite within its configuration management system. The SQLITE_SOURCE_ID string contains the date and time of the check-in (UTC) and a SHA1 or SHA3-256 hash of the entire source tree. If the source code has been edited in any way since it was last checked in, then the last four hexadecimal digits of the hash may be modified.\n\nSee also: sqlite3_libversion(), sqlite3_libversion_number(), sqlite3_sourceid(), sqlite_version() and sqlite_source_id().\n\nThese are special values for the destructor that is passed in as the final argument to routines like sqlite3_result_blob(). If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.\n\nThe typedef is necessary to work around problems in certain C++ compilers.\n\nThese integer constants designate various run-time status parameters that can be returned by sqlite3_status().\n\nNew status parameters may be added from time to time.\n\nWhen SQLite invokes the xSync() method of an sqlite3_io_methods object it uses a combination of these integer values as the second argument.\n\nWhen the SQLITE_SYNC_DATAONLY flag is used, it means that the sync operation only needs to flush data to mass storage. Inode information need not be flushed. If the lower four bits of the flag equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics. If the lower four bits equal SQLITE_SYNC_FULL, that means to use Mac OS X style fullsync instead of fsync().\n\nDo not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags with the PRAGMA synchronous=NORMAL and PRAGMA synchronous=FULL settings. The synchronous pragma determines when calls to the xSync VFS method occur and applies uniformly across all platforms. The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how energetic or rigorous or forceful the sync operations are and only make a difference on Mac OSX for the default SQLite code. (Third-party VFS implementations might also make the distinction between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the operating systems natively supported by SQLite, only Mac OSX cares about the difference.)\n\nThese constants are the valid operation code parameters used as the first argument to sqlite3_test_control().\n\nThese parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the sqlite3_test_control() interface.\n\nThese constants identify classes of events that can be monitored using the sqlite3_trace_v2() tracing logic. The M argument to sqlite3_trace_v2(D,M,X,P) is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.\n\nNew tracing constants may be added in future releases.\n\nA trace callback has four arguments: xCallback(T,C,P,X). The T argument is one of the integer type codes above. The C argument is a copy of the context pointer passed in as the fourth argument to sqlite3_trace_v2(). The P and X arguments are pointers whose meanings depend on T.\n\nThese constants define the current transaction state of a database file. The sqlite3_txn_state(D,S) interface returns one of these constants in order to describe the transaction state of schema S in database connection D."
    },
    {
        "link": "https://tutorialspoint.com/sqlite/sqlite_c_cpp.htm",
        "document": "In this chapter, you will learn how to use SQLite in C/C++ programs.\n\nBefore you start using SQLite in our C/C++ programs, you need to make sure that you have SQLite library set up on the machine. You can check SQLite Installation chapter to understand the installation process.\n\nFollowing are important C/C++ SQLite interface routines, which can suffice your requirement to work with SQLite database from your C/C++ program. If you are looking for a more sophisticated application, then you can look into SQLite official documentation.\n\nThis routine opens a connection to an SQLite database file and returns a database connection object to be used by other SQLite routines. If the filename argument is NULL or ':memory:', sqlite3_open() will create an in-memory database in RAM that lasts only for the duration of the session. If the filename is not NULL, sqlite3_open() attempts to open the database file by using its value. If no file by that name exists, sqlite3_open() will open a new database file by that name. This routine provides a quick, easy way to execute SQL commands provided by sql argument which can consist of more than one SQL command. Here, the first argument sqlite3 is an open database object, sqlite_callback is a call back for which data is the 1st argument and errmsg will be returned to capture any error raised by the routine. SQLite3_exec() routine parses and executes every command given in the sql argument until it reaches the end of the string or encounters an error. This routine closes a database connection previously opened by a call to sqlite3_open(). All prepared statements associated with the connection should be finalized prior to closing the connection. If any queries remain that have not been finalized, sqlite3_close() will return SQLITE_BUSY with the error message Unable to close due to unfinalized statements.\n\nFollowing C code segment shows how to connect to an existing database. If the database does not exist, then it will be created and finally a database object will be returned.\n\nNow, let's compile and run the above program to create our database test.db in the current directory. You can change your path as per your requirement.\n\nIf you are going to use C++ source code, then you can compile your code as follows −\n\nHere, we are linking our program with sqlite3 library to provide required functions to C program. This will create a database file test.db in your directory and you will have the following result.\n\nFollowing C code segment will be used to create a table in the previously created database −\n\nWhen the above program is compiled and executed, it will create COMPANY table in your test.db and the final listing of the file will be as follows −\n\nFollowing C code segment shows how you can create records in COMPANY table created in the above example −\n\nWhen the above program is compiled and executed, it will create the given records in COMPANY table and will display the following two lines −\n\nBefore proceeding with actual example to fetch records, let us look at some detail about the callback function, which we are using in our examples. This callback provides a way to obtain results from SELECT statements. It has the following declaration −\n\nIf the above callback is provided in sqlite_exec() routine as the third argument, SQLite will call this callback function for each record processed in each SELECT statement executed within the SQL argument.\n\nFollowing C code segment shows how you can fetch and display records from the COMPANY table created in the above example −\n\nWhen the above program is compiled and executed, it will produce the following result.\n\nFollowing C code segment shows how we can use UPDATE statement to update any record and then fetch and display updated records from the COMPANY table.\n\nWhen the above program is compiled and executed, it will produce the following result.\n\nFollowing C code segment shows how you can use DELETE statement to delete any record and then fetch and display the remaining records from the COMPANY table.\n\nWhen the above program is compiled and executed, it will produce the following result."
    },
    {
        "link": "https://samuelowino.medium.com/sqlite3s-c-c-interface-is-really-concise-121792296947",
        "document": "SQLite support a concise application programming interface that’s extended by ORM library developers. The API is written and provided for C/C++ with a dedicated extension features such as sqlite3_create_collation, that provides support for creating and deleting a collation associated with the database connection.\n\nWith regards to this article, I intend on focusing on APIs that enable regular day-to-day database operations such as, creating a database, launching tables within the database and executing queries against that database and its respective tables.\n\nsqlite3 is an object that represents a database connection. Normally sqlite3 represents an open and active connection to the database, that way it can be used to execute sql queries and manage the database file.\n\nTo open a connection to a database, use sqlite3_open or sqlite3_open_v2. SQLite functions provide return codes that define the result of the operation such as opening a database connection in this case.\n\nIf the specified database file does not exist, SQLite will attempt to create it.\n\nsqlite3_open_v2 supports opening the database in different modes by specifying a flag.\n• SQLITE_OPEN_CREATE: Creates the database file if it does not exist\n• SQLITE_OPEN_URI: Interprets the passed in filename as a uri\n\nThese flags can be combined with a pipeline operator “|” or by using bitwise OR\n\nEach sqlite function returns an integer value indicating whether the operation was successful or if an error occurred.\n\nHere is a list of potential return codes\n\nsqlite3_errmsg is used to retrieve a human-readable string describing the most recent error in the database.\n\nsqlite3_errmsg retrieves a human-readable string describing the most recent error in the database.\n\nDue to security requirements and code efficiency needs, SQLite supports the concept of prepared statements. These prepared statements protect programs from common attacks, most notably SQL injection. It does this by passing SQL query params securely instead of by string concatenation on the actual query itself.\n\nThe sqlite3_stmt object is a prepared statement that allows the developer to prepare, execute and retrieve results from a query programmatically in a secure and efficient manner.\n\nsqlite3_stmt supports the use of ? for query params placeholders instead of actual values. SQLite supports binding parameters to these placeholders before the query is executed.\n\nsqlite3_prepare_v2 compiles a given sqlite3_stmt into a bytcode representation which is then executed by the SQLite engine. An intermediate representation of your query allows you to reuse a prepared statement (sqlite3_stmt) multiple times by binding different parameters and calling sqlite3_prepare_v2 multiple times. This promotes code reuse as well as security.\n\nThis can be very useful, for example inserting multiple values from an array.\n• Parsing: SQLite parses the provided SQL query string and checks it for syntax errors. If syntax errors are found the function returns SQLITE_ERROR as the return code and sets the appropriate error message in sqlite3_errmsg\n• Compilation: If no syntax errors exist on the SQL query, SQLite compiles the query into an internal bytecode format that the SQLite engine can execute. Once generated, the bytecode is stored in sqlite3_stmt object and returned via the pointer *ppStmt\n• Parameterization: When the SQL statement contains placeholders such as “?” the prepared statement is set in a way that allows multiple executions by parsing different values to the placeholders.\n• Memory Management: The generated bytecode is stored in memory for future execution. It is important to finalize the sqlite3_stmt with sqlite3_finalized when done using the stmt prepared with sqlite3_prepare_v2\n\nsqlite3_bind (as the name suggests) binds values to parameters specified with placeholders such as ?. There are multiple variants of the sqlite3_bind_* function for various supported data types.\n\nDuring binding, the parameters are indexed starting from index 1.\n\nsqlite3_step is responsible for executing SQL statements (sqlite3_stmt). Depending on the type of SQL query (INSERT, CREATE, DELETE, UPDATE…) sqlite3_step might return results, affected rows in the database or complete execution with a simple result code.\n\nsqlite3_step can return various codes that indicate the status of the operation.\n\nSQLITE_DONE : Indicates that the statement has finished executing successfully and no more rows are available.\n\nSQLITE_ROW : Indicates that the statement has successfully produced a row of data (used with SELECT queries). The data can be retrieved from sqlite using sqlite3_column_*\n\nSQLITE_BUSY : Indicates that the database file is currently locked\n\nSQLITE_ERROR : Indicates that a generic error occurred during the execution of sqlite3_step. The error can be collected via sqlite3_errmsg\n\nsqlite3_column_* comprises a family of functions that supports retrieval of values from a row of query result set. sqlite3_column_* functions are used after a call to sqlite3_step when a result code of SQLITE_ROW is detected.\n\nSQLITE_ROW indicates that a row of data is available for processing.\n\nHere is a list of common sqlite3_column_* functions:\n\n| Function | Purpose | Usage |\n\n|-------------------------------|-----------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------|\n\n| `sqlite3_column_blob()` | Returns the value of the column as a binary large object (BLOB). | Use when the column contains binary data. |\n\n| `sqlite3_column_double()` | Returns the value of the column as a `double` (floating-point number). | Use for numeric data interpreted as floating-point numbers. |\n\n| `sqlite3_column_int()` | Returns the value of the column as a 32-bit signed integer. | Use for numeric data within the 32-bit integer range. |\n\n| `sqlite3_column_int64()` | Returns the value of the column as a 64-bit signed integer. | Use for numeric data requiring 64-bit precision. |\n\n| `sqlite3_column_text()` | Returns the value of the column as a UTF-8 encoded string. | Use for text data in UTF-8 format. |\n\n| `sqlite3_column_text16()` | Returns the value of the column as a UTF-16 encoded string. | Use for text data in UTF-16 format. |\n\n| `sqlite3_column_type()` | Returns the data type of the column for the current row. | Use to identify data type (`INTEGER`, `FLOAT`, `TEXT`, `BLOB`, `NULL`). |\n\n| `sqlite3_column_bytes()` | Returns the number of bytes in a BLOB or UTF-8 string. | Use to determine the size of data returned by `sqlite3_column_blob()` or `sqlite3_column_text()`. |\n\n| `sqlite3_column_bytes16()` | Returns the number of bytes in a UTF-16 encoded string. | Use to determine the size of data returned by `sqlite3_column_text16()`. |\n\n| `sqlite3_column_name()` | Returns the name of the column in the result set. | Use to retrieve column names for metadata. |\n\n| `sqlite3_column_decltype()` | Returns the declared type of the column in the table schema. | Use to get declared types like `TEXT`, `INTEGER`, `BLOB`, etc. |\n\n| `sqlite3_column_table_name()` | Returns the name of the table from which the column originates. | Useful for identifying tables in complex queries. |\n\n| `sqlite3_column_origin_name()`| Returns the name of the column in the original table. | Useful for identifying source columns in multi-table queries. |\n\n| `sqlite3_column_database_name()` | Returns the name of the database containing the table that the column originates from. | Use in scenarios involving multiple databases. |\n\n| `sqlite3_column_value()` | Returns the value of the column as an `sqlite3_value` object. | Use for advanced or custom data manipulations. |\n\n| `sqlite3_column_count()` | Returns the number of columns in the current result set. | Use to iterate over all columns in a row. |\n\nAn sqlite3_stmt goes through the sqlite3_bind_* stage which binds parameters on the placeholders of the sqlite3_stmt. To reuse the sqlite3_stmt with new values on its placeholders, you call sqlite3_reset which will undo the previous sqlite3_bind stage.\n\nThis is essential when executing an sqlite3_stmt multiple times in a loop with different parameters and values\n\nA result code of SQLITE_OK would indicate the reset was successful, while any other error code might indicate a failure.\n\nIn the end, it is important to destroy the sqlite3_stmt and free all associated resources. sqlite3_finalize is used for this purpose. Calling sqlite3_finalize marks the end of the lifecycle of a prepared statement (sqlite3_stmt)\n\nThis call will free memory and associated resources used by sqlite3_stmt.\n\nTo summarise, the complete lifecycle of a sqlite3_stmt (prepared statement) is as follows:\n• Reset the sqlite3_stmt (prepared statement) for reuse with new values/parameters: sqlite3_reset\n• Finalize when done to free resources: sqlite3_finalize\n\nAfter all is done, always close the database connection: sqlite3_close(db).\n\nSQLite3 is a powerful database engine with a lot of capabilities and it follows software development wisdom, like Bjarne Stroustrap’s zero-overhead principle “You don’t pay for what you don’t use.” and Richard Kernegy’s spirit of C principles such as Simplicity and Minimalism “C is designed to be simple and efficient, providing a small set of features that can be combined in powerful ways”.\n\nPerhaps we can all agree that indeed: SQLite3’s database engine as well as its C/C++ Interface is Concise and by extension beautiful."
    },
    {
        "link": "https://stackoverflow.com/questions/60276634/sqlite-c-api-closing-a-database-is-there-an-official-documentation-error",
        "document": "In the official SQLite's C API documentation (www) for an API call I can read this:\n\nThe and routines are destructors for the object. Calls to and return if the object is successfully destroyed and all associated resources are deallocated. If the database connection is associated with unfinalized prepared statements or unfinished objects then will leave the database connection open and return .\n\nHow can these two functions with a return value return a string and ? This is impossible. Where can I catch the strings that functions are returning? I was thinking of using (www) like this:\n\nThis results in a lot of API calls which would probably stress the database. Does anyone have any better solution?"
    },
    {
        "link": "https://stackoverflow.com/questions/56566845/how-to-use-findnextfile-call-in-windows-to-list-directory-contents",
        "document": "In your first code snippet, you are clearly compiling your project with defined (as evident by you being able to pass a to without error). When is defined, maps to . But wants a instead. So the simpliest solution to that error is to just change to to satisfy the call to . But then you will have a new error because you would be passing a to , which wants a instead. So you will need to call instead to fix that error:\n\nIn your second code snippet, does not have an overloaded for data, but it does have an overload for . The field is a array, which decays into a pointer to the 1st character, and all pointers are implicitly convertible to . So that is why you are seeing memory addresses being printed. You need to use instead:\n\nMost Win32 APIs that deal with string data have (ANSI) and (Wide, Unicode) flavors, and provide generic -based macros to map to one or the other based on the conditional. In this case, maps to either or , maps to either or , map to either or , etc.\n\nSo the general rule is, the suffix you explicitly state (or omit) in an API function call should also be repeated in any related variable declarations as needed. If you call an API function explicitly, use appropriate variable types explicitly. If you call a API function explicitly, use appropriate variable types explicitly. If you omit / in an API function call, omit it in variable declarations (or replace with for , if needed)."
    },
    {
        "link": "https://stackoverflow.com/questions/2038912/how-to-recursively-traverse-directories-in-c-on-windows",
        "document": "Here is how you do it (this is all from memory so there may be errors):\n\nSo you could call this like\n\nto find all the *.wav files in C:\\WINDOWS and its subdirectories.\n\nTechnically you don't have to do two FindFirstFile() calls, but I find the pattern matching functions Microsoft provides (i.e. PathMatchFileSpec or whatever) aren't as capable as FindFirstFile(). Though for \"*.wav\" it would probably be fine."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/fileio/listing-the-files-in-a-directory",
        "document": "The following example calls FindFirstFile, FindNextFile, and FindClose to list files in a specified directory."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstfilea",
        "document": "Searches a directory for a file or subdirectory with a name that matches a specific name (or partial name if wildcards are used).\n\nTo specify additional attributes to use in a search, use the FindFirstFileEx function.\n\nTo perform this operation as a transacted operation, use the FindFirstFileTransacted function.\n\nThe directory or path, and the file name. The file name can include wildcard characters, for example, an asterisk (*) or a question mark (?).\n\nThis parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\\).\n\nIf the string ends with a wildcard, period (.), or directory name, the user must have access permissions to the root and all subdirectories on the path.\n\nBy default, the name is limited to MAX_PATH characters. To extend this limit to 32,767 wide characters, prepend \"\\\\?\\\" to the path. For more information, see Naming Files, Paths, and Namespaces.\n\nA pointer to the WIN32_FIND_DATA structure that receives information about a found file or directory.\n\nIf the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or FindClose, and the lpFindFileData parameter contains information about the first file or directory found.\n\nIf the function fails or fails to locate files from the search string in the lpFileName parameter, the return value is INVALID_HANDLE_VALUE and the contents of lpFindFileData are indeterminate. To get extended error information, call the GetLastError function.\n\nIf the function fails because no matching files can be found, the GetLastError function returns ERROR_FILE_NOT_FOUND.\n\nThe FindFirstFile function opens a search handle and returns information about the first file that the file system finds with a name that matches the specified pattern. This may or may not be the first file or directory that appears in a directory-listing application (such as the dir command) when given the same file name string pattern. This is because FindFirstFile does no sorting of the search results. For additional information, see FindNextFile.\n\nThe following list identifies some other search characteristics:\n• The search is performed strictly on the name of the file, not on any attributes such as a date or a file type (for other options, see FindFirstFileEx).\n• The search includes the long and short file names.\n• An attempt to open a search with a trailing backslash always fails.\n• Passing an invalid string, NULL, or empty string for the lpFileName parameter is not a valid use of this function. Results in this case are undefined.\n\nAfter the search handle is established, you can use it to search for other files that match the same pattern by using the FindNextFile function.\n\nWhen the search handle is no longer needed, close it by using the FindClose function, not CloseHandle.\n\nAs stated previously, you cannot use a trailing backslash (\\) in the lpFileName input string for FindFirstFile, therefore it may not be obvious how to search root directories. If you want to see files or get the attributes of a root directory, the following options would apply:\n• To examine files in a root directory, you can use \"C:\\*\" and step through the directory by using FindNextFile.\n• To get the attributes of a root directory, use the GetFileAttributes function.\n\nNote Prepending the string \"\\\\?\\\" does not allow access to the root directory.\n\nOn network shares, you can use an lpFileName in the form of the following: \"\\\\Server\\Share\\*\". However, you cannot use an lpFileName that points to the share itself; for example, \"\\\\Server\\Share\" is not valid.\n\nTo examine a directory that is not a root directory, use the path to that directory, without a trailing backslash. For example, an argument of \"C:\\Windows\" returns information about the directory \"C:\\Windows\", not about a directory or file in \"C:\\Windows\". To examine the files and directories in \"C:\\Windows\", use an lpFileName of \"C:\\Windows\\*\".\n\nBe aware that some other thread or process could create or delete a file with this name between the time you query for the result and the time you act on the information. If this is a potential concern for your application, one possible solution is to use the CreateFile function with CREATE_NEW (which fails if the file exists) or OPEN_EXISTING (which fails if the file does not exist).\n\nIf you are writing a 32-bit application to list all the files in a directory and the application may be run on a 64-bit computer, you should call the Wow64DisableWow64FsRedirection function before calling FindFirstFile and call Wow64RevertWow64FsRedirection after the last call to FindNextFile. For more information, see File System Redirector.\n\nIf the path points to a symbolic link, the WIN32_FIND_DATA buffer contains information about the symbolic link, not the target.\n\nIn Windows 8 and Windows Server 2012, this function is supported by the following technologies.\n\nThe following C++ example shows you a minimal use of FindFirstFile.\n\nFor another example, see Listing the Files in a Directory."
    },
    {
        "link": "https://wholetomato.com/blog/2024/11/14/how-to-query-file-attributes-50x-faster-on-windows",
        "document": "Imagine you’re developing a tool that needs to scan for file changes across thousands of project files. Retrieving file attributes efficiently becomes critical for such scenarios. In this article, I’ll demonstrate a technique to get file attributes that can achieve a surprising speedup of over 50+ times compared to standard Windows methods.\n\nLet’s dive in and explore how we can achieve this.\n\nThis is a blog post made in collaboration with Bartlomiej Filipek from C++ stories. You can visit his blog here.\n\nThe inspiration for this article came from a recent update for Visual Assist – a tool that heavily improves Visual Studio experience and productivity for C# and C++ developers.\n\nIn one of their blog post, they shared:\n\nAfter watching the webinar, I noticed some details about efficiently getting file attributes and I decided to give it a try on my machine. In other words I tried to recreate their results.\n\nDisclaimer: Idera, the company behind Visual Assist, helped me write this post and sponsored it.\n\nOn Windows, there are at least a few options to check for a file change:\n\nBelow, you can see some primary usage of each approach:\n\nis a Windows API function that allows for efficient searching of directories. It retrieves information about files that match a specified file name pattern. The function can be used with different information levels, such as and , to control the amount of file information fetched.\n\nAdditionally you can also pass as the additional flag to indicate that the function should use a larger buffer which might bring some extra performance.\n\nis another Windows API function that retrieves file attributes for a specified file or directory. Unlike , which is used for searching and listing files, is typically used for retrieving attributes of a single file or directory.\n\nis a low level routine that might be tricky to use, but gives us more control over the iteration. The main idea is to get a lerge buffer of data and read it on the application side, rather than rely on sometimes costly kernel/system calls.\n\nAssuming you have a file open, which is a directory, you can iterate over its children in the following way:\n\nIntroduced in C++17, the library provides a modern and portable way to interact with the file system. It includes functions for file attribute retrieval, directory iteration, and other common file system operations.\n\nTo evaluate the performance of different file attribute retrieval methods, I developed a small benchmark. This application measures the time taken by each method to retrieve file attributes for N number of files in a specified directory.\n\nThe struct stores the file name and last write time.\n\nEach retrieval technique will have to go over a directory and build a vector of objects.\n\nAnd the last one, the most portable technique:\n\nThe function sets up the benchmarking environment, runs the benchmarks, and prints the results.\n\nTo measure the performance of each file attribute retrieval method, I executed benchmarks on a directory containing 1000, 2000 or 5000 random text files. The tests were performed on a laptop equipped with an Intel i7 4720HQ CPU and an SSD. I measured the time taken by each method and compared the results to determine the fastest approach.\n\nEach test run consisted of two executions: the first with uncached file attributes and the second likely benefiting from system-level caching.\n\nThe speedup factor is the factor of the current result compared to the slowest technique in a given run.\n\nThe results consistently showed that with the flag was the fastest method in uncached scenarios, offering speedups up to 129x compared to . However, in cached scenarios, (Basic and Standard) achieved over 50x speedup improvements. The parameters for “Large Fetch” seems to increase the performance.\n\nFor the directory with 2000 files, (Basic) demonstrated a speedup factor of over 179x in the first run and went down to 68 in the second run. In the directory with 5000 files, we can see that takes crown and acheives 59x speedup, while other techniques reaches 43x max. Notably, performed on par with .\n\nGetting file attributes is only part of the story, and while important, they may contribute to only a small portion of the overall performance for the whole project. The Visual Assist team, who contributed to this article, improved their initial parse time performance by avoiding using the same techniques as this article. But Visual Assist also improved performance through further techniques. My simple benchmark showed 50x speedups, but we cannot directly compare it with the final Visual Assist, as the tool does many more things with files.\n\nThe main item being optimised was the initial parse, where VA builds a symbol database when a project is opened for the first time. This involves parsing all code and all headers. They decided that it’s a reasonable assumption that headers won’t change while a project is being loaded, and so the file access is cached during the initial parse, avoiding the filesystem entirely. (Changes after a project has been parsed the first time are, of course, still caught.) The combination of switching to a much faster method for checking filetimes and then avoiding file IO completely contributed to the up-to-15-times-faster performance improvement they saw in version 2024.1 at the beginning of this year.\n\nRead further details on their blog Visual Assist 2024.1 release post – January 2024 and Catching up with VA: Our most recent performance updates – Tomato Soup.\n\nIn the text, we went through a benchmark that compares several techniques for fetching file attributes. In short, it’s best to gather attributes at the same time as you iterate through the directory – using or via . So if you want to do this operation hundreds of times, it’s best to measure time and choose the best technique. What’s more, if you expect to have lots of files in a directory it’s good to check techniques offering larger buffers.\n\nThe benchmark also showed one feature: while C++17 and its library offer a robust and standardized way to work with files and directories, it can be limited in terms of performance. In many cases, if you need super optimal performance, you need to open the hood and work with the specific operating system API.\n• Do you use std::filesystem for tasks involving hundreds of files?\n• Do you know other techniques that offer greater performance when working with files?\n\nShare your comments below. And if you’re using C++, you can also download and try Visual Assist yourself for 30 days for free."
    }
]