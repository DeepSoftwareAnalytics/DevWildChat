[
    {
        "link": "https://docs.python.org/3/library/shutil.html",
        "document": "The module offers a number of high-level operations on files and collections of files. In particular, functions are provided which support file copying and removal. For operations on individual files, see also the module.\n\nChanged in version 3.5: Added support for the xztar format. High-level utilities to create and read compressed and archived files are also provided. They rely on the and modules. Create an archive file (such as zip or tar) and return its name. base_name is the name of the file to create, including the path, minus any format-specific extension. format is the archive format: one of “zip” (if the module is available), “tar”, “gztar” (if the module is available), “bztar” (if the module is available), or “xztar” (if the module is available). root_dir is a directory that will be the root directory of the archive, all paths in the archive will be relative to it; for example, we typically chdir into root_dir before creating the archive. base_dir is the directory where we start archiving from; i.e. base_dir will be the common prefix of all files and directories in the archive. base_dir must be given relative to root_dir. See Archiving example with base_dir for how to use base_dir and root_dir together. root_dir and base_dir both default to the current directory. If dry_run is true, no archive is created, but the operations that would be executed are logged to logger. owner and group are used when creating a tar archive. By default, uses the current owner and group. logger must be an object compatible with PEP 282, usually an instance of . The verbose argument is unused and deprecated. This function is not thread-safe when custom archivers registered with do not support the root_dir argument. In this case it temporarily changes the current working directory of the process to root_dir to perform archiving. Changed in version 3.8: The modern pax (POSIX.1-2001) format is now used instead of the legacy GNU format for archives created with . Changed in version 3.10.6: This function is now made thread-safe during creation of standard and tar archives. Return a list of supported formats for archiving. Each element of the returned sequence is a tuple . By default provides these formats:\n• None zip: ZIP file (if the module is available).\n• None tar: Uncompressed tar file. Uses POSIX.1-2001 pax format for new archives.\n• None gztar: gzip’ed tar-file (if the module is available).\n• None bztar: bzip2’ed tar-file (if the module is available).\n• None xztar: xz’ed tar-file (if the module is available). You can register new formats or provide your own archiver for any existing formats, by using . Register an archiver for the format name. function is the callable that will be used to unpack archives. The callable will receive the base_name of the file to create, followed by the base_dir (which defaults to ) to start archiving from. Further arguments are passed as keyword arguments: owner, group, dry_run and logger (as passed in ). If function has the custom attribute set to , the root_dir argument is passed as a keyword argument. Otherwise the current working directory of the process is temporarily changed to root_dir before calling function. In this case is not thread-safe. If given, extra_args is a sequence of pairs that will be used as extra keywords arguments when the archiver callable is used. description is used by which returns the list of archivers. Defaults to an empty string. Changed in version 3.12: Added support for functions supporting the root_dir argument. Remove the archive format name from the list of supported formats. Unpack an archive. filename is the full path of the archive. extract_dir is the name of the target directory where the archive is unpacked. If not provided, the current working directory is used. format is the archive format: one of “zip”, “tar”, “gztar”, “bztar”, or “xztar”. Or any other format registered with . If not provided, will use the archive file name extension and see if an unpacker was registered for that extension. In case none is found, a is raised. The keyword-only filter argument is passed to the underlying unpacking function. For zip files, filter is not accepted. For tar files, it is recommended to set it to , unless using features specific to tar and UNIX-like filesystems. (See Extraction filters for details.) The filter will become the default for tar files in Python 3.14. Never extract archives from untrusted sources without prior inspection. It is possible that files are created outside of the path specified in the extract_dir argument, e.g. members that have absolute filenames starting with “/” or filenames with two dots “..”. Changed in version 3.7: Accepts a path-like object for filename and extract_dir. Registers an unpack format. name is the name of the format and extensions is a list of extensions corresponding to the format, like for Zip files. function is the callable that will be used to unpack archives. The callable will receive:\n• None the path of the archive, as a positional argument;\n• None the directory the archive must be extracted to, as a positional argument;\n• None possibly a filter keyword argument, if it was given to ;\n• None additional keyword arguments, specified by extra_args as a sequence of tuples. description can be provided to describe the format, and will be returned by the function. Unregister an unpack format. name is the name of the format. Return a list of all registered formats for unpacking. Each element of the returned sequence is a tuple . By default provides these formats:\n• None zip: ZIP file (unpacking compressed files works only if the corresponding module is available).\n• None gztar: gzip’ed tar-file (if the module is available).\n• None bztar: bzip2’ed tar-file (if the module is available).\n• None xztar: xz’ed tar-file (if the module is available). You can register new formats or provide your own unpacker for any existing formats, by using . In this example, we create a gzip’ed tar-file archive containing all files found in the directory of the user: In this example, similar to the one above, we show how to use , but this time with the usage of base_dir. We now have the following directory structure: In the final archive, should be included, but should not. Therefore we use the following: Listing the files in the resulting archive gives us:"
    },
    {
        "link": "https://geeksforgeeks.org/python-shutil-move-method",
        "document": "Shutil module in Python provides many functions of high-level operations on files and collections of files. It comes under Python’s standard utility modules. This module helps in automating the process of copying and removing files and directories.\n\nThe method moves a file or directory from a source to a destination. It handles directories recursively, moving the source into the destination directory if it exists. If the destination already exists as a file, it may be overwritten, depending on the behavior of . The method returns the new path of the destination.\n\nExample 1: Using files method to move a file from source to destination.\n\nExample 2: Using method to move file by using method and the destination directory exists already."
    },
    {
        "link": "https://geeksforgeeks.org/shutil-module-in-python",
        "document": "Shutil module offers high-level operation on a file like a copy, create, and remote operation on the file. It comes under Python’s standard utility modules. This module helps in automating the process of copying and removal of files and directories. In this article, we will learn this module.\n\nshutil.copy() method in Python is used to copy the content of the source file to the destination file or directory. It also preserves the file’s permission mode but other metadata of the file like the file’s creation and modification times is not preserved.\n\nThe source must represent a file but the destination can be a file or a directory. If the destination is a directory then the file will be copied into the destination using the base filename from the source. Also, the destination must be writable. If the destination is a file and already exists then it will be replaced with the source file otherwise a new file will be created.\n\nExample 2: If the destination is a directory.\n\nCopying the Metadata along with File\n\nshutil.copy2() method in Python is used to copy the content of the source file to the destination file or directory. This method is identical to shutil.copy() method but it also tries to preserve the file’s metadata.\n\nExample 2: If the destination is a directory\n\nCopying the content of one file to another\n\nshutil.copyfile() method in Python is used to copy the content of the source file to the destination file. The metadata of the file is not copied. Source and destination must represent a file and destination must be writable. If the destination already exists then it will be replaced with the source file otherwise a new file will be created.\n\nIf source and destination represent the same file then SameFileError exception will be raised.\n\nshutil.copytree() method recursively copies an entire directory tree rooted at source (src) to the destination directory. The destination directory, named by (dst) must not already exist. It will be created during copying.\n\nParameters:\n\nsrc: A string representing the path of the source directory.\n\ndest: A string representing the path of the destination.\n\nsymlinks (optional) : This parameter accepts True or False, depending on which the metadata of the original links or linked links will be copied to the new tree.\n\nignore (optional) : If ignore is given, it must be a callable that will receive as its arguments the directory being visited by copytree(), and a list of its contents, as returned by os.listdir().\n\ncopy_function (optional): The default value of this parameter is copy2. We can use other copy function like copy() for this parameter.\n\nignore_dangling_symlinks (optional) : This parameter value when set to True is used to put a silence on the exception raised if the file pointed by the symlink doesn’t exist. Return Value: This method returns a string which represents the path of newly created directory.\n\nshutil.rmtree() is used to delete an entire directory tree, the path must point to a directory (but not a symbolic link to a directory).\n\nshutil.which() method tells the path to an executable application that would be run if the given cmd was called. This method can be used to find a file on a computer which is present on the PATH.\n\nSyntax: shutil.which(cmd, mode = os.F_OK | os.X_OK, path = None)\n\nParameters:\n\ncmd: A string representing the file.\n\nmode: This parameter specifies mode by which method should execute. os.F_OK tests existence of the path and os.X_OK Checks if path can be executed or we can say mode determines if the file exists and executable.\n\npath: This parameter specifies the path to be used, if no path is specified then the results of os.environ() are used\n\nReturn Value: This method returns the path to an executable application"
    },
    {
        "link": "https://note.nkmk.me/en/python-shutil-move",
        "document": "In Python, allows you to move a file or a directory (folder).\n\nIf you want to delete or copy files and directories, refer to the following articles.\n\nThe sample code in this article imports the module as shown below. It is part of the standard library, so no additional installation is necessary.\n\nThe following initial state of files and directories will be used as examples for the various move operations in this article.\n\nThe first argument should be the path of the source file or directory, and the second should be the path of the destination directory. The function returns the path of the moved file or directory.\n\nPaths can be represented as either strings or path-like objects like . When specifying a directory as a string, the trailing delimiter ( ) is optional.\n\nIf you specify a non-existent path as the destination, the object will be moved and renamed. More on this later.\n\nBe aware that an error is thrown if a file with the same name already exists in the destination.\n\nIf an existing file is specified as the destination, it will be overwritten. More on this later.\n\nMove a directory to another directory; all files and directories within it will also be moved recursively.\n\nAn error occurs if a directory with the same name exists at the destination or an existing file is specified as the destination.\n\nRemove as it is no longer needed for the explanation.\n\nBy specifying a new (non-existent) path as the file's destination, you can move and rename the file.\n\nIf the destination includes a non-existent intermediate directory, an error will occur. In such cases, create the parent directories in advance using .\n\nNote that if you attempt to specify a new directory as the second argument (for example, ), it will be interpreted as a new filename and the file will be renamed to . Trying to specify will cause an error. You must first create a directory.\n\nBy specifying a new (non-existent) path as the directory's destination, you can move and rename the directory.\n\nIn the case of directories, any non-existent intermediate directories in the destination are created automatically.\n\nOverwrite an existing file at the destination\n\nIf the path of an existing file is specified as the destination for a file, the existing file will be overwritten with the content of the source file. The filename stays the same, but the original content is replaced, so exercise caution.\n\nNote that if the destination is an existing directory, the file will be moved into that directory, as in the previous examples.\n\nMove all files and directories from one directory to another\n\nAs mentioned above, when you move a directory with , all files and directories within it are moved. If you want to move the contained files and directories without moving the parent directory itself, you can generate a list and move each item.\n\nFor example, consider a directory with files and subdirectories, and an empty directory .\n\nYou can use to get a list of the file and directory names in the specified directory, and then move them individually with .\n• Get a list of file and directory names in Python\n\nSince returns only the names of files and directories, you must concatenate them with the original directory path using .\n• Get the filename, directory, extension from a path string in Python\n\nMove multiple files based on certain conditions with wildcards and regex\n\nAs a practical use case for , let's see how to move multiple files based on certain conditions.\n\nPlease note that using in can be time-consuming with a large number of files and directories. For improved efficiency, consider specifying conditions with other special characters when feasible.\n\nUse wildcards to specify conditions\n\nThe module allows you to use wildcard characters like to generate a list of file and directory names. For detailed usage, refer to the following article.\n• How to use glob() in Python\n\nConsider the following files and directories:\n\nFor example, you can move all files including those in subdirectories. You need to create the destination directory in advance.\n\nIf you want to maintain the structure of the source directory, you could do it as follows.\n\nConsider the following files and directories:\n\nSpecify the argument in , use to extract the directory name, and use to concatenate paths. You don't need to create the destination directory in advance because it's generated with .\n• Get the filename, directory, extension from a path string in Python\n\nUse regex to specify conditions\n\nFor complex conditions that can't be handled by glob alone, use the module to specify conditions with regular expressions.\n• Regular expressions with the re module in Python\n\nThe basic approach remains the same as when using alone.\n\nConsider the following files and directories:\n\nUse with and to recursively list all files and directories, and then filter them by regex with .\n\nFor example, to move files with names consisting only of digits and either a or extension, including files in subdirectories, use to match digits, to match one or more repetitions, and to match either or .\n\nIf you want to maintain the source directory's structure, you could do it as follows:\n\nConsider the following files and directories:\n\nThe operation is similar to using alone."
    },
    {
        "link": "https://docs.python.org/3/library/os.html",
        "document": "This module provides a portable way of using operating system dependent functionality. If you just want to read or write a file see , if you want to manipulate paths, see the module, and if you want to read all the lines in all the files on the command line see the module. For creating temporary files and directories see the module, and for high-level file and directory handling see the module.\n\nNotes on the availability of these functions:\n• None The design of all built-in operating system dependent modules of Python is such that as long as the same functionality is available, it uses the same interface; for example, the function returns stat information about path in the same format (which happens to have originated with the POSIX interface).\n• None Extensions peculiar to a particular operating system are also available through the module, but using them is of course a threat to portability.\n• None All functions accepting path or file names accept both bytes and string objects, and result in an object of the same type, if a path or file name is returned.\n• None On VxWorks, os.popen, os.fork, os.execv and os.spawn*p* are not supported.\n• None On WebAssembly platforms, Android and iOS, large parts of the module are not available or behave differently. APIs related to processes (e.g. , ) and resources (e.g. ) are not available. Others like and are emulated or stubs. WebAssembly platforms also lack support for signals (e.g. , )."
    },
    {
        "link": "https://docs.python.org/3/library/shutil.html",
        "document": "The module offers a number of high-level operations on files and collections of files. In particular, functions are provided which support file copying and removal. For operations on individual files, see also the module.\n\nChanged in version 3.5: Added support for the xztar format. High-level utilities to create and read compressed and archived files are also provided. They rely on the and modules. Create an archive file (such as zip or tar) and return its name. base_name is the name of the file to create, including the path, minus any format-specific extension. format is the archive format: one of “zip” (if the module is available), “tar”, “gztar” (if the module is available), “bztar” (if the module is available), or “xztar” (if the module is available). root_dir is a directory that will be the root directory of the archive, all paths in the archive will be relative to it; for example, we typically chdir into root_dir before creating the archive. base_dir is the directory where we start archiving from; i.e. base_dir will be the common prefix of all files and directories in the archive. base_dir must be given relative to root_dir. See Archiving example with base_dir for how to use base_dir and root_dir together. root_dir and base_dir both default to the current directory. If dry_run is true, no archive is created, but the operations that would be executed are logged to logger. owner and group are used when creating a tar archive. By default, uses the current owner and group. logger must be an object compatible with PEP 282, usually an instance of . The verbose argument is unused and deprecated. This function is not thread-safe when custom archivers registered with do not support the root_dir argument. In this case it temporarily changes the current working directory of the process to root_dir to perform archiving. Changed in version 3.8: The modern pax (POSIX.1-2001) format is now used instead of the legacy GNU format for archives created with . Changed in version 3.10.6: This function is now made thread-safe during creation of standard and tar archives. Return a list of supported formats for archiving. Each element of the returned sequence is a tuple . By default provides these formats:\n• None zip: ZIP file (if the module is available).\n• None tar: Uncompressed tar file. Uses POSIX.1-2001 pax format for new archives.\n• None gztar: gzip’ed tar-file (if the module is available).\n• None bztar: bzip2’ed tar-file (if the module is available).\n• None xztar: xz’ed tar-file (if the module is available). You can register new formats or provide your own archiver for any existing formats, by using . Register an archiver for the format name. function is the callable that will be used to unpack archives. The callable will receive the base_name of the file to create, followed by the base_dir (which defaults to ) to start archiving from. Further arguments are passed as keyword arguments: owner, group, dry_run and logger (as passed in ). If function has the custom attribute set to , the root_dir argument is passed as a keyword argument. Otherwise the current working directory of the process is temporarily changed to root_dir before calling function. In this case is not thread-safe. If given, extra_args is a sequence of pairs that will be used as extra keywords arguments when the archiver callable is used. description is used by which returns the list of archivers. Defaults to an empty string. Changed in version 3.12: Added support for functions supporting the root_dir argument. Remove the archive format name from the list of supported formats. Unpack an archive. filename is the full path of the archive. extract_dir is the name of the target directory where the archive is unpacked. If not provided, the current working directory is used. format is the archive format: one of “zip”, “tar”, “gztar”, “bztar”, or “xztar”. Or any other format registered with . If not provided, will use the archive file name extension and see if an unpacker was registered for that extension. In case none is found, a is raised. The keyword-only filter argument is passed to the underlying unpacking function. For zip files, filter is not accepted. For tar files, it is recommended to set it to , unless using features specific to tar and UNIX-like filesystems. (See Extraction filters for details.) The filter will become the default for tar files in Python 3.14. Never extract archives from untrusted sources without prior inspection. It is possible that files are created outside of the path specified in the extract_dir argument, e.g. members that have absolute filenames starting with “/” or filenames with two dots “..”. Changed in version 3.7: Accepts a path-like object for filename and extract_dir. Registers an unpack format. name is the name of the format and extensions is a list of extensions corresponding to the format, like for Zip files. function is the callable that will be used to unpack archives. The callable will receive:\n• None the path of the archive, as a positional argument;\n• None the directory the archive must be extracted to, as a positional argument;\n• None possibly a filter keyword argument, if it was given to ;\n• None additional keyword arguments, specified by extra_args as a sequence of tuples. description can be provided to describe the format, and will be returned by the function. Unregister an unpack format. name is the name of the format. Return a list of all registered formats for unpacking. Each element of the returned sequence is a tuple . By default provides these formats:\n• None zip: ZIP file (unpacking compressed files works only if the corresponding module is available).\n• None gztar: gzip’ed tar-file (if the module is available).\n• None bztar: bzip2’ed tar-file (if the module is available).\n• None xztar: xz’ed tar-file (if the module is available). You can register new formats or provide your own unpacker for any existing formats, by using . In this example, we create a gzip’ed tar-file archive containing all files found in the directory of the user: In this example, similar to the one above, we show how to use , but this time with the usage of base_dir. We now have the following directory structure: In the final archive, should be included, but should not. Therefore we use the following: Listing the files in the resulting archive gives us:"
    },
    {
        "link": "https://geeksforgeeks.org/python-shutil-copytree-method",
        "document": "Shutil module in Python provides many functions of high-level operations on files and collections of files. It comes under Python’s standard utility modules. This module helps in automating process of copying and removal of files and directories.\n\n method recursively copies an entire directory tree rooted at source (src) to the destination directory. The destination directory, named by (dst) must not already exist. It will be created during copying. Permissions and times of directories are copied with copystat() and individual files are copied using shutil.copy2().\n\nSyntax: shutil.copytree(src, dst, symlinks = False, ignore = None, copy_function = copy2, igonre_dangling_symlinks = False)\n\n Parameters: \n\n src: A string representing the path of the source directory.\n\n dest: A string representing the path of the destination.\n\n symlinks (optional) : This parameter accepts True or False, depending on which the metadata of the original links or linked links will be copied to the new tree.\n\n ignore (optional) : If ignore is given, it must be a callable that will receive as its arguments the directory being visited by , and a list of its contents, as returned by .\n\n copy_function (optional): The default value of this parameter is copy2. We can use other copy function like for this parameter.\n\n igonre_dangling_symlinks (optional) : This parameter value when set to True is used to put a silence on the exception raised if the file pointed by the symlink doesn’t exist.\n\n Return Value: This method returns a string which represents the path of newly created directory.\n\nExample #1 :\n\n Using method to copy file from source to destination"
    },
    {
        "link": "https://stackoverflow.com/questions/1868714/how-do-i-copy-an-entire-directory-of-files-into-an-existing-directory-using-pyth",
        "document": "Run the following code from a directory that contains a directory named (containing one or more files) and a directory named (also containing one or more files). Make sure there is not a directory named . $ python copytree_test.py Traceback (most recent call last): File \"copytree_test.py\", line 5, in <module> shutil.copytree('baz', 'foo') File \"/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/shutil.py\", line 110, in copytree File \"/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/os.py\", line 172, in makedirs OSError: [Errno 17] File exists: 'foo' I want this to work the same way as if I had typed: Do I need to use to copy each file in into ? (After I've already copied the contents of 'bar' into 'foo' with ?) Or is there an easier/better way?"
    },
    {
        "link": "https://stackoverflow.com/questions/1994488/copy-file-or-directories-recursively-in-python",
        "document": "Python seems to have functions for copying files (e.g. ) and functions for copying directories (e.g. ) but I haven't found any function that handles both. Sure, it's trivial to check whether you want to copy a file or a directory, but it seems like a strange omission.\n\nIs there really no standard function that works like the unix command, i.e. supports both directories and files and copies recursively? What would be the most elegant way to work around this problem in Python?"
    },
    {
        "link": "https://geekpython.in/shutil-module-in-python",
        "document": "Copying or moving files or folders manually from one directory to another directory could be a real pain. This can be automated using a Python module called .\n\nShutil module provides some high-level operations on files and collection of files like copying, moving, or removing the files.\n\nIn other words, the module helps in automating the task of file copying or moving from one directory to another directory. It comes under the Python standard library so it doesn’t need to be installed externally.\n\nIn this article, we’ll learn this module.\n\nmethod is used to copy the content of the source file to the destination file or directory. While the process of copying also copies the file’s permission mode but other metadata like the file’s creation and modification times, is not preserved.\n\nThe source must represent a file but the destination can be a file or a directory. If the destination is a directory then the file will be copied to the destination directory with a base filename from the source. The destination must be writable.\n\nIf the destination is a file and already exists then it will be replaced by the source file otherwise the new file will be created.\n• : A string that shows the path of the source file.\n• : A string that shows the path of the destination file or directory.\n• (optional): The default value of this parameter is . If it is and the source represents a symbolic link then the destination will be created as a symbolic link.\n\nIf the destination is the directory\n\nCopy metadata along with the file\n\nmethod is used to copy the contents of the source file to the destination file or directory. It is the same as the method but the only difference is that this method tries to preserve the metadata of the file.\n• : A string that shows the path of the source file.\n• : A string that shows the path of the destination file or directory.\n• (optional): The default value of this parameter is . If it is and the source represents a symbolic link then it attempts to copy all metadata from the source symbolic link to the newly-created destination symbolic link. This functionality is platform dependent.\n\nIf the destination is a directory\n\nCopy content from one file to another file\n\nmethod is used to copy the content of the source file to the destination file without the metadata. The source and destination must represent a file and the destination file must be writable. If the destination already exists then it’ll be replaced or a new file will be created.\n• : A string that shows the path of the source file.\n• : A string that shows the path of the destination file or directory.\n• (optional): The default value of this parameter is . If and source represent a symbolic link then a new symbolic link will be created instead of copying the file.\n\nIf the source and destination file path is the same\n\nIf it happens then a will be raised and we can handle the error by using .\n\nmethod is used to replicate the complete directory tree. It recursively copies the entire directory tree rooted at the source directory to the destination directory. The destination directory must not already exist. The new directory will be created during the process.\n• : A string that shows the path of the source directory.\n• : A string that shows the path of the destination.\n• (optional): This parameter accepts or , depending on which the metadata of the original links or linked links will be copied to the new tree.\n• (optional): If ignore is given, it must be a callable that will receive as its arguments the directory being visited by , and a list of its contents, as returned by .\n• (optional): The default value of this parameter is , other copy function like can be used for this parameter.\n• (optional): This parameter value when set to is used to put a silence on the exception raised if the file pointed by the symlink doesn’t exist.\n\nmethod is used to delete the entire directory tree, the specified path must point to a directory (but not to a symbolic link to a directory).\n• : A path-like object representing a file path. A path-like object is either a string or bytes object representing a path.\n• : If is true, errors resulting from failed removals will be ignored.\n• : If is false or omitted, such errors are handled by calling a handler specified by .\n\nmethod is used to move the source file or a directory to the destination location. If the destination directory already exists then the source directory will move inside that directory.\n\n: A string that shows the path of the source file.\n\n: A string that shows the path of the destination file or directory.\n\n(optional): The default value of this parameter is . We can use other copy functions also.\n\nmethod is used to find the path to an executable file specified to the argument. If no is specified then it will return .\n• : This parameter specifies the mode by which the method should execute.\n• tests the existence of the path\n• checks if the path can be executed\n• : This parameter specifies the path to be used, if no path is specified then the results of are used.\n\nThere are some other cool methods that the module provides other than the above-mentioned methods.\n\nCopy the stats of a file or a directory using shutil\n\nmethod is used to copy the stats of a file or a directory like permission bits, last access time, last modification time, and flags from the source to the destination.\n\nmethod is used to get the statistics of disk usage of the specified path. The return value has attributes total, used, and free which are the amount(in bytes) of the total, used, and free space. A path may be a file or a directory.\n\nis used to create an archive file in a or format.\n\nis used to unpack the archive file. The method takes two arguments, the first is the which is the full path of the archive file and the second is the in which the files are extracted.\n\nWe sure learned to handle high-level file operations using the module. We’ve learned how to\n• Copy the file or a directory to another directory\n• Copy the metadata of the file\n• Permanently move the file or a directory to another location\n\nAlong with these operations, we’ve seen some of the cool methods which are provided by the module.\n\nThat’s all for now"
    }
]