[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function",
        "document": "An declaration creates an object. Each time when an async function is called, it returns a new which will be resolved with the value returned by the async function, or rejected with an exception uncaught within the async function.\n\nAsync functions can contain zero or more expressions. Await expressions make promise-returning functions behave as though they're synchronous by suspending execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression. Use of and enables the use of ordinary / blocks around asynchronous code.\n\nNote: The keyword is only valid inside async functions within regular JavaScript code. If you use it outside of an async function's body, you will get a . can be used on its own with JavaScript modules.\n\nAsync functions always return a promise. If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise.\n\nFor example, consider the following code:\n\nIt is similar to:\n\nNote that even though the return value of an async function behaves as if it's wrapped in a , they are not equivalent. An async function will return a different reference, whereas returns the same reference if the given value is a promise. It can be a problem when you want to check the equality of a promise and a return value of an async function.\n\nThe body of an async function can be thought of as being split by zero or more await expressions. Top-level code, up to and including the first await expression (if there is one), is run synchronously. In this way, an async function without an await expression will run synchronously. If there is an await expression inside the function body, however, the async function will always complete asynchronously.\n\nIt is also equivalent to:\n\nCode after each await expression can be thought of as existing in a callback. In this way a promise chain is progressively constructed with each reentrant step through the function. The return value forms the final link in the chain.\n\nIn the following example, we successively await two promises. Progress moves through function in three stages.\n• The first line of the body of function is executed synchronously, with the await expression configured with the pending promise. Progress through is then suspended and control is yielded back to the function that called .\n• Some time later, when the first promise has either been fulfilled or rejected, control moves back into . The result of the first promise fulfillment (if it was not rejected) is returned from the await expression. Here is assigned to . Progress continues, and the second await expression is evaluated. Again, progress through is suspended and control is yielded.\n• Some time later, when the second promise has either been fulfilled or rejected, control re-enters . The result of the second promise resolution is returned from the second await expression. Here is assigned to . Control moves to the return expression (if any). The default return value of is returned as the resolution value of the current promise.\n\nNote how the promise chain is not built-up in one go. Instead, the promise chain is constructed in stages as control is successively yielded from and returned to the async function. As a result, we must be mindful of error handling behavior when dealing with concurrent asynchronous operations.\n\nFor example, in the following code an unhandled promise rejection error will be thrown, even if a handler has been configured further along the promise chain. This is because will not be \"wired into\" the promise chain until control returns from .\n\ndeclarations behave similar to declarations — they are hoisted to the top of their scope and can be called anywhere in their scope, and they can be redeclared only in certain contexts."
    },
    {
        "link": "https://w3schools.com/js/js_async.asp",
        "document": "The keyword before a function makes the function return a promise:\n\nHere is how to use the Promise:\n\nOr simpler, since you expect a normal value (a normal response, not an error):\n\nThe keyword can only be used inside an function.\n\nThe keyword makes the function pause the execution and wait for a resolved promise before it continues:\n\nLet's go slowly and learn how to use it.\n\nasync function getFile() {\n\n let myPromise = new Promise(function(resolve) {\n\n let req = new XMLHttpRequest();\n\n req.open('GET', \"mycar.html\");\n\n req.onload = function() {\n\n if (req.status == 200) {\n\n resolve(req.response);\n\n } else {\n\n resolve(\"File not Found\");\n\n }\n\n };\n\n req.send();\n\n });\n\n document.getElementById(\"demo\").innerHTML = await myPromise;\n\n }\n\n \n\n getFile();\n\nThe following table defines the first browser version with full support for both:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function*",
        "document": "An declaration creates an object. Each time when an async generator function is called, it returns a new object, which conforms to the async iterator protocol. Every call to returns a that resolves to the iterator result object.\n\nAn async generator function combines the features of async functions and generator functions. You can use both the and keywords within the function body. This empowers you to handle asynchronous tasks ergonomically with , while leveraging the lazy nature of generator functions.\n\nWhen a promise is yielded from an async generator, the iterator result promise's eventual state will match that of the yielded promise. For example:\n\nwill be logged, because if the yielded promise rejects, the iterator result will reject as well. The property of an async generator's resolved result will not be another promise.\n\ndeclarations behave similar to declarations — they are hoisted to the top of their scope and can be called anywhere in their scope, and they can be redeclared only in certain contexts."
    },
    {
        "link": "https://javascript.info/async-await",
        "document": "There’s a special syntax to work with promises in a more comfortable fashion, called “async/await”. It’s surprisingly easy to understand and use.\n\nLet’s start with the keyword. It can be placed before a function, like this:\n\nThe word “async” before a function means one simple thing: a function always returns a promise. Other values are wrapped in a resolved promise automatically.\n\nFor instance, this function returns a resolved promise with the result of ; let’s test it:\n\n…We could explicitly return a promise, which would be the same:\n\nSo, ensures that the function returns a promise, and wraps non-promises in it. Simple enough, right? But not only that. There’s another keyword, , that works only inside functions, and it’s pretty cool.\n\nThe keyword makes JavaScript wait until that promise settles and returns its result.\n\nHere’s an example with a promise that resolves in 1 second:\n\nThe function execution “pauses” at the line and resumes when the promise settles, with becoming its result. So the code above shows “done!” in one second.\n\nLet’s emphasize: literally suspends the function execution until the promise settles, and then resumes it with the promise result. That doesn’t cost any CPU resources, because the JavaScript engine can do other jobs in the meantime: execute other scripts, handle events, etc.\n\nIt’s just a more elegant syntax of getting the promise result than . And, it’s easier to read and write.\n\nLet’s take the example from the chapter Promises chaining and rewrite it using :\n• We’ll need to replace calls with .\n• Also we should make the function for them to work.\n\nPretty clean and easy to read, right? Much better than before.\n\nIf a promise resolves normally, then returns the result. But in the case of a rejection, it throws the error, just as if there were a statement at that line.\n\n…is the same as this:\n\nIn real situations, the promise may take some time before it rejects. In that case there will be a delay before throws an error.\n\nWe can catch that error using , the same way as a regular :\n\nIn the case of an error, the control jumps to the block. We can also wrap multiple lines:\n\nIf we don’t have , then the promise generated by the call of the async function becomes rejected. We can append to handle it:\n\nIf we forget to add there, then we get an unhandled promise error (viewable in the console). We can catch such errors using a global event handler as described in the chapter Error handling with promises.\n\nThe keyword before a function has two effects:\n• Allows to be used in it.\n\nThe keyword before a promise makes JavaScript wait until that promise settles, and then:\n• If it’s an error, an exception is generated — same as if were called at that very place.\n• Otherwise, it returns the result.\n\nTogether they provide a great framework to write asynchronous code that is easy to both read and write.\n\nWith we rarely need to write , but we still shouldn’t forget that they are based on promises, because sometimes (e.g. in the outermost scope) we have to use these methods. Also is nice when we are waiting for many tasks simultaneously."
    },
    {
        "link": "https://geeksforgeeks.org/async-await-function-in-javascript",
        "document": "Async and Await in JavaScript is used to simplify handling asynchronous operations using promises. By enabling asynchronous code to appear synchronous, they enhance code readability and make it easier to manage complex asynchronous flows.\n\nThe function allows us to write promise-based code as if it were synchronous. This ensures that the execution thread is not blocked. Async functions always return a promise. If a value is returned that is not a promise, JavaScript automatically wraps it in a resolved promise.\n\nThe keyword is used to wait for a promise to resolve. It can only be used within an async block. Await makes the code wait until the promise returns a result, allowing for cleaner and more manageable asynchronous code.\n• async keyword transforms a regular JavaScript function into an asynchronous function, causing it to return a Promise.\n• await keyword is used inside an async function to pause its execution and wait for a Promise to resolve before continuing.\n\nJavaScript provides predefined arguments for handling promises: resolve and reject.\n• resolve: Used when an asynchronous task is completed successfully.\n• reject: Used when an asynchronous task fails, providing the reason for failure.\n• Improved Readability: Async and Await allow asynchronous code to be written in a synchronous style, making it easier to read and understand.\n• Avoids Callback Hell: Async and Await prevent nested callbacks and complex promise chains, making the code more linear and readable.\n• Better Debugging: Debugging async/await code is more intuitive since it behaves similarly to synchronous code.\n\nWhat does async do?\n\nWhat does await do?\n\nCan you use await outside async functions?\n\nWhat happens if an async function throws an error?\n\nHow is Async/Await different from Promises?"
    },
    {
        "link": "https://stackoverflow.com/questions/50046841/proper-way-to-make-api-fetch-post-with-async-await",
        "document": "I'm working on a project that requires me to make requests to an API. What is the proper form for making a request with Async/Await?\n\nAs an example, here is my fetch to get a list of all devices. How would I go about changing this request to to create a new device? I understand I would have to add a header with a data body."
    },
    {
        "link": "https://codecademy.com/learn/fscp-async-javascript-and-http-requests/modules/fecp-learn-javascript-requests/cheatsheet",
        "document": "HTTP requests are made with the intention of retrieving information or data from a source (server) over the web. requests have no body, so the information that the source requires, in order to return the proper response, must be included in the request URL path or query string.\n\nThe JavaScript Fetch API is used to write HTTP requests using Promises. The main function accepts a URL parameter and returns a promise that resolves to a response object or rejects with an error message if a network error occurs. The example code begins by calling the function. Then a method is chained to the end of the . It ends with the response callback to handle success and the rejection callback to handle failure.\n\nThe function accepts an optional second argument, an options object, used to customize the request. This can be used to change the request type, headers, specify a request body, and much more. In the example code below, the function as a second argument—an object containing options for the fetch request specifying the and the .\n\nHTTP requests are made with the intention of sending new information to the source (server) that will receive it. For a request, the new information is stored in the body of the request.\n\nThe … syntax is used with the Fetch API to handle promises. In the example code, the keyword is used to make the function an async function. This means that the function will return a promise. The keyword used before the call makes the code wait until the promise is resolved."
    },
    {
        "link": "https://stackoverflow.com/questions/63686037/how-to-use-a-post-request-in-a-loop-using-async",
        "document": "First of all, you can either use or methodology. is introduced to overcome the chaining issue (which is called snake code). So when your project gets larger, you hit with this chaining issue. So with you do not need to use . You need to use with .\n\nI have created a sample code and repo exclusively for your requirement where I simulated your problem with `async/await. I have tested as well and attach screenshots as well in the readme. Please have a look.\n\nThis is how it looks. You get all the results then the only res.send will process. get executed once you get all the results."
    },
    {
        "link": "https://twilio.com/en-us/blog/5-ways-to-make-http-requests-in-node-js-using-async-await",
        "document": "Making HTTP requests is core functionality for modern languages and one of the first things many developers learn when acclimating to new environments. When it comes to Node.js there are a fair amount of solutions to this problem both built into the language and by the community. Let’s take a look at some of the most popular ones. A few years ago, I wrote a similar post on this topic. But now that async/await functionality is more pervasive and mainstream in JavaScript code, making network requests is more straightforward than ever. On top of that, Request, the previously most popular HTTP library for Node has been deprecated. So it's time for an updated guide! As in the other post, we’ll be using NASA’s Astronomy Picture of the Day API as the JSON API that we are interacting with in all of these examples because space is the coolest thing ever.\n\nBefore moving on, make sure you have up to date versions of Node.js and npm installed on your machine. For the purpose of making comparisons, let's start by taking a look at the default HTTP module without Promises and async/await. With this module, you have the advantage of not relying on any dependencies, but it isn't very developer-friendly compared to other solutions. The following code will send a request to NASA’s API and print out the URL for the astronomy picture of the day as well as an explanation:\n\nMuch of the and the module’s functionality is fairly low-level. You’re required to receive response data in chunks and need to explicitly listen for when all of the data is received. You also need to parse the response data manually. This module also does not support HTTPS by default, so we need to require the module instead if the API we are using communicates over HTTPS. Although you can't use the async/await feature for the HTTP requests made with this library, you could potentially use asynchronous streams for chunking the data. It may take a bit more effort to get the data you want, but is a great utility if you don’t want to add dependencies to your codebase or want access to its low level functionality. Got is a great choice if you want a more lightweight library. It is designed to be human-friendly and is also available to use by default in Twilio Functions.\n\nThis library does not parse JSON by default, so we needed to add as an argument when making the request. Got is a fantastic option if you just want an easy to use library that deals with HTTP requests in a sane way. Axios is another Promise based HTTP client that works for the browser as well as node.js. To install Axios from npm, enter the following command in your terminal:\n\nThis library does have a built in function for converting the response to JSON, but it does not do it automatically in the same way that Axios and SuperAgent do. This is a great library for people who are used to using the Fetch API in the browser. This doesn’t cover all of the solutions, but now you see how the basic functionality works in a few of the most popular HTTP libraries in Node. Other languages have a similar variety of libraries to tackle this problem. Check out these other tutorials in Swift, Python and Ruby. Also, check out our Node.js Quickstarts for a place to apply your new skills. What are your favorite ways to send HTTP requests? Feel free to reach out and let me know or ask any questions:"
    },
    {
        "link": "https://dev.to/losnikitos/three-ways-to-make-an-async-request-in-javascript-xhr-promise-asyncawait-1bff",
        "document": "Asynchronous programming is a crucial part of modern-day JavaScript development. It allows you to make requests to servers, access databases, and manipulate the DOM without blocking the main thread of execution.\n\nThe way we develop code in 2023 is very different from how it was done in the 2000s. We now have access to promises, async/await, and the fetch API, whereas back then we were using XHR and callbacks. If you were handed a legacy frontend project, this article can help you understand how it was done in the past so that you can rewrite it into a modern codebase if necessary.\n\nIn this article, we will build a simple program that fetches JSON from a URL and prints the result to the console. We will use code patterns from different eras of JavaScript.\n\nXMLHttpRequest (XHR) is an API in the form of an object that is used to transfer data between the web browser and a server. It is the oldest way to make an asynchronous request in JavaScript. XHR provides a way to make HTTP requests to the server and get responses without having to reload the entire page.\n\nHere is an example of how to make an XHR request:\n\n\n\nOr maybe you were using jQuery? It was a popular JavaScript library that simplified HTML document traversing, event handling, animating, and Ajax interactions. This is what the same request will look like in jQuery:\n\n\n\nThe 2015 way: Fetch and promises\n\nFetch is a newer and more modern technology that replaces XHR, or XMLHttpRequest. It is built directly into modern web browsers, which means that it is easier to use and requires less overhead than XHR. It uses Promises instead of callbacks, which makes it easier to manage asynchronous calls without getting bogged down in complex code.\n\nPromise is an object in JavaScript that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. It allows you to write asynchronous code that is more readable and maintainable by chaining together methods like and to handle the result of a Promise.\n\nHere is an example of how to make an async request using Fetch and Promises:\n\n\n\nAsync/await is a modern way of writing asynchronous code that is built on top of Promises. It allows you to write asynchronous code that looks like synchronous code. Here is an example of how to make an async request using Async/await:\n\n\n\nNote that we have to wrap the code in a function as statement cannot be called in top level code.\n\nWe explored three different ways to make asynchronous requests in JavaScript. When possible, avoid using legacy code and instead utilize new language features. However, make sure that the target browsers support these features. You can check caniuse.com if you're unsure.\n\nThank you for reading! I hope this article has been helpful to you. Happy coding!"
    }
]