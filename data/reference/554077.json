[
    {
        "link": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html",
        "document": "\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. All elements in the array must implement the interface. Furthermore, all elements in the array must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - if the array contains elements that are not mutually comparable (for example, strings and integers) - (optional) if the natural ordering of the array elements is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in this range must implement the mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified range of the specified array of objects into ascending order, according to the natural ordering of its elements. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in this range must implement the interface. Furthermore, all elements in this range must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable by the specified comparator (that is, must not throw a for any elements and in the array). Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must beby the specified comparator (that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator - (optional) if the comparator is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, must not throw a for any elements and in the range). Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in the range must beby the specified comparator (that is,must not throw afor any elementsandin the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. All elements in the array must implement the interface. Furthermore, all elements in the array must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the array to be sorted - if the array contains elements that are not mutually comparable (for example, strings and integers) - (optional) if the natural ordering of the array elements is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in this range must implement the mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified range of the specified array of objects into ascending order, according to the natural ordering of its elements. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in this range must implement the interface. Furthermore, all elements in this range must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable by the specified comparator (that is, must not throw a for any elements and in the array). Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must beby the specified comparator (that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the class of the objects to be sorted - the array to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator - (optional) if the comparator is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, must not throw a for any elements and in the range). Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in the range must beby the specified comparator (that is,must not throw afor any elementsandin the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator. - if or (optional) if the comparator is found to violate the contract\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the class of the objects in the array - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the class of the objects in the array - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holdsand the operation performs addition, then upon return the array holds. Parallel prefix computation is usually more efficient than sequential loops for large arrays. Because floating-point operations may not be strictly associative, the returned result may not be identical to the value that would be obtained if the operation was performed sequentially. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of longs for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of ints for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of shorts for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of chars for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of bytes for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of doubles for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of floats for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the natural ordering of its elements (as by the method) prior to making this call. If it is not sorted, the results are undefined. (If the array contains elements that are not mutually comparable (for example, strings and integers), itbe sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the search key is not comparable to the elements of the array.\n• cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the natural ordering of its elements (as by the method) prior to making this call. If it is not sorted, the results are undefined. (If the range contains elements that are not mutually comparable (for example, strings and integers), itbe sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the search key is not comparable to the elements of the array within the specified range.\n• Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the specified comparator (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the class of the objects in the array - the array to be searched - the value to be searched for - the comparator by which the array is ordered. A value indicates that the elements' natural ordering should be used. index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the array contains elements that are not mutually comparable using the specified comparator, or the search key is not comparable to the elements of the array using this comparator.\n• Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the specified comparator (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the class of the objects in the array - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for - the comparator by which the array is ordered. A value indicates that the elements' natural ordering should be used. index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the range contains elements that are not mutually comparable using the specified comparator, or the search key is not comparable to the elements in the range using this comparator.\n• Returns if the two specified arrays of longs are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• equal to one another. Returns true if the two specified arrays of longs, over the specified ranges, areto one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. - the first array to be tested for equality - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested fro equality - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested if the two arrays, over the specified ranges, are equal - if or if - if or if - if either array is\n• Returns if the two specified arrays of ints are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• equal to one another. Returns true if the two specified arrays of ints, over the specified ranges, areto one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. - the first array to be tested for equality - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested fro equality - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested if the two arrays, over the specified ranges, are equal - if or if - if or if - if either array is\n• Returns if the two specified arrays of shorts are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• equal to one another. Returns true if the two specified arrays of shorts, over the specified ranges, areto one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. - the first array to be tested for equality - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested fro equality - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested if the two arrays, over the specified ranges, are equal - if or if - if or if - if either array is\n• Returns if the two specified arrays of chars are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• equal to one another. Returns true if the two specified arrays of chars, over the specified ranges, areto one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. - the first array to be tested for equality - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested fro equality - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested if the two arrays, over the specified ranges, are equal - if or if - if or if - if either array is\n• Returns if the two specified arrays of bytes are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• equal to one another. Returns true if the two specified arrays of bytes, over the specified ranges, areto one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. - the first array to be tested for equality - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested fro equality - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested if the two arrays, over the specified ranges, are equal - if or if - if or if - if either array is\n• Returns if the two specified arrays of booleans are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• equal to one another. Returns true if the two specified arrays of booleans, over the specified ranges, areto one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. - the first array to be tested for equality - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested fro equality - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested if the two arrays, over the specified ranges, are equal - if or if - if or if - if either array is\n• if the two specified arrays of doubles are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Two doubles and are considered equal if: (Unlike the operator, this method considers equals to itself, and 0.0d unequal to -0.0d.) Returnsif the two specified arrays of doubles areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are. Two doublesandare considered equal if:(Unlike theoperator, this method considersequals to itself, and 0.0d unequal to -0.0d.) - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• equal to one another. Returns true if the two specified arrays of doubles, over the specified ranges, areto one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. Two doubles and are considered equal if: (Unlike the operator, this method considers equals to itself, and 0.0d unequal to -0.0d.) - the first array to be tested for equality - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested fro equality - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested if the two arrays, over the specified ranges, are equal - if or if - if or if - if either array is\n• if the two specified arrays of floats are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Two floats and are considered equal if: (Unlike the operator, this method considers equals to itself, and 0.0f unequal to -0.0f.) Returnsif the two specified arrays of floats areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are. Two floatsandare considered equal if:(Unlike theoperator, this method considersequals to itself, and 0.0f unequal to -0.0f.) - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• equal to one another. Returns true if the two specified arrays of floats, over the specified ranges, areto one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. Two floats and are considered equal if: (Unlike the operator, this method considers equals to itself, and 0.0f unequal to -0.0f.) - the first array to be tested for equality - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested fro equality - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested if the two arrays, over the specified ranges, are equal - if or if - if or if - if either array is\n• Returns if the two specified arrays of Objects are equal to one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objects and are considered equal if . In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• equal to one another. Returns true if the two specified arrays of Objects, over the specified ranges, areto one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. Two objects and are considered equal if . - the first array to be tested for equality - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested fro equality - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested if the two arrays, over the specified ranges, are equal - if or if - if or if - if either array is\n• if the two specified arrays of Objects are equal to one another. Returnsif the two specified arrays of Objects areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Two objects and are considered equal if, given the specified comparator, . - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal - if the comparator is\n• equal to one another. Returns true if the two specified arrays of Objects, over the specified ranges, areto one another. Two arrays are considered equal if the number of elements covered by each range is the same, and all corresponding pairs of elements over the specified ranges in the two arrays are equal. In other words, two arrays are equal if they contain, over the specified ranges, the same elements in the same order. Two objects and are considered equal if, given the specified comparator, . - the first array to be tested for equality - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested fro equality - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested if the two arrays, over the specified ranges, are equal - if or if - if or if - if either array or the comparator is\n• Assigns the specified long value to each element of the specified array of longs. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified long value to each element of the specified range of the specified array of longs. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified int value to each element of the specified array of ints. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified int value to each element of the specified range of the specified array of ints. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified short value to each element of the specified array of shorts. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified short value to each element of the specified range of the specified array of shorts. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified char value to each element of the specified array of chars. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified char value to each element of the specified range of the specified array of chars. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified byte value to each element of the specified array of bytes. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified byte value to each element of the specified range of the specified array of bytes. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified boolean value to each element of the specified array of booleans. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified boolean value to each element of the specified range of the specified array of booleans. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified double value to each element of the specified array of doubles. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified double value to each element of the specified range of the specified array of doubles. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified float value to each element of the specified array of floats. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified float value to each element of the specified range of the specified array of floats. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified Object reference to each element of the specified array of Objects. - the array to be filled - the value to be stored in all elements of the array - if the specified value is not of a runtime type that can be stored in the specified array\n• Assigns the specified Object reference to each element of the specified range of the specified array of Objects. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array - if the specified value is not of a runtime type that can be stored in the specified array\n• Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of exactly the same class as the original array. - the class of the objects in the array - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with nulls to obtain the specified length\n• Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of the class . - the class of the objects in the original array - the class of the objects in the returned array - the array to be copied - the length of the copy to be returned - the class of the copy to be returned a copy of the original array, truncated or padded with nulls to obtain the specified length - if an element copied from is not of a runtime type that can be stored in an array of class\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with null characters (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with null characters to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with false elements to obtain the specified length\n• ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . Copies the specified range of the specified array into a new array. The initial index of the range () must lie between zero and, inclusive. The value atis placed into the initial element of the copy (unlessor). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (), which must be greater than or equal to, may be greater than, in which caseis placed in all elements of the copy whose index is greater than or equal to. The length of the returned array will be The resulting array is of exactly the same class as the original array. - the class of the objects in the array - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with nulls to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . The resulting array is of the class . - the class of the objects in the original array - the class of the objects in the returned array - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) - the class of the copy to be returned a new array containing the specified range from the original array, truncated or padded with nulls to obtain the required length - if an element copied from is not of a runtime type that can be stored in an array of class .\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with null characters to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with false elements to obtain the required length\n• Returns a fixed-size list backed by the specified array. (Changes to the returned list \"write through\" to the array.) This method acts as bridge between array-based and collection-based APIs, in combination with . The returned list is serializable and implements This method also provides a convenient way to create a fixed-size list initialized to contain several elements: - the class of the objects in the array - the array by which the list will be backed a list view of the specified array\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any two non-nullarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• Returns a hash code based on the contents of the specified array. If the array contains other arrays as elements, the hash code is based on their identities rather than their contents. It is therefore acceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. For any two arrays and such that , it is also the case that . The value returned by this method is equal to the value that would be returned by , unless is , in which case is returned. - the array whose content-based hash code to compute\n• Returns a hash code based on the \"deep contents\" of the specified array. If the array contains other arrays as elements, the hash code is based on their contents and so on, ad infinitum. It is therefore unacceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. The behavior of such an invocation is undefined. For any two arrays and such that , it is also the case that . The computation of the value returned by this method is similar to that of the value returned by on a list containing the same elements as in the same order, with one difference: If an element of is itself an array, its hash code is computed not by calling , but as by calling the appropriate overloading of if is an array of a primitive type, or as by calling recursively if is an array of a reference type. If is , this method returns 0. - the array whose deep-content-based hash code to compute\n• if the two specified arrays are deeply equal to one another. Unlike the Returnsif the two specified arrays areto one another. Unlike the method, this method is appropriate for use with nested arrays of arbitrary depth. Two array references are considered deeply equal if both are , or if they refer to arrays that contain the same number of elements and all corresponding pairs of elements in the two arrays are deeply equal. Two possibly elements and are deeply equal if any of the following conditions hold:\n• and are both arrays of object reference types, and\n• and are arrays of the same primitive type, and the appropriate overloading of would return true. Note that this definition permits elements at any depth. Note that this definition permitselements at any depth. If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined. - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• , which describes their identities rather than their contents. Returns a string representation of the contents of the specified array. If the array contains other arrays as elements, they are converted to strings by the method inherited from, which describes theirrather than their contents. The value returned by this method is equal to the value that would be returned by , unless is , in which case is returned. - the array whose string representation to return\n• Returns a string representation of the \"deep contents\" of the specified array. If the array contains other arrays as elements, the string representation contains their contents and so on. This method is designed for converting multidimensional arrays to strings. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by , unless they are themselves arrays. If an element is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of . If an element is an array of a reference type, it is converted to a string as by invoking this method recursively. To avoid infinite recursion, if the specified array contains itself as an element, or contains an indirect reference to itself through one or more levels of arrays, the self-reference is converted to the string . For example, an array containing only a reference to itself would be rendered as . This method returns if the specified array is . - the array whose string representation to return\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. Setting a subrange of an array, using a generator function to compute each element, can be written as follows: - type of elements of the array - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. Setting a subrange of an array, in parallel, using a generator function to compute each element, can be written as follows: - type of elements of the array - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. Setting a subrange of an array, using a generator function to compute each element, can be written as follows: - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. Setting a subrange of an array, in parallel, using a generator function to compute each element, can be written as follows: - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. Setting a subrange of an array, using a generator function to compute each element, can be written as follows: - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. Setting a subrange of an array, in parallel, using a generator function to compute each element, can be written as follows: - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. Setting a subrange of an array, using a generator function to compute each element, can be written as follows: - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. Setting a subrange of an array, in parallel, using a generator function to compute each element, can be written as follows: - a function accepting an index and producing the desired value for that position - if the generator is null\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use the spliterator for the array elements\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - The type of the array elements - The array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the type of the array elements - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use an for the array\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover an for the array range - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See for the definition of a common and proper prefix.) A array reference is considered lexicographically less than a non- array reference. Two array references are considered equal. The comparison is consistent with , more specifically the following holds for arrays and : This method behaves as if (for non- array references): - the first array to compare - the second array to compare the value if the first and second array are equal and contain the same elements in the same order; a value less than if the first array is lexicographically less than the second array; and a value greater than if the first array is lexicographically greater than the second array\n• arrays lexicographically over the specified ranges. Compares twoarrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See for the definition of a common and proper prefix.) The comparison is consistent with , more specifically the following holds for arrays and with specified ranges [ , ) and [ , ) respectively: This method behaves as if: - the first array to compare - the index (inclusive) of the first element in the first array to be compared - the index (exclusive) of the last element in the first array to be compared - the second array to compare - the index (inclusive) of the first element in the second array to be compared - the index (exclusive) of the last element in the second array to be compared the value if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than if, over the specified ranges, the first array is lexicographically greater than the second array - if or if - if or if - if either array is\n• arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See for the definition of a common and proper prefix.) A array reference is considered lexicographically less than a non- array reference. Two array references are considered equal. The comparison is consistent with , more specifically the following holds for arrays and : This method behaves as if (for non- array references): - the first array to compare - the second array to compare the value if the first and second array are equal and contain the same elements in the same order; a value less than if the first array is lexicographically less than the second array; and a value greater than if the first array is lexicographically greater than the second array\n• arrays lexicographically over the specified ranges. Compares twoarrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See for the definition of a common and proper prefix.) The comparison is consistent with , more specifically the following holds for arrays and with specified ranges [ , ) and [ , ) respectively: This method behaves as if: - the first array to compare - the index (inclusive) of the first element in the first array to be compared - the index (exclusive) of the last element in the first array to be compared - the second array to compare - the index (inclusive) of the first element in the second array to be compared - the index (exclusive) of the last element in the second array to be compared the value if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than if, over the specified ranges, the first array is lexicographically greater than the second array - if or if - if or if - if either array is\n• arrays lexicographically, numerically treating elements as unsigned. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See for the definition of a common and proper prefix.) A array reference is considered lexicographically less than a non- array reference. Two array references are considered equal. This method behaves as if (for non- array references): - the first array to compare - the second array to compare the value if the first and second array are equal and contain the same elements in the same order; a value less than if the first array is lexicographically less than the second array; and a value greater than if the first array is lexicographically greater than the second array\n• arrays lexicographically over the specified ranges, numerically treating elements as unsigned. Compares twoarrays lexicographically over the specified ranges, numerically treating elements as unsigned. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See for the definition of a common and proper prefix.) This method behaves as if: - the first array to compare - the index (inclusive) of the first element in the first array to be compared - the index (exclusive) of the last element in the first array to be compared - the second array to compare - the index (inclusive) of the first element in the second array to be compared - the index (exclusive) of the last element in the second array to be compared the value if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than if, over the specified ranges, the first array is lexicographically greater than the second array - if or if - if or if - if either array is null\n• arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See for the definition of a common and proper prefix.) A array reference is considered lexicographically less than a non- array reference. Two array references are considered equal. The comparison is consistent with , more specifically the following holds for arrays and : This method behaves as if (for non- array references): - the first array to compare - the second array to compare the value if the first and second array are equal and contain the same elements in the same order; a value less than if the first array is lexicographically less than the second array; and a value greater than if the first array is lexicographically greater than the second array\n• arrays lexicographically over the specified ranges. Compares twoarrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See for the definition of a common and proper prefix.) The comparison is consistent with , more specifically the following holds for arrays and with specified ranges [ , ) and [ , ) respectively: This method behaves as if: - the first array to compare - the index (inclusive) of the first element in the first array to be compared - the index (exclusive) of the last element in the first array to be compared - the second array to compare - the index (inclusive) of the first element in the second array to be compared - the index (exclusive) of the last element in the second array to be compared the value if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than if, over the specified ranges, the first array is lexicographically greater than the second array - if or if - if or if - if either array is\n• arrays lexicographically, numerically treating elements as unsigned. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See for the definition of a common and proper prefix.) A array reference is considered lexicographically less than a non- array reference. Two array references are considered equal. This method behaves as if (for non- array references): - the first array to compare - the second array to compare the value if the first and second array are equal and contain the same elements in the same order; a value less than if the first array is lexicographically less than the second array; and a value greater than if the first array is lexicographically greater than the second array\n• arrays lexicographically over the specified ranges, numerically treating elements as unsigned. Compares twoarrays lexicographically over the specified ranges, numerically treating elements as unsigned. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See for the definition of a common and proper prefix.) This method behaves as if: - the first array to compare - the index (inclusive) of the first element in the first array to be compared - the index (exclusive) of the last element in the first array to be compared - the second array to compare - the index (inclusive) of the first element in the second array to be compared - the index (exclusive) of the last element in the second array to be compared the value if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than if, over the specified ranges, the first array is lexicographically greater than the second array - if or if - if or if - if either array is null\n• arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See for the definition of a common and proper prefix.) A array reference is considered lexicographically less than a non- array reference. Two array references are considered equal. The comparison is consistent with , more specifically the following holds for arrays and : This method behaves as if (for non- array references): - the first array to compare - the second array to compare the value if the first and second array are equal and contain the same elements in the same order; a value less than if the first array is lexicographically less than the second array; and a value greater than if the first array is lexicographically greater than the second array\n• arrays lexicographically over the specified ranges. Compares twoarrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See for the definition of a common and proper prefix.) The comparison is consistent with , more specifically the following holds for arrays and with specified ranges [ , ) and [ , ) respectively: This method behaves as if: - the first array to compare - the index (inclusive) of the first element in the first array to be compared - the index (exclusive) of the last element in the first array to be compared - the second array to compare - the index (inclusive) of the first element in the second array to be compared - the index (exclusive) of the last element in the second array to be compared the value if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than if, over the specified ranges, the first array is lexicographically greater than the second array - if or if - if or if - if either array is\n• arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See for the definition of a common and proper prefix.) A array reference is considered lexicographically less than a non- array reference. Two array references are considered equal. The comparison is consistent with , more specifically the following holds for arrays and : This method behaves as if (for non- array references): - the first array to compare - the second array to compare the value if the first and second array are equal and contain the same elements in the same order; a value less than if the first array is lexicographically less than the second array; and a value greater than if the first array is lexicographically greater than the second array\n• arrays lexicographically over the specified ranges. Compares twoarrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See for the definition of a common and proper prefix.) The comparison is consistent with , more specifically the following holds for arrays and with specified ranges [ , ) and [ , ) respectively: This method behaves as if: - the first array to compare - the index (inclusive) of the first element in the first array to be compared - the index (exclusive) of the last element in the first array to be compared - the second array to compare - the index (inclusive) of the first element in the second array to be compared - the index (exclusive) of the last element in the second array to be compared the value if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than if, over the specified ranges, the first array is lexicographically greater than the second array - if or if - if or if - if either array is\n• arrays lexicographically, numerically treating elements as unsigned. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See for the definition of a common and proper prefix.) A array reference is considered lexicographically less than a non- array reference. Two array references are considered equal. This method behaves as if (for non- array references): - the first array to compare - the second array to compare the value if the first and second array are equal and contain the same elements in the same order; a value less than if the first array is lexicographically less than the second array; and a value greater than if the first array is lexicographically greater than the second array\n• arrays lexicographically over the specified ranges, numerically treating elements as unsigned. Compares twoarrays lexicographically over the specified ranges, numerically treating elements as unsigned. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See for the definition of a common and proper prefix.) This method behaves as if: - the first array to compare - the index (inclusive) of the first element in the first array to be compared - the index (exclusive) of the last element in the first array to be compared - the second array to compare - the index (inclusive) of the first element in the second array to be compared - the index (exclusive) of the last element in the second array to be compared the value if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than if, over the specified ranges, the first array is lexicographically greater than the second array - if or if - if or if - if either array is null\n• arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See for the definition of a common and proper prefix.) A array reference is considered lexicographically less than a non- array reference. Two array references are considered equal. The comparison is consistent with , more specifically the following holds for arrays and : This method behaves as if (for non- array references): - the first array to compare - the second array to compare the value if the first and second array are equal and contain the same elements in the same order; a value less than if the first array is lexicographically less than the second array; and a value greater than if the first array is lexicographically greater than the second array\n• arrays lexicographically over the specified ranges. Compares twoarrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See for the definition of a common and proper prefix.) The comparison is consistent with , more specifically the following holds for arrays and with specified ranges [ , ) and [ , ) respectively: This method behaves as if: - the first array to compare - the index (inclusive) of the first element in the first array to be compared - the index (exclusive) of the last element in the first array to be compared - the second array to compare - the index (inclusive) of the first element in the second array to be compared - the index (exclusive) of the last element in the second array to be compared the value if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than if, over the specified ranges, the first array is lexicographically greater than the second array - if or if - if or if - if either array is\n• arrays lexicographically, numerically treating elements as unsigned. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See for the definition of a common and proper prefix.) A array reference is considered lexicographically less than a non- array reference. Two array references are considered equal. This method behaves as if (for non- array references): - the first array to compare - the second array to compare the value if the first and second array are equal and contain the same elements in the same order; a value less than if the first array is lexicographically less than the second array; and a value greater than if the first array is lexicographically greater than the second array\n• arrays lexicographically over the specified ranges, numerically treating elements as unsigned. Compares twoarrays lexicographically over the specified ranges, numerically treating elements as unsigned. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See for the definition of a common and proper prefix.) This method behaves as if: - the first array to compare - the index (inclusive) of the first element in the first array to be compared - the index (exclusive) of the last element in the first array to be compared - the second array to compare - the index (inclusive) of the first element in the second array to be compared - the index (exclusive) of the last element in the second array to be compared the value if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than if, over the specified ranges, the first array is lexicographically greater than the second array - if or if - if or if - if either array is null\n• arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See for the definition of a common and proper prefix.) A array reference is considered lexicographically less than a non- array reference. Two array references are considered equal. The comparison is consistent with , more specifically the following holds for arrays and : This method behaves as if (for non- array references): - the first array to compare - the second array to compare the value if the first and second array are equal and contain the same elements in the same order; a value less than if the first array is lexicographically less than the second array; and a value greater than if the first array is lexicographically greater than the second array\n• arrays lexicographically over the specified ranges. Compares twoarrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See for the definition of a common and proper prefix.) The comparison is consistent with , more specifically the following holds for arrays and with specified ranges [ , ) and [ , ) respectively: This method behaves as if: - the first array to compare - the index (inclusive) of the first element in the first array to be compared - the index (exclusive) of the last element in the first array to be compared - the second array to compare - the index (inclusive) of the first element in the second array to be compared - the index (exclusive) of the last element in the second array to be compared the value if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than if, over the specified ranges, the first array is lexicographically greater than the second array - if or if - if or if - if either array is\n• arrays lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See for the definition of a common and proper prefix.) A array reference is considered lexicographically less than a non- array reference. Two array references are considered equal. The comparison is consistent with , more specifically the following holds for arrays and : This method behaves as if (for non- array references): - the first array to compare - the second array to compare the value if the first and second array are equal and contain the same elements in the same order; a value less than if the first array is lexicographically less than the second array; and a value greater than if the first array is lexicographically greater than the second array\n• arrays lexicographically over the specified ranges. Compares twoarrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements, as if by , at a relative index within the respective arrays that is the length of the prefix. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See for the definition of a common and proper prefix.) The comparison is consistent with , more specifically the following holds for arrays and with specified ranges [ , ) and [ , ) respectively: This method behaves as if: - the first array to compare - the index (inclusive) of the first element in the first array to be compared - the index (exclusive) of the last element in the first array to be compared - the second array to compare - the index (inclusive) of the first element in the second array to be compared - the index (exclusive) of the last element in the second array to be compared the value if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than if, over the specified ranges, the first array is lexicographically greater than the second array - if or if - if or if - if either array is\n• arrays, within comparable elements, lexicographically. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing two elements of type at an index within the respective arrays that is the prefix length, as if by: Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See for the definition of a common and proper prefix.) A array reference is considered lexicographically less than a non- array reference. Two array references are considered equal. A array element is considered lexicographically than a non- array element. Two array elements are considered equal. The comparison is consistent with , more specifically the following holds for arrays and : This method behaves as if (for non- array references and elements): - the first array to compare - the second array to compare the value if the first and second array are equal and contain the same elements in the same order; a value less than if the first array is lexicographically less than the second array; and a value greater than if the first array is lexicographically greater than the second array\n• arrays lexicographically over the specified ranges. Compares twoarrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing two elements of type at a relative index within the respective arrays that is the prefix length, as if by: Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See for the definition of a common and proper prefix.) The comparison is consistent with , more specifically the following holds for arrays and with specified ranges [ , ) and [ , ) respectively: This method behaves as if (for non- array elements): - the first array to compare - the index (inclusive) of the first element in the first array to be compared - the index (exclusive) of the last element in the first array to be compared - the second array to compare - the index (inclusive) of the first element in the second array to be compared - the index (exclusive) of the last element in the second array to be compared the value if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than if, over the specified ranges, the first array is lexicographically greater than the second array - if or if - if or if - if either array is\n• arrays lexicographically using a specified comparator. If the two arrays share a common prefix then the lexicographic comparison is the result of comparing with the specified comparator two elements at an index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two array lengths. (See for the definition of a common and proper prefix.) A array reference is considered lexicographically less than a non- array reference. Two array references are considered equal. This method behaves as if (for non- array references): - the first array to compare - the second array to compare the value if the first and second array are equal and contain the same elements in the same order; a value less than if the first array is lexicographically less than the second array; and a value greater than if the first array is lexicographically greater than the second array - if the comparator is\n• arrays lexicographically over the specified ranges. Compares twoarrays lexicographically over the specified ranges. If the two arrays, over the specified ranges, share a common prefix then the lexicographic comparison is the result of comparing with the specified comparator two elements at a relative index within the respective arrays that is the prefix length. Otherwise, one array is a proper prefix of the other and, lexicographic comparison is the result of comparing the two range lengths. (See for the definition of a common and proper prefix.) This method behaves as if (for non- array elements): - the first array to compare - the index (inclusive) of the first element in the first array to be compared - the index (exclusive) of the last element in the first array to be compared - the second array to compare - the index (inclusive) of the first element in the second array to be compared - the index (exclusive) of the last element in the second array to be compared the value if, over the specified ranges, the first and second array are equal and contain the same elements in the same order; a value less than if, over the specified ranges, the first array is lexicographically less than the second array; and a value greater than if, over the specified ranges, the first array is lexicographically greater than the second array - if or if - if or if - if either array or the comparator is\n• arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. Finds and returns the index of the first mismatch between twoarrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non- arrays, and , share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and , share a proper prefix if the following expression is true: - the first array to be tested for a mismatch - the second array to be tested for a mismatch the index of the first mismatch between the two arrays, otherwise . - if either array is\n• arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. Finds and returns the relative index of the first mismatch between twoarrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a proper if the following expression is true: - the first array to be tested for a mismatch - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested for a mismatch - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested the relative index of the first mismatch between the two arrays over the specified ranges, otherwise . - if or if - if or if - if either array is\n• arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. Finds and returns the index of the first mismatch between twoarrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non- arrays, and , share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and , share a proper prefix if the following expression is true: - the first array to be tested for a mismatch - the second array to be tested for a mismatch the index of the first mismatch between the two arrays, otherwise . - if either array is\n• arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. Finds and returns the relative index of the first mismatch between twoarrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a proper if the following expression is true: - the first array to be tested for a mismatch - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested for a mismatch - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested the relative index of the first mismatch between the two arrays over the specified ranges, otherwise . - if or if - if or if - if either array is\n• arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. Finds and returns the index of the first mismatch between twoarrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non- arrays, and , share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and , share a proper prefix if the following expression is true: - the first array to be tested for a mismatch - the second array to be tested for a mismatch the index of the first mismatch between the two arrays, otherwise . - if either array is\n• arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. Finds and returns the relative index of the first mismatch between twoarrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a proper if the following expression is true: - the first array to be tested for a mismatch - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested for a mismatch - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested the relative index of the first mismatch between the two arrays over the specified ranges, otherwise . - if or if - if or if - if either array is\n• arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. Finds and returns the index of the first mismatch between twoarrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non- arrays, and , share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and , share a proper prefix if the following expression is true: - the first array to be tested for a mismatch - the second array to be tested for a mismatch the index of the first mismatch between the two arrays, otherwise . - if either array is\n• arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. Finds and returns the relative index of the first mismatch between twoarrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a proper if the following expression is true: - the first array to be tested for a mismatch - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested for a mismatch - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested the relative index of the first mismatch between the two arrays over the specified ranges, otherwise . - if or if - if or if - if either array is\n• arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. Finds and returns the index of the first mismatch between twoarrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non- arrays, and , share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and , share a proper prefix if the following expression is true: - the first array to be tested for a mismatch - the second array to be tested for a mismatch the index of the first mismatch between the two arrays, otherwise . - if either array is\n• arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. Finds and returns the relative index of the first mismatch between twoarrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a proper if the following expression is true: - the first array to be tested for a mismatch - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested for a mismatch - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested the relative index of the first mismatch between the two arrays over the specified ranges, otherwise . - if or if - if or if - if either array is\n• arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. Finds and returns the index of the first mismatch between twoarrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non- arrays, and , share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and , share a proper prefix if the following expression is true: - the first array to be tested for a mismatch - the second array to be tested for a mismatch the index of the first mismatch between the two arrays, otherwise . - if either array is\n• arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. Finds and returns the relative index of the first mismatch between twoarrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a proper if the following expression is true: - the first array to be tested for a mismatch - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested for a mismatch - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested the relative index of the first mismatch between the two arrays over the specified ranges, otherwise . - if or if - if or if - if either array is\n• arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. Finds and returns the index of the first mismatch between twoarrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non- arrays, and , share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and , share a proper prefix if the following expression is true: - the first array to be tested for a mismatch - the second array to be tested for a mismatch the index of the first mismatch between the two arrays, otherwise . - if either array is\n• arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. Finds and returns the relative index of the first mismatch between twoarrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a proper if the following expression is true: - the first array to be tested for a mismatch - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested for a mismatch - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested the relative index of the first mismatch between the two arrays over the specified ranges, otherwise . - if or if - if or if - if either array is\n• arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. Finds and returns the index of the first mismatch between twoarrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non- arrays, and , share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and , share a proper prefix if the following expression is true: - the first array to be tested for a mismatch - the second array to be tested for a mismatch the index of the first mismatch between the two arrays, otherwise . - if either array is\n• arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. Finds and returns the relative index of the first mismatch between twoarrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a proper if the following expression is true: - the first array to be tested for a mismatch - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested for a mismatch - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested the relative index of the first mismatch between the two arrays over the specified ranges, otherwise . - if or if - if or if - if either array is\n• arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. Finds and returns the index of the first mismatch between twoarrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non- arrays, and , share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and , share a proper prefix if the following expression is true: - the first array to be tested for a mismatch - the second array to be tested for a mismatch the index of the first mismatch between the two arrays, otherwise . - if either array is\n• arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. Finds and returns the relative index of the first mismatch between twoarrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a proper if the following expression is true: - the first array to be tested for a mismatch - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested for a mismatch - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested the relative index of the first mismatch between the two arrays over the specified ranges, otherwise . - if or if - if or if - if either array is\n• arrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. Finds and returns the index of the first mismatch between twoarrays, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller array. The specified comparator is used to determine if two array elements from the each array are not equal. If the two arrays share a common prefix then the returned index is the length of the common prefix and it follows that there is a mismatch between the two elements at that index within the respective arrays. If one array is a proper prefix of the other then the returned index is the length of the smaller array and it follows that the index is only valid for the larger array. Otherwise, there is no mismatch. Two non- arrays, and , share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and , share a proper prefix if the following expression is true: - the first array to be tested for a mismatch - the second array to be tested for a mismatch the index of the first mismatch between the two arrays, otherwise . - if either array or the comparator is\n• arrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. Finds and returns the relative index of the first mismatch between twoarrays over the specified ranges, otherwise return -1 if no mismatch is found. The index will be in the range of 0 (inclusive) up to the length (inclusive) of the smaller range. If the two arrays, over the specified ranges, share a common prefix then the returned relative index is the length of the common prefix and it follows that there is a mismatch between the two elements at that relative index within the respective arrays. If one array is a proper prefix of the other, over the specified ranges, then the returned relative index is the length of the smaller range and it follows that the relative index is only valid for the array with the larger range. Otherwise, there is no mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a common prefix of length if the following expression is true: Note that a common prefix length of indicates that the first elements from each array mismatch. Note that a common prefix length ofindicates that the first elements from each array mismatch. Two non- arrays, and with specified ranges [ , ) and [ , ) respectively, share a proper if the following expression is true: - the first array to be tested for a mismatch - the index (inclusive) of the first element in the first array to be tested - the index (exclusive) of the last element in the first array to be tested - the second array to be tested for a mismatch - the index (inclusive) of the first element in the second array to be tested - the index (exclusive) of the last element in the second array to be tested the relative index of the first mismatch between the two arrays over the specified ranges, otherwise . - if or if - if or if - if either array or the comparator is"
    },
    {
        "link": "https://geeksforgeeks.org/arrays-copyof-in-java-with-examples",
        "document": "Arrays.copyOf() is a method of java.util.Arrays class. It is used to copy the specified array, truncating or padding with false (for boolean arrays) if necessary so that the copy has the specified length.\n\nThis method can be used with both 1D and 2D arrays, but it’s important to note that Arrays.copyOf() performs a shallow copy, meaning that if you’re copying an array of objects, the objects themselves are not duplicated—only the references to them.\n\nThe below example shows the basic use of Arrays.copyOf() method to create a copy of an array with a specified length.\n\nThis demonstrates how Arrays.copyOf() method can be used to duplicate a 1D array with basic functionality before exploring complex examples.\n\nHere, we will learn how to use method to copy a 1D array and then modify its extra elements.\n• original : The original array to be copied.\n• newLength : The desired length of the new copy.\n\nWhen the length of the copied array is greater than the original, the new array is padded with default values (0 for int, false for boolean, and null for reference types) to fill the remaining indices.\n\nWhen working with 2D arrays, the method performs a shallow copy, meaning only the references to each row are copied. For a deep copy of the rows in a 2D array, you would need to copy each row individually."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html",
        "document": "\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. All elements in the array must implement the interface. Furthermore, all elements in the array must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - if the array contains elements that are not mutually comparable (for example, strings and integers) - (optional) if the natural ordering of the array elements is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in this range must implement the mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified range of the specified array of objects into ascending order, according to the natural ordering of its elements. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in this range must implement the interface. Furthermore, all elements in this range must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable by the specified comparator (that is, must not throw a for any elements and in the array). Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must beby the specified comparator (that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator - (optional) if the comparator is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, must not throw a for any elements and in the range). Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in the range must beby the specified comparator (that is,must not throw afor any elementsandin the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. All elements in the array must implement the interface. Furthermore, all elements in the array must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the array to be sorted - if the array contains elements that are not mutually comparable (for example, strings and integers) - (optional) if the natural ordering of the array elements is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in this range must implement the mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified range of the specified array of objects into ascending order, according to the natural ordering of its elements. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in this range must implement the interface. Furthermore, all elements in this range must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable by the specified comparator (that is, must not throw a for any elements and in the array). Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must beby the specified comparator (that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the class of the objects to be sorted - the array to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator - (optional) if the comparator is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, must not throw a for any elements and in the range). Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in the range must beby the specified comparator (that is,must not throw afor any elementsandin the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator. - if or (optional) if the comparator is found to violate the contract\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the class of the objects in the array - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the class of the objects in the array - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holdsand the operation performs addition, then upon return the array holds. Parallel prefix computation is usually more efficient than sequential loops for large arrays. Because floating-point operations may not be strictly associative, the returned result may not be identical to the value that would be obtained if the operation was performed sequentially. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of longs for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of ints for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of shorts for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of chars for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of bytes for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of doubles for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of floats for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the natural ordering of its elements (as by the method) prior to making this call. If it is not sorted, the results are undefined. (If the array contains elements that are not mutually comparable (for example, strings and integers), itbe sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the search key is not comparable to the elements of the array.\n• cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the natural ordering of its elements (as by the method) prior to making this call. If it is not sorted, the results are undefined. (If the range contains elements that are not mutually comparable (for example, strings and integers), itbe sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the search key is not comparable to the elements of the array within the specified range.\n• Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the specified comparator (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the class of the objects in the array - the array to be searched - the value to be searched for - the comparator by which the array is ordered. A value indicates that the elements' natural ordering should be used. index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the array contains elements that are not mutually comparable using the specified comparator, or the search key is not comparable to the elements of the array using this comparator.\n• Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the specified comparator (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the class of the objects in the array - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for - the comparator by which the array is ordered. A value indicates that the elements' natural ordering should be used. index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the range contains elements that are not mutually comparable using the specified comparator, or the search key is not comparable to the elements in the range using this comparator.\n• if the two specified arrays of longs are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of longs areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of ints are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of ints areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of shorts are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of shorts areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of chars are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of chars areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of bytes are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of bytes areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of booleans are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of booleans areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of doubles are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of doubles areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are Two doubles and are considered equal if: (Unlike the operator, this method considers equals to itself, and 0.0d unequal to -0.0d.) - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of floats are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of floats areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are Two floats and are considered equal if: (Unlike the operator, this method considers equals to itself, and 0.0f unequal to -0.0f.) - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of Objects are equal to one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objects and are considered equal if . In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of Objects areto one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objectsandare consideredif. In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• Assigns the specified long value to each element of the specified array of longs. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified long value to each element of the specified range of the specified array of longs. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified int value to each element of the specified array of ints. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified int value to each element of the specified range of the specified array of ints. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified short value to each element of the specified array of shorts. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified short value to each element of the specified range of the specified array of shorts. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified char value to each element of the specified array of chars. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified char value to each element of the specified range of the specified array of chars. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified byte value to each element of the specified array of bytes. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified byte value to each element of the specified range of the specified array of bytes. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified boolean value to each element of the specified array of booleans. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified boolean value to each element of the specified range of the specified array of booleans. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified double value to each element of the specified array of doubles. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified double value to each element of the specified range of the specified array of doubles. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified float value to each element of the specified array of floats. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified float value to each element of the specified range of the specified array of floats. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified Object reference to each element of the specified array of Objects. - the array to be filled - the value to be stored in all elements of the array - if the specified value is not of a runtime type that can be stored in the specified array\n• Assigns the specified Object reference to each element of the specified range of the specified array of Objects. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array - if the specified value is not of a runtime type that can be stored in the specified array\n• Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of exactly the same class as the original array. - the class of the objects in the array - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with nulls to obtain the specified length\n• Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of the class . - the class of the objects in the original array - the class of the objects in the returned array - the array to be copied - the length of the copy to be returned - the class of the copy to be returned a copy of the original array, truncated or padded with nulls to obtain the specified length - if an element copied from is not of a runtime type that can be stored in an array of class\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with null characters (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with null characters to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with false elements to obtain the specified length\n• ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . Copies the specified range of the specified array into a new array. The initial index of the range () must lie between zero and, inclusive. The value atis placed into the initial element of the copy (unlessor). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (), which must be greater than or equal to, may be greater than, in which caseis placed in all elements of the copy whose index is greater than or equal to. The length of the returned array will be The resulting array is of exactly the same class as the original array. - the class of the objects in the array - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with nulls to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . The resulting array is of the class . - the class of the objects in the original array - the class of the objects in the returned array - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) - the class of the copy to be returned a new array containing the specified range from the original array, truncated or padded with nulls to obtain the required length - if an element copied from is not of a runtime type that can be stored in an array of class .\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with null characters to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with false elements to obtain the required length\n• Returns a fixed-size list backed by the specified array. (Changes to the returned list \"write through\" to the array.) This method acts as bridge between array-based and collection-based APIs, in combination with . The returned list is serializable and implements This method also provides a convenient way to create a fixed-size list initialized to contain several elements: - the class of the objects in the array - the array by which the list will be backed a list view of the specified array\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any two non-nullarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• Returns a hash code based on the contents of the specified array. If the array contains other arrays as elements, the hash code is based on their identities rather than their contents. It is therefore acceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. For any two arrays and such that , it is also the case that . The value returned by this method is equal to the value that would be returned by , unless is , in which case is returned. - the array whose content-based hash code to compute\n• Returns a hash code based on the \"deep contents\" of the specified array. If the array contains other arrays as elements, the hash code is based on their contents and so on, ad infinitum. It is therefore unacceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. The behavior of such an invocation is undefined. For any two arrays and such that , it is also the case that . The computation of the value returned by this method is similar to that of the value returned by on a list containing the same elements as in the same order, with one difference: If an element of is itself an array, its hash code is computed not by calling , but as by calling the appropriate overloading of if is an array of a primitive type, or as by calling recursively if is an array of a reference type. If is , this method returns 0. - the array whose deep-content-based hash code to compute\n• if the two specified arrays are deeply equal to one another. Unlike the Returnsif the two specified arrays areto one another. Unlike the method, this method is appropriate for use with nested arrays of arbitrary depth. Two array references are considered deeply equal if both are , or if they refer to arrays that contain the same number of elements and all corresponding pairs of elements in the two arrays are deeply equal. Two possibly elements and are deeply equal if any of the following conditions hold:\n• and are both arrays of object reference types, and\n• and are arrays of the same primitive type, and the appropriate overloading of would return true. Note that this definition permits elements at any depth. Note that this definition permitselements at any depth. If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined. - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• , which describes their identities rather than their contents. Returns a string representation of the contents of the specified array. If the array contains other arrays as elements, they are converted to strings by the method inherited from, which describes theirrather than their contents. The value returned by this method is equal to the value that would be returned by , unless is , in which case is returned. - the array whose string representation to return\n• Returns a string representation of the \"deep contents\" of the specified array. If the array contains other arrays as elements, the string representation contains their contents and so on. This method is designed for converting multidimensional arrays to strings. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by , unless they are themselves arrays. If an element is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of . If an element is an array of a reference type, it is converted to a string as by invoking this method recursively. To avoid infinite recursion, if the specified array contains itself as an element, or contains an indirect reference to itself through one or more levels of arrays, the self-reference is converted to the string . For example, an array containing only a reference to itself would be rendered as . This method returns if the specified array is . - the array whose string representation to return\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - type of elements of the array - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - type of elements of the array - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use the spliterator for the array elements\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - The type of the array elements - The array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the type of the array elements - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use an for the array\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover an for the array range - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size"
    },
    {
        "link": "https://stackoverflow.com/questions/13197702/resize-an-array-while-keeping-current-elements-in-java",
        "document": "Here are a couple of ways to do it.\n\nCopies an array from the specified source array, beginning at the specified position, to the specified position of the destination array. A subsequence of array components are copied from the source array referenced by src to the destination array referenced by dest. The number of components copied is equal to the length argument. The components at positions srcPos through srcPos+length-1 in the source array are copied into positions destPos through destPos+length-1, respectively, of the destination array.\n\nCopies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain null. Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of exactly the same class as the original array.\n\nNote that this method usually uses behind the scenes.\n\nResizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)\n\nArrayList functions similarly to an array, except it automatically expands when you add more elements than it can contain. It's backed by an array, and uses Arrays.copyOf."
    },
    {
        "link": "https://stackoverflow.com/questions/5785745/make-copy-of-an-array",
        "document": "If you must work with raw arrays and not then has what you need. If you look at the source code, these are the absolutely best ways to get a copy of an array. They do have a good bit of defensive programming because the method throws lots of unchecked exceptions if you feed it illogical parameters.\n\nYou can use either which will copy from the first to element to the new shorter array.\n\nCopies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain null. Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of exactly the same class as the original array.\n\nor will also do the trick:\n\nCopies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case null is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from. The resulting array is of exactly the same class as the original array.\n\nAs you can see, both of these are just wrapper functions over with defensive logic that what you are trying to do is valid.\n\nis the absolute fastest way to copy arrays."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/java-singleton-design-pattern-best-practices-examples",
        "document": "Java Singleton Pattern is one of the Gangs of Four Design patterns and comes in the Creational Design Pattern category. From the definition, it seems to be a straightforward design pattern, but when it comes to implementation, it comes with a lot of concerns.\n\nIn this article, we will learn about singleton design pattern principles, explore different ways to implement the singleton design pattern, and some of the best practices for its usage.\n• Singleton pattern restricts the instantiation of a class and ensures that only one instance of the class exists in the Java Virtual Machine.\n• The singleton class must provide a global access point to get the instance of the class.\n• Singleton pattern is used for logging, drivers objects, caching, and thread pool.\n• Singleton design pattern is also used in other design patterns like Abstract Factory, Builder, Prototype, Facade, etc.\n• Singleton design pattern is used in core Java classes also (for example, , ).\n\nTo implement a singleton pattern, we have different approaches, but all of them have the following common concepts.\n• Private constructor to restrict instantiation of the class from other classes.\n• Private static variable of the same class that is the only instance of the class.\n• Public static method that returns the instance of the class, this is the global access point for the outer world to get the instance of the singleton class.\n\nIn further sections, we will learn different approaches to singleton pattern implementation and design concerns with the implementation.\n\nIn eager initialization, the instance of the singleton class is created at the time of class loading. The drawback to eager initialization is that the method is created even though the client application might not be using it. Here is the implementation of the static initialization singleton class:\n\nIf your singleton class is not using a lot of resources, this is the approach to use. But in most of the scenarios, singleton classes are created for resources such as File System, Database connections, etc. We should avoid the instantiation unless the client calls the method. Also, this method doesn’t provide any options for exception handling.\n\nStatic block initialization implementation is similar to eager initialization, except that instance of the class is created in the static block that provides the option for exception handling.\n\nBoth eager initialization and static block initialization create the instance even before it’s being used and that is not the best practice to use.\n\nLazy initialization method to implement the singleton pattern creates the instance in the global access method. Here is the sample code for creating the singleton class with this approach:\n\nThe preceding implementation works fine in the case of the single-threaded environment, but when it comes to multi-threaded systems, it can cause issues if multiple threads are inside the condition at the same time. It will destroy the singleton pattern and both threads will get different instances of the singleton class. In the next section, we will see different ways to create a thread-safe singleton class.\n\nA simple way to create a thread-safe singleton class is to make the global access method synchronized so that only one thread can execute this method at a time. Here is a general implementation of this approach:\n\nThe preceding implementation works fine and provides thread-safety, but it reduces the performance because of the cost associated with the synchronized method, although we need it only for the first few threads that might create separate instances. To avoid this extra overhead every time, double-checked locking principle is used. In this approach, the synchronized block is used inside the condition with an additional check to ensure that only one instance of a singleton class is created. The following code snippet provides the double-checked locking implementation:\n\nPrior to Java 5, the Java memory model had a lot of issues, and the previous approaches used to fail in certain scenarios where too many threads tried to get the instance of the singleton class simultaneously. So Bill Pugh came up with a different approach to create the singleton class using an inner static helper class. Here is an example of the Bill Pugh Singleton implementation:\n\nNotice the private inner static class that contains the instance of the singleton class. When the singleton class is loaded, class is not loaded into memory and only when someone calls the method, this class gets loaded and creates the singleton class instance. This is the most widely used approach for the singleton class as it doesn’t require synchronization.\n\nReflection can be used to destroy all the previous singleton implementation approaches. Here is an example class:\n\nWhen you run the preceding test class, you will notice that of both instances is not the same which destroys the singleton pattern. Reflection is very powerful and used in a lot of frameworks like Spring and Hibernate. Continue your learning with Java Reflection Tutorial.\n\nTo overcome this situation with Reflection, Joshua Bloch suggests the use of to implement the singleton design pattern as Java ensures that any value is instantiated only once in a Java program. Since Java Enum values are globally accessible, so is the singleton. The drawback is that the type is somewhat inflexible (for example, it does not allow lazy initialization).\n\nSometimes in distributed systems, we need to implement interface in the singleton class so that we can store its state in the file system and retrieve it at a later point in time. Here is a small singleton class that implements interface also:\n\nThe problem with serialized singleton class is that whenever we deserialize it, it will create a new instance of the class. Here is an example:\n\nSo it destroys the singleton pattern. To overcome this scenario, all we need to do is provide the implementation of method.\n\nAfter this, you will notice that of both instances is the same in the test program.\n\nContinue your learning with more Java tutorials."
    },
    {
        "link": "https://geeksforgeeks.org/java-singleton-design-pattern-practices-examples",
        "document": "In previous articles, we discussed about singleton design pattern and singleton class implementation in detail. \n\nIn this article, we will see how we can create singleton classes. After reading this article you will be able to create your singleton class according to your requirement, which is simple and without bottlenecks. \n\nThere are many ways this can be done in Java. All these ways differ in their implementation of the pattern, but in the end, they all achieve the same end result of a single instance.\n• Eager initialization: This is the simplest method of creating a singleton class. In this, object of class is created when it is loaded to the memory by JVM. It is done by assigning the reference of an instance directly. \n\n It can be used when program will always use instance of this class, or the cost of creating the instance is not too large in terms of resources and time.\n• Pros:\n• None May lead to resource wastage. Because instance of class is created always, whether it is required or not.\n• None CPU time is also wasted in creation of instance if it is not required.\n• None Exception handling is not possible.\n• Using static block: This is also a sub part of Eager initialization. The only difference is object is created in a static block so that we can have access on its creation, like exception handling. In this way also, object is created at the time of class loading. \n\n It can be used when there is a chance of exceptions in creating object with eager initialization.\n• Pros:\n• None No need to implement getInstance() method. Instance can be accessed directly.\n• None Exceptions can be handled in static block.\n• None May lead to resource wastage. Because instance of class is created always, whether it is required or not.\n• None CPU time is also wasted in creation of instance if it is not required.\n• Lazy initialization: In this method, object is created only if it is needed. This may prevent resource wastage. An implementation of getInstance() method is required which return the instance. There is a null check that if object is not created then create, otherwise return previously created. To make sure that class cannot be instantiated in any other way, constructor is made final. As object is created with in a method, it ensures that object will not be created until and unless it is required. Instance is kept private so that no one can access it directly. \n\n It can be used in a single threaded environment because multiple threads can break singleton property as they can access get instance method simultaneously and create multiple objects.\n• Pros:\n• None Object is created only if it is needed. It may overcome wastage of resource and CPU time.\n• None Exception handling is also possible in method.\n• None Every time a condition of null has to be checked.\n• None In multithreaded environment, it may break singleton property.\n• Thread Safe Singleton: A thread safe singleton is created so that singleton property is maintained even in multithreaded environment. To make a singleton class thread safe, getInstance() method is made synchronized so that multiple threads can’t access it simultaneously.\n• Pros:\n• None It is also thread safe.\n• None getInstance() method is synchronized so it causes slow performance as multiple threads can’t access it simultaneously.\n• Lazy initialization with Double check locking: In this mechanism, we overcome the overhead problem of synchronized code. In this method, getInstance is not synchronized but the block which creates instance is synchronized so that minimum number of threads have to wait and that’s only for first time.\n• Pros:\n• None It is also thread safe.\n• None Performance overhead gets reduced because of synchronized keyword.\n• None First time, it can affect performance.\n• Bill Pugh Singleton Implementation: Prior to Java5, memory model had a lot of issues and above methods caused failure in certain scenarios in multithreaded environment. So, Bill Pugh suggested a concept of inner static classes to use for singleton.\n• When the singleton class is loaded, inner class is not loaded and hence doesn’t create object when loading the class. Inner class is created only when getInstance() method is called. So it may seem like eager initialization but it is lazy initialization. \n\n This is the most widely used approach as it doesn’t use synchronization.\n\nWhen to use What\n• None Eager initialization is easy to implement but it may cause resource and CPU time wastage. Use it only if cost of initializing a class is less in terms of resources or your program will always need the instance of class.\n• None By using Static block in Eager initialization we can provide exception handling and also can control over instance.\n• None Using synchronized we can create singleton class in multi-threading environment also but it can cause slow performance, so we can use Double check locking mechanism.\n• None Bill Pugh implementation is most widely used approach for singleton classes. Most developers prefer it because of its simplicity and advantages."
    },
    {
        "link": "https://stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java",
        "document": "What is an efficient way to implement a singleton design pattern in Java?\n\nWant to improve this question? Update the question so it focuses on one problem only by editing this post .\n\n. This question needs to be more focused . It is not currently accepting answers.\n\nDepending on the usage, there are several \"correct\" answers. Since Java 5, the best way to do it is to use an enum: Pre Java 5, the most simple case is: public final class Foo { private static final Foo INSTANCE = new Foo(); private Foo() { if (INSTANCE != null) { throw new IllegalStateException(\"Already instantiated\"); } } public static Foo getInstance() { return INSTANCE; } public Object clone() throws CloneNotSupportedException{ throw new CloneNotSupportedException(\"Cannot clone instance of this class\"); } } Let's go over the code. First, you want the class to be final. In this case, I've used the keyword to let the users know it is final. Then you need to make the constructor private to prevent users to create their own Foo. Throwing an exception from the constructor prevents users to use reflection to create a second Foo. Then you create a field to hold the only instance, and a method to return it. The Java specification makes sure that the constructor is only called when the class is first used. When you have a very large object or heavy construction code and also have other accessible static methods or fields that might be used before an instance is needed, then and only then you need to use lazy initialization. You can use a to load the instance. The code would then look like: public final class Foo { private static class FooLoader { private static final Foo INSTANCE = new Foo(); } private Foo() { if (FooLoader.INSTANCE != null) { throw new IllegalStateException(\"Already instantiated\"); } } public static Foo getInstance() { return FooLoader.INSTANCE; } } Since the line is only executed when the class FooLoader is actually used, this takes care of the lazy instantiation, and is it guaranteed to be thread safe. When you also want to be able to serialize your object you need to make sure that deserialization won't create a copy. public final class Foo implements Serializable { private static final long serialVersionUID = 1L; private static class FooLoader { private static final Foo INSTANCE = new Foo(); } private Foo() { if (FooLoader.INSTANCE != null) { throw new IllegalStateException(\"Already instantiated\"); } } public static Foo getInstance() { return FooLoader.INSTANCE; } @SuppressWarnings(\"unused\") private Foo readResolve() { return FooLoader.INSTANCE; } } The method will make sure the only instance will be returned, even when the object was serialized in a previous run of your program.\n\nDisclaimer: I have just summarized all of the awesome answers and wrote it in my own words. While implementing Singleton we have two options: Lazy loading adds bit overhead (lots of to be honest), so use it only when you have a very large object or heavy construction code and also have other accessible static methods or fields that might be used before an instance is needed, then and only then you need to use lazy initialization. Otherwise, choosing early loading is a good choice. The most simple way of implementing a singleton is: public class Foo { // It will be our sole hero private static final Foo INSTANCE = new Foo(); private Foo() { if (INSTANCE != null) { // SHOUT throw new IllegalStateException(\"Already instantiated\"); } } public static Foo getInstance() { return INSTANCE; } } Everything is good except it's an early loaded singleton. Lets try lazy loaded singleton class Foo { // Our now_null_but_going_to_be sole hero private static Foo INSTANCE = null; private Foo() { if (INSTANCE != null) { // SHOUT throw new IllegalStateException(\"Already instantiated\"); } } public static Foo getInstance() { // Creating only when required. if (INSTANCE == null) { INSTANCE = new Foo(); } return INSTANCE; } } So far so good, but our hero will not survive while fighting alone with multiple evil threads who want many many instance of our hero. So let’s protect it from evil multi threading: class Foo { private static Foo INSTANCE = null; // TODO Add private shouting constructor public static Foo getInstance() { // No more tension of threads synchronized (Foo.class) { if (INSTANCE == null) { INSTANCE = new Foo(); } } return INSTANCE; } } But it is not enough to protect out hero, really!!! This is the best we can/should do to help our hero: class Foo { // Pay attention to volatile private static volatile Foo INSTANCE = null; // TODO Add private shouting constructor public static Foo getInstance() { if (INSTANCE == null) { // Check 1 synchronized (Foo.class) { if (INSTANCE == null) { // Check 2 INSTANCE = new Foo(); } } } return INSTANCE; } } This is called the \"double-checked locking idiom\". It's easy to forget the volatile statement and difficult to understand why it is necessary. For details: The \"Double-Checked Locking is Broken\" Declaration Now we are sure about evil threads, but what about the cruel serialization? We have to make sure even while de-serialiaztion no new object is created: class Foo implements Serializable { private static final long serialVersionUID = 1L; private static volatile Foo INSTANCE = null; // The rest of the things are same as above // No more fear of serialization @SuppressWarnings(\"unused\") private Object readResolve() { return INSTANCE; } } The method will make sure the only instance will be returned, even when the object was serialized in a previous run of our program. Finally, we have added enough protection against threads and serialization, but our code is looking bulky and ugly. Let’s give our hero a makeover: public final class Foo implements Serializable { private static final long serialVersionUID = 1L; // Wrapped in a inner static class so that loaded only when required private static class FooLoader { // And no more fear of threads private static final Foo INSTANCE = new Foo(); } // TODO add private shouting construcor public static Foo getInstance() { return FooLoader.INSTANCE; } // Damn you serialization @SuppressWarnings(\"unused\") private Foo readResolve() { return FooLoader.INSTANCE; } } Yes, this is our very same hero :) Since the line is only executed when the class is actually used, this takes care of the lazy instantiation, and is it guaranteed to be thread-safe. And we have come so far. Here is the best way to achieve everything we did is best possible way: Which internally will be treated like public class Foo { // It will be our sole hero private static final Foo INSTANCE = new Foo(); } That's it! No more fear of serialization, threads and ugly code. Also ENUMS singleton are lazily initialized. This approach is functionally equivalent to the public field approach, except that it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. While this approach has yet to be widely adopted, a single-element enum type is the best way to implement a singleton. Now you might have realized why ENUMS are considered as best way to implement a singleton and thanks for your patience :)\n\nThere is a lot of nuance around implementing a singleton. The holder pattern can not be used in many situations. And IMO when using a volatile - you should also use a local variable. Let's start at the beginning and iterate on the problem. You'll see what I mean. The first attempt might look something like this: Here we have the MySingleton class which has a private static member called INSTANCE, and a public static method called getInstance(). The first time getInstance() is called, the INSTANCE member is null. The flow will then fall into the creation condition and create a new instance of the MySingleton class. Subsequent calls to getInstance() will find that the INSTANCE variable is already set, and therefore not create another MySingleton instance. This ensures there is only one instance of MySingleton which is shared among all callers of getInstance(). But this implementation has a problem. Multi-threaded applications will have a race condition on the creation of the single instance. If multiple threads of execution hit the getInstance() method at (or around) the same time, they will each see the INSTANCE member as null. This will result in each thread creating a new MySingleton instance and subsequently setting the INSTANCE member. Here we’ve used the synchronized keyword in the method signature to synchronize the getInstance() method. This will certainly fix our race condition. Threads will now block and enter the method one at a time. But it also creates a performance problem. Not only does this implementation synchronize the creation of the single instance; it synchronizes all calls to getInstance(), including reads. Reads do not need to be synchronized as they simply return the value of INSTANCE. Since reads will make up the bulk of our calls (remember, instantiation only happens on the first call), we will incur an unnecessary performance hit by synchronizing the entire method. Here we’ve moved synchronization from the method signature, to a synchronized block that wraps the creation of the MySingleton instance. But does this solve our problem? Well, we are no longer blocking on reads, but we’ve also taken a step backward. Multiple threads will hit the getInstance() method at or around the same time and they will all see the INSTANCE member as null. They will then hit the synchronized block where one will obtain the lock and create the instance. When that thread exits the block, the other threads will contend for the lock, and one by one each thread will fall through the block and create a new instance of our class. So we are right back where we started. Here we issue another check from inside the block. If the INSTANCE member has already been set, we’ll skip initialization. This is called double-checked locking. This solves our problem of multiple instantiation. But once again, our solution has presented another challenge. Other threads might not “see” that the INSTANCE member has been updated. This is because of how Java optimizes memory operations. Threads copy the original values of variables from main memory into the CPU’s cache. Changes to values are then written to, and read from, that cache. This is a feature of Java designed to optimize performance. But this creates a problem for our singleton implementation. A second thread — being processed by a different CPU or core, using a different cache — will not see the changes made by the first. This will cause the second thread to see the INSTANCE member as null forcing a new instance of our singleton to be created. We solve this by using the volatile keyword on the declaration of the INSTANCE member. This will tell the compiler to always read from, and write to, main memory, and not the CPU cache. But this simple change comes at a cost. Because we are bypassing the CPU cache, we will take a performance hit each time we operate on the volatile INSTANCE member — which we do four times. We double-check existence (1 and 2), set the value (3), and then return the value (4). One could argue that this path is the fringe case as we only create the instance during the first call of the method. Perhaps a performance hit on creation is tolerable. But even our main use-case, reads, will operate on the volatile member twice. Once to check existence, and again to return its value. Since the performance hit is due to operating directly on the volatile member, let’s set a local variable to the value of the volatile and operate on the local variable instead. This will decrease the number of times we operate on the volatile, thereby reclaiming some of our lost performance. Note that we have to set our local variable again when we enter the synchronized block. This ensures it is up to date with any changes that occurred while we were waiting for the lock. I wrote an article about this recently. Deconstructing The Singleton. You can find more information on these examples and an example of the \"holder\" pattern there. There is also a real-world example showcasing the double-checked volatile approach.\n\nI would say an enum singleton. Singleton using an enum in Java is generally a way to declare an enum singleton. An enum singleton may contain instance variables and instance methods. For simplicity's sake, also note that if you are using any instance method then you need to ensure thread safety of that method if at all it affects the state of object. The use of an enum is very easy to implement and has no drawbacks regarding serializable objects, which have to be circumvented in the other ways. /** * Singleton pattern example using a Java Enum */ public enum Singleton { INSTANCE; public void execute (String arg) { // Perform operation here } } You can access it by , and it is much easier than calling the method on Singleton. Enum constants are serialized differently than ordinary serializable or externalizable objects. The serialized form of an enum constant consists solely of its name; field values of the constant are not present in the form. To serialize an enum constant, writes the value returned by the enum constant's name method. To deserialize an enum constant, reads the constant name from the stream; the deserialized constant is then obtained by calling the method, passing the constant's enum type along with the received constant name as arguments. Like other serializable or externalizable objects, enum constants can function as the targets of back references appearing subsequently in the serialization stream. The process by which enum constants are serialized cannot be customized: any class-specific , , , , and methods defined by enum types are ignored during serialization and deserialization. Similarly, any or field declarations are also ignored--all enum types have a fixed of . Documenting serializable fields and data for enum types is unnecessary, since there is no variation in the type of data sent. Another problem with conventional Singletons are that once you implement the interface, they no longer remain singleton because the method always return a new instance, like a constructor in Java. This can be avoided by using and discarding the newly created instance by replacing with a singleton like below: // readResolve to prevent another instance of Singleton private Object readResolve(){ return INSTANCE; } This can become even more complex if your singleton class maintains state, as you need to make them transient, but with in an enum singleton, serialization is guaranteed by the JVM."
    },
    {
        "link": "https://geeksforgeeks.org/singleton-design-pattern",
        "document": "The Singleton Method Design Pattern ensures a class has only one instance and provides a global access point to it. It’s ideal for scenarios requiring centralized control, like managing database connections or configuration settings. This article explores its principles, benefits, drawbacks, and best use cases in software development.\n\nBelow are the principles of the Singleton Pattern:\n• Single Instance: Singleton ensures that only one instance of the class exists throughout the application.\n• Global Access: Provide a global point of access to that instance.\n• Lazy or Eager Initialization: Support creating the instance either when needed (lazy) or when the class is loaded (eager).\n• Private Constructor: Restrict direct instantiation by making the constructor private, forcing the use of the access point\n\nWhen to use Singleton Method Design Pattern?\n\nUse the Singleton method Design Pattern when:\n• None Consider using the Singleton pattern when you need to ensure that only one instance of a class exists in your application.\n• None Use it when you want to provide a straightforward way for clients to access that instance from a specific location in your code.\n• None If you think you might want to extend the class later, the Singleton pattern is a good choice. It allows for subclassing, so clients can work with the extended version without changing the original Singleton.\n• None This pattern is often used in situations like logging, managing connections to hardware or databases, caching data, or handling thread pools, where having just one instance makes sense\n\nSingleton class can be instantiated by two methods:\n• Early initialization : In this method, class is initialized whether it is to be used or not. The main advantage of this method is its simplicity. You initiate the class at the time of class loading. Its drawback is that class is always initialized whether it is being used or not.\n• Lazy initialization : In this method, class in initialized only when it is required. It can save you from instantiating the class when you don’t need it. Generally, lazy initialization is used when we create a singleton class.\n\nBelow are the main key components of Singleton Method Design Pattern:\n\nThe Singleton pattern or pattern Singleton employs a static member within the class. This static member ensures that memory is allocated only once, preserving the single instance of the Singleton class.\n\nThe Singleton pattern or pattern singleton incorporates a private constructor, which serves as a barricade against external attempts to create instances of the Singleton class. This ensures that the class has control over its instantiation process.\n\nA crucial aspect of the Singleton pattern is the presence of a static factory method. This method acts as a gateway, providing a global point of access to the Singleton object. When someone requests an instance, this method either creates a new instance (if none exists) or returns the existing instance to the caller.\n\nThe implementation of a Singleton Design Pattern or Pattern Singleton is described in the following class diagram:\n\nThe implementation of the singleton Design pattern is very simple and consists of a single class. To ensure that the singleton instance is unique, all the singleton constructors should be made private. Global access is done through a static method that can be globally accesed to a single instance as shown in the code.\n\nThe getInstance method, we check whether the instance is null. If the instance is not null, it means the object was created before; otherwisewe create it using the new operator.\n\nSometimes we need to have only one instance of our class for example a single DB connection shared by multiple objects as creating a separate DB connection for every object may be costly. Similarly, there can be a single configuration manager or error manager in an application that handles all problems instead of creating multiple managers.\n\nLet’s see various design options for implementing such a class. If you have a good handle on static class variables and access modifiers this should not be a difficult task.\n\nHere we have declared getInstance() static so that we can call it without instantiating the class. The first time getInstance() is called it creates a new singleton object and after that, it just returns the same object.\n\nThis execution sequence creates two objects for the singleton. Therefore this classic implementation is not thread-safe.\n\nHere using synchronized makes sure that only one thread at a time can execute getInstance(). The main disadvantage of this method is that using synchronized every time while creating the singleton object is expensive and may decrease the performance of your program. However, if the performance of getInstance() is not critical for your application this method provides a clean and simple solution.\n\nHere we have created an instance of a singleton in a static initializer. JVM executes a static initializer when the class is loaded and hence this is guaranteed to be thread-safe. Use this method only when your singleton class is light and is used throughout the execution of your program.\n\nMethod 4 – Most Efficient || Use “Double Checked Locking” to implement singleton design pattern\n\nIf you notice carefully once an object is created synchronization is no longer useful because now obj will not be null and any sequence of operations will lead to consistent results. So we will only acquire the lock on the getInstance() once when the obj is null. This way we only synchronize the first way through, just what we want.\n\nWe have declared the obj volatile which ensures that multiple threads offer the obj variable correctly when it is being initialized to the Singleton instance. This method drastically reduces the overhead of calling the synchronized method every time.\n\nMethod 5 – Java Specific || Instantiation through inner class || Using class loading concept\n\nThis is one of the ways of implementing Singleton Design Pattern in java. It is specific to java language. Some concepts to understand before implementing singleton design by using this way in java:\n• None Classes are loaded only one time in memory by JDK.\n• None Inner classes in java are loaded in memory by JDK when it comes into scope of usage. It means that if we are not performing any action with inner class in our codebase, JDK will not load that inner class into memory. It is loaded only when this is being used somewhere.\n\nIn the above code, we are having a private static inner class SingletonInner and having private field. Through, getInstance() method of singleton class, we will access the field of inner class, and due to being inner class, it will be loaded only one time at the time of accessing the INSTANCE field first time. And the INSTANCE is a static member due to which it will be initialized only once.\n\nUse Cases for the Singleton Design Pattern\n\nBelow are some common situations where the Singleton Design Pattern is useful:\n• None In applications where creating and managing database connections is resource-heavy, using a Singleton ensures that there’s just one connection maintained throughout the application.\n• None When global settings need to be accessed by different parts of the application, a Singleton configuration manager provides a single point of access for these settings.\n• None Singleton helps to centralize control and making it easier to manage the state and actions of user interface components.\n• None Singleton can effectively organize print jobs and streamlines the process in the systems where document printing is required.\n\nBelow are the advantages of using the Singleton Design Pattern:\n• None The Singleton pattern guarantees that there’s only one instance with a unique identifier, which helps prevent naming issues.\n• None This pattern supports both eager initialization (creating the instance when the class is loaded) and lazy initialization (creating it when it’s first needed), providing adaptability based on the use case.\n• None When implemented correctly, a Singleton can be thread-safe, ensuring that multiple threads don’t accidentally create duplicate instances.\n• None By keeping just one instance, the Singleton pattern can help lower memory usage in applications where resources are limited.\n\nHere are some drawbacks of using the Singleton Design Pattern:\n• None Singletons can make unit testing difficult since they introduce a global state. This can complicate testing components that depend on a Singleton, as its state can influence the test results.\n• None In multi-threaded environments, the process of creating and initializing a Singleton can lead to race conditions if multiple threads try to create it simultaneously.\n• None If you later find that you need multiple instances or want to modify how instances are created, it can require significant code changes.\n• None The Singleton pattern creates a global dependency, which can complicate replacing the Singleton with a different implementation or using dependency injection.\n• None Subclassing a Singleton can be tricky since the constructor is usually private. This requires careful handling and may not fit standard inheritance practices."
    },
    {
        "link": "https://stackoverflow.com/questions/37928642/singleton-pattern-configuration-and-dependency-injection",
        "document": "I am currently porting a C library to Java. The C library connects to an external device and provides functions to configure the device and receive data. The core of my design is a class that encapsulates the connection to the device and provides the low-level C API mapping generated using JNA.\n\nSince most of the C library doesn't translate that well into the OO-World of Java (Single header library containing 100+ functions) i have a couple of \"Manager\" classes that provide access to most of the functionality.\n\nCreating more than one of these classes doesn't make sense, since the C library only manages one resource of everything (configuration, data-buffer, etc). So i want to implement the Singleton pattern for my Java classes (effectively also signaling the users of my new java library, that there is only ONE Manager object in the whole system).\n\nAdditionally i want to be able to configure these Manager classes using an external config file. I have never implemented a configuration utility before, so i don't really know where to put that.\n\nLastly ALL of my Manager classes need a reference to a object.\n\nSo i need a design that allows me to:"
    }
]