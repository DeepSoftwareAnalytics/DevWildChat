[
    {
        "link": "https://blog.postman.com/how-to-create-a-rest-api-with-node-js-and-express",
        "document": "How to create a REST API with Node.js and Express\n\nNode.js is an ideal choice for developers who are looking to create fast and efficient web applications with RESTful APIs. In fact, it is the most widely used web development tool in the United States. But what makes Node.js so powerful? Why should you learn to use Node.js for building REST APIs, and what is the best way to go about it?\n\nIn this post, we’ll explore the answers to these questions and more. By the end, you’ll be able to set up a server, define routes, handle requests and responses, and work with databases. You can also get some hands-on experience by coding along with us and building a user management API with endpoints for user registration, login, profile management, and more.\n\nUse the links below to navigate to the section that interests you most:\n• Why use Node.js to build your REST API?\n• How to set up a Node.js app?\n• How to create a user management API with Node.js and Express?\n\nRelated: What is an API?\n\nREST, which stands for REpresentational State Transfer, is a software development architecture that defines a set of rules for communication between a client and a server. Let’s break this down a little more:\n• A REST client is a code or app used to communicate with REST servers.\n• A server contains resources that the client wants to access or change.\n• A resource is any information that the API can return.\n\nA REST API, also known as a RESTful API, is an API that conforms to the REST architecture. These APIs use the HTTP protocol to access and manipulate data on the server.\n\nThe essential components of a REST API include the HTTP method, endpoint, headers, and body. Here’s an example of a REST API that gives you a list of astronauts who are currently in space.\n\nThe HTTP method defines the action the client wants to make on the server, which includes creating, reading, updating, or deleting resources (CRUD). Here are four HTTP methods that are commonly used in REST APIs:\n• GET: used to retrieve resources.\n\nNow that we’ve covered the fundamentals of RESTful APIs, let’s look at why and how you can build them with Node.js.\n\nBy definition, Node.js is an open-source and cross-platform JavaScript runtime environment that runs based on Chrome’s V8 engine.\n\nTo break this down a little further, you can:\n• \n• Execute your JavaScript program or application on the server instead of the browser using Node.js (runtime environment).\n\nWhy should you use Node.js and Express to build your REST API?\n\nHere are four key advantages of Node.js and Express:\n• The ability to use a single language (JavaScript) for both client-side and server-side development.\n• Fast and powerful performance, owing to the ability to run multiple requests in parallel.\n• Middleware and routing capabilities that are built into Express to make API development quick and easy.\n• A large, active community of developers contributing to the ecosystem.\n\nAs you develop the user management API, you’ll start seeing these benefits quickly. Let’s get started.\n\nTo follow along, you need to have the following:\n\nIf you don’t have a Postman account yet, you can sign up for free here.\n\nThe first thing we’ll need to do is install Node.js on our machine. You can download the latest LTS version from the official Node.js website. Follow the prompts in the Node.js Installer and customize the defaults, if necessary. When you’re done, you should have installed Node.js, as well as NPM (Node Package Manager). You can verify the installation by running the following commands in your terminal:\n\nIf you see the versions of Node.js and NPM show up, your installation was successful.\n\nNext, we’ll create a new folder for the project by running the following command in your terminal (note that entering this command as-is will name your project “node rest api,” but you can change the name, if you’d like):\n\nTo navigate to your project, enter this command:\n\nTo initialize your app, run the following command in your terminal:\n\nYou will be prompted to enter your project name, description, and GitHub repository. You can accept the defaults by pressing Enter/Return, or customize them.\n\nNext, open this project in your editor, where you will see a new file called . This file contains the data you added about your project in the terminal. It also describes how you’re going to run the project and lists its dependencies (frameworks and libraries).\n\nFrom here on, you can run all your commands in your editor’s terminal.\n\nRun the following command to install the Express framework:\n\nWe’ll start by creating a new file named in the root of the project directory. We’ll use this file to set up the app. Then, we’ll load the dependencies so we can use them. In the file, add the following code to import Express:\n\nNow, let’s set up Express to create an app and configure it to parse requests with JSON payloads. Here’s the code you can add to do that:\n\nNow we need to make this application a server by getting it to listen for connections. To do this, we’ll connect to a port to listen for incoming requests.\n\nIn the file, we’ll add the following code to define the server code:\n\nWith the variable, we set up the port automatically by allowing the API to be deployed to a cloud platform like AWS or Azure. In case the variable is not set, we’ll default to using port 3000.\n\nNext, we’ll add the following code to the file in order to set up the server to listen on the specified port:\n\nLet’s start by defining a status endpoint to ensure the API is working.\n\nExpress lets you define routes using the function. Here, METHOD refers to the different HTTP methods, like GET, POST, PUT, and DELETE. For a GET request, you’d define the route by adding an function. This function has two parameters. We’ll use the first parameter to define the path. In this case, it is the endpoint:\n\nNext, we’ll add a callback function as the second parameter, which defines what we will do when the request is called. This function has two parameters: the request object (which contains details like the HTTP method, headers, and request body) and the response object (which defines the information that we want to send). The response (res) object contains different methods of sending a response to the client, such as , , and .\n\nHere’s what it looks like now:\n\nWith , we then define the response we want to return. But since we want to send back JSON, we’ll need to first define a JSON object. So, we define a status variable and create an object:\n\nChallenge for you: Go to your Postman account and test the endpoint with the GET request method. You should get a response that says “Running,” as shown below:\n\nIf you receive the expected response, congratulations! You’ve just created your first API.\n\nSimilarly, you can use , , and to handle other request methods.\n\nNow, we’ll create the following API endpoints for user management:\n• GET : Retrieving a user’s profile (restricted to the user themselves)\n• PATCH : Updating a user’s profile (restricted to the user themselves)\n• GET : Retrieving all users (available to all users)\n\nWe’ll also look at how you can use JSON Web Tokens (JWTs) to set up authentication for certain endpoints.\n\nWe recommend trying out the user management API to understand what responses you can expect.\n\nTo get started, clone the companion repository that contains the entire code for the app and use this tutorial to understand the basics of how we go about creating the user management app.\n\nOnce you’ve cloned the repository, navigate to the project, where you’ll find the following folders:\n• authorization: contains everything related to the and endpoints.\n• common: contains middlewares and models used for all endpoints.\n• storage: stores all the data for the app locally.\n• users: contains everything related to all of the user endpoints.\n\nRun to install the following libraries that we will be using:\n• Sequelize: A Node.js ORM (object-relational mapper) tool that helps with connecting to a database.\n• SQLite3: A library that helps us to create a database, define tables, and manage a SQLite database file.\n• jsonwebtoken: An implementation of JSON Web Token (JWT), an open standard (RFC 7519), used to securely transmit information between parties as a JSON object.\n• AJV (Another JSON Schema Validator): A library that helps us validate the payload received against a structure defined using a JSON Schema.\n\nIn real-world apps, we use databases to store data more efficiently. Since this is only a simple project, we wanted to keep things easy. So, we will build the API with SQLite, define the structure of the data in , and store data in .\n\nWe’ll start by creating a new file called . Next, in the same file, we will define our schema, which holds all the properties of a user (such as , , and ).\n\nWe’ll also specify the data type—and whether the data can be left void—for every user property. For the user ID, we’ll use auto-increment to automatically create a unique number when a new record is inserted into the table:\n\nSimilarly, you can also define other properties, such as , , , , , and , in the schema.\n\nIn the same file, we will define an initialize method to register our schema with the Sequelize library and return a model. The returned model can then be used to manipulate (i.e., create, read, update, and delete) the data stored in the database.\n\nHere’s how you can define a function to create a user:\n\nYou can also define wrapper functions that consume the Sequelize library to get and update entries in the database, just like we did for .\n\nNow, we’re all set to define operations with the module. Let’s look at how to define the endpoint.\n\nWe’ll start by creating a file named , which will hold all the controller functions for the different routes related to the user module, like , , etc.\n\nRefer to the example below to understand how to set up the controller function. This function uses the function created in the file above to fetch all the users from the table and return them in the response:\n\nAt the top of the file, add the following code to import the router:\n\nNext, we will import the in the file and define the route as shown below:\n\nNext, we need to register the file in our file so that any calls made to the endpoints are routed to the correct file. To do that, we add the following code:\n\nIn this tutorial, we’ll implement authentication and authorization using JSON Web Tokens (JWT). JWT generates a valid token for the user and ensures that only authenticated users can access specific API endpoints.\n\nWhen the user provides the necessary payload while registering or logging in, we will provide a token in return. The token typically expires after a period of time. To keep things simple, we will only focus on creating a single token.\n\nNow we can define the endpoint. The payload needs to contain , , , , , , and . Here’s an example:\n\nWe will set up a controller to create a new user in the User table using helper functions defined in —and also generate a JWT that will be returned as the response. Additionally, before storing the user in the table, we will hash the password using the SHA246 algorithm for better security:\n\nThe function used in the code above uses the jsonwebtoken library to generate a JWT that can be returned back to the user.\n\nNow, we need to create the route and invoke the controller function that we just created. We can do that by adding the following code in :\n\nLikewise, you can also define the endpoint.\n\nWe also need to register the file in our file so that any calls made to the or endpoints are routed to the correct file. To do that, we add the following code:\n\nWe need to make sure that only authenticated users can securely access data in the Users resource.\n\nLet us define a middleware that checks if the user is using a valid JWT. To do this, we’ll add the following code in :\n\nHere, we’re checking for the presence of auth headers. If no auth headers are provided, we return a 401 unauthorized error. Likewise, we also add checks and return the same error when a bearer auth header is not provided, or when a bearer auth header is provided, but a token is not provided.\n\nIn , we’ll check for permissions and validate if the user:\n• exists in our database (to access the endpoint).\n• has the required role (to access the and endpoints).\n\nHere, we’ll check if a user is in our database, and return a 403 forbidden error if not:\n\nNow, we’ll add the authentication middleware to the user’s module routes in :\n\nWe can update the endpoint created to the code given below:\n\nThis way, the endpoint can only be accessed by a logged in user who has the role.\n\nIf you’ve tried this out on your own, congratulations on creating your first app using Node.js! You now have a solid foundation for building powerful and scalable APIs for your web applications.\n\nYou can continue building this app by adding or updating user properties, filtering the users by a particular property (with a query parameter), or connecting to another database like MongoDB etc or MySQL. You can also check out the product directory app added in the Products folder.\n\nIf you have any questions, suggestions, or feedback for us, feel free to drop them in the comments below. We’d love to hear from you!\n\nWhat database should I use with Node.js?\n\nIn this tutorial, we used SQLite to store the data in a file. SQLite is a great library that allows you to create a database, define tables, and manage a SQLite database file. It also helps you connect with a range of databases— including MongoDB, MySQL, and PostgreSQL—and run queries to manage data in the database. However, you can use any other database based on your requirements by installing the appropriate Node.js driver and modifying the controller functions to interact with the database.\n\nWhat is the best framework for building REST APIs in Node.js?\n\nWhile Feathers, Nest, LoopBack, and Moleculer are great frameworks for building REST APIs, here are a few reasons why Express is the best option:\n• It offers features like Model-View-Controller (MVC), robust routing capabilities, and built-in middleware to enable you to create dynamic, scalable applications.\n• It has a large Express community that can help you be faster and more efficient.\n• It is easy to set up, learn, and use, making it an ideal choice for beginners.\n\nThis blog was co-authored by Arvind Kalra, who also worked on the companion code repository."
    },
    {
        "link": "https://apidog.com/blog/how-to-create-a-rest-api-with-node-js-and-express",
        "document": "In today's interconnected world, building robust and scalable APIs has become a necessity for enabling seamless communication between diverse software components. REST APIs have emerged as the de facto standard for facilitating web data exchange, leveraging the HTTP protocol's power.\n\nNode.js, a JavaScript runtime built on Chrome's V8 engine, has gained traction for creating efficient, lightweight APIs. Its event-driven, non-blocking I/O model excels at handling concurrent connections, making it ideal for scalable, real-time APIs.\n\nFrameworks like Express.js simplify development, allowing developers to build robust APIs for diverse use cases quickly. For web developers seeking to create RESTful APIs, Node.js and Express offer a powerful combination to streamline the process.\n\nA REST API is an architectural style that leverages the HTTP protocol to facilitate data exchange between client and server applications. It is based on a set of constraints and principles, including a uniform interface, stateless communication, and the use of standard HTTP methods (GET, POST, PUT, DELETE) for performing operations on resources.\n\nResources are the fundamental units in REST. Each resource is identified by a URL (Uniform Resource Locator). For example, in a REST API for managing books, a book might be a resource accessible at .\n\nREST APIs use standard HTTP methods to interact with resources:\n• GET: Retrieve data from the server (e.g., get a list of books or a single book).\n• POST: Send data to the server to create a new resource (e.g., add a new book).\n• PUT: Update an existing resource with new data (e.g., update details of an existing book).\n\nEach request from a client to a server must contain all the information the server needs to fulfill that request. The server does not store any state about the client session between requests. This makes REST APIs scalable and easy to maintain.\n\nResources can be represented in different formats, such as JSON (JavaScript Object Notation), XML (eXtensible Markup Language), or plain text. JSON is the most commonly used format due to its lightweight nature and ease of use.\n\nREST APIs are designed to have a uniform interface that allows for consistent interaction with resources. This involves:\n• Manipulation of resources through representations: Clients use representations to interact with resources (e.g., sending JSON data to create or update a resource).\n• Self-descriptive messages: Each message includes enough information to describe how to process it.\n• Hypermedia as the engine of application state (HATEOAS): Clients interact with resources entirely through hyperlinks provided dynamically by the server.\n\nREST separates the client and server, allowing them to evolve independently. The client handles the user interface and user experience, while the server manages data storage, processing, and security.\n\nResponses from a REST API can be explicitly marked as cacheable or non-cacheable. This allows clients to cache responses to improve performance and reduce the need for repeated requests.\n\nHere is an example of Rest API endpoints for a library:\n\n1. Get a list of all books\n• Description: Retrieves a list of all books in the library.\n• Description: Retrieves details of a specific book by its ID.\n• Description: Adds a new book to the library.\n• Description: Updates the details of an existing book.\n\nNode.js, a server-side JavaScript runtime, and Express, a popular Node.js framework, make for a powerful combination to create RESTful APIs. In this blog post, we'll explore the process of creating a REST API using Node.js and Express, step by step, with practical examples.\n\nWhy Use Node.js and Express to Build Rest API?\n\nUsing Node.js and Express to create APIs offers several advantages that make it a popular choice among developers. Here are some of the key benefits:\n\nNode.js is built on the V8 JavaScript engine from Google, which compiles JavaScript directly to machine code. This results in high performance and speed. Node.js is also designed with an event-driven, non-blocking I/O model, which makes it highly efficient and scalable for handling numerous simultaneous connections.\n\nNode.js allows developers to use JavaScript for both client-side and server-side development. This consistency reduces the learning curve and simplifies the development process, as developers can use the same language and data structures across the entire application stack.\n\nNode.js, combined with Express, enables rapid development of applications. Express is a minimal and flexible framework that provides a robust set of features for web and mobile applications. It simplifies routing, middleware management, and view rendering, allowing developers to build APIs quickly and efficiently.\n\nNode.js has a rich ecosystem of libraries and modules available through npm (Node Package Manager). This vast collection of pre-built modules significantly speeds up development by allowing developers to reuse existing code for common tasks.\n\nNode.js and Express are well-suited for building JSON-based RESTful APIs. JavaScript’s native support for JSON simplifies data exchange between the server and the client. Express's lightweight nature makes it ideal for creating RESTful endpoints efficiently.\n\nNode.js excels in building real-time applications, such as chat applications or live-update features. Its non-blocking architecture allows for handling real-time data streaming and interactions seamlessly.\n\nNode.js has a large and active community. This vibrant community contributes to a wealth of open-source libraries, tools, and frameworks, ensuring that developers have access to the latest best practices, solutions to common problems, and ongoing improvements.\n\nNode.js is particularly well-suited for microservices architecture. Its lightweight nature allows developers to create small, independent services that can be deployed and scaled individually. This modularity leads to better maintainability and scalability of applications.\n\nNode.js is cross-platform, meaning it can run on various operating systems, including Windows, macOS, and Linux. This flexibility is beneficial for developing applications that need to operate in different environments.\n\n10. Ease of Learning and Use\n\nFor developers familiar with JavaScript, learning Node.js and Express is relatively straightforward. The simplicity and minimalism of Express make it easy to get started with building APIs without a steep learning curve.\n\nBefore we dive into building our REST API, make sure you have the following tools and knowledge:\n• Node.js and npm: Install Node.js, which includes npm (Node Package Manager), from the official website.\n• Text Editor or IDE: Choose your preferred code editor. Some popular choices are Visual Studio Code, Sublime Text, or WebStorm.\n• Basic JavaScript Knowledge: Understanding of JavaScript is crucial for Node.js development.\n\nLet's start by creating a new directory for your project and initializing it with npm.\n\nThis will create a file with default settings for your project.\n\nWe need a couple of packages to get our REST API up and running:\n• Nodemon (Optional): A tool that helps in automatically restarting the server during development.\n\nNow, let's create an Express application and set up a basic server.\n\nHere, we've created a basic Express app, added the body-parser middleware to parse JSON data, and started a server on port 3000.\n\nIn a REST API, routes define the endpoints for different HTTP methods (GET, POST, PUT, DELETE). Let's create a simple example with a GET request.\n\nThis code defines a route for that responds with a JSON message when accessed via a GET request.\n\nYou can run your API using Node.js, but during development, it's handy to use Nodemon, which will automatically restart your server on code changes.\n\nNow, if you access , you should see the \"Hello, World!\" message.\n\nTo make a useful API, you'll need to define more routes and implement CRUD (Create, Read, Update, Delete) operations for your resources. Here's an example of a simple \"To-Do List\" API。\n\nIn this example, we've added routes to list and create to-do items. You can extend this by implementing PUT and DELETE for updating and deleting tasks.\n\nTesting your API is crucial to ensure it works as expected. Tools like Apidog or Insomnia can help you send requests and verify the responses.\n\nWhen you're ready to share your API with the world, you can deploy it on platforms like Heroku, AWS, or Azure.\n\nAn alternative way to Create a REST API with Apidog\n\nApidog simplifies REST API development, streamlining testing, documentation, security, and performance. This article demonstrates how to use Apidog and its key features.\n\nFirst, you need to create an account on Apidog. This can be done by going to the Apidog website and clicking the \"Sign up\" button. After registration, you will be redirected to the Apidog homepage.\n\nWithin the project, you can create a new API. The documentation is the blueprint of the REST API, describing its resources, operations, and parameters. To create a new API, click the \"+\" button on the project page.\n\nFill in the HTTP methods, request/response models, query parameters, headers, etc.\n\nAfter all APIs have been developed, you can click the \"Send\" button to test your APIs.\n\nCreating a REST API with Node.js and Express is a powerful skill for any web developer. In this blog post, we covered the essential steps from project setup to defining routes, and even touched on testing and deployment. Remember, practice is key, so don't hesitate to build your own APIs, experiment with different functionalities, and explore more advanced features as you become more proficient with Node.js and Express.\n\nWith this foundation, you'll be well on your way to developing robust and scalable web applications with RESTful APIs. Happy coding!\n\n1. What is the best framework for Node.js REST API?\n\nWhile Feathers, Nest, LoopBack, and Moleculer are excellent frameworks, here are a few reasons why Express is the best option:\n\nFeature-Rich: Express offers features like Model-View-Controller (MVC) architecture, robust routing capabilities, and built-in middleware, enabling you to create dynamic, scalable applications.\n\nStrong Community Support: It has a large community that can help you work faster and more efficiently.\n\nUser-Friendly: Express is easy to set up, learn, and use, making it an ideal choice for beginners.\n\n2. Should l use Go or node for REST API？\n\nChoosing between Go (Golang) and Node.js for building a REST API depends on several factors including performance requirements, development speed, concurrency needs, and your team's expertise.\n\nWhen to Use Go:\n• You need high performance and efficiency.\n• You prefer a statically typed language for compile-time error checking and performance optimization.\n• You are building a microservices architecture where performance is critical.\n\nWhen to Use Node.js:\n• You need a fast development cycle and access to a large ecosystem of libraries and tools.\n• You want to use JavaScript across both the front-end and back-end.\n• You have a team already experienced with JavaScript.\n\n3. What is the best language to implement REST API?\n\nThe best language for implementing a REST API will depend on your specific project requirements, the expertise of your development team, and the existing technology stack in use.\n• For High Performance: Go or C# (ASP.NET Core).\n• For Existing Ecosystem and Community: JavaScript (Node.js) or PHP.\n• For Enterprise-Level Applications: Java or C#.\n\nNode.js itself is a runtime environment for executing JavaScript on the server side, and it doesn't \"use\" REST APIs in the sense of having built-in REST functionality. However, Node.js is widely used to create REST APIs, thanks to its asynchronous, event-driven architecture and the availability of frameworks like Express.js, which make it straightforward to build and manage RESTful web services.\n\n5. Do people still use Express?\n\nYes, people still use Express.js widely for developing REST APIs and web applications.\n\nNext.js and Express are two different tools that serve different purposes in the web development ecosystem, and one does not necessarily replace the other.\n\nYes, Node.js is very well-suited for API development, especially for building RESTful APIs.\n\n8. What is the best database for Node.JS API?\n\nThe \"best\" database for your Node.js API depends heavily on your specific project requirements and preferences. MongoDB is popular for its flexibility and ease of integration with Node.js, while PostgreSQL and MySQL are favored for their strong consistency and SQL capabilities. SQLite is ideal for embedded applications or simpler use cases. Assessing your application's needs and considering these factors will help you choose the most suitable database for your Node.js API."
    },
    {
        "link": "https://dev.to/anticoder03/building-restful-apis-with-nodejs-and-express-step-by-step-tutorial-2oc6",
        "document": "A RESTful API (Representational State Transfer) is a popular architectural style for building web services, where the client (frontend) interacts with the server (backend) using HTTP requests. RESTful APIs are lightweight, stateless, and scalable, making them ideal for modern applications.\n\nNode.js is a runtime environment that allows JavaScript to be run on the server side. Combined with Express, a minimal and flexible web application framework for Node.js, you can easily create powerful RESTful APIs.\n\nHere’s a step-by-step explanation of how to build a RESTful API with Node.js and Express:\n\nTo begin, make sure Node.js is installed on your system. You can download it from the official website. Once installed, initialize a new project:\n\n\n\nThis creates a basic file that keeps track of the project dependencies.\n\nNow, create a basic server using Express. In the root of your project, create a file called :\n\n\n\nVisit in your browser, and you should see \"Welcome to the REST API!\"\n\nLet’s build the core functionality of a RESTful API, focusing on CRUD operations (Create, Read, Update, Delete) for a sample resource, such as .\n\nThis endpoint will respond with a list of users in JSON format when the client sends a request to .\n\nThe in the route allows dynamic values, where the client can specify which user they want to retrieve by ID.\n\nThe method allows clients to send data (usually via JSON) to create new resources. Here, captures the data sent from the client, and a new user object is created and returned.\n\nThe method allows the client to update an existing resource. The server finds the user by ID and updates the name based on the client’s input.\n\nThe method removes a specific resource. In this case, it deletes a user based on the ID passed in the URL.\n\nTo persist data, you can integrate a database like MongoDB or MySQL. For example, to use MongoDB with Node.js, you would install the Mongoose library and connect your API to a database:\n\n\n\nThen, modify your code to use Mongoose for handling CRUD operations on a database rather than in-memory data:\n\n\n\nIt's important to handle errors properly in your API and return appropriate HTTP status codes:\n• when a resource does not exist\n\nYou can test the API using tools like Postman or curl by sending HTTP requests to the various endpoints.\n\nExample command for testing the endpoint:\n\n\n\nBuilding a RESTful API with Node.js and Express is relatively simple and efficient. By following these steps, you can set up routes, handle HTTP requests, and integrate with databases to create a full-fledged API. You can further enhance the API by adding features like authentication, validation, and logging to make it production-ready."
    },
    {
        "link": "https://medium.com/pipedrive-engineering/maintaining-rest-api-documentation-with-node-js-part-i-65e9700e3b30",
        "document": "Creating and maintaining APIs is no easy task — we create methods, test them, and then update them several times. Over this span of time, it’s easy to forget to update the documentation which thus makes it stale and irrelevant.\n\nAlso, many APIs are composed by an assortment of different services that have their own definition, methods, and paths. All of this combined makes the complexity of keeping a full set of documentation up-to-date extremely complex and difficult.\n\nIn this two-part series, we plan to detail how to maintain your API documentation and keep it up-to-date in Node. We will also introduce a new component recently created to assist you in this task. Throughout we’ll be using OpenAPI specification to maintain documentation in an easy way.\n\nYou can find part II of this article here: https://medium.com/pipedrive-engineering/maintaining-rest-api-documentation-with-node-js-part-ii-26d1a622d3fe\n\nTo achieve our goals we’ll use as a UI client and , a newly created Node component that allows us to declare our API schemas in Node.\n\nAs you will likely notice when getting into the code, the schemas are based on Joi types. Types.* are just wrappers to assist you, which means you can create a schema for your request parameters and use it in a validation middleware to keep your security in sync with your APIs with only minimal changes. To ensure these schemas don’t waste your time, they can also be used to validate and document your APIs.\n\nDevelopers tend to use Joi to validate data schemas in node, but Joi is more powerful than just that. This makes it a good match to use Joi to describe an API and also to harden it, combining both worlds — specially because there is no good options out there for this purpose. This allows us to keep our APIs documented and secure.\n\nThis article (and the next) will assume you have at least some knowledge in Node and Typescript (which the examples are written in).\n• Creating and setting up your REST server\n• Combining multiple OpenAPI schemas to keep your full API spec up to date\n\nWe hope we caught your attention by this point, so, let’s get started!"
    },
    {
        "link": "https://expressjs.com",
        "document": "Express is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications.\n\nWith a myriad of HTTP utility methods and middleware at your disposal, creating a robust API is quick and easy.\n\nExpress provides a thin layer of fundamental web application features, without obscuring Node.js features that you know and love.\n\nExpress is a lightweight and flexible routing framework with minimal core features meant to be augmented through the use of Express Express is a lightweight and flexible routing framework with minimal core features meant to be augmented through the use of Express middleware modules."
    },
    {
        "link": "https://medium.com/@schaman762/integrating-angular-with-rest-apis-a-comprehensive-guide-d3a889e560c7",
        "document": "Angular is a powerful front-end framework for building web applications, and one of its key strengths is its seamless integration with RESTful APIs. Consuming REST APIs allows Angular applications to interact with back-end services, enabling data exchange and dynamic functionality. This article provides a comprehensive guide on how to integrate Angular with RESTful services using Angular’s built-in , handling errors gracefully, and demonstrating real-world examples.\n\nREST (Representational State Transfer) is an architectural style used to design networked applications. RESTful APIs follow this style and allow communication between clients and servers using HTTP protocols. REST APIs are popular due to their simplicity, statelessness, and scalability, making them ideal for web applications.\n\nIn Angular, consuming REST APIs allows your application to perform CRUD (Create, Read, Update, Delete) operations, retrieve dynamic data, and communicate with the back-end for real-time updates.\n\nAngular provides a powerful service, which simplifies making HTTP requests to interact with REST APIs. To use , you need to set it up in your Angular project.\n\nTo start, you need to import the in your Angular application’s root module ( ):\n\nNext, create a service to manage HTTP requests. Services in Angular are used to encapsulate business logic and communicate with external data sources.\n\nThis creates an file where you can define your HTTP requests.\n\nIn this service, we define methods for basic CRUD operations that interact with a mock API ( ). These methods use to make GET, POST, PUT, and DELETE requests.\n\nOnce the service is set up, you can call these methods in your components to make API requests and handle the data.\n\nStep 3: Use the API Service in a Component\n\nNow, let’s use the in a component to fetch and display data. Inject the service in the component and subscribe to the observable returned by the methods.\n\nUse Angular’s templating syntax to display the fetched posts in your HTML template:\n\nHere, we display the list of posts if the API request is successful, or an error message if the request fails.\n\nWhen working with REST APIs, handling errors is critical to providing a smooth user experience. Angular’s allows you to handle errors using the operator from .\n\nIn this example, we use the operator to intercept errors and handle them by logging the error and returning a user-friendly message.\n\nLet’s extend our example by creating a form where users can submit a new post, which will be sent to the API.\n\nIn your component’s HTML file, create a form for submitting a new post:\n\nIn your component, add logic to handle the form submission and send the data to the API:\n\nIn this example, when the user submits the form, the method in the is called to send the data to the API. Upon success, the form is cleared, and on failure, an error message is displayed.\n\nInterceptors allow you to intercept and modify HTTP requests and responses globally. This is useful for adding authentication tokens, logging requests, or retrying failed requests.\n\nTo create an interceptor, generate a new service:\n\nAdd the interceptor to the array in :\n\nTo automatically retry failed requests, use the operator from :\n\nIntegrating Angular with REST APIs is a core feature of building dynamic and data-driven applications. Angular’s provides a straightforward and powerful way to interact with RESTful services, while error handling, interceptors, and retry mechanisms ensure robust communication. With the examples and strategies outlined in this guide, you’ll be well-equipped to build scalable, API-driven Angular applications."
    },
    {
        "link": "https://openliberty.io/guides/rest-client-angular.html",
        "document": "Angular is a framework for creating interactive web applications. Angular applications are written in HTML, CSS, and TypeScript, a variant of JavaScript. Angular helps you create responsive and intuitive applications that download once and run as a single web page. Consuming REST services with your Angular application allows you to request only the data and operations that you need, minimizing loading times. You will learn how to access a REST service and deserialize the returned JSON that contains a list of artists and their albums by using an Angular service and the Angular HTTP Client. You will then present this data using an Angular component. The REST service that provides the artists and albums resource was written for you in advance and responds with the . The Angular application was created and configured for you in the directory. It contains the default starter application. There are many files that make up an Angular application, but you only need to edit a few to consume the REST service and display its data. Angular applications must be compiled before they can be used. The Angular compilation step was configured as part of the Maven build. You can use the folder of this guide as a template for getting started with your own applications built on Angular and Open Liberty. You will implement an Angular client that consumes this JSON and displays its contents at the URL. To learn more about REST services and how you can write them, see Creating a RESTful web service.\n\nThe fastest way to work through this guide is to clone the Git repository and use the projects that are provided inside: The directory contains the starting project that you will build upon. The directory contains the finished project that you will build. Before you begin, make sure you have all the necessary prerequisites. The directory in the root of this guide contains the finished application. Give it a try before you proceed. To try out the application, first go to the directory and run the following Maven goal to build the application and deploy it to Open Liberty: After you see the following message, your Liberty instance is ready: The defaultServer server is ready to run a smarter planet. Then, point your browser to the web application root http://localhost:9080/app to see the following output: foo wrote 2 albums: Album titled album_one by foo contains 12 tracks Album tilted album_two by foo contains 15 tracks bar wrote 1 albums: Album titled foo walks into a bar by bar contains 12 tracks dj wrote 0 albums: After you are finished checking out the application, stop the Liberty instance by pressing in the command-line session where you ran Liberty. Alternatively, you can run the goal from the directory in another shell session:\n\nThe front end of your application uses Node.js to execute your Angular code. The Maven project is configured for you to install Node.js and produce the production files, which are copied to the web content of your application. Node.js is server-side JavaScript runtime that is used for developing networking applications. Its convenient package manager, npm, is used to execute the Angular scripts found in the file. To learn more about Node.js, see the official Node.js documentation. The is used to the dependencies listed in your file from the npm registry into a folder called . The folder is found in your directory. Then, the configuration the production files to the directory. The file is defined so that the production build is copied into the web content of your application.\n\nYour application needs a way to communicate with and retrieve resources from RESTful web services. In this case, the provided Angular application needs to communicate with the artists service to retrieve the artists JSON. While there are various ways to perform this task, Angular contains a built-in that you can use. Angular applications consist of modules, which are groups of classes that perform specific functions. The Angular framework provides its own modules for applications to use. One of these modules, the HTTP Client module, includes convenience classes that make it easier and quicker for you to consume a RESTful API from your application. You will create the module that organizes your application, which is called the root module. The root module includes the Angular HTTP Client module. { BrowserModule } from ; { NgModule } from ; { HttpClientModule } from ; { AppComponent } from ; NgModule({ : [ AppComponent ], : [ BrowserModule, HttpClientModule, ], : [], : [AppComponent] }) AppModule { } The imports the class into the file. By using the tag, you can declare a module and organize your dependencies within the Angular framework. The array is a declaration array that imports the so that you can use the HTTP Client module in your application.\n\nYou need to create the component that is used in the application to acquire and display data from the REST API. The component file contains two classes: the service, which handles data access, and the component itself, which handles the presentation of the data. Services are classes in Angular that are designed to share their functionality across entire applications. A good service performs only one function, and it performs this function well. In this case, the class requests artists data from the REST service. The file imports the class and the decorator. The class is defined. While it shares the file of the component class , it can also be defined in its own file. The class is annotated by so instances of it can be provided to other classes anywhere in the application. The class injects an instance of the class, which it uses to request data from the REST API. It contains the constant, which points to the API endpoint it requests data from. The URL does not contain a host name because the artists API endpoint is accessible from the same host as the Angular application. You can send requests to external APIs by specifying the full URL. Finally, it implements a method that makes the request and returns the result. To obtain the data for display on the page, the method tries to use the injected instance to perform a HTTP request to the constant. If successful, it returns the result. If an error occurs, it prints the error message to the console. The method uses a feature of JavaScript called , to make requests and receive responses without preventing the application from working while it waits. For the result of the method to be compatible with this feature, it must be converted to a Promise by invoking its method. APromise is how JavaScript represents the state of an asynchronous operation. If you want to learn more, check out promisejs.org for an introduction.\n\nDefining the component to consume the service Components are the basic building blocks of Angular application user interfaces. Components are made up of a TypeScript class annotated with the annotation and the HTML template file (specified by ) and CSS style files (specified by .) Update the class to use the artists service to fetch the artists data and save it so the component can display it. { Component, OnInit } from ; { HttpClient } from ; { Injectable } from ; Injectable() ArtistsService { constructor( http: HttpClient) { } ARTISTS_URL = ; async fetchArtists() { { const data: any = await .http.get(ArtistsService.ARTISTS_URL).toPromise(); data; } (error) { console.error( + error); } } } Component({ : , : , : [ ArtistsService ], : [ ] }) AppComponent OnInit { : any[] = []; constructor( artistsService: ArtistsService) { } ngOnInit() { .artistsService.fetchArtists().then(data => { .artists = data; }); } } Replace the entire class along with the annotation. Add to the list of imported classes at the top. The property on the annotation indicates that this component provides the to other classes in the application. implements , which is a special interface called a lifecycle hook. When Angular displays, updates, or removes a component, it calls a specific function, the lifecycle hook, on the component so the component can run code in response to this event. This component responds to the event via the method, which fetches and populates the component’s template with data when it is initialized for display. The file imports the interface from the package. is a class member of type that starts out as an empty array. It holds the artists retrieved from the service so the template can display them. An instance of the class is injected into the constructor and is accessible by any function that is defined in the class. The function uses the instance to request the artists data. The method is an function so it returns a Promise. To retrieve the data from the request, calls the method on the Promise which takes in the data and stores it to the class member.\n\nNow that you have a service to fetch the data and a component to store it in, you will create a template to specify how the data will be displayed on the page. When you visit the page in the browser, the component populates the template to display the artists data with formatting. The template contains a element that is enumerated by using the directive. The variable is bound to the member of the component. The element itself and all elements contained within it are repeated for each artist, and the and placeholders are populated with the information from each artist. The same strategy is used to display each by each artist.\n\nThe Open Liberty instance is already started, and the REST service is running. In a new command-line session, build the front end by running the following command in the directory: The build might take a few minutes to complete. You can rebuild the front end at any time with the Maven goal. Any local changes to your TypeScript or HTML are picked up when you build the front end. Point your browser to the http://localhost:9080/app web application root to see the following output: foo wrote 2 albums: Album titled album_one by foo contains 12 tracks Album tilted album_two by foo contains 15 tracks bar wrote 1 albums: Album titled foo walks into a bar by bar contains 12 tracks dj wrote 0 albums: If you use the command to access the web application root URL, you see only the application root page in HTML. The Angular framework uses JavaScript to render the HTML to display the application data. A web browser runs JavaScript, and the command doesn’t."
    },
    {
        "link": "https://angular.dev/api",
        "document": ""
    },
    {
        "link": "https://v17.angular.io/tutorial/tour-of-heroes/toh-pt6",
        "document": ""
    },
    {
        "link": "https://digitor.in/angular-and-restful-api-integration-a-developers-guide",
        "document": "In modern web development, integrating RESTful APIs with Angular is a common practice for building dynamic, data-driven applications. REST (Representational State Transfer) APIs are widely used to enable communication between a front-end application and a back-end server. Angular, with its powerful HTTP client module, makes it incredibly easy for developers to interact with RESTful APIs and handle asynchronous data effectively.\n\nThis guide will walk you through the process of Angular and RESTful API integration, explaining the essential steps, best practices, and tools that will help you create seamless, efficient, and scalable web applications.\n\nA RESTful API is an interface that allows applications to communicate with each other over HTTP. It follows a set of principles for data exchange and operations using standard HTTP methods such as GET, POST, PUT, DELETE, and PATCH. These APIs typically return data in JSON format, which Angular can easily process and display in the application.\n\nFor developers, RESTful APIs are a powerful way to separate the concerns of the client and server, enabling the creation of scalable, modular, and maintainable applications.\n\nSetting Up Angular to Integrate with RESTful APIs\n\nTo make HTTP requests in Angular, you first need to import and configure the in your Angular application. This module provides the necessary tools for making HTTP calls and processing API responses.\n\nTo set up the HTTP client in your Angular app, follow these steps:\n• Add to the array in your module.\n\nHere’s how you can do it:\n\nOnce the is set up, the next step is to create an Angular service that will handle all HTTP operations. This service will be responsible for making API calls to your backend and processing the responses.\n\nTo generate the service, you can use the Angular CLI:\n\nIn the service, you’ll define methods to make HTTP requests (GET, POST, PUT, DELETE). Here’s an example of a simple service for fetching data from a RESTful API:\n\nThis service is now ready to interact with the RESTful API using Angular’s HTTP client. The method makes a GET request, while makes a POST request to send data to the server.\n\n3. Using the Service in Components\n\nTo use the API service in your components, simply inject the service into the component and call its methods. Here’s an example of how to fetch and display data from the API in a component:\n\nIn the template ( ), you can loop through and display the data:\n\nThis approach ensures that the component interacts with the service to retrieve the data, while the service itself handles the actual HTTP request.\n\nWhen dealing with API calls, it’s essential to handle both the successful response and any errors that may arise. Angular provides several ways to manage these situations.\n\nUse Angular’s operators to handle the response data. You can use operators like , , and to modify or process the data before passing it to your component.\n\nHandling errors is crucial for providing a good user experience. You can use to catch errors and display user-friendly messages.\n\nBest Practices for Integrating RESTful APIs with Angular\n\nAngular’s HTTP client returns Observables, which allow you to manage asynchronous operations efficiently. Use RxJS operators to process the response and handle errors effectively.\n\nTo avoid unnecessary API requests and improve performance, consider implementing caching mechanisms for data that doesn’t change frequently. Use RxJS operators like to cache API responses.\n\nAlways ensure that your API endpoints are secure by implementing authentication (JWT, OAuth) and validation mechanisms. Avoid exposing sensitive data in API responses.\n\nInstead of hardcoding API URLs, store them in configuration files or environment variables, making it easier to manage different environments (development, production).\n\nIntegrating RESTful APIs with Angular enables developers to create highly dynamic, data-driven web applications. With Angular’s powerful HttpClientModule and RxJS operators, developers can efficiently handle API requests, responses, and errors, ensuring a smooth user experience.\n\nBy following best practices, you can ensure that your Angular application is scalable, maintainable, and capable of handling complex data interactions with APIs. Whether you’re building a small app or a large enterprise solution, understanding how to integrate RESTful APIs with Angular is an essential skill for modern web development.\n\nReady to enhance your web app with Angular and RESTful API integration? Contact us to discuss how we can help you bring your project to life.\n\nExplore more related articles to deepen your understanding and make informed choices about graphic design techniques"
    }
]