[
    {
        "link": "https://stackoverflow.com/questions/38699899/how-to-handle-exceptions-in-console-app",
        "document": "I have a console app that interacts with hardware. My idea was to log all exceptions with their stacktraces so valuable information is not lost due to not having a pipe to a file.\n\nBut how to handle the location of that file? I cant ask for a path each time.\n\nThat is why i thought just put the file next to the executable. But cant be sure where the app will reside. And I have not found a distinct answer to \"how to get the app path\"\n\nI found: But no explanation how this works.\n\nAnd: But the op said this only may work. Is there another way to handle the errorlogging / a sure way to get the app path?"
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/455701/the-best-way-to-handle-exceptions",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/32545270/best-practice-for-java-exception-handling",
        "document": "First of all the problem with \"best practice\" advice is that it tends to over-simplify the question and the answer. Then someone (like yourself) comes along and notices that it is contradictory1.\n\nIMO, best practice is to take \"best practice\" advice and people who regularly use that phrase with a healthy level of suspicion. Try to understand the real issues yourself, and reach your own conclusions ... rather than just relying someone else to tell you what is \"best practice\".\n\n1 - Or worse ... they don't notice the contradictions, edge-cases, etc, and blindly follow the so-called \"best practice\". And occasionally, they find themselves in a dark place, because the \"best practice\" recommendation was inappropriate.\n\nSo what's the problem here? It is this statement:\n\nIn fact, it is not normally good coding practice to catch generic exceptions like . But it is the right thing to do in some circumstances. And your example is one where it is appropriate.\n\nWell lets look a case where catching is a bad idea:\n\nWhy is that a bad idea? Because that is going to catch and handle unexpected exceptions; i.e. exceptions that you (the developer) did not think were possible, or that you did not even consider. That's OK ... but then the code logs the exception, and continues running as if nothing happened.\n\nThat's the real problem ... attempting to recover from an unexpected exception.\n\nThe (so-called) \"best practice\" advice to \"never catch generic exceptions\" deals with the issue, but in a crude way that doesn't deal with the edge cases. One of the edge cases is that catching (and logging) a generic exception is OK if you then immediately shut the application down ... like you are doing.\n\nNow contrast that with the (supposedly) good practice version in your question. What is the difference?\n• Your version produces more user friendly / less alarming diagnostics ... up to a point.\n• Your version is significantly more code.\n• Your version is unhelpful to someone trying to diagnose the problem because the stacktraces are not recorded.\n\nAnd the counterpoints to 1 and 2 are:\n• You can spend limitless time honing the \"user friendly\" diagnostics for an application, and still fail to help the kind of user who can't or won't understand ...\n• It also depends on who the typical user is.\n\nAs you can see, this is far more nuanced than \"catching generic exceptions is bad practice\"."
    },
    {
        "link": "https://medium.com/@charleslively/java-coding-best-practices-for-effective-exception-handling-e8f9181d7436",
        "document": "Java is an incredibly powerful and complex programming language that is used extensively in full-stack development. Exception handling is an essential part of Java development, as it allows developers to create robust and reliable applications that can handle unexpected errors and situations gracefully. This ensures that the program behaves as expected and does not crash, making it an invaluable tool for developers. With exception handling, developers can create applications that are reliable and resilient, allowing them to create software solutions that are tailored to their needs.\n\nBy using exception handling, developers can anticipate and handle errors gracefully, rather than having the program crash or behave unpredictably. Exception handling also allows developers to provide useful feedback to users about what went wrong and how to fix it. By using exceptions, developers can make their programs more reliable and robust.\n\nExceptions are an important part of programming in Java and are used to handle errors that occur during the execution of a program. Exceptions can occur for a variety of reasons, such as invalid input data, network issues, hardware failures, and more.\n\nProperly handling exceptions can help to prevent these issues from crashing the program, as well as provide a way for developers to log errors for debugging and communicate them to users in a meaningful way. In this article, we will discuss the concept of exceptions in Java, their importance in writing reliable and error-free code, and best practices for handling them effectively. By understanding exceptions and how to handle them properly, developers can create robust and reliable programs that are less prone to errors.\n\nII. What are Exceptions in Java?\n\nIn Java, an exception is an event that occurs during the execution of a program that disrupts the normal flow of the program’s instructions. Exceptions in Java are thrown using the throw keyword, and they can be caught and handled using the try-catch block.\n\nThe hierarchy of exceptions in Java starts with the Object class and extends to the Throwable class. The Throwable class has two subclasses: Exception and Error. The Exception class is further divided into Checked and Unchecked Exceptions, which are used to distinguish between exceptions that can be anticipated and those that are generally caused by programming errors. By understanding this hierarchy of exceptions, developers can better understand how to handle errors and create more reliable and robust Java programs.\n\nFor example, if an exception is thrown, the program will stop executing and look for an appropriate exception handler to handle the exception. This exception handler can take various forms, such as displaying an error message to the user or logging the exception for debugging purposes. By using the try-catch block, developers can ensure that their program will continue to run smoothly even if an exception is thrown. The ExampleException class demonstrates how an exception can be implemented for a common problem, division by zero.\n\nIn this example, the method throws an if the second argument is 0. In the method, we call the method with the arguments 10 and 0, which causes an exception to be thrown. The block catches the exception and prints a message to the console.\n\nJava has three types of exceptions: Checked Exceptions, Unchecked Exceptions, and Errors.\n\nChecked exceptions are exceptions that are checked by the compiler at compile-time. The compiler checks if a method that can throw a checked exception is either caught or declared by the method. If it is not, the compiler will throw a compilation error. This means that any code that calls a method that can throw a checked exception must either handle the exception or declare it in the method signature. These types of exceptions can be caught and handled using a try-catch block or can be declared in the method signature using the throws keyword.\n\nOne example of a checked exception is the IOException. This exception is thrown when an input/output operation fails, such as when a file cannot be read or written. Programmers must handle this exception in order to prevent their application from crashing when it encounters this type of error. The example below illustrates how to utilize a IOException:\n\nAnother common checked exception in Java is the SQLException. This exception is thrown when an error occurs while accessing a database. This can happen for a variety of reasons, such as when the database is down, the login credentials are incorrect, or the database schema has been changed. Programmers must handle this exception in order to ensure that their application can handle database errors gracefully. The example below illustrates how to utilize a SQLException:\n\nThe ClassNotFoundException is another type of checked exception that can be thrown in Java. This exception is thrown when an application tries to load a class but the class cannot be found. This can occur when the class is not on the classpath or has been removed from the application. Programmers must handle this exception in order to ensure that their application can continue running even if a required class is not available. The example below illustrates how to utilize a ClassNotFoundException:\n\nFinally, the ParseException is a checked exception that is thrown when an error occurs while parsing a string into a date, number, or other format. This can happen when the string is in the wrong format or contains invalid characters. Programmers must handle this exception in order to ensure that their application can gracefully handle user input errors related to date and number formats. The example below illustrates how to utilize a ParseException:\n\nIn summary, there are several types of checked exceptions in Java, including the IOException, SQLException, ClassNotFoundException, and ParseException.\n\nUnchecked exceptions are exceptions that are not checked by the compiler at compile-time. Unchecked exceptions are usually caused by programming errors such as null pointer exceptions, array index out-of-bounds exceptions, and class cast exceptions.\n\nUnchecked exceptions are also called runtime exceptions and can be handled using a try-catch block or can be allowed to propagate up the call stack. ArithmeticException, ArrayIndexOutOfBoundsException, and NullPointerException.\n\nUnchecked exceptions are a type of exception in Java that are not checked by the compiler at compile-time. These types of exceptions are usually caused by programming errors and can lead to unexpected results. Common unchecked exceptions in Java include ArithmeticException, ArrayIndexOutOfBoundsException, and NullPointerException. For instance, attempting to access a null object, dividing by zero, or accessing an out-of-bounds array index can all lead to unchecked exceptions. To avoid these types of errors, it is important to thoroughly test code for any potential issues before running it. Keep in mind the following when dealing with unchecked exceptions:\n• NullPointerException: This exception occurs when a program tries to access a null object. For example, if a program tries to call a method on a null object, a NullPointerException will be thrown.\n• ArithmeticException: This exception occurs when a program attempts to divide by zero or perform some other illegal arithmetic operation. For example, if a program tries to divide a number by zero, an ArithmeticException will be thrown.\n• ArrayIndexOutOfBoundsException: This exception occurs when a program tries to access an array element that is out of bounds. For example, if a program tries to access the 10th element of an array that only has 5 elements, an ArrayIndexOutOfBoundsException will be thrown.\n\nAdditionally, you can also have errors in Java. Errors are exceptions that occur during the execution of the Java Virtual Machine (JVM) or the operating system. Errors are not exceptions in the conventional sense and are usually caused by issues such as out-of-memory errors or stack overflow errors. Errors are generally considered fatal and cannot be handled by the program.\n\nV. Best Practices for Handling Exceptions in Java\n\nWhen it comes to handling exceptions in Java, there are several tips and best practices that can help to ensure that your code is reliable and error-free. It is important to ensure that all exceptions are handled properly and that the code is tested thoroughly. It is also important to use the appropriate exception classes and to create custom exceptions when needed. Additionally, it is beneficial to use the try-catch blocks to handle exceptions and to use logging to track errors. By following these tips and best practices, developers can ensure that their code is reliable and error-free. Specifically, you want to be sure to follow these recommendations:\n• Handle exceptions at the appropriate level: It’s important to handle exceptions at the appropriate level in your code. For example, if you are working with a database, you should catch database-related exceptions at the database layer, rather than letting them propagate up to the application layer.\n• Use specific exception types: Use specific exception types rather than catching general exception types. This will make it easier to handle specific types of exceptions and provide more informative error messages to the user.\n• Provide informative error messages: When handling exceptions, it’s important to provide informative error messages that explain what went wrong and how the user can resolve the issue.\n• Don’t ignore exceptions: Never ignore exceptions or catch them without handling them. Ignoring exceptions can lead to unexpected behavior and make it difficult to identify the root cause of problems.\n• Use finally blocks: Use blocks to ensure that resources are properly released, even if an exception is thrown.\n\nAs a software developer, making use of exceptions in any language is important to ensure a cohesive and accurate software experience for users. Specifically, proper exception handling is critical to ensuring that code is reliable, error-free, and secure. By following the best practices and handling exceptions at the appropriate level, developers can prevent bugs and improve the overall quality of their code. Exception handling also allows developers to provide useful feedback to users about what went wrong and how to fix it, making the program more reliable and resilient."
    },
    {
        "link": "https://geeksforgeeks.org/exceptions-in-java",
        "document": "Exception handling in Java allows developers to manage runtime errors effectively by using mechanisms like try-catch block, finally block, throwing Exceptions, Custom Exception handling, etc.\n\nAn Exception is an unwanted or unexpected event that occurs during the execution of a program (i.e., at runtime) and disrupts the normal flow of the program’s instructions. It occurs when something unexpected things happen, like accessing an invalid index, dividing by zero, or trying to open a file that does not exist.\n\nException in Java is an error condition that occurs when something wrong happens during the program execution.\n\nExample: Showing an Arithmetic Exception or you can say divide by zero exception.\n\nException handling in Java is an effective mechanism for managing runtime errors to ensure the application’s regular flow is maintained. Some Common examples of exceptions include ClassNotFoundException, IOException, SQLException, RemoteException, etc. By handling these exceptions, Java enables developers to create robust and fault-tolerant applications.\n\nExample: The below Java program modifies the previous example to handle an ArithmeticException using try-catch, and finally blocks and keep the program running.\n\nThe summary is depicted via visual aid below as follows:\n\nAll exception and error types are subclasses of the class Throwable, which is the base class of the hierarchy. One branch is headed by Exception. This class is used for exceptional conditions that user programs should catch. NullPointerException is an example of such an exception. Another branch, Error is used by the Java run-time system(JVM) to indicate errors having to do with the run-time environment itself(JRE). StackOverflowError is an example of such an error.\n\nThe below figure demonstrates the exception hierarchy in Java:\n\nExceptions can occur due several reasons, such as:\n\nErrors represent irrecoverable conditions such as Java virtual machine (JVM) running out of memory, memory leaks, stack overflow errors, library incompatibility, infinite recursion, etc. Errors are usually beyond the control of the programmer, and we should not try to handle errors.\n\nTo know more differences about Exception and Errors, refer to this article: Exception vs Errors in Java.\n\nJava defines several types of exceptions that relate to its various class libraries. Java also allows users to define their own exceptions.\n\nExceptions can be categorized in two ways:\n\nBuild-in Exception are pre-defined exception classes provided by Java to handle common errors during program execution.\n\nChecked exceptions are called compile-time exceptions because these exceptions are checked at compile-time by the compiler. Examples of Checked Exception are listed below:\n• ClassNotFoundException: Throws when the program tries to load a class at runtime but the class is not found because its not present in the correct location or it is missing from the project.\n• InterruptedException: Thrown when a thread is paused and another thread interrupts it.\n• InstantiationException: Thrown when the program tries to create an object of a class but fails because the class is abstract, an interface, or has no default constructor.\n• SQLException: Throws when there’s an error with the database.\n• FileNotFoundException: Thrown when the program tries to open a file that doesn’t exist\n\nThe unchecked exceptions are just opposite to the checked exceptions. The compiler will not check these exceptions at compile time. In simple words, if a program throws an unchecked exception, and even if we didn’t handle or declare it, the program would not give a compilation error. Examples of Unchecked Exception are listed below:\n• ArithmeticException: It is thrown when there’s an illegal math operation.\n• ClassCastException: It is thrown when you try to cast an object to a class it does not belongs to.\n• NullPointerException: It is thrown when you try to use a null object (e.g. accessing its methods or fields)\n• ArrayIndexOutOfBoundsException: It occurs when we try to access an array element with an invalid index.\n• ArrayStoreException: h appens when you store an object of the wrong type in an array.\n• IllegalThreadStateException: It is thrown when a thread operation is not allowed in its current state\n\nSometimes, the built-in exceptions in Java are not able to describe a certain situation. In such cases, users can also create exceptions, which are called “user-defined Exceptions“.\n\nA try-catch block in Java is a mechanism to handle exception. The try block contains code that might thrown an exception and the catch block is used to handles the exceptions if it occurs.\n\nThe finally Block is used to execute important code regardless of whether an exception occurs or not.\n\nNote: finally block is always executes after the try-catch block. It is also used for resource cleanup.\n\nWe can handle multiple type of exceptions in Java by using multiple catch blocks, each catching a different type of exception.\n\nHow Does JVM Handle an Exception?\n\nDefault Exception Handling: When an Exception occurs, the JVM Creates an exception object containing the error name, description, and program state. Creating the Exception Object and handling it in the run-time system is called throwing an Exception. There might be a list of the methods that had been called to get to the method where an exception occurred. This ordered list of methods is called Call Stack. Now the following procedure will happen.\n• None The run-time system searches the call stack for an Exception handler\n• None It starts searching from the method where the exception occurred and proceeds backward through the call stack.\n• None If a handler is found, the exception is passed to it.\n• None If no handler is found, the default exception handler terminates the program and prints the stack trace.\n\nLook at the below diagram to understand the flow of the call stack.\n\nLet us see an example that illustrates how a run-time system searches for appropriate exception handling code on the call stack.\n\nCustomized Exception Handling: Java exception handling uses five keywords: try, catch, throw and throws, and finally. Code that might cause an exception goes in the try block. If an exception occurs, it is caught using catch. We can throw exceptions manually with throw, and methods must declare exceptions they can throw using throws. The finally block is used for code that must run after try, whether an exception occurs or not.\n\nConsider the below program in order to get a better understanding of the try-catch clause.\n\nExplanation: In the above example, an array is defined with size i.e. we can access elements only from index 0 to 3. But we trying to access the elements at index 4 (by mistake) that is why it is throwing an exception. In this case, JVM terminates the program abnormally. The statement System.out.println(“Hi, I want to execute”); will never execute. To execute it, we must handle the exception using try-catch. Hence to continue the normal flow of the program, we need a try-catch clause."
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Scanner.html",
        "document": "\n• If this scanner has not yet been closed then if its underlying readable also implements the interface then the readable's method will be invoked. If this scanner is already closed then invoking this method will have no effect. Attempting to perform search operations after a scanner has been closed will result in an .\n• Returns the last thrown by this 's underlying . This method returns if no such exception exists. the last exception thrown by this scanner's readable\n• Returns the this is currently using to match delimiters.\n• Sets this scanner's delimiting pattern to the specified pattern.\n• . Sets this scanner's delimiting pattern to a pattern constructed from the specified An invocation of this method of the form behaves in exactly the same way as the invocation . Invoking the method will set the scanner's delimiter to the default.\n• A scanner's locale affects many elements of its default primitive matching regular expressions; see localized numbers above.\n• Sets this scanner's locale to the specified locale. A scanner's locale affects many elements of its default primitive matching regular expressions; see localized numbers above. Invoking the method will set the scanner's locale to the initial locale. - A string specifying the locale to use\n• A scanner's radix affects elements of its default number matching regular expressions; see localized numbers above. the default radix of this scanner\n• Sets this scanner's default radix to the specified radix. A scanner's radix affects elements of its default number matching regular expressions; see localized numbers above. If the radix is less than or greater than , then an is thrown. Invoking the method will set the scanner's radix to . - The radix to use when scanning numbers - if radix is out of range\n• if no match has been performed, or if the last match was not successful. Returns the match result of the last scanning operation performed by this scanner. This method throwsif no match has been performed, or if the last match was not successful. The various methods of make a match result available if they complete without throwing an exception. For instance, after an invocation of the method that returned an int, this method returns a for the search of the Integer regular expression defined above. Similarly the , , and methods will make a match available if they succeed. a match result for the last match operation - If no match result is available\n• Returns the string representation of this . The string representation of a contains information that may be useful for debugging. The exact format is unspecified. The string representation of this scanner\n• Returns true if this scanner has another token in its input. This method may block while waiting for input to scan. The scanner does not advance past any input. true if and only if this scanner has another token - if this scanner is closed\n• . Finds and returns the next complete token from this scanner. A complete token is preceded and followed by input that matches the delimiter pattern. This method may block while waiting for input to scan, even if a previous invocation of returned - if no more tokens are available - if this scanner is closed\n• The remove operation is not supported by this implementation of . - if this method is invoked.\n• Returns true if the next token matches the pattern constructed from the specified string. The scanner does not advance past any input. An invocation of this method of the form behaves in exactly the same way as the invocation . - a string specifying the pattern to scan true if and only if this scanner has another token matching the specified pattern - if this scanner is closed\n• Returns the next token if it matches the pattern constructed from the specified string. If the match is successful, the scanner advances past the input that matched the pattern. An invocation of this method of the form behaves in exactly the same way as the invocation . - a string specifying the pattern to scan - if no such tokens are available - if this scanner is closed\n• Returns true if the next complete token matches the specified pattern. A complete token is prefixed and postfixed by input that matches the delimiter pattern. This method may block while waiting for input. The scanner does not advance past any input. - the pattern to scan for true if and only if this scanner has another token matching the specified pattern - if this scanner is closed\n• . If the match is successful, the scanner advances past the input that matched the pattern. Returns the next token if it matches the specified pattern. This method may block while waiting for input to scan, even if a previous invocation of returned. If the match is successful, the scanner advances past the input that matched the pattern. - the pattern to scan for - if no more tokens are available - if this scanner is closed\n• Returns true if there is another line in the input of this scanner. This method may block while waiting for input. The scanner does not advance past any input. true if and only if this scanner has another line of input - if this scanner is closed\n• Advances this scanner past the current line and returns the input that was skipped. This method returns the rest of the current line, excluding any line separator at the end. The position is set to the beginning of the next line. Since this method continues to search through the input looking for a line separator, it may buffer all of the input searching for the line to skip if no line separators are present. the line that was skipped - if no line was found - if this scanner is closed\n• Attempts to find the next occurrence of a pattern constructed from the specified string, ignoring delimiters. An invocation of this method of the form behaves in exactly the same way as the invocation . - a string specifying the pattern to search for the text that matched the specified pattern - if this scanner is closed\n• is returned and the scanner's position is unchanged. This method may block waiting for input that matches the pattern. Attempts to find the next occurrence of the specified pattern ignoring delimiters. If the pattern is found before the next line separator, the scanner advances past the input that matched and returns the string that matched the pattern. If no such pattern is detected in the input up to the next line separator, thenis returned and the scanner's position is unchanged. This method may block waiting for input that matches the pattern. Since this method continues to search through the input looking for the specified pattern, it may buffer all of the input searching for the desired token if no line separators are present. - the pattern to scan for the text that matched the specified pattern - if this scanner is closed\n• Attempts to find the next occurrence of a pattern constructed from the specified string, ignoring delimiters. An invocation of this method of the form behaves in exactly the same way as the invocation . - a string specifying the pattern to search for the text that matched the specified pattern - if this scanner is closed\n• Attempts to find the next occurrence of the specified pattern. This method searches through the input up to the specified search horizon, ignoring delimiters. If the pattern is found the scanner advances past the input that matched and returns the string that matched the pattern. If no such pattern is detected then the null is returned and the scanner's position remains unchanged. This method may block waiting for input that matches the pattern. A scanner will never search more than code points beyond its current position. Note that a match may be clipped by the horizon; that is, an arbitrary match result may have been different if the horizon had been larger. The scanner treats the horizon as a transparent, non-anchoring bound (see and ). If horizon is , then the horizon is ignored and this method continues to search through the input looking for the specified pattern without bound. In this case it may buffer all of the input searching for the pattern. If horizon is negative, then an IllegalArgumentException is thrown. - the pattern to scan for the text that matched the specified pattern - if this scanner is closed\n• Skips input that matches the specified pattern, ignoring delimiters. This method will skip input if an anchored match of the specified pattern succeeds. If a match to the specified pattern is not found at the current position, then no input is skipped and a is thrown. Since this method seeks to match the specified pattern starting at the scanner's current position, patterns that can match a lot of input (\".*\", for example) may cause the scanner to buffer a large amount of input. Note that it is possible to skip something without risking a by using a pattern that can match nothing, e.g., . - a string specifying the pattern to skip over - if the specified pattern is not found - if this scanner is closed\n• Skips input that matches a pattern constructed from the specified string. An invocation of this method of the form behaves in exactly the same way as the invocation . - a string specifying the pattern to skip over - if this scanner is closed\n• Returns true if the next token in this scanner's input can be interpreted as a boolean value using a case insensitive pattern created from the string \"true|false\". The scanner does not advance past the input that matched. true if and only if this scanner's next token is a valid boolean value - if this scanner is closed\n• Scans the next token of the input into a boolean value and returns that value. This method will throw if the next token cannot be translated into a valid boolean value. If the match is successful, the scanner advances past the input that matched. the boolean scanned from the input - if the next token is not a valid boolean - if this scanner is closed\n• Returns true if the next token in this scanner's input can be interpreted as a byte value in the default radix using the method. The scanner does not advance past any input. true if and only if this scanner's next token is a valid byte value - if this scanner is closed\n• Returns true if the next token in this scanner's input can be interpreted as a byte value in the specified radix using the method. The scanner does not advance past any input. If the radix is less than or greater than , then an is thrown. - the radix used to interpret the token as a byte value true if and only if this scanner's next token is a valid byte value - if this scanner is closed - if the radix is out of range\n• . Scans the next token of the input as a An invocation of this method of the form behaves in exactly the same way as the invocation , where is the default radix of this scanner. the scanned from the input - if the next token does not match the Integer regular expression, or is out of range - if this scanner is closed\n• . This method will throw if the next token cannot be translated into a valid byte value as described below. If the translation is successful, the scanner advances past the input that matched. Scans the next token of the input as a. This method will throwif the next token cannot be translated into a valid byte value as described below. If the translation is successful, the scanner advances past the input that matched. If the next token matches the Integer regular expression defined above then the token is converted into a value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via , prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to with the specified radix. If the radix is less than or greater than , then an is thrown. - the radix used to interpret the token as a byte value the scanned from the input - if the next token does not match the Integer regular expression, or is out of range - if this scanner is closed - if the radix is out of range\n• Returns true if the next token in this scanner's input can be interpreted as a short value in the default radix using the method. The scanner does not advance past any input. true if and only if this scanner's next token is a valid short value in the default radix - if this scanner is closed\n• Returns true if the next token in this scanner's input can be interpreted as a short value in the specified radix using the method. The scanner does not advance past any input. If the radix is less than or greater than , then an is thrown. - the radix used to interpret the token as a short value true if and only if this scanner's next token is a valid short value in the specified radix - if this scanner is closed - if the radix is out of range\n• . Scans the next token of the input as a An invocation of this method of the form behaves in exactly the same way as the invocation , where is the default radix of this scanner. the scanned from the input - if the next token does not match the Integer regular expression, or is out of range - if this scanner is closed\n• . This method will throw if the next token cannot be translated into a valid short value as described below. If the translation is successful, the scanner advances past the input that matched. Scans the next token of the input as a. This method will throwif the next token cannot be translated into a valid short value as described below. If the translation is successful, the scanner advances past the input that matched. If the next token matches the Integer regular expression defined above then the token is converted into a value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via , prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to with the specified radix. If the radix is less than or greater than , then an is thrown. - the radix used to interpret the token as a short value the scanned from the input - if the next token does not match the Integer regular expression, or is out of range - if this scanner is closed - if the radix is out of range\n• Returns true if the next token in this scanner's input can be interpreted as an int value in the default radix using the method. The scanner does not advance past any input. true if and only if this scanner's next token is a valid int value - if this scanner is closed\n• Returns true if the next token in this scanner's input can be interpreted as an int value in the specified radix using the method. The scanner does not advance past any input. If the radix is less than or greater than , then an is thrown. - the radix used to interpret the token as an int value true if and only if this scanner's next token is a valid int value - if this scanner is closed - if the radix is out of range\n• . Scans the next token of the input as an An invocation of this method of the form behaves in exactly the same way as the invocation , where is the default radix of this scanner. the scanned from the input - if the next token does not match the Integer regular expression, or is out of range - if this scanner is closed\n• . This method will throw if the next token cannot be translated into a valid int value as described below. If the translation is successful, the scanner advances past the input that matched. Scans the next token of the input as an. This method will throwif the next token cannot be translated into a valid int value as described below. If the translation is successful, the scanner advances past the input that matched. If the next token matches the Integer regular expression defined above then the token is converted into an value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via , prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to with the specified radix. If the radix is less than or greater than , then an is thrown. - the radix used to interpret the token as an int value the scanned from the input - if the next token does not match the Integer regular expression, or is out of range - if this scanner is closed - if the radix is out of range\n• Returns true if the next token in this scanner's input can be interpreted as a long value in the default radix using the method. The scanner does not advance past any input. true if and only if this scanner's next token is a valid long value - if this scanner is closed\n• Returns true if the next token in this scanner's input can be interpreted as a long value in the specified radix using the method. The scanner does not advance past any input. If the radix is less than or greater than , then an is thrown. - the radix used to interpret the token as a long value true if and only if this scanner's next token is a valid long value - if this scanner is closed - if the radix is out of range\n• . Scans the next token of the input as a An invocation of this method of the form behaves in exactly the same way as the invocation , where is the default radix of this scanner. the scanned from the input - if the next token does not match the Integer regular expression, or is out of range - if this scanner is closed\n• . This method will throw if the next token cannot be translated into a valid long value as described below. If the translation is successful, the scanner advances past the input that matched. Scans the next token of the input as a. This method will throwif the next token cannot be translated into a valid long value as described below. If the translation is successful, the scanner advances past the input that matched. If the next token matches the Integer regular expression defined above then the token is converted into a value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via , prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to with the specified radix. If the radix is less than or greater than , then an is thrown. - the radix used to interpret the token as an int value the scanned from the input - if the next token does not match the Integer regular expression, or is out of range - if this scanner is closed - if the radix is out of range\n• Returns true if the next token in this scanner's input can be interpreted as a float value using the method. The scanner does not advance past any input. true if and only if this scanner's next token is a valid float value - if this scanner is closed\n• . This method will throw if the next token cannot be translated into a valid float value as described below. If the translation is successful, the scanner advances past the input that matched. Scans the next token of the input as a. This method will throwif the next token cannot be translated into a valid float value as described below. If the translation is successful, the scanner advances past the input that matched. If the next token matches the Float regular expression defined above then the token is converted into a value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via , prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to . If the token matches the localized NaN or infinity strings, then either \"Nan\" or \"Infinity\" is passed to as appropriate. the scanned from the input - if the next token does not match the Float regular expression, or is out of range - if this scanner is closed\n• Returns true if the next token in this scanner's input can be interpreted as a double value using the method. The scanner does not advance past any input. true if and only if this scanner's next token is a valid double value - if this scanner is closed\n• . This method will throw if the next token cannot be translated into a valid double value. If the translation is successful, the scanner advances past the input that matched. Scans the next token of the input as a. This method will throwif the next token cannot be translated into a valid double value. If the translation is successful, the scanner advances past the input that matched. If the next token matches the Float regular expression defined above then the token is converted into a value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via , prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to . If the token matches the localized NaN or infinity strings, then either \"Nan\" or \"Infinity\" is passed to as appropriate. the scanned from the input - if the next token does not match the Float regular expression, or is out of range - if the input is exhausted - if this scanner is closed\n• in the default radix using the Returns true if the next token in this scanner's input can be interpreted as ain the default radix using the method. The scanner does not advance past any input. true if and only if this scanner's next token is a valid - if this scanner is closed\n• in the specified radix using the Returns true if the next token in this scanner's input can be interpreted as ain the specified radix using the method. The scanner does not advance past any input. If the radix is less than or greater than , then an is thrown. - the radix used to interpret the token as an integer true if and only if this scanner's next token is a valid - if this scanner is closed - if the radix is out of range\n• Scans the next token of the input as a An invocation of this method of the form behaves in exactly the same way as the invocation , where is the default radix of this scanner. the scanned from the input - if the next token does not match the Integer regular expression, or is out of range - if the input is exhausted - if this scanner is closed\n• Scans the next token of the input as a If the next token matches the Integer regular expression defined above then the token is converted into a value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the , and passing the resulting string to the constructor with the specified radix. If the radix is less than or greater than , then an is thrown. - the radix used to interpret the token the scanned from the input - if the next token does not match the Integer regular expression, or is out of range - if the input is exhausted - if this scanner is closed - if the radix is out of range\n• using the Returns true if the next token in this scanner's input can be interpreted as ausing the method. The scanner does not advance past any input. true if and only if this scanner's next token is a valid - if this scanner is closed\n• Scans the next token of the input as a If the next token matches the Decimal regular expression defined above then the token is converted into a value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the , and passing the resulting string to the constructor. the scanned from the input - if the next token does not match the Decimal regular expression, or is out of range - if the input is exhausted - if this scanner is closed\n• Resetting a scanner discards all of its explicit state information which may have been changed by invocations of , , or . An invocation of this method of the form behaves in exactly the same way as the invocation\n• Returns a stream of delimiter-separated tokens from this scanner. The stream contains the same tokens that would be returned, starting from this scanner's current state, by calling the method repeatedly until the method returns false. The resulting stream is sequential and ordered. All stream elements are non-null. Scanning starts upon initiation of the terminal stream operation, using the current state of this scanner. Subsequent calls to any methods on this scanner other than and may return undefined results or may cause undefined effects on the returned stream. The returned stream's source is fail-fast and will, on a best-effort basis, throw a if any such calls are detected during stream pipeline execution. After stream pipeline execution completes, this scanner is left in an indeterminate state and cannot be reused. If this scanner contains a resource that must be released, this scanner should be closed, either by calling its method, or by closing the returned stream. Closing the stream will close the underlying scanner. is thrown if the scanner has been closed when this method is called, or if this scanner is closed during stream pipeline execution. This method might block waiting for more input. For example, the following code will create a list of comma-delimited tokens from a string: The resulting list would contain , , the empty string, and . - if this scanner is closed\n• and then Returns a stream of match results from this scanner. The stream contains the same results in the same order that would be returned by callingand then successively as long as finds matches. The resulting stream is sequential and ordered. All stream elements are non-null. Scanning starts upon initiation of the terminal stream operation, using the current state of this scanner. Subsequent calls to any methods on this scanner other than and may return undefined results or may cause undefined effects on the returned stream. The returned stream's source is fail-fast and will, on a best-effort basis, throw a if any such calls are detected during stream pipeline execution. After stream pipeline execution completes, this scanner is left in an indeterminate state and cannot be reused. If this scanner contains a resource that must be released, this scanner should be closed, either by calling its method, or by closing the returned stream. Closing the stream will close the underlying scanner. is thrown if the scanner has been closed when this method is called, or if this scanner is closed during stream pipeline execution. As with the methods, this method might block waiting for additional input, and it might buffer an unbounded amount of input searching for a match. For example, the following code will read a file and return a list of all sequences of characters consisting of seven or more Latin capital letters: - the pattern to be matched - if this scanner is closed\n• Returns a stream of match results that match the provided pattern string. The effect is equivalent to the following code: - if this scanner is closed - if the regular expression's syntax is invalid"
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html",
        "document": "A simple text scanner which can parse primitive types and strings using regular expressions.\n\nA breaks its input into tokens using a delimiter pattern, which by default matches whitespace. The resulting tokens may then be converted into values of different types using the various methods.\n\nFor example, this code allows a user to read a number from :\n\nAs another example, this code allows types to be assigned from entries in a file :\n\nThe scanner can also use delimiters other than whitespace. This example reads several items in from a string:\n\nThe same output can be generated with this code, which uses a regular expression to parse all four tokens at once:\n\nThe default whitespace delimiter used by a scanner is as recognized by . . The method will reset the value of the scanner's delimiter to the default whitespace delimiter regardless of whether it was previously changed.\n\nThe and methods and their primitive-type companion methods (such as and ) first skip any input that matches the delimiter pattern, and then attempt to return the next token. Both and methods may block waiting for further input. Whether a method blocks has no connection to whether or not its associated method will block.\n\nThe , , and methods operate independently of the delimiter pattern. These methods will attempt to match the specified pattern with no regard to delimiters in the input and thus can be used in special circumstances where delimiters are not relevant. These methods may block waiting for more input.\n\nWhen a scanner throws an , the scanner will not pass the token that caused the exception, so that it may be retrieved or skipped via some other method.\n\nDepending upon the type of delimiting pattern, empty tokens may be returned. For example, the pattern will return no empty tokens since it matches multiple instances of the delimiter. The delimiting pattern could return empty tokens since it only passes one space at a time.\n\nA scanner can read text from any object which implements the interface. If an invocation of the underlying readable's method throws an then the scanner assumes that the end of the input has been reached. The most recent thrown by the underlying readable can be retrieved via the method.\n\nWhen a is closed, it will close its input source if the source implements the interface.\n\nA is not safe for multithreaded use without external synchronization.\n\nUnless otherwise mentioned, passing a parameter into any method of a will cause a to be thrown.\n\nA scanner will default to interpreting numbers as decimal unless a different radix has been set by using the method. The method will reset the value of the scanner's radix to regardless of whether it was previously changed.\n\nAn instance of this class is capable of scanning numbers in the standard formats as well as in the formats of the scanner's locale. A scanner's initial locale is the value returned by the method; it may be changed via the method. The method will reset the value of the scanner's locale to the initial locale regardless of whether it was previously changed.\n\nThe localized formats are defined in terms of the following parameters, which for a particular locale are taken from that locale's object, , and its and object, .\n\nThe strings that can be parsed as numbers by an instance of this class are specified in terms of the following regular-expression grammar, where Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10).\n\nWhitespace is not significant in the above regular expressions."
    },
    {
        "link": "https://rameshfadatare.medium.com/java-scanner-methods-02de492687e3",
        "document": "The class in Java is used for parsing primitive types and strings using regular expressions. This class can be used to read input from various sources like input streams, files, or strings. The class is a part of the package and provides many methods for reading and processing different types of input.\n\nFor more detailed information about Scanner methods, please refer to the official Java SE Documentation.\n\nThe Java Scanner class is widely used to parse text for strings and primitive types using a regular expression. It is the simplest way to get input in Java. With the help of Scanner in Java, we can get input from the user in primitive types (such as int, long, double, byte, float, short) as well as strings.\n\nHere is the list of commonly used methods of the Java class, each with a link to a detailed explanation, examples, and real-world uses. Click on the method names to learn more about how to use them effectively in your applications.\n\nclose() — Closes the scanner, releasing any resources associated with it.\n\ndelimiter() — Returns the current delimiter used by the scanner.\n\nfindAll() — Finds and returns a stream of match results for the specified pattern.\n\nfindInLine() — Attempts to find the next occurrence of a pattern within the current line.\n\nhasNext() — Returns true if the scanner has another token in its input.\n\nhasNextInt() — Returns true if the next token in the scanner can be interpreted as an int value.\n\nhasNextLine() — Returns true if there is another line in the input of this scanner.\n\nmatch() — Returns the match result for the last scanning operation performed by this scanner.\n\nnext() — Finds and returns the next complete token from this scanner.\n\nnextBigDecimal() — Scans the next token as a BigDecimal.\n\nnextBigInteger() — Scans the next token as a BigInteger.\n\nnextBoolean() — Scans the next token as a boolean value.\n\nnextByte() — Scans the next token as a byte value.\n\nnextDouble() — Scans the next token as a double value.\n\nnextFloat() — Scans the next token as a float value.\n\nnextInt() — Scans the next token as an int value.\n\nnextLine() — Advances the scanner past the current line and returns the input that was skipped.\n\nnextLong() — Scans the next token as a long value.\n\nnextShort() — Scans the next token as a short value.\n\ntokens() — Returns a stream of delimiter-separated tokens from this scanner."
    },
    {
        "link": "https://stackoverflow.com/questions/11871520/how-can-i-read-input-from-the-console-using-the-scanner-class-in-java",
        "document": "Basically, all I want is have the scanner read an input for the username, and assign the input to a String variable.\n\nHow could I read input from the console using the Scanner class? Something like this:\n• None is synchronized, so read operations on a BufferedReader can be safely done from multiple threads. The buffer size may be specified, or the default size(8192) may be used. The default is large enough for most purposes. readLine() « just reads data line by line from the stream or source. A line is considered to be terminated by any one these: \n\n, \\r (or) \\r\n• None breaks its input into tokens using a delimiter pattern, which by default matches whitespace(\\s) and it is recognised by . « Until the user enters data, the scanning operation may block, waiting for input. « Use Scanner(BUFFER_SIZE = 1024) if you want to parse a specific type of token from a stream. « A scanner however is not thread safe. It has to be externally synchronized. next() « Finds and returns the next complete token from this scanner. nextInt() « Scans the next token of the input as an int. String name = null; int number; java.io.BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); name = in.readLine(); // If the user has not entered anything, assume the default value. number = Integer.parseInt(in.readLine()); // It reads only String,and we need to parse it. System.out.println(\"Name \" + name + \"\\t number \" + number); java.util.Scanner sc = new Scanner(System.in).useDelimiter(\"\\\\s\"); name = sc.next(); // It will not leave until the user enters data. number = sc.nextInt(); // We can read specific data. System.out.println(\"Name \" + name + \"\\t number \" + number); // The Console class is not working in the IDE as expected. java.io.Console cnsl = System.console(); if (cnsl != null) { // Read a line from the user input. The cursor blinks after the specified input. name = cnsl.readLine(\"Name: \"); System.out.println(\"Name entered: \" + name); }\n\nThere are several ways to get input from the user. Here in this program we will take the Scanner class to achieve the task. This Scanner class comes under , hence the first line of the program is import java.util.Scanner; which allows the user to read values of various types in Java. The import statement line should have to be in the first line the java program, and we proceed further for code. in.nextInt(); // It just reads the numbers in.nextLine(); // It get the String which user enters To access methods in the Scanner class create a new scanner object as \"in\". Now we use one of its method, that is \"next\". The \"next\" method gets the string of text that a user enters on the keyboard. Here I'm using to get the String which the user enters. import java.util.Scanner; class GetInputFromUser { public static void main(String args[]) { int a; float b; String s; Scanner in = new Scanner(System.in); System.out.println(\"Enter a string\"); s = in.nextLine(); System.out.println(\"You entered string \" + s); System.out.println(\"Enter an integer\"); a = in.nextInt(); System.out.println(\"You entered integer \" + a); System.out.println(\"Enter a float\"); b = in.nextFloat(); System.out.println(\"You entered float \" + b); } }\n\nYou can make a simple program to ask for the user's name and print whatever the reply use inputs. Or ask the user to enter two numbers and you can add, multiply, subtract, or divide those numbers and print the answers for user inputs just like the behavior of a calculator. So there you need the Scanner class. You have to , and in the code you need to use: Scanner input = new Scanner(System.in); System.out.println(\"Please enter your name: \"); s = input.next(); // Getting a String value System.out.println(\"Please enter your age: \"); i = input.nextInt(); // Getting an integer System.out.println(\"Please enter your salary: \"); d = input.nextDouble(); // Getting a double See how this differs: , , According to a String, int and a double varies the same way for the rest. Don't forget the import statement at the top of your code.\n\nThere is a simple way to read from the console. Please find the below code: import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner sc = new Scanner(System.in); // Reading of Integer int number = sc.nextInt(); // Reading of String String str = sc.next(); } } For a detailed understanding, please refer to the below documents. Now let's talk about the detailed understanding of the Scanner class working: This is the constructor for creating the Scanner instance. Here we are passing the reference which is nothing but a . Here it opens the Pipe for console input. public InputStreamReader(InputStream in) { super(in); try { sd = StreamDecoder.forInputStreamReader(in, this, (String)null); // ## Check lock object } catch (UnsupportedEncodingException e) { // The default encoding should always be available throw new Error(e); } } By passing the System.in this code will opens the socket for reading from console.\n\nthis is wrong method, you have to make an integer or a string, i would like to prefer string, and then give a string any name that can be i that can be n or anything else, remember that you are giving name to username you can also give name username also, and the code is"
    },
    {
        "link": "https://w3schools.com/java/java_user_input.asp",
        "document": "The class is used to get user input, and it is found in the package.\n\nTo use the class, create an object of the class and use any of the available methods found in the class documentation. In our example, we will use the method, which is used to read Strings:\n\nIn the example above, we used the method, which is used to read Strings. To read other types, look at the table below:\n\nIn the example below, we use different methods to read data of various types:\n\nNote: If you enter wrong input (e.g. text in a numerical input), you will get an exception/error message (like \"InputMismatchException\"). You can read more about exceptions and how to handle errors in the Exceptions chapter."
    },
    {
        "link": "https://stackoverflow.com/questions/3059333/validating-input-using-java-util-scanner",
        "document": "has many methods that can be used to validate input. Here's a brief overview of all of them:\n• - does it have any token at all?\n• - does it have another line of input?\n• For Java primitives\n• - does it have a token that can be parsed into an ?\n• Also available are , , , , , and\n• As bonus, there's also and\n• The integral types also has overloads to specify radix (for e.g. hexadecimal)\n\nis capable of more, enabled by the fact that it's regex-based. One important feature is , which lets you define what pattern separates your tokens. There are also and methods that ignores delimiters.\n\nThe following discussion will keep the regex as simple as possible, so the focus remains on .\n\nHere's a simple example of using to validate positive from the input.\n\nNote how much easier is to use compared to the more verbose / combo. By contract, a guarantees that if it , then will peacefully give you that , and will not throw any / / .\n• How to use Scanner to accept only valid int as input\n• How do I keep a scanner from throwing exceptions when the wrong type is entered? (java)\n\nExample 2: Multiple on the same token\n\nNote that the snippet above contains a statement to advance the until it . It's important to realize that none of the methods advance the past any input! You will find that if you omit this line from the snippet, then it'd go into an infinite loop on an invalid input!\n\nThis has two consequences:\n• If you need to skip the \"garbage\" input that fails your test, then you need to advance the one way or another (e.g. , , , etc).\n• If one test fails, you can still test if it perhaps !\n\nHere's an example of performing multiple tests.\n\nNote that the order of the tests matters. If a , then it also , but it's not necessarily the other way around. More often than not you'd want to do the more specific test before the more general test.\n\nhas many advanced features supported by regular expressions. Here's an example of using it to validate vowels.\n\nIn regex, as a Java string literal, the pattern is what is called a \"character class\"; it matches any of the letters , , , , . Note that it's trivial to make the above test case-insensitive: just provide such regex pattern to the .\n• - Returns if the next token matches the pattern constructed from the specified string.\n\nExample 4: Using two at once\n\nSometimes you need to scan line-by-line, with multiple tokens on a line. The easiest way to accomplish this is to use two , where the second takes the from the first as input. Here's an example:\n\nIn addition to constructor, there's also among others.\n• provides a rich set of features, such as methods for validation.\n• Proper usage of in combination means that a will NEVER throw an / .\n• Always remember that does not advance the past any input.\n• Don't be shy to create multiple if necessary. Two simple is often better than one overly complex .\n• Finally, even if you don't have any plans to use the advanced regex features, do keep in mind which methods are regex-based and which aren't. Any method that takes a argument is regex-based.\n• Tip: an easy way to turn any into a literal pattern is to it."
    },
    {
        "link": "https://stackoverflow.com/questions/45783777/java-console-input-handling",
        "document": "This is my first question here, I hope it's not too based on opinions. I've searched on the internet for quite a while now, but couldn't find a similar question.\n\n I need to write a Java program that reads commands from the console, validates the input, gets the parameters and passes them on to a different class.\n\n There are some restrictions on what I can do and use (university).\n• Only the packages java.util, java.lang and java.io are allowed\n• Each method can only be 80 lines long\n• Each line can only be 120 characters long\n• I am not allowed to use System.exit / Runtime.exit\n• The Terminal class is used to handle user input. will read a line from the console, like\n\nI have a fully working program - however my solution will not be accepted because of the way I handle console inputs ( method too long). I'm doing it like this:\n• None The main class has the main method and an \"interaction loop\" where console inputs are handled. The main method calls the interaction loop in a while loop, with a boolean \"quit\" as a guardian.\n• None The interaction loop handles console input. I need to check for 16 different commands - each with their own types of parameters. I chose to work with Patterns and Matchers, because I can use the groups for convenience. Now the problems start - I have never learned how to correctly handle user inputs. What I have done here is, for each possible command, create a new Matcher, see if the input matches, if it does then do whatever needs to be done for this input. private static runInteractionLoop() { Matcher m; String query = Terminal.readLine; m = Pattern.compile(\"sliding-window (\\\\d+) (-?\\\\d+(?:\\\\.\\\\d+)?;)*(-?\\\\d+(?:\\\\.\\\\d+)?)\").matcher(query); if (m.matches()) { xyz.doSth(Integer.parseInt(m.group(1)), ......); ... return; } m = Pattern.compile(\"record ([a-z]+) (-?\\\\d+(?:\\\\.\\\\d+)?)\").matcher(query); if (m.matches()) { xyz.doSthElse(m.group(1), Double.parseDouble(m.group(2))); return; } ... if (query.equals(\"quit\")) { quit = true; return; } Terminal.printError(\"invalid input\"); }\n\nAs you can see, doing this 16 times stretches out the method to more than 80 lines (5 lines per input max). It's also obviously very inefficient and to be honest, I'm quite ashamed to be posting this here (crap code). I just don't know how to do this correctly, using only java.util and having some way to quickly get the parameters (e.g. the Matcher groups here).\n\n\n\n Any ideas? I would be very grateful for suggestions. Thanks.\n\nEDIT/UPDATE:\n\n I have made the decision to split the verification into two methods - one for each half of the commands. Looks ugly, but passes the Uni's checkstyle requirements. However, I'd still be more than happy if someone shows me a better solution to my problem - for the future (because I obviously have no idea how to make this prettier, shorter and/or more efficient)."
    },
    {
        "link": "https://geeksforgeeks.org/ways-to-read-input-from-console-in-java",
        "document": "In Java, there are four different ways to read input from the user in the command line environment(console).\n\nBuffered Reader Class is the classical method to take input, Introduced in JDK 1.0. This method is used by wrapping the System.in (standard input stream) in an InputStreamReader which is wrapped in a BufferedReader, we can read input from the user in the command line.\n• None The input is buffered for efficient reading.\n• None The wrapping code is hard to remember.\n\nExample: The below Java program demonstrates how to use BufferReader to read a line of input from the user and print it to the console.\n\nNote: To read other types, we use functions like Integer.parseInt(), Double.parseDouble(). To read multiple values, we use split().\n\nScanner Class is probably the most preferred method to take input, Introduced in JDK 1.5. The main purpose of the Scanner class is to parse primitive types and strings using regular expressions; however, it is also can be used to read input from the user in the command line.\n• None Convenient methods for parsing primitives (nextInt(), nextFloat(), …) from the tokenized input.\n• None Regular expressions can be used to find tokens.\n• None The reading methods are not synchronized.\n\nExample: The below Java program demonstrates how to use Scanner class to read and display different type of user input.\n\nConsole Class has been becoming a preferred way for reading user’s input from the command line, Introduced in JDK 1.6. In addition, it can be used for reading password-like input without echoing the characters entered by the user; the format string syntax can also be used (like System.out.printf()).\n\nExample: The below Java program demonstrates how to use System.console() to read user input from the console, which works in terminal but not in most IDEs.\n• None Format string syntax can be used.\n• None Does not work in non-interactive environment (such as in an IDE).\n\nCommand line argument has been around since JDK 1.0 and are used in competitive coding. These inputs are passed to the program during execution and are stored as strings in the args[] array. If we need numeric values, we can convert the strings using methods like Integer.parseInt() or Float.parseFloat(). These programs are run from the command line, with inputs provided while executing the program.\n\nExample: The below Java program demonstrates how to check and print command-line arguments passed to the program or display a message if no arguments are provided.\n\nDataInputStream class in Java, introduced in JDK 1.0, is used to read primitive data types like int, float, boolean, and strings from an input stream in a way that works across different machines. It is part of the package and wraps an existing input stream. It’s commonly used with DataOutputStream or similar sources to ensure the data is read correctly.\n\nExample: The below Java program demonstrates how to use the class to read an integer and a string from user input.\n\nfor more faster ways of reading input."
    },
    {
        "link": "https://theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/User-input-with-the-Java-Console-class",
        "document": ""
    },
    {
        "link": "https://labex.io/tutorials/java-how-to-prompt-user-input-in-a-java-console-application-417592",
        "document": "Console applications, also known as command-line applications, are programs that run in a text-based interface, typically a terminal or command prompt. These applications are widely used in software development, system administration, and various other domains where a graphical user interface (GUI) is not necessary or may even be undesirable.\n\nIn the context of Java programming, console applications are a common way to interact with users and perform various tasks. They offer a simple and efficient way to accept user input, process data, and display output without the need for a complex GUI.\n\nOne of the key features of console applications is their ability to prompt the user for input. This is often done using the class, which provides a convenient way to read and parse user input from the console.\n\nIn the example above, the class is used to read the user's input, which is then displayed back to the user. This demonstrates the basic structure of a console application and the process of prompting the user for input.\n\nBy understanding the fundamentals of console applications and the class, developers can create powerful and efficient Java programs that can be easily deployed and used on various platforms, including Linux-based systems."
    }
]