[
    {
        "link": "https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-content?view=powershell-7.5",
        "document": "The cmdlet gets the content of the item at the location specified by the path, such as the text in a file or the content of a function. For files, the content is read one line at a time and returns a collection of objects, each representing a line of content. Beginning in PowerShell 3.0, can also get a specified number of lines from the beginning or end of an item.\n\nExample 1: Get the content of a text file\n\nThis example gets the content of a file in the current directory. The file has 100 lines in the format, This is Line X and is used in several examples. 1..100 | ForEach-Object { Add-Content -Path .\\LineNumbers.txt -Value \"This is line $_.\" } Get-Content -Path .\\LineNumbers.txt This is Line 1 This is Line 2 ... This is line 99. This is line 100. The array values 1-100 are sent down the pipeline to the cmdlet. uses a script block with the cmdlet to create the file. The variable represents the array values as each object is sent down the pipeline. The cmdlet uses the Path parameter to specify the file and displays the content in the PowerShell console.\n\nExample 2: Limit the number of lines Get-Content returns\n\nExample 3: Get a specific line of content from a text file\n\nThis command gets a specific number of lines from a file and then displays only the last line of that content. The TotalCount parameter gets the first 25 lines of content. This example uses the file referenced in Example 1. The command is wrapped in parentheses so that the command completes before going to the next step. returns an array of lines, this allows you to add the index notation after the parenthesis to retrieve a specific line number. In this case, the index specifies the last index in the returned array of 25 retrieved lines.\n\nExample 4: Get the last line of a text file\n\nExample 5: Get the content of an alternate data stream\n\nThis example describes how to use the Stream parameter to get the content of an alternate data stream for files stored on a Windows NTFS volume. In this example, the cmdlet is used to create sample content in a file named . Set-Content -Path .\\Stream.txt -Value 'This is the content of the Stream.txt file' # Specify a wildcard to the Stream parameter to display all streams of the recently # created file. Get-Item -Path .\\Stream.txt -Stream * PSPath : Microsoft.PowerShell.Core\\FileSystem::C:\\Test\\Stream.txt::$DATA PSParentPath : Microsoft.PowerShell.Core\\FileSystem::C:\\Test PSChildName : Stream.txt::$DATA PSDrive : C PSProvider : Microsoft.PowerShell.Core\\FileSystem PSIsContainer : False FileName : C:\\Test\\Stream.txt Stream : :$DATA Length : 44 # Retrieve the content of the primary stream. # Note the single quotes to prevent variable substitution. Get-Content -Path .\\Stream.txt -Stream ':$DATA' This is the content of the Stream.txt file # Alternative way to get the same content. Get-Content -Path .\\Stream.txt -Stream \"\" # The primary stream doesn't need to be specified to get the primary stream of the file. # This gets the same data as the prior two examples. Get-Content -Path .\\Stream.txt This is the content of the Stream.txt file # Use the Stream parameter of Add-Content to create a new Stream containing sample # content. $addContentSplat = @{ Path = '.\\Stream.txt' Stream = 'NewStream' Value = 'Added a stream named NewStream to Stream.txt' } Add-Content @addContentSplat # Use Get-Item to verify the stream was created. Get-Item -Path .\\Stream.txt -Stream * PSPath : Microsoft.PowerShell.Core\\FileSystem::C:\\Test\\Stream.txt::$DATA PSParentPath : Microsoft.PowerShell.Core\\FileSystem::C:\\Test PSChildName : Stream.txt::$DATA PSDrive : C PSProvider : Microsoft.PowerShell.Core\\FileSystem PSIsContainer : False FileName : C:\\Test\\Stream.txt Stream : :$DATA Length : 44 PSPath : Microsoft.PowerShell.Core\\FileSystem::C:\\Test\\Stream.txt:NewStream PSParentPath : Microsoft.PowerShell.Core\\FileSystem::C:\\Test PSChildName : Stream.txt:NewStream PSDrive : C PSProvider : Microsoft.PowerShell.Core\\FileSystem PSIsContainer : False FileName : C:\\Test\\Stream.txt Stream : NewStream Length : 46 # Retrieve the content of your newly created Stream. Get-Content -Path .\\Stream.txt -Stream NewStream Added a stream named NewStream to Stream.txt The Stream parameter is a dynamic parameter of the FileSystem provider. By default only retrieves data from the default, or stream. Streams can be used to store hidden data such as attributes, security settings, or other data. They can also be stored on directories without being child items.\n\nExample 7: Use Filters with Get-Content\n\nExample 8: Get file contents as a byte array\n\nSpecifies that the content should be read as a stream of bytes. The AsByteStream parameter was introduced in Windows PowerShell 6.0. A warning occurs when you use the AsByteStream parameter with the Encoding parameter. The AsByteStream parameter ignores any encoding and the output is returned as a stream of bytes. When reading from and writing to binary files, use the AsByteStream parameter and a value of 0 for the ReadCount parameter. A ReadCount value of 0 reads the entire file in a single read operation. The default ReadCount value, 1, reads one byte in each read operation and converts each byte into a separate object. Piping single-byte output to causes errors unless you use the AsByteStream parameter with .\n\nSpecifies the delimiter that uses to divide the file into objects while it reads. The default is , the end-of-line character. When reading a text file, returns a collection of string objects, each ending with an end-of-line character. When you enter a delimiter that doesn't exist in the file, returns the entire file as a single, undelimited object. You can use this parameter to split a large file into smaller files by specifying a file separator, as the delimiter. The delimiter is preserved (not discarded) and becomes the last item in each file section. Delimiter is a dynamic parameter that the FileSystem provider adds to the cmdlet. This parameter works only in file system drives. Currently, when the value of the Delimiter parameter is an empty string, does not return anything. This is a known issue. To force to return the entire file as a single, undelimited string. Enter a value that doesn't exist in the file.\n\nSpecifies the type of encoding for the target file. The default value is . The acceptable values for this parameter are as follows:\n• : Uses the encoding for the ASCII (7-bit) character set.\n• : Uses the encoding for the for the current culture's ANSI code page. This option was added in PowerShell 7.4.\n• : Encodes in UTF-16 format using the big-endian byte order.\n• : Encodes in UTF-32 format using the big-endian byte order.\n• : Uses the default encoding for MS-DOS and console programs.\n• : Encodes in UTF-16 format using the little-endian byte order. Encoding is a dynamic parameter that the FileSystem provider adds to the cmdlet. This parameter is available only in file system drives. Beginning with PowerShell 6.2, the Encoding parameter also allows numeric IDs of registered code pages (like ) or string names of registered code pages (like ). For more information, see the .NET documentation for Encoding.CodePage. Starting with PowerShell 7.4, you can use the value for the Encoding parameter to pass the numeric ID for the current culture's ANSI code page without having to specify it manually. UTF-7* is no longer recommended to use. As of PowerShell 7.1, a warning is written if you specify for the Encoding parameter.\n\nCauses the cmdlet to wait indefinitely, keeping the file open, until interrupted. While waiting, checks the file once per second and outputs new lines if present. When used with the TotalCount parameter, waits until the specified number of lines are available in the specified file. For example, if you specify a TotalCount of 10 and the file already has 10 or more lines, returns the 10 lines and exits. If the file has fewer than 10 lines, outputs each line as it arrives, but waits until the tenth line arrives before exiting. You can interrupt Wait by pressing + . Deleting the file causes a non-terminating error that also interrupts the waiting. Wait is a dynamic parameter that the FileSystem provider adds to the cmdlet. This parameter works only in file system drives. Wait can't be combined with Raw."
    },
    {
        "link": "https://stackoverflow.com/questions/36507343/get-last-n-lines-or-bytes-of-a-huge-file-in-windows-like-unixs-tail-avoid-ti",
        "document": "I need to retrieve the last n lines of huge files (1-4 Gb), in Windows 7. Due to corporate restrictions, I cannot run any command that is not built-in. The problem is that all solutions I found appear to read the whole file, so they are extremely slow.\n\nCan this be accomplished, fast?\n• I managed to get the first n lines, fast.\n• It is ok if I get the last n bytes. (I used this https://stackoverflow.com/a/18936628/2707864 for the first n bytes).\n\nSolutions here Unix tail equivalent command in Windows Powershell did not work. Using does not make it fast. I do not have (and I do not know if it will work fast).\n\nPS: There are quite a few related questions for and , but not focused on the issue of speed. Therefore, useful or accepted answers there may not be useful here. E.g.,\n\nCMD.EXE batch script to display last 10 lines from a txt file\n\npowershell to get the first x MB of a file"
    },
    {
        "link": "https://reddit.com/r/PowerShell/comments/tn8l7i/how_to_extract_last_few_lines_from_a_text_file",
        "document": "I am trying to come up with a logic to extract last few lines of a text file. I have a logic in mind where we first get the total number of lines in the files and read the text file from the end selecting only those lines that are needed from the end. As a beginner in coding i m finding it hard to put this logic to code, is there any better way to do it?"
    },
    {
        "link": "https://stackoverflow.com/questions/33511772/read-file-line-by-line-in-powershell",
        "document": "Documentation on loops in PowerShell is plentiful, and you might want to check out the following help topics: , , , .\n\nAnother idiomatic PowerShell solution to your problem is to pipe the lines of the text file to the cmdlet:\n\nInstead of regex matching inside the loop, you could pipe the lines through to filter just those you're interested in:"
    },
    {
        "link": "https://lazyadmin.nl/powershell/get-content",
        "document": "The Get-Content cmdlet can be used to retrieve the contents from a file in PowerShell. It will retrieve the contents one line at a time, storing them in an array. This allows you to use or process each line in your PowerShell script.\n\nGet-Content comes with several parameters that allow you to select or filter the results you want to retrieve from the file. And when you need to process a lot of large files, then using the parameter can speed up the process.\n\nIn this article, we are going to take a look at how to use the Get-Content cmdlet, and explain the different parameters that we can use.\n\nWe are going to start with the basics, read a file in PowerShell line-by-line using the cmdlet. For the examples below I will be using a text file with 100 lines, which are numbered. This makes it easier to follow the examples:\n\nThe code above is from Microsoft and creates a text file where each line starts with the string “This is line ” followed by the line number:\n\nTo view the results of the newly created file, we can use the cmdlet. You only need to specify the path to the file to start reading its contents of it:\n\nIf we store the result of Get-Content in a variable, then we can see that PowerShell stores the results in an array. This means that we can use any Array function on the results, or process each line using a ForEach loop:\n\nReturning the First or Last x Lines\n\nBy default, the Get-Content cmdlet will return all the contents of a file in PowerShell. But in some cases, you only want to view the first or last x lines from a file. For example, when debugging an issue, you often only need the last couple of lines from a log file.\n\nFor this we have two options, we can use the parameter , which returns the first x items of the content. Or we can use the parameter , which returns the last x items of a file.\n\nSo let’s go back to our log file example. We want to view the last 10 lines from the log. To do this, we need to specify the path and add 10 to return only the last 10 lines:\n\nTo read the first x item from a file we will need to use the parameter :\n\nIf you know which specific line you need from a text file, then it’s possible to select only a single line from the text file. As we know, the results are stored in an array. So we can use the array index to select a line number that we need.\n\nKeep in mind that the array index starts at 0, so if we want to return line 16, we need to specify index number 15. We wrap the command in parentheses so that PowerShell first completes the Get-Content command before it continues.\n\nIf you have a large text file then you might not want to read it completely to only return a single line. What you can do is select only the first or last x lines from the file, and then select the line number using the array index.\n\nFor example, let’s say we need the fifth line from a file. We set the to 5, reading only the first 5 lines, and return the last item from the array:\n\nIt’s also possible to read the contents of multiple files at once with Get-Content in PowerShell. To do this you only need to specify the path where the files are located followed by an asterisk .\n\nKeep in mind though that there won’t be any reference in the results to the source files. So you won’t know from which file line x comes.\n\nWe can also filter which files we want to read. So for example, if you only want to get the contents of all the .log files then you can add the parameter to it:\n\nThe Get-Content cmdlet reads each line of the file into the array, which is great when you need to process each line independently or you are looking for a single line. But array a terrible if you need to do a search and replace on the contents of a file.\n\nFor example, when you have an HTML file that you are using as a template for an email that you are about the send with PowerShell. In the HTML file, we have placeholders that we need to replace, like this:\n\nInstead of looping through each line to find the placeholders and replace them, we can use the parameter to read the whole file as a single string and use the -Replace operator to replace the placeholders:\n\nAnother advantage of using the -Raw parameter is that it’s a lot faster. Get-Content works great with small text files, but when you need to process large text files then you will probably notice that the command is a bit sluggish.\n\nFor example, a text file of 50Mb takes almost 5 seconds to read as you can see in the screenshot below:\n\nBut when using -Raw it took less than half a second:\n\nIf you still need the results in an array then we can use combined with the string operator to create an array of each line of the file. This method is still 5 times faster than using Get-Content without .\n\nWhen processing very large files, 100Mb and large, then there is an even faster method to read the contents of the file with PowerShell. The .Net method . will read all the lines into the memory in half of the time compared to using the -Raw method.\n\nThe results are, just like with Get-Content, stored in an array. So you can process that data in the same way.\n\nYou can also use the method , which is even faster. But this will immediately stream the contents to the console, instead of storing it in the memory. The problem with this method is that you will need to close the file when done, otherwise, it will be locked by the stream.\n\nThe last interesting function of Get-Contents is that we can monitor or watch the contents of a file using the parameter. If you, for example, want to monitor a log file. Then instead of rerunning the Get-Content cmdlet every time, you can add the parameter.\n\nAs soon as the contents of the file are updated (and saved), it will update the output of Get-Content.\n\nIf we add new lines to the end of the file, then these will show up in the results.\n\nThe Get-Content cmdlet in PowerShell is great when you need to read a file quickly. But when working with large files you really need to use the -Raw parameter at least to speed up the process. Also, give the .Net method a try, you will be amazed at how fast it is.\n\nI hope you found this article useful, if you have any questions, then just drop a comment below."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/findstr",
        "document": "Searches for patterns of text in files.\n• None All findstr command-line options must precede strings and filename in the command string.\n• None Regular expressions use both literal characters and meta-characters to find patterns of text, rather than exact strings of characters.\n• None A literal character is a character that doesn't have a special meaning in the regular-expression syntax; instead, it matches an occurrence of that character. For example, letters and numbers are literal characters.\n• None A meta-character is a symbol with special meaning (an operator or delimiter) in the regular-expression syntax. Repeat - Zero or more occurrences of the previous character or class. Character class - Any one character in a set. Inverse class - Any one character not in a set. Range - Any characters within the specified range. The special characters in regular expression syntax have the most power when you use them together. For example, use the combination of the wildcard character ( ) and repeat ( ) character to match any string of characters: Use the following expression as part of a larger expression to match any string beginning with b and ending with ing:\n• None To search for multiple strings in a set of files, you must create a text file that contains each search criterion on a separate line.\n• None Use spaces to separate multiple search strings unless the argument is prefixed with /c.\n\nTo search for hello or there in file x.y, type:\n\nTo search for hello there in file x.y, type:\n\nTo find all occurrences of the word Windows (with an initial capital letter W) in the file proposal.txt, type:\n\nTo search every file in the current directory and all subdirectories that contained the word Windows, regardless of the letter case, type:\n\nTo find all occurrences of lines that begin with FOR and are preceded by zero or more spaces (as in a computer program loop), and to display the line number where each occurrence is found, type:\n\nTo list the exact files that you want to search in a text file, use the search criteria in the file stringlist.txt, to search the files listed in filelist.txt, and then to store the results in the file results.out, type:\n\nTo list every file containing the word computer within the current directory and all subdirectories, regardless of case, type:\n\nTo list every file containing the word computer and any other words that begin with comp, (such as compliment and compete), type:"
    },
    {
        "link": "https://stackoverflow.com/questions/43450914/how-to-use-findstr-in-powershell-to-find-lines-where-all-words-in-the-search-str",
        "document": "You can use to do a regex based search through multiple files.\n\nTo match all of multiple search terms in a single string with regular expressions, you'll have to use a lookaround assertion:\n\nIn the above example, this is what's happening with the first command:\n\nWe then pipe the resulting FileInfo objects to and use the following regex pattern:\n\nSince each lookahead group is just being asserted for correctness and the search position within the string never changes, the order doesn't matter.\n\nIf you want it to match strings that contain any of the words, you can use a simple non-capturing group:\n\nThese can of course be abstracted away in a simple proxy function.\n\nI generated the block and most of the body of the function definition below with:\n\nThen removed unnecessary parameters (including and ), then added the pattern generator (see inline comments):\n\nNow you can use it like this, and it'll behave almost like :"
    },
    {
        "link": "https://stackoverflow.com/questions/58889324/how-to-use-findstr-in-powershell-to-search-for-a-string-in-the-whole-drive",
        "document": "If speed matters, stick with , and use the switch to perform a recursive search, as vonPryz suggests:\n• None makes search recursively; that is, the input directory as well as as all its subdirectories and their subdirectories, ... are searched.\n• None looks for the search string literally (default is to treat it as a regular expression, in which case is a metacharacter (a character with special meanings) that matches any input character);\n• None prints only the paths of the files in which the search string is found.\n• None invariably includes hidden directories and files in the search.\n• None quietly ignores inaccessible directories, i.e., directories that cannot be accessed due to lack of permissions.\n\nCaveat: The string will only be found in files that use ASCII character encoding or one of its supersets (ANSI, OEM, UTF-8); to match all of the latter, the search string itself must comprise ASCII-range characters only; e.g, it mustn't contain accented letters such as .\n\nIf you need to also recognize additional character encodings, notably UTF-16LE (\"Unicode\"), use in combination with , but note that it will be noticeably slower.\n\nOn the plus side, :\n• outputs objects that complement the lines found with rich metadata, notably what parts of the line matched; access the property to extract the line only; contains the full path of the input file.\n\nBy default, the search argument passed to is interpreted as a regular expression, as with . Add the switch to perform a literal string search instead, which not only avoids the need to -escape special characters such as in the search string, but also speeds up the operation.\n\nAs js2010, suggests, another way to speed up the command is to use the parameter (e.g., ) rather than including the wildcard pattern in the parameter argument ( ).\n\nIf you need to include hidden directories and files, add the switch; by default and ignore them.\n\nGiven that you're searching the entire drive, you're likely to encounter directories you won't be able to access due to lack of permissions, especially if you don't run with elevation and also include (but even with elevation (running as admin) access-denied errors can occur).\n\nUse to silence errors; if you need to inspect errors later, also add something like ( is short for ), which collects the errors that occur in variable .\n\nTo put it all together:\n\nFinally, note that can itself target files, but only those in a single directory; also, hidden files are invariably ignored.\n\nE.g., to only search the current directory's files:"
    },
    {
        "link": "https://pdq.com/blog/powershell-searching-through-files-for-matching-strings",
        "document": "Trying to find a file containing a certain string of text using PowerShell? Well, you’ve come to the right place. I’ll show you how to find exactly what you’re looking for with the cmdlet and a basic PowerShell script.\n\nIn this example, we pipe the results of to the cmdlet and filter with the pattern ‘Appx.’ We add the parameter so the command doesn’t interpret the pattern as regular expression, which does by default. In the end, this example returns all the PowerShell commands that have the string ‘Appx’ in the name.\n\nAs I mentioned in the previous section, one of the primary uses of the command is to search for text strings in a file. Let’s start with an easy example to get our feet wet.\n\nIn this example, we’re searching files for the string pattern ‘Bart.Simpson.’ For the path, we’re searching the C:\\temp directory, specifically looking for .csv files. As you can see in the screenshot, we found a matching result on line 4 of a file called Usernames.csv.\n\nIf there are multiple sources found that match the pattern, the command returns each source. To show this off, I’ll run the command again, but this time I added a second file containing the pattern we’re looking for.\n\nIf you’re familiar with PowerShell, you’ve probably used the parameter to search subdirectories. However, the command doesn’t support the parameter. That’s okay, though, because we can use with the parameter and then pipe the results to the command. Here’s an example.\n\nIn this example, we use the command to define the directory path and use the parameter to ensure that subdirectories are included. The results are then piped to the command. We don’t have to redefine the path since it was already set in the previous command."
    },
    {
        "link": "https://superuser.com/questions/1540804/how-do-to-use-windows-findstr-or-other-utility-to-find-file-containing-a-strin",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]