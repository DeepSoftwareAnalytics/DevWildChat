[
    {
        "link": "https://discuss.streamlit.io/t/new-component-streamlit-oauth/40364",
        "document": ""
    },
    {
        "link": "https://medium.com/@coding-otter/google-oauth-in-streamlit-a-solution-that-finally-works-for-me-a212a79fec30",
        "document": "Recently, I had an opportunity at work to add authentication to a Streamlit app. This wasn’t something I had done before with Streamlit, but it turned into a learning experience that I figured might be helpful to share.\n\nOur internal Streamlit app was initially hosted on Streamlit Community Cloud as a private app, where user authentication was handled for us. But as we needed separate dev and prod environments, we decided to host the app ourselves — meaning we had to implement our own authentication. To avoid managing a user database, we chose Google OAuth. It’s simple, widely trusted, and lets Google handle most of the work so we can focus on the app.\n\nThe Trials and Errors of Streamlit Authentication\n\nLike most developers, I started by searching for solutions online. Here’s a quick overview of the approaches I tried and why they didn’t quite work:\n• Code from Streamlit Discussion Forum \n\nA solution found in Streamlit discussion forum used session state to manage login info. It worked as expected initially, but the login state will not persist after a page refresh — not ideal.\n• Streamlit-Google-Auth Repository\n\nNext, I came across the streamlit-google-auth repo, which looked promising since it used JSON web tokens stored in cookies for user authentication. This should have allowed persistent login information through cookies, but somehow the token was still lost after a page refresh.\n\nUsing the streamlit-google-auth repository as a reference, I tweaked the approach to get around the token deletion issue and trimmed the code down to the essentials. My main requirements were:\n• Google Account Login: Allow users to log in with their Google accounts\n• Access Control: Only allow specific users from an list to access the app\n\nHere’s what my solution looks like when running. If this looks like what you’re aiming to build, check out the code below for reference!\n• User with no Permission to the App: gets an access denied message\n• User with an expired jwt: asks the user to login again\n\nHere’s the code that finally worked for me.\n\nimport time\n\nimport streamlit as st\n\nimport google_auth_oauthlib.flow\n\nfrom googleapiclient.discovery import build\n\nfrom auth.token_manager import AuthTokenManager\n\n\n\nclass Authenticator:\n\n def __init__(\n\n self,\n\n allowed_users: list,\n\n secret_path: str,\n\n redirect_uri: str,\n\n token_key: str,\n\n cookie_name: str = \"auth_jwt\",\n\n token_duration_days: int = 1,\n\n ):\n\n st.session_state[\"connected\"] = st.session_state.get(\"connected\", False)\n\n self.allowed_users = allowed_users\n\n self.secret_path = secret_path\n\n self.redirect_uri = redirect_uri\n\n self.auth_token_manager = AuthTokenManager(\n\n cookie_name=cookie_name,\n\n token_key=token_key,\n\n token_duration_days=token_duration_days,\n\n )\n\n self.cookie_name = cookie_name\n\n\n\n def _initialize_flow(self) -> google_auth_oauthlib.flow.Flow:\n\n flow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n\n self.secret_path,\n\n scopes=[\n\n \"openid\",\n\n \"https://www.googleapis.com/auth/userinfo.profile\",\n\n \"https://www.googleapis.com/auth/userinfo.email\",\n\n ],\n\n redirect_uri=self.redirect_uri,\n\n )\n\n return flow\n\n\n\n def get_auth_url(self) -> str:\n\n flow = self._initialize_flow()\n\n auth_url, _ = flow.authorization_url(\n\n access_type=\"offline\", include_granted_scopes=\"true\"\n\n )\n\n return auth_url\n\n\n\n def login(self):\n\n if not st.session_state[\"connected\"]:\n\n auth_url = self.get_auth_url()\n\n st.link_button(\"login with google\", auth_url)\n\n\n\n def check_auth(self):\n\n\n\n if st.session_state[\"connected\"]:\n\n st.toast(\":green[user is authenticated]\")\n\n return\n\n\n\n if st.session_state.get(\"logout\"):\n\n st.toast(\":green[user logged out]\")\n\n return\n\n\n\n token = self.auth_token_manager.get_decoded_token()\n\n if token is not None:\n\n st.query_params.clear()\n\n st.session_state[\"connected\"] = True\n\n st.session_state[\"user_info\"] = {\n\n \"email\": token[\"email\"],\n\n \"oauth_id\": token[\"oauth_id\"],\n\n }\n\n st.rerun() # update session state\n\n\n\n time.sleep(1) # important for the token to be set correctly\n\n\n\n auth_code = st.query_params.get(\"code\")\n\n st.query_params.clear()\n\n if auth_code:\n\n flow = self._initialize_flow()\n\n flow.fetch_token(code=auth_code)\n\n creds = flow.credentials\n\n\n\n oauth_service = build(serviceName=\"oauth2\", version=\"v2\", credentials=creds)\n\n user_info = oauth_service.userinfo().get().execute()\n\n oauth_id = user_info.get(\"id\")\n\n email = user_info.get(\"email\")\n\n\n\n if email in self.allowed_users:\n\n self.auth_token_manager.set_token(email, oauth_id)\n\n st.session_state[\"connected\"] = True\n\n st.session_state[\"user_info\"] = {\n\n \"oauth_id\": oauth_id,\n\n \"email\": email,\n\n }\n\n else:\n\n st.toast(\":red[access denied: Unauthorized user]\")\n\n # no rerun\n\n\n\n def logout(self):\n\n st.session_state[\"logout\"] = True\n\n st.session_state[\"user_info\"] = None\n\n st.session_state[\"connected\"] = None\n\n self.auth_token_manager.delete_token()\n\n # no rerun\n\nYou can check out my full code here:\n\nGetting Google OAuth to work with Streamlit was trickier than I expected. Streamlit’s automatic rerun can sometimes cause unexpected behavior, making the debugging process more challenging. I hope this code can help smooth things out for you."
    },
    {
        "link": "https://docs.streamlit.io/develop/concepts/connections/authentication",
        "document": "Personalizing your app for your users is a great way to make your app more engaging.\n\nUser authentication and personalization unlocks a plethora of use cases for developers, including controls for admins, a personalized stock ticker, or a chatbot app with a saved history between sessions.\n\nBefore reading this guide, you should have a basic understanding of secrets management.\n\nStreamlit supports user authentication with OpenID Connect (OIDC), which is an authentication protocol built on top of OAuth 2.0. OIDC supports authentication, but not authorization: that is, OIDC connections tell you who a user is (authentication), but don't give you the authority to impersonate them (authorization). If you need to connect with a generic OAuth 2.0 provider or have your app to act on behalf of a user, consider using or creating a custom component.\n\nThere are three commands involved with user authentication:\n• redirects the user to your identity provider. After they log in, Streamlit stores an identity cookie and then redirects them to the homepage of your app in a new session.\n• is a dict-like object for accessing user information. It has a persistent attribute, , which you can check for the user's login status. When they are logged in, other attributes are available per your identity provider's configuration.\n• removes the identity cookie from the user's browser and redirects them to the homepage of your app in a new session.\n\nStreamlit checks for the identity cookie at the beginning of each new session. If a user logs in to your app in one tab and then opens a new tab, they will automatically be logged in to your app in the new tab. When you call in a user session, Streamlit removes the identity cookie and starts a new session. This logs the user out from the current session. However, if they were logged in to other sessions already, they will remain logged in within those sessions. The information in is updated at the beginning of a session (which is why and both start new sessions after saving or deleting the identity cookie).\n\nIf a user closes your app without logging out, the identity cookie will expire after 30 days. This expiration time is not configurable and is not tied to any expiration time that may be returned in your user's identity token. If you need to prevent persistent authentication in your app, check the expiration information returned by the identity provider in and manually call when needed.\n\nStreamlit does not modify or delete any cookies saved directly by your identity provider. For example, if you use Google as your identity provider and a user logs in to your app with Google, they will remain logged in to their Google account after they log out of your app with .\n\nIn order to use an identity provider, you must first configure your identity provider through an admin account. This typically involves setting up a client or application within the identity provider's system. Follow the documentation for your identity provider. As a general overview, an identity-provider client typically does the following:\n• Manages the list of your users.\n• Optional: Allows users to add themselves to your user list.\n• Declares the set of attributes passed from each user account to the client (which is then passed to your Streamlit app).\n• Only allows authentication requests to come from your Streamlit app.\n• Redirects users back to your Streamlit app after they authenticate.\n\nTo configure your app, you'll need the following:\n• Your app's URL For example, use for most local development cases.\n• A redirect URL, which is your app's URL with the pathname For example, for most local development cases.\n• A cookie secret, which should be a strong, randomly generated string\n\nAfter you use this information to configure your identity-provider client, you'll receive the following information from your identity provider:\n\nExamples for popular OIDC provider configurations are listed in the API reference for .\n\nAfter you've configured your identity-provider client, you'll need to configure your Streamlit app, too. uses your app's file to configure your connection, similar to how works.\n\nWhether you have one OIDC provider or many, you'll need to have an dictionary in . You must declare and in the dictionary. These two values are shared between all OIDC providers in your app.\n\nIf you are only using one OIDC provider, you can put the remaining three properties ( , , and ) in . However, if you are using multiple providers, they should each have a unique name so you can declare their unique values in their own dictionaries. For example, if you name your connections and , put their remaining properties in dictionaries named and , respectively.\n\nIf you use Google Identity as your identity provider, a basic configuration for local development will look like the following TOML file:\n\nMake sure the port in matches the port you are using. The should be a strong, randomly generated secret. Both the and should have been entered into your client configuration on Google Cloud. You must copy the and from Google Cloud after you create your client. For some identity providers, may be unique to your client. However, for Google Cloud, a single URL is shared for OIDC clients.\n\nWhen you use , your script run ends as soon as the login button is displayed. This lets you avoid nesting your entire page within a conditional block. Additionally, you can use callbacks to simplify the code further:\n\nIf you use more than one OIDC provider, you'll need to declare a unique name for each. If you want to use Google Identity and Microsoft Entra ID as two providers for the same app, your configuration for local development will look like the following TOML file:\n\nMicrosoft's server metadata URL varies slightly depending on how your client is scoped. Replace with the appropriate value described in Microsoft's documentation for OpenID configuration.\n\nUsing callbacks, this would look like:\n\nTo customize the behavior of your identity provider, you may need to declare additional keywords. For a complete list of OIDC parameters, see OpenID Connect Core and your provider's documentation. By default, Streamlit sets and . You can change these and other OIDC parameters by passing a dictionary of settings to . and , which are used for security, are handled automatically and don't need to be specified.\n\nFor example,if you are using Auth0 and need to force users to log in every time, use as described in Auth0's Customize Signup and Login Prompts. Your configuration will look like this:"
    },
    {
        "link": "https://medium.com/@dnplus/exploring-streamlit-oauth-effortless-authentication-for-your-apps-e23f18a00d48",
        "document": "Have you ever wondered how to seamlessly implement OAuth authentication in your Streamlit applications? Good news! I just released a brand-new Streamlit OAuth component that makes this process incredibly easy. Let’s dive in and see how you can integrate it into your Streamlit app.\n\n1. User-Friendly: No need to delve into the complexities of OAuth. With just a few lines of code, you can integrate authentication into your Streamlit app effortlessly.\n\n2. Multi-Platform Support: Supports various OAuth providers, including Google, Facebook, GitHub, and more, catering to the needs of different applications.\n\n3. Customization Options: Provides rich customization options, allowing you to adjust the authentication flow according to your requirements.\n\n4. Real-Time Feedback: Utilize Streamlit’s live preview feature to instantly see the effects of the authentication process.\n\nHow to Use\n\nFirst, you need to install this component. You can find its installation page on PyPI.org, and you can run the following command:\n\nOnce installed, you can import the component into your Streamlit app:\n\nThat’s it! These few lines of code are enough to integrate OAuth authentication into your Streamlit app.\n\nIf you want to delve deeper into using this component, check out my GitHub repository, which includes detailed documentation and example code to help you get started quickly.\n\nThe Streamlit OAuth component is a tool that makes authentication a breeze, aiming to bring more convenience to your app development. If you have any questions, suggestions, or feedback, feel free to raise them in the GitHub repository. Looking forward to seeing your fantastic applications — happy coding!"
    },
    {
        "link": "https://discuss.streamlit.io/t/google-authentication-with-google-auth-oauthlib/79386",
        "document": "Good morning community, I present my strange case using the library google-auth-oauthlib · PyPI supported by the tutorial of the great Fanilo Andrianasolo https://www.youtube.com/watch?v=0M4K53XBsjo\n\nI will tell you my case in detail in case you can help me solve the problem.\n\nCreate a test application to apply Google authentication, follow all the steps indicated in the Fanilo tutorial.\n• I have the project on Google Cloud\n• I included the permissions and the test email accounts\n• I created the OAuth 2.0 Client ID credential and downloaded the JSON\n• I created my streamlit project with the following libraries:\n• I put my GCP credentials JSON file in the project\n• I created my script as follows:\n\nI complete the authentication process without problems, but when I redirect to the application page, after logging in, the logged in user information is not streamed, as if the application was reloaded and everything was lost.\n\nIf you notice, I put a print after the method call\n\nIt doesn’t print anything, I show you the console output after login\n\nAnd this is how the page looks after authentication:\n\nWhy does this happen? How can I fix it?\n\nI thought it was my code and I downloaded the source code from the Fanilo tutorial (GitHub - andfanilo/streamlit-google-authentication-tests: Exploring different ways for Google Authentication in Streamlit), I put my credentials in and the same thing happens, why did it work in the tutorial and not in mine?\n\nThank you so much for all the help you can give me."
    },
    {
        "link": "https://docs.authlib.org/en/latest/client/oauth2.html",
        "document": "This documentation covers the common design of a Python OAuth 2.0 client. Authlib provides three implementations of OAuth 2.0 client:\n• None implementation of OAuth for Requests, which is a replacement for requests-oauthlib.\n• None implementation of OAuth for HTTPX, which is async OAuth 2.0 client powered by HTTPX.\n\nand shares the same API.\n\nThere are also frameworks integrations of Flask OAuth Client, Django OAuth Client and Starlette OAuth Client. If you are using these frameworks, you may have interests in their own documentation.\n\nIf you are not familiar with OAuth 2.0, it is better to read Introduce OAuth 2.0 now.\n\nThere are two steps in OAuth 2 to obtain an access token with authorization code grant type. Initialize the session for reuse: # we want to fetch user's email You can assign a in case you want to specify the callback url. Unlike OAuth 1, there is no request token. The first step is to jump to the remote authorization server: The returns a tuple of , in real project, you should save the state for later use. Now head over to the generated authorization url, and grant the authorization. The authorization server will redirect you back to your site with a code and state arguments: Use to obtain access token. This method will also verify the state in case of CSRF attack: In real project, this session can not be re-used since you are redirected to another website. You need to create another session yourself: Authlib has a built-in Flask/Django integration. Learn from them. Authlib client can handle PKCE automatically, just pass to and :\n\nOAuth2Session supports implicit grant type. It can fetch the access token with the of : Visit this link, and grant the authorization, the OAuth authorization server will redirect back to your redirect_uri, the response url would be something like: Fetch access token from the fragment with method: # if you don't specify access token endpoint, it will fetch from fragment. GitHub doesn’t support response type, try with other services.\n\nWhen fetching access token, the authorization server will require a client authentication, Authlib provides three default methods defined by RFC7591: The default value is . You can change the auth method with : If the authorization server requires other means of authentication, you can construct an for your own need, and pass it to : It is also possible to extend the client authentication method with . Besides the default three authentication methods, there are more provided by Authlib. e.g. These two methods are defined by RFC7523 and OpenID Connect. Find more in Using JWTs Client Assertion in OAuth2Session. There are still cases that developers need to define a custom client authentication method. Take issue #158 as an example, the provider requires us put and on URL when sending POST request: Let’s call this weird authentication method , and this is how we can get our OAuth 2.0 client authenticated: With registered, OAuth 2.0 client will authenticate with the signed URI. It is also possible to assign the function to directly:\n\nNow you can access the protected resources. If you re-use the session, you don’t need to do anything: The above is not the real flow, just like what we did in Fetch Token, we need to create another session ourselves: # token is a dict which must contain ``access_token``, ``token_type``\n\nThere are services that claimed they are providing OAuth API, but with a little differences. Some services even return with the wrong Content Type. Compliance hooks are provided to solve those problems: For instance, Stackoverflow MUST add a parameter in query string to protect users’ resources. And stackoverflow’s response is not in JSON. Let’s fix it: If you find a non standard OAuth 2 services, and you can’t fix it. Please report it in GitHub issues.\n\nFor services that support OpenID Connect, if a scope of is provided, the authorization server will return a value of in response: The remote server may require other parameters for OpenID Connect requests, for instance, it may require a parameter, in this case, you need to generate it yourself, and pass it to : # remember to save this nonce for verification At the last step of , the return value contains a : This is a JWT text, it can not be used unless it is parsed. Authlib has provided tools for parsing and validating OpenID Connect id_token: Get deep inside with and . Learn how to validate JWT claims at JSON Web Token (JWT)."
    },
    {
        "link": "https://docs.authlib.org",
        "document": "The ultimate Python library in building OAuth and OpenID Connect servers. It is designed from low level specifications implementations to high level frameworks integrations, to meet the needs of everyone."
    },
    {
        "link": "https://github.com/lepture/authlib/blob/master/docs/client/oauth2.rst",
        "document": "This documentation covers the common design of a Python OAuth 2.0 client. Authlib provides three implementations of OAuth 2.0 client:\n• implementation of , which is a replacement for requests-oauthlib.\n• implementation of , which is async OAuth 2.0 client powered by HTTPX.\n\n:class:`requests_client.OAuth2Session` and :class:`httpx_client.AsyncOAuth2Client` shares the same API.\n\nThere are also frameworks integrations of :ref:`flask_client`, :ref:`django_client` and :ref:`starlette_client`. If you are using these frameworks, you may have interests in their own documentation.\n\nIf you are not familiar with OAuth 2.0, it is better to read :ref:`intro_oauth2` now.\n\nThere are two steps in OAuth 2 to obtain an access token with authorization code grant type. Initialize the session for reuse:\n\nYou can assign a in case you want to specify the callback url.\n\nUnlike OAuth 1, there is no request token. The first step is to jump to the remote authorization server:\n\nThe returns a tuple of , in real project, you should save the state for later use.\n\nNow head over to the generated authorization url, and grant the authorization.\n\nThe authorization server will redirect you back to your site with a code and state arguments:\n\nUse to obtain access token. This method will also verify the state in case of CSRF attack:\n\nIn real project, this session can not be re-used since you are redirected to another website. You need to create another session yourself:\n\nAuthlib has a built-in Flask/Django integration. Learn from them.\n\nAuthlib client can handle PKCE automatically, just pass to and :\n\nOAuth2Session supports implicit grant type. It can fetch the access token with the of :\n\nVisit this link, and grant the authorization, the OAuth authorization server will redirect back to your redirect_uri, the response url would be something like:\n\nFetch access token from the fragment with method:\n\nThe grant type is supported since Version 0.5. Use and to fetch the access token:\n\nThe grant type is supported since Version 0.5. If no or no user info provided, it would be a request. But it is suggested that you specify a for it:\n\nWhen fetching access token, the authorization server will require a client authentication, Authlib provides three default methods defined by RFC7591:\n\nThe default value is . You can change the auth method with :\n\nIf the authorization server requires other means of authentication, you can construct an for your own need, and pass it to :\n\nIt is also possible to extend the client authentication method with . Besides the default three authentication methods, there are more provided by Authlib. e.g.\n\nThese two methods are defined by RFC7523 and OpenID Connect. Find more in :ref:`jwt_oauth2session`.\n\nThere are still cases that developers need to define a custom client authentication method. Take :issue:`158` as an example, the provider requires us put and on URL when sending POST request:\n\nLet's call this weird authentication method , and this is how we can get our OAuth 2.0 client authenticated:\n\nWith registered, OAuth 2.0 client will authenticate with the signed URI. It is also possible to assign the function to directly:\n\nNow you can access the protected resources. If you re-use the session, you don't need to do anything:\n\nThe above is not the real flow, just like what we did in :ref:`fetch_oauth2_access_token`, we need to create another session ourselves:\n\nIt is possible that your previously saved token is expired when accessing protected resources. In this case, we can refresh the token manually, or even better, Authlib will refresh the token automatically and update the token for us.\n\nIf your :class:`~requests_client.OAuth2Session` class was created with the token_endpoint parameter, Authlib will automatically refresh the token when it has expired:\n\nBy default, the token will be refreshed 60 seconds before its actual expiry time, to avoid clock skew issues. You can control this behaviour by setting the parameter of the :class:`~requests_client.OAuth2Session` class.\n\nTo call :meth:`~requests_client.OAuth2Session.refresh_token` manually means we are going to exchange a new \"access_token\" with \"refresh_token\":\n\nAuthlib can also refresh a new token automatically when requesting resources. This is done by passing a function when constructing the client instance:\n\nWhen sending a request to resources endpoint, if our previously saved token is expired, this will invoke method itself and call this our defined to save the new token:\n\nIf the provider support token revocation and introspection, you can revoke and introspect the token with:\n\nYou can find the available parameters in API docs:\n\nThere are services that claimed they are providing OAuth API, but with a little differences. Some services even return with the wrong Content Type. Compliance hooks are provided to solve those problems:\n\nFor instance, Stackoverflow MUST add a site parameter in query string to protect users' resources. And stackoverflow's response is not in JSON. Let's fix it:\n\nIf you find a non standard OAuth 2 services, and you can't fix it. Please report it in GitHub issues.\n\nFor services that support OpenID Connect, if a scope of is provided, the authorization server will return a value of in response:\n\nThe remote server may require other parameters for OpenID Connect requests, for instance, it may require a parameter, in this case, you need to generate it yourself, and pass it to :\n\nAt the last step of , the return value contains a :\n\nThis is a JWT text, it can not be used unless it is parsed. Authlib has provided tools for parsing and validating OpenID Connect id_token:\n\nGet deep inside with :class:`~authlib.jose.JsonWebToken` and :class:`~authlib.oidc.core.CodeIDToken`. Learn how to validate JWT claims at :ref:`jwt_guide`.\n\n:class:`~requests_client.AssertionSession` is a Requests Session for Assertion Framework of OAuth 2.0 Authorization Grants. It is also know as service account. A configured with handle token authorization automatically, which means you can just use it.\n\nTake Google Service Account as an example, with the information in your service account JSON configure file:\n\nThere is a ready to use in loginpass. You can also read these posts:"
    },
    {
        "link": "https://docs.authlib.org/en/latest/client",
        "document": "This part of the documentation contains information on the client parts. Authlib provides many frameworks integrations, including:\n\nIn order to use Authlib client, you have to install each library yourself. For example, you want to use OAuth clients:\n\nFor instance, you want to use OAuth clients:\n\nHere is a simple overview of Flask OAuth client:\n\nFollow the documentation below to find out more in detail."
    },
    {
        "link": "https://github.com/lepture/authlib",
        "document": "The ultimate Python library in building OAuth and OpenID Connect servers. JWS, JWK, JWA, JWT are included.\n\nBuild your own OAuth 1.0, OAuth 2.0, and OpenID Connect providers:\n\nIf you found security bugs, please do not send a public issue or patch. You can send me email at me@lepture.com. Attachment with patch is welcome. My PGP Key fingerprint is:\n\nOr, you can use the Tidelift security contact. Tidelift will coordinate the fix and disclosure.\n\nIf your company is creating a closed source OAuth provider, it is strongly suggested that your company purchasing a commercial license.\n\nIf you need any help, you can always ask questions on StackOverflow with a tag of \"Authlib\". DO NOT ASK HELP IN GITHUB ISSUES.\n\nWe also provide commercial consulting and supports. You can find more information at https://authlib.org/support."
    }
]