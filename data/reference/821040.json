[
    {
        "link": "https://en.wikipedia.org/wiki/Answer_set_programming",
        "document": "Answer set programming (ASP) is a form of declarative programming oriented towards difficult (primarily NP-hard) search problems. It is based on the stable model (answer set) semantics of logic programming. In ASP, search problems are reduced to computing stable models, and answer set solvers—programs for generating stable models—are used to perform search. The computational process employed in the design of many answer set solvers is an enhancement of the DPLL algorithm and, in principle, it always terminates (unlike Prolog query evaluation, which may lead to an infinite loop).\n\nIn a more general sense, ASP includes all applications of answer sets to knowledge representation and reasoning[1][2] and the use of Prolog-style query evaluation for solving problems arising in these applications.\n\nAn early example of answer set programming was the planning method proposed in 1997 by Dimopoulos, Nebel and Köhler.[3][4] Their approach is based on the relationship between plans and stable models.[5] In 1998 Soininen and Niemelä[6] applied what is now known as answer set programming to the problem of product configuration.[4] In 1999, the term \"answer set programming\" appeared for the first time in a book The Logic Programming Paradigm as the title of a collection of two papers.[4] The first of these papers identified the use of answer set solvers for search as a new programming paradigm.[7] That same year Niemelä also proposed \"logic programs with stable model semantics\" as a new paradigm.[8]\n\nLparse is the name of the program that was originally created as a grounding tool (front-end) for the answer set solver smodels. The language that Lparse accepts is now commonly called AnsProlog,[9] short for Answer Set Programming in Logic.[10] It is now used in the same way in many other answer set solvers, including assat, clasp, cmodels, gNt, nomore++ and pbmodels. (dlv is an exception; the syntax of ASP programs written for dlv is somewhat different.)\n\nAn AnsProlog program consists of rules of the form\n\nThe symbol (\"if\") is dropped if is empty; such rules are called facts. The simplest kind of Lparse rules are rules with constraints.\n\nOne other useful construct included in this language is choice. For instance, the choice rule\n\nsays: choose arbitrarily which of the atoms to include in the stable model. The Lparse program that contains this choice rule and no other rules has 8 stable models—arbitrary subsets of . The definition of a stable model was generalized to programs with choice rules.[11] Choice rules can be treated also as abbreviations for propositional formulas under the stable model semantics.[12] For instance, the choice rule above can be viewed as shorthand for the conjunction of three \"excluded middle\" formulas:\n\nThe language of Lparse allows us also to write \"constrained\" choice rules, such as\n\nThis rule says: choose at least 1 of the atoms , but not more than 2. The meaning of this rule under the stable model semantics is represented by the propositional formula\n\nCardinality bounds can be used in the body of a rule as well, for instance:\n\nAdding this constraint to an Lparse program eliminates the stable models that contain at least 2 of the atoms . The meaning of this rule can be represented by the propositional formula\n\nVariables (capitalized, as in Prolog) are used in Lparse to abbreviate collections of rules that follow the same pattern, and also to abbreviate collections of atoms within the same rule. For instance, the Lparse program\n\nhas the same meaning as\n\nA range is of the form:\n\nwhere start and end are constant-valued arithmetic expressions. A range is a notational shortcut that is mainly used to define numerical domains in a compatible way. For example, the fact\n\nRanges can also be used in rule bodies with the same semantics.\n\nA conditional literal is of the form:\n\nIf the extension of is , the above condition is semantically equivalent to writing in the place of the condition. For example,\n\nTo find a stable model of the Lparse program stored in file we use the command\n\nOption 0 instructs smodels to find all stable models of the program. For instance, if file contains the rules\n\nthen the command produces the output\n\nAn -coloring of a graph is a function such that for every pair of adjacent vertices . We would like to use ASP to find an -coloring of a given graph (or determine that it does not exist).\n\nThis can be accomplished using the following Lparse program:\n\nLine 1 defines the numbers to be colors. According to the choice rule in Line 2, a unique color should be assigned to each vertex . The constraint in Line 3 prohibits assigning the same color to vertices and if there is an edge connecting them.\n\nIf we combine this file with a definition of , such as\n\nand run smodels on it, with the numeric value of specified on the command line, then the atoms of the form in the output of smodels will represent an -coloring of .\n\nThe program in this example illustrates the \"generate-and-test\" organization that is often found in simple ASP programs. The choice rule describes a set of \"potential solutions\"—a simple superset of the set of solutions to the given search problem. It is followed by a constraint, which eliminates all potential solutions that are not acceptable. However, the search process employed by smodels and other answer set solvers is not based on trial and error.\n\nA clique in a graph is a set of pairwise adjacent vertices. The following Lparse program finds a clique of size in a given directed graph, or determines that it does not exist:\n\nThis is another example of the generate-and-test organization. The choice rule in Line 1 \"generates\" all sets consisting of vertices. The constraint in Line 2 \"weeds out\" the sets that are not cliques.\n\nA Hamiltonian cycle in a directed graph is a cycle that passes through each vertex of the graph exactly once. The following Lparse program can be used to find a Hamiltonian cycle in a given directed graph if it exists; we assume that 0 is one of the vertices.\n\nThe choice rule in Line 1 \"generates\" all subsets of the set of edges. The three constraints \"weed out\" the subsets that are not Hamiltonian cycles. The last of them uses the auxiliary predicate (\" is reachable from 0\") to prohibit the vertices that do not satisfy this condition. This predicate is defined recursively in Lines 6 and 7.\n\nThis program is an example of the more general \"generate, define and test\" organization: it includes the definition of an auxiliary predicate that helps us eliminate all \"bad\" potential solutions.\n\nIn natural language processing, dependency-based parsing can be formulated as an ASP problem.[13] The following code parses the Latin sentence \"Puella pulchra in villa linguam latinam discit\", \"the pretty girl is learning Latin in the villa\". The syntax tree is expressed by the arc predicates which represent the dependencies between the words of the sentence. The computed structure is a linearly ordered rooted tree.\n\nThe ASP standardization working group produced a standard language specification, called ASP-Core-2,[14] towards which recent ASP systems are converging. ASP-Core-2 is the reference language for the Answer Set Programming Competition, in which ASP solvers are periodically benchmarked over a number of reference problems.\n\nEarly systems, such as smodels, used backtracking to find solutions. As the theory and practice of Boolean SAT solvers evolved, a number of ASP solvers were built on top of SAT solvers, including ASSAT and Cmodels. These converted ASP formula into SAT propositions, applied the SAT solver, and then converted the solutions back to ASP form. More recent systems, such as Clasp, use a hybrid approach, using conflict-driven algorithms inspired by SAT, without fully converting into a Boolean-logic form. These approaches allow for significant improvements of performance, often by an order of magnitude, over earlier backtracking algorithms.\n\nThe Potassco project acts as an umbrella for many of the systems below, including clasp, grounding systems (gringo), incremental systems (iclingo), constraint solvers (clingcon), action language to ASP compilers (coala), distributed Message Passing Interface implementations (claspar), and many others.\n\nMost systems support variables, but only indirectly, by forcing grounding, by using a grounding system such as Lparse or gringo as a front end. The need for grounding can cause a combinatorial explosion of clauses; thus, systems that perform on-the-fly grounding might have an advantage.[15]\n\nQuery-driven implementations of answer set programming, such as the Galliwasp system[16] and s(CASP)[17] avoid grounding altogether by using a combination of resolution and coinduction."
    },
    {
        "link": "https://doc.ic.ac.uk/~mjs/teaching/KnowledgeRep491/StableModels-2x1.pdf",
        "document": ""
    },
    {
        "link": "https://cs.utexas.edu/~vl/teaching/378/ASP.pdf",
        "document": ""
    },
    {
        "link": "https://doc.ic.ac.uk/~ml1909/teaching/Non-monotonic%20Logic-based%20Learning,%20Summary.pdf",
        "document": ""
    },
    {
        "link": "http://users.ics.aalto.fi/ini/papers/niemela-ecai2010-tutorial-ASP.pdf",
        "document": ""
    },
    {
        "link": "https://cs.utexas.edu/~vl/teaching/378/pwc.pdf",
        "document": ""
    },
    {
        "link": "https://cs.cmu.edu/~cmartens/asp-notes.pdf",
        "document": ""
    },
    {
        "link": "http://w3schools.com/ASp/asp_syntax.asp",
        "document": "All our examples shows the ASP code in red.\n\nThis makes it easier for you to understand how ASP works.\n\nThe default scripting language in ASP is VBScript.\n\nASP files can be ordinary HTML files. In addition, ASP files can also contain server scripts.\n\nScripts surrounded by <% and %> are executed on the server.\n\nThe Response.Write() method is used by ASP to write output to HTML.\n\nThe following example writes \"Hello World\" into HTML:\n\nTo set JavaScript as the scripting language for a web page you must insert a language specification at the top of the page:\n\nThere is an easy shortcut to Response.Write(). You can use an equal sign (=) instead.\n\nThe following example also writes \"Hello World\" into HTML:\n\nHTML tags can be a part of the output:\n\nHTML attributes can be a part of the output:\n\nThis tutorial contains a lot of VBScript examples."
    },
    {
        "link": "https://cs.utexas.edu/~vl/teaching/378/ASP.pdf",
        "document": ""
    },
    {
        "link": "http://wp.doc.ic.ac.uk/arusso/wp-content/uploads/sites/47/2015/01/clingo_guide.pdf",
        "document": ""
    }
]