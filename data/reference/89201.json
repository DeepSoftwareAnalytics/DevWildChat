[
    {
        "link": "https://docs.flutter.dev/ui/layout",
        "document": "The core of Flutter's layout mechanism is widgets. In Flutter, almost everything is a widget—even layout models are widgets. The images, icons, and text that you see in a Flutter app are all widgets. But things you don't see are also widgets, such as the rows, columns, and grids that arrange, constrain, and align the visible widgets. You create a layout by composing widgets to build more complex widgets.\n\nIn the following example, the first screenshot displays three icons with labels and the second screenshot includes the visual layout for rows and columns. In the second screenshot, is set to so you can see the visual layout.\n\nHere's a diagram of the widget tree for the previous example:\n\nMost of this should look as you might expect, but you might be wondering about the containers (shown in pink). is a widget class that allows you to customize its child widget. Use a when you want to add padding, margins, borders, or background color, to name some of its capabilities.\n\nEach widget is placed in a to add margins. The entire is also placed in a to add padding around the row.\n\nThe rest of the UI is controlled by properties. Set an 's color using its property. Use the property to set the font, its color, weight, and so on. Columns and rows have properties that allow you to specify how their children are aligned vertically or horizontally, and how much space the children should occupy.\n\nHow do you lay out a single widget in Flutter? This section shows you how to create and display a simple widget. It also shows the entire code for a simple Hello World app.\n\nIn Flutter, it takes only a few steps to put text, an icon, or an image on the screen.\n\nChoose from a variety of layout widgets based on how you want to align or constrain a visible widget, as these characteristics are typically passed on to the contained widget.\n\nFor example, you could use the layout widget to center a visible widget horizontally and vertically:\n\nChoose a visible widget for your app to contain visible elements, such as text, images, or icons.\n\nFor example, you could use the widget display some text:\n\nAll layout widgets have either of the following:\n• A property if they take a single child—for example, or\n• A property if they take a list of widgets—for example, , , , or .\n\nAdd the widget to the widget:\n\nA Flutter app is itself a widget, and most widgets have a method. Instantiating and returning a widget in the app's method displays the widget.\n\nOne of the most common layout patterns is to arrange widgets vertically or horizontally. You can use a widget to arrange widgets horizontally, and a widget to arrange widgets vertically.\n\nTo create a row or column in Flutter, you add a list of children widgets to a or widget. In turn, each child can itself be a row or column, and so on. The following example shows how it is possible to nest rows or columns inside of rows or columns.\n\nThis layout is organized as a . The row contains two children: a column on the left, and an image on the right:\n\nYou'll implement some of Pavlova's layout code in Nesting rows and columns.\n\nYou control how a row or column aligns its children using the and properties. For a row, the main axis runs horizontally and the cross axis runs vertically. For a column, the main axis runs vertically and the cross axis runs horizontally.\n\nThe and enums offer a variety of constants for controlling alignment.\n\nIn the following example, each of the 3 images is 100 pixels wide. The render box (in this case, the entire screen) is more than 300 pixels wide, so setting the main axis alignment to divides the free horizontal space evenly between, before, and after each image.\n\nColumns work the same way as rows. The following example shows a column of 3 images, each is 100 pixels high. The height of the render box (in this case, the entire screen) is more than 300 pixels, so setting the main axis alignment to divides the free vertical space evenly between, above, and below each image.\n\nWhen a layout is too large to fit a device, a yellow and black striped pattern appears along the affected edge. Here is an example of a row that is too wide:\n\nWidgets can be sized to fit within a row or column by using the widget. To fix the previous example where the row of images is too wide for its render box, wrap each image with an widget.\n\nPerhaps you want a widget to occupy twice as much space as its siblings. For this, use the widget property, an integer that determines the flex factor for a widget. The default flex factor is 1. The following code sets the flex factor of the middle image to 2:\n\nBy default, a row or column occupies as much space along its main axis as possible, but if you want to pack the children closely together, set its to . The following example uses this property to pack the star icons together.\n\nThe layout framework allows you to nest rows and columns inside of rows and columns as deeply as you need. Let's look at the code for the outlined section of the following layout:\n\nThe outlined section is implemented as two rows. The ratings row contains five stars and the number of reviews. The icons row contains three columns of icons and text.\n\nThe widget tree for the ratings row:\n\nThe variable creates a row containing a smaller row of 5-star icons, and text:\n\nThe icons row, below the ratings row, contains 3 columns; each column contains an icon and two lines of text, as you can see in its widget tree:\n\nThe variable contains the ratings and icons rows, as well as the title and text that describes the Pavlova:\n\nThe left column is placed in a to constrain its width. Finally, the UI is constructed with the entire row (containing the left column and the image) inside a .\n\nThe Pavlova image is from Pixabay. You can embed an image from the net using but, for this example, the image is saved to an images directory in the project, added to the pubspec file, and accessed using . For more information, see Adding assets and images.\n\nFlutter has a rich library of layout widgets. Here are a few of those most commonly used. The intent is to get you up and running as quickly as possible, rather than overwhelm you with a complete list. For information on other available widgets, refer to the Widget catalog, or use the Search box in the API reference docs. Also, the widget pages in the API docs often make suggestions about similar widgets that might better suit your needs.\n\nThe following widgets fall into two categories: standard widgets from the widgets library, and specialized widgets from the Material library. Any app can use the widgets library but only Material apps can use the Material Components library.\n\nMany layouts make liberal use of s to separate widgets using padding, or to add borders or margins. You can change the device's background by placing the entire layout into a and changing its background color or image.\n\nThis layout consists of a column with two rows, each containing 2 images. A is used to change the background color of the column to a lighter grey.\n\nA is also used to add a rounded border and margins to each image:\n\nYou can find more examples in the tutorial.\n\nUse to lay widgets out as a two-dimensional list. provides two pre-fabricated lists, or you can build your own custom grid. When a detects that its contents are too long to fit the render box, it automatically scrolls.\n• Detects when the column content exceeds the render box and automatically provides scrolling\n• Build your own custom grid, or use one of the provided grids:\n• allows you to specify the number of columns\n• allows you to specify the maximum pixel width of a tile\n\n, a column-like widget, automatically provides scrolling when its content is too long for its render box.\n• Can be laid out horizontally or vertically\n• Detects when its content won't fit and provides scrolling\n• Less configurable than , but easier to use and supports scrolling\n\nUse to arrange widgets on top of a base widget—often an image. The widgets can completely or partially overlap the base widget.\n• Use for widgets that overlap another widget\n• The first widget in the list of children is the base widget; subsequent children are overlaid on top of that base widget\n• You can choose to clip children that exceed the render box\n\nA , from the Material library, contains related nuggets of information and can be composed from almost any widget, but is often used with . has a single child, but its child can be a column, row, list, grid, or other widget that supports multiple children. By default, a shrinks its size to 0 by 0 pixels. You can use to constrain the size of a card.\n\nIn Flutter, a features slightly rounded corners and a drop shadow, giving it a 3D effect. Changing a 's property allows you to control the drop shadow effect. Setting the elevation to 24, for example, visually lifts the further from the surface and causes the shadow to become more dispersed. For a list of supported elevation values, see Elevation in the Material guidelines. Specifying an unsupported value disables the drop shadow entirely.\n• Used for presenting related nuggets of information\n• Accepts a single child, but that child can be a , , or other widget that holds a list of children\n\nUse , a specialized row widget from the Material library, for an easy way to create a row containing up to 3 lines of text and optional leading and trailing icons. is most commonly used in or , but can be used elsewhere.\n• A specialized row that contains up to 3 lines of text and optional icons\n• Less configurable than , but easier to use\n\nTo fully understand Flutter's layout system, you need to learn how Flutter positions and sizes the components in a layout. For more information, see Understanding constraints.\n\nThe following videos, part of the Flutter in Focus series, explain and widgets.\n\nEach episode of the Widget of the Week series focuses on a widget. Several of them includes layout widgets.\n\nThe following resources might help when writing layout code."
    },
    {
        "link": "https://docs.flutter.dev/get-started/fundamentals/layout",
        "document": "Given that Flutter is a UI toolkit, you'll spend a lot of time creating layouts with Flutter widgets. In this section, you'll learn how to build layouts with some of the most common layout widgets. You'll use Flutter DevTools (also called Dart DevTools) to understand how Flutter is creating your layout. Finally, you'll encounter and debug one of Flutter's most common layout errors, the dreaded \"unbounded constraints\" error.\n\nThe core of Flutter's layout mechanism is widgets. In Flutter, almost everything is a widget — even layout models are widgets. The images, icons, and text that you see in a Flutter app are all widgets. Things you don't see are also widgets, such as the rows, columns, and grids that arrange, constrain, and align the visible widgets.\n\nYou create a layout by composing widgets to build more complex widgets. For example, the diagram below shows 3 icons with a label under each one, and the corresponding widget tree:\n\nIn this example, there's a row of 3 columns where each column contains an icon and a label. All layouts, no matter how complex, are created by composing these layout widgets.\n\nUnderstanding constraints in Flutter is an important part of understanding how layout works in Flutter.\n\nLayout, in a general sense, refers to the size of the widgets and their positions on the screen. The size and position of any given widget is constrained by its parent; it can't have any size it wants, and it doesn't decide its own place on the screen. Instead, size and position are determined by a conversation between a widget and its parent.\n\nIn the simplest example, the layout conversation looks like this:\n• A widget receives its constraints from its parent.\n• A constraint is just a set of 4 doubles: a minimum and maximum width, and a minimum and maximum height.\n• The widget determines what size it should be within those constraints, and passes its width and height back to the parent.\n• The parent looks at the size it wants to be and how it should be aligned, and sets the widget's position accordingly. Alignment can be set explicitly, using a variety of widgets like , and the alignment properties on and .\n\nIn Flutter, this layout conversation is often expressed with the simplified phrase, \"Constraints go down. Sizes go up. Parent sets the position.\"\n\nIn Flutter, widgets are rendered by their underlying objects. These objects determine how to handle the constraints they're passed.\n\nGenerally, there are three kinds of boxes:\n• Those that try to be as big as possible. For example, the boxes used by and .\n• Those that try to be the same size as their children. For example, the boxes used by and\n• Those that try to be a particular size. For example, the boxes used by and .\n\nSome widgets, for example , vary from type to type based on their constructor arguments. The constructor defaults to trying to be as big as possible, but if you give it a width, for instance, it tries to honor that and be that particular size.\n\nOthers, for example and (flex boxes) vary based on the constraints they are given. Read more about flex boxes and constraints in the Understanding Constraints article.\n\nTo lay out a single widget in Flutter, wrap a visible widget, such as or with a widget that can change its position on a screen, such as a widget.\n\nThe following figure shows a widget that isn't aligned on the left, and a widget that has been centered on the right.\n\nAll layout widgets have either of the following:\n• A property if they take a single child—for example, , , or .\n• A property if they take a list of widgets—for example, , , , or .\n\nis a convenience widget that's made up of several widgets responsible for layout, painting, positioning, and sizing. In regard to layout, it can be used to add padding and margins to a widget. There is also a widget that could be used here to the same effect. The following example uses a .\n\nThe following figure shows a widget without padding on the left, and a widget with padding on the right.\n\nTo create more complex layouts in Flutter, you can compose many widgets. For example, you can combine and :\n\nOne of the most common layout patterns is to arrange widgets vertically or horizontally. You can use a widget to arrange widgets horizontally, and a widget to arrange widgets vertically. The first figure on this page used both.\n\nThis is the most basic example of using a widget.\n\nEach child of or can be rows and columns themselves, combining to make a complex layout. For example, you could add labels to each of the images in the example above using columns.\n\nIn the following example, the widgets are each 200 pixels wide, and the viewport is 700 pixels wide. The widgets are consequently aligned to the left, one after the other, with all the extra space on the right.\n\nYou control how a row or column aligns its children using the and properties. For a row, the main axis runs horizontally and the cross axis runs vertically. For a column, the main axis runs vertically and the cross axis runs horizontally.\n\nSetting the main axis alignment to divides the free horizontal space evenly between, before, and after each image.\n\nColumns work the same way as rows. The following example shows a column of 3 images, each is 100 pixels high. The height of the render box (in this case, the entire screen) is more than 300 pixels, so setting the main axis alignment to divides the free vertical space evenly between, above, and below each image.\n\nThe and enums offer a variety of constants for controlling alignment.\n\nFlutter includes other widgets that can be used for alignment, notably the widget.\n\nWhen a layout is too large to fit a device, a yellow and black striped pattern appears along the affected edge. In this example, the viewport is 400 pixels wide, and each child is 150 pixels wide.\n\nWidgets can be sized to fit within a row or column by using the widget. To fix the previous example where the row of images is too wide for its render box, wrap each image with an widget.\n\nThe widget can also dictate how much space a widget should take up relative to its siblings. For example, perhaps you want a widget to occupy twice as much space as its siblings. For this, use the widgets property, an integer that determines the flex factor for a widget. The default flex factor is 1. The following code sets the flex factor of the middle image to 2:\n\nIn certain situations, a box's constraint is unbounded, or infinite. This means that either the maximum width or the maximum height is set to . A box that tries to be as big as possible won't function usefully when given an unbounded constraint and, in debug mode, throws an exception.\n\nThe most common case where a render box ends up with an unbounded constraint is within a flex box ( or ), and within a scrollable region (such as and other subclasses). , for example, tries to expand to fit the space available in its cross-direction (perhaps it's a vertically-scrolling block and tries to be as wide as its parent). If you nest a vertically scrolling inside a horizontally scrolling , the inner list tries to be as wide as possible, which is infinitely wide, since the outer one is scrollable in that direction.\n\nPerhaps the most common error you'll run into while building a Flutter application is due to incorrectly using layout widgets, and is referred to as the \"unbounded constraints\" error.\n\nIf there was only one type error you should be prepared to confront when you first start building Flutter apps, it would be this one.\n\nFlutter has many built-in widgets that automatically scroll and also offers a variety of widgets that you can customize to create specific scrolling behavior. On this page, you'll see how to use the most common widget for making any page scrollable, as well as a widget for creating scrollable lists.\n\nis a column-like widget that automatically provides scrolling when its content is longer than its render box. The most basic way to use a is very similar to using a or . Unlike a column or row, a requires its children to take up all the available space on the cross axis, as shown in the example below.\n\ns are commonly used when you have an unknown or very large (or infinite) number of list items. When this is the case, it's best to use the constructor. The builder constructor only builds the children that are currently visible on screen.\n\nIn the following example, the is displaying a list of to-do items. The todo items are being fetched from a repository, and therefore the number of todos is unknown.\n\nBecause Flutter is used to create mobile, tablet, desktop, and web apps, it's likely you'll need to adjust your application to behave differently depending on things like screen size or input device. This is referred to as making an app adaptive and responsive.\n\nOne of the most useful widgets in making adaptive layouts is the widget. is one of many widgets that uses the \"builder\" pattern in Flutter.\n\nIn Flutter, you'll find several widgets that use the word \"builder\" in their names or in their constructors. The following list isn't exhaustive:\n\nThese different \"builders\" are useful for solving different problems. For example, the constructor is primarily used to lazily render items in a list, while the widget is useful for gaining access to the in deeply widget code.\n\nDespite their different use cases, these builders are unified by how they work. Builder widgets and builder constructors all have arguments called 'builder' (or something similar, like in the case of ), and the builder argument always accepts a callback. This callback is a builder function. Builder functions are callbacks that pass data to the parent widget, and the parent widget uses those arguments to build and return the child widget. Builder functions always pass in at least one argument–the build context– and generally at least one other argument.\n\nFor example, the widget is used to create responsive layouts based on the size of the viewport. The builder callback body is passed the that it receives from its parent, along with the widgets 'BuildContext'. With these constraints, you can return a different widget based on the available space.\n\nIn the following example, the widget returned by the changes based on whether the viewport is less than or equal 600 pixels, or greater than 600 pixels.\n\nMeanwhile, the callback on the constructor is passed the build context and an . This callback is called once for every item in the list, and the int argument represents the index of the list item. The first time the itemBuilder callback is called when Flutter is building the UI, the int passed to the function is 0, the second time it's 1, and so on.\n\nThis allows you to provide specific configuration based on the index. Recall the example above using the constructor:\n\nThis example code uses the index that's passed into the builder to grab the correct todo from the list of items, and then displays that todo's data in the widget that is returned from the builder.\n\nTo exemplify this, the following example changes the background color of every other list item.\n\nAs this section of the website is evolving, we welcome your feedback!"
    },
    {
        "link": "https://stackoverflow.com/questions/51326170/flutter-layout-row-column-share-width-expand-height",
        "document": "I'm still having a bit of trouble with the layouting in Flutter.\n\n Right now I want to have the available space shared between 3 widgets, in a quadrant layout. The width is evenly shared (this works fine via 2 widgets in a Row), but now I also want the height to adjust automatically so . If the content of is larger, I want and to adjust their height and vice versa.\n\nIs this even possible in Flutter?"
    },
    {
        "link": "https://medium.com/flutter-community/flutter-the-advanced-layout-rule-even-beginners-must-know-edc9516d1a2",
        "document": "When someone learning Flutter asks you why some widget with is not 100 pixels wide, the default answer is to tell them to put that widget inside of a , right?\n\nIf you do it, they will come back again and again, asking why some is not working, why that is overflowing, or what is supposed to be doing.\n\nInstead, first tell them that Flutter layout is very different from HTML layout (which is probably where they’re coming from), and then make them memorize the following rule:\n\n👉 Constraints go down. Sizes go up. Positions are set by parents.\n\nFlutter layout can’t really be understood without knowing this rule, so I believe everyone should learn it early on.\n• A widget gets its own constraints from its parent. A “constraint” is just a set of 4 doubles: a minimum and maximum width, and a minimum and maximum height.\n• Then the widget goes through its own list of children. One by one, the widget tells its children what are their constraints (which can be different for each child), and then asks each child which size it wants to be.\n• Then, the widget positions its children (horizontally in the axis, and vertically in the axis), one by one.\n• And, finally, the widget tells its parent about its own size (within the original constraints, of course).\n\nFor example, if a widget is like a column with some padding, and wants to layout its two children:\n\nWidget — Hey parent, what are my constraints? Parent —You must be from to pixels wide, and to tall.\n\n \n\nWidget — Hm, since I want to have pixels of padding, then my children can have at most pixels of width and pixels of height. \n\n \n\n Widget — Hey first child, You must be from to pixels wide, and to tall. First Child — OK, then I wish to be pixels wide, and pixels tall. Widget — Hm, since I want to put my second child below the first one, this leaves only pixels of height for my second child. Widget — Hey second child, You must be from to wide, and to tall. Second Child — OK, I wish to be pixels wide, and pixels tall. Widget — Very Well. I will put my first child into position and , and my second child into and . Widget — Hey parent, I’ve decided that my size is going to be pixels wide, and pixels tall.\n\nAs a result of the above described layout rule, Flutter’s layout engine has a few important limitations:\n• A widget can decide its own size only within the constraints given to it by its parent. This means a widget usually cannot have any size it wants.\n• A widget can’t know and doesn’t decide its own position in the screen, since it’s the widget’s parent who decides the position of the widget.\n• Since the parent’s size and position, in its turn, also depends on its own parent, it’s impossible to precisely define the size and position of any widget without taking into consideration the tree as a whole.\n• Run the CodePen below (you have to click the button first and then click the button that appears in the bottom-right);\n• Or get the most recent code from this GitHub repo.\n\nThe screen is the parent of the . It forces the red to be exactly the same size of the screen.\n\n \n\nSo the fills the screen and it gets all red.\n\nThe red wants to be 100 × 100, but it can’t, because the screen forces it to be exactly the same size of the screen.\n\n \n\nSo the fills the screen.\n\nThe screen forces the to be exactly the same size of the screen. So the fills the screen.\n\nThe tells the it can be any size it wants, but not bigger than the screen. Now the can indeed be 100 × 100.\n\nThis is different from the previous example in that it uses instead of .\n\n \n\nThe also tells the it can be any size it wants, but if there is empty space it will not center the , but will instead align it to the bottom-right of the available space.\n\nThe screen forces the to be exactly the same size of the screen. So the fills the screen.\n\nThe tells the it can be any size it wants, but not bigger than the screen. The wants to be of infinite size, but since it can’t be bigger than the screen, it will just fill the screen.\n\nThe screen forces the to be exactly the same size of the screen. So the fills the screen.\n\nThe tells the it is free to be any size it wants, but not bigger than the screen. Since the has no child and no fixed size, it decides it wants to be as big as possible, so it fits the whole screen.\n\nBut why does the decide that? Simply because that’s a design decision by those who created the widget. It could have been created differently, and you actually have to read the ’s documentation to understand what it will do depending on the circumstances.\n\nThe screen forces the to be exactly the same size of the screen. So the fills the screen.\n\nThe tells the red it can be any size it wants, but not bigger than the screen. Since the red has no size but has a child, it decides it wants to be the same size of its child.\n\nThe red tells its child that it can be any size it wants, but not bigger than the screen.\n\nThe child happens to be a green , that wants to be 30 × 30. As said, the red will size itself to its children size, so it will also be 30 × 30. No red color will be visible, since the green will occupy all of the red .\n\nThe red will size itself to its children size, but it takes its own padding into consideration. So it will be 70 × 70 ( = 30 × 30 plus 20 pixels of padding on all sides). The red color will be visible because of the padding, and the green will have the same size as the previous example.\n\nYou would guess the would have to be between 70 and 150 pixels, but you would be wrong. The only imposes additional constraints than the ones it received from its parent.\n\nHere, the screen forces the to be exactly the same size of the screen, so it will tell its child to also assume the size of the screen, thus ignoring its parameter.\n\nNow, will allow to be any size up to the screen size. The will impose its child the additional constraints from its parameter.\n\nSo the must be between 70 and 150 pixels. It wants to have 10 pixels, so it will end up having 70 (the minimum).\n\nwill allow to be any size up to the screen size. The will impose its child the additional constraints from its parameter.\n\nSo the must be between 70 and 150 pixels. It wants to have 1000 pixels, so it will end up having 150 (the maximum).\n\nwill allow to be any size up to the screen size. The will impose its child the additional constraints from its parameter.\n\nSo the must be between 70 and 150 pixels. It wants to have 100 pixels, and that’s the size it will have, since that’s between 70 and 150.\n\nThe screen forces the to be exactly the same size of the screen. However, the lets its child have any size it wants.\n\nThe screen forces the to be exactly the same size of the screen, and lets its child have any size it wants.\n\nUnfortunately, in this case the has 4000 pixels of width \n\nand is too big to fit in the , so the will display the much dreaded “overflow warning”.\n\nThe screen forces the to be exactly the same size of the screen, and lets its child have any size it wants.\n\n, used like this, is similar to , and the difference is that it won’t display any warnings if the child doesn’t fit the space.\n\nIn this case the has 4000 pixels of width, and is too big to fit in the , but the will simply show what it can, no warnings given.\n\nThis won’t render anything, and you will get an error in the console.\n\nThe lets its child have any size it wants, however its child is a with infinite size.\n\nFlutter can’t render infinite sizes, so it will throw an error with the following message: .\n\nHere you won’t get an error anymore, because when the is given an infinite size by the , it will pass down to its child the maximum width of 100.\n\nNote, if you change the to a widget, the will not apply its limit anymore (since its limit is only applied when it gets infinite constraints), and the width will be allowed to grow past 100.\n\nThis makes it clear the difference between a and a .\n\nThe screen forces the to be exactly the same size of the screen. The will have some natural width (also called its intrinsic width) that depends on the amount of text, its font size, etc.\n\nThe will let the have any size it wants, but after the tells its size to the , the will scale it until it fills all of the available width.\n\nBut what happens if we put the inside of a ? The will let the have any size it wants, up to the screen size.\n\nThe will then size itself to the , and let the have any size it wants. Since both and the have the same size, no scaling will happen.\n\nHowever, what happens if is inside of , but the is too large to fit the screen?\n\nwill try to size itself to the , but it cannot be bigger than the screen. It will then assume the screen size, and resize the so that it fits the screen too.\n\nIf, however, we remove the , the will get its maximum width from the screen, and will break the line so that it fits the screen.\n\nNote can only scale a widget that is bounded (has non infinite width and height). Otherwise, it won’t render anything, and you will get an error in the console.\n\nThe screen forces the to be exactly the same size of the screen.\n\nJust like an , the won’t impose any constraints to its children, and will instead let them have any size they want. The will then put them side by side, and any extra space will remain empty.\n\nSince the won’t impose any constraints to its children, it’s quite possible that the children will be too big to fit the available width. In this case, just like an , the will display the “overflow warning”.\n\nWhen a child is wrapped in an widget, the will not let this child define its own width anymore.\n\nInstead, it will define the width according to the other children, \n\nand only then the widget will force the original child to have the ’s width.\n\nIn other words, once you use , the original child’s width becomes irrelevant, and will be ignored.\n\nIf all children are wrapped in widgets, each will have a size proportional to its flex parameter, and only then each widget will force their child to have the ’s width.\n\nIn other words, the ignores their children preferred width.\n\nThe only difference if you use instead of , is that will let its child have the same or smaller width than the itself, while forces its child to have the exact same width of the .\n\nBut both and will ignore their children widths when sizing themselves.\n\nNote, this means it’s impossible to expand children proportionally to their sizes. The will either use the exact child’s with, or ignore it completely when you use or .\n\nShameless plug: my package assorted_layout_widgets has a special row widget which will resize its cells proportionately to each child width.\n\nThe screen forces the to be exactly the same size of the screen. So the fills the screen.\n\nThe tells the it can be any size it wants, but not bigger than the screen.\n\n \n\nNote: When a widget tells its child it can be smaller than a certain size, we say the widget supplies “loose” constraints to its child. More on that later.\n\nIf we want the ’s child to be exactly the same size as the itself, we can wrap its child into a .\n\n \n\nNote: When a widget tells its child it must be of a certain size, we say the widget supplies “tight” constraints to its child."
    },
    {
        "link": "https://api.flutter.dev/flutter/widgets/LayoutBuilder-class.html",
        "document": "Builds a widget tree that can depend on the parent widget's size.\n\nSimilar to the Builder widget except that the framework calls the builder function at layout time and provides the parent widget's constraints. This is useful when the parent constrains the child's size and doesn't depend on the child's intrinsic size. The LayoutBuilder's final size will match its child's size.\n\nThe builder function is called in the following situations:\n• The first time the widget is laid out.\n• When the parent widget passes different layout constraints.\n• When the parent widget updates this widget.\n• When the dependencies that the builder function subscribes to change.\n\nThe builder function is not called during layout if the parent passes the same constraints repeatedly.\n\nIf the child should be smaller than the parent, consider wrapping the child in an Align widget. If the child might want to be bigger, consider wrapping it in a SingleChildScrollView or OverflowBox.\n• SliverLayoutBuilder, the sliver counterpart of this widget.\n• CustomSingleChildLayout, which positions its child during layout."
    },
    {
        "link": "https://stackoverflow.com/questions/68624440/dynamic-height-of-a-columns-child",
        "document": "Let's say I have this :\n\nWhat I want to achieve is that the always has a flex of 2, and only gets smaller if the screen (or parent) is too small to render both the card and the buttons. However, with the code above, the card gets scaled down to its minimum size to contain the text, although there is space at the end of the screen.\n\n Replacing the card's widget with an widget would fix this, but as I already said, it will never get smaller then, which will end up in a bottom overflow if the screen gets smaller (or the buttons get bigger).\n\nIs there any way to achieve what I want? Or is this just a limitation of Flutter's rendering system?\n\nEdit: I want to avoid making the screen scrollable."
    },
    {
        "link": "https://docs.flutter.dev/ui/layout/constraints",
        "document": "When someone learning Flutter asks you why some widget with isn't 100 pixels wide, the default answer is to tell them to put that widget inside of a , right?\n\nIf you do, they'll come back again and again, asking why some isn't working, why that is overflowing, or what is supposed to be doing.\n\nInstead, first tell them that Flutter layout is very different from HTML layout (which is probably where they're coming from), and then make them memorize the following rule:\n\nFlutter layout can't really be understood without knowing this rule, so Flutter developers should learn it early on.\n• A widget gets its own constraints from its parent. A constraint is just a set of 4 doubles: a minimum and maximum width, and a minimum and maximum height.\n• Then the widget goes through its own list of children. One by one, the widget tells its children what their constraints are (which can be different for each child), and then asks each child what size it wants to be.\n• Then, the widget positions its children (horizontally in the axis, and vertically in the axis), one by one.\n• And, finally, the widget tells its parent about its own size (within the original constraints, of course).\n\nFor example, if a composed widget contains a column with some padding, and wants to lay out its two children as follows:\n\nThe negotiation goes something like this:\n\nWidget: \"Hey parent, what are my constraints?\"\n\nParent: \"You must be from to pixels wide, and to tall.\"\n\nWidget: \"Hmmm, since I want to have pixels of padding, then my children can have at most pixels of width and pixels of height.\"\n\nWidget: \"Hey first child, You must be from to pixels wide, and to tall.\"\n\nFirst child: \"OK, then I wish to be pixels wide, and pixels tall.\"\n\nWidget: \"Hmmm, since I want to put my second child below the first one, this leaves only pixels of height for my second child.\"\n\nWidget: \"Hey second child, You must be from to wide, and to tall.\"\n\nSecond child: \"OK, I wish to be pixels wide, and pixels tall.\"\n\nWidget: \"Very well. My first child has position and , and my second child has and .\"\n\nWidget: \"Hey parent, I've decided that my size is going to be pixels wide, and pixels tall.\"\n\nFlutter's layout engine is designed to be a one-pass process. This means that Flutter lays out its widgets very efficiently, but does result in a few limitations:\n• None A widget can decide its own size only within the constraints given to it by its parent. This means a widget usually can't have any size it wants.\n• None A widget can't know and doesn't decide its own position in the screen, since it's the widget's parent who decides the position of the widget.\n• None Since the parent's size and position, in its turn, also depends on its own parent, it's impossible to precisely define the size and position of any widget without taking into consideration the tree as a whole.\n• None If a child wants a different size from its parent and the parent doesn't have enough information to align it, then the child's size might be ignored. Be specific when defining alignment.\n\nIn Flutter, widgets are rendered by their underlying objects. Many boxes in Flutter, especially those that just take a single child, pass their constraint on to their children.\n\nGenerally, there are three kinds of boxes, in terms of how they handle their constraints:\n• Those that try to be as big as possible. For example, the boxes used by and .\n• Those that try to be the same size as their children. For example, the boxes used by and .\n• Those that try to be a particular size. For example, the boxes used by and .\n\nSome widgets, for example , vary from type to type based on their constructor arguments. The constructor defaults to trying to be as big as possible, but if you give it a , for instance, it tries to honor that and be that particular size.\n\nOthers, for example and (flex boxes) vary based on the constraints they are given, as described in the Flex section.\n\nFor an interactive experience, use the following DartPad. Use the numbered horizontal scrolling bar to switch between 29 different examples.\n\nIf you prefer, you can grab the code from this GitHub repo.\n\nThe examples are explained in the following sections.\n\nThe screen is the parent of the , and it forces the to be exactly the same size as the screen.\n\nSo the fills the screen and paints it red.\n\nThe red wants to be 100 × 100, but it can't, because the screen forces it to be exactly the same size as the screen.\n\nSo the fills the screen.\n\nThe screen forces the to be exactly the same size as the screen, so the fills the screen.\n\nThe tells the that it can be any size it wants, but not bigger than the screen. Now the can indeed be 100 × 100.\n\nThis is different from the previous example in that it uses instead of .\n\nalso tells the that it can be any size it wants, but if there is empty space it won't center the . Instead, it aligns the container to the bottom-right of the available space.\n\nThe screen forces the to be exactly the same size as the screen, so the fills the screen.\n\nThe tells the that it can be any size it wants, but not bigger than the screen. The wants to be of infinite size, but since it can't be bigger than the screen, it just fills the screen.\n\nThe screen forces the to be exactly the same size as the screen, so the fills the screen.\n\nThe tells the that it can be any size it wants, but not bigger than the screen. Since the has no child and no fixed size, it decides it wants to be as big as possible, so it fills the whole screen.\n\nBut why does the decide that? Simply because that's a design decision by those who created the widget. It could have been created differently, and you have to read the API documentation to understand how it behaves, depending on the circumstances.\n\nThe screen forces the to be exactly the same size as the screen, so the fills the screen.\n\nThe tells the red that it can be any size it wants, but not bigger than the screen. Since the red has no size but has a child, it decides it wants to be the same size as its child.\n\nThe red tells its child that it can be any size it wants, but not bigger than the screen.\n\nThe child is a green that wants to be 30 × 30. Given that the red sizes itself to the size of its child, it is also 30 × 30. The red color isn't visible because the green entirely covers the red .\n\nThe red sizes itself to its children's size, but it takes its own padding into consideration. So it is also 30 × 30 plus padding. The red color is visible because of the padding, and the green has the same size as in the previous example.\n\nYou might guess that the has to be between 70 and 150 pixels, but you would be wrong. The only imposes additional constraints from those it receives from its parent.\n\nHere, the screen forces the to be exactly the same size as the screen, so it tells its child to also assume the size of the screen, thus ignoring its parameter.\n\nNow, allows to be any size up to the screen size. The imposes additional constraints from its parameter onto its child.\n\nThe Container must be between 70 and 150 pixels. It wants to have 10 pixels, so it ends up having 70 (the minimum).\n\nallows to be any size up to the screen size. The imposes additional constraints from its parameter onto its child.\n\nThe must be between 70 and 150 pixels. It wants to have 1000 pixels, so it ends up having 150 (the maximum).\n\nallows to be any size up to the screen size. The imposes additional constraints from its parameter onto its child.\n\nThe must be between 70 and 150 pixels. It wants to have 100 pixels, and that's the size it has, since that's between 70 and 150.\n\nThe screen forces the to be exactly the same size as the screen. However, the lets its child be any size it wants.\n\nThe screen forces the to be exactly the same size as the screen, and lets its child be any size it wants.\n\nUnfortunately, in this case the is 4000 pixels wide and is too big to fit in the , so the displays the much dreaded \"overflow warning\".\n\nThe screen forces the to be exactly the same size as the screen, and lets its child be any size it wants.\n\nis similar to ; the difference is that it won't display any warnings if the child doesn't fit the space.\n\nIn this case, the has 4000 pixels of width, and is too big to fit in the , but the simply shows as much as it can, with no warnings given.\n\nThis won't render anything, and you'll see an error in the console.\n\nThe lets its child be any size it wants, however its child is a with infinite size.\n\nFlutter can't render infinite sizes, so it throws an error with the following message:\n\nHere you won't get an error anymore, because when the is given an infinite size by the ; it passes a maximum width of 100 down to its child.\n\nIf you swap the for a widget, the won't apply its limit anymore (since its limit is only applied when it gets infinite constraints), and the width of the is allowed to grow past 100.\n\nThis explains the difference between a and a .\n\nThe screen forces the to be exactly the same size as the screen. The has some natural width (also called its intrinsic width) that depends on the amount of text, its font size, and so on.\n\nThe lets the be any size it wants, but after the tells its size to the , the scales the Text until it fills all of the available width.\n\nBut what happens if you put the inside of a widget? The lets the be any size it wants, up to the screen size.\n\nThe then sizes itself to the , and lets the be any size it wants. Since both and the have the same size, no scaling happens.\n\nHowever, what happens if is inside of a widget, but the is too large to fit the screen?\n\ntries to size itself to the , but it can't be bigger than the screen. It then assumes the screen size, and resizes so that it fits the screen, too.\n\nIf, however, you remove the , the gets its maximum width from the screen, and breaks the line so that it fits the screen.\n\ncan only scale a widget that is bounded (has non-infinite width and height). Otherwise, it won't render anything, and you'll see an error in the console.\n\nThe screen forces the to be exactly the same size as the screen.\n\nJust like an , the won't impose any constraints onto its children, and instead lets them be any size they want. The then puts them side-by-side, and any extra space remains empty.\n\nSince won't impose any constraints onto its children, it's quite possible that the children might be too big to fit the available width of the . In this case, just like an , the displays the \"overflow warning\".\n\nWhen a 's child is wrapped in an widget, the won't let this child define its own width anymore.\n\nInstead, it defines the width according to the other children, and only then the widget forces the original child to have the 's width.\n\nIn other words, once you use , the original child's width becomes irrelevant, and is ignored.\n\nIf all of 's children are wrapped in widgets, each has a size proportional to its flex parameter, and only then each widget forces its child to have the 's width.\n\nIn other words, ignores the preferred width of its children.\n\nThe only difference if you use instead of , is that lets its child have the same or smaller width than the itself, while forces its child to have the exact same width of the . But both and ignore their children's width when sizing themselves.\n\nThe screen forces the to be exactly the same size as the screen, so the fills the screen. The tells the that it can be any size it wants, but not bigger than the screen.\n\nIf you want the 's child to be exactly the same size as the itself, you can wrap its child with .\n\nIt's very common to hear that some constraint is \"tight\" or \"loose\", so what does that mean?\n\nA tight constraint offers a single possibility, an exact size. In other words, a tight constraint has its maximum width equal to its minimum width; and has its maximum height equal to its minimum height.\n\nAn example of this is the widget, which is contained by the class: the box used by the child returned by the application's function is given a constraint that forces it to exactly fill the application's content area (typically, the entire screen).\n\nAnother example: if you nest a bunch of boxes inside each other at the root of your application's render tree, they'll all exactly fit in each other, forced by the box's tight constraints.\n\nIf you go to Flutter's file and search for the constructors, you'll find the following:\n\nIf you revisit Example 2, the screen forces the red to be exactly the same size as the screen. The screen achieves that, of course, by passing tight constraints to the .\n\nA loose constraint is one that has a minimum of zero and a maximum non-zero.\n\nSome boxes loosen the incoming constraints, meaning the maximum is maintained but the minimum is removed, so the widget can have a minimum width and height both equal to zero.\n\nUltimately, 's purpose is to transform the tight constraints it received from its parent (the screen) to loose constraints for its child (the ).\n\nIf you revisit Example 3, the allows the red to be smaller, but not bigger than the screen.\n\nIn certain situations, a box's constraint is unbounded, or infinite. This means that either the maximum width or the maximum height is set to .\n\nA box that tries to be as big as possible won't function usefully when given an unbounded constraint and, in debug mode, throws an exception.\n\nThe most common case where a render box ends up with an unbounded constraint is within a flex box ( or ), and within a scrollable region (such as and other subclasses).\n\n, for example, tries to expand to fit the space available in its cross-direction (perhaps it's a vertically-scrolling block and tries to be as wide as its parent). If you nest a vertically scrolling inside a horizontally scrolling , the inner list tries to be as wide as possible, which is infinitely wide, since the outer one is scrollable in that direction.\n\nThe next section describes the error you might encounter with unbounded constraints in a widget.\n\nA flex box ( and ) behaves differently depending on whether its constraint is bounded or unbounded in its primary direction.\n\nA flex box with a bounded constraint in its primary direction tries to be as big as possible.\n\nA flex box with an unbounded constraint in its primary direction tries to fit its children in that space. Each child's value must be set to zero, meaning that you can't use when the flex box is inside another flex box or a scrollable; otherwise it throws an exception.\n\nThe cross direction (width for or height for ), must never be unbounded, or it can't reasonably align its children.\n\nKnowing the general layout rule is necessary, but it's not enough.\n\nEach widget has a lot of freedom when applying the general rule, so there is no way of knowing how it behaves by just reading the widget's name.\n\nIf you try to guess, you'll probably guess wrong. You can't know exactly how a widget behaves unless you've read its documentation, or studied its source-code.\n\nThe layout source-code is usually complex, so it's probably better to just read the documentation. However, if you decide to study the layout source-code, you can easily find it by using the navigating capabilities of your IDE.\n• None Find a in your code and navigate to its source code. To do this, use (macOS) or (Windows/Linux) in Android Studio or IntelliJ. You'll be taken to the file. Since extends , navigate to the source code (also in ).\n• None Scroll down until you find a method called . As you can see, this method returns a . This is the render-object for the . Now navigate to the source-code of , which takes you to the file.\n• None Scroll down until you find a method called . This is the method that does the layout for the .\n\nMarcelo originally published this content as Flutter: The Advanced Layout Rule Even Beginners Must Know on Medium. We loved it and asked that he allow us to publish in on docs.flutter.dev, to which he graciously agreed. Thanks, Marcelo! You can find Marcelo on GitHub and pub.dev.\n\nAlso, thanks to Simon Lightfoot for creating the header image at the top of the article."
    },
    {
        "link": "https://stackoverflow.com/questions/73469893/how-can-stretch-height-of-one-of-child-widget-according-to-another-widget-in-a-r",
        "document": "I wanted to get same dynamic height of right widget to left widget in Row Widget.Below I was attaching screenshot of my expected design. Could you help how can do that.\n\nWe can see right side date widget is expanding , So I wanted to get the height of left side widget(blue and purple) same as right side widget.\n\nIf left side image widget is not possible to expand the height then is any there any possible to create custom widget, Any solution is welcome. Thanks in advance.\n\nAfter Using IntrinsicHeight I was unable to remove default padding around the icons"
    },
    {
        "link": "https://medium.com/@ximya/get-dynamic-widget-size-in-flutter-f3e12c52ce1f",
        "document": "When working with UI in Flutter, there are often cases where you need to measure the size of widgets that have variable sizes depending on their child widgets. Let’s take the example of an OTT streaming app.\n\nIn the movie detail page, the plot section shows both text and images. If this area exceeds a certain height, a ‘More’ button appears, partially hiding the content. Pressing ‘More’ reveals the rest of the content.\n\nThis plot section does not have a fixed size. Rather, its height varies dynamically based on the amount of text data, device width, and image height. Therefore, to implement such a UI structure, it’s necessary to measure the rendered height of the widget and conditionally set up UI elements like the ‘more’ button and the hidden content based on whether it exceeds a certain height.\n\nSo, how can we measure the dynamic size of widgets? In this post, we’ll explore step-by-step how to measure the variable size of widgets through a simple example. Additionally, we’ll delve into the following concepts, addressing Flutter’s rendering process.\n\nLet’s briefly examine the example we’ll cover in the post.\n\nThe above screenshot depicts a simple page displaying information about movie cast members. It consists of a Text widget for the title section and a ListView widget with ExpansionTile displaying information about the cast members, all wrapped inside a Column. The Text widget for the title section shows the current height of the Column.\n\nWhen you click on the ExpansionTile, the widget expands to show detailed information about the cast members. Therefore, the size of the widget changes, requiring adjustment of the height value accordingly. We can summarize the following requirements.\n\nFirst, let’s take a look at how widgets are drawn on the screen in Flutter.\n\nYou’ve probably heard about the concept that Flutter creates widgets based on a 3 Tree Architecture consisting of , , and . You may not be very familiar with encountering objects of elements or render trees during Flutter development, as it's not very common. However, understanding the basic concepts of Flutter's widget tree structure can be very helpful when direct manipulation or access to element or render objects is required, as in this example. So, let's try to explain it in a way that's easier to understand.\n\nTo help understand the three tree structures of widgets, let’s use the analogy of building a Lamborghini. To build a car, various components such as color, engine, etc., need to be determined. In the above code, we’re passing necessary options to the Car class within the method.\n\nThis process is similar to creating a blueprint for the car, defining how the car’s components are structured and shaped. StatelessWidget or StatefulWidget always override the method and return a widget inside. These codes are returned as a and internally create the necessary 'element' through .\n\nThe generated from the is comprised of elements that are part of widgets and are responsible for managing widget lifecycle and state changes. While the contains structural information about the code written by developers, the consists of pieces of widgets created based on the widget tree.\n\nIf the widget tree is likened to a blueprint of a car, the in the can be compared to both the and the managing those parts. Just as a car engineer arranges and manages necessary parts according to the blueprint, the element tree creates elements that are parts of the UI needed for the final rendering of widgets and communicates any to the render tree as necessary. Now, let's take a closer look at the characteristics of elements.\n\nAll Flutter widgets are , meaning their content cannot be modified during runtime. This is similar to a car not being able to suddenly transform into a motorcycle. However, elements are , allowing widgets to be changed as needed. In other words, elements can be removed and replaced with new elements.\n\nThe , which we always pass as an argument when executing the method in StatelessWidget or StatefulWidget, is used when direct manipulation or access to the Element object is required. It also indicates where the Element created from the widget tree is positioned in the tree. It's like an engineer (BuildContext) examining the blueprint (Widget Tree) to determine where the necessary parts (Element) are and arranging them accordingly.\n\nSimilarly, when displaying a popup using methods like showDialog, we always need to pass the because we need to know which widget (screen) in the composed tree the dialog should appear on.\n\nOnce the necessary elements are created, the widget finally creates a . It's used to handle the actual rendering via the widget's method, which creates a RenderObject, an object that manages the widget's size and layout information. During this process, the , created from the Element Tree, becomes directly involved.\n\nThe rendering tree can be likened to the . It completes the car using the components manufactured from the Element Tree.\n\nIn the rendering tree, two main methods, and , are used to actually render the widgets we see. During the phase, parent nodes pass constraints to child nodes, and at the lowest level, the final size information is passed back up to determine where and how widgets should be drawn. Then, the operation is performed, passing the work to the GPU thread to finally complete the widgets.\n\nWhat If it Wasn’t Composed of Three Widget Trees?\n\nNow that you have some understanding of the architecture of the widget tree, you can clearly understand the reason why widgets are composed of three widget trees. If you were to replace a wheel on a car, you wouldn’t need to rebuild the entire car from scratch. You’d simply replace the existing wheel with a new one. Flutter operates on a similar principle. When parts of a rendered widget need to change based on state, the corresponding element detects this and communicates the changes to the render tree, allowing only the necessary parts to be re-rendered.\n\nHowever, if Flutter’s widget tree were composed of only one tree, even widgets that didn’t need to change based on state would be redrawn, leading to inefficiencies. It would be like building a new car every time you change a wheel.\n\nIn summary, the fundamental reason Flutter’s widgets are composed of three tree structures is to efficiently re-render only the necessary parts of the screen when changes are needed based on state."
    },
    {
        "link": "https://medium.com/flutter-community/flutter-the-advanced-layout-rule-even-beginners-must-know-edc9516d1a2",
        "document": "When someone learning Flutter asks you why some widget with is not 100 pixels wide, the default answer is to tell them to put that widget inside of a , right?\n\nIf you do it, they will come back again and again, asking why some is not working, why that is overflowing, or what is supposed to be doing.\n\nInstead, first tell them that Flutter layout is very different from HTML layout (which is probably where they’re coming from), and then make them memorize the following rule:\n\n👉 Constraints go down. Sizes go up. Positions are set by parents.\n\nFlutter layout can’t really be understood without knowing this rule, so I believe everyone should learn it early on.\n• A widget gets its own constraints from its parent. A “constraint” is just a set of 4 doubles: a minimum and maximum width, and a minimum and maximum height.\n• Then the widget goes through its own list of children. One by one, the widget tells its children what are their constraints (which can be different for each child), and then asks each child which size it wants to be.\n• Then, the widget positions its children (horizontally in the axis, and vertically in the axis), one by one.\n• And, finally, the widget tells its parent about its own size (within the original constraints, of course).\n\nFor example, if a widget is like a column with some padding, and wants to layout its two children:\n\nWidget — Hey parent, what are my constraints? Parent —You must be from to pixels wide, and to tall.\n\n \n\nWidget — Hm, since I want to have pixels of padding, then my children can have at most pixels of width and pixels of height. \n\n \n\n Widget — Hey first child, You must be from to pixels wide, and to tall. First Child — OK, then I wish to be pixels wide, and pixels tall. Widget — Hm, since I want to put my second child below the first one, this leaves only pixels of height for my second child. Widget — Hey second child, You must be from to wide, and to tall. Second Child — OK, I wish to be pixels wide, and pixels tall. Widget — Very Well. I will put my first child into position and , and my second child into and . Widget — Hey parent, I’ve decided that my size is going to be pixels wide, and pixels tall.\n\nAs a result of the above described layout rule, Flutter’s layout engine has a few important limitations:\n• A widget can decide its own size only within the constraints given to it by its parent. This means a widget usually cannot have any size it wants.\n• A widget can’t know and doesn’t decide its own position in the screen, since it’s the widget’s parent who decides the position of the widget.\n• Since the parent’s size and position, in its turn, also depends on its own parent, it’s impossible to precisely define the size and position of any widget without taking into consideration the tree as a whole.\n• Run the CodePen below (you have to click the button first and then click the button that appears in the bottom-right);\n• Or get the most recent code from this GitHub repo.\n\nThe screen is the parent of the . It forces the red to be exactly the same size of the screen.\n\n \n\nSo the fills the screen and it gets all red.\n\nThe red wants to be 100 × 100, but it can’t, because the screen forces it to be exactly the same size of the screen.\n\n \n\nSo the fills the screen.\n\nThe screen forces the to be exactly the same size of the screen. So the fills the screen.\n\nThe tells the it can be any size it wants, but not bigger than the screen. Now the can indeed be 100 × 100.\n\nThis is different from the previous example in that it uses instead of .\n\n \n\nThe also tells the it can be any size it wants, but if there is empty space it will not center the , but will instead align it to the bottom-right of the available space.\n\nThe screen forces the to be exactly the same size of the screen. So the fills the screen.\n\nThe tells the it can be any size it wants, but not bigger than the screen. The wants to be of infinite size, but since it can’t be bigger than the screen, it will just fill the screen.\n\nThe screen forces the to be exactly the same size of the screen. So the fills the screen.\n\nThe tells the it is free to be any size it wants, but not bigger than the screen. Since the has no child and no fixed size, it decides it wants to be as big as possible, so it fits the whole screen.\n\nBut why does the decide that? Simply because that’s a design decision by those who created the widget. It could have been created differently, and you actually have to read the ’s documentation to understand what it will do depending on the circumstances.\n\nThe screen forces the to be exactly the same size of the screen. So the fills the screen.\n\nThe tells the red it can be any size it wants, but not bigger than the screen. Since the red has no size but has a child, it decides it wants to be the same size of its child.\n\nThe red tells its child that it can be any size it wants, but not bigger than the screen.\n\nThe child happens to be a green , that wants to be 30 × 30. As said, the red will size itself to its children size, so it will also be 30 × 30. No red color will be visible, since the green will occupy all of the red .\n\nThe red will size itself to its children size, but it takes its own padding into consideration. So it will be 70 × 70 ( = 30 × 30 plus 20 pixels of padding on all sides). The red color will be visible because of the padding, and the green will have the same size as the previous example.\n\nYou would guess the would have to be between 70 and 150 pixels, but you would be wrong. The only imposes additional constraints than the ones it received from its parent.\n\nHere, the screen forces the to be exactly the same size of the screen, so it will tell its child to also assume the size of the screen, thus ignoring its parameter.\n\nNow, will allow to be any size up to the screen size. The will impose its child the additional constraints from its parameter.\n\nSo the must be between 70 and 150 pixels. It wants to have 10 pixels, so it will end up having 70 (the minimum).\n\nwill allow to be any size up to the screen size. The will impose its child the additional constraints from its parameter.\n\nSo the must be between 70 and 150 pixels. It wants to have 1000 pixels, so it will end up having 150 (the maximum).\n\nwill allow to be any size up to the screen size. The will impose its child the additional constraints from its parameter.\n\nSo the must be between 70 and 150 pixels. It wants to have 100 pixels, and that’s the size it will have, since that’s between 70 and 150.\n\nThe screen forces the to be exactly the same size of the screen. However, the lets its child have any size it wants.\n\nThe screen forces the to be exactly the same size of the screen, and lets its child have any size it wants.\n\nUnfortunately, in this case the has 4000 pixels of width \n\nand is too big to fit in the , so the will display the much dreaded “overflow warning”.\n\nThe screen forces the to be exactly the same size of the screen, and lets its child have any size it wants.\n\n, used like this, is similar to , and the difference is that it won’t display any warnings if the child doesn’t fit the space.\n\nIn this case the has 4000 pixels of width, and is too big to fit in the , but the will simply show what it can, no warnings given.\n\nThis won’t render anything, and you will get an error in the console.\n\nThe lets its child have any size it wants, however its child is a with infinite size.\n\nFlutter can’t render infinite sizes, so it will throw an error with the following message: .\n\nHere you won’t get an error anymore, because when the is given an infinite size by the , it will pass down to its child the maximum width of 100.\n\nNote, if you change the to a widget, the will not apply its limit anymore (since its limit is only applied when it gets infinite constraints), and the width will be allowed to grow past 100.\n\nThis makes it clear the difference between a and a .\n\nThe screen forces the to be exactly the same size of the screen. The will have some natural width (also called its intrinsic width) that depends on the amount of text, its font size, etc.\n\nThe will let the have any size it wants, but after the tells its size to the , the will scale it until it fills all of the available width.\n\nBut what happens if we put the inside of a ? The will let the have any size it wants, up to the screen size.\n\nThe will then size itself to the , and let the have any size it wants. Since both and the have the same size, no scaling will happen.\n\nHowever, what happens if is inside of , but the is too large to fit the screen?\n\nwill try to size itself to the , but it cannot be bigger than the screen. It will then assume the screen size, and resize the so that it fits the screen too.\n\nIf, however, we remove the , the will get its maximum width from the screen, and will break the line so that it fits the screen.\n\nNote can only scale a widget that is bounded (has non infinite width and height). Otherwise, it won’t render anything, and you will get an error in the console.\n\nThe screen forces the to be exactly the same size of the screen.\n\nJust like an , the won’t impose any constraints to its children, and will instead let them have any size they want. The will then put them side by side, and any extra space will remain empty.\n\nSince the won’t impose any constraints to its children, it’s quite possible that the children will be too big to fit the available width. In this case, just like an , the will display the “overflow warning”.\n\nWhen a child is wrapped in an widget, the will not let this child define its own width anymore.\n\nInstead, it will define the width according to the other children, \n\nand only then the widget will force the original child to have the ’s width.\n\nIn other words, once you use , the original child’s width becomes irrelevant, and will be ignored.\n\nIf all children are wrapped in widgets, each will have a size proportional to its flex parameter, and only then each widget will force their child to have the ’s width.\n\nIn other words, the ignores their children preferred width.\n\nThe only difference if you use instead of , is that will let its child have the same or smaller width than the itself, while forces its child to have the exact same width of the .\n\nBut both and will ignore their children widths when sizing themselves.\n\nNote, this means it’s impossible to expand children proportionally to their sizes. The will either use the exact child’s with, or ignore it completely when you use or .\n\nShameless plug: my package assorted_layout_widgets has a special row widget which will resize its cells proportionately to each child width.\n\nThe screen forces the to be exactly the same size of the screen. So the fills the screen.\n\nThe tells the it can be any size it wants, but not bigger than the screen.\n\n \n\nNote: When a widget tells its child it can be smaller than a certain size, we say the widget supplies “loose” constraints to its child. More on that later.\n\nIf we want the ’s child to be exactly the same size as the itself, we can wrap its child into a .\n\n \n\nNote: When a widget tells its child it must be of a certain size, we say the widget supplies “tight” constraints to its child."
    }
]