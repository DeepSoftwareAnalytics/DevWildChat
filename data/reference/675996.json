[
    {
        "link": "https://wiki.libsdl.org/SDL2/SDL_CreateRenderer",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/70585370/sdl-renderer-not-initating-a-window",
        "document": "Find centralized, trusted content and collaborate around the technologies you use most. Learn more about Collectives\n\nConnect and share knowledge within a single location that is structured and easy to search. Learn more about Teams\n\nGet early access and see previews of new features. Learn more about Labs"
    },
    {
        "link": "https://wiki.libsdl.org/SDL2/SDL_CreateWindowAndRenderer",
        "document": "the width of the window."
    },
    {
        "link": "https://github.com/libsdl-org/SDL/issues/12461",
        "document": "Is this intended or a bug? If it's intended, it's not documented.\n\nSetting the texture scale mode will apply retroactively on that texture to all previous render copy calls up to the previous call to render present.\n\nThis is illustrated with the below code. Shows comparison between scale mode and other properties. the color mod doesn't act this way.\n\nThe line is required to make the rendering window look as I am intending. Use a very small (e.g. 16x16) test image to show the difference.\n\n800 600 ( , []) { ; ; ( ); ( ); ( , . , . , . ); ( , . , . , . ); ( ( ) ) { ( , ()); ; } (!( ( ) )) { ( , ()); (); ; } ( , , , , , ); (! ) { ( \"Window could not be created! SDL_Error: %s\n\n\" , ()); (); (); ; } ( , , ); (! ) { ( \"Renderer could not be created! SDL_Error: %s\n\n\" , ()); ( ); (); (); ; } ( , ); (! ) { ( , ()); ( ); ( ); (); (); ; } { , , , }; ( ); ( , , , ); ( , , , ); . . ; ( , , , ); ( , , , ); ( ); ( , ); . . ; ( , , , ); ( ); ( ); ( ); ( ); ( ); (); (); ; }"
    },
    {
        "link": "https://stackoverflow.com/questions/57704512/how-do-i-create-a-functional-function-that-creates-a-sdl-window-and-renderer-wh",
        "document": "I have recently started learning the C programming language and the SDL game development library. My objective with these two is to create several 2D games before graduating to something higher. In attempting my first game engine, I ran into no problem whatsoever because it was that basic; it consisted only of initializing SDL, loading surfaces and textures, and using keyboard events to control the positions of these textures onscreen. Now, in creating my second game engine I am not so lucky and have run into a problem - which is why I am here. The problem stems from a very basic function that, when two arguments - a SDL window and renderer - are passed, creates a window along with a renderer. The function doesn't do its job!\n\nWith several google searches, I found out that the underlying cause of my function not working as it should was pointers. Though I have tried the proposed solutions, none managed to fix my problem.\n\nMy first program (before research) is as below:\n\nThis piece of code compiled with no error but unfortunately, when run, the renderer did not draw green to the window, as it should have done.\n\nMy second program (after research) is as below:\n\nAfter my online help on pointers, I tried the above code and still yielded the same results."
    },
    {
        "link": "https://stackoverflow.com/questions/19167486/memory-efficient-resourcemanager-for-sdl-textures",
        "document": "There's a variety of different ways to do this. You should consider using some sort of hash table that relates your keys (string names) to your objects. Instead of a manager, the idea is more of a locator, because a manager implies that it controls the lifetime of the objects. Investigate how XNA's ContentManager works for an example of a really nice API for resource management. This is C#, obviously, but the API is really clean and friendly.\n\nSo my suggestion is, for basic resource location, you should use a unordered map. You can wrap it if you'd like to add more functionality, such as lifetime management or content loading.\n\nBased on your example, you could wrap the hash set and add your own templated Load method that works something like:\n\nThis is obviously a crude example of resource management, but there is much more to learn about this topic in general. I suggest reading up on data structures (such as linked listsand binary trees) in general, and then look into design patterns like factory, singleton, and builder. These are just starting points, but are good enough to point you in the right direction for this kind of stuff. Good luck!"
    },
    {
        "link": "https://stackoverflow.com/questions/35331901/c-sdl-memory-management",
        "document": "I'm working on a simple scrolling space shooter. I have a Sprite class inherited by Entity Class objects. I'm getting memory leak from these objects. I tested this with the main menu for this game and I believe the issue lies within the sprite class.\n\nThe issue with the memory seems to be that I am not SDL_Destroy..ing the texture and renderer. However, by destroying the texture, I get wild results with one texture being substituted for another, or no texture at all. If I destroy the renderer, no images will load. If I destroy neither then everything loads fine, but there's memory leak.\n\nI believe the wild textures have to do with the way I'm handling vectors of objects, but I don't know of another way to handle them..\n\nI have several vectors that produce bullets, asteroids, etc.. That all use the Sprite class. I use code similar to this to handle their deletion when they are no longer needed:\n\nThe Asteroid class is just one of the classes that is changing images randomly.. It inherits Entity, which inherits Sprite.. not sure if it's also leaking memory. It's hard to test with everything else..\n\nhere is the asteroid class:\n\nI'm new to C++, but learning quick. If anyone could point me in the right direction, I'd appreciate it."
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/152838/how-to-properly-manage-memory-in-sdl2",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://discourse.libsdl.org/t/properly-doing-surface-texture-code-and-structure/20006",
        "document": "I’m creating my first major application with SDL after making multiple small ones. Right now I want to make sure I set myself up right for the future so I don’t run into problems, but I’ll describe the main one I run into and hopefully someone can shed some light on the issue: Right now my game is a tile-based one, so I have a bunch of static textures that never really need modifying. Drawing a bunch of them on screen in fullscreen accelerated mode yields 1000fps+ which is awesome. Note I have read the article on why FPS drops are not the end-all-be-all because of how it’s measured (so I understand 1000 to 500 is not as drastic as 30 to 15 for example) The performance hit I’m getting is coming from my console text rendering. Right now lets say we have 10 lines being rendered from a stored log of messages. Every frame (yes this is a bad idea on paper; I know) I use TTF to create a surface, then convert to texture with SDL_CreateTextureFromSurface() and then push that to the renderer. Creating a texture from a surface is quite expensive and is probably causing the major performance hit. I might be doing it wrong (I’m freeing everything and have no memory leaks), but I don’t understand how creating so many strings is causing such a significant performance hit. Maybe creating strings is just expensive in general, but this leads me to a few questions:\n• Since my game is heavily ‘sprite’ based, would it be better to:\n• Stay in the surface area and just do SDL_UpdateWindowSurface()?\n• Do textures by writing everything to a ‘screen’ surface and push as a texture that at the end?\n• Cache as much as possible to textures and strictly do textures?\n• My large fps drop is coming from the expensive operation of SDL_CreateTextureFromSurface() when attempting to take console log text and render it in the console every frame, what is the best way to handle this? Some thoughts I have are:\n• Keep everything as surfaces and just write them to the surface and push that at the end to a texture\n• Convert strings to a texture and only create new textures when new strings are needed for rendering (so if were displaying lines 10-20, then cache lines 10-20 as textures and just draw those, only update when we want to see 11-21 or such so only 10 textures are in memory at a time, and creation is only done when there’s an update)\n• Compose an alphabet of textures, and then just dynamically render the strings letter by letter each frame\n\n *Note that I am running SDL_CreateTextureFromSurface() every frame for x number of strings (create surface with TTF, surface => texture, rendercopy)\n• Are surfaces better with software and textures better with hardware/accelerated? Or is it best to always go textures now no matter what?\n• Should I keep the surfaces around in memory with the textures? I don’t know if its easier to access pixel data that way instead of constantly polling the texture\n• Would there be any reason to have a texture that is ‘streaming’? This may be answered previously, but if there is, why would one use that rather than doing it all surface and pushing it at the very end to the renderer?\n\n How expensive is making a texture from a large surface? Like should I expect a significant processing power hit from lets say converting a final surface thats 800x600 to a texture before pushing?\n• Slightly off topic: Is there a need to use SDL_Delay() at all? Or should I use SDL_Delay(1) at least once after a frame is rendered to possibly not choke the operating system? Any input or help is greatly appreciated\n• My large fps drop is coming from the expensive operation of\n\n SDL_CreateTextureFromSurface() when attempting to take console log text and\n\n render it in the console every frame, what is the best way to handle this?\n\n Some thoughts I have are:\n• Compose an alphabet of textures, and then just dynamically render the\n\n strings letter by letter each frame\n\n *Note that I am running SDL_CreateTextureFromSurface() every frame for x\n\n number of strings (create surface with TTF, surface => texture, rendercopy) This is what I’d suggest. Depending on the design of your tile engine,\n\n it might work well as a basis for this sort of system (note: I’d\n\n suggest placing each letter in the same texture, so that if the entire\n\n texture was displayed at once it’d look like a list of letters). If you actually do this, then I’d definitely suggest keeping the\n\n result in a different file than everything else, so that you’ll have\n\n an easier time refining and reusing your “textured console” in the\n\n future.\n• Convert strings to a texture and only create new textures when new strings\n\n are needed for rendering (so if were displaying lines 10-20, then cache\n\n lines 10-20 as textures and just draw those, only update when we want to see\n\n 11-21 or such so only 10 textures are in memory at a time, and creation is\n\n only done when there’s an update) For SDL I probably wouldn’t do this, with one exception: Ryan has\n\n mentioned a method of using a shader script to convert a 8-bit\n\n paletted image into a 32-bit “true color” image. I haven’t ever spent\n\n the time to figure out if this is possible (or how to do it if it is)\n\n but if you’ve used shaders before then you might try using one to\n\n treat a one dimensional image as a reference into an “alphabet\n\n texture”. Regretfully I think this may be beyond the current SDL2 api (there was\n\n a recent conversation about some sort of buffering of the render\n\n state) so this probably belongs firmly in the “for future\n\n consideration” category. This is also certainly more complex, but if\n\n you do keep the text display code as a separate piece of code from all\n\n of the other rendering, then this version should be able to use the\n\n same interface as the normal version, and thus would be a relatively\n\n straight-forward path for a future upgrade.\n• Are surfaces better with software and textures better with\n\n hardware/accelerated? Or is it best to always go textures now no matter\n\n what? In software renderers, textures are implemented AS surfaces, so little\n\n difference there. For hardware/accelerated, textures will usually be\n\n better because:\n• They’re already on the graphics card, and thus can use a\n\n hopefully-faster local bus on the card, instead of having to go\n\n through both that local bus AND the motherboard bus;\n• GPUs stereotypically have a large number of somewhat simplified\n\n processor cores that act as an array, instead of 1 to 8 cores that act\n\n independently. Thus, anything that the graphics cores have the\n\n capability to handle (note: because they’re special-purpose, there\n\n apparently have limits on conditionals), AND which can be broken down\n\n into a set of mostly identical procedures (remember: limited\n\n branching) is something that the GPU will automatically be faster at,\n\n because while the CPU could do one more complex version, the GPU could\n\n do 8 (or 800) simpler versions. So, for software it mostly doesn’t matter. For hardware, it can\n\n potentially be a massive difference, if you can keep the code simple\n\n enough.\n• Should I keep the surfaces around in memory with the textures? I don’t\n\n know if its easier to access pixel data that way instead of constantly\n\n polling the texture If you want to occasionally (or often) read the pixel data, and you\n\n AREN’T going to be modifying it, then yes, keep a copy of the surface\n\n in the same location as you keep the texture, so that you can avoid\n\n transferring data back and forth between MB and graphics card. If\n\n you’re going to be modifying either of them then you’ll need to sync\n\n them, which will reduce the effectiveness of this buffering technique\n\n (though if you only modify small portions, or read even twice as often\n\n as you modify, then this can potentially still be a good idea).\n• Slightly off topic: Is there a need to use SDL_Delay() at all? Or should\n\n I use SDL_Delay(1) at least once after a frame is rendered to possibly not\n\n choke the operating system? I’d suggest using SDL_Delay() in conjunction with some sort of time\n\n function (possibly the ordinary C/C++ functions) so that you don’t\n\n wind up wasting time on 70 fps instead of 60. That having been said, I\n\n recall there being some minimum time where SDL just deals with it by\n\n busy-waiting, so in that case you won’t be able to gain any extra\n\n favor from the scheduling algorithms with this.> Date: Sat, 28 Sep 2013 17:02:32 +0000 From: “NuclearDonkey” \n\n To: sdl at lists.libsdl.org\n\n Subject: [SDL] Properly doing surface/texture code and structure\n• It is just better to use SDL_Textures all around, but you could do\n\n option (b) if you really wanted to.\n• Surfaces are better in software yes, and textures in software are really\n\n surfaces behind the scenes. I would architect my engine to use\n\n SDL_textures. That means not doing the stuff that is slow, such as\n\n calling SDL_CreateTextureFromSurface() multiple\n\n times per frame.\n• You can’t poll textures in SDL (Well you can, if you are using Direct3D\n\n renderer).\n• Streaming texture can be locked and you can update it with new pixel\n\n data. Other textures cannot be locked.\n• Using SDL_Delay() can be a good idea if your game has time to spare.On Sat, Sep 28, 2013 at 10:32 PM, NuclearDonkey wrote: **\n\n I’m creating my first major application with SDL after making multiple\n\n small ones. Right now I want to make sure I set myself up right for the\n\n future so I don’t run into problems, but I’ll describe the main one I run\n\n into and hopefully someone can shed some light on the issue: Right now my game is a tile-based one, so I have a bunch of static\n\n textures that never really need modifying. Drawing a bunch of them on\n\n screen in fullscreen accelerated mode yields 1000fps+ which is awesome.\n\n Note I have read the article on why FPS drops are not the end-all-be-all\n\n because of how it’s measured (so I understand 1000 to 500 is not as drastic\n\n as 30 to 15 for example) The performance hit I’m getting is coming from my console text rendering.\n\n Right now lets say we have 10 lines being rendered from a stored log of\n\n messages. Every frame (yes this is a bad idea on paper; I know) I use TTF\n\n to create a surface, then convert to texture with\n\n SDL_CreateTextureFromSurface() and then push that to the renderer. Creating\n\n a texture from a surface is quite expensive and is probably causing the\n\n major performance hit. I might be doing it wrong (I’m freeing everything\n\n and have no memory leaks), but I don’t understand how creating so many\n\n strings is causing such a significant performance hit. Maybe creating\n\n strings is just expensive in general, but this leads me to a few questions:\n• Since my game is heavily ‘sprite’ based, would it be better to:\n• Stay in the surface area and just do SDL_UpdateWindowSurface()?\n• Do textures by writing everything to a ‘screen’ surface and push as a\n\n texture that at the end?\n• Cache as much as possible to textures and strictly do textures?\n• My large fps drop is coming from the expensive operation of\n\n SDL_CreateTextureFromSurface() when attempting to take console log text and\n\n render it in the console every frame, what is the best way to handle this?\n\n Some thoughts I have are:\n• Keep everything as surfaces and just write them to the surface and push\n\n that at the end to a texture\n• Convert strings to a texture and only create new textures when new\n\n strings are needed for rendering (so if were displaying lines 10-20, then\n\n cache lines 10-20 as textures and just draw those, only update when we want\n\n to see 11-21 or such so only 10 textures are in memory at a time, and\n\n creation is only done when there’s an update)\n• Compose an alphabet of textures, and then just dynamically render the\n\n strings letter by letter each frame\n\n *Note that I am running SDL_CreateTextureFromSurface() every frame for x\n\n number of strings (create surface with TTF, surface => texture, rendercopy)\n• Are surfaces better with software and textures better with\n\n hardware/accelerated? Or is it best to always go textures now no matter\n\n what?\n• Should I keep the surfaces around in memory with the textures? I don’t\n\n know if its easier to access pixel data that way instead of constantly\n\n polling the texture\n• Would there be any reason to have a texture that is ‘streaming’? This\n\n may be answered previously, but if there is, why would one use that rather\n\n than doing it all surface and pushing it at the very end to the renderer?\n\n How expensive is making a texture from a large surface? Like should I\n\n expect a significant processing power hit from lets say converting a final\n\n surface thats 800x600 to a texture before pushing?\n• Slightly off topic: Is there a need to use SDL_Delay() at all? Or\n\n should I use SDL_Delay(1) at least once after a frame is rendered to\n\n possibly not choke the operating system? Any input or help is greatly appreciated [image: Smile]\n\nThe performance hit I’m getting is coming from my console text rendering. Right now lets say we have 10 lines being rendered from a stored log of messages. Every frame (yes this is a bad idea on paper; I know) I use TTF to create a surface, then convert to texture with SDL_CreateTextureFromSurface() and then push that to the renderer. Creating a texture from a surface is quite expensive and is probably causing the major performance hit. I might be doing it wrong (I’m freeing everything and have no memory leaks), but I don’t understand how creating so many strings is causing such a significant performance hit. Maybe creating strings is just expensive in general, but this leads me to a few questions: I’m assuming this is a quake-style console. Given that, I’ve got\n\n some thoughts.\n• Create the texture once and recreate it as rarely as possible.\n\n You need only ever re-create it when the size of the displayed\n\n console gets bigger than what you can actually display with the\n\n texture you’ve got. If your game runs at 800x600 and your console is\n\n only allowed to be half-height, 800x300 is needed. If the user\n\n changes game resolution to 640x480, 800x300 still works. If they go\n\n up to 1024x768, well, why aren’t you using OpenGL? (Kidding,\n\n mostly?) No, at that point you’d have to actually re-allocate the\n\n texture to 1024x384. Even 10 year old graphics cards handle textures\n\n of that size, though hopefully not an endless number since a 32bpp\n\n texture at that size is 1.5 megabytes(!)\n• The surface likewise should be kept unless you know you need to\n\n make it bigger. You might think resizing it smaller may reclaim some\n\n memory, but again not necessarily. Memory fragmentation is annoying,\n\n and even though the OS can sometimes clean it up on you, you’d rather\n\n not have the performance hit if it needs to do so. See Generally Off-Topic (and somewhat simplified) History Lesson for\n\n why that is.\n• Render that surface only when the content of the console changes.\n\n Not the position. Theoretically you only have to re-render the new\n\n text, since you can just blit the old to, eg, scroll a line, but I\n\n bet you’re going to find insignificant difference in clearing the\n\n surface and re-rendering versus moving pre-rendered pixels, clearing\n\n the free space, and writing to it. You then stream the updated\n\n surface into the texture. That’s still moving potentially 1.5 MiB\n\n across your system bus at 1024x384, but ? how often do you do that?\n\n Besides, a pure software renderer would have to do it at 30+ frames\n\n per second. Which is why a lot of those software renderers back in\n\n the day ran at 320x200x8bpp? It’s a lot easier to move 64KiB on a\n\n 386 than 1.5MiB!\n• If you don’t need to read back pixels aside from the occasional\n\n screenshot, your best bet is usually to put your graphics in to\n\n textures (and hopefully offloaded to the GPU) as quick as possible\n\n and do your compositing there. If you’ve got sprites and tiles, load\n\n 'em and leave 'em is usually a good rule of thumb, unless you can’t\n\n as with your console. Of course, if you had a pre-rendered font, that you could load as a\n\n texture. There were libraries for SDL 1.x that did so, but obviously\n\n that costs you unicode support. Generally Off-Topic History Lesson: Back in the DOS daze (and on\n\n other dated platform where a game takes over the entire system),\n\n games would typically allocate memory at startup?like generally all\n\n of it?and use their own very simplistic memory manager. This memory\n\n is your heap, and the offset of the first unused space in it is your\n\n heap pointer. They’d load all of the common resources first and save the heap\n\n pointer upon doing so as a high water mark. Resources used only by\n\n the current level/etc continue to be loaded into the heap. The\n\n local heap equivalent of free() likely does very little, if it even\n\n exists, until you decide you’re done with all of the previous level’s\n\n data at once. Then you erase everything down to the high water mark,\n\n basically by just replacing the heap pointer with the high water mark\n\n location. Then you have your stack, which generally goes at the top of the\n\n heap and builds down. Need a temporary string buffer to use a printf\n\n variant? Stack alloc. Same for any alloc you’ll free by the end of\n\n the function. This explains many of the glitches and bugs in those old games,\n\n doesn’t it? Smashed heap and/or stack. These days you don’t take over the whole computer, and the OS still\n\n does memory management for you. Heap allocations tend to be done in\n\n pages, and CPUs pretty much since the 386 allow OSes to swap memory\n\n around physical space and even out to the HD? And you can free and\n\n reallocate unused parts of pages. But the page isn’t freed until all\n\n allocations into it are freed (ref counting), and the OS generally\n\n cannot clean up the contents of a page. Incidentally, you’ll note that Windows and classic MacOS use things\n\n called handles. These are pointers to opaque structures that happen\n\n to contain pointers to stuff. These handles are used by the OS to be\n\n able to move memory allocations for the OS around without telling you\n\n about it. The APIs that spawned them predate CPUs that can remap\n\n memory like that. If you ever play with microcontrollers (such as those by Atmel,\n\n Microchip, Parallax, and even some based ARM-based devices nowadays)\n\n you’ll have exactly the same memory structure to deal with. RAM\n\n allocated in a heap from the bottom up, with a stack allocated\n\n (basically by calling functions in your C code) from the top down.\n\n And all too easy with memory fragmentation to have the heap smash the\n\n stack.On Sat, Sep 28, 2013 at 05:02:32PM +0000, NuclearDonkey wrote:\n• Since my game is heavily ‘sprite’ based, would it be better to:\n• Stay in the surface area and just do SDL_UpdateWindowSurface()?\n• Do textures by writing everything to a ‘screen’ surface and push as a texture that at the end?\n• Cache as much as possible to textures and strictly do textures?\n• My large fps drop is coming from the expensive operation of SDL_CreateTextureFromSurface() when attempting to take console log text and render it in the console every frame, what is the best way to handle this? Some thoughts I have are:\n• Keep everything as surfaces and just write them to the surface and push that at the end to a texture\n• Convert strings to a texture and only create new textures when new strings are needed for rendering (so if were displaying lines 10-20, then cache lines 10-20 as textures and just draw those, only update when we want to see 11-21 or such so only 10 textures are in memory at a time, and creation is only done when there’s an update)\n• Compose an alphabet of textures, and then just dynamically render the strings letter by letter each frame\n\n *Note that I am running SDL_CreateTextureFromSurface() every frame for x number of strings (create surface with TTF, surface => texture, rendercopy)\n• Are surfaces better with software and textures better with hardware/accelerated? Or is it best to always go textures now no matter what?\n• Should I keep the surfaces around in memory with the textures? I don’t know if its easier to access pixel data that way instead of constantly polling the texture\n• Would there be any reason to have a texture that is ‘streaming’? This may be answered previously, but if there is, why would one use that rather than doing it all surface and pushing it at the very end to the renderer?\n\n How expensive is making a texture from a large surface? Like should I expect a significant processing power hit from lets say converting a final surface thats 800x600 to a texture before pushing?\n• Slightly off topic: Is there a need to use SDL_Delay() at all? Or should I use SDL_Delay(1) at least once after a frame is rendered to possibly not choke the operating system? Any input or help is greatly appreciated\n\nI had need to display a console similar to VGA. ?This took much more pain than I expected so I’ll share the code to spare others. ?It’s in Python so you’ll have to tweak it for C, but the point is you can see all the SDL2 calls needed to get something to work. ?I think I extracted the relevant parts. The font glyphs are stored as a 256x1 RGBA texture.??The char is from the old extended ascii font (cp850) whereas the font used (Lucida Console) is in Unicode. ?The font mapping is done once when the font texture is created. ?This simple texture works because the numbers of chars is small. ?To support a full font, the code would have to adapt to (cache) the chars used. Since it’s modelled after VGA, it’s 80x25 with one byte of char and one byte of color information. ?Drawing is basically a lot of fill rects each with a character blended on top. ?There’s nothing smart done for blank lines or scrolling cases. The code is not optimized much but it was good enough for now so I moved on. I didn’t use sdl ttf strings for every draw because I 1) wanted only textures used, 2) had extreme color needs, 3) didn’t need/want font issues like kerning. ? ? ? ? # need fonts that display 195 extended ascii (251c unicode) like (Lucida)?\n\n ? ? ? ? for f in [“lucon.ttf”]:\n\n ? ? ? ? ? ? ? ? self.font = ttf.TTF_OpenFont(f, 20) # look locally first?\n\n ? ? ? ? ? ? ? ? if not bool(self.font): ?# font != None\n\n ? ? ? ? ? ? ? ? ? ? self.font = ttf.TTF_OpenFont(path.join(getenv(‘windir’), “Fonts”, f), 20) ? ? ? ? if not bool(self.font):\n\n ? ? ? ? ? ? raise Exception(‘no monospace fonts found’)\n\n ? ? ? ? self.font_texture = None ? ? ? ? # remember we do not automatically display a window unless the?\n\n ? ? ? ? # the code initializes the video. ? ? def font_set(self):\n\n ? ? ? ? # copy images of all 256 chars to self.font_texture?\n\n ? ? ? ? self.font_texture = sdl2.SDL_CreateTexture(self.renderer,?\n\n ? ? ? ? ? ? sdl2.SDL_PIXELFORMAT_RGBA8888, sdl2.SDL_TEXTUREACCESS_TARGET,?\n\n ? ? ? ? ? ? self.char_width * 256, self.char_height)\n\n ? ? ? ? sdl2.SDL_SetRenderTarget(self.renderer, self.font_texture)\n\n ? ? ? ? sdl2.SDL_SetRenderDrawColor(self.renderer, 0, 0, 0, 0) # black alpha\n\n ? ? ? ? sdl2.SDL_RenderClear(self.renderer)\n\n ? ? ? ? sdl2.SDL_SetRenderDrawBlendMode(self.renderer, sdl2.SDL_BLENDMODE_NONE) ? ? ? ? r = sdl2.SDL_Rect(0, 0, self.char_width, self.char_height)\n\n ? ? ? ? white = Color(‘white’)\n\n ? ? ? ? for c in range(1, 256):\n\n ? ? ? ? ? ? #char_surface = ttf.TTF_RenderGlyph_Solid(self.font, ord(chr(c).decode(‘cp850’)), white)\n\n ? ? ? ? ? ? char_surface = ttf.TTF_RenderGlyph_Blended(self.font, ord(chr(c).decode(‘cp850’)), white)\n\n ? ? ? ? ? ? char_texture = sdl2.SDL_CreateTextureFromSurface(self.renderer, char_surface) ? ? def reconfigure(self):\n\n ? ? ? ? app_name = path.splitext(path.basename(argv[0]))[0]\n\n ? ? ? ? width = ctypes.c_int()\n\n ? ? ? ? ttf.TTF_GlyphMetrics(self.font, ord(‘0’), None, None, None, None, width)\n\n ? ? ? ? self.char_width = width.value\n\n ? ? ? ? self.char_height = ttf.TTF_FontLineSkip(self.font) ? ? ? ? ? ? if sdl2.SDL_PollEvent(ctypes.byref(e)) != 0:\n\n ? ? ? ? ? ? ? ? if e.type == sdl2.events.SDL_QUIT:\n\n ? ? ? ? ? ? ? ? ? ? sdl2.SDL_DestroyTexture(self.font_texture)\n\n ? ? ? ? ? ? ? ? ? ? sdl2.SDL_DestroyWindow(self.window)\n\n ? ? ? ? ? ? ? ? ? ? self.window = None\n\n ? ? ? ? ? ? ? ? ? ? sdl2.SDL_DestroyRenderer(self.renderer)\n\n ? ? ? ? ? ? ? ? ? ? self.renderer = None\n\n ? ? ? ? ? ? ? ? ? ? sdl2.SDL_Quit()\n\n ? ? ? ? ? ? ? ? ? ? self.cpu.keep_going = False\n\n ? ? ? ? ? ? ? ? ? ? return # exit to avoid the draw below ? ? ? ? sdl2.SDL_SetRenderDrawBlendMode(self.renderer, sdl2.SDL_BLENDMODE_NONE)\n\n ? ? ? ? back_last = 0\n\n ? ? ? ? palette_index = back_last * 3\n\n ? ? ? ? # the VGA RGB palette is 6 bits per color channel. ?\n\n ? ? ? ? # So shift it up to fill a full 8 bits each channel.?\n\n ? ? ? ? sdl2.SDL_SetRenderDrawColor(self.renderer,?\n\n ? ? ? ? ? ? self.palette_data[palette_index] << 2,?\n\n ? ? ? ? ? ? self.palette_data[palette_index + 1] << 2,?\n\n ? ? ? ? ? ? self.palette_data[palette_index + 2] << 2,\n\n ? ? ? ? ? ? 0xff) ? ? ? ? ? ? for x in range(self.columns):\n\n ? ? ? ? ? ? ? ? c = self.cpu.m.m[screen_p]\n\n ? ? ? ? ? ? ? ? attribute = self.cpu.m.m[screen_p + 1] ? ? ? ? ? ? ? ? r.x = screen_x\n\n ? ? ? ? ? ? ? ? r.y = screen_y\n\n ? ? ? ? ? ? ? ? back = (attribute >> 4) & 0b1111\n\n ? ? ? ? ? ? ? ? if back != back_last:\n\n ? ? ? ? ? ? ? ? ? ? back_last = back\n\n ? ? ? ? ? ? ? ? ? ? palette_index = back * 3\n\n ? ? ? ? ? ? ? ? ? ? # the VGA RGB palette is 6 bits per color channel. ?\n\n ? ? ? ? ? ? ? ? ? ? # So shift it up to fill a full 8 bits each channel.?\n\n ? ? ? ? ? ? ? ? ? ? sdl2.SDL_SetRenderDrawColor(self.renderer,?\n\n ? ? ? ? ? ? ? ? ? ? ? ? self.palette_data[palette_index] << 2,?\n\n ? ? ? ? ? ? ? ? ? ? ? ? self.palette_data[palette_index + 1] << 2,?\n\n ? ? ? ? ? ? ? ? ? ? ? ? self.palette_data[palette_index + 2] << 2,\n\n ? ? ? ? ? ? ? ? ? ? ? ? 0xff) ? ? ? ? ? ? ? ? sdl2.SDL_RenderFillRect(self.renderer, r)\n\n ? ? ? ? ? ? ? ? # could draw/merge all rects first, then go back and render chars The performance hit I’m getting is coming from my console text rendering. Right now lets say we have 10 lines being rendered from a stored log of?"
    },
    {
        "link": "https://discourse.libsdl.org/t/memory-leak-while-using-sdl/28449",
        "document": "Hello,\n\n I created this program to create a carousel type of display after reading from a json web file. Everything basically works okay but for some reason, it never stops using up memory. I’m sure its because its drawing SDL surfaces and textures but in my code, I destroy all the surfaces and textures I create in the main loop so I don’t know why it keeps continuing to somehow create more sdl textures and surfaces even though I seem to be explicitly destroying what I create. I tried to post my code but this forum kept saying I’m limited to two links a post, which I took out, but still wouldn’t let me post. Here is a google drive link to it.\n\nIn the and functions, you’re creating/loading a font with , each frame, without destroying it. I’m fairly sure that’s what causing the memory leak. I understand that you need to recreate a surface and a texture while rendering text with the function, but you should be able to load the background texture and the font(s) at the start-up of the application, instead of creating/loading those objects every frame. The function should only be executed (once) at the start-up of the application aswell.\n\nThank you. I’m sure that is part of the problem but I’m still leaking memory somewhere. Okay. I fixed the last issue real quick by making my font variable global and just creating it one time when main starts. I also took out TTF_Init and put it in main one time instead of calling each each frame. Its still causing a memory leak somehow from somewhere else.\n\n I can probably slow down the leak by using preloaded texts like I do the pictures. I’m already loading the strings into a vector when I parse the json file. I was already getting a memory leak however before I added the text headline and caption.\n\n Another problem I’m having is that the text repeats inside of the surface that I turn into a texture. The text heading and caption is repeated inside of the SDL_Surface. I also commented out the showCardHeadline/Caption and I’m still getting a memory link.\n\nThat’s a good place to look. I don’t destroy the data previously there before it is moved. I will try that and let you know. One thing is when I comment out everything in my main loop, the leak stops so its one of the loop functions causing the problems. Move left and move right dont get called every frame but the leak looks like it is called every frame because of the rate at which it grows. Even if I comment out everything but the background which I destroy at the end of the loop, there is a memory leak.\n\nI found the reason why carouselCardImages was getting so large. My loadTexture function was appending any texture to the end of my carouselfCardImages array where I used it. I was using it very specifically at first but later I realized I could use it a lot more generally but forgot to take out the line to append whatever texture it gets to carouselCardImages. Everywhere I used it, it was putting that image onto my array. It stays at size 14 now instead of growing by hundreds every few seconds. Thank you for your feedback. I was still leaking memory because when assigning a value to a vector, it allocates memory again. I found std::rotate which works very well with my carouselCardImages array and doesn’t allocate any new memory so no memory leak now! Now I have to figure out how to do this with the captions and I’m done. Thank you for your help."
    }
]