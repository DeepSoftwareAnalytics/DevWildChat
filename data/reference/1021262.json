[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies",
        "document": "A cookie (also known as a web cookie or browser cookie) is a small piece of data a server sends to a user's web browser. The browser may store cookies, create new cookies, modify existing ones, and send them back to the same server with later requests. Cookies enable web applications to store limited amounts of data and remember state information; by default the HTTP protocol is stateless. In this article we will explore the main uses of cookies, explain best practices for using them, and look at their privacy and security implications.\n\nYou can specify an expiration date or time period after which the cookie should be deleted and no longer sent. Depending on the attributes set within the header when the cookies are created, they can be either permanent or session cookies:\n• Permanent cookies are deleted after the date specified in the attribute: or after the period specified in the attribute: Note: has been available for longer than , however is less error-prone, and takes precedence when both are set. The rationale behind this is that when you set an date and time, they're relative to the client the cookie is being set on. If the server is set to a different time, this could cause errors.\n• Session cookies — cookies without a or attribute – are deleted when the current session ends. The browser defines when the \"current session\" ends, and some browsers use session restoring when restarting. This can cause session cookies to last indefinitely. Note: If your site authenticates users, it should regenerate and resend session cookies, even ones that already exist, whenever a user authenticates. This approach helps prevent session fixation attacks, where a third-party can reuse a user's session. There are some techniques designed to recreate cookies after they're deleted. These are known as \"zombie\" cookies. These techniques violate the principles of user privacy and control, may violate data privacy regulations, and could expose a website using them to legal liability.\n\nTo update a cookie via HTTP, the server can send a header with the existing cookie's name and a new value. For example: There are several reasons why you might want to do this, for example if a user has updated their preferences and the application wants to reflect the changes in client-side data (you could also do this with a client-side storage mechanism such as Web Storage). In the browser, you can create new cookies via JavaScript using the property, or the asynchronous Cookie Store API. Note that all examples below use , as it is the most widely supported/established option. You can also access existing cookies and set new values for them, provided the attribute isn't set on them (i.e. in the header that created it): Note that, for security purposes, you can't change cookie values by sending an updated header directly when initiating a request, i.e. via or . Note that there are also good reasons why you shouldn't allow JavaScript to modify cookies — i.e. set during creation. See the Security section for more details.\n\nWhen you store information in cookies, by default all cookie values are visible to, and can be changed by, the end user. You really don't want your cookies to be misused — for example accessed/modified by bad actors, or sent to domains where they shouldn't be sent. The potential consequences can range from annoying — apps not working or exhibiting strange behavior — to catastrophic. A criminal could for example steal a session ID and use it to set a cookie that makes it look like they are logged in as someone else, taking control of their bank or e-commerce account in the process. You can secure your cookies in a variety of ways, which are reviewed in this section.\n\nYou can ensure that cookies are sent securely and aren't accessed by unintended parties or scripts in one of two ways: with the attribute and the attribute:\n• A cookie with the attribute is only sent to the server with an encrypted request over the HTTPS protocol. It's never sent with unsecured HTTP (except on localhost), which means man-in-the-middle attackers can't access it easily. Insecure sites (with in the URL) can't set cookies with the attribute. However, don't assume that prevents all access to sensitive information in cookies. For example, someone with access to the client's hard disk (or JavaScript if the attribute isn't set) can read and modify the information.\n• A cookie with the attribute can't be accessed by JavaScript, for example using ; it can only be accessed when it reaches the server. Cookies that persist user sessions for example should have the attribute set — it would be really insecure to make them available to JavaScript. This precaution helps mitigate cross-site scripting (XSS) attacks. Note: Depending on the application, you may want to use an opaque identifier that the server looks up rather than storing sensitive information directly in cookies, or investigate alternative authentication/confidentiality mechanisms such as JSON Web Tokens.\n\nDefine where cookies are sent The and attributes define the scope of a cookie: what URLs the cookies are sent to.\n• The attribute specifies which server can receive a cookie. If specified, cookies are available on the specified server and its subdomains. For example, if you set from , cookies are available on that domain and subdomains like . If the header does not specify a attribute, the cookies are available on the server that sets it but not on its subdomains. Therefore, specifying is less restrictive than omitting it. Note that a server can only set the attribute to its own domain or a parent domain, not to a subdomain or some other domain. So, for example, a server with domain could set the attribute to or , but not or (the cookies would still be sent to subdomains such as though). See Invalid domains for more details.\n• The attribute indicates a URL path that must exist in the requested URL in order to send the header. For example: The (\"/\") character is considered a directory separator, and subdirectories match as well. For example, if you set , these request paths match:\n\nThe attribute lets servers specify whether/when cookies are sent with cross-site requests — i.e. third-party cookies. Cross-site requests are requests where the site (the registrable domain) and/or the scheme (http or https) do not match the site the user is currently visiting. This includes requests sent when links are clicked on other sites to navigate to your site, and any request sent by embedded third-party content. helps to prevent leakage of information, preserving user privacy and providing some protection against cross-site request forgery attacks. It takes three possible values: , , and :\n• causes the browser to only send the cookie in response to requests originating from the cookie's origin site. This should be used when you have cookies relating to functionality that will always be behind an initial navigation, such as authentication or storing shopping cart information. Note: Cookies that are used for sensitive information should also have a short lifetime.\n• is similar, except the browser also sends the cookie when the user navigates to the cookie's origin site (even if the user is coming from a different site). This is useful for cookies affecting the display of a site — for example you might have partner product information along with an affiliate link on your website. When that link is followed to the partner website, they might want to set a cookie stating that the affiliate link was followed, which displays a reward banner and provides a discount if the product is purchased.\n• specifies that cookies are sent on both originating and cross-site requests. This is useful if you want to send cookies along with requests made from third-party content embedded in other sites, for example, ad-tech or analytics providers. Note that if is set then the attribute must also be set — requires a secure context. If no attribute is set, the cookie is treated as by default.\n\nBecause of the design of the cookie mechanism, a server can't confirm that a cookie was set from a secure origin or even tell where a cookie was originally set. A vulnerable application on a subdomain can set a cookie with the attribute, which gives access to that cookie on all other subdomains. This mechanism can be abused in a session fixation attack. See session fixation for primary mitigation methods. As a defense-in-depth measure, however, you can use cookie prefixes to assert specific facts about the cookie. Two prefixes are available:\n• : If a cookie name has this prefix, it's accepted in a header only if it's also marked with the attribute, was sent from a secure origin, does not include a attribute, and has the attribute set to . In other words, the cookie is domain-locked.\n• : If a cookie name has this prefix, it's accepted in a header only if it's marked with the attribute and was sent from a secure origin. This is weaker than the prefix. The browser will reject cookies with these prefixes that don't comply with their restrictions. This ensures that subdomain-created cookies with prefixes are either confined to a subdomain or ignored completely. As the application server only checks for a specific cookie name when determining if the user is authenticated or a CSRF token is correct, this effectively acts as a defense measure against session fixation. Note: On the server, the web application must check for the full cookie name including the prefix. User agents do not strip the prefix from the cookie before sending it in a request's header. For more information about cookie prefixes and the current state of browser support, see the Prefixes section of the Set-Cookie reference article.\n\nEarlier on we talked about how the attribute can be used to control when third-party cookies are sent, and that this can help preserve user privacy. Privacy is a very important consideration when building websites which, when done right, can build trust with your users. If done badly, it can completely erode that trust and cause all kinds of other problems. Third-party cookies can be set by third-party content embedded in sites via s. They have many legitimate uses include sharing user profile information, counting ad impressions, or collecting analytics across different related domains. However, third-party cookies can also be used to create creepy, invasive user experiences. A third-party server can create a profile of a user's browsing history and habits based on cookies sent to it by the same browser when accessing multiple sites. The classic example is when you search for product information on one site and are then chased around the web by adverts for similar products wherever you go. Browser vendors know that users don't like this behavior, and as a result have all started to block third-party cookies by default, or at least made plans to go in that direction. Third-party cookies (or just tracking cookies) may also be blocked by other browser settings or extensions. Note: Cookie blocking can cause some third-party components (such as social media widgets) not to function as intended. As browsers impose further restrictions on third-party cookies, developers should start to look at ways to reduce their reliance on them. See our Third-party cookies article for detailed information on third-party cookies, the issues associated with them, and what alternatives are available. See our Privacy landing page for more information on privacy in general.\n\nLegislation or regulations that cover the use of cookies include:\n• The General Data Privacy Regulation (GDPR) in the European Union\n• The ePrivacy Directive in the EU These regulations have global reach. They apply to any site on the World Wide Web that users from these jurisdictions access (the EU and California, with the caveat that California's law applies only to entities with gross revenue over 25 million USD, among things). These regulations include requirements such as:\n• Notifying users that your site uses cookies.\n• Allowing users to opt out of receiving some or all cookies.\n• Allowing users to use the bulk of your service without receiving cookies. There may be other regulations that govern the use of cookies in your locality. The burden is on you to know and comply with these regulations. There are companies that offer \"cookie banner\" code that helps you comply with these regulations. Note: Companies should disclose the types of cookies they use on their sites for transparency purposes and to comply with regulations. For example, see Google's notice on the types of cookies it uses and Mozilla's Websites, Communications & Cookies Privacy Notice."
    },
    {
        "link": "https://web.dev/articles/cookie-notice-best-practices",
        "document": "This document discusses how cookie notices can affect performance, performance measurement, and user experience.\n\nCookie notices can have a significant impact on page performance due to the fact that they are typically loaded early in the page load process, are shown to all users, and can potentially influence the loading of ads and other page content.\n• None Largest Contentful Paint (LCP): Most cookie consent notices are fairly small and therefore typically don't contain a page's LCP element. However, this can happen—particularly on mobile devices. On mobile devices, a cookie notice typically takes up a larger portion of the screen. This usually occurs when a cookie notice contains a large block of text (text blocks can be LCP elements too).\n• None Interaction to Next Paint (INP): Cookie notices can often be a cause for high INP as they typically add a lot of third-party scripts when accepted. The main issue is often to do the Accept interaction as that results in a lot of processing to add those third-party scripts all at once. Refer to the Best Practices section on how to mitigate this.\n• None Cumulative Layout Shift (CLS): Cookie consent notices are a very common source of layout shifts.\n\nGenerally speaking, you can expect a cookie notice from third-party providers to have a greater impact on performance than a cookie notice that you build yourself. This is not a problem unique to cookie notices—but rather the nature of third-party scripts in general.\n\nThe best practices in this section focus on third-party cookie notices. Some, but not all, of these best practices will also be applicable to first-party cookie notices.\n\nAs mentioned previously, the Accept button is often a particular cause of INP issues due to the large amount of processing that happens when it's clicked.\n\nThe Chrome team has worked with a number of Consent Management Platforms (CMP) to yield after clicking accept to allow the browser to acknowledge that acceptance quickly in the next paint. See this PubTech case study as an example.\n\nIf your CMP is affected by this, try reaching out to them to see if they can similarly avoid INP issues for sites embedding it. See the Optimize Long Tasks article for guidance on yielding tactics.\n\nCookie notice scripts should be loaded asynchronously. To do this, add the attribute to the script tag.\n\nScripts that are not asynchronous block the browser parser. This delays page load and LCP. For more information, see Efficiently load third-party JavaScript.\n\nCookie notice scripts should be loaded \"directly\" by placing the script tag in the HTML of the main document—rather than loaded by a tag manager or other script. Using a tag manager or secondary script to inject the cookie notice script delays the loading of the cookie notice script: it obscures the script from the browser's lookahead parser and it prevents the script from loading before JavaScript execution.\n\nEstablish an early connection with the cookie notice origin\n\nAll sites that load their cookie notice scripts from a third-party location should use either the or resource hints to help establish an early connection with the origin that hosts cookie notice resources. For more information, see Establish network connections early to improve perceived page speed.\n\nSome sites would benefit from using the resource hint to load their cookie notice script. The resource hint informs the browser to initiate an early request for the specified resource.\n\nis most powerful when its usage is limited to fetching a couple key resources per page. Thus, the usefulness of preloading the cookie notice script will vary depending on the situation.\n\nBe aware of performance tradeoffs when styling cookie notices\n\nCustomizing the look and feel of a third-party cookie notice may incur additional performance costs. For example, third-party cookie notices aren't always able to reuse the same resources (for example, web fonts) that are used elsewhere on the page. In addition, third-party cookie notices tend to load styling at the end of long request chains. To avoid any surprises, be aware of how your cookie notice loads and applies styling and related resources.\n\nThese are some of the most common layout shift issues associated with cookie notices:\n• Top-of-screen cookie notices: Top-of-screen cookie notices are a very common source of layout shift. If a cookie notice is inserted into the DOM after the surrounding page has already rendered, it will push the page elements below it further down the page. This type of layout shift can be eliminated by reserving space in the DOM for the consent notice. If this is not a feasible solution—for example, if the dimensions of your cookie notice vary by geography, consider using a sticky footer or modal to display the cookie notice. Because both of these alternative approaches display the cookie notice as an \"overlay\" on top of the rest of the page, the cookie notice shouldn't cause content shifts when it loads.\n• Animations: Many cookie notices use animations—for example, \"sliding in\" a cookie notice is a common design pattern. Depending on how these effects are implemented, they can cause layout shifts. For more information, see Debugging layout shifts.\n• Fonts: Late-loading fonts can block render and or cause layout shifts. This phenomena is more apparent on slow connections.\n\nThese techniques take more work to implement but can further optimize the loading of cookie notice scripts:\n• Caching and serving third-party cookie notice scripts from your own servers can improve the delivery speed of these resources.\n• Using service workers can allow you more control over the fetching and caching of third-party scripts such as cookie notice scripts.\n\nCookie notices can impact performance measurements. This section discusses some of these implications and techniques for mitigating them.\n\nSome analytics and RUM tools use cookies to collect performance data. In the event that a user declines usage of cookies these tools cannot capture performance data.\n\nSites should be aware of this phenomenon; it is also worthwhile to understand the mechanisms that your RUM tooling uses to collect its data. However, for the typical site this discrepancy probably isn't a cause for alarm given the direction and magnitude of the data skew. Cookie usage is not a technical requirement for performance measurement. The web-vitals JavaScript library is an example of a library that does not use cookies.\n\nDepending on how your site uses cookies to collect performance data (that is, whether the cookies contain personal information), as well as the legislation in question, the use of cookies for performance measurement might not be subject to the same legislative requirements as some of the cookies used on your site for other purposes—for example, advertising cookies. Some sites choose to break out performance cookies as a separate category of cookies when asking for user consent.\n\nWithout custom configuration, most synthetic tools (such as Lighthouse and WebPageTest) will only measure the experience of a first-time user who has not responded to a cookie consent notice. However, not only do variations in cache state (for example, an initial visit versus a repeat visit) need to be considered when collecting performance data, but also variations in cookie acceptance state—accepted, rejected, or unresponded.\n\nThe following sections discuss WebPageTest and Lighthouse settings that can be helpful for incorporating cookie notices into performance measurement workflows. However, cookies and cookie notices are just one of many factors that can be difficult to perfectly simulate in lab environments. For this reason, it is important to make RUM data the cornerstone of your performance benchmarking, rather than synthetic tooling.\n\nYou can use scripting to have a WebPageTest \"click\" the cookie consent banner while collecting a trace.\n\nAdd a script by going to the Script tab. The following script navigates to the URL to be tested and then clicks the DOM element with the .\n\nWhen using this script be aware that:\n• tells WebPageTest to \"combine\" the results of the scripting steps that follow into a single set of traces and measurements. Running this script without can also be useful—separate traces make it easier to see whether resources were loaded before or after cookie acceptance.\n• is a WebPageTest convention that refers to the URL that is being tested.\n• tells WebPageTest to click the element indicated by and wait for the subsequent browser activity to complete. It follows the format .\n\nIf you've configured this script correctly, the screenshot taken by WebPageTest shouldn't show a cookie notice (the cookie notice has been accepted).\n\nFor more information on WebPageTest scripting, check out WebPageTest documentation.\n\nTo run WebPageTest with a cookie set, go to the Advanced tab and add the cookie header to the Custom headers field:\n\nTo change the test location used by WebPageTest, click the Test Location drop-down located on the Advanced Testing tab.\n\nSetting cookies on a Lighthouse run can serve as a mechanism for getting a page into a particular state for testing by Lighthouse. Lighthouse's cookie behavior varies slightly by context (DevTools, CLI, or PageSpeed Insights).\n\nCookies are not cleared when Lighthouse is run from DevTools. However, other types of storage are cleared by default. This behavior can be changed by using the Clear Storage option in the Lighthouse settings panel.\n\nRunning Lighthouse from the CLI uses a fresh Chrome instance, so no cookies are set by default. To run Lighthouse from the CLI with a particular cookie set, use the following command:\n\nFor more information on setting custom request headers in Lighthouse CLI, see Running Lighthouse on Authenticated Pages.\n\nRunning Lighthouse from PageSpeed Insights uses a fresh Chrome instance and does not set any cookies. PageSeed Insights cannot be configured to set particular cookies.\n\nThe user experience (UX) of different cookie consent notices is primarily the result of two decisions: the location of the cookie notice within the page and the extent to which the user can customize a site's use of cookies. This section discusses potential approaches to these two decisions.\n\nWhen considering potential designs for your cookie notice, here are some things to think about:\n• UX: Is this a good user experience? How will this particular design affect existing page elements and user flows?\n• Business: What is your site's cookie strategy? What are your goals for the cookie notice?\n• Legal: Does this comply with legal requirements?\n• Engineering: How much work would this be to implement and maintain? How difficult would it be to change?\n\nCookie notices can be displayed as a header, inline element, or footer. They can also be displayed on top of page content using a modal or served as an interstitial.\n\nCookie notices are commonly placed in the header or footer. Of these two options, the footer placement is generally preferable because it is unobtrusive, does not compete for attention with banner ads or notifications, and typically does not cause CLS. In addition, it is a common place for placing privacy policies and terms of use.\n\nAlthough inline cookie notices are an option, they can be difficult to integrate into existing user interfaces, and therefore are uncommon.\n\nModals are cookie consent notices that are displayed on top of page content. Modals can look and perform quite differently depending on their size.\n\nSmaller, partial-screen modals can be a good alternative for sites that are struggling to implement cookie notices in a way that doesn't cause layout shifts.\n\nOn the other hand, large modals that obscure the majority of page content should be used carefully. In particular, smaller sites may find that users bounce rather than accept the cookie notice of an unfamiliar site with obscured content. Although they are not necessarily synonymous concepts, if you are considering using a full-screen cookie consent modal, you should be aware of legislation regarding cookie walls.\n\nCookie notice interfaces give users varying levels of control over which cookies they accept.\n\nThese notice-style cookie banners don't present users with direct UX controls for opting out of cookies. Instead, they typically include a link to the site's cookie policy which may provide users with information about managing cookies using their web browser. These notices typically include a \"Dismiss\" and \"Accept\" buttons.\n\nThese cookie notices give the user the option of declining cookies but don't support more granular controls. This approach to cookie notices is less common.\n\nThese cookie notices provide users with more fine-grained controls for configuring the cookie usage that they accept.\n• None UX: Controls for configuring cookie usage are most commonly displayed using a separate modal that is launched when the user responds to the initial cookie consent notice. However, if space permits, some sites will display these controls inline within the initial cookie consent notice.\n• None Granularity: The most common approach to cookie configurability is to allow users to opt-in to cookies by cookie \"category\". Examples of common cookie categories include functional, targeting, and social media cookies. However, some sites will go a step further and allow users to opt-in on a per-cookie basis. Alternatively, another way of providing users with more specific controls is to break down cookie categories like \"advertising\" into specific use cases—for example, allowing users to separately opt-in to \"basic ads\" and \"personalized ads\"."
    },
    {
        "link": "https://my.onetrust.com/s/article/UUID-648cbd31-0007-76ab-ca6c-85023ebf83dc?language=en_US",
        "document": ""
    },
    {
        "link": "https://trustarc.com/resource/best-practices-cookie-consent",
        "document": "Websites today are rarely a single-party affair. On any given website, consumers typically interact with many third parties that collect private data about them, whether web visitors realize it or not.\n\nOrganizations that do so without first collecting cookie consent from users may find they aren’t in compliance with privacy laws.\n\nInternet cookies – little data files – store information in consumers’ web browsers. There are benefits for consumers who accept cookies.\n\nFor example, cookies let websites remember past interactions, website logins, shopping carts, pages visited, and more, offering more personalized and convenient website visits.\n\nBut not all cookies are the same, and there are privacy issues that businesses collecting data need to be aware of.\n\nWhat are the different types of cookies?\n\nFirst-party cookies are stored by the website domain consumers visit. They only work on that domain.\n\nFirst-party cookies make the consumer experience smoother by remembering information such as login details, cart information, and site preferences.\n\nThird-party cookies come via external domains that aren’t the website users have visited.\n\nThey can follow consumers from site to site, with each site using the information stored in the cookies to retarget users.\n\nPermanent or persistent cookies stay on your browser history for an extended period of time, over multiple browser sessions.\n\nSession cookies, in contrast, expire as soon as the browsing session is over.\n\nWhat are the privacy risks if cookie consent is not managed properly?\n\nWhen third parties collect consumer data through technologies not readily apparent to consumers, like cookies, it creates privacy risks because consumers are unable to make informed decisions about their data.\n\nGovernment regulators around the world have established regulations and laws governing this type of data collection.\n\nIt’s important for companies to fully understand how they use cookies, what third parties collect data on their site, and how they and these third parties collect and use this data.\n\nWhat are the laws and regulations around cookies?\n\nA number of laws regulate how third parties collect data online.\n\nIn the EU, the Cookie Law (aka ePrivacy Directive) and General Data Protection Regulation (GDPR) protect consumers’ privacy rights by allowing them to choose whether to allow companies to collect, store, and use their personal information.\n\nTogether, these two laws form the world’s strictest data privacy regime.\n\nWhile there is no equivalent overarching law in the U.S., a number of states have implemented laws regulating cookie usage as it relates to their residents. These include the California Consumer Privacy Act (CCPA) and the Virginia Consumer Data Protection Act (VCDPA).\n\nWhat should I know when using internet cookies?\n\nCookies can be an effective way to target consumers. However, it could be detrimental to your business if you don’t manage cookie consent and private data correctly.\n\nThere are a number of best-practice steps you should be aware of when choosing how to employ cookie technology on your website:\n• Classify your cookies, and use a unique domain name per technology, such as HTTP cookies, web beacons, JavaScripts, and Flash LSOs. This is to separate any online behavioral advertising practices from those that are not online behavioral advertising.\n• Have a clear and simple opt-out policy:\n• Use the same cookie name per opt-out mechanism. For example, the opt-out cookie set for the DAA opt-out mechanism has the same name as the cookie set for the NAI opt-out mechanism.\n• Cookies used to manage opt-out preferences need to have a minimum expiration date of five years to adequately honor user preferences.\n• Your opt-out mechanisms need to be tested regularly to verify that they function properly.\n• Establish strict policies around data retention:\n• Retain data only as long as needed to carry out its business purpose, or as long as legally required.\n• Where possible, use session cookies instead of persistent cookies. Give users a choice, where appropriate, to accept a persistent cookie (such as a login cookie).\n• When using persistent cookies, set an expiration date consistent with the shelf life or usefulness of the data you collect.\n• Audit, understand and review cookie use:\n• Audit the use of cookies on your site and how you use cookies on third-party sites.\n• Verify that the use of cookies is consistent with your privacy policy or the privacy policy of the third-party site where your cookies are placed.\n• Verify that third parties setting cookies on your site are authorized to do so.\n• Understand what types of third parties set cookies on your site and the purpose of those cookies.\n• Verify that third parties aren’t collecting data in a manner inconsistent with your own privacy policy.\n• Understand what data is being captured on the cookie. Cookies shouldn’t store sensitive information such as credit card numbers.\n\nWhat do I need to let consumers know about cookies?\n\nWhen you’re using cookies on your site, it’s important to:\n• Disclose in your privacy policy what information cookies and other technologies collect, and how that information is used.\n• Disclose the types of cookies being used on your site. Organize them by their purpose.\n• Explain what options users have when it comes to your company’s use of cookies, such as opting out of tracking.\n• You should also state what opt-out choices are available.\n• Multi-site trackers should require publishers and sites within their network to disclose via their privacy policies that a third party will be tracking a user’s activity on this and other websites.\n• They should also provide a link to an opt-out mechanism.\n• Where possible, provide notice outside of the privacy policy, using tools such as the AdChoices icon.\n\nHow do I let web visitors know about cookie use?\n\nYour cookie consent pop-up notification message should appear when new users visit your site. Most site development tools allow you to generate cookie pop-ups, while also giving users the option to customize their data sharing.\n\nMake sure you inform users of all the types of cookies you’ve employed previously, too.\n\nWill internet cookies be a thing in the future?\n\nGoogle has flip flopped on its announcement to phase out the use of third-party cookies in 2024. In a significant shift from previously communicated plans and strategy, on July 22nd, 2024, Google announced that it would no longer be phasing out support for third-party cookies in its Chrome browser. Find out what that means for your business."
    },
    {
        "link": "https://captaincompliance.com/education/best-practices-for-adding-cookie-tracking-to-your-website",
        "document": "Cookie tracking is an essential aspect of modern web development, allowing businesses to collect data about user behavior, preferences, and interactions. However, implementing cookie tracking must be done with care, respecting privacy laws and user consent. Captain Compliance provides a suite of cookie tools such as cookie scanning and a cookie notice pop up banner you can use for your website that is simple and easy to install. Now that Google has confirmed that they are not deprecating 3rd party cookies it’s important to setup a CMP that is trusted and easy to install. Now they also said Fingerprinting is okay as of early 2025 so now things are going to get very interesting.\n\nBest Practices for Adding Cookie Tracking to Your Website This Year\n\nGoogle’s approval of fingerprinting, effective February 16, alongside its phased cookie rollback, is redefining how websites track users. With third-party cookies fading (Chrome’s reduction began with 1% of users in 2024, targeting full deprecation by year-end), businesses must adapt. Here’s how to implement cookie tracking effectively and ethically amid these changes.\n\nFirst, prioritize first-party cookies. They’re less invasive, tied to your domain, and align with privacy laws like GDPR and CCPA. Use them to store session data—logins, cart items—enhancing user experience without cross-site snooping. Pair this with clear consent banners. Oregon’s 2024 AI guidance, for instance, stresses transparency under laws like the OCPA; tell users what you’re tracking and why. Opt-in, not opt-out, is the gold standard.\n\nSecond, integrate fingerprinting judiciously. Google’s policy shift allows it, but regulators like the U.K.’s ICO warn it’s not a free pass—lawful deployment means consent and clarity. Fingerprinting’s edge (unifying device signals like browser type and IP) beats cookies’ fragility, but it’s stealthier, so disclose it. A simple “We use device data to personalize ads” can preempt backlash.\n\nThird, lean on alternatives. Google’s Privacy Sandbox offers APIs like Topics for cohort-based targeting—less granular but privacy-friendly. Test these now; adoption’s lagging, but they’re future-proof. Meanwhile, secure your data. Oregon’s OCIPA demands breach notifications—encrypt cookie-stored info to dodge fines.\n\nAudit regularly. Laws evolve—California’s CPRA mandates annual reviews. Ensure your tracking respects retention limits (e.g., delete data after two years unless justified). In 2025, blending cookies, fingerprinting, and emerging tools requires balance: deliver value to users, not just advertisers. Transparency and compliance aren’t optional—they’re your shield in a privacy-first world.\n\n\n\nThis educational series outlines the best practices for adding cookie tracking to your website, ensuring compliance and maximizing effectiveness.\n\nCookie tracking involves placing small text files (cookies) on a user’s device when they visit a website. These cookies can store various types of data, such as:\n• Session information: To keep users logged in during their visit.\n\nBefore implementing cookie tracking, it’s crucial to understand the legal requirements, such as the General Data Protection Regulation (GDPR) in the EU and the CPRA & The California Consumer Privacy Act (CCPA) in the US. These laws mandate that websites must:\n• Inform users about the use of cookies: Clearly state what cookies are being used and their purpose.\n• Obtain user consent: Allow users to opt-in to non-essential cookies.\n• Provide options to manage preferences: Enable users to adjust their cookie settings at any time.\n\nA comprehensive cookie policy should be easily accessible from your website. It should include:\n• A detailed description of the types of cookies used.\n• The purpose of each cookie.\n• Information on how users can manage their cookie preferences.\n\nA Consent Management Platform (CMP) helps you manage user consent efficiently. Captain Compliance offers a robust CMP that simplifies this process, providing features such as:\n• Easy integration through Google Tag Manager, Shopify, or direct implementation via the Captain Compliance dashboard.\n\nA cookie banner is a visible notification that informs users about cookie usage and requests their consent. Best practices for cookie banners include:\n• Prominence: Ensure the banner is noticeable without obstructing content.\n• Options: Provide buttons for accepting all cookies, rejecting non-essential cookies, and managing preferences.\n\nClassify cookies into categories to help users make informed decisions. Common categories include:\n• Performance cookies: Used for analytics and site performance tracking.\n\nAllow users to manage their cookie preferences easily. Captain Compliance’s software enables detailed preference management, allowing users to:\n• View and modify cookie settings at any time.\n\nStay compliant by regularly reviewing your cookie practices and updating your policies as needed. This includes:\n• Auditing cookies: Periodically check which cookies are in use and their purposes.\n• Updating policies: Reflect any changes in your cookie policy and user consent mechanisms.\n• Monitoring regulations: Stay informed about changes in privacy laws and adjust your practices accordingly.\n\nIdentify all cookies used on your website. Tools like the one offered here at Captain Compliance has the fastest loading auditing feature that can help automate this process.\n\nBased on your audit, draft a comprehensive cookie policy. Include details about each cookie, its purpose, and how users can manage their settings.\n\nChoose a CMP that fits your needs. Captain Compliance provides a user-friendly CMP that integrates seamlessly with:\n• Google Tag Manager: Insert the CMP tag through your GTM account.\n• Shopify: Use the Captain Compliance app available in the Shopify App Store.\n• Direct Integration: Implement the CMP code directly into your website’s HTML through the Captain Compliance dashboard.\n\nUsing your CMP, create a cookie banner that:\n• Clearly states your use of cookies.\n• Provides options for users to accept, reject, or customize their cookie settings.\n\nSet up detailed preference management options within your CMP. Ensure users can:\n\nRegularly review your cookie practices and user consent logs. Update your cookie policy and CMP settings as needed to remain compliant with regulations and reflect any changes in your data collection practices.\n\nCaptain Compliance offers an all-in-one solution for managing cookie consent and user preferences. Key benefits include:\n• Easy Installation: Integrate with popular platforms like Google Tag Manager and Shopify, or directly through the Captain Compliance dashboard.\n• Customizable Solutions: Tailor consent banners and preference management options to fit your brand’s look and feel.\n• Compliance Assurance: Stay up-to-date with the latest legal requirements and ensure your website remains compliant.\n• User-Friendly Interface: Provide a seamless experience for users to manage their cookie preferences.\n• Real-Time Consent Logging: Keep track of user consents for audit purposes.\n• Comprehensive Audits: Automatically identify and categorize all cookies used on your website.\n• Flexible Integration Options: Choose the integration method that works best for your website.\n• Dedicated Support: Access expert assistance for any compliance-related questions or issues.\n\nTime To Implement Cookie Tracking On Your Website!\n\nImplementing cookie tracking on your website is not just about collecting data; it’s about doing so responsibly and in compliance with all the data privacy laws (20 just in the USA as of this writing). By following best practices and leveraging automated data privacy compliance software tools like Captain Compliance, you can ensure your website respects user privacy while gathering valuable insights. Remember to:\n• Regularly review and update your practices to stay compliant.\n\nBy prioritizing transparency and user consent, you build trust with your audience and maintain compliance with ever-evolving privacy regulations."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie",
        "document": "The property lets you read and write cookies associated with the document. It serves as a getter and setter for the actual values of the cookies.\n\nRead all cookies accessible from this location In the code above is a string containing a semicolon-separated list of all cookies (i.e. pairs). Note that each key and value may be surrounded by whitespace (space and tab characters): in fact, RFC 6265 mandates a single space after each semicolon, but some user agents may not abide by this.\n\nIn the code above, is a string of form , specifying the cookie to set/update. Note that you can only set/update a single cookie at a time using this method. Consider also that:\n• Any of the following cookie attribute values can optionally follow the key-value pair, each preceded by a semicolon separator:\n• (e.g., or ): The host to which the cookie will be sent. If not specified, this defaults to the host portion of the current document location and the cookie is not available on subdomains. If a domain is specified, subdomains are always included. Contrary to earlier specifications, leading dots in domain names are ignored, but browsers may decline to set the cookie containing such dots. Note: The domain must match the domain of the JavaScript origin. Setting cookies to foreign domains will be silently ignored.\n• : The expiry date of the cookie. If neither nor is specified, it will expire at the end of session. Warning: When user privacy is a concern, it's important that any web app implementation invalidate cookie data after a certain timeout instead of relying on the browser to do it. Many browsers let users specify that cookies should never expire, which is not necessarily safe. See for help formatting this value.\n• : The maximum age of the cookie in seconds (e.g., or 31536000 for a year).\n• : Indicates that the cookie should be stored using partitioned storage. See Cookies Having Independent Partitioned State (CHIPS) for more details.\n• : The value of the cookie's attribute (See Define where cookies are sent for more information).\n• : The attribute of a header can be set by a server to specify when the cookie will be sent. Possible values are , or (see also Controlling third-party cookies with ).\n• The value will send the cookie for all same-site requests and top-level navigation GET requests. This is sufficient for user tracking, but it will prevent many Cross-Site Request Forgery (CSRF) attacks. This is the default value in modern browsers.\n• The value will prevent the cookie from being sent by the browser to the target site in all cross-site browsing contexts, even when following a regular link.\n• The value explicitly states no restrictions will be applied. The cookie will be sent in all requests—both cross-site and same-site.\n• : Specifies that the cookie should only be transmitted over a secure protocol.\n• The cookie value string can use to ensure that the string does not contain any commas, semicolons, or whitespace (which are disallowed in cookie values).\n• Some user agent implementations support the following cookie prefixes:\n• Signals to the browser that it should only include the cookie in requests transmitted over a secure channel.\n• Signals to the browser that in addition to the restriction to only use the cookie from a secure origin, the scope of the cookie is limited to a path attribute passed down by the server. If the server omits the path attribute the \"directory\" of the request URI is used. It also signals that the domain attribute must not be present, which prevents the cookie from being sent to other domains. For Chrome the path attribute must always be the origin. Note: The dash is considered part of the prefix. Note: These flags are only settable with the attribute. Note: As you can see from the code above, is an accessor property with native setter and getter functions, and consequently is not a data property with a value: what you write is not the same as what you read, everything is always mediated by the JavaScript interpreter.\n\nExample 3: Do something only once In order to use the following code, please replace all occurrences of the word (the name of the cookie) with a custom name. function doOnce() { if ( !document.cookie .split(\"; \") .find((row) => row.startsWith(\"doSomethingOnlyOnce\")) ) { // Note that we are setting `SameSite=None;` in this example because the example // needs to work cross-origin. // It is more common not to set the `SameSite` attribute, which results in the default, // and more secure, value of `SameSite=Lax;` document.cookie = \"doSomethingOnlyOnce=true; expires=Fri, 31 Dec 9999 23:59:59 GMT; SameSite=None; Secure\"; const output = document.getElementById(\"do-once\"); output.textContent = \"> Do something here!\"; } } function clearOutputDoOnce() { const output = document.getElementById(\"do-once\"); output.textContent = \"\"; }\n\nIt is important to note that the attribute does not protect against unauthorized reading of the cookie from a different path. It can be easily bypassed using the DOM, for example by creating a hidden element with the path of the cookie, then accessing this iframe's property. The only way to protect the cookie is by using a different domain or subdomain, due to the same origin policy. Cookies are often used in web applications to identify a user and their authenticated session. Stealing a cookie from a web application leads to hijacking the authenticated user's session. Common ways to steal cookies include using social engineering or by exploiting a cross-site scripting (XSS) vulnerability in the application - The cookie attribute can help to mitigate this attack by preventing access to cookie value through JavaScript. Read more about Cookies and Security."
    },
    {
        "link": "https://github.com/js-cookie/js-cookie",
        "document": "👉👉 If you're viewing this at https://github.com/js-cookie/js-cookie, you're reading the documentation for the main branch. View documentation for the latest release. 👈👈\n\nJavaScript Cookie supports npm under the name .\n\nThe npm package has a field pointing to an ES module variant of the library, mainly to provide support for ES module aware bundlers, whereas its field points to an UMD module for full backward compatibility.\n\nNot all browsers support ES modules natively yet. For this reason the npm package/release provides both the ES and UMD module variant and you may want to include the ES module along with the UMD fallback to account for this:\n\nCreate a cookie that expires 7 days from now, valid across the entire site:\n\nCreate an expiring cookie, valid to the path of the current page:\n\nNote: It is not possible to read a particular cookie by passing one of the cookie attributes (which may or may not have been used when writing the cookie in question):\n\nThe cookie with the name will only be available on if it's visible from where the code is called; the domain and/or path attribute will not have an effect when reading.\n\nDelete a cookie valid to the path of the current page:\n\nIMPORTANT! When deleting a cookie and you're not relying on the default attributes, you must pass the exact same , , and attributes that were used to set the cookie:\n\nNote: Removing a nonexistent cookie neither raises any exception nor returns any value.\n\nIf there is any danger of a conflict with the namespace , the method will allow you to define a new namespace and preserve the original one. This is especially useful when running the script on third party sites e.g. as part of a widget or SDK.\n\nNote: The method is not necessary when using AMD or CommonJS, thus it is not exposed in those environments.\n\nThis project is RFC 6265 compliant. All special characters that are not allowed in the cookie-name or cookie-value are encoded with each one's UTF-8 Hex equivalent using percent-encoding. The only character in cookie-name or cookie-value that is allowed and still encoded is the percent character, it is escaped in order to interpret percent input as literal. Please note that the default encoding/decoding strategy is meant to be interoperable only between cookies that are read/written by js-cookie. To override the default encoding/decoding strategy you need to use a converter.\n\nNote: According to RFC 6265, your cookies may get deleted if they are too big or there are too many cookies in the same domain, more details here.\n\nCookie attribute defaults can be set globally by creating an instance of the api via , or individually for each call to by passing a plain object as the last argument. Per-call attributes override the default attributes.\n\nDefine when the cookie will be removed. Value must be a which will be interpreted as days from time of creation or a instance. If omitted, the cookie becomes a session cookie.\n\nTo create a cookie that expires in less than a day, you can check the FAQ on the Wiki.\n\nDefault: Cookie is removed when the user closes the browser.\n\nA indicating the path where the cookie is visible.\n\nThis means one cannot set a path using in case such pathname contains a filename like so: (or at least, such cookie cannot be read correctly).\n\nIn fact, you should never allow untrusted input to set the cookie attributes or you might be exposed to a XSS attack.\n\nA indicating a valid domain where the cookie should be visible. The cookie will also be visible to all subdomains.\n\nDefault: Cookie is visible only to the domain or subdomain of the page where the cookie was created, except for Internet Explorer (see below).\n\nAssuming a cookie that is being created on :\n\nThis means that if you omit the attribute, it will be visible for a subdomain in IE.\n\nEither or , indicating if the cookie transmission requires a secure protocol (https).\n\nA , allowing to control whether the browser is sending a cookie along with cross-site requests.\n\nNote that more recent browsers are making \"Lax\" the default value even without specifiying anything here.\n\nCreate a new instance of the api that overrides the default decoding implementation. All get methods that rely in a proper decoding to work, such as and , will run the given converter for each cookie. The returned value will be used as the cookie value.\n\nExample from reading one of the cookies that can only be decoded using the function:\n\nCreate a new instance of the api that overrides the default encoding implementation:\n\nReleasing should be done via the GitHub Actions workflow, so that published packages on npmjs.com have package provenance.\n\nGitHub releases are created as a draft and need to be published manually! (This is so we are able to craft suitable release notes before publishing.)\n\nMany thanks to BrowserStack for providing unlimited browser testing free of cost."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Cookies",
        "document": "A cookie (also known as a web cookie or browser cookie) is a small piece of data a server sends to a user's web browser. The browser may store cookies, create new cookies, modify existing ones, and send them back to the same server with later requests. Cookies enable web applications to store limited amounts of data and remember state information; by default the HTTP protocol is stateless. In this article we will explore the main uses of cookies, explain best practices for using them, and look at their privacy and security implications.\n\nYou can specify an expiration date or time period after which the cookie should be deleted and no longer sent. Depending on the attributes set within the header when the cookies are created, they can be either permanent or session cookies:\n• Permanent cookies are deleted after the date specified in the attribute: or after the period specified in the attribute: Note: has been available for longer than , however is less error-prone, and takes precedence when both are set. The rationale behind this is that when you set an date and time, they're relative to the client the cookie is being set on. If the server is set to a different time, this could cause errors.\n• Session cookies — cookies without a or attribute – are deleted when the current session ends. The browser defines when the \"current session\" ends, and some browsers use session restoring when restarting. This can cause session cookies to last indefinitely. Note: If your site authenticates users, it should regenerate and resend session cookies, even ones that already exist, whenever a user authenticates. This approach helps prevent session fixation attacks, where a third-party can reuse a user's session. There are some techniques designed to recreate cookies after they're deleted. These are known as \"zombie\" cookies. These techniques violate the principles of user privacy and control, may violate data privacy regulations, and could expose a website using them to legal liability.\n\nTo update a cookie via HTTP, the server can send a header with the existing cookie's name and a new value. For example: There are several reasons why you might want to do this, for example if a user has updated their preferences and the application wants to reflect the changes in client-side data (you could also do this with a client-side storage mechanism such as Web Storage). In the browser, you can create new cookies via JavaScript using the property, or the asynchronous Cookie Store API. Note that all examples below use , as it is the most widely supported/established option. You can also access existing cookies and set new values for them, provided the attribute isn't set on them (i.e. in the header that created it): Note that, for security purposes, you can't change cookie values by sending an updated header directly when initiating a request, i.e. via or . Note that there are also good reasons why you shouldn't allow JavaScript to modify cookies — i.e. set during creation. See the Security section for more details.\n\nWhen you store information in cookies, by default all cookie values are visible to, and can be changed by, the end user. You really don't want your cookies to be misused — for example accessed/modified by bad actors, or sent to domains where they shouldn't be sent. The potential consequences can range from annoying — apps not working or exhibiting strange behavior — to catastrophic. A criminal could for example steal a session ID and use it to set a cookie that makes it look like they are logged in as someone else, taking control of their bank or e-commerce account in the process. You can secure your cookies in a variety of ways, which are reviewed in this section.\n\nYou can ensure that cookies are sent securely and aren't accessed by unintended parties or scripts in one of two ways: with the attribute and the attribute:\n• A cookie with the attribute is only sent to the server with an encrypted request over the HTTPS protocol. It's never sent with unsecured HTTP (except on localhost), which means man-in-the-middle attackers can't access it easily. Insecure sites (with in the URL) can't set cookies with the attribute. However, don't assume that prevents all access to sensitive information in cookies. For example, someone with access to the client's hard disk (or JavaScript if the attribute isn't set) can read and modify the information.\n• A cookie with the attribute can't be accessed by JavaScript, for example using ; it can only be accessed when it reaches the server. Cookies that persist user sessions for example should have the attribute set — it would be really insecure to make them available to JavaScript. This precaution helps mitigate cross-site scripting (XSS) attacks. Note: Depending on the application, you may want to use an opaque identifier that the server looks up rather than storing sensitive information directly in cookies, or investigate alternative authentication/confidentiality mechanisms such as JSON Web Tokens.\n\nDefine where cookies are sent The and attributes define the scope of a cookie: what URLs the cookies are sent to.\n• The attribute specifies which server can receive a cookie. If specified, cookies are available on the specified server and its subdomains. For example, if you set from , cookies are available on that domain and subdomains like . If the header does not specify a attribute, the cookies are available on the server that sets it but not on its subdomains. Therefore, specifying is less restrictive than omitting it. Note that a server can only set the attribute to its own domain or a parent domain, not to a subdomain or some other domain. So, for example, a server with domain could set the attribute to or , but not or (the cookies would still be sent to subdomains such as though). See Invalid domains for more details.\n• The attribute indicates a URL path that must exist in the requested URL in order to send the header. For example: The (\"/\") character is considered a directory separator, and subdirectories match as well. For example, if you set , these request paths match:\n\nThe attribute lets servers specify whether/when cookies are sent with cross-site requests — i.e. third-party cookies. Cross-site requests are requests where the site (the registrable domain) and/or the scheme (http or https) do not match the site the user is currently visiting. This includes requests sent when links are clicked on other sites to navigate to your site, and any request sent by embedded third-party content. helps to prevent leakage of information, preserving user privacy and providing some protection against cross-site request forgery attacks. It takes three possible values: , , and :\n• causes the browser to only send the cookie in response to requests originating from the cookie's origin site. This should be used when you have cookies relating to functionality that will always be behind an initial navigation, such as authentication or storing shopping cart information. Note: Cookies that are used for sensitive information should also have a short lifetime.\n• is similar, except the browser also sends the cookie when the user navigates to the cookie's origin site (even if the user is coming from a different site). This is useful for cookies affecting the display of a site — for example you might have partner product information along with an affiliate link on your website. When that link is followed to the partner website, they might want to set a cookie stating that the affiliate link was followed, which displays a reward banner and provides a discount if the product is purchased.\n• specifies that cookies are sent on both originating and cross-site requests. This is useful if you want to send cookies along with requests made from third-party content embedded in other sites, for example, ad-tech or analytics providers. Note that if is set then the attribute must also be set — requires a secure context. If no attribute is set, the cookie is treated as by default.\n\nBecause of the design of the cookie mechanism, a server can't confirm that a cookie was set from a secure origin or even tell where a cookie was originally set. A vulnerable application on a subdomain can set a cookie with the attribute, which gives access to that cookie on all other subdomains. This mechanism can be abused in a session fixation attack. See session fixation for primary mitigation methods. As a defense-in-depth measure, however, you can use cookie prefixes to assert specific facts about the cookie. Two prefixes are available:\n• : If a cookie name has this prefix, it's accepted in a header only if it's also marked with the attribute, was sent from a secure origin, does not include a attribute, and has the attribute set to . In other words, the cookie is domain-locked.\n• : If a cookie name has this prefix, it's accepted in a header only if it's marked with the attribute and was sent from a secure origin. This is weaker than the prefix. The browser will reject cookies with these prefixes that don't comply with their restrictions. This ensures that subdomain-created cookies with prefixes are either confined to a subdomain or ignored completely. As the application server only checks for a specific cookie name when determining if the user is authenticated or a CSRF token is correct, this effectively acts as a defense measure against session fixation. Note: On the server, the web application must check for the full cookie name including the prefix. User agents do not strip the prefix from the cookie before sending it in a request's header. For more information about cookie prefixes and the current state of browser support, see the Prefixes section of the Set-Cookie reference article.\n\nEarlier on we talked about how the attribute can be used to control when third-party cookies are sent, and that this can help preserve user privacy. Privacy is a very important consideration when building websites which, when done right, can build trust with your users. If done badly, it can completely erode that trust and cause all kinds of other problems. Third-party cookies can be set by third-party content embedded in sites via s. They have many legitimate uses include sharing user profile information, counting ad impressions, or collecting analytics across different related domains. However, third-party cookies can also be used to create creepy, invasive user experiences. A third-party server can create a profile of a user's browsing history and habits based on cookies sent to it by the same browser when accessing multiple sites. The classic example is when you search for product information on one site and are then chased around the web by adverts for similar products wherever you go. Browser vendors know that users don't like this behavior, and as a result have all started to block third-party cookies by default, or at least made plans to go in that direction. Third-party cookies (or just tracking cookies) may also be blocked by other browser settings or extensions. Note: Cookie blocking can cause some third-party components (such as social media widgets) not to function as intended. As browsers impose further restrictions on third-party cookies, developers should start to look at ways to reduce their reliance on them. See our Third-party cookies article for detailed information on third-party cookies, the issues associated with them, and what alternatives are available. See our Privacy landing page for more information on privacy in general.\n\nLegislation or regulations that cover the use of cookies include:\n• The General Data Privacy Regulation (GDPR) in the European Union\n• The ePrivacy Directive in the EU These regulations have global reach. They apply to any site on the World Wide Web that users from these jurisdictions access (the EU and California, with the caveat that California's law applies only to entities with gross revenue over 25 million USD, among things). These regulations include requirements such as:\n• Notifying users that your site uses cookies.\n• Allowing users to opt out of receiving some or all cookies.\n• Allowing users to use the bulk of your service without receiving cookies. There may be other regulations that govern the use of cookies in your locality. The burden is on you to know and comply with these regulations. There are companies that offer \"cookie banner\" code that helps you comply with these regulations. Note: Companies should disclose the types of cookies they use on their sites for transparency purposes and to comply with regulations. For example, see Google's notice on the types of cookies it uses and Mozilla's Websites, Communications & Cookies Privacy Notice."
    },
    {
        "link": "https://cs.uic.edu/~ckanich/cs484/f24/readings/chapter-2-client-side-web-development/statefulness-1-cookies/index.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/3400759/how-can-i-list-all-cookies-for-the-current-page-with-javascript",
        "document": "Experimental Spec (poor browser support as of Apr 2023, use 2022 answer):\n\nNote: You cannot get cookies in browser code.\n\nMany people have already mentioned that gets you all the cookies (except ones).\n\nI'll just add a snippet to keep up with the times.\n\nThe snippet will return an object with cookie names as the keys with cookie values as the values.\n\nEdit: Someone correctly pointed out that you'll face issues if your cookie key or value has an in it. Maybe consider using escape sequences to mitigate this?"
    },
    {
        "link": "https://w3schools.com/css/css_positioning.asp",
        "document": "The property specifies the type of positioning method used for an element (static, relative, fixed, absolute or sticky).\n\nThe property specifies the type of positioning method used for an element.\n\nThere are five different position values:\n\nElements are then positioned using the top, bottom, left, and right properties. However, these properties will not work unless the property is set first. They also work differently depending on the position value.\n\nStatic positioned elements are not affected by the top, bottom, left, and right properties.\n\nAn element with is not positioned in any special way; it is always positioned according to the normal flow of the page:\n\nHere is the CSS that is used:\n\nAn element with is positioned relative to its normal position.\n\nSetting the top, right, bottom, and left properties of a relatively-positioned element will cause it to be adjusted away from its normal position. Other content will not be adjusted to fit into any gap left by the element.\n\nHere is the CSS that is used:\n\nAn element with is positioned relative to the viewport, which means it always stays in the same place even if the page is scrolled. The top, right, bottom, and left properties are used to position the element.\n\nA fixed element does not leave a gap in the page where it would normally have been located.\n\nNotice the fixed element in the lower-right corner of the page. Here is the CSS that is used:\n\nAn element with is positioned relative to the nearest positioned ancestor (instead of positioned relative to the viewport, like fixed).\n\nHowever; if an absolute positioned element has no positioned ancestors, it uses the document body, and moves along with page scrolling.\n\nNote: Absolute positioned elements are removed from the normal flow, and can overlap elements.\n\nHere is a simple example:\n\nHere is the CSS that is used:\n\nAn element with is positioned based on the user's scroll position.\n\nA sticky element toggles between and , depending on the scroll position. It is positioned relative until a given offset position is met in the viewport - then it \"sticks\" in place (like position:fixed).\n\nIn this example, the sticky element sticks to the top of the page ( ), when you reach its scroll position.\n\nHow to position text over an image:\n\nSet the shape of an element\n\n This example demonstrates how to set the shape of an element. The element is clipped into this shape, and displayed."
    },
    {
        "link": "https://stackoverflow.com/questions/15650056/fixed-position-in-responsive-design",
        "document": "It appears that you want is , the difference being that absolute images do not move while scrolling.\n\n http://www.impressivewebs.com/absolute-position-css/\n\nIt's worth taking a look at this link in order to see the differences between relative, absolute, and fixed positioning:\n\n http://css-tricks.com/absolute-relative-fixed-positioining-how-do-they-differ/"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/CSS_layout/Positioning",
        "document": "Positioning allows you to take elements out of normal document flow and make them behave differently, for example, sitting on top of one another or always remaining in the same place inside the browser viewport. This article explains the different values and how to use them. Structuring content with HTML, CSS Styling basics, Fundamental text and font styling, familiarity with CSS layout fundamental concepts.\n• positioning is the default way elements are positioned on the page.\n• Relatively positioned elements remain in the normal flow, but absolute (and fixed/sticky) positioning takes elements completely out of the normal flow to sit in a separate layer.\n• Final layout position can be modified using the , , , and properties, but these have different effects depending on the set value.\n• Setting the positioning context of a positioned element by positioning an ancestor element. We'd like you to do the following exercises on your local computer. If possible, grab a copy of from our GitHub repo (source code here) and use that as a starting point.\n\nStatic positioning is the default that every element gets. It just means \"put the element into its default position in the normal flow — nothing special to see here.\" To see this (and get your example set up for future sections) first add a of to the second in the HTML: Now add the following rule to the bottom of your CSS: If you save and refresh, you'll see no difference at all, except for the updated background color of the 2nd paragraph. This is fine — as we said before, static positioning is the default behavior! Note: You can see the example at this point live at (see source code).\n\n, , , and are used alongside to specify exactly where to move the positioned element to. To try this out, add the following declarations to the rule in your CSS: Note: The values of these properties can take any units you'd reasonably expect: pixels, mm, rems, %, etc. If you now save and refresh, you'll get a result something like this: <h1>Relative positioning</h1> <p> I am a basic block level element. My adjacent block level elements sit on new lines below me. </p> <p class=\"positioned\"> By default we span 100% of the width of our parent element, and we are as tall as our child content. Our total width and height is our content + padding + border width/height. </p> <p> We are separated by our margins. Because of margin collapsing, we are separated by the width of one of our margins, not both. </p> <p> Inline elements <span>like this one</span> and <span>this one</span> sit on the same line as one another, and adjacent text nodes, if there is space on the same line. Overflowing inline elements <span>wrap onto a new line if possible — like this one containing text</span>, or just go on to a new line if not, much like this image will do: <img src=\"https://mdn.github.io/shared-assets/images/examples/long.jpg\" alt=\"snippet of cloth\" /> </p> Cool, huh? Ok, so this probably wasn't what you were expecting. Why has it moved to the bottom and to the right if we specified top and left? This may seem counterintuitive. You need to think of it as if there's an invisible force that pushes the specified side of the positioned box, moving it in the opposite direction. So, for example, if you specify , it's as if a force will push the top of the box, causing it to move downwards by 30px. Note: You can see the example at this point live at (see source code).\n\nLet's try changing the position declaration in your code as follows: If you now save and refresh, you should see something like so: <h1>Absolute positioning</h1> <p> I am a basic block level element. My adjacent block level elements sit on new lines below me. </p> <p class=\"positioned\"> By default we span 100% of the width of our parent element, and we are as tall as our child content. Our total width and height is our content + padding + border width/height. </p> <p> We are separated by our margins. Because of margin collapsing, we are separated by the width of one of our margins, not both. </p> <p> inline elements <span>like this one</span> and <span>this one</span> sit on the same line as one another, and adjacent text nodes, if there is space on the same line. Overflowing inline elements <span>wrap onto a new line if possible — like this one containing text</span>, or just go on to a new line if not, much like this image will do: <img src=\"https://mdn.github.io/shared-assets/images/examples/long.jpg\" alt=\"snippet of cloth\" /> </p> First of all, note that the gap where the positioned element should be in the document flow is no longer there — the first and third elements have closed together like it no longer exists! Well, in a way, this is true. An absolutely positioned element no longer exists in the normal document flow. Instead, it sits on its own layer separate from everything else. This is very useful: it means that we can create isolated UI features that don't interfere with the layout of other elements on the page. For example, popup information boxes, control menus, rollover panels, UI features that can be dragged and dropped anywhere on the page, and so on. Second, notice that the position of the element has changed. This is because , , , and behave in a different way with absolute positioning. Rather than positioning the element based on its relative position within the normal document flow, they specify the distance the element should be from each of the containing element's sides. In this case, we are saying that the absolutely positioned element should sit 30px from the top of the containing element (the initial containing block, in this case, see below) and 30px from the left. Note: You can use , , , and to resize elements if you need to. Try setting and on your positioned elements and see what happens! Put it back again afterwards… Note: Yes, margins still affect positioned elements. Margin collapsing doesn't, however. Note: You can see the example at this point live at (see source code).\n\nWhich element is the \"containing element\" of an absolutely positioned element? This is very much dependent on the property value of the ancestors of the positioned element. If no ancestor elements have their position property explicitly defined, then by default all ancestor elements will have a static position. The result of this is the absolutely positioned element will be contained in the initial containing block. The initial containing block has the dimensions of the viewport and is also the block that contains the element. In other words, the absolutely positioned element will be displayed outside of the element and be positioned relative to the initial viewport. The positioned element is nested inside the in the HTML source, but in the final layout it's 30px away from the top and the left edges of the page. We can change the positioning context, that is, which element the absolutely positioned element is positioned relative to. This is done by setting positioning on one of the element's ancestors: to one of the elements it's nested inside of (you can't position it relative to an element it's not nested inside of). To see this, add the following declaration to your rule: This should give the following result: <h1>Positioning context</h1> <p> I am a basic block level element. My adjacent block level elements sit on new lines below me. </p> <p class=\"positioned\"> Now I'm absolutely positioned relative to the <code><body></code> element, not the <code><html></code> element! </p> <p> We are separated by our margins. Because of margin collapsing, we are separated by the width of one of our margins, not both. </p> <p> inline elements <span>like this one</span> and <span>this one</span> sit on the same line as one another, and adjacent text nodes, if there is space on the same line. Overflowing inline elements <span>wrap onto a new line if possible — like this one containing text</span>, or just go on to a new line if not, much like this image will do: <img src=\"https://mdn.github.io/shared-assets/images/examples/long.jpg\" alt=\"snippet of cloth\" /> </p> The positioned element now sits relative to the element. Note: You can see the example at this point live at (see source code).\n\nAll this absolute positioning is good fun, but there's another feature we haven't considered yet. When elements start to overlap, what determines which elements appear over others and which elements appear under others? In the example we've seen so far, we only have one positioned element in the positioning context, and it appears on the top since positioned elements win over non-positioned elements. What about when we have more than one? Try adding the following to your CSS to make the first paragraph absolutely positioned too: At this point you'll see the first paragraph colored lime, moved out of the document flow, and positioned a bit above from where it originally was. It's also stacked below the original paragraph where the two overlap. This is because the paragraph is the second paragraph in the source order, and positioned elements later in the source order win over positioned elements earlier in the source order. Can you change the stacking order? Yes, you can, by using the property. \"z-index\" is a reference to the z-axis. You may recall from previous points in the course where we discussed web pages using horizontal (x-axis) and vertical (y-axis) coordinates to work out positioning for things like background images and drop shadow offsets. For languages that run left to right, (0,0) is at the top left of the page (or element), and the x- and y-axes run across to the right and down the page. Web pages also have a z-axis: an imaginary line that runs from the surface of your screen towards your face (or whatever else you like to have in front of the screen). values affect where positioned elements sit on that axis; positive values move them higher up the stack, negative values move them lower down the stack. By default, positioned elements all have a of , which is effectively 0. To change the stacking order, try adding the following declaration to your rule: You should now see the lime paragraph on top: <h1>z-index</h1> <p> I am a basic block level element. My adjacent block level elements sit on new lines below me. </p> <p class=\"positioned\"> Now I'm absolutely positioned relative to the <code><body></code> element, not the <code><html></code> element! </p> <p> We are separated by our margins. Because of margin collapsing, we are separated by the width of one of our margins, not both. </p> <p> inline elements <span>like this one</span> and <span>this one</span> sit on the same line as one another, and adjacent text nodes, if there is space on the same line. Overflowing inline elements <span>wrap onto a new line if possible — like this one containing text</span>, or just go on to a new line if not, much like this image will do: <img src=\"https://mdn.github.io/shared-assets/images/examples/long.jpg\" alt=\"snippet of cloth\" /> </p> Note that only accepts unitless index values; you can't specify that you want one element to be 23 pixels up the Z-axis — it doesn't work like that. Higher values will go above lower values and it's up to you what values you use. Using values of 2 or 3 would give the same effect as values of 300 or 40000. Note: You can see an example for this live at (see source code).\n\nLet's now look at fixed positioning. This works in exactly the same way as absolute positioning, with one key difference: whereas absolute positioning fixes an element in place relative to its nearest positioned ancestor (the initial containing block if there isn't one), fixed positioning fixes an element in place relative to the visible portion of the viewport. This means that you can create useful UI items that are fixed in place, like persistent navigation menus that are always visible no matter how much the page scrolls. Let's put together a simple example to show what we mean. First of all, delete the existing and rules from your CSS. Now update the rule to remove the declaration and add a fixed height, like so: Now we're going to give the <h1> element and have it sit at the top of the viewport. Add the following rule to your CSS: The is required to make it stick to the top of the screen. We give the heading the same width as the content column and then a white background and some padding and margin so the content won't be visible underneath it. If you save and refresh, you'll see a fun little effect of the heading staying fixed — the content appears to scroll up and disappear underneath it. But notice how some of the content is initially clipped under the heading. This is because the positioned heading no longer appears in the document flow, so the rest of the content moves up to the top. We could improve this by moving the paragraphs all down a bit. We can do this by setting some top margin on the first paragraph. Add this now: You should now see the finished example: <h1>Fixed positioning</h1> <p> I am a basic block level element. My adjacent block level elements sit on new lines below me. </p> <p class=\"positioned\">I'm not positioned any more.</p> <p> We are separated by our margins. Because of margin collapsing, we are separated by the width of one of our margins, not both. </p> <p> Inline elements <span>like this one</span> and <span>this one</span> sit on the same line as one another, and adjacent text nodes, if there is space on the same line. Overflowing inline elements <span>wrap onto a new line if possible — like this one containing text</span>, or just go on to a new line if not, much like this image will do: <img src=\"https://mdn.github.io/shared-assets/images/examples/long.jpg\" alt=\"snippet of cloth\" /> </p> Note: You can see an example for this live at (see source code)."
    },
    {
        "link": "https://medium.com/@bigton7307/position-fixed-but-responsive-f9a2f6f1d86e",
        "document": "I started a project for school designing a website with CSS and HTML. Over the course of several lessons I learned how to use the Position property efficiently. The position property is used to move an element around in an HTML website. The five different values for the position property are static, sticky, relative, absolute, and… fixed. Its pretty simple to implement these into your code but knowing the function of each value is important.\n\nStatic is your normal “resting” position. Elements have static as a default position. Position relative is used to move an element around from its normal position. Any element moved using position relative does not affect the position of other elements. The values used for position relative are top, bottom, left, right which can be used for position absolute as well. Position absolute removes an element from the normal document flow. You can use position absolute if you have position relative on the parent container of the element. Position fixed is similar to position absolute. It is used if you have an element that you want to stay in the same spot while you scroll. Position sticky is similar to position fixed but it is a part of the normal document flow.\n\nTypically for a navbar you would use position fixed so u can see the navigation links at the top while you are scrolling through the webpage. I was doing this for a project and I was having an issue with the responsiveness of the navbar. Every time I would shrink the page the hamburger icon would not shrink with the page. Instead it would stay where I positioned it for the tablet view.\n\nI tried adding position fixed to the elements in the navbar, I tried removing the fixed position from the navbar and adding it only to the elements in the navbar, I tried rearranging my HTML (big mistake!) but nothing would change.\n\nThis plagued me for a month. I would be thinking of possible solutions to try even while I was working. Eventually I got some assistance and the solution would change how I problem solve for good. Turns out the problem was not with the navbar at all but due to some elements further down the page. Whenever I would shrink the viewport some of these elements were not properly set up to be responsive so they would not shrink with the viewport.\n\nThis is my HTML\n\nThis is my CSS\n\nOnce I resized these elements I had zero issues with the navbar shrinking with the viewport.\n\nMoral of the story is if you are having issues with your code the problem isn’t always within the element itself or the property you’re using. Sometimes you just need to check further down the line to find your problem."
    },
    {
        "link": "https://quora.com/How-do-you-approach-positioning-in-CSS-responsive-design",
        "document": "Something went wrong. Wait a moment and try again."
    }
]