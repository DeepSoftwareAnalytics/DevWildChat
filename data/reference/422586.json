[
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://geeksforgeeks.org/list-methods-python",
        "document": "Python list methods are built-in functions that allow us to perform various operations on lists, such as adding, removing, or modifying elements. In this article, we’ll explore all Python list methods with a simple example.\n\nLet’s look at different list methods in Python:\n• None : Adds an element to the end of the list.\n• None : Removes all elements from the list.\n• None : Returns the number of times a specified element appears in the list.\n• None : Adds elements from another list to the end of the current list.\n• None : Returns the index of the first occurrence of a specified element.\n• None : Inserts an element at a specified position.\n• None : Removes and returns the element at the specified position (or the last element if no index is specified).\n• None : Removes the first occurrence of a specified element.\n• None : Reverses the order of the elements in the list.\n• None : Sorts the list in ascending order (by default).\n\nIn the code below, we will add an element to the list.\n\nIn the code below, we will create a copy of a list.\n\nIn the code below, we will clear all elements from the list.\n\nIn the code below, we will count the occurrences of a specific element in the list.\n\nIn the code below, we will extend the list by adding elements from another list.\n\nIn the code below, we will find the index of a specific element in the list.\n\nIn the code below, we will insert an element at a specific position in the list.\n\nIn the code below, we will remove the last element from the list.\n\nIn the code below, we will remove the first occurrence of a specified element from the list.\n\nIn the code below, we will reverse the order of the elements in the list.\n\nIn the code below, we will sort the elements of the list in ascending order"
    },
    {
        "link": "https://w3schools.com/python/ref_list_pop.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://datacamp.com/tutorial/python-pop",
        "document": "Learn the art of writing your own functions in Python, as well as key concepts like scoping and error handling."
    },
    {
        "link": "https://pythonsnacks.com/p/python-list-methods-functions-example",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/63354305/python-catching-indexerror-in-user-input",
        "document": "Having trouble getting my input to catch index errors regarding a function that searches list. Below is my code\n\nWhen entering an input outside of the index, I get the following error:\n\nHow would I go about getting it to catch the error?"
    },
    {
        "link": "https://stackoverflow.com/questions/54981448/how-to-avoid-indexerror-list-index-out-of-range-error",
        "document": "Suppose there are a list called ' ' and an int variable called ' '. Basically, the list ' ' might change over time and hence the ' ' might raise ' '. However, I just want to make record when this error occurs since it is not that important. To avoid this error, my basic solutions currently are:\n\nExcept for statement, are there other solutions to avoid the 'IndexError: list index out of range' error?"
    },
    {
        "link": "https://geeksforgeeks.org/python-list-index-out-of-range-indexerror",
        "document": "How to Fix IndexError – List Index Out of Range in Python\n\nIndexError: list index out of range is a common error in Python when working with lists. This error happens when we try to access an index that does not exist in the list. This article will explore the causes of this error, how to fix it and best practices for avoiding it.\n\nCauses of IndexError: List Index Out of Range\n\nThis error usually occurs under the following conditions:\n\n1. Accessing an index that exceeds the length of the list\n\nHere’s how we can resolve and avoid this error with examples:\n\nAlways verify the length of the list before accessing an index.\n\nNegative indexes start from the end of the list. So, make sure that index don’t exceed the list boundaries.\n\nWhen iterating over a list make sure that index don’t exceed the list boundaries.\n\nEnumerate provides the index and value of a list and this index will never go out of bounds.\n\nUsing a try-except block we can prevent our program to crash and allows us to handle errors easily."
    },
    {
        "link": "https://freecodecamp.org/news/list-index-out-of-range-python-error-message-solved",
        "document": "In this article you'll see a few of the reasons that cause the Python error.\n\nBesides knowing why this error occurs in the first place, you'll also learn some ways to avoid it.\n\nHow to Create a List in Python\n\nTo create a list object in Python, you need to:\n• and include 0 or more list items inside square brackets, . Each list item needs to be separated by a comma.\n\nFor example, to create a list of names you would do the following:\n\nThe code above created a list called that has four values: .\n\nHow to Check the Length of a List in Python\n\nTo check the length of a list in Python, use Python's build-in method.\n\nwill return an integer, which will be the number of items stored in the list.\n\nThere are four items stored in the list, therefore the length of the list will be four.\n\nHow to Access Individual List Items in Python\n\nEach item in a list has its own index number.\n\nIndexing in Python, and most modern programming languages, starts at 0.\n\nThis means that the first item in a list has an index of 0, the second item has an index of 1, and so on.\n\nYou can use the index number to access the individual item.\n\nTo access an item in a list using its index number, first write the name of the list. Then, inside square brackets, include the intiger that corresponds with the item's index number.\n\nTaking the example from earlier, this is how you would access each item inside the list using its index number:\n\nYou can also use negative indexing to access items inside lists in Python.\n\nTo access the last item, you use the index value of -1. To acces the second to last item, you use the index value of -2.\n\nHere is how you would access each item inside a list using negative indexing:\n\nWhy does the error occur in Python?\n\nUsing an index number that is out of the range of the list\n\nYou'll get the error when you try and access an item using a value that is out of the index range of the list and does not exist.\n\nThis is quite common when you try to access the last item of a list, or the first one if you're using negative indexing.\n\nLet's go back to the list we've used so far.\n\nSay I want to access the last item, \"Lenny\", and try to do so by using the following code:\n\nGenerally, the index range of a list is , with being the total number of values in the list.\n\nWith the total values of the list above being , the index range is .\n\nNow, let's try to access an item using negative indexing.\n\nSay I want to access the first item in the list, \"Kelly\", by using negative indexing.\n\nWhen using negative indexing, the index range of a list is , where the total number of items contained in the list.\n\nWith the total number of items in the list being , the index range is .\n\nUsing the wrong value in the function in a Python loop\n\nYou'll get the error when iterating through a list and trying to access an item that doesn't exist.\n\nOne common instance where this can occur is when you use the wrong integer in Python's function.\n\nThe function typically takes in one integer number, which indicates where the counting will stop.\n\nFor example, indicates that the counting will start from and end at .\n\nSo, by default, the counting starts at position , is incremented by each time, and the number is up to – but not including – the position where the counting will stop.\n\nLet's take the following example:\n\nHere, the list has four values.\n\nI wanted to loop through the list and print out each value.\n\nWhen I used I was telling the Python interpreter to print the values that are at the positions .\n\nHowever, there is no item in position 4.\n\nYou can see this by first printing out the number of the position and then the value at that position.\n\nYou see that at position is \"Kelly\", at position is \"Nelly\", at position is \"Jimmy\" and at position is \"Lenny\".\n\nWhen it comes to position four, which was specified with which indicates positions of , there is nothing to print out and therefore the interpreter throws an error.\n\nOne way to fix this is to lower the integer in :\n\nAnother way to fix this when using a loop is to pass the length of the list as an argument to the function. You do this by using the built-in Python function, as shown in an earlier section:\n\nWhen passing as an argument to , make sure that you don't make the following mistake:\n\nAfter running the code, you'll again get an error:\n\nHopefully this article gave you some insight into why the error occurs and some ways you can avoid it.\n\nIf you want to learn more about Python, check out freeCodeCamp's Python Certification. You'll start learning in an interacitve and beginner-friendly way. You'll also build five projects at the end to put into practice and help reinforce what you learned.\n\nThanks for reading and happy coding!"
    },
    {
        "link": "https://reviewnprep.com/blog/mastering-exception-handling-in-python-real-life-examples-and-best-practices",
        "document": "Welcome to the beginner’s guide to exception handling in Python! As Python continues to dominate the programming world, it’s essential for developers of all levels to master the art of handling exceptions effectively. Whether you’re just starting out or looking to refresh your skills, this comprehensive guide will take you through the ins and outs of exception handling in Python, using practical examples to bring the concepts to life.\n\nException handling plays a crucial role in writing reliable and robust code, ensuring that your programs gracefully handle unexpected errors and prevent crashes. In this guide, we’ll dive deep into the world of exceptions, exploring the different types of exceptions, how to raise and handle them, and the best practices for error handling in Python.\n\nThrough a series of practical examples, you’ll gain hands-on experience in dealing with common exceptions, such as ValueError, FileNotFoundError, and IndexError. By the end of this guide, you’ll have the confidence and skills to tackle any unforeseen errors that come your way, making your Python programs more resilient and user-friendly.\n\nSo let’s get started on this exception handling journey and level up your Python coding skills!\n\nExceptions are error conditions that disrupt the normal flow of a program. They can occur due to a wide range of reasons, such as invalid input, file operations, or unexpected issues during execution.\n\nThese exceptions halt the normal flow of the program. Without exception handling, our Python scripts would crash whenever they encounter an error condition. By leveraging built-in exception handling tools like the try-except block, we can account for potential exceptions and take appropriate actions.\n\nPython has a wide range of built-in exception classes for different types of errors:\n• – Raised when a module/library cannot be imported\n• – Occurs when trying to access an invalid index in a list, tuple, etc\n• – Happens when using an undeclared variable\n• – Indicates two incompatible types are mixed in an operation\n• – Thrown when dividing by zero\n• – Raised when a file cannot be found at a specified path\n\nAnd many more specialized exceptions…\n\nBeing aware of common error types helps write code that catches the exceptions specific to our program logic and use case.\n\nThe basic structure for handling exceptions in Python is the block. It allows you to catch and handle exceptions gracefully:\n\nThe code inside the try clause is executed. If that code raises no exceptions, then no output from except clause is generated. But if an exception occurs, it is caught and the except block with the matching exception type is executed.\n\nWe can thus anticipate errors and ensure the program doesn’t crash if things go wrong.\n\nUsing Multiple Except Blocks for Different Types of Exceptions\n\nYou can use multiple blocks to handle different types of exceptions:\n\nHaving specific except blocks allow handling exceptions differently instead of generic handling.\n\nThe Else Clause and Finally Clause in Exception Handling\n\nThe clause is executed if the code in the block doesn’t raise any exceptions. The clause is always executed, regardless of whether an exception occurred or not:\n\nThe finally clause helps execute cleanup code like closing files, connections etc irrespective of exceptions.\n\nAlong with built-in exceptions, we can define custom exception classes by subclassing Exception:\n\nWe can raise exceptions manually with raise and catch them later:\n\nThis makes code more readable by separating custom error scenarios.\n\nBest Practices for Exception Handling in Python\n\nHere are some best practices to write clean, robust exception handling:\n• Keep try blocks small and focused to properly handle exceptions\n• Catch specific exceptions instead of generic Exception class to differentiate errors\n• Print custom error messages from except blocks upon failures\n• Use finally clause to execute sections of cleanup code reliably\n• Use blocks only where needed.\n• Don’t wrap your entire code in a massive block; limit it to potential error-prone sections.\n• Avoid using without specifying the exception type, as it can catch unintended errors.\n• Use logging to record exceptions for later analysis.\n\nMastering the basics of exception handling in Python is crucial for writing robust and error-resistant code. By understanding common types of exceptions, using try-except blocks effectively, and following best practices, you can create code that gracefully handles unexpected issues, making your applications more reliable and user-friendly.\n\nWhether you’re working on file operations, game development, or any other project, effective exception handling is a skill that will serve you well in your programming journey.\n\nI hope this guide gave you a solid understanding of key exception handling principles along with actionable coding examples. These learnings will help you eliminate crashes in your Python codebase and handle failures gracefully!"
    }
]