[
    {
        "link": "https://blog.angular-university.io/angular-custom-form-controls",
        "document": "The Angular Forms and ReactiveForms modules come with a series of built-in directives that make it very simple to bind standard HTML elements like inputs, checkboxes, text areas, etc. to a form group.\n\nBesides these standard HTML elements, we might also want to use custom form controls, like dropdowns, selection boxes, toggle buttons, sliders, or many other types of commonly used custom form components.\n\nFor these custom controls, we would like to have the ability to configure them as form fields using the exact same directives ( , ,\n\n ) as we use for standard input boxes.\n\nIn this guide, we are going to learn exactly how to take an existing custom form control component and make it fully compatible with the Angular Forms API, so that the component can participate in the parent form validation and value tracking mechanisms.\n• if we are using template driven forms, we will be able to plug the custom component to the form simply by using\n• and in the case of reactive forms, we will be able to add the custom component to the form using (or )\n\nWe will be building in this guide a simple quantity selector component, that can be used to increment or decrement a value. The component will be part of a form and will be marked as in error in case that the counter does not match a valid range.\n\nThe new custom form control will be fully compatible with the built-in Angular Forms Validators , as well as any other built-in or custom validators.\n\nWe will also learn in this guide how to create reusable nested forms, which are form sections that be reused in many different forms.\n\nThe typical example of such type of nested forms is an address sub-form, and we are going to build one in this post.\n\nIn this post, we will cover the following topics:\n• What are form control value accessors?\n• How to implement nested form groups (an address nested form)\n\nThis post is part of our ongoing series on Angular Forms, you can find all the articles available here.\n\nSo without further ado, let's get started learning everything that we need to know for creating our own custom form controls and nested forms!\n\nIn order to know how to build a custom form control, we need to first understand how the built-in form controls work.\n\nThe built-in form controls target native HTML elements such as inputs, text areas, checkboxes, etc.\n\nHere is an example of a simple form with a couple of plain HTML form fields:\n\nAs we can see, we have here a couple of standard form controls, with the\n\n property applied to it. And this is how the HTML element gets binded to the form.\n\nWhenever the user interacts with the form inputs, the form value and validity state will be automatically re-calculated.\n\nSo how does this all work under the hood then?\n\nWhat are control value accessors?\n\nWhat happens is that, under the hood, the Angular forms module is applying to each native HTML element a built-in Angular directive, which will be responsible for tracking the value of the field, and communicate it back to the parent form.\n\nThis type of special directive is known as a control value accessor directive.\n\nTake for example the checkbox field of the form above. There is a built-in directive which is part of the reactive forms module that is designed to specifically track the value of a checkbox, and nothing more.\n\nHere is the simplified declaration of this directive:\n\nAs we can see by the selector, this value tracking directive specifically targets HTML inputs of type checkbox only, but only if the , or\n\n properties are applied to it.\n\nIf this directive only targets checkboxes, then what about all the other types of form controls, like text inputs or text areas?\n\nWell, each of those control types has their own value accessor directive, which is different than .\n\nAll of those directives are built-in into the Angular Forms module and cover only the standard HTML form controls.\n\nThis means that if we want to implement our own custom form control, we are going to have to implement a custom value accessor for it as well.\n\nThe custom form control that we will build\n\nLet's say that we want to build a custom form control that represents a numeric counter with increase and decrease buttons, for selecting an order quantity for example.\n\nEach time that the buttons are pressed, the counter should be incremented or decremented by a configurable amount.\n\nWe can configure this control to specify a maximum value allowed for the form field, and mark it as invalid if the range is not met.\n\nHere is what the numeric form control will look like:\n\nAnd here is the implementation code for this simple component, without any form functionality added yet:\n\nIn its current form, this component is not compatible with either template-driven or reactive forms.\n\nWe would like to be able to add this component to a form in a very similar way to how we add a standard HTML input to a form, by either adding the\n\n or directives to it:\n\nWe would also like for this component to be compatible with the built-in validators, and use them to make the field mandatory and set a maximum value:\n\nBut in the case of the current version of our control, if we would try to do so we would get an error:\n\nIn order to fix this error, and make the component compatible with Angular Forms, we need to give this form control a value accessor, just like the case of native HTML elements like text inputs, checkboxes, etc.\n\nIn order to do that, we are going to make the component implement the\n\n interface.\n\nLet's go over the methods of the ControlValueAccessor interface. Remember, they are not meant to be called directly by our code as these are framework callbacks.\n\nAll of these methods are meant to be called only by the Forms module at runtime, and they are meant to facilitate communication between our form control and the parent form.\n\nHere are the methods of this interface, and how they work:\n• writeValue: this method is called by the Forms module to write a value into a form control\n• registerOnChange: When a form value changes due to user input, we need to report the value back to the parent form. This is done by calling a callback, that was initially registered with the control using the registerOnChange method\n• registerOnTouched: When the user first interacts with the form control, the control is considered to have the status touched, which is useful for styling. In order to report to the parent form that the control was touched, we need to use a callback registered using the registerOnToched method\n• setDisabledState: form controls can be enabled and disabled using the Forms API. This state can be transmitted to the form control via the setDisabledState method\n\nAnd here is the component, with the interface already implemented:\n\nLet's now go through each of the methods one by one, and explain how they were implemented.\n\nThe method is called by the Angular forms module whenever the parent form wants to set a value in the child control.\n\nIn the case of our component, we will take the value and assign it directly to the internal property:\n\nThe parent form can set a value in the child control using , but what about the other way around?\n\nIf the user interacts with the form control and increments or decrements the counter value, then the new value needs to be communicated back to the parent form.\n\nThe child control can notify the parent form that a new value is available via the use of a callback function.\n\nThe first step for this to work, is for the parent form to register the callback function with the child control, bt using the method:\n\nAs we can see, when this method is called, we are going to receive our callback function, which we then save for later in a member variable.\n\nThe member variable is declared as a function, and initialized with an empty function, meaning a function with an empty body.\n\nThis way, if our program by some reason calls the function before the\n\n call was made, we won't run into any errors.\n\nWhen the value of the counter is changed by either clicking on the increment or decrement buttons, then we need to notify the parent form that a new value is available.\n\nWe are going to do so by calling the callback function and reporting the new value:\n\nBesides reporting new values back to the parent form, we also need to inform the parent form when the child control has been considered to be touched by the user.\n\nWhen the form is initialized, every form control (and the form group as well) is considered to be in status untouched, and the CSS class is applied to the form group and also to each of its individual child controls.\n\nBut when a child control gets touched by the user, meaning the user has tried to interact with it at least once, then the whole form is considered touched as well, meaning that the CSS class gets applied to the form.\n\nThese touched/untouched CSS classes are important for styling error messages in a form, so our custom form control needs to support this as well.\n\nLike before, we need to have a callback registered, so that the child control can report its touched status back to the parent form:\n\nWe now need to call this callback when the control is considered touched, and this will happen whenever the user clicks any of the increment or decrement buttons at least once:\n\nAs we can see, when one of the two buttons gets clicked for the first time, we are going to call the callback once, and the form control will now be considered as touched by the parent form.\n\nThe custom form control will have the CSS class applied to it as expected:\n\nIts also possible for the parent form to enable or disable any of its child controls, by calling the method. We can keep the disabled status in the member variable , and use it in order to turn on and off the increment/decrement functionality:\n\nFinally, the last piece of the puzzle to implement the interface correctly, is to register the custom form control as a known value accessor in the dependency injection system:\n\nWithout this configuration in place, our custom form control will not work correctly.\n\nSo what does this configuration do? We are adding the component to the list of known value accessors, that are all registered with the unique dependency injection key (also known as an injection token).\n\nNotice the flag set to true, this means that this dependency provides a list of values, and not only one value. This is normal because there are many value accessors registered with Angular Forms besides our own.\n\nFor example, all the built-in value accessors for standard text inputs, checkboxes, etc. are also registered under .\n\nThis way, whenever the Angular forms module needs the full list of all the value accessors available, all it has to do is to inject .\n\nWith this, our component is now capable of setting the value of a property in a form.\n\nMore than that, the component is now capable of participating in the form validation process and is already fully compatible with for example the built-in and validators.\n\nBut what if the component needs to have its own built-in validation rules, that are always active for every instance of the component, independently of the form configuration?\n\nIn the case of our custom form control, we would like for it to ensure that the quantity is positive. If it's not, then the form field should be marked as in error, and this should be true for all instances of the component, always.\n\nIn order to implement this logic, we are going to have our component implement the interface. This interface contains only two methods:\n• validate: This method is used to validate the current value of the form control. This method will be called whenever a new value is reported to the parent form. The method needs to return null if no errors are found, or an error object containing all the details needed to correctly display a meaningful error message to the user.\n• registerOnValidatorChange: This will register a callback that will allow us to trigger the validation of the custom control on demand. We don't need to do this when new values are emitted, as validation is already triggered in that case. We only need to call this method if some other input that also affects the behavior of has changed\n\nLet's now see how to implement this interface, and do a final demo of the working component.\n\nThe only method of that we really have to implement is the method:\n\nIn this implementation, we return if the value is valid, and an error object containing all the details about the error.\n\nIn the case of our component, we didn't need to implement\n\n , as implementing this method is optional.\n\nWe only need this method if for example, our component had configurable validation rules, that depended on some of the component inputs. If that would be the case, we could trigger a new validation on demand in case one of the validation inputs changes.\n\nIn our case, the implementation only depends on the current value of the control, so we didn't need to implement and grab that callback for further use.\n\nIn order for the Validator interface to work properly, we also need to register our custom component with the injection token:\n\nNotice that without registering this class properly in ,\n\n the method will never get called.\n\nAnd with the two interfaces and , we now have a fully functional custom form control, compatible with both reactive and template-driven forms, and capable of both setting the value of a form property and participating in the form validation process.\n\nHere is the final code:\n\nLet's now test this component at runtime, by adding it to a form with a couple of standard validators:\n\nAs we can see, we are making the field mandatory, and setting a maximum value of 100. The initial value of the control is 60, which is a valid value.\n\nBut what happens if we set the value to for example 110? The form will then become invalid, and the control will have an error associated with it.\n\nWe can see the error by checking the value of the property of\n\n :\n\nAs we can see, the built-in validator kicked in and marked our custom form control in error as expected.\n\nBut what if instead, we set the quantity value to for example a negative -10 value? Here is what the property of our control will now look like:\n\nAs we can see, now the method created a object, which was then set as part of the errors of the form control.\n\nWe now have a fully functional custom form control, compatible with template-driven forms, reactive forms, and all built-in validators.\n\nHow to implement nested form groups (an address nested form)\n\nA very common forms use case that can be implemented with what we have learned so far are nested form groups, that can be reused across multiple forms.\n\nA good example of this is an address form, with all the usual address fields:\n\nNow imagine that your application has many different forms where an address is required. We wouldn't want to repeat all the code needed for displaying and validating those fields across every form.\n\nInstead, what we would like to do is to create a reusable form section under the form of an Angular component, that we could then plug into multiple forms, sort of a nested reusable sub-form.\n\nHere is how we would like to use such an address form component:\n\nAs we can see, we would like to make our address form component fully compatible with Angular forms, meaning that it should support the ,\n\n and directives, and be able to participate in the validation of the parent form.\n\nIndeed, all we have to do for that is to implement just like we did before the\n\n and interfaces. So how will this work?\n\nFirst, we need to define the view of our nested address form component:\n\nAs we can see, our nested address form is also a from group itself, and it also uses Angular forms internally to collect the values of every address field and validate their values.\n\nThe object already contains all the information about the values and validity state of this subform. We can now use this information to quickly implement both the and interfaces:\n\nHere are some important notes about this implementation:\n• the form address component uses itself a form internally for doing all the form validation using a series of built-in validators\n• we are using the principle of delegation as much as possible here. For example, we are getting all the information that we need from the object\n• As an example of the delegation principle, we are implementing using , and we are implementing by using and\n• We are using the Observable to know when a new value is emitted by the the address form, and calling the callback to notify the parent form.\n• As we are manually subscribing to the Observable, we are also unsubscribing from it using , to avoid any memory leaks\n• we are implementing the method by checking if the embedded form controls have any errors and passing them to the object\n\nIf we try to fill in the values of the address form, we are going to see that they are reported back to the parent form, and show up under the property.\n\nThis is property of the parent form containing , after typing in an address:\n\nEvery form control has linked to it a control value accessor, which is responsible for the interaction between the form control and the parent form.\n\nAnd this includes all the standard HTML form controls like text inputs, checkboxes, etc., for which the forms module provides built-in control value accessors.\n\nFor a custom form control, we will have to build our own control value accessor by implementing the interface, and if we want the control to do custom value validation then we need to implement the interface.\n\nWe can also use the same technique to implement nested form groups (like an address sub-form), that can be reused across multiple forms.\n\nI hope that you have enjoyed this post, if you would like to learn a lot more about Angular Forms, we recommend checking the Angular Forms In Depth course, where validators, custom form controls, and many other advanced form topics are covered in detail.\n\nAlso, if you have some questions or comments please let me know in the comments below and I will get back to you.\n\nTo get notified of upcoming posts on Angular, I invite you to subscribe to our newsletter:\n\nAnd if you are just getting started learning Angular, have a look at the Angular for Beginners Course:"
    },
    {
        "link": "https://medium.com/ngconf/custom-form-inputs-with-controlvalueaccessor-4bd4eb6f8c22",
        "document": "There are times when the default inputs available to us in the browser don’t meet our needs or need to be included in a reusable Angular component. You may want to create a custom checkbox or radio button, or just want to use a card with a button as a form input. In any of these situations, you can use the Control Value Accessor to allow an Angular component to communicate with your form. In this article, we’ll look at an example of using control value accessor.\n\nI was recently working on a form where the user was going to need to select an option, and only one option, like you would normally use a radio button for. This is what it looked like:\n\nThe user will choose one of these items, and when they select it the form goes to another step. I needed their selection to be stored as a value in the form as well. I could have used an that patched the value of the form, but I wanted it to be more semantic and obvious about what was going on. To get the value to store in the form, I needed a custom form , where each of the above cards was the . I could wrap them in an Angular component and loop over a list of options that were available to the user.\n\nThis is where I remembered a talk from Jennifer Wadella at ng-conf 2019 that talked about using . There is a lot of content out there, and I encourage you to read more about it (and watch the video from Jennifer’s talk). This example will not go into all the details of what can do, but it will give you an example and get you started.\n\nThe first step in creating our custom input with control value accessor is to implement the interface. This requires us to implement three methods: , , and .\n\nThis sets the callback function that the forms API will call when the form value changes. You must provide a function that you will call when the user interacts with the input and the value should be changed. In this case, when the user interacts with our component and we want to update the changed value, we will call .\n\nThis is similar to the method, but runs when the input is touched by the user. To register the touch, we will call .\n\nThis method is used to write a new value to the element. In my case, I didn’t need to implement this method, but you may need to do something like this in your case:\n\nThis would write the value that is passed in to the method to the native input’s value in the DOM.\n\nThis is an optional method that you can implement, and it allows you to run a block of code when the forms API sets the input to or from disabled.\n\nSetting the Providers for the Component\n\nAfter implementing the required methods for the interface we need to set some providers for the component. The providers are set in an array in the component metadata:\n\nEssentially this turns our component into the custom input for the forms API to interact with.\n\nNow that we have our card (as shown above) and the is implemented, we need to make sure that the user can select the input by clicking on the “Choose this Option” button. This part is pretty simple, though. All we need to do is run a function when the click event occurs, something like this:\n\nNow when the user clicks on the button, the form’s value will update to the value of .\n\nNow that we have our custom input, we need to implement it in the parent component with the form. This is actually easy as well after doing the other work. If you’ve set up your , all you need to do is add the formControlName attribute to the component in the HTML file.\n\nAs long as your has an attribute called , then clicking on the card will set the option’s ID as the value in the form.\n\nYou can check out this StackBlitz for a working example of this custom input component using control value accessor.\n\nI have been working with reactive forms for a few years now, and only just implemented for the first time. You may not need to use this technique frequently, but in the case that you do need to implement it, don’t worry about the difficulty. In just a few steps (as outlined above) you can get it working.\n\nI’ve shown the example of using reactive forms, but the steps above should work the same if you’re using template driven forms. Instead of using formControlName on the tag, you’ll use ."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/angular-custom-form-control",
        "document": "When creating forms in Angular, sometimes you want to have an input that is not a standard text input, select, or checkbox. By implementing the interface and registering the component as a , you can integrate your custom form control seamlessly into template-driven or reactive forms just as if it were a native input!\n\nIn this article, you will transform a basic star rating input component into a .\n\nTo complete this tutorial, you will need:\n• Node.js installed locally, which you can do by following How to Install Node.js and Create a Local Development Environment.\n• Some familiarity with setting up an Angular project and using Angular components may be beneficial.\n\nThis tutorial was verified with Node v16.4.2, v7.18.1, v12.1.1.\n\nThis can be accomplished with :\n\nThis will add the new component to the app and produce a file:\n\nWe can get the of the component ( to ) and set the value of the component by calling the function or clicking the number of stars desired.\n\nYou can add the component to the application:\n\nAnd interact with it in a web browser.\n\nThis is great, but we can’t just add this input to a form and expect everything to work just yet. We need to make it a .\n\nIn order to make the behave as though it were a native input (and thus, a true custom form control), we need to tell Angular how to do a few things:\n• Write a value to the input -\n• Register a function to tell Angular when the value of the input changes -\n• Register a function to tell Angular when the input has been touched -\n\nThese four things make up the interface, the bridge between a form control and a native element or custom input component. Once our component implements that interface, we need to tell Angular about it by providing it as a so that it can be used.\n\nRevisit in your code editor and make the following changes:\n\nThis code will allow the input to be disabled, and when it is make it somewhat transparent.\n\nAnd interact with it in a web browser.\n\nYou can also disable the input controls:\n\nWe can now say that our is a custom form component! It will work just like any other native input (Angular provides the for those!) in template-driven or reactive forms.\n\nIn this article, you transformed a basic star rating input component into a .\n• Control state and validity become available with , such as and classes.\n\nIf you’d like to learn more about Angular, check out our Angular topic page for exercises and programming projects."
    },
    {
        "link": "https://sreyaj.dev/custom-form-controls-controlvalueaccessor-in-angular",
        "document": "How to create custom form controls in Angular using ControlValueAccessor? We can create custom form components and connect them to either template-driven forms or reactive forms.\n\nSo when I say custom form controls, I am talking about those elements that are not your typical controls like input fields, radio buttons, or checkboxes. For example, a star rating component or a knob. These are not available out of the box.\n\nWe can also make sections in a form as child components which can be then used as custom form controls. In this way, larger forms can be broken down into manageable pieces.\n\nFor all the default form controls like input field, radio button, checkbox, select dropdown, etc, custom control value accessors are already written and shipped with Angular. Eg: CheckboxControlValueAccessor\n\nWe will be talking more about it and how to use it to create really cool form.\n\nWhen we hear the term form, we would be thinking of few input text fields and maybe some checkboxes and stuff. But when it comes to really complex forms where we have a lot of custom buttons, lists, and selections, the whole form will become very complex. And managing such a complex form would be a problem.\n\nWhen there are a lot of custom form elements or when the form starts to get big, it's probably a good idea to break it into smaller sections. Placing everything in a single template would make it really messy.\n\nWe can break down the form into multiple components and then connect it with the main form.\n\nControlValueAccessor is something that comes with Angular. It acts as a bridge between DOM elements and the angular Form API.\n\nSo If you have a custom element that you would like to connect to your form, you have to make use of ControlValueAccessor to make the element compatible with Angular Forms API. Doing so will enable the element to be connected using (Template Driven Forms) or (Reactive Forms).\n\nLet's take a look at how do we create a custom form control.\n\nWhen I started with Angular, I was not aware that something like this existed. I remember when I wrote child components for forms and used and to receive and send form values to the parent form component. I used to listen to the changes in the child component and then emit the values to the parent.\n\nIn the parent, the values will be taken and used to patch the form. This was until I came across the magical ControlValueAccessor. No more inputs and outputs, everything just works.\n\nStep 1 is to implement the interface in the custom component. The interface would ask us to add few methods in our class.\n\nLet us see what each of the methods is doing. Once we are clear on how things are, we can dive into the implementation.\n• - this function is called by the Forms API to update the value of the element. When or value changes, this function gets called and the latest value is passed in as the argument to the function. We can use the latest value and make changes in the component. (ref)\n• - we get access to a function in the argument that can be saved to a local variable. Then this function can be called when there are any changes in the value of our custom form control. (ref)\n• - we get access to another function that can be used to update the state of the form to . So when the user interacts with our custom form element, we can call the saved function to let Angular know that the element has been interacted with. (ref)\n• - this function will be called by the forms API when the disabled state is changed. We can get the current state and update the state of the custom form control. (ref)\n\nOnce we implement these functions, the next step is to provide the token in the component's providers array like so:\n\nNote: Here I created a provider constant and then passed it into the . Also you can see the use of (ref) here. It is needed because we are referring to the class which is not defined before its reference.\n\nSo now that we know what each of these functions does, we can start implementing our custom form element.\n\nWe are going to take a look at the base form that we are gonna work with. We just have some basic input fields and 2 custom form elements.\n\nThis is how we need the data to be. Here the and the fields are going to be connected to a custom form control. We are using Reactive Forms in the example.\n\nHere is how our form will look like:\n\nand in the template\n\nNotice in the above template we are directly using on the and components. This will be only possible if those components are implementing the interface. This is how you make a component behave like a form control.\n\nWe are going to see how to implement a cool country selector component as a custom form control that can be directly connected to a form. In this example, I'll be using Reactive Forms.\n\nThe component is pretty straightforward, we will give the user to select one country from a given list. The behavior is similar to a radio button. The only difference here is that we are using our own custom component to implement this design.\n\nAs always, I start by creating a new module and component for our country selector form control.\n\nHere is how we implement the ControlValueAccessor for our country selector component.\n\nWe provide it in the providers array inside the decorator.\n\nIf the user has given an initial value to in the form, we will get the initial value in the method. We get the value and assign it to our local variable which manages the state.\n\nWhen the user clicks on a different country, we mark the field as and then assign the value to the variable. The main part is we also call the method and pass the newly selected country code. This will set the new value as the form control's value.\n\nBy using the argument from method we can implement the disabled state for our component. So If we trigger disable from the form using:\n\nDoing the above will trigger a call to method where the state is passed, which is then assigned to a local variable . Now we can use this local variable to add a class or disable the button.\n\nThat is all! We have successfully created a custom form control. Check the GitHub repo for full code.\n\nNow let's see how to implement the second custom form control in our form, which allows user to select their communication preferences.\n\nThis is also a very simple component that has a bunch of checkboxes. We could have added this in the same parent component where the form is initialized. But by creating a separate component, we are making it more maintainable.\n\nAgain it's the same thing we are doing, we have an variable that manages the local state of the component. When there is any value-change triggered by the form, we get the new value in the method, we update the local state with the changed value. When the user makes any change, we update the local state and call the method and pass the updated state which updates the form as well.\n\nFind the complete code for the component in the repo.\n\nAngular makes it really easy to implement custom form control using . By implementing few methods, we can directly hook our component to a or form with ease.\n\nWe can write all sorts of crazy form elements and use them without writing logic to handle communication between parent and child. Let the forms API do the magic for us.\n\nWe can also use this approach to break sections of the form into their own individual component. This way if the form is big/complex, we can break then down into smaller components that can be easily managed.\n\nDo add your thoughts in the comments section. Stay Safe ❤️"
    },
    {
        "link": "https://material.angular.io/guide/creating-a-custom-form-field-control",
        "document": ""
    },
    {
        "link": "https://blog.angular-university.io/angular-custom-form-controls",
        "document": "The Angular Forms and ReactiveForms modules come with a series of built-in directives that make it very simple to bind standard HTML elements like inputs, checkboxes, text areas, etc. to a form group.\n\nBesides these standard HTML elements, we might also want to use custom form controls, like dropdowns, selection boxes, toggle buttons, sliders, or many other types of commonly used custom form components.\n\nFor these custom controls, we would like to have the ability to configure them as form fields using the exact same directives ( , ,\n\n ) as we use for standard input boxes.\n\nIn this guide, we are going to learn exactly how to take an existing custom form control component and make it fully compatible with the Angular Forms API, so that the component can participate in the parent form validation and value tracking mechanisms.\n• if we are using template driven forms, we will be able to plug the custom component to the form simply by using\n• and in the case of reactive forms, we will be able to add the custom component to the form using (or )\n\nWe will be building in this guide a simple quantity selector component, that can be used to increment or decrement a value. The component will be part of a form and will be marked as in error in case that the counter does not match a valid range.\n\nThe new custom form control will be fully compatible with the built-in Angular Forms Validators , as well as any other built-in or custom validators.\n\nWe will also learn in this guide how to create reusable nested forms, which are form sections that be reused in many different forms.\n\nThe typical example of such type of nested forms is an address sub-form, and we are going to build one in this post.\n\nIn this post, we will cover the following topics:\n• What are form control value accessors?\n• How to implement nested form groups (an address nested form)\n\nThis post is part of our ongoing series on Angular Forms, you can find all the articles available here.\n\nSo without further ado, let's get started learning everything that we need to know for creating our own custom form controls and nested forms!\n\nIn order to know how to build a custom form control, we need to first understand how the built-in form controls work.\n\nThe built-in form controls target native HTML elements such as inputs, text areas, checkboxes, etc.\n\nHere is an example of a simple form with a couple of plain HTML form fields:\n\nAs we can see, we have here a couple of standard form controls, with the\n\n property applied to it. And this is how the HTML element gets binded to the form.\n\nWhenever the user interacts with the form inputs, the form value and validity state will be automatically re-calculated.\n\nSo how does this all work under the hood then?\n\nWhat are control value accessors?\n\nWhat happens is that, under the hood, the Angular forms module is applying to each native HTML element a built-in Angular directive, which will be responsible for tracking the value of the field, and communicate it back to the parent form.\n\nThis type of special directive is known as a control value accessor directive.\n\nTake for example the checkbox field of the form above. There is a built-in directive which is part of the reactive forms module that is designed to specifically track the value of a checkbox, and nothing more.\n\nHere is the simplified declaration of this directive:\n\nAs we can see by the selector, this value tracking directive specifically targets HTML inputs of type checkbox only, but only if the , or\n\n properties are applied to it.\n\nIf this directive only targets checkboxes, then what about all the other types of form controls, like text inputs or text areas?\n\nWell, each of those control types has their own value accessor directive, which is different than .\n\nAll of those directives are built-in into the Angular Forms module and cover only the standard HTML form controls.\n\nThis means that if we want to implement our own custom form control, we are going to have to implement a custom value accessor for it as well.\n\nThe custom form control that we will build\n\nLet's say that we want to build a custom form control that represents a numeric counter with increase and decrease buttons, for selecting an order quantity for example.\n\nEach time that the buttons are pressed, the counter should be incremented or decremented by a configurable amount.\n\nWe can configure this control to specify a maximum value allowed for the form field, and mark it as invalid if the range is not met.\n\nHere is what the numeric form control will look like:\n\nAnd here is the implementation code for this simple component, without any form functionality added yet:\n\nIn its current form, this component is not compatible with either template-driven or reactive forms.\n\nWe would like to be able to add this component to a form in a very similar way to how we add a standard HTML input to a form, by either adding the\n\n or directives to it:\n\nWe would also like for this component to be compatible with the built-in validators, and use them to make the field mandatory and set a maximum value:\n\nBut in the case of the current version of our control, if we would try to do so we would get an error:\n\nIn order to fix this error, and make the component compatible with Angular Forms, we need to give this form control a value accessor, just like the case of native HTML elements like text inputs, checkboxes, etc.\n\nIn order to do that, we are going to make the component implement the\n\n interface.\n\nLet's go over the methods of the ControlValueAccessor interface. Remember, they are not meant to be called directly by our code as these are framework callbacks.\n\nAll of these methods are meant to be called only by the Forms module at runtime, and they are meant to facilitate communication between our form control and the parent form.\n\nHere are the methods of this interface, and how they work:\n• writeValue: this method is called by the Forms module to write a value into a form control\n• registerOnChange: When a form value changes due to user input, we need to report the value back to the parent form. This is done by calling a callback, that was initially registered with the control using the registerOnChange method\n• registerOnTouched: When the user first interacts with the form control, the control is considered to have the status touched, which is useful for styling. In order to report to the parent form that the control was touched, we need to use a callback registered using the registerOnToched method\n• setDisabledState: form controls can be enabled and disabled using the Forms API. This state can be transmitted to the form control via the setDisabledState method\n\nAnd here is the component, with the interface already implemented:\n\nLet's now go through each of the methods one by one, and explain how they were implemented.\n\nThe method is called by the Angular forms module whenever the parent form wants to set a value in the child control.\n\nIn the case of our component, we will take the value and assign it directly to the internal property:\n\nThe parent form can set a value in the child control using , but what about the other way around?\n\nIf the user interacts with the form control and increments or decrements the counter value, then the new value needs to be communicated back to the parent form.\n\nThe child control can notify the parent form that a new value is available via the use of a callback function.\n\nThe first step for this to work, is for the parent form to register the callback function with the child control, bt using the method:\n\nAs we can see, when this method is called, we are going to receive our callback function, which we then save for later in a member variable.\n\nThe member variable is declared as a function, and initialized with an empty function, meaning a function with an empty body.\n\nThis way, if our program by some reason calls the function before the\n\n call was made, we won't run into any errors.\n\nWhen the value of the counter is changed by either clicking on the increment or decrement buttons, then we need to notify the parent form that a new value is available.\n\nWe are going to do so by calling the callback function and reporting the new value:\n\nBesides reporting new values back to the parent form, we also need to inform the parent form when the child control has been considered to be touched by the user.\n\nWhen the form is initialized, every form control (and the form group as well) is considered to be in status untouched, and the CSS class is applied to the form group and also to each of its individual child controls.\n\nBut when a child control gets touched by the user, meaning the user has tried to interact with it at least once, then the whole form is considered touched as well, meaning that the CSS class gets applied to the form.\n\nThese touched/untouched CSS classes are important for styling error messages in a form, so our custom form control needs to support this as well.\n\nLike before, we need to have a callback registered, so that the child control can report its touched status back to the parent form:\n\nWe now need to call this callback when the control is considered touched, and this will happen whenever the user clicks any of the increment or decrement buttons at least once:\n\nAs we can see, when one of the two buttons gets clicked for the first time, we are going to call the callback once, and the form control will now be considered as touched by the parent form.\n\nThe custom form control will have the CSS class applied to it as expected:\n\nIts also possible for the parent form to enable or disable any of its child controls, by calling the method. We can keep the disabled status in the member variable , and use it in order to turn on and off the increment/decrement functionality:\n\nFinally, the last piece of the puzzle to implement the interface correctly, is to register the custom form control as a known value accessor in the dependency injection system:\n\nWithout this configuration in place, our custom form control will not work correctly.\n\nSo what does this configuration do? We are adding the component to the list of known value accessors, that are all registered with the unique dependency injection key (also known as an injection token).\n\nNotice the flag set to true, this means that this dependency provides a list of values, and not only one value. This is normal because there are many value accessors registered with Angular Forms besides our own.\n\nFor example, all the built-in value accessors for standard text inputs, checkboxes, etc. are also registered under .\n\nThis way, whenever the Angular forms module needs the full list of all the value accessors available, all it has to do is to inject .\n\nWith this, our component is now capable of setting the value of a property in a form.\n\nMore than that, the component is now capable of participating in the form validation process and is already fully compatible with for example the built-in and validators.\n\nBut what if the component needs to have its own built-in validation rules, that are always active for every instance of the component, independently of the form configuration?\n\nIn the case of our custom form control, we would like for it to ensure that the quantity is positive. If it's not, then the form field should be marked as in error, and this should be true for all instances of the component, always.\n\nIn order to implement this logic, we are going to have our component implement the interface. This interface contains only two methods:\n• validate: This method is used to validate the current value of the form control. This method will be called whenever a new value is reported to the parent form. The method needs to return null if no errors are found, or an error object containing all the details needed to correctly display a meaningful error message to the user.\n• registerOnValidatorChange: This will register a callback that will allow us to trigger the validation of the custom control on demand. We don't need to do this when new values are emitted, as validation is already triggered in that case. We only need to call this method if some other input that also affects the behavior of has changed\n\nLet's now see how to implement this interface, and do a final demo of the working component.\n\nThe only method of that we really have to implement is the method:\n\nIn this implementation, we return if the value is valid, and an error object containing all the details about the error.\n\nIn the case of our component, we didn't need to implement\n\n , as implementing this method is optional.\n\nWe only need this method if for example, our component had configurable validation rules, that depended on some of the component inputs. If that would be the case, we could trigger a new validation on demand in case one of the validation inputs changes.\n\nIn our case, the implementation only depends on the current value of the control, so we didn't need to implement and grab that callback for further use.\n\nIn order for the Validator interface to work properly, we also need to register our custom component with the injection token:\n\nNotice that without registering this class properly in ,\n\n the method will never get called.\n\nAnd with the two interfaces and , we now have a fully functional custom form control, compatible with both reactive and template-driven forms, and capable of both setting the value of a form property and participating in the form validation process.\n\nHere is the final code:\n\nLet's now test this component at runtime, by adding it to a form with a couple of standard validators:\n\nAs we can see, we are making the field mandatory, and setting a maximum value of 100. The initial value of the control is 60, which is a valid value.\n\nBut what happens if we set the value to for example 110? The form will then become invalid, and the control will have an error associated with it.\n\nWe can see the error by checking the value of the property of\n\n :\n\nAs we can see, the built-in validator kicked in and marked our custom form control in error as expected.\n\nBut what if instead, we set the quantity value to for example a negative -10 value? Here is what the property of our control will now look like:\n\nAs we can see, now the method created a object, which was then set as part of the errors of the form control.\n\nWe now have a fully functional custom form control, compatible with template-driven forms, reactive forms, and all built-in validators.\n\nHow to implement nested form groups (an address nested form)\n\nA very common forms use case that can be implemented with what we have learned so far are nested form groups, that can be reused across multiple forms.\n\nA good example of this is an address form, with all the usual address fields:\n\nNow imagine that your application has many different forms where an address is required. We wouldn't want to repeat all the code needed for displaying and validating those fields across every form.\n\nInstead, what we would like to do is to create a reusable form section under the form of an Angular component, that we could then plug into multiple forms, sort of a nested reusable sub-form.\n\nHere is how we would like to use such an address form component:\n\nAs we can see, we would like to make our address form component fully compatible with Angular forms, meaning that it should support the ,\n\n and directives, and be able to participate in the validation of the parent form.\n\nIndeed, all we have to do for that is to implement just like we did before the\n\n and interfaces. So how will this work?\n\nFirst, we need to define the view of our nested address form component:\n\nAs we can see, our nested address form is also a from group itself, and it also uses Angular forms internally to collect the values of every address field and validate their values.\n\nThe object already contains all the information about the values and validity state of this subform. We can now use this information to quickly implement both the and interfaces:\n\nHere are some important notes about this implementation:\n• the form address component uses itself a form internally for doing all the form validation using a series of built-in validators\n• we are using the principle of delegation as much as possible here. For example, we are getting all the information that we need from the object\n• As an example of the delegation principle, we are implementing using , and we are implementing by using and\n• We are using the Observable to know when a new value is emitted by the the address form, and calling the callback to notify the parent form.\n• As we are manually subscribing to the Observable, we are also unsubscribing from it using , to avoid any memory leaks\n• we are implementing the method by checking if the embedded form controls have any errors and passing them to the object\n\nIf we try to fill in the values of the address form, we are going to see that they are reported back to the parent form, and show up under the property.\n\nThis is property of the parent form containing , after typing in an address:\n\nEvery form control has linked to it a control value accessor, which is responsible for the interaction between the form control and the parent form.\n\nAnd this includes all the standard HTML form controls like text inputs, checkboxes, etc., for which the forms module provides built-in control value accessors.\n\nFor a custom form control, we will have to build our own control value accessor by implementing the interface, and if we want the control to do custom value validation then we need to implement the interface.\n\nWe can also use the same technique to implement nested form groups (like an address sub-form), that can be reused across multiple forms.\n\nI hope that you have enjoyed this post, if you would like to learn a lot more about Angular Forms, we recommend checking the Angular Forms In Depth course, where validators, custom form controls, and many other advanced form topics are covered in detail.\n\nAlso, if you have some questions or comments please let me know in the comments below and I will get back to you.\n\nTo get notified of upcoming posts on Angular, I invite you to subscribe to our newsletter:\n\nAnd if you are just getting started learning Angular, have a look at the Angular for Beginners Course:"
    },
    {
        "link": "https://medium.com/@dmmishchenko/angular-controlvalueaccessor-5183004e0557",
        "document": "In a previous article, I discussed the potential pitfalls of working with Angular’s ControlValueAccessor aka (CVA). Today, I’ve decided to offer a comprehensive guide on how to implement ControlValueAccessor, along with an overview of its pros and cons.\n\nHow we can bind data in Angular\n\nWe can use ngModel directive to connect view and model together:\n\nWe can use forms:\n\nBut what if we need to do the same data bind logic with custom component?\n\nLet’s imagine that you need to build simple counter:\n\nTask looks pretty easy. So here is a code of this component:\n\nand then you can use it like this:\n\nThen you decide to add disabled state to your component:\n\nand usage will change too:\n\nThen for some reasons you need validation:\n\nand the usage now will be:\n\nMore and more standard features to implement\n\nTrust me, you don’t want to do these things every time from scratch\n\nOther way to do it — use ControlValueAccessor\n\nCVA — an interface that acts as a bridge between the Angular forms API and a native element in the DOM.\n\nThe CVA interface includes methods that you need to implement for the interaction between the form API and your custom control\n• writeValue — This method is called by the form API to update the value of your custom control.\n• registerOnChange — This method allows the form API to register a callback function that should be called when the value in your custom control changes.\n• registerOnTouched — This method allows the form API to register a callback function that should be called when your custom control has been touched.\n• setDisabledState() — This method is called by the form API when the disabled state of your custom control should change. This method is optional.\n\nand the usage will be:\n\nWhat are advantages of such approach?\n\nYou can also use your component with ngModel:\n• Can use without form for simple cases\n• Simple API, same as input control has\n\nValidators should be implemented as directive, example: tap here\n\nWe can implement internal validation within our component if there is a specific need to do so.\n\nLet’s take a look at this component:\n\nWe want to validate the selected ingredients if the vegan option is chosen. While this can be easily handled outside the component with a custom validator, it can also be done internally, as previously mentioned.\n\nWe need to add NG_VALIDATORS inside a component’s providers:\n\nand also implement one method inside your component:"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/angular-custom-form-control",
        "document": "When creating forms in Angular, sometimes you want to have an input that is not a standard text input, select, or checkbox. By implementing the interface and registering the component as a , you can integrate your custom form control seamlessly into template-driven or reactive forms just as if it were a native input!\n\nIn this article, you will transform a basic star rating input component into a .\n\nTo complete this tutorial, you will need:\n• Node.js installed locally, which you can do by following How to Install Node.js and Create a Local Development Environment.\n• Some familiarity with setting up an Angular project and using Angular components may be beneficial.\n\nThis tutorial was verified with Node v16.4.2, v7.18.1, v12.1.1.\n\nThis can be accomplished with :\n\nThis will add the new component to the app and produce a file:\n\nWe can get the of the component ( to ) and set the value of the component by calling the function or clicking the number of stars desired.\n\nYou can add the component to the application:\n\nAnd interact with it in a web browser.\n\nThis is great, but we can’t just add this input to a form and expect everything to work just yet. We need to make it a .\n\nIn order to make the behave as though it were a native input (and thus, a true custom form control), we need to tell Angular how to do a few things:\n• Write a value to the input -\n• Register a function to tell Angular when the value of the input changes -\n• Register a function to tell Angular when the input has been touched -\n\nThese four things make up the interface, the bridge between a form control and a native element or custom input component. Once our component implements that interface, we need to tell Angular about it by providing it as a so that it can be used.\n\nRevisit in your code editor and make the following changes:\n\nThis code will allow the input to be disabled, and when it is make it somewhat transparent.\n\nAnd interact with it in a web browser.\n\nYou can also disable the input controls:\n\nWe can now say that our is a custom form component! It will work just like any other native input (Angular provides the for those!) in template-driven or reactive forms.\n\nIn this article, you transformed a basic star rating input component into a .\n• Control state and validity become available with , such as and classes.\n\nIf you’d like to learn more about Angular, check out our Angular topic page for exercises and programming projects."
    },
    {
        "link": "https://hackernoon.com/mastering-angular-control-value-accessor-a-guide-for-angular-developer",
        "document": "Angular, the popular front-end framework developed by Google, offers a plethora of tools and techniques to build dynamic and interactive web applications. One such feature that often goes underutilized is the Control Value Accessor (CVA).\n\nIn this comprehensive guide, we will delve deep into mastering Angular Control Value Accessor and explore how it can empower Angular developers to build custom form controls and enhance the user experience.\n\nWhat Is a Control Value Accessor?\n\nControl Value Accessor, often abbreviated as CVA, is an Angular feature that allows developers to create custom form controls. These custom controls can seamlessly integrate with Angular's reactive forms, providing a unified and consistent way to manage form input elements.\n\nBefore we dive into the intricacies of Control Value Accessor, it's essential to adopt a structured approach to our learning. The MECE (Mutually Exclusive, Collectively Exhaustive) principle can help us organize our knowledge and ensure that we cover all aspects of this topic comprehensively.\n• Understanding Control Value Accessor: We'll start by gaining a clear understanding of what Control Value Accessor is and why it's essential in Angular development.\n• Implementing a Basic Control Value Accessor: We'll explore the fundamental steps involved in creating a simple custom form control using CVA.\n• Advanced Customization: Once we grasp the basics, we'll delve into advanced customization options and techniques, such as integrating with third-party libraries and handling complex user interactions.\n• Use Cases and Scenarios: We'll examine various real-world scenarios where the Control Value Accessor can be a game-changer, from creating custom input masks to building complex data pickers.\n• Troubleshooting and Debugging: No development process is without its challenges. We'll discuss common issues that developers might encounter while working with CVA and how to troubleshoot them effectively.\n• Best Practices: To master Control Value Accessor, it's crucial to follow best practices. We'll outline a set of guidelines that will help developers make the most of this feature.\n\nControl Value Accessor is a powerful Angular mechanism that allows you to bridge the gap between Angular forms and custom form controls. It provides a standardized way to:\n• Write values into a DOM element: This means that you can control what gets displayed in your custom form control.\n• Listen for changes on a DOM element: You can also react to user interactions and update the form's model accordingly.\n\nIn essence, the Control Value Accessor acts as a mediator between the Angular form model and your custom form control. This ensures that your custom controls seamlessly integrate into Angular's form infrastructure, making them indistinguishable from native form controls.\n\nNow that we have a foundational understanding of Control Value Accessor, let's roll up our sleeves and implement a basic custom form control.\n\nFirst, we need to create a TypeScript class that represents our custom form control. This class should implement the interface, which enforces the necessary methods and properties.\n\nThe interface mandates the implementation of four methods:\n• : This method is called when the form model needs to update the view. Here, you can set the value of your custom control element.\n• : This method allows you to register a callback function that should be executed when the custom control's value changes.\n• : Similar to , this method lets you register a function to be called when the control is touched (e.g., clicked or focused).\n• : This method enables you to disable or enable your custom control programmatically.\n\nStep 3: Integrating the Custom Control in the Template\n\nWith the Control Value Accessor methods in place, you can now integrate your custom control in your component's template. For example, if you're creating a custom input, your template might look like this:\n\nFinally, you can use your custom control in a form just like any other form control:\n\nWhile the basic implementation of Control Value Accessor serves most needs, there are situations where you need advanced customization. Let's explore some advanced techniques and use cases.\n\nSometimes, you might want to incorporate third-party libraries like date pickers or rich text editors as custom form controls. Control Value Accessor can be a bridge between these libraries and Angular forms, ensuring seamless two-way data binding.\n\nImagine creating a custom control for a color picker that allows users to select multiple colors. With Control Value Accessor, you can handle complex interactions, such as adding and removing colors from the control's value array, with ease.\n\nNow that we've covered the basics and advanced customization, let's explore some practical use cases and scenarios where the Control Value Accessor shines.\n\nA common requirement in web forms is input masks, where users are guided to enter data in a specific format (e.g., phone numbers or credit card numbers). Control Value Accessor makes it straightforward to build custom input masks that enhance user experience and data accuracy.\n\nDate pickers with various date formats, date ranges, and selectable options can be challenging to implement. Control Value Accessor allows you to encapsulate this complexity into a reusable and easily customizable form control.\n\nAs with any technology, working with Control Value Accessor may lead to issues and bugs. Here are some common challenges developers might encounter and how to tackle them:\n\nIf you find that your custom control's value is not updating as expected, ensure that you've correctly implemented the method to reflect changes in the DOM element.\n\nIf your registered callbacks ( and ) are not triggering, double-check their implementations and ensure you've properly registered them in your custom control.\n\nAngular's form handling can sometimes clash with custom controls. Ensure that your custom control integrates seamlessly with Angular forms by following best practices.\n\nTo master Control Value Accessor, follow these best practices:\n• Keep It Simple: Start with basic implementations, and progressively add complexity as needed. Overcomplicating your custom controls can lead to maintenance challenges.\n• Documentation: Thoroughly document your custom controls, including their inputs, outputs, and usage examples. This will make it easier for other developers (or even your future self) to work with them.\n• Testing: Write unit tests for your custom controls to ensure they behave as expected in various scenarios.\n• Accessibility: Ensure that your custom controls are accessible to all users. Follow accessibility guidelines and test with screen readers and keyboard navigation.\n• Reusability: Aim for high reusability. Custom controls that are versatile and easily configurable are more valuable.\n\nMastering Angular Control Value Accessor opens up a world of possibilities for Angular developers. It empowers you to create custom form controls that seamlessly integrate with Angular's reactive forms, improving the user experience and code maintainability.\n\nBy following best practices and exploring advanced techniques, you can become a Control Value Accessor expert and take your Angular development skills to the next level.\n\nIn this guide, we've covered the fundamentals, implementation steps, advanced customization, real-world use cases, troubleshooting tips, and best practices for Control Value Accessor. Armed with this knowledge, you're well-equipped to leverage this powerful feature in your Angular projects. Happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/44731894/get-access-to-formcontrol-from-the-custom-form-component-in-angular",
        "document": "This solution was born from the discussion in the Angular repository. Please, make sure to read it or even better to participate if you are interested in this problem.\n\nI've studied the code of directive and it's inspired me to write the following solution:\n\nI'm injecting the parent to the component and then getting the specific from it using control name obtained through binding.\n\nHowever, be advised, that this solution is tailored specifically for the use case where directive is used on host element. It won't work in other cases. For this you will need to add some additional logic. If you think, that this should be addressed by Angular, make sure to visit the discussion."
    },
    {
        "link": "https://dev.to/krishhnaa/understanding-angular-controlvalueaccessor-with-an-example-33gb",
        "document": "In my previous article, I explained the ControlValueAccessor Interface now lets deep dive with an example.\n\nLet’s say you have a custom input component that is meant to accept phone numbers in a specific format, such as . You want to create a custom form control that will enforce this format and allow for easy data binding to the component.\n\nTo achieve this, you can create a ControlValueAccessor for the custom input component. The ControlValueAccessor interface defines four methods that you need to implement: , , , and .\n\nHere’s an example implementation of the interface for our custom phone number input component:\n\n\n\nIn the above code, we first import and from the @angular/forms module. We then implement the ControlValueAccessor interface in our PhoneNumberInputComponent class.\n\nThe method is called by the Angular forms API when the value of the form control is updated. We simply set the phoneNumber property to the value passed in.\n\nThe and methods are used to register callback functions that Angular calls when the value or touched state of the control changes. We store these callback functions in private class properties and .\n\nThe method is optional and can be implemented if you want to disable the input control.\n\nThe method is called whenever the phone number input value changes. We enforce the phone number format by replacing all non-numeric characters and formatting the string with parentheses and hyphens. We then call the onChange() method with the formatted phone number to notify the form control that the value has changed.\n\nThe method is called whenever the input control loses focus. We call the method to notify the form control that the input has been touched.\n\nBy implementing the interface, our custom phone number input component can be easily used in a reactive form. In the above code, we first import and from the module. We then implement the ControlValueAccessor interface in our class.\n\nThe method is called by the Angular forms API when the value of the form control is updated. We simply set the phoneNumber property to the value passed in.\n\nThe and methods are used to register callback functions that Angular calls when the value or touched state of the control changes. We store these callback functions in private class properties onChange and onTouched.\n\nThe method is optional and can be implemented if you want to disable the input control.\n\nThe method is called whenever the phone number input value changes. We enforce the phone number format by replacing all non-numeric characters and formatting the string with parentheses and hyphens. We then call the onChange() method with the formatted phone number to notify the form control that the value has changed.\n\nThe method is called whenever the input control loses focus. We call the onTouched() method to notify the form control that the input has been touched.\n\nBy implementing the interface, our custom phone number input component can be easily used in a reactive form.\n\nAnd in the template, you will create a form with where you will specify the component and use the like the below example.\n\n\n\nIn the above code, we first create a in our component's class and assign it to the formGroup attribute of the element.\n\nWe then create a label for the phone number input and use the directive to bind the phone number input to the \"phone\" form control.\n\nFinally, we use the custom input component and pass it the \"phone\" form control.\n\nNow, whenever the phone number input value changes, the method in our will be called, and the value will be propagated to the \"phone\" form control through the callback.\n\nSimilarly, whenever the input loses focus, the method will be called, and the onTouched() callback will be called to mark the control as touched.\n\nNote that you also need to import the in your module in order to use reactive forms in your application"
    },
    {
        "link": "https://hackernoon.com/mastering-angular-control-value-accessor-a-guide-for-angular-developer",
        "document": "Angular, the popular front-end framework developed by Google, offers a plethora of tools and techniques to build dynamic and interactive web applications. One such feature that often goes underutilized is the Control Value Accessor (CVA).\n\nIn this comprehensive guide, we will delve deep into mastering Angular Control Value Accessor and explore how it can empower Angular developers to build custom form controls and enhance the user experience.\n\nWhat Is a Control Value Accessor?\n\nControl Value Accessor, often abbreviated as CVA, is an Angular feature that allows developers to create custom form controls. These custom controls can seamlessly integrate with Angular's reactive forms, providing a unified and consistent way to manage form input elements.\n\nBefore we dive into the intricacies of Control Value Accessor, it's essential to adopt a structured approach to our learning. The MECE (Mutually Exclusive, Collectively Exhaustive) principle can help us organize our knowledge and ensure that we cover all aspects of this topic comprehensively.\n• Understanding Control Value Accessor: We'll start by gaining a clear understanding of what Control Value Accessor is and why it's essential in Angular development.\n• Implementing a Basic Control Value Accessor: We'll explore the fundamental steps involved in creating a simple custom form control using CVA.\n• Advanced Customization: Once we grasp the basics, we'll delve into advanced customization options and techniques, such as integrating with third-party libraries and handling complex user interactions.\n• Use Cases and Scenarios: We'll examine various real-world scenarios where the Control Value Accessor can be a game-changer, from creating custom input masks to building complex data pickers.\n• Troubleshooting and Debugging: No development process is without its challenges. We'll discuss common issues that developers might encounter while working with CVA and how to troubleshoot them effectively.\n• Best Practices: To master Control Value Accessor, it's crucial to follow best practices. We'll outline a set of guidelines that will help developers make the most of this feature.\n\nControl Value Accessor is a powerful Angular mechanism that allows you to bridge the gap between Angular forms and custom form controls. It provides a standardized way to:\n• Write values into a DOM element: This means that you can control what gets displayed in your custom form control.\n• Listen for changes on a DOM element: You can also react to user interactions and update the form's model accordingly.\n\nIn essence, the Control Value Accessor acts as a mediator between the Angular form model and your custom form control. This ensures that your custom controls seamlessly integrate into Angular's form infrastructure, making them indistinguishable from native form controls.\n\nNow that we have a foundational understanding of Control Value Accessor, let's roll up our sleeves and implement a basic custom form control.\n\nFirst, we need to create a TypeScript class that represents our custom form control. This class should implement the interface, which enforces the necessary methods and properties.\n\nThe interface mandates the implementation of four methods:\n• : This method is called when the form model needs to update the view. Here, you can set the value of your custom control element.\n• : This method allows you to register a callback function that should be executed when the custom control's value changes.\n• : Similar to , this method lets you register a function to be called when the control is touched (e.g., clicked or focused).\n• : This method enables you to disable or enable your custom control programmatically.\n\nStep 3: Integrating the Custom Control in the Template\n\nWith the Control Value Accessor methods in place, you can now integrate your custom control in your component's template. For example, if you're creating a custom input, your template might look like this:\n\nFinally, you can use your custom control in a form just like any other form control:\n\nWhile the basic implementation of Control Value Accessor serves most needs, there are situations where you need advanced customization. Let's explore some advanced techniques and use cases.\n\nSometimes, you might want to incorporate third-party libraries like date pickers or rich text editors as custom form controls. Control Value Accessor can be a bridge between these libraries and Angular forms, ensuring seamless two-way data binding.\n\nImagine creating a custom control for a color picker that allows users to select multiple colors. With Control Value Accessor, you can handle complex interactions, such as adding and removing colors from the control's value array, with ease.\n\nNow that we've covered the basics and advanced customization, let's explore some practical use cases and scenarios where the Control Value Accessor shines.\n\nA common requirement in web forms is input masks, where users are guided to enter data in a specific format (e.g., phone numbers or credit card numbers). Control Value Accessor makes it straightforward to build custom input masks that enhance user experience and data accuracy.\n\nDate pickers with various date formats, date ranges, and selectable options can be challenging to implement. Control Value Accessor allows you to encapsulate this complexity into a reusable and easily customizable form control.\n\nAs with any technology, working with Control Value Accessor may lead to issues and bugs. Here are some common challenges developers might encounter and how to tackle them:\n\nIf you find that your custom control's value is not updating as expected, ensure that you've correctly implemented the method to reflect changes in the DOM element.\n\nIf your registered callbacks ( and ) are not triggering, double-check their implementations and ensure you've properly registered them in your custom control.\n\nAngular's form handling can sometimes clash with custom controls. Ensure that your custom control integrates seamlessly with Angular forms by following best practices.\n\nTo master Control Value Accessor, follow these best practices:\n• Keep It Simple: Start with basic implementations, and progressively add complexity as needed. Overcomplicating your custom controls can lead to maintenance challenges.\n• Documentation: Thoroughly document your custom controls, including their inputs, outputs, and usage examples. This will make it easier for other developers (or even your future self) to work with them.\n• Testing: Write unit tests for your custom controls to ensure they behave as expected in various scenarios.\n• Accessibility: Ensure that your custom controls are accessible to all users. Follow accessibility guidelines and test with screen readers and keyboard navigation.\n• Reusability: Aim for high reusability. Custom controls that are versatile and easily configurable are more valuable.\n\nMastering Angular Control Value Accessor opens up a world of possibilities for Angular developers. It empowers you to create custom form controls that seamlessly integrate with Angular's reactive forms, improving the user experience and code maintainability.\n\nBy following best practices and exploring advanced techniques, you can become a Control Value Accessor expert and take your Angular development skills to the next level.\n\nIn this guide, we've covered the fundamentals, implementation steps, advanced customization, real-world use cases, troubleshooting tips, and best practices for Control Value Accessor. Armed with this knowledge, you're well-equipped to leverage this powerful feature in your Angular projects. Happy coding!"
    },
    {
        "link": "https://medium.com/@majdasab/implementing-control-value-accessor-in-angular-1b89f2f84ebf",
        "document": "Control Value Accessor interface gives us the power to leverage the Angular forms API, and create a connection between it and the DOM element. The major benefits we gain from doing that, is that we get all the default validations you’d get with any element, in order to track the validity, and it’s value.\n\nThe example we’re working with today will teach you how to create a custom input element based component that leverages the forms API using the template driven approach.\n\nFor a quick and an easy tutorial, let’s navigate to https://stackblitz.com and create a new Angular project, later on you just have to copy the changes to your local project.\n\nHere’s a screenshot of our file structure for reference:\n\nStart by creating a new component, let’s call it custom-input.component.ts, by default the component will be called CustomInputComponent.\n\nTo test if everything is working fine, navigate to custom-input.component.ts, and within the ‘@Component’ annotation change the ‘template’ property value to an input, so the end result for now should look like this:\n\nNotice that the file is placed inside ‘custom-input’ folder.\n\nEnsure the the component is imported, and that the imported component name is added to the ‘declaration’ array, similar to this:\n\nGo ahead and add <app-custom-input></app-custom-input> to your app.component.html and you should see the input element:\n\nOpen custom-input.component.ts, and let’s start with the imports:\n\nA. We need to import 1. ‘ControlValueAccessor’ and 2. ‘NG_VALUE_ACCESSOR’ from the forms ngModules, and add ‘forwardRef’ to the list named imports from the core ngModule:\n\nB. Within the ‘@Component’ annotation, add the following provider configuration, so that our component gets access to the VALUE_ACCESSOR, in addition update the ‘template’ with the code below to bind a value to the ngModel and output a local value (Don’t worry about any errors for now):\n\nNow it’s time to implement the ControlValueAccessor interface.\n\nYou’re going to need to implement the following methods and variables:\n• onChange → the callback function to register on UI change\n• onTouch → the callback function to register on element touch\n• set value(val: any) → sets the value used by the ngModel of the element\n• writeValue(value: any) → This will will write the value to the view if the the value changes occur on the model programmatically\n• registerOnChange(fn: any) → When the value in the UI is changed, this method will invoke a callback function\n• registerOnTouch(fn: any) → When the element is touched, this method will get called\n\nWe are done with the implementation. Time to test the validations and the value access!\n\nLet’s first test if we can bind an ngModel value to the custom component, and track its value.\n\nNavigate to app.component.html and replace what we have before with the following:\n\nMake sure you bind ngModel on the custom element to a variable, and provide a name for the component in the name property.\n\nThe ‘external: {{external}}’ allows us to view the value which the element holds. Ensure that this variable ‘external’ is declared in app.component.ts\n\nIf everything goes well without any errors, you should be able to enter values in the input element on the screen and see both values get updated both local and external:\n\nTo access the validations provided to the element by default, simply bind the ngModel to a template reference as follows, and give the reference any name you wish:\n\nNow to access these validation, simply output the JS-Object and stringify it using the json pipeline operator\n\nYou can find a working example here"
    },
    {
        "link": "https://angular.love/never-again-be-confused-when-implementing-controlvalueaccessor-in-angular-forms",
        "document": "If you’re working on a complex project inevitably you will face the situation when you have to create a custom form control. The essential component of this task will be implementing . There are some articles on the web that explain how to implement it but none provides an insight into what role this component plays in the Angular forms architecture. If you want to know not only how to implement it but also why this article is for you.\n\nHere I’ll first explain why we need and how it’s used inside Angular. Then I’ll demonstrate how to wrap a 3rd party widget into an Angular component and setup communication with a parent component using the standard input/output mechanism. And finally I’ll show how to implement that introduces a new communication mechanism specifically for Angular forms.\n\nIf you’ve worked with forms in Angular before you are probably familiar with FormControl. The Angular docs describe it as an entity that tracks the value and validation status of an individual form control. It’s important to understand that when you work with forms, a is always created regardless of whether you use template driven or reactive forms. With the reactive approach, you create a control yourself explicitly and use the or the directive to bind it to a native control. If you use template driven approach, the is created implicitly by the NgModel directive:\n\nA created implicitly or explicitly has to interact with a native form control like input or textarea. And instead of a native form control it’s also possible to have a custom form control created as an Angular component. A custom form control usually wraps a control that is written using pure JavaScript like jQueryUI’s slider. Throughout this article I’ll be using “native form control” phrase to distinguish between the Angular specific and a form control you use in HTML. But you should understand that instead of a native form control like , any custom form control can interact with a .\n\nThe number of native form controls is limited, but the variety of custom form controls can be potentially infinite. So, Angular needs a generic mechanism to stand between Angular’s and a native/custom form control. This is where the ControlValueAccessor object comes into play. This is the object that stands between the Angular and a native form control and synchronizes values between the two. Here is what the docs say about it:\n\nAny component or directive can be turned into by implementing the interface and registering itself as an provider. We will see in a minute how this can be done. Among others the interface defines two important methods — and :\n\nThe method is used by to set the value to the native form control. The method is used by to register a callback that is expected to be triggered every time the native form control is updated. It is your responsibility to pass the updated value to this callback so that the value of respective Angular form control is updated. The method is used to indicate that a user interacted with a control.\n\nHere is the diagram that demonstrates an interaction:\n\nAgain, it’s important to understand that always interacts with a form control created explicitly (reactive forms) or implicitly (template driven).\n\nAngular implements default value accessors for all standard native form elements:\n\nAs you can see the is used when Angular encounters or in a component template:\n\nAll form directives, including the directive used above, call the setUpControl function to setup interaction between a and a . Here is the code snippet demonstrating that for the directive:\n\nAnd here is the gist of the function that shows how the native and Angular’s form controls are synchronized:\n\nOnce we understand the mechanics, we can continue implementing our own accessor for a custom form control.\n\nSince Angular provides control value accessors for all default native controls a new value accessor is most often implemented to wrap 3rd party plugins/widgets. I mentioned a slider widget from jQueryUI library earlier and this is the plugin we will use for our custom form control.\n\nLet’s start with the most basic implementation which just wraps the widget and shows it on the screen. To do that we implement a new and use a DOM element from its template to render the slider:\n\nHere we create a slider widget on the native DOM element using standard jQuery approach. Then we save the reference to the widget into the property.\n\nOnce we have our wrapper component ready we can use it in the parent component like this:\n\nTo run the application we need to include the jQuery related dependencies. For simplicity we will add them as global dependencies into :\n\nHere is the application that demonstrates the setup.\n\nWith the above implementation our custom slider control doesn’t have any way to interact with the parent component. So let’s use standard input/output mechanisms as communication channels:\n\nOnce the slider widget is created we subscribe to its value changes using event. Once the event is triggered we notify the parent using output event emitter. And we also track changes to the input binding using lifecycle hook and once the value is updated we set it into the slider widget.\n\nAnd here is how we use the component now in parent component:\n\nHere is the application that demonstrates the setup.\n\nHowever, if we want to use our slider as part of a form and communicate with it using template driven or reactive form directives we need to implement a value accessor. And we don’t need standard input/output communication mechanism so we will remove it when implementing the value accessor.\n\nImplementing a custom value accessor is not difficult. It requires 2 simple steps:\n\nprovider specifies a class that implements interface and is used by Angular to setup synchronization with . It’s usually the class of the component or directive that registers the provider. All form directives inject value accessors using the token and then select a suitable accessor. If there is an accessor which is not built-in or it is selected. Otherwise Angular picks the default accessor if it’s provided. And there can be no more than one custom accessor defined for an element.\n\nSo let’s first define the provider:\n\nWe specified the class directly in component decorator descriptor. However, all default accessors implemented by Angular define a provide outside the class metadata like this:\n\nand so they need to use . To learn more about read What is `forwardRef` in Angular and why we need it. When implementing a custom I recommend specifying a class directly in the decorator descriptor.\n\nWe are not interested in learning whether user interacted with a control or not so we leave empty. Inside we simply save the reference to the callback function passed by . We will trigger it every time the change in the slider value occurs. And inside the method we set the value to the slider widget.\n\nSo now if we depict the above functionality to the interaction picture it looks something like this:\n\nIf you compare two implementations as a simple wrapper and as a you should see the interaction with a parent component is different, while the interaction with the underlining slider widget is the same. You may also notice that actually simplifies the interaction with the parent component. We use where we used in the simple wrapper and call where we emitted value before with .\n\nThe custom slider control implemented as can now be used like this:\n\nYou can find the final implementation here.\n\nThat's basically it. You can find the final project on github here."
    },
    {
        "link": "https://blog.angular-university.io/angular-custom-form-controls",
        "document": "The Angular Forms and ReactiveForms modules come with a series of built-in directives that make it very simple to bind standard HTML elements like inputs, checkboxes, text areas, etc. to a form group.\n\nBesides these standard HTML elements, we might also want to use custom form controls, like dropdowns, selection boxes, toggle buttons, sliders, or many other types of commonly used custom form components.\n\nFor these custom controls, we would like to have the ability to configure them as form fields using the exact same directives ( , ,\n\n ) as we use for standard input boxes.\n\nIn this guide, we are going to learn exactly how to take an existing custom form control component and make it fully compatible with the Angular Forms API, so that the component can participate in the parent form validation and value tracking mechanisms.\n• if we are using template driven forms, we will be able to plug the custom component to the form simply by using\n• and in the case of reactive forms, we will be able to add the custom component to the form using (or )\n\nWe will be building in this guide a simple quantity selector component, that can be used to increment or decrement a value. The component will be part of a form and will be marked as in error in case that the counter does not match a valid range.\n\nThe new custom form control will be fully compatible with the built-in Angular Forms Validators , as well as any other built-in or custom validators.\n\nWe will also learn in this guide how to create reusable nested forms, which are form sections that be reused in many different forms.\n\nThe typical example of such type of nested forms is an address sub-form, and we are going to build one in this post.\n\nIn this post, we will cover the following topics:\n• What are form control value accessors?\n• How to implement nested form groups (an address nested form)\n\nThis post is part of our ongoing series on Angular Forms, you can find all the articles available here.\n\nSo without further ado, let's get started learning everything that we need to know for creating our own custom form controls and nested forms!\n\nIn order to know how to build a custom form control, we need to first understand how the built-in form controls work.\n\nThe built-in form controls target native HTML elements such as inputs, text areas, checkboxes, etc.\n\nHere is an example of a simple form with a couple of plain HTML form fields:\n\nAs we can see, we have here a couple of standard form controls, with the\n\n property applied to it. And this is how the HTML element gets binded to the form.\n\nWhenever the user interacts with the form inputs, the form value and validity state will be automatically re-calculated.\n\nSo how does this all work under the hood then?\n\nWhat are control value accessors?\n\nWhat happens is that, under the hood, the Angular forms module is applying to each native HTML element a built-in Angular directive, which will be responsible for tracking the value of the field, and communicate it back to the parent form.\n\nThis type of special directive is known as a control value accessor directive.\n\nTake for example the checkbox field of the form above. There is a built-in directive which is part of the reactive forms module that is designed to specifically track the value of a checkbox, and nothing more.\n\nHere is the simplified declaration of this directive:\n\nAs we can see by the selector, this value tracking directive specifically targets HTML inputs of type checkbox only, but only if the , or\n\n properties are applied to it.\n\nIf this directive only targets checkboxes, then what about all the other types of form controls, like text inputs or text areas?\n\nWell, each of those control types has their own value accessor directive, which is different than .\n\nAll of those directives are built-in into the Angular Forms module and cover only the standard HTML form controls.\n\nThis means that if we want to implement our own custom form control, we are going to have to implement a custom value accessor for it as well.\n\nThe custom form control that we will build\n\nLet's say that we want to build a custom form control that represents a numeric counter with increase and decrease buttons, for selecting an order quantity for example.\n\nEach time that the buttons are pressed, the counter should be incremented or decremented by a configurable amount.\n\nWe can configure this control to specify a maximum value allowed for the form field, and mark it as invalid if the range is not met.\n\nHere is what the numeric form control will look like:\n\nAnd here is the implementation code for this simple component, without any form functionality added yet:\n\nIn its current form, this component is not compatible with either template-driven or reactive forms.\n\nWe would like to be able to add this component to a form in a very similar way to how we add a standard HTML input to a form, by either adding the\n\n or directives to it:\n\nWe would also like for this component to be compatible with the built-in validators, and use them to make the field mandatory and set a maximum value:\n\nBut in the case of the current version of our control, if we would try to do so we would get an error:\n\nIn order to fix this error, and make the component compatible with Angular Forms, we need to give this form control a value accessor, just like the case of native HTML elements like text inputs, checkboxes, etc.\n\nIn order to do that, we are going to make the component implement the\n\n interface.\n\nLet's go over the methods of the ControlValueAccessor interface. Remember, they are not meant to be called directly by our code as these are framework callbacks.\n\nAll of these methods are meant to be called only by the Forms module at runtime, and they are meant to facilitate communication between our form control and the parent form.\n\nHere are the methods of this interface, and how they work:\n• writeValue: this method is called by the Forms module to write a value into a form control\n• registerOnChange: When a form value changes due to user input, we need to report the value back to the parent form. This is done by calling a callback, that was initially registered with the control using the registerOnChange method\n• registerOnTouched: When the user first interacts with the form control, the control is considered to have the status touched, which is useful for styling. In order to report to the parent form that the control was touched, we need to use a callback registered using the registerOnToched method\n• setDisabledState: form controls can be enabled and disabled using the Forms API. This state can be transmitted to the form control via the setDisabledState method\n\nAnd here is the component, with the interface already implemented:\n\nLet's now go through each of the methods one by one, and explain how they were implemented.\n\nThe method is called by the Angular forms module whenever the parent form wants to set a value in the child control.\n\nIn the case of our component, we will take the value and assign it directly to the internal property:\n\nThe parent form can set a value in the child control using , but what about the other way around?\n\nIf the user interacts with the form control and increments or decrements the counter value, then the new value needs to be communicated back to the parent form.\n\nThe child control can notify the parent form that a new value is available via the use of a callback function.\n\nThe first step for this to work, is for the parent form to register the callback function with the child control, bt using the method:\n\nAs we can see, when this method is called, we are going to receive our callback function, which we then save for later in a member variable.\n\nThe member variable is declared as a function, and initialized with an empty function, meaning a function with an empty body.\n\nThis way, if our program by some reason calls the function before the\n\n call was made, we won't run into any errors.\n\nWhen the value of the counter is changed by either clicking on the increment or decrement buttons, then we need to notify the parent form that a new value is available.\n\nWe are going to do so by calling the callback function and reporting the new value:\n\nBesides reporting new values back to the parent form, we also need to inform the parent form when the child control has been considered to be touched by the user.\n\nWhen the form is initialized, every form control (and the form group as well) is considered to be in status untouched, and the CSS class is applied to the form group and also to each of its individual child controls.\n\nBut when a child control gets touched by the user, meaning the user has tried to interact with it at least once, then the whole form is considered touched as well, meaning that the CSS class gets applied to the form.\n\nThese touched/untouched CSS classes are important for styling error messages in a form, so our custom form control needs to support this as well.\n\nLike before, we need to have a callback registered, so that the child control can report its touched status back to the parent form:\n\nWe now need to call this callback when the control is considered touched, and this will happen whenever the user clicks any of the increment or decrement buttons at least once:\n\nAs we can see, when one of the two buttons gets clicked for the first time, we are going to call the callback once, and the form control will now be considered as touched by the parent form.\n\nThe custom form control will have the CSS class applied to it as expected:\n\nIts also possible for the parent form to enable or disable any of its child controls, by calling the method. We can keep the disabled status in the member variable , and use it in order to turn on and off the increment/decrement functionality:\n\nFinally, the last piece of the puzzle to implement the interface correctly, is to register the custom form control as a known value accessor in the dependency injection system:\n\nWithout this configuration in place, our custom form control will not work correctly.\n\nSo what does this configuration do? We are adding the component to the list of known value accessors, that are all registered with the unique dependency injection key (also known as an injection token).\n\nNotice the flag set to true, this means that this dependency provides a list of values, and not only one value. This is normal because there are many value accessors registered with Angular Forms besides our own.\n\nFor example, all the built-in value accessors for standard text inputs, checkboxes, etc. are also registered under .\n\nThis way, whenever the Angular forms module needs the full list of all the value accessors available, all it has to do is to inject .\n\nWith this, our component is now capable of setting the value of a property in a form.\n\nMore than that, the component is now capable of participating in the form validation process and is already fully compatible with for example the built-in and validators.\n\nBut what if the component needs to have its own built-in validation rules, that are always active for every instance of the component, independently of the form configuration?\n\nIn the case of our custom form control, we would like for it to ensure that the quantity is positive. If it's not, then the form field should be marked as in error, and this should be true for all instances of the component, always.\n\nIn order to implement this logic, we are going to have our component implement the interface. This interface contains only two methods:\n• validate: This method is used to validate the current value of the form control. This method will be called whenever a new value is reported to the parent form. The method needs to return null if no errors are found, or an error object containing all the details needed to correctly display a meaningful error message to the user.\n• registerOnValidatorChange: This will register a callback that will allow us to trigger the validation of the custom control on demand. We don't need to do this when new values are emitted, as validation is already triggered in that case. We only need to call this method if some other input that also affects the behavior of has changed\n\nLet's now see how to implement this interface, and do a final demo of the working component.\n\nThe only method of that we really have to implement is the method:\n\nIn this implementation, we return if the value is valid, and an error object containing all the details about the error.\n\nIn the case of our component, we didn't need to implement\n\n , as implementing this method is optional.\n\nWe only need this method if for example, our component had configurable validation rules, that depended on some of the component inputs. If that would be the case, we could trigger a new validation on demand in case one of the validation inputs changes.\n\nIn our case, the implementation only depends on the current value of the control, so we didn't need to implement and grab that callback for further use.\n\nIn order for the Validator interface to work properly, we also need to register our custom component with the injection token:\n\nNotice that without registering this class properly in ,\n\n the method will never get called.\n\nAnd with the two interfaces and , we now have a fully functional custom form control, compatible with both reactive and template-driven forms, and capable of both setting the value of a form property and participating in the form validation process.\n\nHere is the final code:\n\nLet's now test this component at runtime, by adding it to a form with a couple of standard validators:\n\nAs we can see, we are making the field mandatory, and setting a maximum value of 100. The initial value of the control is 60, which is a valid value.\n\nBut what happens if we set the value to for example 110? The form will then become invalid, and the control will have an error associated with it.\n\nWe can see the error by checking the value of the property of\n\n :\n\nAs we can see, the built-in validator kicked in and marked our custom form control in error as expected.\n\nBut what if instead, we set the quantity value to for example a negative -10 value? Here is what the property of our control will now look like:\n\nAs we can see, now the method created a object, which was then set as part of the errors of the form control.\n\nWe now have a fully functional custom form control, compatible with template-driven forms, reactive forms, and all built-in validators.\n\nHow to implement nested form groups (an address nested form)\n\nA very common forms use case that can be implemented with what we have learned so far are nested form groups, that can be reused across multiple forms.\n\nA good example of this is an address form, with all the usual address fields:\n\nNow imagine that your application has many different forms where an address is required. We wouldn't want to repeat all the code needed for displaying and validating those fields across every form.\n\nInstead, what we would like to do is to create a reusable form section under the form of an Angular component, that we could then plug into multiple forms, sort of a nested reusable sub-form.\n\nHere is how we would like to use such an address form component:\n\nAs we can see, we would like to make our address form component fully compatible with Angular forms, meaning that it should support the ,\n\n and directives, and be able to participate in the validation of the parent form.\n\nIndeed, all we have to do for that is to implement just like we did before the\n\n and interfaces. So how will this work?\n\nFirst, we need to define the view of our nested address form component:\n\nAs we can see, our nested address form is also a from group itself, and it also uses Angular forms internally to collect the values of every address field and validate their values.\n\nThe object already contains all the information about the values and validity state of this subform. We can now use this information to quickly implement both the and interfaces:\n\nHere are some important notes about this implementation:\n• the form address component uses itself a form internally for doing all the form validation using a series of built-in validators\n• we are using the principle of delegation as much as possible here. For example, we are getting all the information that we need from the object\n• As an example of the delegation principle, we are implementing using , and we are implementing by using and\n• We are using the Observable to know when a new value is emitted by the the address form, and calling the callback to notify the parent form.\n• As we are manually subscribing to the Observable, we are also unsubscribing from it using , to avoid any memory leaks\n• we are implementing the method by checking if the embedded form controls have any errors and passing them to the object\n\nIf we try to fill in the values of the address form, we are going to see that they are reported back to the parent form, and show up under the property.\n\nThis is property of the parent form containing , after typing in an address:\n\nEvery form control has linked to it a control value accessor, which is responsible for the interaction between the form control and the parent form.\n\nAnd this includes all the standard HTML form controls like text inputs, checkboxes, etc., for which the forms module provides built-in control value accessors.\n\nFor a custom form control, we will have to build our own control value accessor by implementing the interface, and if we want the control to do custom value validation then we need to implement the interface.\n\nWe can also use the same technique to implement nested form groups (like an address sub-form), that can be reused across multiple forms.\n\nI hope that you have enjoyed this post, if you would like to learn a lot more about Angular Forms, we recommend checking the Angular Forms In Depth course, where validators, custom form controls, and many other advanced form topics are covered in detail.\n\nAlso, if you have some questions or comments please let me know in the comments below and I will get back to you.\n\nTo get notified of upcoming posts on Angular, I invite you to subscribe to our newsletter:\n\nAnd if you are just getting started learning Angular, have a look at the Angular for Beginners Course:"
    }
]