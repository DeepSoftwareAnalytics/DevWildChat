[
    {
        "link": "https://pika.readthedocs.io",
        "document": "Pika is a pure-Python implementation of the AMQP 0-9-1 protocol that tries to stay fairly independent of the underlying network support library.\n\nIf you have not developed with Pika or RabbitMQ before, the Introduction to Pika documentation is a good place to get started.\n\nPika is available for download via PyPI and may be installed using easy_install or pip: To install from source, run “python setup.py install” in the root source directory."
    },
    {
        "link": "https://github.com/pika/pika",
        "document": "Pika is a pure-Python implementation of the AMQP 0-9-1 protocol including RabbitMQ's extensions.\n• Supports Python 3.7+ (1.1.0 was the last version to support 2.7)\n• Since threads aren't appropriate to every situation, it doesn't require threads. Pika core takes care not to forbid them, either. The same goes for greenlets, callbacks, continuations, and generators. An instance of Pika's built-in connection adapters isn't thread-safe, however.\n• People may be using direct sockets, plain old , or any of the wide variety of ways of getting network events to and from a Python application. Pika tries to stay compatible with all of these, and to make adapting it to a new environment as simple as possible.\n\nPika's documentation can be found at https://pika.readthedocs.io.\n\nHere is the most simple example of use, sending a message with the adapter:\n\nAnd an example of writing a blocking consumer:\n• - synchronous adapter on top of library for simple usage.\n• - asynchronous adapter for use with Gevent's I/O loop.\n• - asynchronous adapter for use with Tornado's I/O loop.\n• - asynchronous adapter for use with Twisted's I/O loop.\n\nYou can also pass multiple instances for fault-tolerance as in the code snippet below (host names are just examples, of course). To enable retries, set and as needed in the last element of the sequence. Retries occur after connection attempts using all of the given connection parameters fail.\n\nWith non-blocking adapters, such as and , you can request a connection using multiple connection parameter instances via the connection adapter's class method.\n\nThe single-threaded usage constraint of an individual Pika connection adapter instance may result in a dropped AMQP/stream connection due to AMQP heartbeat timeout in consumers that take a long time to process an incoming message. A common solution is to delegate processing of the incoming messages to another thread, while the connection adapter's thread continues to service its I/O loop's message pump, permitting AMQP heartbeats and other I/O to be serviced in a timely fashion.\n\nMessages processed in another thread may not be acknowledged directly from that thread, since all accesses to the connection adapter instance must be from a single thread, which is the thread running the adapter's I/O loop. This is accomplished by requesting a callback to be executed in the adapter's I/O loop thread. For example, the callback function's implementation might look like this:\n\nThe code running in the other thread may request the function to be executed in the connection adapter's I/O loop thread using an adapter-specific mechanism:\n• None abstracts its I/O loop from the application and thus exposes . Refer to this method's docstring for additional information. For example:\n• None When using a non-blocking connection adapter, such as or , you use the underlying asynchronous framework's native API for requesting an I/O loop-bound callback from another thread. For example, 's I/O loop provides , 's I/O loop has , while 's I/O loop exposes .\n\nThis threadsafe callback request mechanism may also be used to delegate publishing of messages, etc., from a background thread to the connection adapter's thread.\n\nSome RabbitMQ clients (Bunny, Java, .NET, Objective-C, Swift) provide a way to automatically recover a connection, its channels and topology (e.g. queues, bindings and consumers) after a network failure. Others require connection recovery to be performed by the application code and strive to make it a straightforward process. Pika falls into the second category.\n\nPika supports multiple connection adapters. They take different approaches to connection recovery.\n\nFor adapter exception handling can be used to check for connection errors. Here is a very basic example:\n\nThis example can be found in examples/consume_recover.py.\n\nGeneric operation retry libraries such as retry can be used. Decorators make it possible to configure some additional recovery behaviours, like delays between retries and limiting the number of retries:\n\nThis example can be found in examples/consume_recover_retry.py.\n\nFor asynchronous adapters, use to react to connection failure events. This callback can be used to clean up and recover the connection.\n\nAn example of recovery using can be found in examples/asynchronous_consumer_example.py.\n\nTo contribute to Pika, please make sure that any new features or changes to existing functionality include test coverage.\n\nPull requests that add or change code without adequate test coverage will be rejected.\n\nAdditionally, please format your code using Yapf with style prior to issuing your pull request. Note: only format those lines that you have changed in your pull request. If you format an entire file and change code outside of the scope of your PR, it will likely be rejected.\n\nNew non-blocking adapters may be implemented in either of the following ways:\n• By subclassing , implementing its abstract method and passing its constructor an implementation of . implements 's abstract methods, including internally-initiated connection logic. For examples, refer to the implementations of , and .\n• By subclassing and implementing its abstract methods. This approach facilitates implementation of custom connection-establishment and transport mechanisms. For an example, refer to the implementation of ."
    },
    {
        "link": "https://rabbitmq.com/tutorials/tutorial-one-python",
        "document": "RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be sure that the letter carrier will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is a post box, a post office, and a letter carrier.\n\nThe major difference between RabbitMQ and the post office is that it doesn't deal with paper, instead it accepts, stores, and forwards binary blobs of data ‒ messages.\n\nRabbitMQ, and messaging in general, uses some jargon.\n• Producing means nothing more than sending. A program that sends messages is a producer :\n• A queue is the name for the post box in RabbitMQ. Although messages flow through RabbitMQ and your applications, they can only be stored inside a queue. A queue is only bound by the host's memory & disk limits, it's essentially a large message buffer. Many producers can send messages that go to one queue, and many consumers can try to receive data from one queue. This is how we represent a queue:\n• Consuming has a similar meaning to receiving. A consumer is a program that mostly waits to receive messages:\n\nNote that the producer, consumer, and broker do not have to reside on the same host; indeed in most applications they don't. An application can be both a producer and consumer, too.\n\nIn this part of the tutorial we'll write two small programs in Python; a producer (sender) that sends a single message, and a consumer (receiver) that receives messages and prints them out. It's the \"Hello World\" of messaging.\n\nIn the diagram below, \"P\" is our producer and \"C\" is our consumer. The box in the middle is a queue - a message buffer that RabbitMQ keeps on behalf of the consumer.\n\nOur overall design will look like:\n\nProducer sends messages to the \"hello\" queue. The consumer receives messages from that queue.\n\nNow we have Pika installed, we can write some code.\n\nOur first program will send a single message to the queue. The first thing we need to do is to establish a connection with RabbitMQ server.\n\nWe're connected now, to a broker on the local machine - hence the localhost. If we wanted to connect to a broker on a different machine we'd simply specify its name or IP address here.\n\nNext, before sending we need to make sure the recipient queue exists. If we send a message to non-existing location, RabbitMQ will just drop the message. Let's create a hello queue to which the message will be delivered:\n\nAt this point we're ready to send a message. Our first message will just contain a string Hello World! and we want to send it to our hello queue.\n\nIn RabbitMQ a message can never be sent directly to the queue, it always needs to go through an exchange. But let's not get dragged down by the details ‒ you can read more about exchanges in the third part of this tutorial. All we need to know now is how to use a default exchange identified by an empty string. This exchange is special ‒ it allows us to specify exactly to which queue the message should go. The queue name needs to be specified in the parameter:\n\nBefore exiting the program we need to make sure the network buffers were flushed and our message was actually delivered to RabbitMQ. We can do it by gently closing the connection.\n\nOur second program will receive messages from the queue and print them on the screen.\n\nAgain, first we need to connect to RabbitMQ server. The code responsible for connecting to Rabbit is the same as previously.\n\nThe next step, just like before, is to make sure that the queue exists. Creating a queue using is idempotent ‒ we can run the command as many times as we like, and only one will be created.\n\nYou may ask why we declare the queue again ‒ we have already declared it in our previous code. We could avoid that if we were sure that the queue already exists. For example if program was run before. But we're not yet sure which program to run first. In such cases it's a good practice to repeat declaring the queue in both programs.\n\nReceiving messages from the queue is more complex. It works by subscribing a function to a queue. Whenever we receive a message, this function is called by the Pika library. In our case this function will print on the screen the contents of the message.\n\nNext, we need to tell RabbitMQ that this particular callback function should receive messages from our hello queue:\n\nFor that command to succeed we must be sure that a queue which we want to subscribe to exists. Fortunately we're confident about that ‒ we've created a queue above ‒ using .\n\nThe parameter will be described later on.\n\nAnd finally, we enter a never-ending loop that waits for data and runs callbacks whenever necessary, and catch during program shutdown.\n\nNow we can try out our programs in a terminal. First, let's start a consumer, which will run continuously waiting for deliveries:\n\nNow start the producer in a new terminal. The producer program will stop after every run:\n\nThe consumer will print the message:\n\nHurray! We were able to send our first message through RabbitMQ. As you might have noticed, the program doesn't exit. It will stay ready to receive further messages, and may be interrupted with Ctrl-C.\n\nTry to run again in a new terminal.\n\nWe've learned how to send and receive a message from a named queue. It's time to move on to part 2 and build a simple work queue."
    },
    {
        "link": "https://pika.readthedocs.io/en/latest",
        "document": "Pika is a pure-Python implementation of the AMQP 0-9-1 protocol that tries to stay fairly independent of the underlying network support library.\n\nIf you have not developed with Pika or RabbitMQ before, the Introduction to Pika documentation is a good place to get started.\n\nPika is available for download via PyPI and may be installed using easy_install or pip: To install from source, run “python setup.py install” in the root source directory."
    },
    {
        "link": "https://pypi.org/project/pika",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://stackoverflow.com/questions/19964377/rabbitmq-python-library-check-status",
        "document": "Folks, I am trying to check connections that error out, and log to alert if that happens.\n\nFor some reason, this is not working, and is spitting out:\n\nHow can I catch failures and alert on them and continue my checks, instead of the script breaking out?"
    },
    {
        "link": "https://github.com/pika/pika/issues/877",
        "document": "I tried to use channel.is_open and connetcion.is_open to get the connection's and channel's status, but failed.\n\n The return value is always True, even though I stopped rabbitmq server.\n\n Here is my test code.\n\nHere is the print log. When rabbitmq server stops, the print log is still the same as below."
    },
    {
        "link": "https://stackoverflow.com/questions/13037121/in-pika-or-rabbitmq-how-do-i-check-if-any-consumers-are-currently-consuming",
        "document": "I would like to check if a Consumer/Worker is present to consume a Message I am about to send.\n\nIf there isn't any Worker, I would start some workers (both consumers and publishers are on a single machine) and then go about publishing Messages.\n\nIf there is a function like , I would implement it somewhat like this -\n\nBut I am unable to find any function with functionality in pika.\n\nIs there some way of accomplishing this, using pika? or maybe, by talking to The Rabbit directly?\n\nI am not completely sure, but I really think RabbitMQ would be aware of the number of consumers subscribed to different queues, since it does dispatch messages to them and accepts acks\n\nI just got started with RabbitMQ 3 hours ago... any help is welcome...\n\nhere is the workers.py code I wrote, if its any help....\n\nI have to move forward so here is a workaround that I am going to take, unless a better approach comes along,\n\nSo, RabbitMQ has these HTTP management apis, they work after you have turned on the management plugin and at middle of HTTP apis page there is\n\nSo, if I connect my Workers and my Produces both by different Connection names / users, I'll be able to check if the Worker Connection is open... (there might be issues when worker dies...)\n\nwill be waiting for a better solution...\n\njust found this in the rabbitmq docs, but this would be hacky to do in python:\n\nso i could do something like,\n\nhacky... still hope pika has some python function to do this..."
    },
    {
        "link": "https://medium.com/analytics-vidhya/how-to-use-rabbitmq-with-python-e0ccfe7fa959",
        "document": "As described in this diagram we have producer and consumer of messages. So there are two sides of This design, One is Producer and other is Consumer we will see both ends and write a python script for that.\n\n* credentials- In this we will define the username and password which is known by the rabbitmq-server(refer installation segment above)\n\n* host- by default we use ‘localhost’ or 0.0.0.0 as the listening server, but it can have any other IP addresses on cloud that has rabbitmq-server listening\n\n* port- this is by default 5672, but it should point to the port where our server is listening\n\n* exchange- this can be assumed as a bridge name which needed to be declared so that queues can be accessed\n\n* routing_key- this is a binding key corresponding to that key, we can set it to be any name\n\n* basic_publish- this is the method which we call to send the message to the corresponding queue\n\nWe will use the same credentials that we created during the installation of rabbimq-server.\n\nimport pika\n\n#declaring the credentials needed for connection like host, port, username, password, exchange etc\n\ncredentials = pika.PlainCredentials('tester','secretPass')\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost', port='5672', credentials= credentials))\n\nchannel = connection.channel()\n\nchannel.exchange_declare('test', durable=True, exchange_type='topic') #defining callback functions responding to corresponding queue callbacks\n\ndef callbackFunctionForQueueA(ch,method,properties,body):\n\n print('Got a message from Queue A: ', body)\n\ndef callbackFunctionForQueueB(ch,method,properties,body):\n\n print('Got a message from Queue B: ', body)\n\ndef callbackFunctionForQueueC(ch,method,properties,body):\n\n print('Got a message from Queue C: ', body) #Attaching consumer callback functions to respective queues that we wrote above\n\nchannel.basic_consume(queue='A', on_message_callback=callbackFunctionForQueueA, auto_ack=True)\n\nchannel.basic_consume(queue='B', on_message_callback=callbackFunctionForQueueB, auto_ack=True)\n\nchannel.basic_consume(queue='C', on_message_callback=callbackFunctionForQueueC, auto_ack=True)\n\n#this will be command for starting the consumer session\n\nchannel.start_consuming()\n\nThis often happens\n\nDue to blocking connection if channel got connected for long time then server rejects the connection. To overcome this we can go through two approaches, One to change the connection type for long time, Other can be to make connection only when you want to send or receive something. Second one is better approach.\n\nThis blog was meant to be the minimal code required to get started with python and we can develop on top of it to harness more advanced features and utilize it for building a great project.\n\nFor further reading, pika has great documentation that we can read:- https://pika.readthedocs.io/en/stable/"
    },
    {
        "link": "https://cloudamqp.com/blog/part2-3-rabbitmq-for-beginners_example-and-sample-code-python.html",
        "document": "Getting started with RabbitMQ and Python\n\nStart by downloading the client-library for Python3. The recommended library for Python is Pika. Put in your file.\n\nYou need a RabbitMQ instance to get started. Read about how to set up an instance here.\n\nWhen running the full code given, a connection will be established between the RabbiMQ instance and your application. Queues and exchanges will be declared and created if they do not already exist and finally a message will be published. The consumer subscribes to the queue, and the messages are handled one by one and sent to the PDF processing method.\n\nA default exchange, identify by the empty string (\"\") will be used. The default exchange means that messages are routed to the queue with the name specified by routing_key, if it exists. (The default exchange is a direct exchange with no name)"
    },
    {
        "link": "https://pika.readthedocs.io/en/stable/modules/parameters.html",
        "document": "To maintain flexibility in how you specify the connection information required for your applications to properly connect to RabbitMQ, pika implements two classes for encapsulating the information, and .\n\nThe classic object for specifying all of the connection parameters required to connect to RabbitMQ, provides attributes for tweaking every possible connection option. # Set the connection parameters to connect to rabbit-server1 on port 5672 # on the / virtual host using the username \"guest\" and password \"guest\" Connection parameters object that is passed into the connection adapter upon construction. client properties used to override the fields in the default client properties reported to RabbitMQ via method. Defaults to . number of socket connection attempts. Defaults to . See also . one of the classes from . Defaults to . desired maximum AMQP frame size to use. Defaults to . AMQP connection heartbeat timeout value for negotiation during connection tuning or callable which is invoked during connection tuning. None to accept broker’s value. 0 turns heartbeat off. Defaults to . hostname or ip address of broker. Defaults to . locale value to pass to broker; e.g., ‘en_US’. Defaults to . interval between socket connection attempts; see also . Defaults to . socket connect timeout in seconds. Defaults to . The value None disables this timeout. full protocol stack TCP/[SSL]/AMQP bring-up timeout in seconds. Defaults to . The value None disables this timeout. None for plaintext or instance for SSL/TLS. None or a dict of options to pass to the underlying socket\n\nThe class allows you to pass in an AMQP URL when creating the object and supports the host, port, virtual host, ssl, username and password in the base URL and other options are passed in via query parameters. # Set the connection parameters to connect to rabbit-server1 on port 5672 # on the / virtual host using the username \"guest\" and password \"guest\" Connect to RabbitMQ via an AMQP URL in the format: Ensure that the virtual host is URI encoded when specified. For example if you are using the default “/” virtual host, the value should be .\n• None dict of client properties used to override the fields in the default client properties reported to RabbitMQ via method\n• None Specify how many times pika should try and reconnect before it gives up\n• None Desired connection heartbeat timeout for negotiation. If not present the broker’s value is accepted. 0 turns heartbeat off.\n• None None for plaintext; for SSL: dict of public ssl context-related arguments that may be passed to as kwargs, except , ,`do_handshake_on_connect`, , , , .\n• None The number of seconds to sleep before attempting to connect on connection failure.\n• None Socket connect timeout value in seconds (float or int)\n• None Positive full protocol stack (TCP/[SSL]/AMQP) bring-up timeout in seconds. It’s recommended to set this value higher than .\n• None Set the timeout, in seconds, that the connection may remain blocked (triggered by Connection.Blocked from broker); if the timeout expires before connection becomes unblocked, the connection will be torn down, triggering the connection’s on_close_callback\n• None Set the tcp options for the underlying socket. url (str) – The AMQP URL to connect to None for plaintext or instance for SSL/TLS. hostname or ip address of broker. Defaults to . one of the classes from . Defaults to . client properties used to override the fields in the default client properties reported to RabbitMQ via method. Defaults to . number of socket connection attempts. Defaults to . See also . desired maximum AMQP frame size to use. Defaults to . AMQP connection heartbeat timeout value for negotiation during connection tuning or callable which is invoked during connection tuning. None to accept broker’s value. 0 turns heartbeat off. Defaults to . locale value to pass to broker; e.g., ‘en_US’. Defaults to . interval between socket connection attempts; see also . Defaults to . socket connect timeout in seconds. Defaults to . The value None disables this timeout. full protocol stack TCP/[SSL]/AMQP bring-up timeout in seconds. Defaults to . The value None disables this timeout. None or a dict of options to pass to the underlying socket"
    },
    {
        "link": "https://stackoverflow.com/questions/27805086/how-to-connect-pika-to-rabbitmq-remote-server-python-pika",
        "document": "first step is to add another account to your rabbitMQ server. To do this in windows...\n• navigate to the \"C:\\Program Files\\RabbitMQ Server\\rabbitmq_server-3.6.2\\sbin\" directory ( type \"cd \\Program Files\\RabbitMQ Server\\rabbitmq_server-3.6.2\\sbin\" and press enter )\n• open a broswer window to the management console & navigate to the admin section (http://localhost:15672/#/users with credentials \"guest\" - \"guest\")\n• add a new user (for example \"the_user\" with password \"the_pass\"\n• give that user permission to virtual host \"/\" (click user's name then click \"set permission\")\n\nNow if you modify the connection info as done in the following modification of send.py you should find success:"
    },
    {
        "link": "https://rabbitmq.com/tutorials/tutorial-one-python",
        "document": "RabbitMQ is a message broker: it accepts and forwards messages. You can think about it as a post office: when you put the mail that you want posting in a post box, you can be sure that the letter carrier will eventually deliver the mail to your recipient. In this analogy, RabbitMQ is a post box, a post office, and a letter carrier.\n\nThe major difference between RabbitMQ and the post office is that it doesn't deal with paper, instead it accepts, stores, and forwards binary blobs of data ‒ messages.\n\nRabbitMQ, and messaging in general, uses some jargon.\n• Producing means nothing more than sending. A program that sends messages is a producer :\n• A queue is the name for the post box in RabbitMQ. Although messages flow through RabbitMQ and your applications, they can only be stored inside a queue. A queue is only bound by the host's memory & disk limits, it's essentially a large message buffer. Many producers can send messages that go to one queue, and many consumers can try to receive data from one queue. This is how we represent a queue:\n• Consuming has a similar meaning to receiving. A consumer is a program that mostly waits to receive messages:\n\nNote that the producer, consumer, and broker do not have to reside on the same host; indeed in most applications they don't. An application can be both a producer and consumer, too.\n\nIn this part of the tutorial we'll write two small programs in Python; a producer (sender) that sends a single message, and a consumer (receiver) that receives messages and prints them out. It's the \"Hello World\" of messaging.\n\nIn the diagram below, \"P\" is our producer and \"C\" is our consumer. The box in the middle is a queue - a message buffer that RabbitMQ keeps on behalf of the consumer.\n\nOur overall design will look like:\n\nProducer sends messages to the \"hello\" queue. The consumer receives messages from that queue.\n\nNow we have Pika installed, we can write some code.\n\nOur first program will send a single message to the queue. The first thing we need to do is to establish a connection with RabbitMQ server.\n\nWe're connected now, to a broker on the local machine - hence the localhost. If we wanted to connect to a broker on a different machine we'd simply specify its name or IP address here.\n\nNext, before sending we need to make sure the recipient queue exists. If we send a message to non-existing location, RabbitMQ will just drop the message. Let's create a hello queue to which the message will be delivered:\n\nAt this point we're ready to send a message. Our first message will just contain a string Hello World! and we want to send it to our hello queue.\n\nIn RabbitMQ a message can never be sent directly to the queue, it always needs to go through an exchange. But let's not get dragged down by the details ‒ you can read more about exchanges in the third part of this tutorial. All we need to know now is how to use a default exchange identified by an empty string. This exchange is special ‒ it allows us to specify exactly to which queue the message should go. The queue name needs to be specified in the parameter:\n\nBefore exiting the program we need to make sure the network buffers were flushed and our message was actually delivered to RabbitMQ. We can do it by gently closing the connection.\n\nOur second program will receive messages from the queue and print them on the screen.\n\nAgain, first we need to connect to RabbitMQ server. The code responsible for connecting to Rabbit is the same as previously.\n\nThe next step, just like before, is to make sure that the queue exists. Creating a queue using is idempotent ‒ we can run the command as many times as we like, and only one will be created.\n\nYou may ask why we declare the queue again ‒ we have already declared it in our previous code. We could avoid that if we were sure that the queue already exists. For example if program was run before. But we're not yet sure which program to run first. In such cases it's a good practice to repeat declaring the queue in both programs.\n\nReceiving messages from the queue is more complex. It works by subscribing a function to a queue. Whenever we receive a message, this function is called by the Pika library. In our case this function will print on the screen the contents of the message.\n\nNext, we need to tell RabbitMQ that this particular callback function should receive messages from our hello queue:\n\nFor that command to succeed we must be sure that a queue which we want to subscribe to exists. Fortunately we're confident about that ‒ we've created a queue above ‒ using .\n\nThe parameter will be described later on.\n\nAnd finally, we enter a never-ending loop that waits for data and runs callbacks whenever necessary, and catch during program shutdown.\n\nNow we can try out our programs in a terminal. First, let's start a consumer, which will run continuously waiting for deliveries:\n\nNow start the producer in a new terminal. The producer program will stop after every run:\n\nThe consumer will print the message:\n\nHurray! We were able to send our first message through RabbitMQ. As you might have noticed, the program doesn't exit. It will stay ready to receive further messages, and may be interrupted with Ctrl-C.\n\nTry to run again in a new terminal.\n\nWe've learned how to send and receive a message from a named queue. It's time to move on to part 2 and build a simple work queue."
    },
    {
        "link": "https://pika.readthedocs.io/en/stable/examples/using_urlparameters.html",
        "document": "Pika has two methods of encapsulating the data that lets it know how to connect to RabbitMQ, and .\n\nIf you’re connecting to RabbitMQ on localhost on port 5672, with the default virtual host of / and the default username and password of guest and guest, you do not need to specify connection parameters when connecting.\n\nUsing is an easy way to minimize the variables required to connect to RabbitMQ and supports all of the directives that supports.\n\nThe following is the format for the URLParameters connection value:\n\nAs you can see, by default, the scheme (amqp, amqps), username, password, host, port and virtual host make up the core of the URL and any other parameter is passed in as query string values.\n\nThe default connection URL connects to the / virtual host as guest using the guest password on localhost port 5672. Note the forwardslash in the URL is encoded to %2F: Connect to a host rabbit1 as the user www-data using the password rabbit_pwd on the virtual host web_messages: Connecting via SSL is pretty easy too. To connect via SSL for the previous example, simply change the scheme to amqps. If you do not specify a port, Pika will use the default SSL port of 5671: If you’re looking to tweak other parameters, such as enabling heartbeats, simply add the key/value pair as a query string value. The following builds upon the SSL connection, enabling heartbeats every 30 seconds: Options that are available as query string values:\n• backpressure_detection: Pass in a value of t to enable backpressure detection, it is disabled by default.\n• channel_max: Alter the default channel maximum by passing in a 32-bit integer value here.\n• connection_attempts: Alter the default of 1 connection attempt by passing in an integer value here.\n• frame_max: Alter the default frame maximum size value by passing in a long integer value .\n• heartbeat: Pass a value greater than zero to enable heartbeats between the server and your application. The integer value you pass here will be the number of seconds between heartbeats.\n• locale: Set the locale of the client using underscore delimited posix Locale code in ll_CC format (en_US, pt_BR, de_DE).\n• retry_delay: The number of seconds to wait before attempting to reconnect on a failed connection, if connection_attempts is > 0.\n• socket_timeout: Change the default socket timeout duration from 0.25 seconds to another integer or float value. Adjust with caution.\n• None ssl_options: A url encoded dict of values for the SSL connection. The available keys are: For an information on what the ssl_options can be set to reference the official Python documentation. Here is an example of setting the client certificate and key: The following example demonstrates how to generate the ssl_options string with Python’s urllib:"
    },
    {
        "link": "https://cloudamqp.com/blog/part2-3-rabbitmq-for-beginners_example-and-sample-code-python.html",
        "document": "Getting started with RabbitMQ and Python\n\nStart by downloading the client-library for Python3. The recommended library for Python is Pika. Put in your file.\n\nYou need a RabbitMQ instance to get started. Read about how to set up an instance here.\n\nWhen running the full code given, a connection will be established between the RabbiMQ instance and your application. Queues and exchanges will be declared and created if they do not already exist and finally a message will be published. The consumer subscribes to the queue, and the messages are handled one by one and sent to the PDF processing method.\n\nA default exchange, identify by the empty string (\"\") will be used. The default exchange means that messages are routed to the queue with the name specified by routing_key, if it exists. (The default exchange is a direct exchange with no name)"
    }
]