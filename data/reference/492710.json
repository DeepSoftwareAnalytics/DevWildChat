[
    {
        "link": "https://pptr.dev/guides/javascript-execution",
        "document": "Puppeteer allows evaluating JavaScript functions in the context of the page driven by Puppeteer:\n\nAlternatively, you can provide a function body as a string:\n\nThe functions you evaluate can return values. If the returned value is of a primitive type, it gets automatically converted by Puppeteer to a primitive type in the script context like in the previous example.\n\nIf the script returns an object, Puppeteer serializes it to a JSON and reconstructs it on the script side. This process might not always yield correct results, for example, when you return a DOM node:\n\nTo work with the returned objects, Puppeteer offers a way to return objects by reference:\n\nThe returned object is either a or a . extends and it is only created for DOM elements.\n\nSee the API documentation for more details about what methods are available for handles.\n\nIf you return a Promise from an evaluate call, the promise will be automatically awaited. For example,\n\nYou can provide arguments to your function:\n\nThe arguments can be primitive values or s."
    },
    {
        "link": "https://latenode.com/blog/executing-javascript-in-page-context-with-pageevaluate-in-puppeteer",
        "document": "is a key Puppeteer method that lets you run JavaScript directly in the browser context. It bridges Node.js and the browser, enabling tasks like DOM manipulation, data extraction, and automation of dynamic web pages. Here's what you need to know:\n• What It Does: Executes JavaScript in the browser, as if you were using the browser's console.\n• How It Works: Converts a function to a string, sends it to the browser, executes it, and returns the result.\n• Limitations: Functions must be JSON-serializable, and Node.js variables are not directly accessible in the browser context.\n\nThis retrieves the page title directly from the browser.\n\nUse for precise, efficient automation tasks, especially when working with JavaScript-heavy websites.\n\nNodeJS : Nodejs/Puppeteer - How to use page.evaluate\n\nWhen working with Puppeteer for web automation, it's crucial to grasp the distinction between the Node.js context and the browser context. These two environments are isolated, each with its own rules for running code and exchanging data.\n\nPuppeteer operates across two environments: the Node.js context, where your main script runs, and the browser context, where interactions with the webpage occur. These are separate processes, each with its own virtual machine.\n\nData exchange between these contexts involves a series of steps, relying heavily on serialization:\n• The function is converted to a string using .\n• This string is sent to the browser via the Chrome DevTools Protocol.\n• The browser evaluates the function within its environment.\n• Results are serialized into JSON and sent back to the Node.js context.\n\nKey limitations: Functions in the browser context cannot directly access variables from the Node.js scope. Puppeteer offers specific tools to address these challenges:\n• : Returns references to objects in the browser context.\n• : Allows the browser to call Node.js functions.\n\nHowever, JSON serialization may strip certain properties, especially with complex objects like DOM nodes. To avoid issues, pass data as function arguments instead of relying on Node.js variables.\n\nMastering these communication techniques ensures you can use effectively for automation tasks. Next, we'll dive into practical examples to see these concepts in action.\n\nThe pageFunction can be a function or a string containing JavaScript code. Using a function is generally better for debugging and TypeScript compatibility. Below are some examples to demonstrate how it works.\n• Extract text from the first directly from the DOM:\n• Manipulate the DOM by adding a new element:\n• Functions run in isolation from your Node.js code.\n• Arguments passed to the function must be JSON-serializable.\n\nDebugging Tip: Use the following configuration to enable debugging during development:\n\nNext, we'll dive into techniques for exchanging data between Node.js and browser contexts.\n\nWhen transferring data with , stick to JSON-serializable values for input arguments.\n\nNow, let's see how these values are returned from the browser context.\n\nWhen using , the returned values are automatically serialized to JSON. Here's how it works:\n\nOnce you've retrieved the output, you may encounter serialization-related challenges. Here's how to tackle them.\n\nIf you're working with TypeScript, ensure your transpiler is set up correctly:\n\nThese strategies will help you handle data exchange effectively in various contexts.\n\nHere’s how you can use in real-world scenarios, complete with practical code snippets.\n\nThis script collects details like title, price, rating, and stock status from product cards on a webpage:\n\nThis approach retrieves data from a table by iterating through its rows and columns:\n\nHere’s how to fill out form fields, trigger events, and submit the form:\n\nFor tasks like selecting dropdown options or checking radio buttons:\n\nThis script scrolls through a page until it collects at least 100 items:\n\nTo load more content dynamically, this script clicks a \"Load More\" button and waits for new elements to appear:\n\nThese examples showcase how to handle diverse scenarios like scraping, form automation, and dynamic content. Adjustments can be made based on the specific structure and behavior of the webpage you're working with.\n\nLatenode incorporates Puppeteer's core features into its automation workflows, making it easier to execute JavaScript directly in the browser. With , users can manipulate the DOM and extract data efficiently. This approach allows for seamless integration of advanced data handling and DOM operations within Latenode's automation environment.\n\nLatenode's browser automation module uses to handle everything from simple DOM tasks to more complex JavaScript execution. Here's how it works in different scenarios:\n\nLatenode also keeps a log of execution history, making it easier to debug scripts.\n\nLatenode is well-equipped to handle dynamic content and complex automation tasks. Here's an example of processing dynamic content on a page:\n\nFor more advanced operations, allows seamless interaction between Node.js and the browser:\n\nTo maintain references to DOM elements across steps, Latenode uses :\n\nThese techniques ensure Latenode can handle dynamic content effectively while maintaining reliable performance. For users on the Prime plan, the platform supports up to 1.5 million scenario runs each month, providing extensive automation capabilities.\n\nWhen working with in browser automation, you might encounter various issues. Here are practical solutions to address them and ensure smoother execution.\n\nProperly configure your TypeScript settings to avoid issues caused by transpilation. For example:\n\nAvoid returning DOM elements directly from . Instead, use for better handling:\n\nScripts may run before the page is fully loaded, leading to timing errors. Use these strategies to handle such cases:\n\nWhen working with multiple elements, pass data safely between contexts:\n\nTo get the best results with , you need to focus on improving performance, reducing unnecessary context switching, and ensuring security. Here’s how you can fine-tune your browser automation workflows.\n\nRunning code efficiently within the page context saves time and system resources. Below are some techniques to make your scripts faster:\n\nChoosing the right selectors also plays a big role in performance:\n\nContext switching between Node.js and the browser environment can slow things down. Here's how to minimize it:\n\nIf you need to process data in Node.js and pass it back to the browser, expose functions instead of repeatedly switching contexts:\n\nOnce performance and context switching are optimized, focus on keeping your scripts secure. Here are some best practices:\n\nFor Latenode workflows, consider these additional tips:\n• Use to cache resources and improve performance across sessions.\n• Handle screenshots with buffers instead of relying on file system operations.\n\nThe method connects Node.js and browser contexts by sending a stringified JavaScript function to execute in the browser. This function operates independently of the Node.js environment, so you need to handle data transfer carefully.\n\nThings to keep in mind:\n• Browser APIs are available only within the context.\n• Node.js variables are not accessible in the browser context.\n\nThese basics lay the groundwork for using Puppeteer effectively. Additional tools can further streamline your automation tasks.\n\nPuppeteer offers several tools to expand the capabilities of :\n\nFor example, exposing Node.js functions to the browser can simplify advanced data processing in workflows like those in Latenode. While works well for handling primitive types and JSON-serializable objects, is essential for dealing with complex browser objects that can't be serialized.\n• Browser Automation with Puppeteer and JavaScript: Practical Implementation in Node.js"
    },
    {
        "link": "https://pptr.dev/api/puppeteer.page.evaluate",
        "document": "Evaluates a function in the page's context and returns the result.\n\nIf the function passed to returns a Promise, the function will wait for the promise to resolve and return its value.\n\nthe return value of .\n\nYou can pass a string instead of a function (although functions are recommended as they are easier to debug and use with TypeScript):\n\nTo get the best TypeScript experience, you should pass in as the generic the type of :\n\nElementHandle instances (including JSHandles) can be passed as arguments to the :"
    },
    {
        "link": "https://community.lambdatest.com/t/executing-javascript-in-puppeteer-with-page-evaluate/29559",
        "document": "I have extensive experience with Puppeteer and using its method to execute JavaScript within the page context. Let’s dive into how you can leverage this feature effectively.\n\nThis is a straightforward and commonly used approach. It allows you to execute JavaScript code directly within the context of the page, accessing its DOM and other properties seamlessly. Great for basic tasks like extracting information or manipulating elements."
    },
    {
        "link": "https://webshare.io/academy-article/puppeteer-execute-javascript",
        "document": "In the realm of web scraping and automated browser testing, Puppeteer stands out as a powerful tool for controlling headless Chrome. One of its key features is the ability to execute JavaScript code directly within the context of a web page, enabling developers to interact dynamically with elements, manipulate data and extract valuable insights.\n\nLet’s discuss the step-by-step process of setting up Puppeteer, navigating to a web page and integrating JavaScript execution to enhance your automation tasks.\n\nBefore diving into Puppeteer’s capabilities, you need to set it up in your development environment. Fortunately, Puppeteer offers easy installation via npm (Node Package Manager), making it accessible to developers across various platforms. Simply run the following command in your terminal to install Puppeteer:\n\nYou need to navigate to the desired URL in order to execute JavaScript on a webpage with Puppeteer. This can be achieved using Puppeteer’s page.goto() method, which loads a given URL in the browser’s tab. Here’s a basic example of how to navigate to a web page using Puppeteer:\n\nYou can execute JavaScript code using Puppeteer’s page.evaluate() method that evaluates the provided function within the context of the page. Here’s how you can execute JavaScript code on a page with Puppeteer:\n\nIn this snippet, Puppeteer evaluates the provided function on the page and returns the title of the web page.\n\nExample - Executing JavaScript on page with Puppeteer\n\nIn this section, we’ll demonstrate how to leverage Puppeteer’s capabilities to execute JavaScript for scraping data on a book-selling website.\n\nLaunching Puppeteer and navigating to the website\n\nFirst, we initiate Puppeteer, launch a new browser instance, create a new page and navigate to the website https://books.toscrape.com/.\n\nNow, we execute custom JavaScript code within the context of the webpage to extract book titles, prices and availability.\n\nThrough the use of document.querySelectorAll(), we target specific elements on the page, such as book titles nested within <h3> tags with the class .product_pod, prices marked with the class .price_color, and availability information indicated by the class .availability.\n\nCombining extracted data into an array of objects\n\nIn this step, we merge the extracted book titles, prices and availability into an array of objects. Using the map() method, each book’s information is paired together into a single object within the booksData array.\n\nLastly, we write the extracted data to a JSON file and close the Puppeteer browser instance.\n\nHere’s how the output looks like:\n\nIn this article, we explored the capabilities of Puppeteer in executing JavaScript on web pages, focusing on the example of extracting data from https://books.toscrape.com/. We demonstrated how Puppeteer enables navigation through web pages, execution of JavaScript to extract targeted information such as book titles, prices and availability, and finally, storing the scraped data in JSON format."
    },
    {
        "link": "https://stackoverflow.com/questions/50243401/whats-the-best-way-to-inject-javascript-into-puppeteer",
        "document": "I'm using Puppeteer to generate PDFs. In a large SPA, there are quite a few times when the code references , but is often what I see in practice.\n\nIf I run the code within the context of Puppeteer, then it should be okay as a headless browser should have a property.\n\nI've seen the approach of having the SPA in a separate port and opening that port, but I'm not sure if that is the best approach to the problem as I already know the JavaScript that I want to run and I just want it executed within the context of Puppeteer.\n\nIs there a better way to execute JavaScript in Puppeteer? Perhaps using something like ?\n\nIf the separate port option is the best I have, then perhaps I'll default to using that."
    },
    {
        "link": "https://freecodecamp.org/news/how-to-use-puppeteer-with-nodejs",
        "document": "Puppeteer is a JavaScript library that allows you to script and interact with browser windows.\n\nIn this guide, we'll explore the basics of using Puppeteer with Node.js so you can start automating your tests.\n• A suitable IDE such as VS Code\n• How to set up your first test with Puppeteer\n• How to run headless Chrome tests on a CI server\n\nPuppeteer is a Node.js library developed by Google that lets you control headless Chrome through the DevTools Protocol.\n\nIt is a tool for automating testing in your application using headless Chrome or Chromebit devices, without requiring any browser extensions like Selenium Webdriver or PhantomJS.\n\nPuppeteer lets you automate the testing of your web applications. With it, you can run tests in the browser and then see the results in real-time on your terminal.\n\nPuppeteer uses the WebDriver protocol to connect with the browser and simulate user interaction with HTML elements or pages.\n\nNode.js is an open-source JavaScript runtime built on Chrome's V8 engine that runs on Linux, Mac OS X, and Windows operating systems. It was first released in 2009 by Ryan Dahl who was one of its original contributors (with some help from Douglas Crockford).\n\nNode.js has become immensely popular over the years as an essential part of many software development projects. It has extensive capabilities when it comes down to coding certain tasks like server-side applications or peer-to-peer networking protocols like Websockets.\n\nHow to Set Up Node.js and Puppeteer\n\nFirst make a directory which you will be working with by right clicking on your preferred location and choosing new folder. You can also use the command in your terminal.\n\nThen create an file in your folder and add the code as shown below:\n\nThe code above creates an instance of the browser which lets Puppeteer launch. Let's make sure we understand the code above:\n• provides the URL to\n\nNow open your terminal and into the folder. Then run to create a file.\n\nPress enter then type yes if asked 'is this ok'.\n\nYour output will look like this:\n\nFollow the setup instructions to install the dependencies that we will use in our project.\n\nHow to Set Up Your First Test with Puppeteer\n\nTo use Puppeteer with Node.js, you'll need to install several packages and set up a few environment variables. This part will walk you through the steps you'll need to follow to use Puppeteer in your tests:\n\nYou only need to complete the last step if you want to run tests on an actual browser instead of just testing against web driver scripts.\n\nIf this is your case, then go ahead and install the selenium-web driver module from the npm package manager by typing .\n\nInstalling the dependencies will generate and a file as shown below:\n\nScreenshots are a great way to capture information in your browser. Well, Puppeteer has got you covered!\n\nTo take a screenshot of the webpage you navigated to, add the code snippet below:\n\nThen type the command below in your terminal:\n\nYou can also create a PDF by adding the following snippet in your code:\n\nThe above code snippet will give us the output shown below:\n\nHow to Test Your Setup\n\nTo test your setup, create a folder in your code, then add .\n\nYour file should contain the following code:\n\nRun your test using . After running your test you will get the following output:\n\nHow to Use One Browser Instance with Puppeteer\n\nAs a web developer, you can use Puppeteer to run scripts in the headless Chrome browser and access the window object. This is useful when testing apps that need access to web resources like localStorage or cookies.\n\nTo use one browser instance with Puppeteer, you just need to pass to the launch method. It's asynchronous so it won't block the main thread and make your application unresponsive.\n\nThe best thing about this method is that, once it's launched, it should only be used once. Otherwise you will get an error when trying to access any webpage from Puppeteer again.\n\nSo, there you have it! Now you know how to get started with Puppeteer and Node.js.\n\nI hope this guide has helped you become more familiar with the tool and its capabilities. Feel free to get in touch with me if you have any questions or suggestions."
    },
    {
        "link": "https://stackoverflow.com/questions/54463695/injecting-html-before-script-evaluation-with-puppeteer",
        "document": "I want to inject some HTML into a specific element on a page using puppeteer.\n\nThe HTML must be injected before any JavaScript is executed.\n\nThere are two ways I think I could do this:\n\nThis function is \"is invoked after the document was created\" but I can't access DOM elements from it. eg:\n\nThis script just outputs newlines when I visit a page.\n• Using to prevent the javascript from executing before I inject the HTML. As per the docs though, this doesn't start executing the javascript after I turn it back on. eg:\n\nMy script looks something like this:\n\nAlternatively, it may also be possible to do something like this, though that seems overly complex for what is a fairly simple request.\n\nIs there an easier way to do this that I am overlooking?"
    },
    {
        "link": "https://medium.com/nerd-for-tech/puppeteer-best-practices-3a1a72c912b0",
        "document": "Puppeteer is pretty easy to use as it provides many APIs to interact with the dom and carry out complex automation and testing. But for beginners, there are some complexities that the developers might not be aware of.\n\nSo here I am sharing some best practices (in my opinion) that I learned from my experience. Let's dive in!\n\nSearch using text/content instead of CSS selectors\n\nThe CSS classes or ids used in third-party websites change frequently. Most well-known websites use random encrypted/hashed strings which might get in the way of using CSS selectors.\n\nThe CSS can also get changed when the developers are refactoring a website. So, it is best to use the text content of the HTML elements as the source of truth.\n\nFor example, you might have to click a login button. So instead of selecting that button using CSS selectors, use the button text “Login” instead.\n\nHere are some ways for achieving the above:\n\nThere are other methods like and that can be used instead of the above methods, but you got the gist of it, right?\n\nIt might be tempting to use the method to wait for an element to load, but there are better ways below. This is not an ideal solution because you don't know how long the element will take to load.\n\nAlways use before performing any operation on an element, especially after a new page has been loaded. This is important because the element you want to access might take time to load or it is being inserted into the DOM using JavaScript after some processing.\n\nYou can't guess when will be an element available on the dom and if you try to perform an operation let's say , it might throw an error as the element hasn't been loaded into the DOM yet.\n\nTherefore, its almost always essential to use waiting methods like the below:\n\nSometimes, it might also come in handy to include a custom timeout as an option and the property.\n\nmeans that if the element is not found after minutes, throw an error. means that the element is found in the DOM and is visible. Otherwise, it may be hidden behind another element or may have a CSS property that makes it invisible.\n\nWhen the browser navigates from one page to another or reloads, it is always necessary to wait for the navigation to complete. Otherwise, if you try to perform operations on the to-be-navigated page and it hasn't completed loading yet, it will throw an error.\n\nThe events that might trigger navigation generally are , , , , and .\n\nWaiting for navigation (till the dom has completely loaded)\n\nThe above might suffice if you just want to wait for the DOM to load. If you also want to wait for the fetch/XHR calls in the background to finish, then method allows you to pass that option.\n\nYou can also extend the default 30s timeout to wait longer if needed\n\nAnother good practice is to use a when waiting for navigation. Pass the first promise as and pass the second promise as the action that might trigger navigation.\n\nThis is necessary because the below code might not work as expected as the might keep on waiting and eventually timeout.\n\nYou might face the common use case of waiting for an API call to populate the page content. In these types of use cases, might come in handy.\n\nThere are two optional properties that can be passed to this method, and .\n\n: Specifies the minimum number of ms till there are no API calls\n\n: Specifies the time limit in ms to wait for till there are no API calls\n\nAlso, for we should use for the reasons mentioned above.\n\nUse evaluate method whenever possible\n\nThe code we write in Puppeteer is converted to vanilla JavaScript that can be understood by the browser and is executed in the browser context. This can be inefficient if you are writing lots of Puppeteer methods that could have been written in an method.\n\nmethod provides better performance as \n\n1) The code is written in vanilla JavaScript that takes less processing from Puppeteer and is easier to write for most devs\n\n2) Most separate Puppeteer calls can be combined into one script, this means fewer calls between the browser and Puppeteer\n\nI am speaking of here, but all these points are also applicable to other helper methods like , and .\n\nFor example, let's say you want to read the text in the first of each row\n\nAs you can see above, Puppeteer will make calls to the browser for every in the , this means a lot of back and forth. Instead, we can use a single script and comparatively shorter code to implement this.\n\nThis takes only a single call to the browser!\n\nWhen NOT to use evaluate\n\ncan seem to be the go-to solution for everything once you get the hang of it. But, there are times when you should avoid using and instead are better off using Puppeteer methods.\n\nThis generally includes user interactions like mouse clicks, keyboard events, typing, hover, focus, etc. These can be implemented using but might not trigger the side effects.\n\nSo, as a rule of thumb, always use Puppeteer methods like , , , , etc when you need to do browser interactions.\n\nThat was it, that was the advice. Remember to do"
    },
    {
        "link": "https://blog.appsignal.com/2023/02/08/puppeteer-in-nodejs-common-mistakes-to-avoid.html",
        "document": "Puppeteer is a powerful Node.js browser automation library for integration testing and web scraping. However, like any complex software, it comes with plenty of potential pitfalls.\n\nIn this article, I'll discuss a variety of common Puppeteer mistakes I've encountered in personal and consulting projects, as well as when monitoring the Puppeteer tag on Stack Overflow. Once you're aware of these problematic patterns, you can write more robust scraping and testing code, while spending less time debugging and wading through arcane Puppeteer errors.\n\nThe article was written using Node 18, Puppeteer 19.4.1, Chrome 108.0.5359.125, and Firefox 108.0.1.\n\nWe will assume you are familiar with ES6 JavaScript syntax, browser development tools, the browser DOM, and Node, and have previously written some Puppeteer scripts.\n\nNow let's examine the pitfalls of Puppeteer.\n\nAttempting to Return Objects and DOM Elements from Callbacks\n\nThe following snippet should be a familiar pattern to those who've previously used Puppeteer:\n\nNote: I'll skip the IIFE, import, and error-handling boilerplate in the remainder of this article.\n\nThe code above attempts to return a DOM element from the browser context back to Node for further processing (clicking it, typing into it, extracting its text content, etc.). However, the call, which runs code in the browser context, resolves to an empty object in Node. DOM elements are complex structures with circular references and cannot be readily serialized and deserialized. These elements can't be decoupled from the browser environment in a meaningful way.\n\nThis behavior isn't specific to Puppeteer. Running on a page with a header element should return on a Chromium-based browser. Firefox gives , also indicating a serialization failure.\n\nOne solution is to use (or the more general ) to create a Puppeteer that exposes an interface to the DOM element. Alternatively, you can use which exposes an interface to the JS object. These interfaces enable you to run code in the browser context on the element, possibly to extract serializable data such as text content or element properties, or issue trusted events. Be sure to dispose of these handles when you no longer need them to avoid memory leaks.\n\nI've used here as it's the most general way to run code in the browser, but the same behavior applies to and as well. These methods are shorthands for the common case when or is the first line in the callback.\n\nTrying to Access Variables from an Callback\n\nAt times, variables may appear to be in scope from an callback in Puppeteer when they aren't. The following example is a bit contrived because we could use , but it nevertheless illustrates the pattern succinctly:\n\nHere, seems like it should be in scope of the callback, but it doesn't exist when the callback runs in the browser, throwing . Yet again, serialization is the culprit: the browser is a completely separate process from Node that doesn't have your Node variables in scope.\n\nUsing the string version of makes the situation clearer:\n\nHowever, building a string can lead to quoting problems. This motivates the more general approach — passing data to the browser by including extra arguments to :\n\nThis parameter-passing pattern also applies to other important Puppeteer calls, such as . A subtle difference is that 's second argument is a configuration options object, followed by the variable parameter arguments:\n\nThis Stack Overflow post offers tips on passing complex arguments to calls.\n\nPuppeteer programmers stuck on a bug often claim their selectors work in browser developer tools, but fail in Puppeteer. Unfortunately, there's no guarantee that code that works in browser developer tools will also work in Puppeteer. Here are some reasons why:\n• Developer tools exposes iframe and shadow root subtrees. Puppeteer requires these trees to be explicitly expanded. It’s worth noting that Microsoft's Playwright library has locators that expand the shadow DOM by default.\n• By the time you get around to interacting with developer tools, the page has typically loaded its resources and executed its JS scripts. In Puppeteer, you can use calls to ensure JS-injected elements are available before interaction.\n• When working in an unautomated browser's developer tools, the website's server trusts you and delivers a full experience. In Node, Puppeteer scripts are often detected as bots, so they are blocked outright or served a restricted version of a page. Adding is an easy way to verify that your HTML structure in Puppeteer is what you expect.\n\nRecognizing developer tools and Node as distinct environments goes a long way to ensuring smooth translations from your developer tools exploration code to the final Puppeteer script.\n\nAssuming Puppeteer's Headless Mode Works the Same as Headful\n\nJust as DevTools is distinct from Node, it's a mistake to assume that Puppeteer's headless mode works the same as headful mode. Websites have a much easier time detecting scripts as bots when in headless mode than in headful mode.\n\nAs with the above tip, is a great way to ensure a document is what you expect. If a selector you see in the developer tools or in headful mode isn't in the headless log, there's a good chance you've been blocked.\n\nNot Using When Triggering Navigation with a Click\n\nNavigation is a common point of failure in Puppeteer scripts. The following code is unsafe:\n\nIn fact, this is a race condition. If the navigation resolves before has the chance to run, the script may throw a timeout error. The correct pattern is:\n\nIn these examples, the navigation wait promise is set before the navigation is triggered, ensuring that it will resolve as intended.\n\nAnother navigation-related mistake is making spurious calls to or . For example:\n\nThis is logical: we want to trigger a navigation with , then wait for that navigation to settle. But already waits for navigation, so the second is waiting for a navigation that's already occurred, causing a timeout.\n\nIt's a similar story when waiting for an idle network state, either with a call or . In fact, waiting for an idle network can make the navigation time out if the automated page keeps enough long-running connections open.\n\nis usually safer since it tolerates two long-running connections. However, it is often used out of laziness or lack of awareness in place of the clear-cut and predicates.\n\nIt's a mistake to set any timeout to 0 — for example, with . Infinite timeouts introduce the potential for the script to block forever when encountering an unexpected state, without giving a clear error message. Under most circumstances, when a script hangs on a selector or navigation for more than a few minutes, it should log an error and either exit so its maintainer can fix the problem, or restart itself if it should keep attempting to do something.\n\nUsually, when I come across infinite timeouts in Puppeteer scripts, it's an artifact of attempting to fix a deeper issue, like the script being detected as a bot and blocked. But the infinite timeout makes these errors harder to detect and resolve by stifling them and causing a silent hang.\n\nAlmost all Puppeteer API calls are asynchronous. The reason for the asynchronous interface is that the browser runs in a separate process from Node. Puppeteer's methods send and receive data and wait for the browser process to respond, much like networking or file system operations. The Node process can use this time to perform CPU-bound work.\n\nA common mistake is forgetting to a promise returned by a Puppeteer call. This can lead to confusing and non-deterministic errors and race conditions.\n\nFor example, omitting on a call may result in a or Execution context was destroyed, most likely because of a navigation .\n\nOne solution to the missing problem described above is to everything, but this can lead to confusion as well.\n\nFor example, I see the following pattern often:\n\nSince doesn't return a promise, it's easy to forget that // do stuff after the request has been handled runs before the request handler callback. The callback is in a different promise chain.\n\nTo solve this, use Puppeteer's (or ) instead of , which acts as a shorthand for manually promisifying the callback.\n\nConsider the following code:\n\nThis code reinstalls an event listener over and over again, slowly eating memory. The problem seems obvious in this minimal example, but I've seen it buried in the midst of moderately-complex, long-running jobs that eventually crash.\n\nenables your browser code to trigger Node code. As with , you can't pass DOM elements or other non-serializable structures as parameters, so a typical use case is passing serialized data like JSON or text for periodic processing. In the common case, you'll use to extract data rather than .\n\nDoing Too Much Work in Parallel\n\nAnother obvious pattern when seen in isolation is:\n\nIf happens to be large enough, the memory and processor load from spawning dozens or hundreds of pages can bring a system down quickly. Consider puppeteer-cluster.\n\nIn this article, we've seen a variety of mistakes and gotchas that every Puppeteer programmer should be aware of.\n\nI hope these tips will save you from making the same mistakes I've made over the years, so you can keep your tests and scripts running smoothly.\n\nP.S. If you liked this post, subscribe to our JavaScript Sorcery list for a monthly deep dive into more magical JavaScript tips and tricks.\n\nP.P.S. If you need an APM for your Node.js app, go and check out the AppSignal APM for Node.js."
    }
]