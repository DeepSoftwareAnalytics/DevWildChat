[
    {
        "link": "https://wiki.libsdl.org/SDL2/SDL_Keycode",
        "document": "Values of this type are used to represent keyboard keys using the current layout of the keyboard. These values include Unicode values representing the unmodified character that would be generated by pressing the key, or an SDLK_* constant for those keys that do not generate characters.\n\nA special exception is the number keys at the top of the keyboard which map to SDLK_0...SDLK_9 on AZERTY layouts."
    },
    {
        "link": "https://libsdl.org/release/SDL-1.2.15/docs/html/sdlkey.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/31941446/what-is-the-difference-between-an-sdl-physical-key-code-and-an-sdl-virtual-key-c",
        "document": "Generally, scancodes are the true values emitted by the keyboard (hardware) to the OS while keycode is what the OS/library maps it to based on the chosen layout. The layout decides the mapping between scancode to some virtual key code. It is part of the operating system's settings. Here, by layout, I mean the functional layout; there're also mechanical and visual layouts. Read more about keyboard layouts in Wikipedia. The concept of scan code and virtual key is explained better with illustration in MSDN.\n\nHowever, SDL uses scancode to mean something different: the scancode of the key in the US QWERTY keyboard whose location is the same as the one in question. It's the device-independant way of denoting a key based on its location. This is buried in an unusual location in SDL's manual:\n\nScancodes are meant to be layout-independent. Think of this as \"the user pressed the Q key as it would be on a US QWERTY keyboard\" regardless of whether this is actually a European keyboard or a Dvorak keyboard or whatever. The scancode is always the same key position. Keycodes are meant to be layout-dependent. Think of this as \"the user pressed the key that is labelled 'Q' on a specific keyboard.\" In example, if you pressed the key that's two keys to the right of CAPS LOCK on a US QWERTY keyboard, it'll report a scancode of SDL_SCANCODE_S and a keycode of SDLK_S. The same key on a Dvorak keyboard, will report a scancode of SDL_SCANCODE_S and a keycode of SDLK_O.\n\nIn the above quote, by layout the manual means the functional layout. The main part of the manual regarding keyboards is a bit brief on this issue:\n\nSDL_Scancode values are used to represent the physical location of a keyboard key on the keyboard. SDL_Keycode values are mapped to the current layout of the keyboard and correlate to an SDL_Scancode. Which one to use is left to the application: scancodes are suited in situations where controls are layout-dependent (eg. the \"WASD\" keys as left-handed arrow keys), whereas keycodes are better suited to situations where controls are character-dependent (eg. the \"I\" key for Inventory).\n\nIn the above quote, by layout the manual means the mechanical/physical layout. So for controlling the character, for instance, using the scancode is better, while for receiving the user's name keycode is better."
    },
    {
        "link": "https://tr0ll.net/libsdl/docs/sdldoc.pdf",
        "document": ""
    },
    {
        "link": "https://blog.theprogrammingjunkie.com/post/sdl2-cheatsheet",
        "document": "// NOTE: For best viewing experience, click \"Raw\" in the top right of the Gist page, or download // this file and view it in your favorite text editor with syntax highlighting! // ASCII art generated by: https://patorjk.com/software/taag/#p=display&f=ANSI%20Shadow&t=Shared%20Object%20Support (with modified 'S' for readability) // Get a mask of the specified subsystems which are currently initialized. // Reset a hint to the default value. // Reset all hints to the default values. // Get the value of a hint. // Get the boolean value of a hint variable. // Set the SDL error message for the current thread. // Retrieve a message about the last error that occurred on the current thread. // Get the last error message that was set for the current thread. // Clear any previous error message for this thread. // Set the priority of all log categories. // Set the priority of a particular log category. // Get the priority of a particular log category. // Log a message with the specified category and priority. // Log a message with the specified category and priority. // Replace the default log output function with one of your own. // Get a list of all assertion failures. // Clear the list of all assertion failures. // Get the version of SDL that is linked against your program. // Get the code revision of SDL that is linked against your program. // Get the number of video drivers compiled into SDL. // Get the name of a built in video driver. // Shut down the video subsystem, if initialized with SDL_VideoInit(). // Get the name of the currently initialized video driver. // Get the number of available video displays. // Get the name of a display in UTF-8 encoding. // Get the desktop area represented by a display. // Get the usable desktop area represented by a display. // Get the dots/pixels-per-inch for a display. // Get the orientation of a display. // Get the number of available display modes. // Get information about the desktop's display mode. // Get information about the current display mode. // Get the closest match to the requested display mode. // Get the index of the display containing a point // Get the index of the display primarily containing a rect // Get the index of the display associated with a window. // Set the display mode to use when a window is visible at fullscreen. // Query the display mode to use when a window is visible at fullscreen. // Get the raw ICC profile data for the screen the window is currently on. // Get the pixel format associated with the window. // Create a window with the specified position, dimensions, and flags. // Create an SDL window from an existing native window. // Get the numeric ID of a window. // Get the title of a window. // Retrieve the data pointer associated with a window. // Get the position of a window. // Get the size of a window's client area. // Get the size of a window's borders (decorations) around the client area. // Get the size of a window in pixels. // Get the minimum size of a window's client area. // Get the maximum size of a window's client area. // Set the window to always be above the others. // Raise a window above other windows and set the input focus. // Make a window as large as possible. // Restore the size and position of a minimized or maximized window. // Get the SDL surface associated with the window. // Copy the window surface to the screen. // Copy areas of the window surface to the screen. // Get the window that currently has an input grab enabled. // Confines the cursor to the specified area of a window. // Get the mouse confinement rectangle of a window. // Set the brightness (gamma multiplier) for a given window's display. // Get the brightness (gamma multiplier) for a given window's display. // Get the opacity of a window. // Set the window as a modal for another window. // Set the gamma ramp for the display that owns a given window. // Get the gamma ramp for a given window's display. // Provide a callback that decides if a window region has special properties. // Request a window to demand attention from the user. // Check whether the screensaver is currently enabled. // Allow the screen to be blanked by a screen saver. // Prevent the screen from being blanked by a screen saver. // Get an OpenGL function by name. // Check if an OpenGL extension is supported for the current context. // Reset all previously set OpenGL context attributes to their default values. // Get the actual value for an attribute from the current context. // Create an OpenGL context for an OpenGL window, and make it current. // Set up an OpenGL context for rendering into an OpenGL window. // Get the currently active OpenGL window. // Get the currently active OpenGL context. // Get the size of a window's underlying drawable in pixels. // Set the swap interval for the current OpenGL context. // Get the swap interval for the current OpenGL context. // Get the number of 2D rendering drivers available for the current display. // Get info about a specific 2D rendering driver for the current display. // Get the renderer associated with a window. // Get the window associated with a renderer. // Get the output size in pixels of a rendering context. // Set an additional color value multiplied into render copy operations. // Get the additional color value multiplied into render copy operations. // Set an additional alpha value multiplied into render copy operations. // Get the additional alpha value multiplied into render copy operations. // Set the blend mode for a texture, used by SDL_RenderCopy(). // Get the blend mode used for texture copy operations. // Set the scale mode used for texture scale operations. // Get the scale mode used for texture scale operations. // Get the user-specified pointer associated with a texture // Update the given texture rectangle with new pixel data. // Update a rectangle within a planar YV12 or IYUV texture with new pixel data. // Update a rectangle within a planar NV12 or NV21 texture with new pixels. // Lock a portion of the texture for **write-only** pixel access. // Lock a portion of the texture for **write-only** pixel access, and expose it as a SDL surface. // Unlock a texture, uploading the changes to video memory, if needed. // Determine whether a renderer supports the use of render targets. // Set whether to force integer scales for resolution-independent rendering. // Get whether integer scales are forced for resolution-independent rendering. // Set the drawing area for rendering on the current target. // Get the drawing area for the current target. // Set the clip rectangle for rendering on the specified target. // Get the clip rectangle for the current target. // Get whether clipping is enabled on the given renderer. // Set the drawing scale for rendering on the current target. // Get the drawing scale for the current target. // Get logical coordinates of point in renderer when given real coordinates of point in window. // Get real coordinates of point in window when given logical coordinates of point in renderer. // Set the color for drawing or filling rectangles, lines, and points, and for SDL_RenderClear(). // Get the color used for drawing operations (Rect, Line and Clear). // Set the blend mode used for drawing operations (Fill and Line). // Get the blend mode used for drawing operations. // Clear the current rendering target with the drawing color. // Draw a series of connected lines on the current rendering target. // Draw some number of rectangles on the current rendering target. // Fill a rectangle on the current rendering target with the drawing color. // Fill some number of rectangles on the current rendering target with the drawing color. // Copy a portion of the texture to the current rendering target. // Copy a portion of the texture to the current rendering, with optional rotation and flipping. // Draw a point on the current rendering target at subpixel precision. // Draw multiple points on the current rendering target at subpixel precision. // Draw a line on the current rendering target at subpixel precision. // Draw a series of connected lines on the current rendering target at subpixel precision. // Draw a rectangle on the current rendering target at subpixel precision. // Draw some number of rectangles on the current rendering target at subpixel precision. // Fill a rectangle on the current rendering target with the drawing color at subpixel precision. // Fill some number of rectangles on the current rendering target with the drawing color at subpixel precision. // Copy a portion of the texture to the current rendering target at subpixel precision. // Copy a portion of the source texture to the current rendering target, with rotation and flipping, at subpixel precision. // Render a list of triangles, optionally using a texture and indices into the vertex array. // Render a list of triangles, optionally using a texture and indices into the vertex arrays. // Read pixels from the current rendering target to an array of pixels. // Update the screen with any rendering performed since the previous call. // Destroy the rendering context for a window and free associated textures. // Force the rendering context to flush any pending commands to the underlying rendering API. // Bind an OpenGL/ES/ES2 texture to the current context. // Unbind an OpenGL/ES/ES2 texture from the current context. // Get the CAMetalLayer associated with the given Metal renderer. // Get the Metal command encoder for the current frame // Toggle VSync of the given renderer. // Get the human readable name of a pixel format. // Convert one of the enumerated pixel formats to a bpp value and RGBA masks. // Convert a bpp value and RGBA masks to an enumerated pixel format. // Create an SDL_PixelFormat structure corresponding to a pixel format. // Create a palette structure with the specified number of color entries. // Map an RGB triple to an opaque pixel value for a given pixel format. // Map an RGBA quadruple to a pixel value for a given pixel format. // Get RGB values from a pixel in the specified format. // Get RGBA values from a pixel in the specified format. // Returns true if the rectangle has no area. // Returns true if the two rectangles are equal. // Calculate the intersection of two rectangles. // Calculate the union of two rectangles. // Calculate the intersection of a rectangle and line segment. // Returns true if the rectangle has no area. // Returns true if the two rectangles are equal, within some given epsilon. // Returns true if the two rectangles are equal, using a default epsilon. // Determine whether two rectangles intersect with float precision. // Calculate the intersection of two rectangles with float precision. // Calculate the union of two rectangles with float precision. // Calculate the intersection of a rectangle and line segment with float precision. // Allocate a new RGB surface with with a specific pixel format and existing pixel data. // Set the palette used by a surface. // Set up a surface for directly accessing the pixels. // Returns whether the surface is RLE enabled // Returns whether the surface has a color key // Get the color key (transparent pixel) for a surface. // Set an additional color value multiplied into blit operations. // Get the additional color value multiplied into blit operations. // Set an additional alpha value used in blit operations. // Get the additional alpha value used in blit operations. // Set the blend mode used for blit operations. // Get the blend mode used for blit operations. // Get the clipping rectangle for a surface. // Creates a new surface identical to the existing surface. // Copy an existing surface to a new surface of the specified format. // Copy an existing surface to a new surface of the specified format enum. // Copy a block of pixels of one format to another format. // Premultiply the alpha on a block of pixels. // Perform a fast fill of a set of rectangles with a specific color. // Perform a fast blit from the source surface to the destination surface. // Perform a fast, low quality, stretch blit between two surfaces of the same format. // Perform bilinear scaling between two surfaces of the same format, 32BPP. // Get the YUV conversion mode, returning the correct mode for the resolution when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC // Get UTF-8 text from the clipboard, which must be freed with SDL_free(). // Query whether the clipboard exists and contains a non-empty text string. // Get UTF-8 text from the primary selection, which must be freed with SDL_free(). // Query whether the primary selection exists and contains a non-empty text string. // Get the address of the `vkGetInstanceProcAddr` function. // Get the names of the Vulkan instance extensions needed to create a surface with SDL_Vulkan_CreateSurface. // Get the size of the window's underlying drawable dimensions in pixels. // Check the event queue for messages and optionally return them. // Check for the existence of a certain event type in the event queue. // Check for the existence of certain event types in the event queue. // Clear events of a specific type from the event queue. // Clear events of a range of types from the event queue. // Wait indefinitely for the next available event. // Wait until the specified timeout (in milliseconds) for the next available event. // Add an event to the event queue. // Set up a filter to process all events before they change internal state and are posted to the internal event queue. // Add a callback to be triggered when an event is added to the event queue. // Run a specific filter function on the current event queue, removing any events for which the filter returns 0. // Set the state of processing events by type. // Allocate a set of user-defined events, and return the beginning event number for that set of events. // Get a snapshot of the current state of the keyboard. // Query the window which currently has keyboard focus. // Clear the state of the keyboard // Get the current key modifier state for the keyboard. // Set the current key modifier state for the keyboard. // Get the key code corresponding to the given scancode according to the current keyboard layout. // Get the scancode corresponding to the given key code according to the current keyboard layout. // Get a human-readable name for a scancode. // Get a scancode from a human-readable name. // Get a human-readable name for a key. // Get a key code from a human-readable name. // Check whether or not Unicode text input events are enabled. // Dismiss the composition window/IME without disabling the subsystem. // Returns if an IME Composite or Candidate window is currently shown. // Set the rectangle used to type Unicode text inputs. // Check whether the platform has screen keyboard support. // Check whether the screen keyboard is shown for given window. // Get the window which currently has mouse focus. // Retrieve the current state of the mouse. // Get the current state of the mouse in relation to the desktop. // Retrieve the relative state of the mouse. // Move the mouse cursor to the given position within the window. // Move the mouse to the given position in global screen space. // Capture the mouse and to track input outside an SDL window. // Create a cursor using the specified bitmap data and mask (in MSB format). // Toggle whether or not the cursor is shown. // Locking for multi-threaded access to the joystick API // Unlocking for multi-threaded access to the joystick API // Count the number of joysticks attached to the system. // Get the implementation dependent name of a joystick. // Get the implementation dependent path of a joystick. // Get the player index of a joystick, or -1 if it's not available This can be called before any joysticks are opened. // Get the implementation-dependent GUID for the joystick at a given device index. // Get the USB vendor ID of a joystick, if available. // Get the USB product ID of a joystick, if available. // Get the product version of a joystick, if available. // Get the type of a joystick, if available. // Get the instance ID of a joystick. // Get the SDL_Joystick associated with an instance id. // Get the SDL_Joystick associated with a player index. // Query whether or not the joystick at a given device index is virtual. // Get the implementation dependent name of a joystick. // Get the implementation dependent path of a joystick. // Get the player index of an opened joystick. // Set the player index of an opened joystick. // Get the implementation-dependent GUID for the joystick. // Get the USB vendor ID of an opened joystick, if available. // Get the USB product ID of an opened joystick, if available. // Get the product version of an opened joystick, if available. // Get the firmware version of an opened joystick, if available. // Get the serial number of an opened joystick, if available. // Get the type of an opened joystick. // Get an ASCII string representation for a given SDL_JoystickGUID. // Get the device information encoded in a SDL_JoystickGUID structure // Get the status of a specified joystick. // Get the instance ID of an opened joystick. // Get the number of general axis controls on a joystick. // Get the number of trackballs on a joystick. // Get the number of POV hats on a joystick. // Get the number of buttons on a joystick. // Update the current state of the open joysticks. // Get the current state of an axis control on a joystick. // Get the initial state of an axis control on a joystick. // Get the current state of a POV hat on a joystick. // Get the ball axis change since the last poll. // Get the current state of a button on a joystick. // Query whether a joystick has an LED. // Query whether a joystick has rumble support on triggers. // Get the battery level of a joystick as SDL_JoystickPowerLevel. // Add support for controllers that SDL is unaware of or to cause an existing controller to have a different binding. // Get the number of mappings installed. // Get the mapping at a particular index. // Get the game controller mapping string for a given GUID. // Get the current mapping of a Game Controller. // Check if the given joystick is supported by the game controller interface. // Get the implementation dependent name for the game controller. // Get the implementation dependent path for the game controller. // Get the type of a game controller. // Get the mapping of a game controller. // Get the SDL_GameController associated with an instance id. // Get the SDL_GameController associated with a player index. // Get the implementation-dependent name for an opened game controller. // Get the implementation-dependent path for an opened game controller. // Get the type of this currently opened controller // Get the player index of an opened game controller. // Set the player index of an opened game controller. // Get the USB vendor ID of an opened controller, if available. // Get the USB product ID of an opened controller, if available. // Get the product version of an opened controller, if available. // Get the firmware version of an opened controller, if available. // Get the serial number of an opened controller, if available. // Check if a controller has been opened and is currently connected. // Get the Joystick ID from a Game Controller. // Manually pump game controller updates if not using the loop. // Convert from an SDL_GameControllerAxis enum to a string. // Get the SDL joystick layer binding for a controller axis mapping. // Query whether a game controller has a given axis. // Get the current state of an axis control on a game controller. // Convert from an SDL_GameControllerButton enum to a string. // Get the SDL joystick layer binding for a controller button mapping. // Query whether a game controller has a given button. // Get the current state of a button on a game controller. // Get the number of touchpads on a game controller. // Get the number of supported simultaneous fingers on a touchpad on a game controller. // Get the current state of a finger on a touchpad on a game controller. // Return whether a game controller has a particular sensor. // Set whether data reporting for a game controller sensor is enabled. // Query whether sensor data reporting is enabled for a game controller. // Get the data rate (number of events per second) of a game controller sensor. // Get the current state of a game controller sensor. // Get the current state of a game controller sensor with the timestamp of the last update. // Query whether a game controller has an LED. // Query whether a game controller has rumble support on triggers. // Return the sfSymbolsName for a given button on a game controller on Apple platforms. // Return the sfSymbolsName for a given axis on a game controller on Apple platforms. // Lock for multi-threaded access to the sensor API // Unlock for multi-threaded access to the sensor API // Count the number of sensors attached to the system right now. // Get the implementation dependent name of a sensor. // Get the type of a sensor. // Get the platform dependent type of a sensor. // Get the instance ID of a sensor. // Return the SDL_Sensor associated with an instance id. // Get the implementation dependent name of a sensor // Get the type of a sensor. // Get the platform dependent type of a sensor. // Get the instance ID of a sensor. // Get the current state of an opened sensor. // Get the current state of an opened sensor with the timestamp of the last update. // Update the current state of the open sensors. // Count the number of haptic devices attached to the system. // Get the implementation dependent name of a haptic device. // Check if the haptic device at the designated index has been opened. // Get the index of a haptic device. // Query whether or not the current mouse has haptic capabilities. // Try to open a haptic device from the current mouse. // Open a haptic device for use from a joystick device. // Get the number of effects a haptic device can store. // Get the number of effects a haptic device can play at the same time. // Get the haptic device's supported features in bitwise manner. // Get the number of haptic axes the device has. // Check to see if an effect is supported by a haptic device. // Create a new haptic effect on a specified device. // Update the properties of an effect. // Run the haptic effect on its associated haptic device. // Stop the haptic effect on its associated haptic device. // Get the status of the current effect on the specified haptic device. // Set the global gain of the specified haptic device. // Set the global autocenter of the device. // Stop all the currently playing effects on a haptic device. // Check whether rumble is supported on a haptic device. // Use this function to get the number of built-in audio drivers. // Use this function to get the name of a built in audio driver. // Use this function to initialize a particular audio driver. // Use this function to shut down audio if you initialized it with SDL_AudioInit(). // Get the name of the current audio driver. // This function is a legacy means of opening the audio device. // Get the number of built-in audio devices. // Get the human-readable name of a specific audio device. // Get the preferred audio format of a specific audio device. // Get the name and preferred format of the default audio device. // This function is a legacy means of querying the audio device. // Use this function to get the current audio state of an audio device. // This function is a legacy means of pausing the audio device. // Use this function to pause and unpause audio playback on a specified device. // Load the audio data of a WAVE file into memory. // Add data to be converted/resampled to the stream. // Get converted/resampled data from the stream // Get the number of converted/resampled bytes available. // Tell the stream that you're done sending data, and anything being buffered should be converted/resampled and made available immediately. // Clear any pending data in the stream without converting it // This function is a legacy means of mixing audio. // Get the number of bytes of still-queued audio. // Drop any queued audio data waiting to be sent to the hardware. // This function is a legacy means of locking the audio device. // Use this function to lock out the audio callback function for a specified device. // This function is a legacy means of unlocking the audio device. // Use this function to unlock the audio callback function for a specified device. // This function is a legacy means of closing the audio device. // Use this function to shut down audio processing and close the audio device. // Get the thread name as it was specified in SDL_CreateThread(). // Get the thread identifier for the current thread. // Get the thread identifier for the specified thread. // Set the priority for the current thread. // Let a thread clean up on exit without intervention. // Get the current thread's value associated with a thread local storage ID. // Set the current thread's value associated with a thread local storage ID. // Cleanup all TLS data for this thread. // Try to lock a mutex without blocking. // Wait until a semaphore has a positive value and then decrements it. // See if a semaphore has a positive value and decrement it if it does. // Wait until a semaphore has a positive value and then decrements it. // Get the current value of a semaphore. // Restart one of the threads that are waiting on the condition variable. // Restart all threads that are waiting on the condition variable. // Wait until a condition variable is signaled or a certain time has passed. // Try to lock a spin lock by setting it to a non-zero value. // Lock a spin lock by setting it to a non-zero value. // Unlock a spin lock by setting it to 0. // Set an atomic variable to a new value if it is currently an old value. // Set an atomic variable to a value. // Get the value of an atomic variable. // Set a pointer to a new value if it is currently an old value. // Get the value of a pointer atomically. // Get the number of milliseconds since SDL library initialization. // Get the number of milliseconds since SDL library initialization. // Get the current value of the high resolution counter. // Get the count per second of the high resolution counter. // Wait a specified number of milliseconds before returning. // Get the directory where the application was run from. // Get the user-and-app-specific path where files can be written. // Use this function to create a new SDL_RWops structure for reading from and/or writing to a named file. // Use this function to create an SDL_RWops structure from a standard I/O file pointer (stdio.h's `FILE*`). // Use this function to prepare a read-write memory buffer for use with SDL_RWops. // Use this function to prepare a read-only memory buffer for use with RWops. // Use this function to allocate an empty, unpopulated SDL_RWops structure. // Use this function to free an SDL_RWops structure allocated by SDL_AllocRW(). // Use this function to get the size of the data stream in an SDL_RWops. // Determine the current read/write offset in an SDL_RWops data stream. // Load all the data from an SDL data stream. // Load all the data from a file path. // Use this function to read a byte from an SDL_RWops. // Use this function to read 16 bits of little-endian data from an SDL_RWops and return in native format. // Use this function to read 16 bits of big-endian data from an SDL_RWops and return in native format. // Use this function to read 32 bits of little-endian data from an SDL_RWops and return in native format. // Use this function to read 32 bits of big-endian data from an SDL_RWops and return in native format. // Use this function to read 64 bits of little-endian data from an SDL_RWops and return in native format. // Use this function to read 64 bits of big-endian data from an SDL_RWops and return in native format. // Use this function to write a byte to an SDL_RWops. // Use this function to write 16 bits in native format to a SDL_RWops as little-endian data. // Use this function to write 16 bits in native format to a SDL_RWops as big-endian data. // Use this function to write 32 bits in native format to a SDL_RWops as little-endian data. // Use this function to write 32 bits in native format to a SDL_RWops as big-endian data. // Use this function to write 64 bits in native format to a SDL_RWops as big-endian data. // Use this function to write 64 bits in native format to a SDL_RWops as little-endian data. // Look up the address of the named function in a shared object. // Get the name of the platform. // Get the number of CPU cores available. // Determine the L1 cache line size of the CPU. // Determine whether the CPU has the RDTSC instruction. // Determine whether the CPU has AltiVec features. // Determine whether the CPU has MMX features. // Determine whether the CPU has 3DNow! features. // Determine whether the CPU has SSE features. // Determine whether the CPU has SSE2 features. // Determine whether the CPU has SSE3 features. // Determine whether the CPU has SSE4.1 features. // Determine whether the CPU has SSE4.2 features. // Determine whether the CPU has AVX features. // Determine whether the CPU has AVX2 features. // Determine whether the CPU has AVX-512F (foundation) features. // Determine whether the CPU has ARM SIMD (ARMv6) features. // Determine whether the CPU has NEON (ARM SIMD) features. // Determine whether the CPU has LSX (LOONGARCH SIMD) features. // Determine whether the CPU has LASX (LOONGARCH SIMD) features. // Get the amount of RAM configured in the system. // Report the alignment this system needs for SIMD allocations. // Byteswap item from the specified endianness to the native endianness if necessary. // Byteswap item from the specified endianness to the native endianness if necessary. // Byteswap item from the specified endianness to the native endianness if necessary. // Byteswap item from the specified endianness to the native endianness if necessary. // Byteswap item from the specified endianness to the native endianness if necessary. // Byteswap item from the specified endianness to the native endianness if necessary. // Byteswap item from the specified endianness to the native endianness if necessary. // Byteswap item from the specified endianness to the native endianness if necessary. // Get the index of the most significant bit. Undefined when called with 0. // Returns true if integer has exactly one bit set. // Set a callback for every Windows message, run before TranslateMessage(). // Get the D3D9 adapter index that matches the specified display index. // Get the D3D9 device associated with a renderer. // Get the D3D11 device associated with a renderer. // Get the D3D12 device associated with a renderer. // Get the DXGI Adapter and Output indices for the specified display index. // Gets a reference to the global async task queue handle for GDK, initializing if needed. // Sets the UNIX nice value for a thread. // Sets the priority (not nice level) and scheduling policy for a thread. // Use this function to set the animation callback on Apple iOS. // Use this function to enable or disable the SDL event pump on Apple iOS. // Used by iOS application delegates to notify SDL about state changes. // Used by iOS application delegates to notify SDL about state changes. // Used by iOS application delegates to notify SDL about state changes. // Used by iOS application delegates to notify SDL about state changes. // Used by iOS application delegates to notify SDL about state changes. // Used by iOS application delegates to notify SDL about state changes. // Used by iOS application delegates to notify SDL about state changes. (*only* iOS) // Get the Android Java Native Interface Environment of the current thread. // Retrieve the Java instance of the Android activity class. // Query if the application is running on Android TV. // Query if the application is running on a Chromebook. // Query if the application is running on a Samsung DeX docking station. // Get the path used for internal storage for this application. // Get the current state of external storage. // Get the path used for external storage for this application. // Detects the device family of WinRT platform at runtime. // Query if the current device is a tablet. // Get the original set of SDL memory functions // Get the current set of SDL memory functions // Get the number of outstanding (unfreed) allocations // This function converts a string between encodings in one pass, returning a string that must be freed with SDL_free() or NULL on error. // If a * b would overflow, return -1. Otherwise store a * b via ret and return 0. // If a + b would overflow, return -1. Otherwise store a + b via ret and return 0."
    },
    {
        "link": "https://stackoverflow.com/questions/75975890/how-to-make-a-switch-case-for-keyboard-input-in-c",
        "document": "I am playing around in C++ and currently have this \"if\" hell:\n\nHow do I make it so that it uses a switch case?\n\nI tried making keyboard input for my game. Well, everything works correctly, but it looks ugly."
    },
    {
        "link": "https://stackoverflow.com/questions/70009280/switch-statement-and-user-input-in-c",
        "document": "According to the C++ 17 Standard (9.4.2 The switch statement)\n\n2 The condition shall be of integral type, enumeration type, or class type. If of class type, the condition is contextually implicitly converted (Clause 7) to an integral or enumeration type. If the (possibly converted) type is subject to integral promotions (7.6), the condition is converted to the promoted type. Any statement within the switch statement can be labeled with one or more case labels as follows: case constant-expression : where the constant-expression shall be a converted constant expression (8.20) of the adjusted type of the switch condition. No two of the case constants in the same switch shall have the same value after conversion.\n\nThe class does not have an implicit conversion operator that converts an object of the type to an integral or enumeration type.\n\nSo the expression in this switch statement\n\nAlso case labels like this\n\nYou could resolve your problem with the switch statement for example the following way"
    },
    {
        "link": "https://geeksforgeeks.org/switch-statement-in-cpp",
        "document": "In C++, the switch statement is a flow control statement that is used to execute the different blocks of statements based on the value of the given expression. It is an alternative to the long if-else-if ladder which provides an easy way to execute different parts of code based on the value of the expression.\n\nLet’s take a look at an example:\n\nExplanation: In the above program, the switch statement evaluates the value of x and executes the matching case. If x is ‘A’, it prints “A”; if ‘B’, it prints “B”. The default case handles other values.\n\nSyntax of switch Statement in C++\n• default case is executed if none of the cases are matched.\n• break keyword in each case is used to break out of the switch statement after the matching case is found. Otherwise, all the statements after the matching case will be executed.\n\nRules of the switch Statement in C++\n\nThere are some rules that we need to follow when using switch statements in C++. They are as follows:\n• None The case value must be either int or char type.\n• None There can be any number of cases.\n• None Each statement of the case can have a break statement. It is optional.\n• None The default Statement is also optional.\n\nFlowchart of Switch Statement in C++\n\nWorking of switch Statement in C++\n\nThe working of the switch statement in C is as follows:\n• Step 2: The evaluated value is then matched against the present case values.\n• Step 3A: If the matching case value is found, that case block is executed.\n• Step 3B: If the matching code is not found, then the default case block is executed if present.\n• Step 4A: If the break keyword is present in the block, then program control comes out of the switch statement.\n• Step 4B: If the break keyword is not present, then all the cases after the matching case are executed.\n• Step 5: Statements after the switch statement is executed.\n\nThe below program demonstrates the uses of switch statement in C++ programs:\n\nAs we can see, if break is not used, every case after the matched case is executed.\n\nPrint the Day Name Using Day Number\n\nIf the expression provided in the switch statement does not result in a constant value, it would not be valid. Some valid expressions for switch case will be,\n\n2. Expression must evaluate only int or char type values.\n\nThe switch statement can only evaluate the integer or character value. So, the switch expression should return the values of type int or char only.\n\nThe break keyword is used in the switch case to break out of the switch when encountered. It is used at the end of every case block so that when the matching case is executed, the program control comes out of the loop.\n\nThe break statement is optional. If omitted, all the cases after the matching case will also be executed.\n\nThe default keyword is used to define a default case which will be executed when no case value is matched. It is also an optional statement, and the switch case statement runs without problem if it is omitted.\n\nIn the C switch statement, duplicate case values are not allowed. All the case values must be unique.\n\nIn C++, we can nest one switch inside another switch statement without any problem. Though it is avoided most of the time as it makes the program more complex and unreadable.\n\n7. Position of Default Case Does Not Matters\n\nRegardless of its placement, the default case only gets executed if none of the other case conditions are met. So, putting it at the beginning, middle, or end doesn’t change the core logic (unless you’re using a less common technique called fall-through).\n\n8. Differences between switch and if else if ladder in C?\n\nFollowing are the main differences between switch and if else if ladder in C++:"
    },
    {
        "link": "https://quora.com/What-is-the-most-efficient-way-to-code-a-switch-case-statement",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://cplusplus.com/forum/beginner/139288",
        "document": "They seem like they are the same and can both be used for the same program so my question is is there any situation were you may need to use one over the other or does it not matter?\n\nI've never really seen a huge difference but then again I've always just used if else statements. I'm a novice though as well. Maybe a pro can come in here and clear some stuff up for us :P\n\nIf you have a menu or something similar where the user has to select a key; a for something, b for another, etc. a switch will almost always be better. A switch is limited in that it can only take an int or char as an argument though so you cannot use strings or other arguments as the argument for example. \n\n is not valid while is.\n\nGenerally you would use switch if there are more than two cases, and you're checking the value of one variable. If-else in most other situations. A lot of people think switch is bad practice though, since you could omit a break statement and mess up the whole purpose.\n\n--There is no significant execution / performance difference between if-else and switch. The difference observed is due to the sample space chosen.\n\n -- If using if-else, its always recommended to put frequently used if condition at the top of if-else ladder\n\n \n\n Nevertheless, i prefer switch for its readability.\n\n\n\n\n\n However, change the type of input from char to string like this and it will not compile: because the quantity used the the switch must be an integer. Also it is not possible to test several different variables in a single switch statement, which indeed is possible in some other languages. \n\n \n\n The switch-case in C++ is quite limited. It does one thing, it does it reasonable well, I tend to use it where it will add to the legibility, though that may sometimes be a matter of preference. Sometimes it's not possible to use switch-case. This is ok:However, change the type of input from char to string like this and it will not compile:because the quantity used the the switch must be an integer. Also it is not possible to test several different variables in a single switch statement, which indeed is possible in some other languages.The switch-case in C++ is quite limited. It does one thing, it does it reasonable well, I tend to use it where it will add to the legibility, though that may sometimes be a matter of preference.\n\nI don't know of anyone who recommends switch as bad practice.\n\n \n\n The switch statement is a specialization of a common case if..else chain: comparing a single ordinal value against a finite list of values. Many CPUs provide instructions to do just this (string search instructions), which translates into a convenient jump table.\n\n \n\n Modern compilers can recognize this optimization in an equivalent if..else chain so these days the code produced is equivalent.\n\n \n\n The automatic drop-through is ridiculed (and rightly so), but unless you are a language designer it really makes no difference."
    }
]