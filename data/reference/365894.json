[
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/blueprint-variables-in-unreal-engine",
        "document": "Variables are displayed as rounded boxes that contain the name of the variable:\n\nVariables can be created in a variety of different types, including data types - such as Boolean, integer, and float - as well as reference types for holding things like Objects, Actors, and particular Classes. Arrays of each variable type can also be created. Each type is color coded for easy identification:\n\nVariables in the My Blueprint Tab\n\nTo allow a variable to be modified from outside its Blueprint, make it public. By default the eye is closed (private); select the eye to open it and make it public. You can also select or clear the Instance Editable box to make the variable private or public. After you've made the variable public, you can modify its value from the Details panel of the Main Editor window. Above, the variable LightColor has been set to Editable and we can now set this value in the Details panel of the Level Editor.\n\nYou can also add a Tooltip for your variables that will appear when mousing over the variable in the editor.\n\nYou can add the Tooltip from the Details panel of the variable. When doing so, if the variable is set to Public, the Eye Icon will change from yellow to green indicating that a Tooltip has been written for the variable.\n\nExpose on Spawn enables you to set if the variable should be accessible at the time of spawning the Blueprint it sits in.\n\nAbove we have a variable called LightColor which is a Linear Color property that is set to Expose on Spawn. This variable is implemented in a Blueprint for a Point Light that uses the Set Light Color node and the LightColor variable to determine the color the light should be.\n\nBelow, inside a different Blueprint, a script is used to spawn the Point Light Blueprint and since the LightColor variable was set to Expose on Spawn, the option to set the value is made available on the Spawn Actor from Class node, allowing us to set its color when the light spawns in the game world.\n\nWith the Private option checked on a variable, this prevents the variable from being modified from external Blueprints.\n\nFor example, we have a variable below that is not set to private:\n\nInside another Blueprint, we spawn the Blueprint that contains the variable, then off the Return Value we can access our variable.\n\nIf we were to set it Private however:\n\nAnd spawn the Blueprint again and try to access that variable, we cannot.\n\nIf you want the value of your variable to be affected by Sequencer, select Expose to Cinematics.\n\nWhen working with variables in Blueprints, you will access them in one of two ways: by using the Get node (referred to as a Getter) to get the value of the variable or by using the Set node (referred to as a Setter) to set the value of the variable.\n\nYou can create a Set node (1 above) or Get node (2 above) for a variable by right-clicking in the graph and typing either Set (variable name) or Get (variable name). Another method you can use is to hold down the Ctrl key and drag in the variable from the MyBlueprint window to create a Get node or hold down the Alt key and drag in the variable from MyBlueprint window to create a Set node.\n\nVariable values can be set either as a part of the Blueprint node network or as a default value prior to execution. To set variable default values:\n• Click Class Defaults on the Blueprint Editor Toolbar to open the Defaults in the Details panel.\n• In the Details panel, enter the desired default values to the right of your variable name. Above, we highlight our Color variable in which we can set its default color.\n• Right-click the variable name in the My Blueprint tab and select Rename in the menu that appears.\n• Type the new variable name in the text box and then press Enter.\n\nYou can set all the properties for a variable in the Details panel. Some variables may have more properties than those shown here, such as Expose to Cinematics for Vectors or a Slider Range for numeric variables like Integers or Floats.\n\nVariables can also be edited as a part of your Blueprint network by way of Get and Set nodes. The easiest way to create these is by dragging a variable from the Variables tab directly into the Event Graph. A small menu will appear asking if you would like to create a Get or Set node.\n\nGet nodes supply portions of the network with a variable value. Once created, these nodes can be plugged into any node that takes the appropriate type.\n\nSet nodes enable you to change the value of a variable. Note that these must be called by an execution wire in order to execute."
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/quick-start-guide-to-variables-timers-and-events-in-unreal-engine-cpp",
        "document": "This tutorial will show you how to expose variables and functions to the editor, use timers to delay or repeat code execution, and use events to communicate between Actors.\n\n1. Creating an Actor that Uses a Timer\n• We will begin by creating a new, Basic Code project, with starter content, named HowTo_VTE, and then adding an Actor class to it. We'll name it Countdown in this tutorial.\n• We'll start by creating a simple countdown timer that we can see in-game. In Countdown.h, add the following lines to the end of our class definition:\n• In Countdown.cpp, we can create our renderable text Component and initialize our countdown time to 3 seconds. We can also turn Ticking off for this type of Actor, since we will not need it. To do this, we must add the header for the Component at the top of the file, making the \"include\" section look like this: With the header included, we can write . It should look like this: ACountdown::ACountdown() { // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it. PrimaryActorTick.bCanEverTick = false; CountdownText = CreateDefaultSubobject<UTextRenderComponent>(TEXT(\"CountdownNumber\")); CountdownText->SetHorizontalAlignment(EHTA_Center); CountdownText->SetWorldSize(150.0f); RootComponent = CountdownText; CountdownTime = 3; } ACountdown::ACountdown() { // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it. PrimaryActorTick.bCanEverTick = false; CountdownText = CreateDefaultSubobject<UTextRenderComponent>(TEXT(\"CountdownNumber\")); CountdownText->SetHorizontalAlignment(EHTA_Center); CountdownText->SetWorldSize(150.0f); RootComponent = CountdownText; CountdownTime = 3; }\n• should update our text display to show the time remaining, or zero if the time is up. This code should run when we first spawn our into the game, and once per second until our variable hits zero.\n• Whenever we assign a Timer to run a function, we are given a Timer Handle. We need to hold onto that handle so that we can shut the Timer down when the countdown finishes. Let's add the function to count time down, and the Timer Handle we'll need to control it, to the class definition in . While we're there, let's also add a function to do something special when the countdown ends: We can also write the body of and in now: void ACountdown::AdvanceTimer() { --CountdownTime; UpdateTimerDisplay(); if (CountdownTime < 1) { //We're done counting down, so stop running the timer. GetWorldTimerManager().ClearTimer(CountdownTimerHandle); CountdownHasFinished(); } } void ACountdown::CountdownHasFinished() { //Change to a special readout CountdownText->SetText(TEXT(\"GO!\")); } void ACountdown::AdvanceTimer() { --CountdownTime; UpdateTimerDisplay(); if (CountdownTime < 1) { //We're done counting down, so stop running the timer. GetWorldTimerManager().ClearTimer(CountdownTimerHandle); CountdownHasFinished(); } } void ACountdown::CountdownHasFinished() { //Change to a special readout CountdownText->SetText(TEXT(\"GO!\")); }\n• Let's initialize the text display in by adding a call to our new update function, and setting a timer to advance and update the countdown once per second: We are updating the display in rather than because values set to variables in the Unreal Editor will be assigned after the constructor, but before BeginPlay. We will want to respect those values later, when we expose to the editor.\n• Let's check our progress so far by going to the Unreal Editor and pressing Compile. We can then drop our updated class from the Content Browser into the Level Editor. Because we set our countdown text during and not , the default Text is shown in the Level Editor. When we press Play, the countdown will progress as expected, saying 3, 2, 1, and finally GO!\n\nAt this point, we've already created a simple class that uses a timer. Non-programming users would get much more out of it if they could set the countdown time, or change the behavior when the countdown finishes. Next, we'll expose these features to the editor.\n\n2. Exposing Variables and Functions to the Editor\n• Our countdown timer is currently hard-coded to use a value of 3 seconds. It would be more useful if we could set the countdown time to any value we want in the editor, and this is easy to do. In Visual Studio, we can open and find the line that says: In order to expose this variable to Unreal Engine, we need to make it a . This enables the engine to preserve the value of the variable when launching the game or loading a saved level. The tag, with empty parentheses, is added right above the variable it affects: supports arguments that change how Unreal Engine will use the variable. Since we want our variable to be editable, we can add the argument: We can also add a comment to our variable in C++, and our comment will become the description of the variable in the Unreal Editor, like this: //How long, in seconds, the countdown will run UPROPERTY(EditAnywhere) int32 CountdownTime; //How long, in seconds, the countdown will run UPROPERTY(EditAnywhere) int32 CountdownTime; There is a lot more we can do with , and looking into other Specifiers such as and might be good next steps, but we have all that we need at the moment. When we return to the Unreal Editor and press Compile, our variable will appear in the Details Panel for the we placed earlier, and we can test out different timer values by changing this number and pressing Play.\n• In addition to changing the value of the timer, let's also enable non-programming developers to change what happens when the timer is up. In Visual Studio, we'll open Countdown.h and find the following line: We can expose this function to the Unreal Engine by making it a , like this: Just like the macro, we need to provide information about what can be done with it in order to enable more features and access for non-programming developers. There are three options to consider:\n• functions are written in C++ and can be called from the Blueprint Graph, but cannot be changed or overridden without editing C++ code. Functions marked this way are usually features that have been programmed for non-programmer use, but that are not supposed to be changed or wouldn't make sense to change. An easy example of this would be any kind of math function.\n• functions are set up in a C++ header (.h) file, but the body of the function is written entirely in the Blueprint Graph, not in C++. These are usually created to give a non-programmer the ability to create custom reactions to special situations that have no expected default action or standard behavior. An example of this might be an event that happens when a powerup touches the player's ship in a spaceship game.\n• functions are like a combination of and functions. They have default behaviors programmed in C++, but these can be supplemented or replaced by overriding in the Blueprint Graph. When programming these, the C++ code always goes in a virtual function with _Implementation added to the end of the name, as shown below. This is the most flexible option, so we will use it for this tutorial. To grant non-programmers the ability to call our C++ function and to override it with Blueprints, we need to make the following changes to : Then, in Countdown.cpp, we will need to change the line that says:\n\nWe have now made a variable and a function accessible to, and alterable by, non-programmers, while providing our own default value and functionality in C++. To see how a non-programmer might use this, we'll make a Blueprint extension of our class and modify it ourselves.\n\n3. Extend and Override C++ with Blueprints\n• To change the behavior of our ACountdown instance, called Countdown1, in the editor, we must first make an editable Blueprint version of it. To do this, we can select it from the World Outliner and click the Blueprint/Add Script button in the Details Panel. From there, we can provide a path and name for the Blueprint asset that will contain our modified ACountdown class. This will create a new asset that represents a Blueprint version of Countdown1. It will also replace Countdown1 with an instance of this new Blueprint, so that changes we make to the Blueprint will affect Countdown1 in the game.\n• The Unreal Editor will automatically take us to our new asset in the Content Browser, and we can Right-click it and choose \"Edit...\" to modify its Blueprint Graph, Component hierarchy, and Default Values.\n• Functions and events can be found in the Event Graph tab, so we'll select that first. Then, by Right-clicking anywhere in the Event Graph window, we can add our CountdownHasFinished function as an event node to define its behavior.\n• We can now add any additional functionality we would like by left-clicking and dragging off of the white (execution) pin on the right side of our new node. When we release the left mouse button, we will be asked what function or event we would like to execute. For this tutorial, let's spawn a Particle System when the countdown finishes. We'll want a Spawn Emitter At Location node, so select that from the list. It can save time to type a partial phrase, like spawn loc, into the search field. We can then left-click and drag the yellow \"Location\" pin and attach it to a Get Actor Location function. Now we just need to select what effect we'd like to see. By clicking Select Asset under Emitter Template, we can get a list of appropriate effect assets. P_Explosion is a good one, so we'll pick that.\n• Click the Compile button at the top left of the Blueprint Editor to save the changes.\n• If we press Play now, we'll see our countdown take place, and our explosion will happen when our countdown number hits zero. However, we programmed our countdown to say GO! at the end, not 0. This is no longer happening because we have completely replaced our C++ functionality with our Blueprint visual scripting. This is not what we intended to do in this case, so we need to add a call to the C++ version of this function, which can be done by right-clicking the Countdown Has Finished node and selecting Add call to parent function from the context menu. When this is done, a node labeled Parent: Countdown Has Finished will be placed in the Event Graph. The typical place to connect a parent node is directly to the event node, which is what we will do here. This is not required, though, as the parent-call node is like any other and can be called anywhere we like, even multiple times. Note that this will replace the connection to Spawn Emitter At Location, so we'll need to connect our **Parent: programming-and-scripting/programming-language-implementation/cpp-in-unreal-engine/unreal-engine-cpp-tutorials Now when we run our game, we should see both the word GO! (from our C++ code) and an explosion (from our Blueprint Graph) after the countdown finishes!\n\n4. On Your Own!\n\nUsing what you have learned, try to do the following:\n• Create an Actor that moves or rotates to a target transform when an Event is run. This could be used as a moving platform or door in a game. Make the Event start a Timer that will trigger a second Event which moves the Actor back to its original location. Use exposed variables (that is, exposed through ) instead of hard-coded values wherever appropriate.\n• Make a lit torch that burns out (perhaps by deactivating a fiery Particle System Component) by using a Timer handle and a few custom Events. For example, an AddFuel Event could extend the burning time of the torch. A DouseWithWater Event could shut it off immediately and prevent AddFuel from working in the future. Both of these features can be written without using a Tick, simply by modifying a running Timer through its handle.\n\nAs for the specifics covered in this tutorial:\n• For more information about Timers, try the Gameplay Timers page.\n• For a complete reference using the tag with variables in your classes or structs, look at the %programming-and-scripting/programming-language-implementation/unreal-engine-reflection-system/Properties:title% page.\n• To learn more about and Event creation, check the %programming-and-scripting/programming-language-implementation/unreal-engine-reflection-system/Functions:title% page.\n• For further tutorials, see the %programming-and-scripting/programming-language-implementation/cpp-in-unreal-engine/tutorials:title% page."
    },
    {
        "link": "https://forums.unrealengine.com/t/a-clean-way-to-initialize-the-variables-of-an-instantiated-object-at-the-start-of-a-level/580040",
        "document": "Hi, I am quite new with blueprints and Unreal Engine in general. I am working on an RTS game a bit similar in the concept to Battlefleet : Gothic Armada and am wondering what the best practice is to setup objects at the start of a level.\n\nMore specifically : I have a structure “struct_teams” which contains all the information about the different teams and that also has an array of arrays. Each sub array of struct_teams lists all the units controlled by a given team. I have anotherblueprint bp_spawner that spawns new units in the desired location (spawning position) and associates the spawns units with the team that owns the spawning point by adding them to the related team array.\n\nI am trying to make this clean and modular so that I can use it in every level of the game and build good Unreal development habits. At the moment : I instantiate the spawner objects variables of my level from the BeginPlay event of the level blueprint. I looked into doing it in the construction script of my blueprint but to do so, the way I found was to reference the level variables in the spawner blueprint and it doesn’t allow giving specific team values to the different spawners. Is there a cleaner way to do it than what I am doing ?\n\nSince the levels will be procedurally generated, making the instances publicly editable doesn’t seem to be an option, unless I am missing something ?\n\nThanks in advance for any feedback"
    },
    {
        "link": "https://reddit.com/r/unrealengine/comments/13g97mi/newer_to_programmingblueprinting_in_ue5_and",
        "document": "I feel kind of silly for asking this as it seems like a basic tool that probably has a big purpose, but the tutorials I've been following haven't really explained what it's really used for, unless they did and I'm just missing the point. So, I guess what I'm wondering is, when someone is making a game, what is something they may add to their game that requires the use of the construction script that they can't create within a function or an event?\n\nMy knowledge to the construction script is limited currently. The tutorial I followed simply had me do things like setting the color and intensity of a light, and then exposing those details to the viewport details panel. That's all fine, but I've started wondering what the purpose of doing that within the construction script is? If I was going to have a light randomly change colors during simulation/gameplay (which was ultimately what we ended up doing), then I can just set the light to have a specific color by default."
    },
    {
        "link": "https://forums.unrealengine.com/t/game-instance-subsystem-not-initialized-during-gameinstance-event-init/1257768",
        "document": "I’ve been trying to write a plugin that handles communication with a server. It does so using a GameInstance subsystem. I got everything working, but then I started wondering if I could make the most used function static, so I don’t always have to include the Subsystem node when calling it in blueprints.\n\nTo get access to my subsystem’s variables when calling the static function, I call GetSubsystem() and this works. except it throws an error when calling it in the Event Init of the Game Instance. The GetSubsystem call returns null here causing the code to fail.\n\nAccording to documentation, Game Instance subsystems are initialized as the Game Instance itself is initialized but I would expect this to be done before calling the blueprint’s Event Init.\n\nMy question is whether it’s normal practice to try and get my variables in this way (I originally tried using static variables but I was getting Unresolved External Symbol errors when I did that) or how else I should go about using the subsystem’s variables in the static method. And if there is a way to force the initialization of the subsystem before the Game Instance’s Event Init runs."
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Engine/Kismet/UKismetSystemLibrary/Delay",
        "document": "Perform a latent action with a delay (specified in seconds). Calling again while it is counting down will be ignored."
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Engine/Kismet",
        "document": ""
    },
    {
        "link": "https://forums.unrealengine.com/t/why-cant-we-use-delay-from-kismetsystemlibrary-in-c-whats-the-mistery-behind-it/49966",
        "document": "I need to make a costum wait in my behavior tree depending on what attack my bot will do, or in death i need to know if some event could happen and 4 days ago i´ve started to search for a latent fuction like delay in BP, but for some reason all the posts in forums or questions in anwswershub tell that we can´t and should never use the delay function.\n\n That’s really wierd since we can call it from the kismetSystemLibrary, and use it in BP, i’ve tried to setup the FLatenActionInfo, but that doesnt seem to work in c++.\n\n First question, is there a way to use that fuction in c++?\n\n If yes, can someone post a simple exemple?\n\n If not, why not, what´s the reason behind it?\n\n And finally, how can i do a latent fuction? If anybody knows how to do it, please post a simple exemple, please… \n\n My exemple, that does not work. My exemple, that does not work.\n\nYou’re supposed to use Timers in C++. IIRC you can’t use it because the Kismet library is MINIMAL_API, so it’s functions aren’t exported. Delays aren’t really as efficient/manageable anyway.\n\nYou’re supposed to use Timers in C++. IIRC you can’t use it because the Kismet library is MINIMAL_API, so it’s functions aren’t exported. Delays aren’t really as efficient/manageable anyway. But its possible to use a fuction like printString(i´ve tested an it works) from that library, but not delay… Ok, so all the libraries that are MINIMAL_API, are limited in c++, and some functions simple can not be used in c++, is that right? I need to create a latent function because in this case (And other cases in my AI bot): I need to be able to say how much time it will take to do the next thing in the behavior tree. How can i setup a latent function (a simple exemple will really help me out)?\n\n PS I know how to setup timers, but they dont work in that case.\n\nThere is already a built-in behavior tree task for what you want. I know that there is a wait node, but you can not change the value of that node within a running game.\n\n In this image that i´ve uploaded, you can see that i´ve made a costum wait, that changes its value with the needed time within other functions in other blueprint, i want to be able to do that in c++, cause i cannot show that gamelogic in blueprint in my final presentation to my teacher.\n\n If anyone knows how to do a latent function, please show a little exemple.\n\nThere is no delay in C++??? there should be an alternative… In any case you can well if is homework I cant say more than this… hint: tick thought dont know if that solves the problem of “not having delay”.\n\nThere is no delay in C++??? there should be an alternative… In any case you can well if is homework I cant say more than this… hint: tick thought dont know if that solves the problem of “not having delay”. Unhappely theres not a solution since bttask dont have a tick fuction.\n\n It would be really nice if Epic staff could do a tutorial on how to do a costum delay function that does work with c++.\n\nUnhappely theres not a solution since bttask dont have a tick fuction.\n\n It would be really nice if Epic staff could do a tutorial on how to do a costum delay function that does work with c++. BT Tasks do have a tick, its just not called Tick. I believe its called TickTask? You can see the overrides in a blueprint task and just add the correct one. ExecuteTask starts a Task, TickTask updates it, AbortTask ends it prematurely (or Tick returns a fail/success result). Have a look at BTTask_MoveTo.h as an example in /Source/Runtime/AIModule/BehaviorTree/Tasks/ for the C++ versions."
    },
    {
        "link": "https://github.com/MrRobinOfficial/Guide-UnrealEngine",
        "document": "You can’t perform that action at this time."
    },
    {
        "link": "https://forums.unrealengine.com/t/is-it-okay-to-use-the-kismetlibrary-functions-inside-of-c/33857",
        "document": "I want to know if it is okay to call KismetLibrary functions from C++? Say I do the following:\n\nI know it can be called, but are there any drawbacks for doing it? I can also just go to the function and copy it and create my own, but would there be any performance hits if I just imported the library and used whatever function I wanted?"
    }
]