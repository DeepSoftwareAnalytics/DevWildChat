[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch",
        "document": "The Fetch API provides a JavaScript interface for making HTTP requests and processing the responses. Fetch is the modern replacement for : unlike , which uses callbacks, Fetch is promise-based and is integrated with features of the modern web such as service workers and Cross-Origin Resource Sharing (CORS). With the Fetch API, you make a request by calling , which is available as a global function in both and contexts. You pass it a object or a string containing the URL to fetch, along with an optional argument to configure the request. The function returns a which is fulfilled with a object representing the server's response. You can then check the request status and extract the body of the response in various formats, including text and JSON, by calling the appropriate method on the response. Here's a minimal function that uses to retrieve some JSON data from a server: async function getData() { const url = \"https://example.org/products.json\"; try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const json = await response.json(); console.log(json); } catch (error) { console.error(error.message); } } We declare a string containing the URL and then call , passing the URL with no extra options. The function will reject the promise on some errors, but not if the server responds with an error status like : so we also check the response status and throw if it is not OK. Otherwise, we fetch the response body content as JSON by calling the method of , and log one of its values. Note that like itself, is asynchronous, as are all the other methods to access the response body content. In the rest of this page we'll look in more detail at the different stages of this process.\n\nThe request body is the payload of the request: it's the thing the client is sending to the server. You cannot include a body with requests, but it's useful for requests that send content to the server, such as or requests. For example, if you want to upload a file to the server, you might make a request and include the file as the request body. To set a request body, pass it as the option: You can supply the body as an instance of any of the following types: Other objects are converted to strings using their method. For example, you can use a object to encode form data (see setting headers for more information): const response = await fetch(\"https://example.org/post\", { method: \"POST\", headers: { \"Content-Type\": \"application/x-www-form-urlencoded\", }, // Automatically converted to \"username=example&password=password\" body: new URLSearchParams({ username: \"example\", password: \"password\" }), // ... }); Note that just like response bodies, request bodies are streams, and making the request reads the stream, so if a request contains a body, you can't make it twice: const request = new Request(\"https://example.org/post\", { method: \"POST\", body: JSON.stringify({ username: \"example\" }), }); const response1 = await fetch(request); console.log(response1.status); // Will throw: \"Body has already been consumed.\" const response2 = await fetch(request); console.log(response2.status); Instead, you would need to create a clone of the request before sending it: See Locked and disturbed streams for more information.\n\nCredentials are cookies, TLS client certificates, or authentication headers containing a username and password. To control whether or not the browser sends credentials, as well as whether the browser respects any response headers, set the option, which can take one of the following three values:\n• : never send credentials in the request or include credentials in the response.\n• (the default): only send and include credentials for same-origin requests. Note that if a cookie's attribute is set to or , then the cookie will not be sent cross-site, even if is set to . Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if is set to , the server must also agree to their inclusion by including the header in its response. Additionally, in this situation the server must explicitly specify the client's origin in the response header (that is, is not allowed). This means that if is set to and the request is cross-origin, then:\n• If the request is a simple request, then the request will be sent with credentials, but the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the response, including credentials, will be delivered to the caller.\n• If the request is not a simple request, then the browser will send a preflighted request without credentials, and the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the browser will follow up with the real request, including credentials, and will deliver the real response, including credentials, to the caller.\n\nRequest and response bodies are actually objects, and whenever you read them, you're streaming the content. This is good for memory efficiency, because the browser doesn't have to buffer the entire response in memory before the caller retrieves it using a method like . This also means that the caller can process the content incrementally as it is received. For example, consider a request that fetches a large text file and processes it in some way, or displays it to the user: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchText(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const text = await response.text(); console.log(text); } catch (e) { console.error(e); } } If we use , as above, we must wait until the whole file has been received before we can process any of it. If we stream the response instead, we can process chunks of the body as they are received from the network: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchTextAsStream(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const stream = response.body.pipeThrough(new TextDecoderStream()); for await (const value of stream) { console.log(value); } } catch (e) { console.error(e); } } In this example, we iterate asynchronously over the stream, processing each chunk as it arrives. Note that when you access the body directly like this, you get the raw bytes of the response and must transform it yourself. In this case we call to pipe the response through a , which decodes the UTF-8-encoded body data as text."
    },
    {
        "link": "https://topcoder.com/thrive/articles/fetch-api-javascript-how-to-make-get-and-post-requests",
        "document": ""
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API",
        "document": "The Fetch API uses and objects (and other things involved with network requests), as well as related concepts such as CORS and the HTTP Origin header semantics.\n\nFor making a request and fetching a resource, use the method. It is a global method in both and contexts. This makes it available in pretty much any context you might want to fetch resources in.\n\nThe method takes one mandatory argument, the path to the resource you want to fetch. It returns a that resolves to the to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. You can also optionally pass in an options object as the second argument (see ).\n\nOnce a is retrieved, there are a number of methods available to define what the body content is and how it should be handled.\n\nYou can create a request and response directly using the and constructors, but it's uncommon to do this directly. Instead, these are more likely to be created as results of other API actions (for example, from service workers).\n\nFind out more about using the Fetch API features in Using Fetch."
    },
    {
        "link": "https://stackoverflow.com/questions/46905051/fetch-api-post-request-response",
        "document": "I am trying to get output from the post request once the form has been submitted but I get a promise response rather than the actual data when posting the form\n\nThe data gets passed to the backend however I want to return the data thats been outputted by the API server."
    },
    {
        "link": "https://brightdata.com/blog/how-tos/fetch-api-nodejs",
        "document": "The Fetch API represents the new officially supported way to perform HTTP requests and retrieve local resources in Node.js. This means that you no longer need external HTTP client dependencies in your project. All you have to do is learn how to use the Node Fetch API, which is what this guide is all about.\n\nHere, you will see:\n• What is the Fetch API\n• Making HTTP requests in Node.js with the Fetch API\n\nWhat Is the Fetch API?\n\nThe Fetch API is a JavaScript interface for fetching resources locally or over a network. In detail, it provides a global fetch() function that makes it easier to perform asynchronous HTTP requests. The same method can also be used to retrieve local files. The JavaScript Fetch API is a flexible replacement for the legacy XMLHttpRequest API.\n\nThe fetch() method is based on the Request and Response objects. It requires only one mandatory argument, the local path or URL to the resource you want to fetch. Then, it also accepts some optional options, including CORS, HTTP header, and caching settings. As an asynchronous method, fetch() returns a Promise that resolves the response produced by the server. This is represented by a Response object, which exposes several methods to access and parse its content body.\n\nThis is what a basic Fetch API call looks like:\n\nThe Fetch API has been supported by major browsers for years. Yet, it has only been part of the standard Node.js library since version 18.0.0, released in April 2022. Specifically, the Node Fetch API is based on undici’s implementation.\n\nBefore Node.js 18, you could use fetch() by enabling it as an experimental feature or thanks to the node-fetch npm library, another popular Fetch API implementation. Since fetch() is now part of the official Node.js standard library, you can use it directly in your code without importing it. All you have to do is call the fetch() method with the syntax below:\n\nurl is mandatory and can contain:\n• The URL to a remote endpoint or resource (e.g., https://httpbin.io/ip or https://example.com/movies.json)\n\noptions is instead an optional object that accepts the following optional fields:\n• method: The HTTP method of the request, such as “GET”, “POST”, “PUT”, “PATCH”, and “DELETE”. The default is “GET”.\n• headers: A Headers or object literal containing the HTTP headers to add to your request. By default, no header is set.\n• body: The object containing the data to use as the body of your request. Note that GET and HEAD requests cannot have a body.\n• mode: The mode to use for the request (e.g., “cors”, “no-cors”, “same-origin”, “navigate”, or “websocket”). By default, it is set to cors.\n• credentials: To specify whether the browser should send the credentials or not. It must be one of the following strings: “omit”, “same-origin”, or “include”.\n• redirect: To determine how to handle an HTTP redirect response. It can be “follow”, “error”, or “manual”. By default, it is set to “follow”.\n• referrer: A string containing the referrer of the request. By default, it is an empty string.\n• referrerPolicy: Specifies the referrer policy to use for the request.\n• signal: An AbortSignal object instance that allows you to abort the request via the AbortController interface.\n• priority: A string that specifies the priority of the current Fetch request relative to other requests of the same type. It accepts “high”, “low”, or “auto”. By default, it is “auto”.\n\nCheck out the fetch() parameters section from the official documentation to learn more.\n\nThis is an example of a Node.js Fetch request with an options object:\n\nNote that the body data must match the Content-Type header.\n\nMaking HTTP Requests in Node.js With the Fetch API\n\nLet’s now see the Node Fetch API in action in real-world request examples for the most popular HTTP methods.\n\nThis is how you can perform a GET request with the Fetch API:\n\nAs you can see, it takes only one line of code. That is because fetch() performs GET requests by default.\n\nThen, you can access the response content with one of the methods below:\n• response.text(): Returns a Promise that resolves with the response body as text.\n• response.json(): Returns a Promise that resolves with an object parsed from the JSON response.\n• response.blob(): Returns a Promise that resolves with the response body as a Blob object.\n• response.arrayBuffer(): Returns a Promise that resolves with the response body as an ArrayBuffer instance.\n• response.formData(): Returns a promise that resolves with the response body as a FormData object.\n\nSo, the code of a complete example would be:\n\nIf the response returned by the server is not in JSON format, the response.json() instruction will fail with a SyntaxError.\n\nMaking a POST request with a Node Fetch API call only takes a few lines:\n\nThe key to sending a POST request with fetch() is to specify data to send to the server in the body option. This can be in several formats, including JSON, FormData, and text. When sending a FormData object, you do not need to specify a Content-Type header. Otherwise, it is mandatory.\n\nPerforming a PUT request with the Fetch API is just like making a POST:\n\nThe only difference is that you need to specify “PUT” as method setting. Similarly, you can send a PATCH request by setting it to “PATCH”.\n\nHere is an example of an HTTP DELETE request with fetch():\n\nAgain, it all comes down to setting the right HTTP method. The Fetch API implementation will take care of the rest.\n\nNow that you know how to use fetch() in common scenarios, you are ready to explore the Node Fetch API’s advanced options.\n\nfetch() enables you to customize the HTTP headers of your request through the headers field of the options object. In particular, headers accepts a Headers object or an object literal with specific string values.\n\nSuppose you want to set the Content-Type and User-Agent header in your fetch() request. You could either use a Headers object as below:\n\nOtherwise, you could equivalently set them with an object literal:\n\nThis syntax is more compact and easier to read.\n\nIf you want to read the HTTP headers set by the server in the response, you can access them as follows:\n\nThe response.headers field returns a Headers object, from which you can access specific headers with the get() method.\n\nA Node.js Fetch API call can fail only for two reasons:\n• An AbortError exception: When the request was intentionally aborted by an AbortController.\n• A TypeError exception: This can occur because of several reasons, such as an invalid header name, an invalid URL, or a generic network error. Find out more causes in the docs.\n\nWhat is essential to understand is that any 4xx or 5xx response is considered a successful request for the Fetch API. In other words, an error response produced by the server will not trigger any JavaScript error. The reason for this behavior is that fetch() made the request and the server replied with a response. Conceptually, that cannot be considered an error from the network’s point of view. At the end of the day, the request ended successfully.\n\nThis means that before dealing with the data returned by the server, you should always check for a successful response. To do so, you can implement the error-handling logic below:\n\nNote that the ok property from Response contains true only when the request was successful.\n\nThe Fetch API supports the abortion of already initiated requests through the AbortController API.\n\nTo stop an ongoing fetch() request, you first need to generate a signal object as below:\n\nNow, whenever you call the following instruction, your request will be interrupted by an AbortError:\n\nKeep in mind that the server might have already received the request. In this case, the server will still execute the request but the response will be ignored by Node.js.\n\nCongrats! You are now a Node.js Fetch API master!\n\nIn this article, you learned what is the Fetch API and how to use it in Node.js. In detail, you started from the fetch() basics and then dug into its advanced options and features. With such a powerful HTTP client, retrieving online data becomes easy. For example, you could use it to call our SERP API endpoints and start scraping SERP data.\n\nWant to learn more about scraping with Node.js? Read our web scraping with Node.js guide."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch",
        "document": "The Fetch API provides a JavaScript interface for making HTTP requests and processing the responses. Fetch is the modern replacement for : unlike , which uses callbacks, Fetch is promise-based and is integrated with features of the modern web such as service workers and Cross-Origin Resource Sharing (CORS). With the Fetch API, you make a request by calling , which is available as a global function in both and contexts. You pass it a object or a string containing the URL to fetch, along with an optional argument to configure the request. The function returns a which is fulfilled with a object representing the server's response. You can then check the request status and extract the body of the response in various formats, including text and JSON, by calling the appropriate method on the response. Here's a minimal function that uses to retrieve some JSON data from a server: async function getData() { const url = \"https://example.org/products.json\"; try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const json = await response.json(); console.log(json); } catch (error) { console.error(error.message); } } We declare a string containing the URL and then call , passing the URL with no extra options. The function will reject the promise on some errors, but not if the server responds with an error status like : so we also check the response status and throw if it is not OK. Otherwise, we fetch the response body content as JSON by calling the method of , and log one of its values. Note that like itself, is asynchronous, as are all the other methods to access the response body content. In the rest of this page we'll look in more detail at the different stages of this process.\n\nThe request body is the payload of the request: it's the thing the client is sending to the server. You cannot include a body with requests, but it's useful for requests that send content to the server, such as or requests. For example, if you want to upload a file to the server, you might make a request and include the file as the request body. To set a request body, pass it as the option: You can supply the body as an instance of any of the following types: Other objects are converted to strings using their method. For example, you can use a object to encode form data (see setting headers for more information): const response = await fetch(\"https://example.org/post\", { method: \"POST\", headers: { \"Content-Type\": \"application/x-www-form-urlencoded\", }, // Automatically converted to \"username=example&password=password\" body: new URLSearchParams({ username: \"example\", password: \"password\" }), // ... }); Note that just like response bodies, request bodies are streams, and making the request reads the stream, so if a request contains a body, you can't make it twice: const request = new Request(\"https://example.org/post\", { method: \"POST\", body: JSON.stringify({ username: \"example\" }), }); const response1 = await fetch(request); console.log(response1.status); // Will throw: \"Body has already been consumed.\" const response2 = await fetch(request); console.log(response2.status); Instead, you would need to create a clone of the request before sending it: See Locked and disturbed streams for more information.\n\nCredentials are cookies, TLS client certificates, or authentication headers containing a username and password. To control whether or not the browser sends credentials, as well as whether the browser respects any response headers, set the option, which can take one of the following three values:\n• : never send credentials in the request or include credentials in the response.\n• (the default): only send and include credentials for same-origin requests. Note that if a cookie's attribute is set to or , then the cookie will not be sent cross-site, even if is set to . Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if is set to , the server must also agree to their inclusion by including the header in its response. Additionally, in this situation the server must explicitly specify the client's origin in the response header (that is, is not allowed). This means that if is set to and the request is cross-origin, then:\n• If the request is a simple request, then the request will be sent with credentials, but the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the response, including credentials, will be delivered to the caller.\n• If the request is not a simple request, then the browser will send a preflighted request without credentials, and the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the browser will follow up with the real request, including credentials, and will deliver the real response, including credentials, to the caller.\n\nRequest and response bodies are actually objects, and whenever you read them, you're streaming the content. This is good for memory efficiency, because the browser doesn't have to buffer the entire response in memory before the caller retrieves it using a method like . This also means that the caller can process the content incrementally as it is received. For example, consider a request that fetches a large text file and processes it in some way, or displays it to the user: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchText(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const text = await response.text(); console.log(text); } catch (e) { console.error(e); } } If we use , as above, we must wait until the whole file has been received before we can process any of it. If we stream the response instead, we can process chunks of the body as they are received from the network: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchTextAsStream(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const stream = response.body.pipeThrough(new TextDecoderStream()); for await (const value of stream) { console.log(value); } } catch (e) { console.error(e); } } In this example, we iterate asynchronously over the stream, processing each chunk as it arrives. Note that when you access the body directly like this, you get the raw bytes of the response and must transform it yourself. In this case we call to pipe the response through a , which decodes the UTF-8-encoded body data as text."
    },
    {
        "link": "https://stackoverflow.com/questions/65816406/which-is-better-practice-when-setting-headers-for-a-fetch-in-javascript",
        "document": "I'm so tired of people trying to define a single \"best practice\" for everything in JavaScript. The answer here is that there is no \"better\" way as far as the fetch API is concerned.\n\nDepending on what you do before calling fetch, the litteral object or the instance of Headers may seem nicer. For example, getting hardcoded headers from a JSON configuration, it would be a waste of code to instantiate a Headers ; on the other hand, if you need to write some logic to generate the headers and select which ones to include, Headers has more explicit and case-insensitive (i.e. safer) methods.\n\nBut that's only my opinion about what I think are clear-cut examples. I'm sure there are people out there who would recommend always using litterals because they want immutability, and others who'd say Headers is more expressive and better typed. Either way, that's not what StackOverflow is for."
    },
    {
        "link": "https://stackoverflow.com/questions/38921726/use-http-2-to-make-api-calls-from-javascript",
        "document": "I know most browsers support http/2 for loading the pages but does this mean I can leverage it when I make api calls using XmlHttpRequest ?\n\nMore specifically my question is if I make 2 calls to fetch data using XmlHttpRequest does it ensure that both of them use the same tcp connection underneath ? None of the documentation I read any where specifies any thing about http2 support for XmlHttpRequest or how I can explicitly open a http2 connection, make some calls leveraging this and then close the connection.\n\nThe okHttp, jetty and other libraries in java offer client libraries to support this. But the javascript support is not clear."
    },
    {
        "link": "https://rapidapi.com/guides/request-headers-fetch",
        "document": "Fetch is a web API that can make an API request to API endpoints to perform CRUD operations. It often takes a request header that contains additional information for the server to process the request.\n\nIn this piece, we will learn how to set the request header in the fetch API. So without any further ado, let’s jump in!\n\nHTTP headers allow clients and servers to talk to each other and pass extra bits of information or instructions. Request headers include additional information sent by the client to the server. They usually contain instructions about the required data and information about the client. The server can use these headers to customize the response. Some examples of request headers include:\n\nLet’s do it in steps to learn how to set request headers using .\n\nWe need an API that we can call to learn how to use the fetch API in Next.js. For this, we will use RapidAPI Hub, which provides over 35,000+ APIs.\n\nWe will use the Famous Quotes API from RapidAPI Hub, so please go ahead and subscribe to it.\n\nGo ahead and create a simple HTML file with a script tag. This will contain all the JavaScript code of your application.\n\nTo set the request header for an API request in , pass an object as a second parameter to the method. The object will need a key whose value will be an object. This object will hold all the request headers for the API request.\n\nYou can see that I have provided a headers object to the API request. This object contains two keys, i.e., and .\n\nThat’s all, folks! I hope this piece helped you learn how to set request headers using . If you want to learn more about the fetch API, I recommend you read this piece."
    },
    {
        "link": "https://github.com/nodejs/undici/issues/2750",
        "document": "What is the problem this feature will solve?\n\nThis will get node's implementation of closer to how it behaves in the browser.\n\nWhat is the feature you are proposing to solve the problem?\n\nSupport protocol upgrade similar to how package does. It's weird to try to use a third-party package that uses node's internal http2 package under the hood.\n\nWhat alternatives have you considered?\n\nI am now using package, but much like or I fear it will fall out of spec and not evolve with the ecosystem."
    }
]