[
    {
        "link": "https://create.roblox.com/docs/scripting",
        "document": "Scripts are plain text files that let you add custom, dynamic behavior to your experiences. You can use scripts to trigger in-game events, respond to player input, save player data, create leaderboards, spawn enemies, control NPC behavior, and much, much more.\n\nThis section is for creators with some coding experience who want to know the specifics of scripting in Roblox. If you've never written code before and want an introduction to programming, see Coding fundamentals, which covers concepts like variables, functions, conditionals, loops, and arrays. For a more guided, step-by-step approach, see the Basic gameplay tutorial.\n\nRoblox scripts use the Luau programming language, which is derived from Lua 5.1.\n• None Compared to Lua 5.1, Luau adds performance enhancements and many useful features, including an optional typing system, string interpolation, and generalized iteration for tables.\n• None All valid Lua 5.1 code is valid Luau code, but the opposite is not true.\n\nMost books and online resources for Lua are still broadly applicable to Luau. For a detailed summary of differences, see Compatibility in the Luau documentation. For language syntax, see the Luau reference.\n\nLuau is gradually typed, so you don't need to specify a type when you create a variable. You can use type() to check object type:\n\nLuau has global and local scopes, but it's almost always better to declare variables and functions locally with the local keyword:\n\nLua uses nil to represent nonexistence or nothingness, which evaluates as false in conditional statements:\n\nAs you might have noticed, -- starts a one-line comment. --[[]] creates a block comment:\n\nTables are the generic term for arrays and dictionaries. Arrays are one-based rather than zero-based, so the first item is [1]. You declare arrays and dictionaries with a single set of curly braces:\n\nYou can iterate over tables using for loops with the ipairs() function for arrays and the pairs() function for dictionaries, but Luau also lets you omit these functions for cleaner syntax:\n• None In Roblox Studio, hover over ServerScriptService in the Explorer window and click +.\n• None Right-click the script and rename it to HelloScript.\n• None Double-click the script to open it in the Script Editor.\n• None Add the following code to the file:\n• None Ensure that the Output window is open.\n\nA big part of adapting to a new development environment is configuring it to meet your needs and understanding the tools at your disposal:\n• None The section of lets you adjust quality of life features like font, colors, indentation, autocomplete, brackets, and tooltips. You might also want to enable dark mode in the section.\n• None or and clicking on a function or variable takes you to its declaration in your codebase (or its online documentation). Using Holdingorand clicking on a function or variable takes you to its declaration in your codebase (or its online documentation). Using can help you navigate larger projects.\n• None menu to enable and . The window is the most basic tool for understanding the behavior of your scripts. Use themenu to enableand\n• None The window shows a summary of errors and warnings, but you might find its utility limited; the Script Editor already highlights these issues as you type.\n• None or . Use and . Logging capabilities are minimal, with no concept of log levels likeor. Useand\n\nFor more information about configuring Studio for scripting, see Script Editor. For information on using your favorite text editor and version control system, see External tools.\n• None In Roblox Studio, add a script to ReplicatedStorage in the Explorer window and rename it to OhNo.\n• None Add the following code to the file:\n• None Note how the output is no different than when you ran your first script.\n\nTo understand why the script didn't run, see Script Types and Locations."
    },
    {
        "link": "https://create.roblox.com/docs/education/battle-royale-series/creating-a-gui",
        "document": "Right now, much of the game information is currently in the Output window, invisible to players. So players can be informed of what's happening in the game, you'll create a graphical user interface (GUI) and code it.\n\nFor this game a text label will display the current game status as well as the remaining player count and time.\n\nFirst, create a Screen GUI object to hold the different text elements. When the player moves the camera, the screen GUI stays in the same place on their screen.\n\nTo ensure all players see the same display, place the GUI in the StarterGUI folder. At game startup, this folder is copied to all players.\n• None In the StarterGUI folder, create a new ScreenGUI. Then in ScreenGUI, add a new TextLabel named StatusText.\n• None To move the label, in the Explorer, select StatusText. Then, in the game view, drag the label where you would like it. Your numbers may differ from the video. The label can also be resized using the anchor points on the corners.\n\nTo reflect changes in the game, scripts will need to update the GUI elements. For instance, the game status, whether it's an intermission or active round, will be stored in a StringValue and updated using local scripts.\n\nThe StatusDisplay script will be used to update the player's GUI whenever the game state changes.\n• None In ReplicatedStorage, create a folder named DisplayValues. In that folder, add a StringValue named Status. To test the value later, give it a temporary value, like \"Welcome to the Battle!\". Because local scripts only run on a player's device, they can't be stored in Server folders like ServerStorage. ReplicatedStorage is a folder that's available both to the client (device) and server.\n• None In StarterGUI > ScreenGUI > Status, add a new local script named StatusDisplay. Scripts that affect the GUI are often parented to that GUI element.\n• None Open StatusDisplay and define the following variables for the follow:\n\nTo change the text in the label, use a Changed event so whenever the Status string is changed by another script, the text label will be updated.\n• None Code a new function named updateText(). In that function, set the Text property of textLabel to status.Value.\n• None Connect the function to the Changed event.\n• None So players see the most up to date status when starting the game, run updateText() at the end of the script.\n• None Run the game and confirm that you see the temporary value in the display.\n\nDuring a game, the text label will need to get information from GameManager, MatchManager, and possibly other scripts. So these different scripts can update the text label when needed, create a module script named DisplayManager.\n\nBecause DisplayManager needs to communicate with other scripts, it'll be a module script.\n• None In ServerStorage > ModuleScripts, create a new module script named DisplayManager. Rename the module table to match the script name.\n• None Add local variables for the following: Replicated Storage, DisplayValues folder, Status.\n• None Create a new module function named updateStatus() that updates the string in the Status value. Other scripts will be able to call this function.\n\nWith the Display Manager set up, it can be used in other scripts to update the GUI text label. As the first message in the GUI, show the start and end of the intermission through the GameManager script.\n• None In ServerScriptService > GameManager, create a variable named displayManager and require the DisplayManager module in ServerStorage.\n• None As the first line after the while true do statement, call displayManager > updateStatus() and pass in a message about waiting for players.\n• None After the end of the repeat loop for the intermission, call updateStatus() and pass in a string announcing the match is starting. Since you'll be testing with the GUI, delete the two print statements for noting the start and end of the intermission.\n• None Test the game with and without your minimum players. The message should read the following:\n\nAt this point, if the text label doesn't display the first message, or still displays \"Label\", try one of the following below.\n• None Make sure in the StatusDisplay local script that is called at the bottom of the script. This ensures that the player gets the most up to date message.\n• None Check that the Status StringValue is in ReplicatedStorage. Due to the unique nature of client-server relations, if it's in ServerStorage, a local script won't be able to find it.\n\nDuring a match, the GUI will display two numbers: remaining player count and time. As these numbers change, the text label will change as well.\n\nIntValues will be used to store the player count and time left.\n• None In ReplicatedStorage > DisplayValues, create two IntValues named PlayersLeft and TimeLeft.\n• None In DisplayManager, add variables to store the players left and time left values.\n• None Create a local function named updateMatchStatus(). Then, set the value of status to display the number of players left and the remaining time.\n• None For both IntValue variables, connect updateRoundStatus() to the Changed event. Don't test yet. Nothing has updated the PlayersLeft or TimeLeft values, so the status won't be changed once a round starts.\n\nNext, add the code for displaying the number of players at the start of a game. Later lessons will update the PlayersLeft value as players are eliminated from the game.\n• None In PlayerManager, add local variables for ReplicatedStorage service, DisplayValues folder and PlayersLeft IntValue.\n• None Show the starting player count by setting the value of playersLeft to the size of the active players array. Then, in sendPlayersToMatch(), under the for loop, type: playersLeft.Value = #activePlayers\n\nRemember that module scripts are used to centralize similar code. Since the timer is tracked in MatchManager, update the TimeLeft value using functions from the Timer script. The display manager will listen for changes to the TimeLeft, and update to match the new value.\n• None In MatchManager, create variables to store the ReplicatedStorage service, DisplayValues folder and TimeLeft value.\n• None Find the startTimer() function. After the timer's Finished event, copy and paste the whole, highlighted while loop below. The code runs a loop to update the timeLeft value as long as the timer is still active. -- Adding +1 makes sure the timer display ends at 1 instead of 0. -- By not setting the time for wait, it offers more accurate looping When added in, the code should look like the sample below. -- Adding +1 makes sure the timer display ends at 1 instead of 0. -- By not setting the time for wait, it offers more accurate looping\n• None Run the game with the minimum players. Check that the status text displays:\n• None The correct amount of starting players. Remember, this number won't change until additional code is added in a future lesson.\n• None Time decreases each second until it stops at 1.\n\nBelow are completed scripts to double check your work."
    },
    {
        "link": "https://create.roblox.com/docs/ui",
        "document": "You can quickly create high-quality graphical user interfaces with minimal scripting requirements using built-in UI objects. Depending on where you create it, UI renders either on-screen or within an experience's 3D world.\n\nOn-screen containers hold UI objects that you want to display on a user's screen. All on-screen UI objects and code are stored and changed on the client.\n\nIn-experience containers such as SurfaceGuis and BillboardGuis hold UI objects that you want to display within your experience's 3D world.\n\nMost UI elements are GuiObjects, 2D graphical user interface objects that you can parent to containers. The four most common are frames, labels, buttons, and text input objects.\n\nUsing the Position, Size, AnchorPoint, and ZIndex properties, you have complete control on how to position, size, and layer GuiObjects. You can also use tweening to transition a GuiObject smoothly from one state to another and provide dynamic visual feedback.\n\nBeyond basic properties for adjusting position and size, Roblox also provides layout structures like list/flex and grid, as well as size modifiers and appearance modifiers.\n\nIn addition to the core user interface objects, the following frameworks provide built‑in and customizable interactivity for your experiences.\n\nProximity prompts are unique built-in UI objects which prompt user interaction to trigger an action when they approach in-experience objects such as doors, light switches, and buttons.\n\nUI drag detectors facilitate and encourage interaction with 2D user interface elements such as sliders, spinners, and more.\n\n3D drag detectors encourage physical interaction with 3D objects in an experience, such as opening doors and drawers, sliding a part around, grabbing and tossing a bowling ball, pulling back and firing a slingshot, and much more."
    },
    {
        "link": "https://devforum.roblox.com/t/lua-scripting-starter-guide/394618",
        "document": "Picking up programming and learning it for the first time works just like any other hobby–art, music, sports, photography, etc.–although, it may be difficult to know where to start as a beginner, especially if you’ve never had experience with it up until now. When I was younger, it was very difficult for me to get into programming as tutorials for a younger, completely unexperienced audience was rare. Although there was plenty of content available, I still had a hard time understanding the material or just got lost in the sea of information that was given to me. There are still plenty of places on either Youtube or other parts of the internet where beginners can learn, but I’ve specifically compiled this list so that you have a neat, simple page you can refer to if you feel lost, or don’t know where to go after searching for tutorials. Becoming an experienced programmer from scratch will not be easy, it will take a lot of effort and more importantly time to become an expert. I say this because many developers I’ve personally known, whether rookies or professionals, tend to bail halfway through their project or goal. Do not lose hope when things don’t come as quickly as you expected, patience is crucial. What sets poor and excellent students isn’t necessarily intelligence, but their willingness to put in work and always seeking new ways to become better at what they do. Think of this article as a legend for Lua, similar to the page in a large book that highlight specific terms or character in the book that the reader might not recognize. When you finish this guide, your ability to code things will be limited, but you should have a much easier time understanding tutorials on more advanced topics. Ultimately, I hope this article can help you get started, or at least guide you through your journey through programming.\n\nP.S. I’ve tried to make this tutorial as kid-friendly as possible, if it is still difficult to read or understand, please DM me on any platform and I’ll try my best fix it. Specific examples are appreciated.\n\nChances are, if you’ve ever played a game, you’ve wondered how it was made. How does a sword go from unequipped to swinging in just a matter of seconds? Why? How is this app able to stream the movies I select? How is the website we’re currently on even able to operate?\n\nComputer programming is an essential part of modern life, as it determines and allows for many technologies we use on a daily basis to operate. However, all code is not written in the same way, rather, there are distinct languages, or ways of writing code. In fact, you might already be familiar with the names of various programming languages, including but not limited to JavaScript or Python.\n\nIn this tutorial, we’ll be covering Lua, the official language of Roblox which can be used to create a variety of different games for users to play.\n\nIn this tutorial, we’ll be using a specific format to write, input, and receive the result of our script. To use a format identical to mine, click on View in the upper left side of your screen, then make sure you have selected and have the following settings:\n\nYour screen should look something similar to this\n\nScripts can be inserted almost everywhere, for the sake of keeping this tutorial short, head over to Model on the top panel and browse to the far left and click on Script, which will generate a script that we can use for our tutorial.\n\nPrint is a built-in function which prints out whatever statement you decide to give it. This can be either number or strings, which we’ll cover in this section. You’ll notice that once you launch a script, there is already a print function automatically typed out for you. This code always comes with your scripts, so we’ll erase it to continue with the next step.\n\nType out print in all lowercase letters. If print is typed incorrectly or typed with any capitals, the program will not recognize the command and will not run it. Add a pair of parenthesis after, studio should automatically add the second one. Make sure there is no space in between print and the parenthesis otherwise Lua will not be able to read it.\n\nNext, we need to add a string in-between the parenthesis so that we don’t just print empty space. A string is any character or words inside of a pair of quotes, such as “Hello World!” For our tutorial, we’ll be adding the string “YellowNoobs!” for the program to print.\n\nYou may replace \"YellowNoobs\" with any other text you wish as long as it is in-between the parenthesis (\"\"), the end result should look something like this,\n\nIf you want to include quotation marks in your quote, you can also use a pair of single quotes (’’) and put the double parenthesis, or vice-versa for single quotes to be printed.\n\nPrint also works for numbers and equations, which it’ll automatically simplify in the output. But before we write out our problem, we need to find the symbols needed to get the right answer.\n\nArithmetic operators are basically all the tools we use in programming to indicate a relationship between numbers. This sounds complicated, but it’s just what we call the symbols we use to add, subtract, multiply, and divide numbers.\n\nHere are the Arithmetic Operators used in Lua:\n\nNow, we’ll write our equation in-between the parenthesis, and paste it into the command bar once we’re ready to get the output. Feel free to mess around with the operators to get the hang of it.\n\nIf we put our code into the command bar we’ll get 81 instead. This is the answer to the equation, and Lua does this because it’s a simplified version, or answer to the problem we originally printed. An important thing to keep in mind is that Lua completes the math using the Order of Operations, meaning it starts with exponents, then division and multiplication, and finally addition and subtraction.\n\nTake this piece of code for example,\n\nWhile you may be tempted to say the answer is 12, since you add 1 + 5, getting 6 and multiplying it by 2, this is wrong. Instead, you multiply 5 and 2 first, then add 1, getting 11. This is a rule of both math and programming, so practice the concept until you can avoid printing the wrong number.\n\nIn order to combine two or more separate values together, you can use concatenation in the print function. We’ll still use the same format, but will add two periods or dots after each string. Do not place this inside of the string, otherwise Lua will interpret it as part of the string and produce an error.\n\nIf we paste this into the command bar, the output will show us a full statement as if it was a single string, meaning the concatenation was successful.\n\nNow that you’ve learned how to make a script, you’ll learn what variables are and how to make your own. Variables are considered vital because they save a lot of time and save you time and make your scripts simpler to review. They can be booleans, numbers, strings, or practically anything you want to assign a name to.\n\nIf you’re struggling to understand the concept of a variable, you can compare it to a nickname you might give someone who’s name may be too tedious to pronounce. Although it is not their birthname, calling them by their nickname will still get their attention as they’ve been given and called by it before.\n\nBelow, I’ve given an example of a variable. The term “variable” will be used interchangeably with the string “YellowNoobs!” whenever we use it in the script. If we put the variable inside of the print command, it will print the text assigned to it. Since the variable is identical to the string we assigned it, we do not need any quotes around the variable name. If you put quotes around a variable name, Lua will interpret it as a string, and print the actual name rather than the value.\n\nIf we copy and paste the code into the input, the output will print our statement.\n\nIt is necessary that you define your variables before using them in your code. Since Lua reads code from top to bottom, it will not know what the variable stands for when it executes the print function. If we paste the code into our command bar, we’ll get the output nil, which means nothing or no data.\n\nWhenever we define the variable, its scope covers all of the code below in the script. Variable scope is just another word for when the variable can be accessed in your script.\n\nThere are two types of variables which you’ll hear about, local and global. The variables we’ve made in this tutorial so far have been global variables, which means they can be accessed in all code below inside the script. Local variables will be covered later in this tutorial, but in simplest terms, they have a much more limited scope.\n\nVariables do not only have to be named “variable” when assigned to a given piece of code. In fact, your variables have to be different names in order for the program to recognize which variable you want it to use in the script.\n\nWhile you can almost freely name your variables, there are a few restrictions that exist inside Lua.\n\nYou can use:\n\nYou can not use:\n• Capital letters as the first letter of the variable (Not required, but common practice)\n• Numbers as the first letter of the variable\n\nComments are a simple green text that organize and give context to your lines of code, which can be a useful tool for yourself or others if you plan on sharing it.\n\nCreating comments is extremely easy, add - - and then your text after you are finished. It should appear something like this.\n\nIf you want your comment to cover more than one line, insert brackets, with your text inside.\n\nAny text attached to the comment will not be executed by the program, and will only be seen by the reader. This green text is helpful in case you want to find a specific piece of code in your script. Comments are also crucial if you plan on sharing your scripts and want the reader to understand what certain commands do. Besides context, you can use comments to credit yourself for your script, or write out directions that the user who uses your script might want to see.\n\nIf you want to change the settings (such as the transparency, or invisibility) of an object in the workspace, you have to write down the specifics before Lua knows what you want it to do.\n\nSo, if we want to change the transparency of the baseplate, we first need to define that the baseplate is inside game.Workspace, with game being the game we’re working on and workspace being the place where baseplate and the rest of our parts are stored. Then, we write the object we’ll be changing (baseplate) and the setting that we want to change (its transparency), and then assign a value to it. If we want it to be fully invisible, we’ll set the value to one, lowering this amount will make it so that it’s semi-transparent.\n\nIn the end, this should make the baseplate completely invisible if we run the code or play the game. Keep in mind that we can change the properties of object in Studio as long as you define it correctly in the code.\n\nWhen you’re writing a sequence of code that needs to be repeated, it may be a little tedious and also messy to write it out several times. Functions are a tool in Lua that we can use to put lines of different code in, which can be repeated and manipulated a lot easier by us. The functions in this segment are not to be confused with the built-in functions of Lua, such as print.\n\nTo define a function, we need to write function and then assign it a name. Then, add a pair of parenthesis after your function name without any spacing in-between, and press enter. I’ll be naming my function printStuff, but you can name yours differently.\n\nNow, we need to write our code for our function to actually execute it. You’ll notice that when you press enter after writing your function, you’ll automatically get end. This statement is here so that you can end, or close off your function, otherwise Lua would get an error.\n\nI want to print several strings, so I’ll insert the several sequences of code inside my function.\n\nWe now have our function, however, nothing will be happen since we haven’t written the command to execute it. We need to type the function name on the next line, and Lua will print our strings.\n\nNow, Lua will execute our code. If we paste all of the content into the command bar, we’ll see that our function is successful. It’s important to note that just like variables, functions need to defined before we actually execute them in our code, otherwise we’ll just get nil.\n\nWhen we covered local variables previously in our tutorial, I mentioned that the scope of it was much more limited. Whereas global variables can be accessed anywhere in our script after being defined, local variables are limited to a block.\n\nSo what is a code block? An example is basically the indented sequence of code that we see in our function. I’ll attach comments to the parts that are a part of the block of code for a visual demonstration.\n\nYou can also tell if something is a block by the small arrow that appears to the left. If you look closely, the arrow facing down next to function is indicating that the block is being shown, and when it is facing up, it means it is closed.\n\nIf we try to print the local variable outside the block, we’ll get nil since the variable can’t be accessed.\n\nA handy feature of functions is the ability to manipulate the variables with ease. You might’ve already noticed the pair of parenthesis when we define the function, and the two other parenthesis when we execute it. These are the spaces where we put our arguments and parameters.\n\nEvery time we execute a function, we might want to change certain parts of the code each time. Parameters are used to tell Lua which variables (and thus any information) inside the function you want to change. They are established when we first define our function, and are placed in-between the first pair of parenthesis on the same line. Make sure to not define the variable you’ll be changing inside of your function, otherwise the parameter will not work.\n\nNow that we’ve defined the parameter, we need to write an argument for the function to be properly executed. An argument is the value we assign the code when executing it. It comes inside our next pair of parenthesis, and can be changed every time we execute the function separately. We’ll print a string and a number, and the program should treat the argument as the variable in the function.\n\nNow if we put it in the output, the two values should be successfully printed.\n\nArguments and parameters aren’t just limited to a single pair, in fact there can be as many as you want. In order to add another pair, separate each parameter and argument by a comma with the next one you want in your function.\n\nNow if we paste it into our command bar, the output should print both statements in the order we gave them. It is important that you put the arguments and parameters in the same order or you will assign the wrong value to the variable. Also, you always have to define your parameters when you execute your function, otherwise Lua will not know what to assign to the variables.\n\nYou might’ve already noticed that below the option to create a script, there is something called a local script. This tutorial won’t go too in-depth about them, but offer a broad summary about its purpose.\n\nLocal scripts are scripts that only affect the user’s client rather than the server. A user’s client is basically what they see, rather than the whole server. So whereas you might be seeing something, your friend playing the same game as you might see something completely different. In comparison, scripts that affect the server are seen by everyone, and not just the individual’s client.\n\nThe concept is a bit difficult to describe by text, and I still can’t do it justice by talking about it in depth, so I urge you to look at this video by TheDevKing to get a better idea of what local scripts are capable of.\n\nYou might’ve heard this word in math class and it is related. Booleans in scripting are the conditions true or false.\n\nWhen comparing values you’ll get a Boolean as well, although you can simply write true or false too.\n\nRelational operators are the operators used to compare values with one another.\n• Equal to, not to be confused with equal which simply assigns something rather than comparing two values: ==\n• Not equal to, which is true if the values are not equal: ~=\n• Greater than or equal to: >=\n• Less than or equal to: <=\n\nNow, let’s take a look at some numbers and see if they represent a true or false boolean\n\nThe first one is false, since the value can only be greater than, and not equal to the other. The next one is true as the values are equal to one another. The last is clearly false, since 8 is not less than the number 2.\n\nIf statements make it so that specific commands only happen if the condition is met, it will execute the code.\n\nFor example, if 5 > 1 the Output will print “Congratulations” since 5 > 1 is true. If the script said 5 < 1 then the script will not print “Congratulations” in Output.\n\nThis is equivalent to saying true instead and will still print our string.\n\nSometimes, our code needs to be repeated in order to produce an outcome we’re looking for. Loops are statements that allow us to repeat code multiple times. They come in several different forms, which we’ll cover in this section of the tutorial.\n\nWhile loops repeat sequences of code while the statement is true. However, when the condition is false, it will not execute the code block. For example, while a variable is less than a certain value, it will continue to print out a string we decide to give it. This is just one of countless things you can do with a while loop, so feel free to get creative if you’re feeling ambitious.\n\nFor our while loop, we’ll assign a number to our variable, x. Afterwards, we go on the next line and write while. This helps Lua understand that it is a while loop, so that when the condition is true, it’ll execute the code block. The do you see after our boolean is simply telling Lua to execute the block of code that is part of the loop when the condition is true.\n\nIn this code, I defined my variable as 10 and made it so that the while loop would continue to run until it was no longer less than a 100. Each time it runs the code, I made it so that it would add 10 to the variable, meaning that once it ran several times, it would no longer execute the code since the condition is false.\n\nNotice the string being printed after the loop. This is not executed until the loop is finished, so not attaching it to the loop can be used to tell us when the loop is finished.\n\nFor loops are able to loop as many times as the user wants. First, we define a variable for the loop, and assign it to a starting and ending value. The loop will continue to repeat until the starting value reaches the end value. While the amount the starting value increases is by 1, you can change it by adding a comma after the end value. Below, is an example of a for loop.\n\nOur loop will now print 1, 6, 11, 16 all the way until 21 where it will stop since it can not go past 25.\n\nHere is the format for the for loop.\n\nA repeat loop repeats the statements assigned to it until a following condition is true.\n\nUnlike a while loop, it runs the statements first before checking if the condition is true.\n\nWriting break at the end of a loop will end the loop if a condition is true. In the example below, break is used to break out of an infinite loop that otherwise keeps running because it is always true.\n\nThis could also work if instead of true we wrote while x < 200 do. The result would be that the loop would end early, ending when x reaches 100 rather than 200.\n\nYou may also hear the term nested loop, which is used to describe a loop with another loop inside of it.\n\nTables are used for storing large sets of data that you might use while creating your script. With tables, you can access and manipulate the data easy, which can come in handy later on. In this section, you’ll be learning about just a single type of tables, arrays.\n\nArrays are simply a list of values compiled in a table. This can include strings, numbers, booleans, functions–pretty much anything that can be used outside the script. To make an array, start by assigning a name of your own to the table.\n\nAfter this first step, you need to assign the data to the table. Assign the table to the data by adding an “=” in between, and write a pair of curly brackets (the second bracket will be automatically typed for you).\n\nNext, you can place all of your values inside of the array. For this tutorial, we’ll place a few strings and numbers together, but you can add more variety to your table if you’re following along. Make sure to separate each value by adding commas in-between them.\n\nIf we want to print specific parts of our array, we can use the index to get what we want. Each value in our array has an index, or number assigned to it. The first value is 1, second value is 2, third value is 3, etc. To print a specific part of our array, we put our table name in the print function, then follow it up with the index of the value, in-between brackets ([]).\n\nIn the end, this should print out our first string, “Hello World” in the output.\n\nWhere Else Can I Learn About Scripting?\n\nThere are many other places to learn, but the sources listed above have helped me with learning or adapting to Lua.\n\nWhat is the Difference Between Input and Output?\n\nInput is the code given to the engine, while output is the received/finished command. For example, print(“YellowNoobs!”) is a input while YellowNoobs is the output.\n\nStopping exploiters isn’t a beginner issue, it is a little more advanced than what we’ve discussed so far. Throughout your scripting career, you’ll realize that the main reason for exploits is due to poor and weak scripts that hackers are able to bypass.\n\nOne feature that Roblox automatically now applies to all games is FilteringEnabled, which prevents hackers from messing with the server itself. To learn more about how it works, you can watch the following video by AlvinBlox,\n\nWhy does Studio Automatically Indent for me?\n\nTechnically, indenting is not necessary, but it is extremely helpful and keeps your code organized. For example, through indents, you can see where your code blocks are. Not only that, but it looks much cleaner. Writing without proper indentation would give both you and the programmers reviewing your code a headache to read.\n\nHow do I become better?\n\nPractice, practice makes perfect, no exceptions. Learning to program unique things by yourself is always something you should strive to achieve as a developer.\n\nThat’s it, the basic tutorial is now finally finished! Hopefully, now you’ll have a far easier time being able to understand new concepts and can use this as a reference whenever you feel stuck.\n\nIf you have any other questions or feedback, please reply in the comments below, good luck!"
    },
    {
        "link": "https://create.roblox.com/docs/luau",
        "document": "Luau is the scripting language creators use in Roblox Studio. It is a fast, small, safe, gradually typed embeddable scripting language derived from Lua 5.1.\n\nThe Script Editor in Studio supports Luau with autocompletion, syntax highlighting, static linting, type checking, and script analysis. It also shows documentation and function signatures for members of the Roblox Engine API.\n• None represents non-existence or nothingness. It's different from any other value or data type. represents non-existence or nothingness. It's different from any other value or data type. represents non-existence or nothingness. It's different from any other value or data type.\n• None , or , have a value of either or . , or, have a value of eitheror , or, have a value of eitheror\n• None are sequences of characters, such as letters, numbers, and symbols. are sequences of characters, such as letters, numbers, and symbols. are sequences of characters, such as letters, numbers, and symbols.\n• None are . are are or of any value except\n\nLuau is dynamically typed by default. Variables, function parameters, and return values can be any data type. This helps you write code faster because you don't need to provide types for each piece of data. You can still declare explicit types for variables in Luau and enable strict type checking to make type issues obvious and easy to locate.\n\nYou can also implement the following data structures using primitive data types:\n• None are Last-In-First-Out collections of items that you can implement using tables. are Last-In-First-Out collections of items that you can implement using tables. are Last-In-First-Out collections of items that you can implement using tables.\n• None are First-In-First-Out collections of items that you can implement using tables. are First-In-First-Out collections of items that you can implement using tables. are First-In-First-Out collections of items that you can implement using tables.\n• None are tables with advanced configurations that can achieve functionalities such as storing pairs of keys and values and calculating arithmetic operations. are tables with advanced configurations that can achieve functionalities such as storing pairs of keys and values and calculating arithmetic operations. are tables with advanced configurations that can achieve functionalities such as storing pairs of keys and values and calculating arithmetic operations.\n\nIn Luau, variables and functions can have global and local scope within a script. Luau has logical, relational, and compound assignment operators. You can use control structures and functions to control when Luau executes code. Many operators and variable assignments perform type coercion to change values to the types that Luau expects."
    },
    {
        "link": "https://devforum.roblox.com/t/moveto-tiny-npc/1730081",
        "document": "I am working on this game where all NPC’s have a humanoid but are on a small scale, for ex;\n\n\n\nAnd I have some waypoints that I want other npcs to walk to, like a tower defense game;\n\n\n\nHow would I move them on those points? Since they are small they break and do not stay on the lines, should I use tween if so how?"
    },
    {
        "link": "https://devforum.roblox.com/t/weird-npc-behavior-when-using-pathfinding-and-humanoidmoveto/1050711",
        "document": "I am working on a a game that uses a mechanic with a delivery man for acquiring items. I ran into a problem that the npc is moving in breaks and just acts strange in general. In studio however they used to act entirely normal (At the end of the clip he does weird again). This is the part of the code that deals with the movement and pathfinding of the npc.\n\nfor i,j in pairs(workspace.workplaces:GetChildren()) do\n\n if j.Owner.Value == plr then\n\n local deliveryman = game.ServerStorage[“Delivery Man”]:Clone()\n\n deliveryman.Parent = j\n\n deliveryman:SetPrimaryPartCFrame(workspace.DeliveryManTarget.CFrame)\n\n for i = 1,280 do\n\n j.Conveyor.Box:SetPrimaryPartCFrame(j.Conveyor.Box:GetPrimaryPartCFrame()+Vector3.new(-.05,0,0))\n\n wait()\n\n end\n\n local PathfindingService = game:GetService(“PathfindingService”)\n\n local path = PathfindingService:CreatePath()\n\n path:ComputeAsync(deliveryman.HumanoidRootPart.Position, j.Conveyor.ConveyorTarget.Position)\n\n local waypoints = path:GetWaypoints()\n\n for _, waypoint in pairs(waypoints) do\n\n deliveryman.Humanoid:MoveTo(waypoint.Position)\n\n deliveryman.Humanoid.MoveToFinished:Wait()\n\n if waypoint.Action == Enum.PathWaypointAction.Jump then\n\n deliveryman.Humanoid.Jump = true\n\n end\n\n end\n\n wait(1)\n\n j.Conveyor.Box:SetPrimaryPartCFrame(j.Conveyor.BoxTarget.CFrame)\n\n path:ComputeAsync(deliveryman.HumanoidRootPart.Position,j.Box.BoxTarget.Position)\n\n local waypoints = path:GetWaypoints()\n\n for _, waypoint in pairs(waypoints) do\n\n deliveryman.Humanoid:MoveTo(waypoint.Position)\n\n deliveryman.Humanoid.MoveToFinished:Wait()\n\n if waypoint.Action == Enum.PathWaypointAction.Jump then\n\n deliveryman.Humanoid.Jump = true\n\n end\n\n end\n\n if deliveryman ~= nil then\n\n j.Box.Box.Transparency = 0\n\n j.Box.Tape.Transparency = 0\n\n j.Box.Tape.CanCollide = true\n\n j.Box.Box.CanCollide = true\n\n j.Box.Box.SurfaceGui.ImageLabel.Visible = true\n\n j.Box.Box.ProximityPrompt.Enabled = true\n\n local newitem = Instance.new(“Folder”,j.Box.Box.ProximityPrompt.Script)\n\n local Class = Instance.new(“StringValue”,newitem)\n\n Class.Name = “Class”\n\n Class.Value = args[1]\n\n local Item = Instance.new(“StringValue”,newitem)\n\n Item.Name = “Item”\n\n Item.Value = args[2]\n\n end\n\n path:ComputeAsync(deliveryman.HumanoidRootPart.Position, workspace.DeliveryManTarget.Position)\n\n local waypoints = path:GetWaypoints()\n\n for _, waypoint in pairs(waypoints) do\n\n deliveryman.Humanoid:MoveTo(waypoint.Position)\n\n deliveryman.Humanoid.MoveToFinished:Wait()\n\n if waypoint.Action == Enum.PathWaypointAction.Jump then\n\n deliveryman.Humanoid.Jump = true\n\n end\n\n end\n\n if deliveryman ~= nil then\n\n deliveryman:Destroy()\n\n end\n\n end\n\n end\n\n I have no clue what is causing this. I think it might have something to do with the MoveTo() timeout but I’m not really sure since I am new to the concept of coroutines."
    },
    {
        "link": "https://create.roblox.com/docs/characters/pathfinding",
        "document": "Pathfinding is the process of moving a character along a logical path to reach a destination, avoiding obstacles and (optionally) hazardous materials or defined regions.\n\nTo assist with pathfinding layout and debugging, Studio can render a navigation mesh and modifier labels. To enable them, toggle on Navigation mesh and Pathfinding modifiers from the Visualization Options widget in the upper‑right corner of the 3D viewport.\n\nWith Navigation mesh enabled, colored areas show where a character might walk or swim, while non-colored areas are blocked. The small arrows indicate areas that a character will attempt to reach by jumping, assuming you set AgentCanJump to true when creating the path.\n\nWith Pathfinding modifiers enabled, text labels indicate specific materials and regions that are taken into consideration when using pathfinding modifiers.\n\nPathfinding calculations consider only parts within certain vertical boundaries:\n• None Lower Boundary — Parts with a bottom coordinate less than -65,536 studs are ignored.\n• None Upper Boundary — Parts with a top coordinate exceeding 65,536 studs are ignored.\n• None Vertical Span — The vertical distance from the lowest part's bottom coordinate to the highest part's top coordinate must not exceed 65,536 studs; otherwise, the pathfinding system will ignore those parts during the pathfinding computation.\n\nThe direct line-of-sight distance for pathfinding from the start to the finish point must not exceed 3,000 studs. Exceeding this distance will result in a NoPath status.\n\nPathfinding is initiated through PathfindingService and its CreatePath() function.\n\nCreatePath() accepts an optional table of parameters which fine tune how the character (agent) moves along the path.\n\nNote that the agent can climb TrussParts during pathfinding assuming you set AgentCanClimb to true when creating the path and nothing blocks the agent from the truss climbing path. A climbable path has the Climb label and the cost for a climbable path is 1 by default.\n\nThis section uses the following pathfinding script for the player's character. To test while reading:\n• None variable to a destination in your 3D world that the player character can reach. Set thevariable to adestination in your 3D world that the player character can reach.\n• None Proceed through the following sections to learn about path computation and character movement.\n\nAfter you've created a valid path with CreatePath(), it must be computed by calling Path:ComputeAsync() with a Vector3 for both the starting point and destination.\n\nOnce the Path is computed, it will contain a series of waypoints that trace the path from start to end. These points can be gathered with the Path:GetWaypoints() function.\n\nEach waypoint consists of both a position (Vector3) and action (PathWaypointAction). To move a character containing a Humanoid, like a typical Roblox character, the easiest way is to call Humanoid:MoveTo() from waypoint to waypoint, using the MoveToFinished event to detect when the character reaches each waypoint.\n\nMany Roblox worlds are dynamic; parts might move or fall and floors may collapse. This can block a computed path and prevent the character from reaching its destination. To handle this, you can connect the Path.Blocked event and re-compute the path around whatever blocked it.\n\nBy default, Path:ComputeAsync() returns the shortest path between the starting point and destination, with the exception that it attempts to avoid jumps. This looks unnatural in some situations — for instance, a path may go through water rather than over a nearby bridge simply because the path through water is geometrically shorter.\n\nTo optimize pathfinding even further, you can implement pathfinding modifiers to compute smarter paths across various materials, around defined regions, or through obstacles.\n\nWhen working with Terrain and BasePart materials, you can include a Costs table within CreatePath() to make certain materials more traversable than others. All materials have a default cost of 1 and any material can be defined as non-traversable by setting its value to math.huge.\n\nKeys in the Costs table should be string names representing Enum.Material names, for example Water for Enum.Material.Water.\n\nIn some cases, material preference is not enough. For example, you might want characters to avoid a defined region, regardless of the materials underfoot. This can be achieved by adding a PathfindingModifier object to a part.\n• None Create an Anchored part around the dangerous region and set its CanCollide property to false.\n• None Insert a PathfindingModifier instance onto the part, locate its Label property, and assign a meaningful name like DangerZone.\n• None Include a Costs table within CreatePath() containing a matching key and associated numeric value. A modifier can be defined as non-traversable by setting its value to math.huge.\n\nIn some cases, it's useful to pathfind through solid obstacles as if they didn't exist. This lets you compute a path through specific physical blockers, versus the computation failing outright.\n• None Create an Anchored part around the object and set its CanCollide property to false.\n• None Insert a PathfindingModifier instance onto the part and enable its PassThrough property. Now, when a path is computed from the zombie NPC to the player character, the path extends beyond the door and you can prompt the zombie to traverse it. Even if the zombie is unable to open the door, it reacts as if it \"hears\" the character behind the door.\n\nSometimes it's necessary to find a path across a space that cannot be normally traversed, such as across a chasm, and perform a custom action to reach the next waypoint. This can be achieved through the PathfindingLink object.\n\nUsing the island example from above, you can make the agent use a boat instead of walking across all of the bridges.\n\nTo create a PathfindingLink using this example:\n• None To assist with visualization and debugging, toggle on from the To assist with visualization and debugging, toggle onfrom the widget in the upper‑right corner of the 3D viewport.\n• None Create two Attachments, one on the boat's seat and one near the boat's landing point.\n• None Create a PathfindingLink object in the workspace, then assign its Attachment0 and Attachment1 properties to the starting and ending attachments respectively.\n• None Assign a meaningful name like UseBoat to its Label property. This name is used as a flag in the pathfinding script to trigger a custom action when the agent reaches the starting link point.\n• None Include a Costs table within CreatePath() containing both a Water key and a custom key matching the Label property name. Assign the custom key a lower value than Water.\n• None In the event which fires when a waypoint is reached, add a custom check for the Label modifier name and take a different action than Humanoid:MoveTo() — in this case, calling a function to seat the agent in the boat, move the boat across the water, and continue the agent's path upon arrival at the destination island. -- Check if the obstacle is further down the path -- Detect when movement to next waypoint is complete -- Increase waypoint index and move to next waypoint -- Use boat if waypoint label is \"UseBoat\"; otherwise move to next waypoint -- Initially move to second waypoint (first waypoint is path start; skip it) -- Stop boat when next to island\n\nIn-experience instance streaming is a powerful feature that dynamically loads and unloads 3D content as a player's character moves around the world. As they explore the 3D space, new subsets of the space stream to their device and some of the existing subsets might stream out.\n\nConsider the following best practices for using PathfindingService in streaming-enabled experiences:\n• None Streaming can block or unblock a given path as a character moves along it. For example, while a character runs through a forest, a tree might stream in somewhere ahead of them and obstruct the path. To make pathfinding work seamlessly with streaming, it's highly recommended that you use the handling blocked paths technique and re-compute the path when necessary.\n• None A common approach in pathfinding is to use the coordinates of existing objects for computation, such as setting a path destination to the position of an existing TreasureChest model in the world. This approach is fully compatible with server-side Scripts since the server has full view of the world at all times, but LocalScripts and ModuleScripts that run on the client may fail if they attempt to compute a path to an object that's not streamed in. To address this issue, consider setting the destination to the position of a BasePart within a persistent model. Persistent models load soon after the player joins and they never stream out, so a client-side script can connect to the PersistentLoaded event and safely access the model for creating waypoints after the event fires."
    },
    {
        "link": "https://devforum.roblox.com/t/how-would-i-make-this-moveto-into-pathfinding/1815674",
        "document": "Take a look at this comment. It does what you asked.\n\nHere is the code"
    },
    {
        "link": "https://devforum.roblox.com/t/pathfinding-support/2629725",
        "document": "So this is the first time I’m using pathfinding in my entire lua development journey.\n\nI need this to update the target in realtime (Kind of like a nextbot) How would I go about doing this?"
    }
]