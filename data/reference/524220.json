[
    {
        "link": "https://docs.python.org/3/library/curses.html",
        "document": "The module provides an interface to the curses library, the de-facto standard for portable advanced terminal handling.\n\nWhile curses is most widely used in the Unix environment, versions are available for Windows, DOS, and possibly other systems as well. This extension module is designed to match the API of ncurses, an open-source curses library hosted on Linux and the BSD variants of Unix.\n\nThe module defines the following exception: Whenever x or y arguments to a function or a method are optional, they default to the current cursor location. Whenever attr is optional, it defaults to . The module defines the following functions: Return the output speed of the terminal in bits per second. On software terminal emulators it will have a fixed high value. Included for historical reasons; in former times, it was used to write output loops for time delays and occasionally to change interfaces depending on the line speed. Return or , depending on whether the programmer can change the colors displayed by the terminal. Enter cbreak mode. In cbreak mode (sometimes called “rare” mode) normal tty line buffering is turned off and characters are available to be read one by one. However, unlike raw mode, special characters (interrupt, quit, suspend, and flow control) retain their effects on the tty driver and calling program. Calling first then leaves the terminal in cbreak mode. Return the intensity of the red, green, and blue (RGB) components in the color color_number, which must be between and . Return a 3-tuple, containing the R,G,B values for the given color, which will be between (no component) and (maximum amount of component). Return the attribute value for displaying text in the specified color pair. Only the first 256 color pairs are supported. This attribute value can be combined with , , and the other attributes. is the counterpart to this function. Set the cursor state. visibility can be set to , , or , for invisible, normal, or very visible. If the terminal supports the visibility requested, return the previous cursor state; otherwise raise an exception. On many terminals, the “visible” mode is an underline cursor and the “very visible” mode is a block cursor. Save the current terminal mode as the “program” mode, the mode when the running program is using curses. (Its counterpart is the “shell” mode, for when the program is not in curses.) Subsequent calls to will restore this mode. Save the current terminal mode as the “shell” mode, the mode when the running program is not using curses. (Its counterpart is the “program” mode, when the program is using curses capabilities.) Subsequent calls to will restore this mode. Update the physical screen. The curses library keeps two data structures, one representing the current physical screen contents and a virtual screen representing the desired next state. The ground updates the physical screen to match the virtual screen. The virtual screen may be updated by a call after write operations such as have been performed on a window. The normal call is simply followed by ; if you have to update multiple windows, you can speed performance and perhaps reduce screen flicker by issuing calls on all windows, followed by a single . Enter echo mode. In echo mode, each character input is echoed to the screen as it is entered. De-initialize the library, and return terminal to normal status. Return the user’s current erase character as a one-byte bytes object. Under Unix operating systems this is a property of the controlling tty of the curses program, and is not set by the curses library itself. The routine, if used, must be called before is called. The effect is that, during those calls, is set to ; the capabilities , , , , , , are disabled; and the string is set to the value of . The effect is that the cursor is confined to the current line, and so are screen updates. This may be used for enabling character-at-a-time line editing without touching the rest of the screen. Flash the screen. That is, change it to reverse-video and then change it back in a short interval. Some people prefer such as ‘visible bell’ to the audible attention signal produced by . Flush all input buffers. This throws away any typeahead that has been typed by the user and has not yet been processed by the program. After returns to signal a mouse event, this method should be called to retrieve the queued mouse event, represented as a 5-tuple . id is an ID value used to distinguish multiple devices, and x, y, z are the event’s coordinates. (z is currently unused.) bstate is an integer value whose bits will be set to indicate the type of event, and will be the bitwise OR of one or more of the following constants, where n is the button number from 1 to 5: , , , , , , , . Changed in version 3.10: The constants are now exposed if they are provided by the underlying curses library. Return the current coordinates of the virtual screen cursor as a tuple . If is currently , then return . Read window related data stored in the file by an earlier call. The routine then creates and initializes a new window using that data, returning the new window object. Return if the terminal can display colors; otherwise, return . Return if the module supports extended colors; otherwise, return . Extended color support allows more than 256 color pairs for terminals that support more than 16 colors (e.g. xterm-256color). Return if the terminal has insert- and delete-character capabilities. This function is included for historical reasons only, as all modern software terminal emulators have such capabilities. Return if the terminal has insert- and delete-line capabilities, or can simulate them using scrolling regions. This function is included for historical reasons only, as all modern software terminal emulators have such capabilities. Take a key value ch, and return if the current terminal type recognizes a key with that value. Used for half-delay mode, which is similar to cbreak mode in that characters typed by the user are immediately available to the program. However, after blocking for tenths tenths of seconds, raise an exception if nothing has been typed. The value of tenths must be a number between and . Use to leave half-delay mode. Change the definition of a color, taking the number of the color to be changed followed by three RGB values (for the amounts of red, green, and blue components). The value of color_number must be between and . Each of r, g, b, must be a value between and . When is used, all occurrences of that color on the screen immediately change to the new definition. This function is a no-op on most terminals; it is active only if returns . Change the definition of a color-pair. It takes three arguments: the number of the color-pair to be changed, the foreground color number, and the background color number. The value of pair_number must be between and (the color pair is wired to white on black and cannot be changed). The value of fg and bg arguments must be between and , or, after calling , . If the color-pair was previously initialized, the screen is refreshed and all occurrences of that color-pair are changed to the new definition. Initialize the library. Return a window object which represents the whole screen. If there is an error opening the terminal, the underlying curses library may cause the interpreter to exit. Return if would modify the window structure, otherwise. Return if has been called (that is, the curses library has been deinitialized). Return the name of the key numbered k as a bytes object. The name of a key generating printable ASCII character is the key’s character. The name of a control-key combination is a two-byte bytes object consisting of a caret ( ) followed by the corresponding printable ASCII character. The name of an alt-key combination (128–255) is a bytes object consisting of the prefix followed by the name of the corresponding ASCII character. Return the user’s current line kill character as a one-byte bytes object. Under Unix operating systems this is a property of the controlling tty of the curses program, and is not set by the curses library itself. Return a bytes object containing the terminfo long name field describing the current terminal. The maximum length of a verbose description is 128 characters. It is defined only after the call to . If flag is , allow 8-bit characters to be input. If flag is , allow only 7-bit chars. Set the maximum time in milliseconds that can elapse between press and release events in order for them to be recognized as a click, and return the previous interval value. The default value is 200 milliseconds, or one fifth of a second. Set the mouse events to be reported, and return a tuple . availmask indicates which of the specified mouse events can be reported; on complete failure it returns . oldmask is the previous value of the given window’s mouse event mask. If this function is never called, no mouse events are ever reported. Create and return a pointer to a new pad data structure with the given number of lines and columns. Return a pad as a window object. A pad is like a window, except that it is not restricted by the screen size, and is not necessarily associated with a particular part of the screen. Pads can be used when a large window is needed, and only a part of the window will be on the screen at one time. Automatic refreshes of pads (such as from scrolling or echoing of input) do not occur. The and methods of a pad require 6 arguments to specify the part of the pad to be displayed and the location on the screen to be used for the display. The arguments are pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol; the p arguments refer to the upper left corner of the pad region to be displayed and the s arguments define a clipping box on the screen within which the pad region is to be displayed. Return a new window, whose left-upper corner is at , and whose height/width is nlines/ncols. By default, the window will extend from the specified position to the lower right corner of the screen. Enter newline mode. This mode translates the return key into newline on input, and translates newline into return and line-feed on output. Newline mode is initially on. Leave echo mode. Echoing of input characters is turned off. Leave newline mode. Disable translation of return into newline on input, and disable low-level translation of newline into newline/return on output (but this does not change the behavior of , which always does the equivalent of return and line feed on the virtual screen). With translation off, curses can sometimes speed up vertical motion a little; also, it will be able to detect the return key on input. When the routine is used, normal flush of input and output queues associated with the , and characters will not be done. You may want to call in a signal handler if you want output to continue as though the interrupt had not occurred, after the handler exits. Return a tuple containing the colors for the requested color pair. The value of pair_number must be between and . Return the number of the color-pair set by the attribute value attr. is the counterpart to this function. Equivalent to ; emit the value of a specified terminfo capability for the current terminal. Note that the output of always goes to standard output. If flag is , the effect is the same as calling . If flag is , or no argument is provided, the queues will be flushed when these control characters are read. Enter raw mode. In raw mode, normal line buffering and processing of interrupt, quit, suspend, and flow control keys are turned off; characters are presented to curses input functions one by one. Restore the terminal to “program” mode, as previously saved by . Restore the terminal to “shell” mode, as previously saved by . Restore the state of the terminal modes to what it was at the last call to . Backend function used by , performing most of the work; when resizing the windows, blank-fills the areas that are extended. The calling application should fill in these areas with appropriate data. The function attempts to resize all windows. However, due to the calling convention of pads, it is not possible to resize these without additional interaction with the application. Resize the standard and current windows to the specified dimensions, and adjusts other bookkeeping data used by the curses library that record the window dimensions (in particular the SIGWINCH handler). Save the current state of the terminal modes in a buffer, usable by . Retrieves the value set by . Sets the number of milliseconds to wait after reading an escape character, to distinguish between an individual escape character entered on the keyboard from escape sequences sent by cursor and function keys. Retrieves the value set by . Sets the number of columns used by the curses library when converting a tab character to spaces as it adds the tab to a window. Set the virtual screen cursor to y, x. If y and x are both , then is set . Initialize the terminal. term is a string giving the terminal name, or ; if omitted or , the value of the environment variable will be used. fd is the file descriptor to which any initialization sequences will be sent; if not supplied or , the file descriptor for will be used. Must be called if the programmer wants to use colors, and before any other color manipulation routine is called. It is good practice to call this routine right after . initializes eight basic colors (black, red, green, yellow, blue, magenta, cyan, and white), and two global variables in the module, and , containing the maximum number of colors and color-pairs the terminal can support. It also restores the colors on the terminal to the values they had when the terminal was just turned on. Return a logical OR of all video attributes supported by the terminal. This information is useful when a curses program needs complete control over the appearance of the screen. Return the value of the environment variable , as a bytes object, truncated to 14 characters. Return the value of the Boolean capability corresponding to the terminfo capability name capname as an integer. Return the value if capname is not a Boolean capability, or if it is canceled or absent from the terminal description. Return the value of the numeric capability corresponding to the terminfo capability name capname as an integer. Return the value if capname is not a numeric capability, or if it is canceled or absent from the terminal description. Return the value of the string capability corresponding to the terminfo capability name capname as a bytes object. Return if capname is not a terminfo “string capability”, or is canceled or absent from the terminal description. Instantiate the bytes object str with the supplied parameters, where str should be a parameterized string obtained from the terminfo database. E.g. could result in , the exact result depending on terminal type. Specify that the file descriptor fd be used for typeahead checking. If fd is , then no typeahead checking is done. The curses library does “line-breakout optimization” by looking for typeahead periodically while updating the screen. If input is found, and it is coming from a tty, the current update is postponed until refresh or doupdate is called again, allowing faster response to commands typed in advance. This function allows specifying a different file descriptor for typeahead checking. Return a bytes object which is a printable representation of the character ch. Control characters are represented as a caret followed by the character, for example as . Printing characters are left as they are. Push ch so the next will return it. Only one ch can be pushed before is called. Update the and module variables. Useful for detecting manual screen resize. Push ch so the next will return it. Only one ch can be pushed before is called. Push a event onto the input queue, associating the given state data with it. If used, this function should be called before or newterm are called. When flag is , the values of lines and columns specified in the terminfo database will be used, even if environment variables and (used by default) are set, or if curses is running in a window (in which case default behavior would be to use the window size if and are not set). Allow use of default values for colors on terminals supporting this feature. Use this to support transparency in your application. The default color is assigned to the color number . After calling this function, initializes, for instance, color pair x to a red foreground color on the default background. Initialize curses and call another callable object, func, which should be the rest of your curses-using application. If the application raises an exception, this function will restore the terminal to a sane state before re-raising the exception and generating a traceback. The callable object func is then passed the main window ‘stdscr’ as its first argument, followed by any other arguments passed to . Before calling func, turns on cbreak mode, turns off echo, enables the terminal keypad, and initializes colors if the terminal has color support. On exit (whether normally or by exception) it restores cooked mode, turns on echo, and disables the terminal keypad.\n\nWindow objects, as returned by and above, have the following methods and attributes: Paint character ch at with attributes attr, overwriting any character previously painted at that location. By default, the character position and attributes are the current settings for the window object. Writing outside the window, subwindow, or pad raises a . Attempting to write to the lower right corner of a window, subwindow, or pad will cause an exception to be raised after the character is printed. Paint at most n characters of the character string str at with attributes attr, overwriting anything previously on the display. Paint the character string str at with attributes attr, overwriting anything previously on the display.\n• None Writing outside the window, subwindow, or pad raises . Attempting to write to the lower right corner of a window, subwindow, or pad will cause an exception to be raised after the string is printed.\n• None A bug in ncurses, the backend for this Python module, can cause SegFaults when resizing windows. This is fixed in ncurses-6.1-20190511. If you are stuck with an earlier ncurses, you can avoid triggering this if you do not call with a str that has embedded newlines. Instead, call separately for each line. Remove attribute attr from the “background” set applied to all writes to the current window. Add attribute attr from the “background” set applied to all writes to the current window. Set the “background” set of attributes to attr. This set is initially (no attributes). Set the background property of the window to the character ch, with attributes attr. The change is then applied to every character position in that window:\n• None The attribute of every character in the window is changed to the new background attribute.\n• None Wherever the former background character appears, it is changed to the new background character. Set the window’s background. A window’s background consists of a character and any combination of attributes. The attribute part of the background is combined (OR’ed) with all non-blank characters that are written into the window. Both the character and attribute parts of the background are combined with the blank characters. The background becomes a property of the character and moves with the character through any scrolling and insert/delete line/character operations. Draw a border around the edges of the window. Each parameter specifies the character to use for a specific part of the border; see the table below for more details. A value for any parameter will cause the default character to be used for that parameter. Keyword parameters can not be used. The defaults are listed in this table: Similar to , but both ls and rs are vertch and both ts and bs are horch. The default corner characters are always used by this function. Set the attributes of num characters at the current cursor position, or at position if supplied. If num is not given or is , the attribute will be set on all the characters to the end of the line. This function moves cursor to position if supplied. The changed line will be touched using the method so that the contents will be redisplayed by the next window refresh. Like , but also cause the whole window to be repainted upon next call to . If flag is , the next call to will clear the window completely. Erase from cursor to the end of the window: all lines below the cursor are deleted, and then the equivalent of is performed. Erase from cursor to the end of the line. Update the current cursor position of all the ancestors of the window to reflect the current cursor position of the window. Delete the line under the cursor. All following lines are moved up by one line. An abbreviation for “derive window”, is the same as calling , except that begin_y and begin_x are relative to the origin of the window, rather than relative to the entire screen. Return a window object for the derived window. Add character ch with attribute attr, and immediately call on the window. Test whether the given pair of screen-relative character-cell coordinates are enclosed by the given window, returning or . It is useful for determining what subset of the screen windows enclose the location of a mouse event. Changed in version 3.10: Previously it returned or instead of or . Encoding used to encode method arguments (Unicode strings and characters). The encoding attribute is inherited from the parent window when a subwindow is created, for example with . By default, current locale encoding is used (see ). Get a character. Note that the integer returned does not have to be in ASCII range: function keys, keypad keys and so on are represented by numbers higher than 255. In no-delay mode, return if there is no input, otherwise wait until a key is pressed. Get a wide character. Return a character for most keys, or an integer for function keys, keypad keys, and other special keys. In no-delay mode, raise an exception if there is no input. Get a character, returning a string instead of an integer, as does. Function keys, keypad keys and other special keys return a multibyte string containing the key name. In no-delay mode, raise an exception if there is no input. Return a tuple of the height and width of the window. Return the beginning coordinates of this window relative to its parent window as a tuple . Return if this window has no parent. Read a bytes object from the user, with primitive line editing capacity. Return a tuple of current cursor position relative to the window’s upper-left corner. Display a horizontal line starting at with length n consisting of the character ch. If flag is , curses no longer considers using the hardware insert/delete character feature of the terminal; if flag is , use of character insertion and deletion is enabled. When curses is first initialized, use of character insert/delete is enabled by default. If flag is , will try and use hardware line editing facilities. Otherwise, line insertion/deletion are disabled. If flag is , any change in the window image automatically causes the window to be refreshed; you no longer have to call yourself. However, it may degrade performance considerably, due to repeated calls to wrefresh. This option is disabled by default. Return the character at the given position in the window. The bottom 8 bits are the character proper, and upper bits are the attributes. Paint character ch at with attributes attr, moving the line from position x right by one character. Insert nlines lines into the specified window above the current line. The nlines bottom lines are lost. For negative nlines, delete nlines lines starting with the one under the cursor, and move the remaining lines up. The bottom nlines lines are cleared. The current cursor position remains the same. Insert a blank line under the cursor. All following lines are moved down by one line. Insert a character string (as many characters as will fit on the line) before the character under the cursor, up to n characters. If n is zero or negative, the entire string is inserted. All characters to the right of the cursor are shifted right, with the rightmost characters on the line being lost. The cursor position does not change (after moving to y, x, if specified). Insert a character string (as many characters as will fit on the line) before the character under the cursor. All characters to the right of the cursor are shifted right, with the rightmost characters on the line being lost. The cursor position does not change (after moving to y, x, if specified). Return a bytes object of characters, extracted from the window starting at the current cursor position, or at y, x if specified. Attributes are stripped from the characters. If n is specified, returns a string at most n characters long (exclusive of the trailing NUL). Return if the specified line was modified since the last call to ; otherwise return . Raise a exception if line is not valid for the given window. Return if the specified window was modified since the last call to ; otherwise return . If flag is , escape sequences generated by some keys (keypad, function keys) will be interpreted by . If flag is , escape sequences will be left as is in the input stream. If flag is , cursor is left where it is on update, instead of being at “cursor position.” This reduces cursor movement where possible. If possible the cursor will be made invisible. If flag is , cursor will always be at “cursor position” after an update. Move the window inside its parent window. The screen-relative parameters of the window are not changed. This routine is used to display different parts of the parent window at the same physical position on the screen. Move the window so its upper-left corner is at . If flag is , will be non-blocking. If flag is , escape sequences will not be timed out. If flag is , after a few milliseconds, an escape sequence will not be interpreted, and will be left in the input stream as is. Mark for refresh but wait. This function updates the data structure representing the desired state of the window, but does not force an update of the physical screen. To accomplish that, call . Overlay the window on top of destwin. The windows need not be the same size, only the overlapping region is copied. This copy is non-destructive, which means that the current background character does not overwrite the old contents of destwin. To get fine-grained control over the copied region, the second form of can be used. sminrow and smincol are the upper-left coordinates of the source window, and the other variables mark a rectangle in the destination window. Overwrite the window on top of destwin. The windows need not be the same size, in which case only the overlapping region is copied. This copy is destructive, which means that the current background character overwrites the old contents of destwin. To get fine-grained control over the copied region, the second form of can be used. sminrow and smincol are the upper-left coordinates of the source window, the other variables mark a rectangle in the destination window. Write all data associated with the window into the provided file object. This information can be later retrieved using the function. Indicate that the num screen lines, starting at line beg, are corrupted and should be completely redrawn on the next call. Touch the entire window, causing it to be completely redrawn on the next call. The 6 optional arguments can only be specified when the window is a pad created with . The additional parameters are needed to indicate what part of the pad and screen are involved. pminrow and pmincol specify the upper left-hand corner of the rectangle to be displayed in the pad. sminrow, smincol, smaxrow, and smaxcol specify the edges of the rectangle to be displayed on the screen. The lower right-hand corner of the rectangle to be displayed in the pad is calculated from the screen coordinates, since the rectangles must be the same size. Both rectangles must be entirely contained within their respective structures. Negative values of pminrow, pmincol, sminrow, or smincol are treated as if they were zero. Reallocate storage for a curses window to adjust its dimensions to the specified values. If either dimension is larger than the current values, the window’s data is filled with blanks that have the current background rendition (as set by ) merged into them. Scroll the screen or scrolling region upward by lines lines. Control what happens when the cursor of a window is moved off the edge of the window or scrolling region, either as a result of a newline action on the bottom line, or typing the last character of the last line. If flag is , the cursor is left on the bottom line. If flag is , the window is scrolled up one line. Note that in order to get the physical scrolling effect on the terminal, it is also necessary to call . Set the scrolling region from line top to line bottom. All scrolling actions will take place in this region. Turn off the standout attribute. On some terminals this has the side effect of turning off all attributes. Return a sub-window, whose upper-left corner is at , and whose width/height is ncols/nlines. Return a sub-window, whose upper-left corner is at , and whose width/height is ncols/nlines. By default, the sub-window will extend from the specified position to the lower right corner of the window. Touch each location in the window that has been touched in any of its ancestor windows. This routine is called by , so it should almost never be necessary to call it manually. If flag is , then is called automatically whenever there is a change in the window. Touch all locations in ancestors of the window that have been changed in the window. Set blocking or non-blocking read behavior for the window. If delay is negative, blocking read is used (which will wait indefinitely for input). If delay is zero, then non-blocking read is used, and will return if no input is waiting. If delay is positive, then will block for delay milliseconds, and return if there is still no input at the end of that time. Pretend count lines have been changed, starting with line start. If changed is supplied, it specifies whether the affected lines are marked as having been changed (changed ) or unchanged (changed ). Pretend the whole window has been changed, for purposes of drawing optimizations. Mark all lines in the window as unchanged since the last call to . Display a vertical line starting at with length n consisting of the character ch with attributes attr.\n\nThe module defines the following data members: Some curses routines that return an integer, such as , return upon failure. Some curses routines that return an integer, such as , return upon success. A bytes object representing the current version of the module. A named tuple containing the three components of the ncurses library version: major, minor, and patch. All values are integers. The components can also be accessed by name, so is equivalent to and so on. Availability: if the ncurses library is used. The maximum number of colors the terminal can support. It is defined only after the call to . The maximum number of color pairs the terminal can support. It is defined only after the call to . The width of the screen, i.e., the number of columns. It is defined only after the call to . Updated by , and . The height of the screen, i.e., the number of lines. It is defined only after the call to . Updated by , and . Some constants are available to specify character cell attributes. The exact constants available are system dependent. Several constants are available to extract corresponding attributes returned by some methods. Keys are referred to by integer constants with names starting with . The exact keycaps available are system dependent. Function keys. Up to 64 function keys are supported. On VT100s and their software emulations, such as X terminal emulators, there are normally at least four function keys ( , , , ) available, and the arrow keys mapped to , , and in the obvious way. If your machine has a PC keyboard, it is safe to expect arrow keys and twelve function keys (older PC keyboards may have only ten function keys); also, the following keypad mappings are standard: The following table lists characters from the alternate character set. These are inherited from the VT100 terminal, and will generally be available on software emulations such as X terminals. When there is no graphic available, curses falls back on a crude printable ASCII approximation. These are available only after has been called. alternate name for upper right corner alternate name for lower right corner alternate name for right tee alternate name for crossover or big plus The following table lists mouse button constants used by : Shift was down during button state change Control was down during button state change Control was down during button state change Changed in version 3.10: The constants are now exposed if they are provided by the underlying curses library. The following table lists the predefined colors:"
    },
    {
        "link": "https://docs.python.org/3/howto/curses.html",
        "document": "The curses library supplies a terminal-independent screen-painting and keyboard-handling facility for text-based terminals; such terminals include VT100s, the Linux console, and the simulated terminal provided by various programs. Display terminals support various control codes to perform common operations such as moving the cursor, scrolling the screen, and erasing areas. Different terminals use widely differing codes, and often have their own minor quirks. In a world of graphical displays, one might ask “why bother”? It’s true that character-cell display terminals are an obsolete technology, but there are niches in which being able to do fancy things with them are still valuable. One niche is on small-footprint or embedded Unixes that don’t run an X server. Another is tools such as OS installers and kernel configurators that may have to run before any graphical support is available. The curses library provides fairly basic functionality, providing the programmer with an abstraction of a display containing multiple non-overlapping windows of text. The contents of a window can be changed in various ways—adding text, erasing it, changing its appearance—and the curses library will figure out what control codes need to be sent to the terminal to produce the right output. curses doesn’t provide many user-interface concepts such as buttons, checkboxes, or dialogs; if you need such features, consider a user interface library such as Urwid. The curses library was originally written for BSD Unix; the later System V versions of Unix from AT&T added many enhancements and new functions. BSD curses is no longer maintained, having been replaced by ncurses, which is an open-source implementation of the AT&T interface. If you’re using an open-source Unix such as Linux or FreeBSD, your system almost certainly uses ncurses. Since most current commercial Unix versions are based on System V code, all the functions described here will probably be available. The older versions of curses carried by some proprietary Unixes may not support everything, though. The Windows version of Python doesn’t include the module. A ported version called UniCurses is available. The Python module is a fairly simple wrapper over the C functions provided by curses; if you’re already familiar with curses programming in C, it’s really easy to transfer that knowledge to Python. The biggest difference is that the Python interface makes things simpler by merging different C functions such as , , and into a single method. You’ll see this covered in more detail later. This HOWTO is an introduction to writing text-mode programs with curses and Python. It doesn’t attempt to be a complete guide to the curses API; for that, see the Python library guide’s section on ncurses, and the C manual pages for ncurses. It will, however, give you the basic ideas.\n\nBefore doing anything, curses must be initialized. This is done by calling the function, which will determine the terminal type, send any required setup codes to the terminal, and create various internal data structures. If successful, returns a window object representing the entire screen; this is usually called after the name of the corresponding C variable. Usually curses applications turn off automatic echoing of keys to the screen, in order to be able to read keys and only display them under certain circumstances. This requires calling the function. Applications will also commonly need to react to keys instantly, without requiring the Enter key to be pressed; this is called cbreak mode, as opposed to the usual buffered input mode. Terminals usually return special keys, such as the cursor keys or navigation keys such as Page Up and Home, as a multibyte escape sequence. While you could write your application to expect such sequences and process them accordingly, curses can do it for you, returning a special value such as . To get curses to do the job, you’ll have to enable keypad mode. Terminating a curses application is much easier than starting one. You’ll need to call: to reverse the curses-friendly terminal settings. Then call the function to restore the terminal to its original operating mode. A common problem when debugging a curses application is to get your terminal messed up when the application dies without restoring the terminal to its previous state. In Python this commonly happens when your code is buggy and raises an uncaught exception. Keys are no longer echoed to the screen when you type them, for example, which makes using the shell difficult. In Python you can avoid these complications and make debugging much easier by importing the function and using it like this: The function takes a callable object and does the initializations described above, also initializing colors if color support is present. then runs your provided callable. Once the callable returns, will restore the original state of the terminal. The callable is called inside a … that catches exceptions, restores the state of the terminal, and then re-raises the exception. Therefore your terminal won’t be left in a funny state on exception and you’ll be able to read the exception’s message and traceback.\n\nWindows are the basic abstraction in curses. A window object represents a rectangular area of the screen, and supports methods to display text, erase it, allow the user to input strings, and so forth. The object returned by the function is a window object that covers the entire screen. Many programs may need only this single window, but you might wish to divide the screen into smaller windows, in order to redraw or clear them separately. The function creates a new window of a given size, returning the new window object. Note that the coordinate system used in curses is unusual. Coordinates are always passed in the order y,x, and the top-left corner of a window is coordinate (0,0). This breaks the normal convention for handling coordinates where the x coordinate comes first. This is an unfortunate difference from most other computer applications, but it’s been part of curses since it was first written, and it’s too late to change things now. Your application can determine the size of the screen by using the and variables to obtain the y and x sizes. Legal coordinates will then extend from to . When you call a method to display or erase text, the effect doesn’t immediately show up on the display. Instead you must call the method of window objects to update the screen. This is because curses was originally written with slow 300-baud terminal connections in mind; with these terminals, minimizing the time required to redraw the screen was very important. Instead curses accumulates changes to the screen and displays them in the most efficient manner when you call . For example, if your program displays some text in a window and then clears the window, there’s no need to send the original text because they’re never visible. In practice, explicitly telling curses to redraw a window doesn’t really complicate programming with curses much. Most programs go into a flurry of activity, and then pause waiting for a keypress or some other action on the part of the user. All you have to do is to be sure that the screen has been redrawn before pausing to wait for user input, by first calling or the method of some other relevant window. A pad is a special case of a window; it can be larger than the actual display screen, and only a portion of the pad displayed at a time. Creating a pad requires the pad’s height and width, while refreshing a pad requires giving the coordinates of the on-screen area where a subsection of the pad will be displayed. # These loops fill the pad with letters; addch() is # explained in the next section # Displays a section of the pad in the middle of the screen. # (0,0) : coordinate of upper-left corner of pad area to display. # (5,5) : coordinate of upper-left corner of window area to be filled # (20, 75) : coordinate of lower-right corner of window area to be The call displays a section of the pad in the rectangle extending from coordinate (5,5) to coordinate (20,75) on the screen; the upper left corner of the displayed section is coordinate (0,0) on the pad. Beyond that difference, pads are exactly like ordinary windows and support the same methods. If you have multiple windows and pads on screen there is a more efficient way to update the screen and prevent annoying screen flicker as each part of the screen gets updated. actually does two things:\n• None Calls the method of each window to update an underlying data structure representing the desired state of the screen.\n• None Calls the function function to change the physical screen to match the desired state recorded in the data structure. Instead you can call on a number of windows to update the data structure, and then call to update the screen.\n\nFrom a C programmer’s point of view, curses may sometimes look like a twisty maze of functions, all subtly different. For example, displays a string at the current cursor location in the window, while moves to a given y,x coordinate first before displaying the string. is just like , but allows specifying a window to use instead of using by default. allows specifying both a window and a coordinate. Fortunately the Python interface hides all these details. is a window object like any other, and methods such as accept multiple argument forms. Usually there are four different forms. Display the string str or character ch at the current position Display the string str or character ch, using attribute attr at the current position Move to position y,x within the window, and display str or ch Move to position y,x within the window, and display str or ch, using attribute attr Attributes allow displaying text in highlighted forms such as boldface, underline, reverse code, or in color. They’ll be explained in more detail in the next subsection. The method takes a Python string or bytestring as the value to be displayed. The contents of bytestrings are sent to the terminal as-is. Strings are encoded to bytes using the value of the window’s attribute; this defaults to the default system encoding as returned by . The methods take a character, which can be either a string of length 1, a bytestring of length 1, or an integer. Constants are provided for extension characters; these constants are integers greater than 255. For example, is a +/- symbol, and is the upper left corner of a box (handy for drawing borders). You can also use the appropriate Unicode character. Windows remember where the cursor was left after the last operation, so if you leave out the y,x coordinates, the string or character will be displayed wherever the last operation left off. You can also move the cursor with the method. Because some terminals always display a flashing cursor, you may want to ensure that the cursor is positioned in some location where it won’t be distracting; it can be confusing to have the cursor blinking at some apparently random location. If your application doesn’t need a blinking cursor at all, you can call to make it invisible. For compatibility with older curses versions, there’s a function that’s a synonym for . When bool is true, the curses library will attempt to suppress the flashing cursor, and you won’t need to worry about leaving it in odd locations. Characters can be displayed in different ways. Status lines in a text-based application are commonly shown in reverse video, or a text viewer may need to highlight certain words. curses supports this by allowing you to specify an attribute for each cell on the screen. An attribute is an integer, each bit representing a different attribute. You can try to display text with multiple attribute bits set, but curses doesn’t guarantee that all the possible combinations are available, or that they’re all visually distinct. That depends on the ability of the terminal being used, so it’s safest to stick to the most commonly available attributes, listed here. The best highlighting mode available So, to display a reverse-video status line on the top line of the screen, you could code: The curses library also supports color on those terminals that provide it. The most common such terminal is probably the Linux console, followed by color xterms. To use color, you must call the function soon after calling , to initialize the default color set (the function does this automatically). Once that’s done, the function returns TRUE if the terminal in use can actually display color. (Note: curses uses the American spelling ‘color’, instead of the Canadian/British spelling ‘colour’. If you’re used to the British spelling, you’ll have to resign yourself to misspelling it for the sake of these functions.) The curses library maintains a finite number of color pairs, containing a foreground (or text) color and a background color. You can get the attribute value corresponding to a color pair with the function; this can be bitwise-OR’ed with other attributes such as , but again, such combinations are not guaranteed to work on all terminals. An example, which displays a line of text using color pair 1: As I said before, a color pair consists of a foreground and background color. The function changes the definition of color pair n, to foreground color f and background color b. Color pair 0 is hard-wired to white on black, and cannot be changed. Colors are numbered, and initializes 8 basic colors when it activates color mode. They are: 0:black, 1:red, 2:green, 3:yellow, 4:blue, 5:magenta, 6:cyan, and 7:white. The module defines named constants for each of these colors: , , and so forth. Let’s put all this together. To change color 1 to red text on a white background, you would call: When you change a color pair, any text already displayed using that color pair will change to the new colors. You can also display new text in this color with: Very fancy terminals can change the definitions of the actual colors to a given RGB value. This lets you change color 1, which is usually red, to purple or blue or any other color you like. Unfortunately, the Linux console doesn’t support this, so I’m unable to try it out, and can’t provide any examples. You can check if your terminal can do this by calling , which returns if the capability is there. If you’re lucky enough to have such a talented terminal, consult your system’s man pages for more information.\n\nThe C curses library offers only very simple input mechanisms. Python’s module adds a basic text-input widget. (Other libraries such as Urwid have more extensive collections of widgets.) There are two methods for getting input from a window:\n• None refreshes the screen and then waits for the user to hit a key, displaying the key if has been called earlier. You can optionally specify a coordinate to which the cursor should be moved before pausing.\n• None does the same thing but converts the integer to a string. Individual characters are returned as 1-character strings, and special keys such as function keys return longer strings containing a key name such as or . It’s possible to not wait for the user using the window method. After , and for the window become non-blocking. To signal that no input is ready, returns (a value of -1) and raises an exception. There’s also a function, which can be used to (in effect) set a timer on each ; if no input becomes available within a specified delay (measured in tenths of a second), curses raises an exception. The method returns an integer; if it’s between 0 and 255, it represents the ASCII code of the key pressed. Values greater than 255 are special keys such as Page Up, Home, or the cursor keys. You can compare the value returned to constants such as , , or . The main loop of your program may look something like this: The module supplies ASCII class membership functions that take either integer or 1-character string arguments; these may be useful in writing more readable tests for such loops. It also supplies conversion functions that take either integer or 1-character-string arguments and return the same type. For example, returns the control character corresponding to its argument. There’s also a method to retrieve an entire string, . It isn’t used very often, because its functionality is quite limited; the only editing keys available are the backspace key and the Enter key, which terminates the string. It can optionally be limited to a fixed number of characters. # Get a 15-character string, with the cursor on the top line The module supplies a text box that supports an Emacs-like set of keybindings. Various methods of the class support editing with input validation and gathering the edit results either with or without trailing spaces. Here’s an example: # Let the user edit until Ctrl-G is struck. See the library documentation on for more details."
    },
    {
        "link": "https://python.readthedocs.io/fr/latest/howto/curses.html",
        "document": "The curses library supplies a terminal-independent screen-painting and keyboard-handling facility for text-based terminals; such terminals include VT100s, the Linux console, and the simulated terminal provided by various programs. Display terminals support various control codes to perform common operations such as moving the cursor, scrolling the screen, and erasing areas. Different terminals use widely differing codes, and often have their own minor quirks. In a world of graphical displays, one might ask “why bother”? It’s true that character-cell display terminals are an obsolete technology, but there are niches in which being able to do fancy things with them are still valuable. One niche is on small-footprint or embedded Unixes that don’t run an X server. Another is tools such as OS installers and kernel configurators that may have to run before any graphical support is available. The curses library provides fairly basic functionality, providing the programmer with an abstraction of a display containing multiple non-overlapping windows of text. The contents of a window can be changed in various ways—adding text, erasing it, changing its appearance—and the curses library will figure out what control codes need to be sent to the terminal to produce the right output. curses doesn’t provide many user-interface concepts such as buttons, checkboxes, or dialogs; if you need such features, consider a user interface library such as Urwid. The curses library was originally written for BSD Unix; the later System V versions of Unix from AT&T added many enhancements and new functions. BSD curses is no longer maintained, having been replaced by ncurses, which is an open-source implementation of the AT&T interface. If you’re using an open-source Unix such as Linux or FreeBSD, your system almost certainly uses ncurses. Since most current commercial Unix versions are based on System V code, all the functions described here will probably be available. The older versions of curses carried by some proprietary Unixes may not support everything, though. The Windows version of Python doesn’t include the module. A ported version called UniCurses is available. You could also try the Console module written by Fredrik Lundh, which doesn’t use the same API as curses but provides cursor-addressable text output and full support for mouse and keyboard input. Thy Python module is a fairly simple wrapper over the C functions provided by curses; if you’re already familiar with curses programming in C, it’s really easy to transfer that knowledge to Python. The biggest difference is that the Python interface makes things simpler by merging different C functions such as , , and into a single method. You’ll see this covered in more detail later. This HOWTO is an introduction to writing text-mode programs with curses and Python. It doesn’t attempt to be a complete guide to the curses API; for that, see the Python library guide’s section on ncurses, and the C manual pages for ncurses. It will, however, give you the basic ideas.\n\nBefore doing anything, curses must be initialized. This is done by calling the function, which will determine the terminal type, send any required setup codes to the terminal, and create various internal data structures. If successful, returns a window object representing the entire screen; this is usually called after the name of the corresponding C variable. Usually curses applications turn off automatic echoing of keys to the screen, in order to be able to read keys and only display them under certain circumstances. This requires calling the function. Applications will also commonly need to react to keys instantly, without requiring the Enter key to be pressed; this is called cbreak mode, as opposed to the usual buffered input mode. Terminals usually return special keys, such as the cursor keys or navigation keys such as Page Up and Home, as a multibyte escape sequence. While you could write your application to expect such sequences and process them accordingly, curses can do it for you, returning a special value such as . To get curses to do the job, you’ll have to enable keypad mode. Terminating a curses application is much easier than starting one. You’ll need to call: to reverse the curses-friendly terminal settings. Then call the function to restore the terminal to its original operating mode. A common problem when debugging a curses application is to get your terminal messed up when the application dies without restoring the terminal to its previous state. In Python this commonly happens when your code is buggy and raises an uncaught exception. Keys are no longer echoed to the screen when you type them, for example, which makes using the shell difficult. In Python you can avoid these complications and make debugging much easier by importing the function and using it like this: The function takes a callable object and does the initializations described above, also initializing colors if color support is present. then runs your provided callable. Once the callable returns, will restore the original state of the terminal. The callable is called inside a ... that catches exceptions, restores the state of the terminal, and then re-raises the exception. Therefore your terminal won’t be left in a funny state on exception and you’ll be able to read the exception’s message and traceback.\n\nWindows are the basic abstraction in curses. A window object represents a rectangular area of the screen, and supports methods to display text, erase it, allow the user to input strings, and so forth. The object returned by the function is a window object that covers the entire screen. Many programs may need only this single window, but you might wish to divide the screen into smaller windows, in order to redraw or clear them separately. The function creates a new window of a given size, returning the new window object. Note that the coordinate system used in curses is unusual. Coordinates are always passed in the order y,x, and the top-left corner of a window is coordinate (0,0). This breaks the normal convention for handling coordinates where the x coordinate comes first. This is an unfortunate difference from most other computer applications, but it’s been part of curses since it was first written, and it’s too late to change things now. Your application can determine the size of the screen by using the and variables to obtain the y and x sizes. Legal coordinates will then extend from to . When you call a method to display or erase text, the effect doesn’t immediately show up on the display. Instead you must call the method of window objects to update the screen. This is because curses was originally written with slow 300-baud terminal connections in mind; with these terminals, minimizing the time required to redraw the screen was very important. Instead curses accumulates changes to the screen and displays them in the most efficient manner when you call . For example, if your program displays some text in a window and then clears the window, there’s no need to send the original text because they’re never visible. In practice, explicitly telling curses to redraw a window doesn’t really complicate programming with curses much. Most programs go into a flurry of activity, and then pause waiting for a keypress or some other action on the part of the user. All you have to do is to be sure that the screen has been redrawn before pausing to wait for user input, by first calling or the method of some other relevant window. A pad is a special case of a window; it can be larger than the actual display screen, and only a portion of the pad displayed at a time. Creating a pad requires the pad’s height and width, while refreshing a pad requires giving the coordinates of the on-screen area where a subsection of the pad will be displayed. # These loops fill the pad with letters; addch() is # Displays a section of the pad in the middle of the screen. # (0,0) : coordinate of upper-left corner of pad area to display. # (5,5) : coordinate of upper-left corner of window area to be filled # (20, 75) : coordinate of lower-right corner of window area to be The call displays a section of the pad in the rectangle extending from coordinate (5,5) to coordinate (20,75) on the screen; the upper left corner of the displayed section is coordinate (0,0) on the pad. Beyond that difference, pads are exactly like ordinary windows and support the same methods. If you have multiple windows and pads on screen there is a more efficient way to update the screen and prevent annoying screen flicker as each part of the screen gets updated. actually does two things:\n• Calls the method of each window to update an underlying data structure representing the desired state of the screen.\n• Calls the function function to change the physical screen to match the desired state recorded in the data structure. Instead you can call on a number of windows to update the data structure, and then call to update the screen.\n\nFrom a C programmer’s point of view, curses may sometimes look like a twisty maze of functions, all subtly different. For example, displays a string at the current cursor location in the window, while moves to a given y,x coordinate first before displaying the string. is just like , but allows specifying a window to use instead of using by default. allows specifying both a window and a coordinate. Fortunately the Python interface hides all these details. is a window object like any other, and methods such as accept multiple argument forms. Usually there are four different forms. Display the string str or character ch at the current position Display the string str or character ch, using attribute attr at the current position Move to position y,x within the window, and display str or ch Move to position y,x within the window, and display str or ch, using attribute attr Attributes allow displaying text in highlighted forms such as boldface, underline, reverse code, or in color. They’ll be explained in more detail in the next subsection. The method takes a Python string or bytestring as the value to be displayed. The contents of bytestrings are sent to the terminal as-is. Strings are encoded to bytes using the value of the window’s attribute; this defaults to the default system encoding as returned by . The methods take a character, which can be either a string of length 1, a bytestring of length 1, or an integer. Constants are provided for extension characters; these constants are integers greater than 255. For example, is a +/- symbol, and is the upper left corner of a box (handy for drawing borders). You can also use the appropriate Unicode character. Windows remember where the cursor was left after the last operation, so if you leave out the y,x coordinates, the string or character will be displayed wherever the last operation left off. You can also move the cursor with the method. Because some terminals always display a flashing cursor, you may want to ensure that the cursor is positioned in some location where it won’t be distracting; it can be confusing to have the cursor blinking at some apparently random location. If your application doesn’t need a blinking cursor at all, you can call to make it invisible. For compatibility with older curses versions, there’s a function that’s a synonym for . When bool is true, the curses library will attempt to suppress the flashing cursor, and you won’t need to worry about leaving it in odd locations. Characters can be displayed in different ways. Status lines in a text-based application are commonly shown in reverse video, or a text viewer may need to highlight certain words. curses supports this by allowing you to specify an attribute for each cell on the screen. An attribute is an integer, each bit representing a different attribute. You can try to display text with multiple attribute bits set, but curses doesn’t guarantee that all the possible combinations are available, or that they’re all visually distinct. That depends on the ability of the terminal being used, so it’s safest to stick to the most commonly available attributes, listed here. So, to display a reverse-video status line on the top line of the screen, you could code: The curses library also supports color on those terminals that provide it. The most common such terminal is probably the Linux console, followed by color xterms. To use color, you must call the function soon after calling , to initialize the default color set (the function does this automatically). Once that’s done, the function returns TRUE if the terminal in use can actually display color. (Note: curses uses the American spelling ‘color’, instead of the Canadian/British spelling ‘colour’. If you’re used to the British spelling, you’ll have to resign yourself to misspelling it for the sake of these functions.) The curses library maintains a finite number of color pairs, containing a foreground (or text) color and a background color. You can get the attribute value corresponding to a color pair with the function; this can be bitwise-OR’ed with other attributes such as , but again, such combinations are not guaranteed to work on all terminals. An example, which displays a line of text using color pair 1: As I said before, a color pair consists of a foreground and background color. The function changes the definition of color pair n, to foreground color f and background color b. Color pair 0 is hard-wired to white on black, and cannot be changed. Colors are numbered, and initializes 8 basic colors when it activates color mode. They are: 0:black, 1:red, 2:green, 3:yellow, 4:blue, 5:magenta, 6:cyan, and 7:white. The module defines named constants for each of these colors: , , and so forth. Let’s put all this together. To change color 1 to red text on a white background, you would call: When you change a color pair, any text already displayed using that color pair will change to the new colors. You can also display new text in this color with: Very fancy terminals can change the definitions of the actual colors to a given RGB value. This lets you change color 1, which is usually red, to purple or blue or any other color you like. Unfortunately, the Linux console doesn’t support this, so I’m unable to try it out, and can’t provide any examples. You can check if your terminal can do this by calling , which returns if the capability is there. If you’re lucky enough to have such a talented terminal, consult your system’s man pages for more information.\n\nThe C curses library offers only very simple input mechanisms. Python’s module adds a basic text-input widget. (Other libraries such as Urwid have more extensive collections of widgets.) There are two methods for getting input from a window:\n• refreshes the screen and then waits for the user to hit a key, displaying the key if has been called earlier. You can optionally specify a coordinate to which the cursor should be moved before pausing.\n• does the same thing but converts the integer to a string. Individual characters are returned as 1-character strings, and special keys such as function keys return longer strings containing a key name such as or . It’s possible to not wait for the user using the window method. After , and for the window become non-blocking. To signal that no input is ready, returns (a value of -1) and raises an exception. There’s also a function, which can be used to (in effect) set a timer on each ; if no input becomes available within a specified delay (measured in tenths of a second), curses raises an exception. The method returns an integer; if it’s between 0 and 255, it represents the ASCII code of the key pressed. Values greater than 255 are special keys such as Page Up, Home, or the cursor keys. You can compare the value returned to constants such as , , or . The main loop of your program may look something like this: The module supplies ASCII class membership functions that take either integer or 1-character string arguments; these may be useful in writing more readable tests for such loops. It also supplies conversion functions that take either integer or 1-character-string arguments and return the same type. For example, returns the control character corresponding to its argument. There’s also a method to retrieve an entire string, . It isn’t used very often, because its functionality is quite limited; the only editing keys available are the backspace key and the Enter key, which terminates the string. It can optionally be limited to a fixed number of characters. # Get a 15-character string, with the cursor on the top line The module supplies a text box that supports an Emacs-like set of keybindings. Various methods of the class support editing with input validation and gathering the edit results either with or without trailing spaces. Here’s an example: See the library documentation on for more details.\n\nThis HOWTO doesn’t cover some advanced topics, such as reading the contents of the screen or capturing mouse events from an xterm instance, but the Python library page for the module is now reasonably complete. You should browse it next. If you’re in doubt about the detailed behavior of the curses functions, consult the manual pages for your curses implementation, whether it’s ncurses or a proprietary Unix vendor’s. The manual pages will document any quirks, and provide complete lists of all the functions, attributes, and characters available to you. Because the curses API is so large, some functions aren’t supported in the Python interface. Often this isn’t because they’re difficult to implement, but because no one has needed them yet. Also, Python doesn’t yet support the menu library associated with ncurses. Patches adding support for these would be welcome; see the Python Developer’s Guide to learn more about submitting patches to Python.\n• Writing Programs with NCURSES: a lengthy tutorial for C programmers.\n• “Use curses... don’t swear”: video of a PyCon 2013 talk on controlling terminals using curses or Urwid.\n• “Console Applications with Urwid”: video of a PyCon CA 2012 talk demonstrating some applications written using Urwid."
    },
    {
        "link": "https://ibm.com/docs/en/aix/7.1?topic=library-manipulating-characters-curses",
        "document": "You can add characters to a curses window using a keyboard or a curses application. This section describes how you can add, remove, or change characters that appear in a curses window.\n\nSome character sets define multi-column characters that occupy more than one column position when displayed on the screen.\n\nWriting a character whose width is greater than the width of the destination window produces an error.\n\nThe curses library provides a number of subroutines that write text changes to a window and mark the area to be updated at the next call to the wrefresh subroutine.\n\nThe waddch subroutines overwrite the character at the current logical cursor location with a specified character. After overwriting, the logical cursor is moved one space to the right. If the waddch subroutines are called at the right margin, these subroutines also add an automatic newline character. Additionally, if you call one of these subroutines at the bottom of a scrolling region and the scrollok subroutine is enabled, the region is scrolled up one line. For example, if you added a new line at the bottom line of a window, the window would scroll up one line.\n\nBy using the winch and waddch subroutine families together, you can copy text and video attributes from one place to another. Using the winch subroutine family, you can retrieve a character and its video attributes. You can then use one of the waddch subroutines to add the character and its attributes to another location.\n\nYou can also use the waddch subroutines to add control characters to a window. Control characters are drawn in the ^X notation.\n\nCalling the winch subroutine on a position in the window containing a control character does not return the character. Instead, it returns one character of the control character representation.\n\nWhen outputting single, noncontrol characters, there can be significant performance gain to using the wechochar subroutines. These subroutines are functionally equivalent to a call to the corresponding waddchr subroutine followed by the corresponding wrefresh subroutine. The wechochar subroutines include the wechochar subroutine, the echochar macro, and the pechochar subroutine.\n\nSome character sets may contain nonspacing characters. (Nonspacing characters are those, other than the ' \\ 0 ' character, for which the wcwidth subroutine returns a width of zero.) The application may write nonspacing characters to a window. Every nonspacing character in a window is associated with a spacing character and modifies the spacing character. Nonspacing characters in a window cannot be addressed separately. A nonspacing character is implicitly addressed whenever a Curses operation affects the spacing character with which the nonspacing character is associated.\n\nNonspacing characters do not support attributes. For interfaces that use wide characters and attributes, the attributes are ignored if the wide character is a nonspacing character. Multi-column characters have a single set of attributes for all columns. The association of nonspacing characters with spacing characters can be controlled by the application using the wide character interfaces. The wide character string functions provide codeset-dependent association.\n\nThe typical effects of a nonspacing character associated with a spacing character called c, are as follows:\n• The nonspacing character may modify the appearance of c. (For instance, there may be nonspacing characters that add diacritical marks to characters. However, there may also be spacing characters with built-in diacritical marks.)\n• The nonspacing characters may bridge c to the character following c. Examples of this usage are the formation of ligatures and the conversion of characters into compound display forms, words, or ideograms.\n\nImplementations may limit the number of nonspacing characters that can be associated with a spacing character, provided any limit is at least 5.\n\nA complex character is a set of associated characters, which may include a spacing character and may also include any nonspacing characters associated with it. A spacing complex character is a complex character that includes one spacing character and any nonspacing characters associated with it. An example of a code set that has complex characters is ISO/IEC 10646-1:1993.\n\nA complex character can be written to the screen. If the complex character does not include a spacing character, any nonspacing characters are associated with the spacing complex character that exists at the specified screen position. When the application reads information back from the screen, it obtains spacing complex characters.\n\nThe cchar_t data type represents a complex character and its rendition. When a cchar_t represents a nonspacing complex character (that is, when there is no spacing character within the complex character), then its rendition is not used. When it is written to the screen, it uses the rendition specified by the spacing character already displayed.\n\nAn object of type cchar_t can be initialized using the setchar subroutine, and its contents can be extracted using the getchar subroutine. The behavior of functions that take a cchar_t value that was not initialized in this way are obtained from a curses function that has a cchar_t output argument.\n\nSome functions process special characters. In functions that do not move the cursor based on the information placed in the window, these special characters would only be used within a string in order to affect the placement of subsequent characters. The cursor movement specified below does not persist in the visible cursor beyond the end of the operation. In functions that do not move the cursor, these special characters can be used to affect the placement of subsequent characters and to achieve movement of the physical cursor.\n\nThe curses functions that perform special-character processing conceptually convert control characters to the ( ' ^ ' ) character followed by a second character (which is an uppercase letter if it is alphabetic) and write this string to the window in place of the control character. The functions that retrieve text from the window will not retrieve the original control character.\n\nYou can use the following variables to add line-drawing characters to the screen with the waddch subroutine. When defined for the terminal, the variable will have the A_ALTCHARSET bit turned on. Otherwise, the default character listed in the following table is stored in the variable.\n\nThe winsch subroutines insert a specified character before the current character in a window. All characters to the right of the inserted character are moved one space to the right. As a result, the rightmost character on the line may be lost. The positions of the logical and physical cursors do not change after the move. The winsch subroutines include the following:\n\nThe winsertln subroutines insert a blank line above the current line in a window. The insertln subroutine inserts a line in the stdscr. The bottom line of the window is lost. The winsertln subroutine performs the same action in a user-defined window.\n\nThe wprintw subroutines replace a series of characters (starting with the current character) with formatted output. The format is the same as for the printf command. The printw family is made up of the following:\n\nThe wprintw subroutines make calls to the waddch subroutine to replace characters.\n\nThe unctrl macro returns a printable representation of the specified control character, displayed in the ^X notation. The unctrl macro returns print characters as is.\n\nScrolling occurs when a program or user moves a cursor off a window's bottom edge. For scrolling to occur, you must first use the scrollok subroutine to enable scrolling for a window. A window is scrolled if scrolling is enabled and if any of the following occurs:\n• The cursor is moved off the edge of a window.\n• A newline character is encountered on the last line.\n• A character is inserted in the last position of the last line.\n\nWhen a window is scrolled, curses will update both the window and the display. However, to get the physical scrolling effect on the terminal, you must call the idlok subroutine with the Flag parameter set to TRUE.\n\nIf scrolling is disabled, the cursor remains on the bottom line at the location where the character was entered.\n\nWhen scrolling is enabled for a window, you can use the setscrreg subroutines to create a software scrolling region inside the window. You pass the setscrreg subroutines values for the top line and bottom line of the region. If setscrreg is enabled for the region and scrolling is enabled for the window, any attempt to move off the specified bottom line causes all the lines in the region to scroll up one line. You can use the setscrreg macro to define a scrolling region in the stdscr. Otherwise, you use the wsetscrreg subroutine to define scrolling regions in user-defined windows.\n\nUnlike the idlok subroutine, the setscrreg subroutines have no bearing on the use of the physical scrolling region capability that the terminal may have.\n\nYou can delete text by replacing it with blank spaces or by removing characters from a character array and sliding the rest of the characters on the line one space to the left.\n\nThe erase macro copies blank space to every position in the stdscr. The werase subroutine puts a blank space at every position in a user-defined window. To delete a single character in a window, use the wdelch subroutine.\n\nThe wclear subroutines are similar to the werase subroutines. However, in addition to putting a blank space at every position of a window, the wclear subroutines also call the clearok subroutine. As a result, the screen is cleared on the next call to the wrefresh subroutine.\n\nThe wclear subroutine family contains the wclear subroutine, the clear macro, and the clearok subroutine. The clear macro puts a blank at every position in the stdscr.\n\nThe clrtoeol macro operates in the stdscr, while the wclrtoeol subroutine performs the same action within a user-defined window.\n\nThe clrtobot macro operates in the stdscr, while the wclrtobot performs the same action in a user-defined window.\n\nThe wdelch subroutines delete the current character and move all the characters to the right of the current character on the current line one position to the left. The last character in the line is filled with a blank. The delch subroutine family consists of the following subroutine and macros:\n\nThe deleteln subroutines delete the current line and move all lines below the current line up one line. This action clears the window's bottom line.\n\nYour program can retrieve characters from the keyboard or from the display. The wgetch subroutines retrieve characters from the keyboard. The winch subroutines retrieve characters from the display.\n\nThe wgetch subroutines read characters from the keyboard attached to the terminal associated with the window. Before getting a character, these subroutines call the wrefresh subroutines if anything in the window has changed: for example, if the cursor has moved or text has changed. For more information, see wgetch Subroutine, in Technical Reference: Base Operating System and Extensions, Volume 2.\n\nThe wgetch subroutine family is made up of the following:\n\nTo place a character previously obtained by a call to the wgetch subroutine back in the input queue, use the ungetch subroutine. The character is retrieved by the next call to the wgetch subroutine.\n\nThe output of the wgetch subroutines is, in part, determined by the mode of the terminal. The following list describes the action of the wgetch subroutines in each type of terminal mode:\n\nWhen you use the wgetch subroutines, do not set both the NOCBREAK mode and the ECHO mode at the same time. Setting both modes can cause undesirable results depending on the state of the tty driver when each character is typed.\n\nFunction keys are defined in the curses.h file. Function keys can be returned by the wgetch subroutine if the keypad is enabled. A terminal may not support all of the function keys. To see if a terminal supports a particular key, check its terminfo database definition. For a list of function keys, see getch, mvgetch, mvwgetch, or wgetch Subroutine, in Technical Reference: Base Operating System and Extensions, Volume 2.\n\nIf your program enables the keyboard with the keypad subroutine, and the user presses a function key, the token for that function key is returned instead of raw characters. The /usr/include/curses.h file defines the possible function keys. Each define statement begins with a KEY_ prefix, and the keys are defined as integers beginning with the value 03510.\n\nIf a character is received that could be the beginning of a function key (such as an Escape character), curses sets a timer (a structure of type timeval that is defined in /usr/include/sys/time.h). If the remainder of the sequence is not received before the timer expires, the character is passed through. Otherwise, the function key's value is returned. For this reason, after a user presses the Esc key there is a delay before the escape is returned to the program. Avoid using the Esc key where possible when you call a single-character subroutine such as the wgetch subroutine. This timer can be overridden or extended by the use of the ESCDELAY environment variable.\n\nThe ESCDELAY environment variable sets the length of time to wait before timing out and treating the ESC keystroke as the Escape character rather than combining it with other characters in the buffer to create a key sequence. The ESCDELAY value is measured in fifths of a millisecond. If the ESCDELAY variable is 0, the system immediately composes the Escape response without waiting for more information from the buffer. You may choose any value from 0 to 99,999. The default setting for the ESCDELAY variable is 500 (1/10th of a second).\n\nTo prevent the wgetch subroutine from setting a timer, call the notimeout subroutine. If notimeout is set to TRUE, curses does not distinguish between function keys and characters when retrieving data.\n\nThe keyname subroutine returns a pointer to a character string containing a symbolic name for the Key argument. The Key argument can be any key returned from the wgetch, getch, mvgetch, or mvwgetch subroutines.\n\nThe winch subroutines retrieve the character at the current position. If any attributes are set for the position, the attribute values are ORed into the value returned. You can use the winch subroutines to extract only the character or its attributes. To do this, use the predefined constants A_CHARTEXT and A_ATTRIBUTES with the logical & (ampersand) operator. These constants are defined in the curses.h file. The following are the winch subroutines:\n\nThe wscanw subroutines read character data, interpret it according to a conversion specification, and store the converted results into memory. The wscanw subroutines use the wgetstr subroutines to read the character data. The following are the wscanw subroutines:\n\nThe vwscanw subroutine scans a window using a variable argument list. For information about manipulating variable argument lists, see the varargs macros in Technical Reference: Base Operating System and Extensions, Volume 2."
    },
    {
        "link": "https://docs.activestate.com/activepython/2.7/python/howto/curses.html",
        "document": "The curses library supplies a terminal-independent screen-painting and keyboard-handling facility for text-based terminals; such terminals include VT100s, the Linux console, and the simulated terminal provided by X11 programs such as xterm and rxvt. Display terminals support various control codes to perform common operations such as moving the cursor, scrolling the screen, and erasing areas. Different terminals use widely differing codes, and often have their own minor quirks. In a world of X displays, one might ask “why bother”? It’s true that character-cell display terminals are an obsolete technology, but there are niches in which being able to do fancy things with them are still valuable. One is on small-footprint or embedded Unixes that don’t carry an X server. Another is for tools like OS installers and kernel configurators that may have to run before X is available. The curses library hides all the details of different terminals, and provides the programmer with an abstraction of a display, containing multiple non-overlapping windows. The contents of a window can be changed in various ways—adding text, erasing it, changing its appearance—and the curses library will automagically figure out what control codes need to be sent to the terminal to produce the right output. The curses library was originally written for BSD Unix; the later System V versions of Unix from AT&T added many enhancements and new functions. BSD curses is no longer maintained, having been replaced by ncurses, which is an open-source implementation of the AT&T interface. If you’re using an open-source Unix such as Linux or FreeBSD, your system almost certainly uses ncurses. Since most current commercial Unix versions are based on System V code, all the functions described here will probably be available. The older versions of curses carried by some proprietary Unixes may not support everything, though. No one has made a Windows port of the curses module. On a Windows platform, try the Console module written by Fredrik Lundh. The Console module provides cursor-addressable text output, plus full support for mouse and keyboard input, and is available from http://effbot.org/zone/console-index.htm. Thy Python module is a fairly simple wrapper over the C functions provided by curses; if you’re already familiar with curses programming in C, it’s really easy to transfer that knowledge to Python. The biggest difference is that the Python interface makes things simpler, by merging different C functions such as , , , into a single method. You’ll see this covered in more detail later. This HOWTO is simply an introduction to writing text-mode programs with curses and Python. It doesn’t attempt to be a complete guide to the curses API; for that, see the Python library guide’s section on ncurses, and the C manual pages for ncurses. It will, however, give you the basic ideas.\n\nBefore doing anything, curses must be initialized. This is done by calling the function, which will determine the terminal type, send any required setup codes to the terminal, and create various internal data structures. If successful, returns a window object representing the entire screen; this is usually called , after the name of the corresponding C variable. Usually curses applications turn off automatic echoing of keys to the screen, in order to be able to read keys and only display them under certain circumstances. This requires calling the function. Applications will also commonly need to react to keys instantly, without requiring the Enter key to be pressed; this is called cbreak mode, as opposed to the usual buffered input mode. Terminals usually return special keys, such as the cursor keys or navigation keys such as Page Up and Home, as a multibyte escape sequence. While you could write your application to expect such sequences and process them accordingly, curses can do it for you, returning a special value such as . To get curses to do the job, you’ll have to enable keypad mode. Terminating a curses application is much easier than starting one. You’ll need to call to reverse the curses-friendly terminal settings. Then call the function to restore the terminal to its original operating mode. A common problem when debugging a curses application is to get your terminal messed up when the application dies without restoring the terminal to its previous state. In Python this commonly happens when your code is buggy and raises an uncaught exception. Keys are no longer echoed to the screen when you type them, for example, which makes using the shell difficult. In Python you can avoid these complications and make debugging much easier by importing the function. It takes a callable and does the initializations described above, also initializing colors if color support is present. It then runs your provided callable and finally deinitializes appropriately. The callable is called inside a try-catch clause which catches exceptions, performs curses deinitialization, and then passes the exception upwards. Thus, your terminal won’t be left in a funny state on exception.\n\nWindows are the basic abstraction in curses. A window object represents a rectangular area of the screen, and supports various methods to display text, erase it, allow the user to input strings, and so forth. The object returned by the function is a window object that covers the entire screen. Many programs may need only this single window, but you might wish to divide the screen into smaller windows, in order to redraw or clear them separately. The function creates a new window of a given size, returning the new window object. A word about the coordinate system used in curses: coordinates are always passed in the order y,x, and the top-left corner of a window is coordinate (0,0). This breaks a common convention for handling coordinates, where the x coordinate usually comes first. This is an unfortunate difference from most other computer applications, but it’s been part of curses since it was first written, and it’s too late to change things now. When you call a method to display or erase text, the effect doesn’t immediately show up on the display. This is because curses was originally written with slow 300-baud terminal connections in mind; with these terminals, minimizing the time required to redraw the screen is very important. This lets curses accumulate changes to the screen, and display them in the most efficient manner. For example, if your program displays some characters in a window, and then clears the window, there’s no need to send the original characters because they’d never be visible. Accordingly, curses requires that you explicitly tell it to redraw windows, using the method of window objects. In practice, this doesn’t really complicate programming with curses much. Most programs go into a flurry of activity, and then pause waiting for a keypress or some other action on the part of the user. All you have to do is to be sure that the screen has been redrawn before pausing to wait for user input, by simply calling or the method of some other relevant window. A pad is a special case of a window; it can be larger than the actual display screen, and only a portion of it displayed at a time. Creating a pad simply requires the pad’s height and width, while refreshing a pad requires giving the coordinates of the on-screen area where a subsection of the pad will be displayed. # These loops fill the pad with letters; this is # explained in the next section # Displays a section of the pad in the middle of the screen The call displays a section of the pad in the rectangle extending from coordinate (5,5) to coordinate (20,75) on the screen; the upper left corner of the displayed section is coordinate (0,0) on the pad. Beyond that difference, pads are exactly like ordinary windows and support the same methods. If you have multiple windows and pads on screen there is a more efficient way to go, which will prevent annoying screen flicker at refresh time. Use the method of each window to update the data structure representing the desired state of the screen; then change the physical screen to match the desired state in one go with the function . The normal method calls as its last act.\n\nFrom a C programmer’s point of view, curses may sometimes look like a twisty maze of functions, all subtly different. For example, displays a string at the current cursor location in the window, while moves to a given y,x coordinate first before displaying the string. is just like , but allows specifying a window to use, instead of using by default. follows similarly. Fortunately the Python interface hides all these details; is a window object like any other, and methods like accept multiple argument forms. Usually there are four different forms. Display the string str or character ch at the current position Display the string str or character ch, using attribute attr at the current position Move to position y,x within the window, and display str or ch Move to position y,x within the window, and display str or ch, using attribute attr Attributes allow displaying text in highlighted forms, such as in boldface, underline, reverse code, or in color. They’ll be explained in more detail in the next subsection. The function takes a Python string as the value to be displayed, while the functions take a character, which can be either a Python string of length 1 or an integer. If it’s a string, you’re limited to displaying characters between 0 and 255. SVr4 curses provides constants for extension characters; these constants are integers greater than 255. For example, is a +/- symbol, and is the upper left corner of a box (handy for drawing borders). Windows remember where the cursor was left after the last operation, so if you leave out the y,x coordinates, the string or character will be displayed wherever the last operation left off. You can also move the cursor with the method. Because some terminals always display a flashing cursor, you may want to ensure that the cursor is positioned in some location where it won’t be distracting; it can be confusing to have the cursor blinking at some apparently random location. If your application doesn’t need a blinking cursor at all, you can call to make it invisible. Equivalently, and for compatibility with older curses versions, there’s a function. When bool is true, the curses library will attempt to suppress the flashing cursor, and you won’t need to worry about leaving it in odd locations. Characters can be displayed in different ways. Status lines in a text-based application are commonly shown in reverse video; a text viewer may need to highlight certain words. curses supports this by allowing you to specify an attribute for each cell on the screen. An attribute is an integer, each bit representing a different attribute. You can try to display text with multiple attribute bits set, but curses doesn’t guarantee that all the possible combinations are available, or that they’re all visually distinct. That depends on the ability of the terminal being used, so it’s safest to stick to the most commonly available attributes, listed here. The best highlighting mode available So, to display a reverse-video status line on the top line of the screen, you could code: The curses library also supports color on those terminals that provide it. The most common such terminal is probably the Linux console, followed by color xterms. To use color, you must call the function soon after calling , to initialize the default color set (the function does this automatically). Once that’s done, the function returns TRUE if the terminal in use can actually display color. (Note: curses uses the American spelling ‘color’, instead of the Canadian/British spelling ‘colour’. If you’re used to the British spelling, you’ll have to resign yourself to misspelling it for the sake of these functions.) The curses library maintains a finite number of color pairs, containing a foreground (or text) color and a background color. You can get the attribute value corresponding to a color pair with the function; this can be bitwise-OR’ed with other attributes such as , but again, such combinations are not guaranteed to work on all terminals. An example, which displays a line of text using color pair 1: As I said before, a color pair consists of a foreground and background color. initializes 8 basic colors when it activates color mode. They are: 0:black, 1:red, 2:green, 3:yellow, 4:blue, 5:magenta, 6:cyan, and 7:white. The curses module defines named constants for each of these colors: , , and so forth. The function changes the definition of color pair n, to foreground color f and background color b. Color pair 0 is hard-wired to white on black, and cannot be changed. Let’s put all this together. To change color 1 to red text on a white background, you would call: When you change a color pair, any text already displayed using that color pair will change to the new colors. You can also display new text in this color with: Very fancy terminals can change the definitions of the actual colors to a given RGB value. This lets you change color 1, which is usually red, to purple or blue or any other color you like. Unfortunately, the Linux console doesn’t support this, so I’m unable to try it out, and can’t provide any examples. You can check if your terminal can do this by calling , which returns TRUE if the capability is there. If you’re lucky enough to have such a talented terminal, consult your system’s man pages for more information.\n\nThe curses library itself offers only very simple input mechanisms. Python’s support adds a text-input widget that makes up some of the lack. The most common way to get input to a window is to use its method. pauses and waits for the user to hit a key, displaying it if has been called earlier. You can optionally specify a coordinate to which the cursor should be moved before pausing. It’s possible to change this behavior with the method . After , for the window becomes non-blocking and returns (a value of -1) when no input is ready. There’s also a function, which can be used to (in effect) set a timer on each ; if no input becomes available within a specified delay (measured in tenths of a second), curses raises an exception. The method returns an integer; if it’s between 0 and 255, it represents the ASCII code of the key pressed. Values greater than 255 are special keys such as Page Up, Home, or the cursor keys. You can compare the value returned to constants such as , , or . Usually the main loop of your program will look something like this: The module supplies ASCII class membership functions that take either integer or 1-character-string arguments; these may be useful in writing more readable tests for your command interpreters. It also supplies conversion functions that take either integer or 1-character-string arguments and return the same type. For example, returns the control character corresponding to its argument. There’s also a method to retrieve an entire string, . It isn’t used very often, because its functionality is quite limited; the only editing keys available are the backspace key and the Enter key, which terminates the string. It can optionally be limited to a fixed number of characters. # Get a 15-character string, with the cursor on the top line The Python module supplies something better. With it, you can turn a window into a text box that supports an Emacs-like set of keybindings. Various methods of class support editing with input validation and gathering the edit results either with or without trailing spaces. See the library documentation on for the details.\n\nThis HOWTO didn’t cover some advanced topics, such as screen-scraping or capturing mouse events from an xterm instance. But the Python library page for the curses modules is now pretty complete. You should browse it next. If you’re in doubt about the detailed behavior of any of the ncurses entry points, consult the manual pages for your curses implementation, whether it’s ncurses or a proprietary Unix vendor’s. The manual pages will document any quirks, and provide complete lists of all the functions, attributes, and characters available to you. Because the curses API is so large, some functions aren’t supported in the Python interface, not because they’re difficult to implement, but because no one has needed them yet. Feel free to add them and then submit a patch. Also, we don’t yet have support for the menu library associated with ncurses; feel free to add that. If you write an interesting little program, feel free to contribute it as another demo. We can always use more of them!"
    },
    {
        "link": "https://stackoverflow.com/questions/23003011/python-curses-without-clearing-screen",
        "document": "I'm not going to say \"It can't be done\", but I will say \"It can't be done\" with stock, out of the box Curses/NCurses.\n\nThe fundamental problem is that the curses library, when it is initialized, has no access to the current state of the terminal, notably what characters and glyphs are currently being displayed.\n\nIn the old days on a PC, the screen was memory mapped, so when a program ran it had access to the existing screen state in order to capture and perhaps restore it later.\n\nFor a generic smart terminal, that's not necessarily the case. On Linux, or the Mac, the terminal type is some kind of \"xterm\". On a windows console terminal, it's a ANSI style terminal (mind xterm is also a kind of ANSI terminal). Terminal type is the code used by the termcap/terminfo library that curses relies upon to know how to move the cursor, delete characters and lines, set color or reverse video, etc.\n\nAll of curses interaction with the screen is through the printing of ESCape sequences, rather than manipulating memory. It doesn't work with a framebuffer.\n\nIf you look at a list of XTerm escape sequences, you'll see there's nothing to report the contents of the screen back to the host program. However, there is an alternate frame buffer. An example of this is, perhaps, . When you edit a file with , takes over the entire screen. But when you exit, your original screen is restored. is switching to the alternate screen buffer, and does all of its operations there, and then restores the primary screen buffer on exit. But this is a simple switching exercise, does not \"know\", nor has access to, the contents of the original screen buffer.\n\nIf you use things like the Linux console (where you can switch screens using the FKeys), or a utility like GNU Screen, these are different. These rely on different concepts (device driver for the Linux console, and pseudo-terminals for GNU Screen), and the overall program maintains the state of each screen themselves. But this information isn't available to a generic program, that I know of. If it is, it's through some proprietary method and not Curses."
    },
    {
        "link": "https://stackoverflow.com/questions/654471/ncurses-initialization-without-clearing-the-screen",
        "document": "I am writing a program that's similar to a shell. Once started up, there's a prompt and you enter in some app-specific commands.\n\nSo far this works just fine. However, I want to add support for command history like in Bash, so the user could hit the up or down arrow and see previously entered commands.\n\nI have included the ncurses library, and I have done a simple hello world test with getch() to make sure the up and down arrows are reported correctly.\n\nThe thing that's bothering me is that it seems to be a requirement that I call initscr() which will clear the screen in order for me to use getch().\n\nOKAY SO THE QUESTION IS:\n\nDoes anybody know a way to use ncurses getch() function without calling initscr() first? If not, can I make it not clear the screen? Basically, I'm looking to have getch() act the same as getchar(), if that makes sense.\n\nEDIT: I think the best example of this is how Python runs in interactive mode."
    },
    {
        "link": "https://docs.python.org/3/howto/curses.html",
        "document": "The curses library supplies a terminal-independent screen-painting and keyboard-handling facility for text-based terminals; such terminals include VT100s, the Linux console, and the simulated terminal provided by various programs. Display terminals support various control codes to perform common operations such as moving the cursor, scrolling the screen, and erasing areas. Different terminals use widely differing codes, and often have their own minor quirks. In a world of graphical displays, one might ask “why bother”? It’s true that character-cell display terminals are an obsolete technology, but there are niches in which being able to do fancy things with them are still valuable. One niche is on small-footprint or embedded Unixes that don’t run an X server. Another is tools such as OS installers and kernel configurators that may have to run before any graphical support is available. The curses library provides fairly basic functionality, providing the programmer with an abstraction of a display containing multiple non-overlapping windows of text. The contents of a window can be changed in various ways—adding text, erasing it, changing its appearance—and the curses library will figure out what control codes need to be sent to the terminal to produce the right output. curses doesn’t provide many user-interface concepts such as buttons, checkboxes, or dialogs; if you need such features, consider a user interface library such as Urwid. The curses library was originally written for BSD Unix; the later System V versions of Unix from AT&T added many enhancements and new functions. BSD curses is no longer maintained, having been replaced by ncurses, which is an open-source implementation of the AT&T interface. If you’re using an open-source Unix such as Linux or FreeBSD, your system almost certainly uses ncurses. Since most current commercial Unix versions are based on System V code, all the functions described here will probably be available. The older versions of curses carried by some proprietary Unixes may not support everything, though. The Windows version of Python doesn’t include the module. A ported version called UniCurses is available. The Python module is a fairly simple wrapper over the C functions provided by curses; if you’re already familiar with curses programming in C, it’s really easy to transfer that knowledge to Python. The biggest difference is that the Python interface makes things simpler by merging different C functions such as , , and into a single method. You’ll see this covered in more detail later. This HOWTO is an introduction to writing text-mode programs with curses and Python. It doesn’t attempt to be a complete guide to the curses API; for that, see the Python library guide’s section on ncurses, and the C manual pages for ncurses. It will, however, give you the basic ideas.\n\nBefore doing anything, curses must be initialized. This is done by calling the function, which will determine the terminal type, send any required setup codes to the terminal, and create various internal data structures. If successful, returns a window object representing the entire screen; this is usually called after the name of the corresponding C variable. Usually curses applications turn off automatic echoing of keys to the screen, in order to be able to read keys and only display them under certain circumstances. This requires calling the function. Applications will also commonly need to react to keys instantly, without requiring the Enter key to be pressed; this is called cbreak mode, as opposed to the usual buffered input mode. Terminals usually return special keys, such as the cursor keys or navigation keys such as Page Up and Home, as a multibyte escape sequence. While you could write your application to expect such sequences and process them accordingly, curses can do it for you, returning a special value such as . To get curses to do the job, you’ll have to enable keypad mode. Terminating a curses application is much easier than starting one. You’ll need to call: to reverse the curses-friendly terminal settings. Then call the function to restore the terminal to its original operating mode. A common problem when debugging a curses application is to get your terminal messed up when the application dies without restoring the terminal to its previous state. In Python this commonly happens when your code is buggy and raises an uncaught exception. Keys are no longer echoed to the screen when you type them, for example, which makes using the shell difficult. In Python you can avoid these complications and make debugging much easier by importing the function and using it like this: The function takes a callable object and does the initializations described above, also initializing colors if color support is present. then runs your provided callable. Once the callable returns, will restore the original state of the terminal. The callable is called inside a … that catches exceptions, restores the state of the terminal, and then re-raises the exception. Therefore your terminal won’t be left in a funny state on exception and you’ll be able to read the exception’s message and traceback.\n\nWindows are the basic abstraction in curses. A window object represents a rectangular area of the screen, and supports methods to display text, erase it, allow the user to input strings, and so forth. The object returned by the function is a window object that covers the entire screen. Many programs may need only this single window, but you might wish to divide the screen into smaller windows, in order to redraw or clear them separately. The function creates a new window of a given size, returning the new window object. Note that the coordinate system used in curses is unusual. Coordinates are always passed in the order y,x, and the top-left corner of a window is coordinate (0,0). This breaks the normal convention for handling coordinates where the x coordinate comes first. This is an unfortunate difference from most other computer applications, but it’s been part of curses since it was first written, and it’s too late to change things now. Your application can determine the size of the screen by using the and variables to obtain the y and x sizes. Legal coordinates will then extend from to . When you call a method to display or erase text, the effect doesn’t immediately show up on the display. Instead you must call the method of window objects to update the screen. This is because curses was originally written with slow 300-baud terminal connections in mind; with these terminals, minimizing the time required to redraw the screen was very important. Instead curses accumulates changes to the screen and displays them in the most efficient manner when you call . For example, if your program displays some text in a window and then clears the window, there’s no need to send the original text because they’re never visible. In practice, explicitly telling curses to redraw a window doesn’t really complicate programming with curses much. Most programs go into a flurry of activity, and then pause waiting for a keypress or some other action on the part of the user. All you have to do is to be sure that the screen has been redrawn before pausing to wait for user input, by first calling or the method of some other relevant window. A pad is a special case of a window; it can be larger than the actual display screen, and only a portion of the pad displayed at a time. Creating a pad requires the pad’s height and width, while refreshing a pad requires giving the coordinates of the on-screen area where a subsection of the pad will be displayed. # These loops fill the pad with letters; addch() is # explained in the next section # Displays a section of the pad in the middle of the screen. # (0,0) : coordinate of upper-left corner of pad area to display. # (5,5) : coordinate of upper-left corner of window area to be filled # (20, 75) : coordinate of lower-right corner of window area to be The call displays a section of the pad in the rectangle extending from coordinate (5,5) to coordinate (20,75) on the screen; the upper left corner of the displayed section is coordinate (0,0) on the pad. Beyond that difference, pads are exactly like ordinary windows and support the same methods. If you have multiple windows and pads on screen there is a more efficient way to update the screen and prevent annoying screen flicker as each part of the screen gets updated. actually does two things:\n• None Calls the method of each window to update an underlying data structure representing the desired state of the screen.\n• None Calls the function function to change the physical screen to match the desired state recorded in the data structure. Instead you can call on a number of windows to update the data structure, and then call to update the screen.\n\nFrom a C programmer’s point of view, curses may sometimes look like a twisty maze of functions, all subtly different. For example, displays a string at the current cursor location in the window, while moves to a given y,x coordinate first before displaying the string. is just like , but allows specifying a window to use instead of using by default. allows specifying both a window and a coordinate. Fortunately the Python interface hides all these details. is a window object like any other, and methods such as accept multiple argument forms. Usually there are four different forms. Display the string str or character ch at the current position Display the string str or character ch, using attribute attr at the current position Move to position y,x within the window, and display str or ch Move to position y,x within the window, and display str or ch, using attribute attr Attributes allow displaying text in highlighted forms such as boldface, underline, reverse code, or in color. They’ll be explained in more detail in the next subsection. The method takes a Python string or bytestring as the value to be displayed. The contents of bytestrings are sent to the terminal as-is. Strings are encoded to bytes using the value of the window’s attribute; this defaults to the default system encoding as returned by . The methods take a character, which can be either a string of length 1, a bytestring of length 1, or an integer. Constants are provided for extension characters; these constants are integers greater than 255. For example, is a +/- symbol, and is the upper left corner of a box (handy for drawing borders). You can also use the appropriate Unicode character. Windows remember where the cursor was left after the last operation, so if you leave out the y,x coordinates, the string or character will be displayed wherever the last operation left off. You can also move the cursor with the method. Because some terminals always display a flashing cursor, you may want to ensure that the cursor is positioned in some location where it won’t be distracting; it can be confusing to have the cursor blinking at some apparently random location. If your application doesn’t need a blinking cursor at all, you can call to make it invisible. For compatibility with older curses versions, there’s a function that’s a synonym for . When bool is true, the curses library will attempt to suppress the flashing cursor, and you won’t need to worry about leaving it in odd locations. Characters can be displayed in different ways. Status lines in a text-based application are commonly shown in reverse video, or a text viewer may need to highlight certain words. curses supports this by allowing you to specify an attribute for each cell on the screen. An attribute is an integer, each bit representing a different attribute. You can try to display text with multiple attribute bits set, but curses doesn’t guarantee that all the possible combinations are available, or that they’re all visually distinct. That depends on the ability of the terminal being used, so it’s safest to stick to the most commonly available attributes, listed here. The best highlighting mode available So, to display a reverse-video status line on the top line of the screen, you could code: The curses library also supports color on those terminals that provide it. The most common such terminal is probably the Linux console, followed by color xterms. To use color, you must call the function soon after calling , to initialize the default color set (the function does this automatically). Once that’s done, the function returns TRUE if the terminal in use can actually display color. (Note: curses uses the American spelling ‘color’, instead of the Canadian/British spelling ‘colour’. If you’re used to the British spelling, you’ll have to resign yourself to misspelling it for the sake of these functions.) The curses library maintains a finite number of color pairs, containing a foreground (or text) color and a background color. You can get the attribute value corresponding to a color pair with the function; this can be bitwise-OR’ed with other attributes such as , but again, such combinations are not guaranteed to work on all terminals. An example, which displays a line of text using color pair 1: As I said before, a color pair consists of a foreground and background color. The function changes the definition of color pair n, to foreground color f and background color b. Color pair 0 is hard-wired to white on black, and cannot be changed. Colors are numbered, and initializes 8 basic colors when it activates color mode. They are: 0:black, 1:red, 2:green, 3:yellow, 4:blue, 5:magenta, 6:cyan, and 7:white. The module defines named constants for each of these colors: , , and so forth. Let’s put all this together. To change color 1 to red text on a white background, you would call: When you change a color pair, any text already displayed using that color pair will change to the new colors. You can also display new text in this color with: Very fancy terminals can change the definitions of the actual colors to a given RGB value. This lets you change color 1, which is usually red, to purple or blue or any other color you like. Unfortunately, the Linux console doesn’t support this, so I’m unable to try it out, and can’t provide any examples. You can check if your terminal can do this by calling , which returns if the capability is there. If you’re lucky enough to have such a talented terminal, consult your system’s man pages for more information.\n\nThe C curses library offers only very simple input mechanisms. Python’s module adds a basic text-input widget. (Other libraries such as Urwid have more extensive collections of widgets.) There are two methods for getting input from a window:\n• None refreshes the screen and then waits for the user to hit a key, displaying the key if has been called earlier. You can optionally specify a coordinate to which the cursor should be moved before pausing.\n• None does the same thing but converts the integer to a string. Individual characters are returned as 1-character strings, and special keys such as function keys return longer strings containing a key name such as or . It’s possible to not wait for the user using the window method. After , and for the window become non-blocking. To signal that no input is ready, returns (a value of -1) and raises an exception. There’s also a function, which can be used to (in effect) set a timer on each ; if no input becomes available within a specified delay (measured in tenths of a second), curses raises an exception. The method returns an integer; if it’s between 0 and 255, it represents the ASCII code of the key pressed. Values greater than 255 are special keys such as Page Up, Home, or the cursor keys. You can compare the value returned to constants such as , , or . The main loop of your program may look something like this: The module supplies ASCII class membership functions that take either integer or 1-character string arguments; these may be useful in writing more readable tests for such loops. It also supplies conversion functions that take either integer or 1-character-string arguments and return the same type. For example, returns the control character corresponding to its argument. There’s also a method to retrieve an entire string, . It isn’t used very often, because its functionality is quite limited; the only editing keys available are the backspace key and the Enter key, which terminates the string. It can optionally be limited to a fixed number of characters. # Get a 15-character string, with the cursor on the top line The module supplies a text box that supports an Emacs-like set of keybindings. Various methods of the class support editing with input validation and gathering the edit results either with or without trailing spaces. Here’s an example: # Let the user edit until Ctrl-G is struck. See the library documentation on for more details."
    },
    {
        "link": "https://docs.python.org/3/library/curses.html",
        "document": "The module provides an interface to the curses library, the de-facto standard for portable advanced terminal handling.\n\nWhile curses is most widely used in the Unix environment, versions are available for Windows, DOS, and possibly other systems as well. This extension module is designed to match the API of ncurses, an open-source curses library hosted on Linux and the BSD variants of Unix.\n\nThe module defines the following exception: Whenever x or y arguments to a function or a method are optional, they default to the current cursor location. Whenever attr is optional, it defaults to . The module defines the following functions: Return the output speed of the terminal in bits per second. On software terminal emulators it will have a fixed high value. Included for historical reasons; in former times, it was used to write output loops for time delays and occasionally to change interfaces depending on the line speed. Return or , depending on whether the programmer can change the colors displayed by the terminal. Enter cbreak mode. In cbreak mode (sometimes called “rare” mode) normal tty line buffering is turned off and characters are available to be read one by one. However, unlike raw mode, special characters (interrupt, quit, suspend, and flow control) retain their effects on the tty driver and calling program. Calling first then leaves the terminal in cbreak mode. Return the intensity of the red, green, and blue (RGB) components in the color color_number, which must be between and . Return a 3-tuple, containing the R,G,B values for the given color, which will be between (no component) and (maximum amount of component). Return the attribute value for displaying text in the specified color pair. Only the first 256 color pairs are supported. This attribute value can be combined with , , and the other attributes. is the counterpart to this function. Set the cursor state. visibility can be set to , , or , for invisible, normal, or very visible. If the terminal supports the visibility requested, return the previous cursor state; otherwise raise an exception. On many terminals, the “visible” mode is an underline cursor and the “very visible” mode is a block cursor. Save the current terminal mode as the “program” mode, the mode when the running program is using curses. (Its counterpart is the “shell” mode, for when the program is not in curses.) Subsequent calls to will restore this mode. Save the current terminal mode as the “shell” mode, the mode when the running program is not using curses. (Its counterpart is the “program” mode, when the program is using curses capabilities.) Subsequent calls to will restore this mode. Update the physical screen. The curses library keeps two data structures, one representing the current physical screen contents and a virtual screen representing the desired next state. The ground updates the physical screen to match the virtual screen. The virtual screen may be updated by a call after write operations such as have been performed on a window. The normal call is simply followed by ; if you have to update multiple windows, you can speed performance and perhaps reduce screen flicker by issuing calls on all windows, followed by a single . Enter echo mode. In echo mode, each character input is echoed to the screen as it is entered. De-initialize the library, and return terminal to normal status. Return the user’s current erase character as a one-byte bytes object. Under Unix operating systems this is a property of the controlling tty of the curses program, and is not set by the curses library itself. The routine, if used, must be called before is called. The effect is that, during those calls, is set to ; the capabilities , , , , , , are disabled; and the string is set to the value of . The effect is that the cursor is confined to the current line, and so are screen updates. This may be used for enabling character-at-a-time line editing without touching the rest of the screen. Flash the screen. That is, change it to reverse-video and then change it back in a short interval. Some people prefer such as ‘visible bell’ to the audible attention signal produced by . Flush all input buffers. This throws away any typeahead that has been typed by the user and has not yet been processed by the program. After returns to signal a mouse event, this method should be called to retrieve the queued mouse event, represented as a 5-tuple . id is an ID value used to distinguish multiple devices, and x, y, z are the event’s coordinates. (z is currently unused.) bstate is an integer value whose bits will be set to indicate the type of event, and will be the bitwise OR of one or more of the following constants, where n is the button number from 1 to 5: , , , , , , , . Changed in version 3.10: The constants are now exposed if they are provided by the underlying curses library. Return the current coordinates of the virtual screen cursor as a tuple . If is currently , then return . Read window related data stored in the file by an earlier call. The routine then creates and initializes a new window using that data, returning the new window object. Return if the terminal can display colors; otherwise, return . Return if the module supports extended colors; otherwise, return . Extended color support allows more than 256 color pairs for terminals that support more than 16 colors (e.g. xterm-256color). Return if the terminal has insert- and delete-character capabilities. This function is included for historical reasons only, as all modern software terminal emulators have such capabilities. Return if the terminal has insert- and delete-line capabilities, or can simulate them using scrolling regions. This function is included for historical reasons only, as all modern software terminal emulators have such capabilities. Take a key value ch, and return if the current terminal type recognizes a key with that value. Used for half-delay mode, which is similar to cbreak mode in that characters typed by the user are immediately available to the program. However, after blocking for tenths tenths of seconds, raise an exception if nothing has been typed. The value of tenths must be a number between and . Use to leave half-delay mode. Change the definition of a color, taking the number of the color to be changed followed by three RGB values (for the amounts of red, green, and blue components). The value of color_number must be between and . Each of r, g, b, must be a value between and . When is used, all occurrences of that color on the screen immediately change to the new definition. This function is a no-op on most terminals; it is active only if returns . Change the definition of a color-pair. It takes three arguments: the number of the color-pair to be changed, the foreground color number, and the background color number. The value of pair_number must be between and (the color pair is wired to white on black and cannot be changed). The value of fg and bg arguments must be between and , or, after calling , . If the color-pair was previously initialized, the screen is refreshed and all occurrences of that color-pair are changed to the new definition. Initialize the library. Return a window object which represents the whole screen. If there is an error opening the terminal, the underlying curses library may cause the interpreter to exit. Return if would modify the window structure, otherwise. Return if has been called (that is, the curses library has been deinitialized). Return the name of the key numbered k as a bytes object. The name of a key generating printable ASCII character is the key’s character. The name of a control-key combination is a two-byte bytes object consisting of a caret ( ) followed by the corresponding printable ASCII character. The name of an alt-key combination (128–255) is a bytes object consisting of the prefix followed by the name of the corresponding ASCII character. Return the user’s current line kill character as a one-byte bytes object. Under Unix operating systems this is a property of the controlling tty of the curses program, and is not set by the curses library itself. Return a bytes object containing the terminfo long name field describing the current terminal. The maximum length of a verbose description is 128 characters. It is defined only after the call to . If flag is , allow 8-bit characters to be input. If flag is , allow only 7-bit chars. Set the maximum time in milliseconds that can elapse between press and release events in order for them to be recognized as a click, and return the previous interval value. The default value is 200 milliseconds, or one fifth of a second. Set the mouse events to be reported, and return a tuple . availmask indicates which of the specified mouse events can be reported; on complete failure it returns . oldmask is the previous value of the given window’s mouse event mask. If this function is never called, no mouse events are ever reported. Create and return a pointer to a new pad data structure with the given number of lines and columns. Return a pad as a window object. A pad is like a window, except that it is not restricted by the screen size, and is not necessarily associated with a particular part of the screen. Pads can be used when a large window is needed, and only a part of the window will be on the screen at one time. Automatic refreshes of pads (such as from scrolling or echoing of input) do not occur. The and methods of a pad require 6 arguments to specify the part of the pad to be displayed and the location on the screen to be used for the display. The arguments are pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol; the p arguments refer to the upper left corner of the pad region to be displayed and the s arguments define a clipping box on the screen within which the pad region is to be displayed. Return a new window, whose left-upper corner is at , and whose height/width is nlines/ncols. By default, the window will extend from the specified position to the lower right corner of the screen. Enter newline mode. This mode translates the return key into newline on input, and translates newline into return and line-feed on output. Newline mode is initially on. Leave echo mode. Echoing of input characters is turned off. Leave newline mode. Disable translation of return into newline on input, and disable low-level translation of newline into newline/return on output (but this does not change the behavior of , which always does the equivalent of return and line feed on the virtual screen). With translation off, curses can sometimes speed up vertical motion a little; also, it will be able to detect the return key on input. When the routine is used, normal flush of input and output queues associated with the , and characters will not be done. You may want to call in a signal handler if you want output to continue as though the interrupt had not occurred, after the handler exits. Return a tuple containing the colors for the requested color pair. The value of pair_number must be between and . Return the number of the color-pair set by the attribute value attr. is the counterpart to this function. Equivalent to ; emit the value of a specified terminfo capability for the current terminal. Note that the output of always goes to standard output. If flag is , the effect is the same as calling . If flag is , or no argument is provided, the queues will be flushed when these control characters are read. Enter raw mode. In raw mode, normal line buffering and processing of interrupt, quit, suspend, and flow control keys are turned off; characters are presented to curses input functions one by one. Restore the terminal to “program” mode, as previously saved by . Restore the terminal to “shell” mode, as previously saved by . Restore the state of the terminal modes to what it was at the last call to . Backend function used by , performing most of the work; when resizing the windows, blank-fills the areas that are extended. The calling application should fill in these areas with appropriate data. The function attempts to resize all windows. However, due to the calling convention of pads, it is not possible to resize these without additional interaction with the application. Resize the standard and current windows to the specified dimensions, and adjusts other bookkeeping data used by the curses library that record the window dimensions (in particular the SIGWINCH handler). Save the current state of the terminal modes in a buffer, usable by . Retrieves the value set by . Sets the number of milliseconds to wait after reading an escape character, to distinguish between an individual escape character entered on the keyboard from escape sequences sent by cursor and function keys. Retrieves the value set by . Sets the number of columns used by the curses library when converting a tab character to spaces as it adds the tab to a window. Set the virtual screen cursor to y, x. If y and x are both , then is set . Initialize the terminal. term is a string giving the terminal name, or ; if omitted or , the value of the environment variable will be used. fd is the file descriptor to which any initialization sequences will be sent; if not supplied or , the file descriptor for will be used. Must be called if the programmer wants to use colors, and before any other color manipulation routine is called. It is good practice to call this routine right after . initializes eight basic colors (black, red, green, yellow, blue, magenta, cyan, and white), and two global variables in the module, and , containing the maximum number of colors and color-pairs the terminal can support. It also restores the colors on the terminal to the values they had when the terminal was just turned on. Return a logical OR of all video attributes supported by the terminal. This information is useful when a curses program needs complete control over the appearance of the screen. Return the value of the environment variable , as a bytes object, truncated to 14 characters. Return the value of the Boolean capability corresponding to the terminfo capability name capname as an integer. Return the value if capname is not a Boolean capability, or if it is canceled or absent from the terminal description. Return the value of the numeric capability corresponding to the terminfo capability name capname as an integer. Return the value if capname is not a numeric capability, or if it is canceled or absent from the terminal description. Return the value of the string capability corresponding to the terminfo capability name capname as a bytes object. Return if capname is not a terminfo “string capability”, or is canceled or absent from the terminal description. Instantiate the bytes object str with the supplied parameters, where str should be a parameterized string obtained from the terminfo database. E.g. could result in , the exact result depending on terminal type. Specify that the file descriptor fd be used for typeahead checking. If fd is , then no typeahead checking is done. The curses library does “line-breakout optimization” by looking for typeahead periodically while updating the screen. If input is found, and it is coming from a tty, the current update is postponed until refresh or doupdate is called again, allowing faster response to commands typed in advance. This function allows specifying a different file descriptor for typeahead checking. Return a bytes object which is a printable representation of the character ch. Control characters are represented as a caret followed by the character, for example as . Printing characters are left as they are. Push ch so the next will return it. Only one ch can be pushed before is called. Update the and module variables. Useful for detecting manual screen resize. Push ch so the next will return it. Only one ch can be pushed before is called. Push a event onto the input queue, associating the given state data with it. If used, this function should be called before or newterm are called. When flag is , the values of lines and columns specified in the terminfo database will be used, even if environment variables and (used by default) are set, or if curses is running in a window (in which case default behavior would be to use the window size if and are not set). Allow use of default values for colors on terminals supporting this feature. Use this to support transparency in your application. The default color is assigned to the color number . After calling this function, initializes, for instance, color pair x to a red foreground color on the default background. Initialize curses and call another callable object, func, which should be the rest of your curses-using application. If the application raises an exception, this function will restore the terminal to a sane state before re-raising the exception and generating a traceback. The callable object func is then passed the main window ‘stdscr’ as its first argument, followed by any other arguments passed to . Before calling func, turns on cbreak mode, turns off echo, enables the terminal keypad, and initializes colors if the terminal has color support. On exit (whether normally or by exception) it restores cooked mode, turns on echo, and disables the terminal keypad.\n\nWindow objects, as returned by and above, have the following methods and attributes: Paint character ch at with attributes attr, overwriting any character previously painted at that location. By default, the character position and attributes are the current settings for the window object. Writing outside the window, subwindow, or pad raises a . Attempting to write to the lower right corner of a window, subwindow, or pad will cause an exception to be raised after the character is printed. Paint at most n characters of the character string str at with attributes attr, overwriting anything previously on the display. Paint the character string str at with attributes attr, overwriting anything previously on the display.\n• None Writing outside the window, subwindow, or pad raises . Attempting to write to the lower right corner of a window, subwindow, or pad will cause an exception to be raised after the string is printed.\n• None A bug in ncurses, the backend for this Python module, can cause SegFaults when resizing windows. This is fixed in ncurses-6.1-20190511. If you are stuck with an earlier ncurses, you can avoid triggering this if you do not call with a str that has embedded newlines. Instead, call separately for each line. Remove attribute attr from the “background” set applied to all writes to the current window. Add attribute attr from the “background” set applied to all writes to the current window. Set the “background” set of attributes to attr. This set is initially (no attributes). Set the background property of the window to the character ch, with attributes attr. The change is then applied to every character position in that window:\n• None The attribute of every character in the window is changed to the new background attribute.\n• None Wherever the former background character appears, it is changed to the new background character. Set the window’s background. A window’s background consists of a character and any combination of attributes. The attribute part of the background is combined (OR’ed) with all non-blank characters that are written into the window. Both the character and attribute parts of the background are combined with the blank characters. The background becomes a property of the character and moves with the character through any scrolling and insert/delete line/character operations. Draw a border around the edges of the window. Each parameter specifies the character to use for a specific part of the border; see the table below for more details. A value for any parameter will cause the default character to be used for that parameter. Keyword parameters can not be used. The defaults are listed in this table: Similar to , but both ls and rs are vertch and both ts and bs are horch. The default corner characters are always used by this function. Set the attributes of num characters at the current cursor position, or at position if supplied. If num is not given or is , the attribute will be set on all the characters to the end of the line. This function moves cursor to position if supplied. The changed line will be touched using the method so that the contents will be redisplayed by the next window refresh. Like , but also cause the whole window to be repainted upon next call to . If flag is , the next call to will clear the window completely. Erase from cursor to the end of the window: all lines below the cursor are deleted, and then the equivalent of is performed. Erase from cursor to the end of the line. Update the current cursor position of all the ancestors of the window to reflect the current cursor position of the window. Delete the line under the cursor. All following lines are moved up by one line. An abbreviation for “derive window”, is the same as calling , except that begin_y and begin_x are relative to the origin of the window, rather than relative to the entire screen. Return a window object for the derived window. Add character ch with attribute attr, and immediately call on the window. Test whether the given pair of screen-relative character-cell coordinates are enclosed by the given window, returning or . It is useful for determining what subset of the screen windows enclose the location of a mouse event. Changed in version 3.10: Previously it returned or instead of or . Encoding used to encode method arguments (Unicode strings and characters). The encoding attribute is inherited from the parent window when a subwindow is created, for example with . By default, current locale encoding is used (see ). Get a character. Note that the integer returned does not have to be in ASCII range: function keys, keypad keys and so on are represented by numbers higher than 255. In no-delay mode, return if there is no input, otherwise wait until a key is pressed. Get a wide character. Return a character for most keys, or an integer for function keys, keypad keys, and other special keys. In no-delay mode, raise an exception if there is no input. Get a character, returning a string instead of an integer, as does. Function keys, keypad keys and other special keys return a multibyte string containing the key name. In no-delay mode, raise an exception if there is no input. Return a tuple of the height and width of the window. Return the beginning coordinates of this window relative to its parent window as a tuple . Return if this window has no parent. Read a bytes object from the user, with primitive line editing capacity. Return a tuple of current cursor position relative to the window’s upper-left corner. Display a horizontal line starting at with length n consisting of the character ch. If flag is , curses no longer considers using the hardware insert/delete character feature of the terminal; if flag is , use of character insertion and deletion is enabled. When curses is first initialized, use of character insert/delete is enabled by default. If flag is , will try and use hardware line editing facilities. Otherwise, line insertion/deletion are disabled. If flag is , any change in the window image automatically causes the window to be refreshed; you no longer have to call yourself. However, it may degrade performance considerably, due to repeated calls to wrefresh. This option is disabled by default. Return the character at the given position in the window. The bottom 8 bits are the character proper, and upper bits are the attributes. Paint character ch at with attributes attr, moving the line from position x right by one character. Insert nlines lines into the specified window above the current line. The nlines bottom lines are lost. For negative nlines, delete nlines lines starting with the one under the cursor, and move the remaining lines up. The bottom nlines lines are cleared. The current cursor position remains the same. Insert a blank line under the cursor. All following lines are moved down by one line. Insert a character string (as many characters as will fit on the line) before the character under the cursor, up to n characters. If n is zero or negative, the entire string is inserted. All characters to the right of the cursor are shifted right, with the rightmost characters on the line being lost. The cursor position does not change (after moving to y, x, if specified). Insert a character string (as many characters as will fit on the line) before the character under the cursor. All characters to the right of the cursor are shifted right, with the rightmost characters on the line being lost. The cursor position does not change (after moving to y, x, if specified). Return a bytes object of characters, extracted from the window starting at the current cursor position, or at y, x if specified. Attributes are stripped from the characters. If n is specified, returns a string at most n characters long (exclusive of the trailing NUL). Return if the specified line was modified since the last call to ; otherwise return . Raise a exception if line is not valid for the given window. Return if the specified window was modified since the last call to ; otherwise return . If flag is , escape sequences generated by some keys (keypad, function keys) will be interpreted by . If flag is , escape sequences will be left as is in the input stream. If flag is , cursor is left where it is on update, instead of being at “cursor position.” This reduces cursor movement where possible. If possible the cursor will be made invisible. If flag is , cursor will always be at “cursor position” after an update. Move the window inside its parent window. The screen-relative parameters of the window are not changed. This routine is used to display different parts of the parent window at the same physical position on the screen. Move the window so its upper-left corner is at . If flag is , will be non-blocking. If flag is , escape sequences will not be timed out. If flag is , after a few milliseconds, an escape sequence will not be interpreted, and will be left in the input stream as is. Mark for refresh but wait. This function updates the data structure representing the desired state of the window, but does not force an update of the physical screen. To accomplish that, call . Overlay the window on top of destwin. The windows need not be the same size, only the overlapping region is copied. This copy is non-destructive, which means that the current background character does not overwrite the old contents of destwin. To get fine-grained control over the copied region, the second form of can be used. sminrow and smincol are the upper-left coordinates of the source window, and the other variables mark a rectangle in the destination window. Overwrite the window on top of destwin. The windows need not be the same size, in which case only the overlapping region is copied. This copy is destructive, which means that the current background character overwrites the old contents of destwin. To get fine-grained control over the copied region, the second form of can be used. sminrow and smincol are the upper-left coordinates of the source window, the other variables mark a rectangle in the destination window. Write all data associated with the window into the provided file object. This information can be later retrieved using the function. Indicate that the num screen lines, starting at line beg, are corrupted and should be completely redrawn on the next call. Touch the entire window, causing it to be completely redrawn on the next call. The 6 optional arguments can only be specified when the window is a pad created with . The additional parameters are needed to indicate what part of the pad and screen are involved. pminrow and pmincol specify the upper left-hand corner of the rectangle to be displayed in the pad. sminrow, smincol, smaxrow, and smaxcol specify the edges of the rectangle to be displayed on the screen. The lower right-hand corner of the rectangle to be displayed in the pad is calculated from the screen coordinates, since the rectangles must be the same size. Both rectangles must be entirely contained within their respective structures. Negative values of pminrow, pmincol, sminrow, or smincol are treated as if they were zero. Reallocate storage for a curses window to adjust its dimensions to the specified values. If either dimension is larger than the current values, the window’s data is filled with blanks that have the current background rendition (as set by ) merged into them. Scroll the screen or scrolling region upward by lines lines. Control what happens when the cursor of a window is moved off the edge of the window or scrolling region, either as a result of a newline action on the bottom line, or typing the last character of the last line. If flag is , the cursor is left on the bottom line. If flag is , the window is scrolled up one line. Note that in order to get the physical scrolling effect on the terminal, it is also necessary to call . Set the scrolling region from line top to line bottom. All scrolling actions will take place in this region. Turn off the standout attribute. On some terminals this has the side effect of turning off all attributes. Return a sub-window, whose upper-left corner is at , and whose width/height is ncols/nlines. Return a sub-window, whose upper-left corner is at , and whose width/height is ncols/nlines. By default, the sub-window will extend from the specified position to the lower right corner of the window. Touch each location in the window that has been touched in any of its ancestor windows. This routine is called by , so it should almost never be necessary to call it manually. If flag is , then is called automatically whenever there is a change in the window. Touch all locations in ancestors of the window that have been changed in the window. Set blocking or non-blocking read behavior for the window. If delay is negative, blocking read is used (which will wait indefinitely for input). If delay is zero, then non-blocking read is used, and will return if no input is waiting. If delay is positive, then will block for delay milliseconds, and return if there is still no input at the end of that time. Pretend count lines have been changed, starting with line start. If changed is supplied, it specifies whether the affected lines are marked as having been changed (changed ) or unchanged (changed ). Pretend the whole window has been changed, for purposes of drawing optimizations. Mark all lines in the window as unchanged since the last call to . Display a vertical line starting at with length n consisting of the character ch with attributes attr.\n\nThe module defines the following data members: Some curses routines that return an integer, such as , return upon failure. Some curses routines that return an integer, such as , return upon success. A bytes object representing the current version of the module. A named tuple containing the three components of the ncurses library version: major, minor, and patch. All values are integers. The components can also be accessed by name, so is equivalent to and so on. Availability: if the ncurses library is used. The maximum number of colors the terminal can support. It is defined only after the call to . The maximum number of color pairs the terminal can support. It is defined only after the call to . The width of the screen, i.e., the number of columns. It is defined only after the call to . Updated by , and . The height of the screen, i.e., the number of lines. It is defined only after the call to . Updated by , and . Some constants are available to specify character cell attributes. The exact constants available are system dependent. Several constants are available to extract corresponding attributes returned by some methods. Keys are referred to by integer constants with names starting with . The exact keycaps available are system dependent. Function keys. Up to 64 function keys are supported. On VT100s and their software emulations, such as X terminal emulators, there are normally at least four function keys ( , , , ) available, and the arrow keys mapped to , , and in the obvious way. If your machine has a PC keyboard, it is safe to expect arrow keys and twelve function keys (older PC keyboards may have only ten function keys); also, the following keypad mappings are standard: The following table lists characters from the alternate character set. These are inherited from the VT100 terminal, and will generally be available on software emulations such as X terminals. When there is no graphic available, curses falls back on a crude printable ASCII approximation. These are available only after has been called. alternate name for upper right corner alternate name for lower right corner alternate name for right tee alternate name for crossover or big plus The following table lists mouse button constants used by : Shift was down during button state change Control was down during button state change Control was down during button state change Changed in version 3.10: The constants are now exposed if they are provided by the underlying curses library. The following table lists the predefined colors:"
    },
    {
        "link": "https://wasimlorgat.com/posts/editor.html",
        "document": ""
    }
]