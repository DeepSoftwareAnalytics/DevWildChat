[
    {
        "link": "https://docs.idris-lang.org/en/latest/effects/depeff.html",
        "document": "In the programs we have seen so far, the available effects have remained constant. Sometimes, however, an operation can change the available effects. The simplest example occurs when we have a state with a dependent type—adding an element to a vector also changes its type, for example, since its length is explicit in the type. In this section, we will see how the library supports this. Firstly, we will see how states with dependent types can be implemented. Secondly, we will see how the effects can depend on the result of an effectful operation. Finally, we will see how this can be used to implement a type-safe and resource-safe protocol for file management.\n\nSuppose we have a function which reads input from the console, converts it to an integer, and adds it to a list which is stored in a . It might look something like the following: But what if, instead of a list of integers, we would like to store a , maintaining the length in the type? This will not type check! Although the vector has length on entry to , it has length on exit. The library allows us to express this as follows: The type means that the operation begins with effects available, and ends with effects available. We have used to update the state, where the suffix indicates that the type is being updated as well as the value. It has the following type:\n\nOften, whether a state is updated could depend on the success or otherwise of an operation. In our example, we might wish to update the vector only if the input is a valid integer (i.e. all digits). As a first attempt, we could try the following, returning a which indicates success: Unfortunately, this will not type check because the vector does not get extended in both branches of the ! Clearly, the size of the resulting vector depends on whether or not the value read from the user was valid. We can express this in the type: n , ok ok n , n , readInt x trim getStr all isDigit unpack x pureM putM cast x get pureM Using rather than allows the output effects to be calculated from the value given. Its type is: When using , we will have to check its return value in order to know what the new set of effects is. For example, to read a set number of values into a vector, we could write the following: The analysis on the result of means that we know in each branch whether reading the integer succeeded, and therefore how many values still need to be read into the vector. What this means in practice is that the type system has verified that a necessary dynamic check (i.e. whether reading a value succeeded) has indeed been done. Only will work here. We cannot use because the and branches must have the same type. The construct, however, abstracts over the value being inspected in the type of each branch.\n\nA practical use for dependent effects is in specifying resource usage protocols and verifying that they are executed correctly. For example, file management follows a resource usage protocol with the following (informally specified) requirements:\n• It is necessary to open a file for reading before reading it\n• Opening may fail, so the programmer should check whether opening was successful\n• A file which is open for reading must not be written to, and vice versa\n• When finished, an open file handle should be closed\n• When a file is closed, its handle should no longer be used These requirements can be expressed formally by creating a effect parameterised over a file handle state, which is either empty, open for reading, or open for writing. The effect’s definition is given below. This effect is mainly for illustrative purposes. Typically we would also like to support random access files and better reporting of error conditions. Moreover, the effect in the module of the library uses slightly more complicated types to support erroneous behaviour of each function and to support more compilcated modes of opening, like for reading and writing, appending or truncating. In particular, consider the type of : This returns a which indicates whether opening the file was successful. The resulting state depends on whether the operation was successful; if so, we have a file handle open for the stated purpose, and if not, we have no file handle. By analysis on the result, we continue the protocol accordingly. Given a function , above, which reads from an open file until reaching the end, we can write a program which opens a file, reads it, then displays the contents and closes it, as follows, correctly following the protocol: The type of , with in its effect list, indicates that any use of the file resource will follow the protocol correctly (i.e. it both begins and ends with an empty resource). If we fail to follow the protocol correctly (perhaps by forgetting to close the file, failing to check that succeeded, or opening the file for writing) then we will get a compile-time error. For example, changing to yields a compile-time error of the following form: In other words: when reading a file, we need a file which is open for reading, but the effect list contains a effect carrying a file open for writing.\n\nIt might seem that having to test each potentially failing operation with a clause could lead to ugly code, with lots of nested case blocks. Many languages support exceptions to improve this, but unfortunately exceptions may not allow completely clean resource management—for example, guaranteeing that any which did succeed has a corresponding close. Idris supports pattern-matching bindings, such as the following: This also has a problem: we are no longer dealing with the case where opening a file failed! The solution is to extend the pattern-matching binding syntax to give brief clauses for failing matches. Here, for example, we could write: This is exactly equivalent to the definition with the explicit . In general, in a -block, the syntax: There can be several , separated by a vertical bar . For example, there is a effect which supports reading command line arguments, among other things (see Appendix Effects Summary). To read command line arguments, we can use : A main program can read command line arguments as follows, where in the list which is returned, the first element is the executable name and the second is an expected argument: Unfortunately, this will not fail gracefully if no argument is given, or if too many arguments are given. We can use pattern matching bind alternatives to give a better (more informative) error: If does not return something of the form the alternative which does match is executed instead, and that value returned."
    },
    {
        "link": "https://docs.idris-lang.org/en/latest/tutorial/typesfuns.html",
        "document": "Idris defines several primitive types: , and for numeric operations, and for text manipulation, and which represents foreign pointers. There are also several data types declared in the library, including , with values and . We can declare some constants with these types. Enter the following into a file and load it into the Idris interactive environment by typing : An Idris file consists of an optional module declaration (here ) followed by an optional list of imports and a collection of declarations and definitions. In this example no imports have been specified. However Idris programs can consist of several modules and the definitions in each module each have their own namespace. This is discussed further in Section Modules and Namespaces. When writing Idris programs both the order in which definitions are given and indentation are significant. Functions and data types must be defined before use, incidentally each definition must have a type declaration, for example see , , from the above listing. New declarations must begin at the same level of indentation as the preceding declaration. Alternatively, a semicolon can be used to terminate declarations. A library module is automatically imported by every Idris program, including facilities for IO, arithmetic, data structures and various common functions. The prelude defines several arithmetic and comparison operators, which we can use at the prompt. Evaluating things at the prompt gives an answer, and the type of the answer. For example: All of the usual arithmetic and comparison operators are defined for the primitive types. They are overloaded using interfaces, as we will discuss in Section Interfaces and can be extended to work on user defined types. Boolean expressions can be tested with the construct, for example:\n\nData types are declared in a similar way and with similar syntax to Haskell. Natural numbers and lists, for example, can be declared as follows: The above declarations are taken from the standard library. Unary natural numbers can be either zero ( ), or the successor of another natural number ( ). Lists can either be empty ( ) or a value added to the front of another list ( ). Data types may also be declared by giving just the types of the constructors. These definitions are equivalent to those above: This syntax is more verbose, but more flexible, and is used for types that can’t be described with the simpler syntax. In the declaration for , we used an infix operator . New operators such as this can be added using a fixity declaration, as follows: Functions, data constructors and type constructors may all be given infix operators as names. They may be used in prefix form if enclosed in brackets, e.g. . Infix operators can use any of the symbols: Some operators built from these symbols can’t be user defined. These are , , , , , , , , , , , , , and .\n\nFunctions are implemented by pattern matching, again using a similar syntax to Haskell. The main difference is that Idris requires type declarations for all functions, using a single colon (rather than Haskell’s double colon ). Some natural number arithmetic functions can be defined as follows, again taken from the standard library: plus y y plus k y plus k y mult y mult k y plus y mult k y The standard arithmetic operators and are also overloaded for use by , and are implemented using the above functions. Unlike Haskell, there is no restriction on whether types and function names must begin with a capital letter or not. Function names ( and above), data constructors ( , , and ) and type constructors ( and ) are all part of the same namespace. By convention, however, data types and constructor names typically begin with a capital letter. We can test these functions at the Idris prompt: When displaying an element of such as , Idris displays it as . The result of is actually which is the natural number . This can be checked at the Idris prompt: Like arithmetic operations, integer literals are also overloaded using interfaces, meaning that we can also test the functions as follows: You may wonder, by the way, why we have unary natural numbers when our computers have perfectly good integer arithmetic built in. The reason is primarily that unary numbers have a very convenient structure which is easy to reason about, and easy to relate to other data structures as we will see later. Nevertheless, we do not want this convenience to be at the expense of efficiency. Fortunately, Idris knows about the relationship between (and similarly structured types) and numbers. This means it can optimise the representation, and functions such as and . Functions can also be defined locally using clauses. For example, to define a function which reverses a list, we can use an auxiliary function which accumulates the new, reversed list, and which does not need to be visible globally: Indentation is significant — functions in the block must be indented further than the outer function. Any names which are visible in the outer scope are also visible in the clause (unless they have been redefined, such as here). A name which appears only in the type will be in scope in the clause if it is a parameter to one of the types, i.e. it is fixed across the entire structure. As well as functions, blocks can include local data declarations, such as the following where is not accessible outside the definition of : In general, functions defined in a clause need a type declaration just like any top level function. However, the type declaration for a function can be omitted if:\n• appears in the right hand side of the top level definition\n• The type of can be completely determined from its first application So, for example, the following definitions are legal: even even k odd k odd odd k even k test c , c , d c x x d y c y z y z w y w Idris programs can contain holes which stand for incomplete parts of programs. For example, we could leave a hole for the greeting in our “Hello world” program: The syntax introduces a hole, which stands for a part of a program which is not yet written. This is a valid Idris program, and you can check the type of : Checking the type of a hole also shows the types of any variables in scope. For example, given an incomplete definition of : We can check the type of and see the expected return type, and the type of the variable : Holes are useful because they help us write functions incrementally. Rather than writing an entire function in one go, we can leave some parts unwritten and use Idris to tell us what is necessary to complete the definition.\n\nIn Idris, types are first class, meaning that they can be computed and manipulated (and passed to functions) just like any other language construct. For example, we could write a function which computes a type: This function calculates the appropriate type from a which flags whether the type should be a singleton or not. We can use this function to calculate a type anywhere that a type can be used. For example, it can be used to calculate a return type: Or it can be used to have varying input types. The following function calculates either the sum of a list of , or returns the given , depending on whether the singleton flag is true: A standard example of a dependent data type is the type of “lists with length”, conventionally called vectors in the dependent type literature. They are available as part of the Idris library, by importing , or we can declare them as follows: Note that we have used the same constructor names as for . Ad-hoc name overloading such as this is accepted by Idris, provided that the names are declared in different namespaces (in practice, normally in different modules). Ambiguous constructor names can normally be resolved from context. This declares a family of types, and so the form of the declaration is rather different from the simple type declarations above. We explicitly state the type of the type constructor — it takes a and a type as an argument, where stands for the type of types. We say that is indexed over and parameterised by . Each constructor targets a different part of the family of types. can only be used to construct vectors with zero length, and to construct vectors with non-zero length. In the type of , we state explicitly that an element of type and a tail of type (i.e., a vector of length ) combine to make a vector of length . We can define functions on dependent types such as in the same way as on simple types such as and above, by pattern matching. The type of a function over will describe what happens to the lengths of the vectors involved. For example, , defined as follows, appends two : The type of states that the resulting vector’s length will be the sum of the input lengths. If we get the definition wrong in such a way that this does not hold, Idris will not accept the definition. For example: When run through the Idris type checker, this results in the following: $ idris VBroken.idr --check VBroken.idr:9:23-25: When checking right hand side of Vect.++ with expected type Vect (S k + m) a When checking an application of constructor Vect.::: Type mismatch between Vect (k + k) a (Type of xs ++ xs) and Vect (plus k m) a (Expected type) Specifically: Type mismatch between plus k k and plus k m This error message suggests that there is a length mismatch between two vectors — we needed a vector of length , but provided a vector of length . Finite sets, as the name suggests, are sets with a finite number of elements. They are available as part of the Idris library, by importing , or can be declared as follows: From the signature, we can see that this is a type constructor that takes a , and produces a type. So this is not a set in the sense of a collection that is a container of objects, rather it is the canonical set of unnamed elements, as in “the set of 5 elements,” for example. Effectively, it is a type that captures integers that fall into the range of zero to where is the argument used to instantiate the type. For example, can be thought of as the type of integers between 0 and 4. Let us look at the constructors in greater detail. is the zeroth element of a finite set with elements; is the th element of a finite set with elements. is indexed by a , which represents the number of elements in the set. Since we can’t construct an element of an empty set, neither constructor targets . As mentioned above, a useful application of the family is to represent bounded natural numbers. Since the first natural numbers form a finite set of elements, we can treat as the set of integers greater than or equal to zero and less than . For example, the following function which looks up an element in a , by a bounded index given as a , is defined in the prelude: This function looks up a value at a given location in a vector. The location is bounded by the length of the vector ( in each case), so there is no need for a run-time bounds check. The type checker guarantees that the location is no larger than the length of the vector, and of course no less than zero. Note also that there is no case for here. This is because it is impossible. Since there is no element of , and the location is a , then can not be . As a result, attempting to look up an element in an empty vector would give a compile time type error, since it would force to be . Let us take a closer look at the type of : It takes two arguments, an element of the finite set of elements, and a vector with elements of type . But there are also two names, and , which are not declared explicitly. These are implicit arguments to . We could also write the type of as: Implicit arguments, given in braces in the type declaration, are not given in applications of ; their values can be inferred from the types of the and arguments. Any name beginning with a lower case letter which appears as a parameter or index in a type declaration, which is not applied to any arguments, will always be automatically bound as an implicit argument. Implicit arguments can still be given explicitly in applications, using and , for example: In fact, any argument, implicit or explicit, may be given a name. We could have declared the type of as: It is a matter of taste whether you want to do this — sometimes it can help document a function by making the purpose of an argument more clear. Furthermore, can be used to pattern match on the left hand side, i.e. gets an implicit variable and attempts to pattern match on “pat”; For example: Sometimes it is useful to provide types of implicit arguments, particularly where there is a dependency ordering, or where the implicit arguments themselves have dependencies. For example, we may wish to state the types of the implicit arguments in the following definition, which defines a predicate on vectors (this is also defined in , under the name ): An instance of states that is an element of . We can construct such a predicate if the required element is , at the head of the vector, or , in the tail of the vector. For example: Within the type signature the typechecker will treat all variables that start with an lowercase letter and are not applied to something else as an implicit variable. To get the above code example to compile you will need to provide a qualified name for . In the example above, we have assumed that the code lives within the module. If the same implicit arguments are being used a lot, it can make a definition difficult to read. To avoid this problem, a block gives the types and ordering of any implicit arguments which can appear within the block: In general, functions and data types must be defined before use, since dependent types allow functions to appear as part of types, and type checking can rely on how particular functions are defined (though this is only true of total functions; see Section Totality Checking). However, this restriction can be relaxed by using a block, which allows data types and functions to be defined simultaneously: even even k odd k odd odd k even k In a block, first all of the type declarations are added, then the function bodies. As a result, none of the function types can depend on the reduction behaviour of any of the functions in the block.\n\nCodata types allow us to define infinite data structures by marking recursive arguments as potentially infinite. For a codata type , each of its constructor arguments of type are transformed into an argument of type . This makes each of the arguments lazy, and allows infinite data structures of type to be built. One example of a codata type is Stream, which is defined as follows. This gets translated into the following by the compiler. The following is an example of how the codata type can be used to form an infinite data structure. In this case we are creating an infinite stream of ones. It is important to note that codata does not allow the creation of infinite mutually recursive data structures. For example the following will create an infinite loop and cause a stack overflow. To fix this we must add explicit declarations to the constructor parameter types, since codata will not add it to constructor parameters of a different type from the one being defined. For example, the following outputs .\n\nIdris includes a number of useful data types and library functions (see the directory in the distribution, and the documentation). This section describes a few of these. The functions described here are imported automatically by every Idris program, as part of . We have already seen the and data types: Note that the constructor names are the same for each — constructor names (in fact, names in general) can be overloaded, provided that they are declared in different namespaces (see Section Modules and Namespaces), and will typically be resolved according to their type. As syntactic sugar, any type with the constructor names and can be written in list form. For example: The library also defines a number of functions for manipulating these types. is overloaded both for and and applies a function to every element of the list or vector. For example, given the following vector of integers, and a function to double an integer: the function can be used as follows to double every element in the vector: For more details of the functions available on and , look in the library files: Functions include filtering, appending, reversing, and so on. There are actually neater ways to write the above expression. One way would be to use an anonymous function: The notation constructs an anonymous function which takes one argument, and returns the expression . Anonymous functions may take several arguments, separated by commas, e.g. . Arguments may also be given explicit types, e.g. , and can pattern match, e.g. . We could also use an operator section: is shorthand for a function which multiplies a number by 2. It expands to . Similarly, would expand to . describes an optional value. Either there is a value of the given type, or there isn’t: is one way of giving a type to an operation that may fail. For example, looking something up in a (rather than a vector) may result in an out of bounds error: The function is used to process values of type , either by applying a function to the value, if there is one, or by providing a default value: Note that the types of the first two arguments are wrapped in . Since only one of the two arguments will actually be used, we mark them as in case they are large expressions where it would be wasteful to compute and then discard them. Values can be paired with the following built-in data type: As syntactic sugar, we can write which, according to context, means either or . Tuples can contain an arbitrary number of values, represented as nested pairs: Dependent pairs allow the type of the second element of a pair to depend on the value of the first element: Again, there is syntactic sugar for this. is the type of a pair of A and P, where the name can occur inside . constructs a value of this type. For example, we can pair a number with a of a particular length: If you like, you can write it out the long way, the two are precisely equivalent: The type checker could of course infer the value of the first element from the length of the vector. We can write an underscore in place of values which we expect the type checker to fill in, so the above definition could also be written as: We might also prefer to omit the type of the first element of the pair, since, again, it can be inferred: One use for dependent pairs is to return values of dependent types where the index is not necessarily known in advance. For example, if we filter elements out of a according to some predicate, we will not know in advance what the length of the resulting vector will be: If the is empty, the result is easy: In the case, we need to inspect the result of a recursive call to to extract the length and the vector from the result. To do this, we use notation, which allows pattern matching on intermediate values: We will see more on notation later. Dependent pairs are sometimes referred to as “Sigma types”. Records are data types which collect several values (the record’s fields) together. Idris provides syntax for defining records and automatically generating field access and update functions. Unlike the syntax used for data structures, records in Idris follow a different syntax to that seen with Haskell. For example, we can represent a person’s name and age in a record: The constructor name is provided using the keyword, and the fields are then given which are in an indented block following the keyword (here, , , , and ). You can declare multiple fields on a single line, provided that they have the same type. The field names can be used to access the field values: We can also use the field names to update a record (or, more precisely, produce a copy of the record with the given fields updated): The syntax generates a function which updates the given fields in a record. assigns a new value to a field, and applies a function to update its value. Each record is defined in its own namespace, which means that field names can be reused in multiple records. Records, and fields within records, can have dependent types. Updates are allowed to change the type of a field, provided that the result is well-typed. It is safe to update the field to a vector of a different length because it will not affect the type of the record: addStudent p c students p students c c We could also use to define more concisely: Records can also be dependent on values. Records have parameters, which cannot be updated like the other fields. The parameters appear as arguments to the resulting type, and are written following the record type name. For example, a pair type could be defined as follows: Using the record from earlier, the size of the class can be restricted using a and the size included in the type by parameterising the record with the size. For example: Note that it is no longer possible to use the function from earlier, since that would change the size of the class. A function to add a student must now specify in the type that the size of the class has been increased by one. As the size is specified using natural numbers, the new value can be incremented using the constructor: n n addStudent p c p students c className c"
    },
    {
        "link": "https://research.metastate.dev/a-gentle-introduction-to-dependent-types",
        "document": "Dependent type (or dependently typed programming) languages allow to enhance the expressiveness of your code, thereby increasing the errors the compiler can catch (at compile time). This allows you to correct them and improve the chances that your program behaves as expected at runtime. It makes them particularly well suited to write smart contracts. For feedback or questions, please do not hesitate to contact us: team@metastate.dev\n\nComputers and software are part of our daily life. They are everywhere and we rely on them daily, for instance for financial transactions, communication or even home appliances [1]. Bugs and errors seem commonly accepted [1], although they can sometimes have catastrophic consequences. For that reason, several solutions exist in order to detect and reduce them, the most prominent one being type systems [2]. The primary goal of a type system is to prevent the manifestation of execution errors by executing a type checking algorithm in order to catch type errors [3] [4]. In computer science, type systems have been introduced in the 1950’s (in programming languages like Fortran) [2].\n\n Nowadays, not all languages use a type system. As a result, programming languages can be classified into two categories: statically or dynamically typed (also known as untyped [4]). Statically typed languages (like Java, C, C++, Fortran, etc.) perform a type checking operation during the compilation process, and stop compilation if the type checker encounters an error [4]. For instance, adding a string to a variable defined as an integer will cause an error. In dynamically typed languages (like Python, JavaScript, etc. [5]), however, this error may only reveal itself when the program is being executed. This can be perceived as an additional difficulty to programmers, as they will not receive any assistance \"to understand what the code actually does\" [4].\n\n \n\n It follows that statically typed languages add a safeguard against potential execution errors compared to dynamically type languages [3]. This extra safeguard will increase compilation time (\"as compilation becomes more expensive\" [4]) as well as potentially the complexity of the code [4]. Thus, dynamically typed languages can be perceived as more permissible and grant more power to the programmer [4]. It is a double-edged sword, as bugs reveal themselves at runtime and are generally fatal for the execution of the software [4]. In order to circumvent some of them, programmers using dynamically typed languages can employ a linter (somehow comparable to a type system, as a linter will analyse the code to detect programming and stylistic errors [6]).\n\n Type systems undeniably confirm the \"absence of some bad program behaviour\", however, they cannot \"prove their presence\" [2]. In other words, they might reject some programs that would work properly at runtime [2]. For instance, consider the following line of code:\n\n \n\n if(true)\n\n return 5;\n\n else\n\n return \"Hello\";\n\n \n\n will be rejected as ill-typed even though the else clause will never be reached [2]. Type checking could be compared to dimensional analysis used in physics , where the analysis of base units of an equation provides a \"partial correctness check\" [7]. For instance, if we express the distance as the multiplication of speed and weight we end up with an incoherent result (distance expressed as m ⋅ kg/s) . $$distance [m] = speed [m/s] \\cdot weight [kg] \\rightarrow [m] \n\neq \\left[\\frac{m \\cdot kg}{s}\\right]$$ In contrast, Einstein’s famous formula is correct at least from a dimension analysis point of view: $$E = mc^2 \\rightarrow \\left[\\frac{kg \\cdot m^2}{s^2}\\right] = [kg] \\cdot [m/s]^2$$ An equation can pass dimensional analysis but will still be meaningless. In the same way, type systems can only ensure that a well-typed software is free from certain errors. Nevertheless, they can reveal a wide range of errors [2] to such an extent that once the code of a richly typed languages compiles, it usually \"just works\" [2]. Thus, it appears that the more richly typed your programming language is, the more errors the compiler will catch [4], increasing the chance that your program behaves as expected. Unfortunately, mainstream statically typed systems only offer a few basic types (e.g. integers, string, boolean, etc.), which limits the expressiveness of the code. Although depending on the use case those basic types offered are more than enough, there are certain use cases where it is insufficient. Therefore, the best solution would be to offer a programming language that allows the programmer to extend the expressiveness of types according to their needs, and capture more advanced properties if needed. This could be done by using dependently typed languages which we will cover in the following section.\n\nUsually, types and terms sit on a different level, the term used defining which type can be assigned to it [8]. For instance, the value 1 will have to be stored in a variable of type int . Now, if we put quotes around it, i.e. ’1’, it immediately becomes a type char or string (you cannot assign it a type int anymore). With dependent types, the separation between types and terms is blurred [9], they now sit on the same level. Thus, dependent types allow types to depend on a term of another type [10] [11]. Hence, any part of a program that can be evaluated to a value can also be evaluated to types [4]. A typical example is an array of a fixed length. For instance, an array of length three is of type array and its size depends on the value passed (in this case three). By using different values you define distinctive types. This allows in turn to specify a function that can only receive a certain type as input. For instance, if you specify as input of your function an array of size three and provide an array of size four, the compiler will catch this error. Other languages also enable you to create an array of a fixed size, however, with a true dependent type, the size of your array can be an arbitrary term that does not need \"to be known at compile time\" [9].\n\n \n\n Thus, with a dependently typed language the developer has the option to add more expressiveness to their code by extending the expressiveness of types [12] and consequently the compiler can catch more errors [4]. It is up to the programmer to decide to which level of detail they want to go (or even to not use them). The more complex the dependent types used, the more time the programmer will have to spend to properly describe them and the more computational expensive it will be [4], but in return they will receive more support from the compiler [8]. Hence, by empowering the developer to be more explicit in their code, it increases the amount of potential errors that the compiler can catch [13][14][15]. Depending on the problem at hand, it is a relatively modest cost to pay [16]. Moreover, as it is up to the programmer to define the level of complexity of their code, they can choose the appropriate level of expressiveness to maximize the net benefit [17].\n\n\n\nThe development of type-dependent programming languages originated from the Curry-Howard correspondence [11]. Essentially, it outlines a correspondence between mathematics (intuitionistic logic) and programming languages (type theory) [18]. It derives its name from the fact that it was first observed by Haskell Curry (in 1934 [19]) and later refined by William Alvin Howard (in 1969 [20])[21]. At the beginning of the 1930s, Curry realized the similarity between axioms of implicational propositional calculus P ⊃ Q ⊃ P (P ⊃ Q ⊃ R) ⊃ (P ⊃ Q) ⊃ P ⊃ R and types of SKI combinator calculus (in particular combinators S and K) [11] A → B → A (A → B → C) → (A → B) → A → C Other similarities started to be discovered which resulted in the Curry-Howard correspondence. The Curry-Howard correspondence states on a high level that each proposition of intuitionistic logic can be converted into a type in the programming language and vice versa [21]. It results that:\n\nIt goes further, as for each provable proposition there exists a program with a corresponding type and vice versa [21]. Thus:\n\nHence, it is possible to prove a mathematical theorem using a computer (which is referred to as computer-assisted proof). One notorious example is the proof of the four color theorem [22]. Thus, by using dependent types to encode propositions as types, the resulting program can be used as a proof. As the compiler will type check the program, it only needs to compile to be proven true [18]. In a way, by type checking your program the compiler will prove that your program verifies certain theorems [22]. Thus, dependently typed programs are in essence \"proof carrying code\" [17].\n\n\n\nUnfortunately, dependent types are not well known by programmers [23]. Mainstream statically typed languages do not support them [14]. Moreover, a large part of the documentation on dependent types are written by academics for other academics to read [23]. Consequently, they are often abstruse. Worse, programmers knowing about them are often reluctant to use dependently typed programming languages as it is believed that type checking becomes undecidable (i.e. by allowing arbitrary expression in types, the type checker will loop endlessly) [23][24]. It seems that the principal hurdle slowing down the propagation of dependent types is related to misunderstanding [23]. This coupled with the fact that there are not a lot high-performance compilers available makes them not very well known to the general public.\n\n \n\n As it is often the case, the best way to learn something is to start playing with it. Although recent, there are various different dependently type languages, among which the most prominent are: Coq (2004 [25]), Agda (2007 [8]), Idris (2011 [26]), F* (2011 [27]). There are several very good resources to start learning them (for Idris see f.i. [1] or [28]). Haskell is another programming language that can be used to experiment with dependent types. Moreover, some people argue that by learning Haskell it helps you grow as a programmer and in a sense makes you a better programmer [29][30]. Thus, the time you spend learning it (even if you do not use it afterwards) will be valuable. Moreover, beginner Haskell programmers experience a curious phenomenon: Once your code compiles, it usually just works. It is such a recurring event that the Haskell wiki has a page for it: Why Haskell just works.\n\n \n\n If there are so many advantages, why are dependently typed languages not more popular? In fact, there are not many projects and companies that use dependently typed languages. This could be due to several reasons:\n• None The commercial adoption of those languages could be weakened because they are quite recent, misunderstood and are perceived as hard to learn. Thus, this reduces the experience levels of the programmers and the potential available skill set of workers. This in turn reduces the potential amount of projects that could benefit from it. Moreoever, the resources that can be used by a general audience are quite scarce at the moment.\n• None Agda and Coq are proof assistants (i.e. to write and check proofs) and are not used for general purpose programming [31][32]. The development of Idris is led by Edwin Brady (the creator of Idris), currently a lecturer at the university of St Andrews [33]. Nonetheless, the limited support and contributors outside of academia might bring enough uncertainties, such as usability, or language long-term support, which could limit industrial adoption.\n• None They might not be a good fit with industries with the motto \"move fast and break things\". A better fit could be industries where security is paramount (military, aerospace, financial institutions). A secrecy veil could surround those projects reducing the known use cases.\n\nThis current status might change as it is a constant evolving field of study (see f.i. the recent work on quantitative type theory that combines dependency with linearity [34][35]). This will in turn broaden the use cases for dependently typed languages. One of those potentially promising fields could be blockchain (specifically to write safer smart contracts). In fact, once a smart contract is deployed on the blockchain, its code is immutable [36]. Hence, it is crucial to ensure the correctness of a smart contract before deploying it on the blockchain [37]. Thus, a longer time to compile a smart contract seems a small price to pay if that can increase its chances to behave as expected. Therefore, using a dependently typed programming language to code smart contracts seems to fit perfectly. See for instance Juvix, a dependently typed programming language specially developed to program safer smart contract.\n\nDependently typed programming languages reduce the separation between types and terms. They allow types to depend on a term of another type, thereby increasing the expressiveness of a programmer’s code and the computational cost but reducing the potential errors. Moreover, the programmer can adapt their level of expressiveness to maximize the cost-benefit ratio.\n\n Unfortunately, at the moment of writing, the commercial adoption of dependent types seems hindered. This could be due to the fact that they are quite recent, misunderstood and are perceived as hard to learn, momentarily reducing the experience levels and available skill set of programmers and thus the potential amount of projects that could benefit from them.\n\n It is, however, an evolving field of study with new potential applications. One promising field could be to use a dependently typed language to write safer smart contracts. This is the case for instance of Juvix, which is a new dependently typed programming language specially developed to program safer smart contract.\n\nMetastate has ceased its activities on the 31st of January 2021. The team members have joined a new company and working on a new project. If you're interested in programming language theory, functional programming, type theory, formal verification, or compiler engineering positions, check out the open positions at Heliax.\n\nIf you have any feedback or questions on this article, please do not hesitate to contact us: hello@heliax.dev."
    },
    {
        "link": "https://idris2.readthedocs.io/en/latest/tutorial/typesfuns.html",
        "document": "Idris defines several primitive types: , and for numeric operations, and for text manipulation, and which represents foreign pointers. There are also several data types declared in the library, including , with values and . We can declare some constants with these types. Enter the following into a file and load it into the Idris interactive environment by typing : An Idris file consists of an optional module declaration (here ) followed by an optional list of imports and a collection of declarations and definitions. In this example no imports have been specified. However Idris programs can consist of several modules and the definitions in each module each have their own namespace. This is discussed further in Section Modules and Namespaces. When writing Idris programs both the order in which definitions are given and indentation are significant. Functions and data types must be defined before use, incidentally each definition must have a type declaration, for example see , , from the above listing. New declarations must begin at the same level of indentation as the preceding declaration. Alternatively, a semicolon can be used to terminate declarations. A library module is automatically imported by every Idris program, including facilities for IO, arithmetic, data structures and various common functions. The prelude defines several arithmetic and comparison operators, which we can use at the prompt. Evaluating things at the prompt gives an answer, for example: All of the usual arithmetic and comparison operators are defined for the primitive types. They are overloaded using interfaces, as we will discuss in Section Interfaces and can be extended to work on user defined types. Boolean expressions can be tested with the construct, for example:\n\nData types are declared in a similar way and with similar syntax to Haskell. Natural numbers and lists, for example, can be declared as follows: Data type names cannot begin with a lower case letter (we will see later why not!). The above declarations are taken from the standard library. Unary natural numbers can be either zero ( ), or the successor of another natural number ( ). Lists can either be empty ( ) or a value added to the front of another list ( ). In the declaration for , we used an infix operator . New operators such as this can be added using a fixity declaration, as follows: Functions, data constructors and type constructors may all be given infix operators as names. They may be used in prefix form if enclosed in brackets, e.g. . Infix operators can use any of the symbols: Some operators built from these symbols can’t be user defined. These are\n\nFunctions are implemented by pattern matching, again using a similar syntax to Haskell. The main difference is that Idris requires type declarations for all functions, using a single colon (rather than Haskell’s double colon ). Some natural number arithmetic functions can be defined as follows, again taken from the standard library: plus y y plus k y plus k y mult y mult k y plus y mult k y The standard arithmetic operators and are also overloaded for use by , and are implemented using the above functions. Unlike Haskell, there is no restriction on whether function names must begin with a capital letter or not. Function names ( and above), data constructors ( , , and ) and type constructors ( and ) are all part of the same namespace. By convention, however, data types and constructor names typically begin with a capital letter. We can test these functions at the Idris prompt: Like arithmetic operations, integer literals are also overloaded using interfaces, meaning that we can also test the functions as follows: You may wonder, by the way, why we have unary natural numbers when our computers have perfectly good integer arithmetic built in. The reason is primarily that unary numbers have a very convenient structure which is easy to reason about, and easy to relate to other data structures as we will see later. Nevertheless, we do not want this convenience to be at the expense of efficiency. Fortunately, Idris knows about the relationship between (and similarly structured types) and numbers. This means it can optimise the representation, and functions such as and . Functions can also be defined locally using clauses. For example, to define a function which reverses a list, we can use an auxiliary function which accumulates the new, reversed list, and which does not need to be visible globally: Indentation is significant — functions in the block must be indented further than the outer function. Any names which are visible in the outer scope are also visible in the clause (unless they have been redefined, such as here). A name which appears in the type will be in scope in the clause. As well as functions, blocks can include local data declarations, such as the following where is not accessible outside the definition of : Functions defined in a clause need a type declaration just like any top level function. Here is another example of how this works in practice: even even k odd k odd odd k even k test c , c , d c c x x d y c y z y z z w y w By default, functions in Idris must be . That is, there must be patterns which cover all possible values of the inputs types. For example, the following definition will give an error: This gives an error because is not defined. Idris reports: You can override this with a annotation: However, this is not advisable, and in general you should only do this during the initial development of a function, or during debugging. If you try to evaluate at run time you will get a run time error. Idris programs can contain holes which stand for incomplete parts of programs. For example, we could leave a hole for the greeting in our “Hello world” program: The syntax introduces a hole, which stands for a part of a program which is not yet written. This is a valid Idris program, and you can check the type of : Checking the type of a hole also shows the types of any variables in scope. For example, given an incomplete definition of : We can check the type of and see the expected return type, and the type of the variable : Holes are useful because they help us write functions incrementally. Rather than writing an entire function in one go, we can leave some parts unwritten and use Idris to tell us what is necessary to complete the definition.\n\nIn Idris, types are first class, meaning that they can be computed and manipulated (and passed to functions) just like any other language construct. For example, we could write a function which computes a type: This function calculates the appropriate type from a which flags whether the type should be a singleton or not. We can use this function to calculate a type anywhere that a type can be used. For example, it can be used to calculate a return type: Or it can be used to have varying input types. The following function calculates either the sum of a list of , or returns the given , depending on whether the singleton flag is true: A standard example of a dependent data type is the type of “lists with length”, conventionally called vectors in the dependent type literature. They are available as part of the Idris library, by importing , or we can declare them as follows: Note that we have used the same constructor names as for . Ad-hoc name overloading such as this is accepted by Idris, provided that the names are declared in different namespaces (in practice, normally in different modules). Ambiguous constructor names can normally be resolved from context. This declares a family of types, and so the form of the declaration is rather different from the simple type declarations above. We explicitly state the type of the type constructor — it takes a and a type as an argument, where stands for the type of types. We say that is indexed over and parameterised by . Each constructor targets a different part of the family of types. can only be used to construct vectors with zero length, and to construct vectors with non-zero length. In the type of , we state explicitly that an element of type and a tail of type (i.e., a vector of length ) combine to make a vector of length . We can define functions on dependent types such as in the same way as on simple types such as and above, by pattern matching. The type of a function over will describe what happens to the lengths of the vectors involved. For example, , defined as follows, appends two : The type of states that the resulting vector’s length will be the sum of the input lengths. If we get the definition wrong in such a way that this does not hold, Idris will not accept the definition. For example: When run through the Idris type checker, this results in the following: $ idris2 Vect.idr --check 1/1: Building Vect (Vect.idr) Vect.idr:7:26--8:1:While processing right hand side of Main.++ at Vect.idr:7:1--8:1: When unifying plus k k and plus k m Mismatch between: k and m This error message suggests that there is a length mismatch between two vectors — we needed a vector of length , but provided a vector of length . Finite sets, as the name suggests, are sets with a finite number of elements. They are available as part of the Idris library, by importing , or can be declared as follows: From the signature, we can see that this is a type constructor that takes a , and produces a type. So this is not a set in the sense of a collection that is a container of objects, rather it is the canonical set of unnamed elements, as in “the set of 5 elements,” for example. Effectively, it is a type that captures integers that fall into the range of zero to where is the argument used to instantiate the type. For example, can be thought of as the type of integers between 0 and 4. Let us look at the constructors in greater detail. is the zeroth element of a finite set with elements; is the th element of a finite set with elements. is indexed by a , which represents the number of elements in the set. Since we can’t construct an element of an empty set, neither constructor targets . As mentioned above, a useful application of the family is to represent bounded natural numbers. Since the first natural numbers form a finite set of elements, we can treat as the set of integers greater than or equal to zero and less than . For example, the following function which looks up an element in a , by a bounded index given as a , is defined in the prelude: This function looks up a value at a given location in a vector. The location is bounded by the length of the vector ( in each case), so there is no need for a run-time bounds check. The type checker guarantees that the location is no larger than the length of the vector, and of course no less than zero. Note also that there is no case for here. This is because it is impossible. Since there is no element of , and the location is a , then can not be . As a result, attempting to look up an element in an empty vector would give a compile time type error, since it would force to be . Let us take a closer look at the type of : It takes two arguments, an element of the finite set of elements, and a vector with elements of type . But there are also two names, and , which are not declared explicitly. These are implicit arguments to . We could also write the type of as: Implicit arguments, given with the declaration, are not given in applications of ; their values can be inferred from the types of the and arguments. Any name beginning with a lower case letter which appears as a parameter or index in a type declaration, which is not applied to any arguments, will always be automatically bound as an implicit argument; this is why data type names cannot begin with a lower case letter. Implicit arguments can still be given explicitly in applications, using and , for example: In fact, any argument, implicit or explicit, may be given a name. We could have declared the type of as: It is a matter of taste whether you want to do this — sometimes it can help document a function by making the purpose of an argument more clear. The names of implicit arguments are in scope in the body of the function, although they cannot be used at run time. There is much more to say about implicit arguments - we will discuss the question of what is available at run time, among other things, in Section Multiplicities In general, functions and data types must be defined before use, since dependent types allow functions to appear as part of types, and type checking can rely on how particular functions are defined (though this is only true of total functions; see Section Totality Checking). However, this restriction can be relaxed by using a block, which allows data types and functions to be defined simultaneously: even even k odd k odd odd k even k In a block, first all of the type declarations are added, then the function bodies. As a result, none of the function types can depend on the reduction behaviour of any of the functions in the block. Forward declarations can allow you to have more fine-grained control over the order in which mutually defined concepts are declared. This can be useful if you need to mention a datatype’s constructor in the type of a mutually defined function, or need to rely on the behaviour of a mutually defined function for something to typecheck. -- or just ``even, odd : Nat -> Bool`` even even k odd k odd odd k even k Placing signature declarations forward can suggest Idris to detect their corresponding mutual definitions.\n\nComputer programs are of little use if they do not interact with the user or the system in some way. The difficulty in a pure language such as Idris — that is, a language where expressions do not have side-effects — is that I/O is inherently side-effecting. So, Idris provides a parameterised type which describes the interactions that the run-time system will perform when executing a function: a -- description of an IO operation returning a value of type a We’ll leave the definition of abstract, but effectively it describes what the I/O operations to be executed are, rather than how to execute them. The resulting operations are executed externally, by the run-time system. We’ve already seen one I/O program: The type of explains that it takes a string, and returns an I/O action which produces an element of the unit type . There is a variant which describes the output of a string without a newline: We can also read strings from user input: A number of other I/O operations are available. For example, by adding to your program, you get access to functions for reading and writing files, including: Note that several of these return , since they may fail.\n\nIdris includes a number of useful data types and library functions (see the directory in the distribution, and the documentation). This section describes a few of these, and how to import them. We have already seen the and data types: You can get access to with . Note that the constructor names are the same for each — constructor names (in fact, names in general) can be overloaded, provided that they are declared in different namespaces (see Section Modules and Namespaces), and will typically be resolved according to their type. As syntactic sugar, any implementation of the names and can be written in list form. For example: Similarly, any implementation of the names and can be written in snoc-list form: and the prelude includes a pre-defined datatype for snoc-lists: The library also defines a number of functions for manipulating these types. is overloaded both for and (we’ll see more details of precisely how later when we cover interfaces in Section Interfaces) and applies a function to every element of the list or vector. For example, given the following vector of integers, and a function to double an integer: the function can be used as follows to double every element in the vector: For more details of the functions available on and , look in the library files: Functions include filtering, appending, reversing, and so on. There are neater ways to write the above expression. One way would be to use an anonymous function: The notation constructs an anonymous function which takes one argument, and returns the expression . Anonymous functions may take several arguments, separated by commas, e.g. . Arguments may also be given explicit types, e.g. , and can pattern match, e.g. . We could also use an operator section: is shorthand for a function which multiplies a number by 2. It expands to . Similarly, would expand to . , defined in the Prelude, describes an optional value. Either there is a value of the given type, or there isn’t: is one way of giving a type to an operation that may fail. For example, looking something up in a (rather than a vector) may result in an out of bounds error: The function is used to process values of type , either by applying a function to the value, if there is one, or by providing a default value: Note that the types of the first two arguments are wrapped in . Since only one of the two arguments will actually be used, we mark them as in case they are large expressions where it would be wasteful to compute and then discard them. Values can be paired with the following built-in data type: As syntactic sugar, we can write which, according to context, means either or . Tuples can contain an arbitrary number of values, represented as nested pairs: Dependent pairs allow the type of the second element of a pair to depend on the value of the first element: Again, there is syntactic sugar for this. is the type of a pair of A and P, where the name can occur inside . constructs a value of this type. For example, we can pair a number with a of a particular length: If you like, you can write it out the long way; the two are equivalent: The type checker could infer the value of the first element from the length of the vector. We can write an underscore in place of values which we expect the type checker to fill in, so the above definition could also be written as: We might also prefer to omit the type of the first element of the pair, since, again, it can be inferred: One use for dependent pairs is to return values of dependent types where the index is not necessarily known in advance. For example, if we filter elements out of a according to some predicate, we will not know in advance what the length of the resulting vector will be: If the is empty, the result is: In the case, we need to inspect the result of a recursive call to to extract the length and the vector from the result. To do this, we use a expression, which allows pattern matching on intermediate values: Dependent pairs are sometimes referred to as “Sigma types”. Records are data types which collect several values (the record’s fields) together. Idris provides syntax for defining records and automatically generating field access and update functions. Unlike the syntax used for data structures, records in Idris follow a different syntax to that seen with Haskell. For example, we can represent a person’s name and age in a record: The constructor name is provided using the keyword, and the fields are then given which are in an indented block following the keyword (here, , , , and ). You can declare multiple fields on a single line, provided that they have the same type. The field names can be used to access the field values: We can use prefix field projections, like in Haskell: Prefix field projections can be disabled per record definition using pragma , which makes all subsequently defined records generate only dotted projections. This pragma has effect until the end of the module or until the closest occurrence of . We can also use the field names to update a record (or, more precisely, produce a copy of the record with the given fields updated): The syntax generates a function which updates the given fields in a record. assigns a new value to a field, and applies a function to update its value. Each record is defined in its own namespace, which means that field names can be reused in multiple records. Records, and fields within records, can have dependent types. Updates are allowed to change the type of a field, provided that the result is well-typed. It is safe to update the field to a vector of a different length because it will not affect the type of the record: addStudent p c students p students c c We could also use to define more concisely: Nested record fields can be accessed using the dot notation: For the dot notation, there must be no spaces after the dots but there may be spaces before the dots. The composite projection must be parenthesised, otherwise would be understood as . Nested record fields can be accessed using the prefix notation, too: Dots with spaces around them stand for function composition operators. Records can also be dependent on values. Records have parameters, which cannot be updated like the other fields. The parameters appear as arguments to the resulting type, and are written following the record type name. For example, a pair type could be defined as follows: Using the record from earlier, the size of the class can be restricted using a and the size included in the type by parameterising the record with the size. For example: In the case of earlier, we can still add a student to a since the size is implicit, and will be updated when a student is added: n n addStudent p c students p students c c In fact, the dependent pair type we have just seen is, in practice, defined as a record, with fields and which allow projecting values out of the pair: It is possible to use record update syntax to update dependent fields, provided that all related fields are updated at once. For example:\n\nIntermediate values can be calculated using bindings: We can do pattern matching in bindings too. For example, we can extract fields from a record as follows, as well as by pattern matching at the top level: These let bindings can be annotated with a type: Since can either indicate a type of equality ( or ) or a definition, some expressions can be ambiguous. Here is an example: We can also use the symbol instead of in this context to, among other things, avoid these ambiguities with propositional equality: The code above can be read as “ has type and its value is ”. Local definitions can also be introduced using . Just like top level ones and ones defined in a clause you need to:\n• None declare the function and its type The symbol cannot be used in a local function definition. Which means that it can be used to interleave let bindings and local definitions without introducing ambiguities. m a m n a m foldMap f fo m a m fo ac el ac f el neutral -- ^ this indicates that `initial` is a separate binding, -- not relevant to definition of `fo` foldl fo initial Idris provides comprehension notation as a convenient shorthand for building lists. The general form is: This generates the list of values produced by evaluating the , according to the conditions given by the comma separated . For example, we can build a list of Pythagorean triples as follows: The notation is another shorthand which builds a list of numbers between and . Alternatively builds a list of numbers between and with the increment specified by the difference between and . This works for type , and , using the and function from the prelude. Another way of inspecting intermediate values is to use a expression. The following function, for example, splits a string into two at a given character: is a library function which breaks a string into a pair of strings at the point where the given function returns true. We then deconstruct the pair it returns, and remove the first character of the second string. A expression can match several cases, for example, to inspect an intermediate value of type . Recall which looks up an index in a list, returning if the index is out of bounds. We can use this to write , which looks up an index and returns a default value if the index is out of bounds: If the index is in bounds, we get the value at that index, otherwise we get a default value:"
    },
    {
        "link": "https://type-driven.org.uk/edwinb/papers/plpv11.pdf",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading",
        "document": "A user-defined type can overload a predefined C# operator. That is, a type can provide the custom implementation of an operation in case one or both of the operands are of that type. The Overloadable operators section shows which C# operators can be overloaded.\n\nUse the keyword to declare an operator. An operator declaration must satisfy the following rules:\n• It includes both a and a modifier.\n• A unary operator has one input parameter. A binary operator has two input parameters. In each case, at least one parameter must have type or where is the type that contains the operator declaration.\n\nThe following example defines a simplified structure to represent a rational number. The structure overloads some of the arithmetic operators:\n\nYou could extend the preceding example by defining an implicit conversion from to . Then, overloaded operators would support arguments of those two types. That is, it would become possible to add an integer to a fraction and obtain a fraction as a result.\n\nYou also use the keyword to define a custom type conversion. For more information, see User-defined conversion operators.\n\nThe following table shows the operators that can be overloaded:\n\nThe following table shows the operators that can't be overloaded:\n\nFor more information, see the following sections of the C# language specification:\n• Why are overloaded operators always static in C#?"
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/136519/examples-of-operator-overloading-which-make-sense",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/1524972/what-are-the-best-practices-for-implementing-the-operator-for-a-class-in-c",
        "document": "While implementing an operator, I have the feeling that I am missing some essential points.\n\n Hence, I am searching some best practices around that.\n\n Here are some related questions I am thinking about:\n• How to cleanly handle the reference comparison?\n• Should it be implemented through a -like interface? Or overriding ?\n• And what about the operator?\n\n(this list might not be exhaustive)."
    },
    {
        "link": "https://geeksforgeeks.org/c-sharp-operator-overloading",
        "document": "The concept of overloading a function can also be applied to operators. Operator overloading gives the ability to use the same operator to do various operations. It provides additional capabilities to C# operators when they are applied to user-defined data types. It enables to make user-defined implementations of various operations where one or both of the operands are of a user-defined class. Only the predefined set of C# operators can be overloaded. To make operations on a user-defined data type is not as simple as the operations on a built-in data type. To use operators with user-defined data types, they need to be overloaded according to a programmer’s requirement. An operator can be overloaded by defining a function to it. The function of the operator is declared by using the operator keyword.\n\nNote : Operator overloading is basically the mechanism of providing a special meaning to an ideal C# operator w.r.t. a user-defined data type such as structures or classes.\n\nThe following table describes the overloading ability of the various operators available in C# :\n\nThe return type can be of any type except void for unary operators like !, ~, + and dot (.) but the return type must be the type of ‘Type’ for – and ++ operators and must be a bool type for true as well as false operators. But do remember that the true and false operators can be overloaded as pairs only. The compilation error arises if a class declares one of these operators without declaring the other.\n\nThe following syntax shows the use of Unary operator –\n\nBinary Operators will work with two Operands. Examples of binary operators include the Arithmetic Operators (+, -, *, /, %), Arithmetic Assignment operators (+=, -+, *=, /+, %=) and Relational Operators etc. Overloading a binary operator is similar to overloading a unary operator, except that a binary operator requires an additional parameter.\n• Operator Overloading provides additional capabilities to C# operators when they are applied to user-defined data types.\n• Operators may be considered as functions internal to the compiler."
    },
    {
        "link": "https://stackoverflow.com/questions/1766492/overloading-operator-versus-equals",
        "document": "I'm working on a C# project on which, until now, I've used immutable objects and factories to ensure that objects of type can always be compared for equality with .\n\nobjects can't be changed once created, and the factory always returns the same object for a given set of arguments. This works great, and throughout the code base we assume that always works for checking equality.\n\nNow I need to add some functionality that introduces an edge case for which this won't always work. The easiest thing to do is to overload for that type, so that none of the other code in the project needs to change. But this strikes me as a code smell: overloading and not just seems weird, and I'm used to the convention that checks reference equality, and checks object equality (or whatever the term is).\n\nIs this a legitimate concern, or should I just go ahead and overload ?"
    }
]