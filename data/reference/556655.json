[
    {
        "link": "https://geeksforgeeks.org/cpp-linked-list",
        "document": "In C++, a linked list is a linear data structure that allows the users to store data in non-contiguous memory locations. A linked list is defined as a collection of nodes where each node consists of two members which represents its value and a next pointer which stores the address for the next node. In this article, we will learn about the linked list, its implementation, and its practical applications.\n\nFollowing are the types of linked lists in C++:\n\nThe singly linked list is the simplest form of linked list in which the node contain two members data and a next pointer that stores the address of the next node. Each node is a singly linked list is connected through the next pointer and the next pointer of the last node points to NULL denoting the end of the linked list. The following diagram describes the structure of a singly linked list:\n\nThe doubly linked list is the modified version of the singly linked list where each node of the doubly linked consists of three data members data ,next and prev. The prev is a pointer that stores the address of the previous node in the linked list sequence. Each node in a doubly linked list except the first and the last node is connected with each other through the prev and next pointer. The prev pointer of the first node and the next pointer of the last node points to NULL in the doubly linked list. The following diagram describes the structure of a doubly linked list:\n\nThe circular linked list is almost same as the singly linked list but with a small change. In a circular linked list the next pointer of the last node points to the first node of the linked list rather than pointing to NULL, this makes this data structure circular in nature which is used in various applications like media players. The following diagram describes the structure of a circular linked list:\n\nThe doubly circular linked list is a combination of a doubly linked list and a circular linked list. In a doubly circular linked list the prev pointer of the first node points to the last node and the next pointer of the last node points to the first node. The main advantage of a doubly circular linked list is that we can access the last node of the linked list in constant time through the first node. The following diagram describes the structure of a doubly circular linked list:\n\nImplementation of Linked List in C++\n\nTo implement a in C++ we can follow the below approach:\n\nRepresentation of a Node in the Linked List\n\nEach node of the linked list will be represented as a having two members data and next where:\n• Data: Represents the value stored in the node.\n• Next Pointer: Stores the reference to the next node in the sequence.\n\nNote: Add another data member Node * prev in the structure for .\n\nFollowing are some basic operations which are required to manipulate the nodes of a linked list:\n\nNote: Here n denotes the number of nodes in the linked list.\n\nNow let's learn how we can implement these basic functions of linked list in C++:\n\nC++ Program for Implementation of Linked List\n\nThe following program illustrates how we can implement a singly linked list data structure in C++:\n\n// C++ Program for Implementation of linked list // Structure for a node in the linked list // Pointer to the first node in the list // Function to Insert a new node at the beginning of the list // Function Insert a new node at the end of the list // If the list is empty, update the head to the new node // Traverse to the last node // Update the last node's next to the new node // Function to Insert a new node at a specific position in the list // Traverse to the node before the desired position // If the position is out of range, print an error message // Insert the new node at the desired position // Function to Delete the first node of the list // Function to Delete the last node of the list // Set the second-to-last node's next to NULL // Function to Delete a node at a specific position in the list // Save the node to be deleted // Function to print the nodes of the linked list\n\nNote: You can easily implement the other types of linked lists with some minor changes in the above code.\n\nFollowing are some common applications of the linked list data structure:\n• None linked lists are used to keep track of free and allocated memory blocks.\n• None Linked lists are used in text editors to implement undo and redo operations.\n• None Linked lists are used to implement\n• None Linked lists are also used to implement fundamental data structures like\n\nFollowing are some of the articles that you can also read to improve your understanding about the linked list data structure:"
    },
    {
        "link": "https://geeksforgeeks.org/linked-list-data-structure",
        "document": ""
    },
    {
        "link": "https://cplusplus.com/articles/Lw6AC542",
        "document": "\n• Efficient insertion and erasure of elements anywhere in the container (constant time).\n• Iterating over the elements in forward order (linear time).\n• Efficient moving elements and block of elements within the container or even between different containers (constant time).\n• Iterating over the elements in forward or reverse order (linear time).\n\nThe linked list is used in many libraries/applications and for a good reason. The following are advantages it has over other containers, indirectly from the reference page on cplusplus.com:The following only applies to a doubly linked list which I will explain later on:Something the reference doesn't explain is how it's implemented. Why would you *want* to know about that? For me, simply curiosity. For others, perhaps they may create their own type of linked list container. Either way, it's knowledge that *someone* will eventually use hopefully.The linked list is generally pictured as a list of linear nodes that are tethered together somehow. In C/++, you generally have a structure which contains data and a pointer to the next structure container which contains data and a pointer to the next structure container... and so on. The linked list's main advantage is that it doesn't contain data in a contiguous way and rather, a flexible way. This allows for fast insertion and better overall iteration. The linked list is often even used as the basis for other containers (such as queue or stack containers).There are several variations of the linked-list. Actually, the term \"linked list\" doesn't really refer to the implementation (thus, an abstract term), just the nature of how the data of the container is held (linked via references). The most common implementation of the linked list is probably the doubly linked list. The doubly linked list is a list that contains nodes that contains references to the previous *and* next link in the list. This allows for fast node erasure, faster fetching of end nodes, and more flexible iteration.At the cost of flexibility of the doubly-linked list, it generally costs more memory to use. In large lists, consider the idea of a node being twice the size as normal. This can affect the application quite a bit. In the case that you have no reason to iterate backwards, the doubly-linked list can be considered inefficient, simply by design. std::list is a doubly linked list. As a result, if I ever come about the need for a singly-linked list, I implement my own. A singly-linked list can only iterate forward simply because the node it holds only holds a reference to the next node in the list and not the previous but comes with the merit of one less reference.Another type of linked-list that's not used quite as often is the circular linked-list. All this is a singly/doubly-linked list where the end node iterates forward to the beginning node (and possibly vice versa). There aren't many uses for this as it generally has problems with iterating through the list but take, for instance, a list that iterates through the nodes until a given signal is received. Also, it's really a technique used with linked lists... not always in implementation although special list implementations can handle circular linked lists better than others: TODO: Add example...In embedded systems, the use of linked lists can be expensive. The holding of each reference can be so heavy that it's undesirable to use a linked-list with nodes that only hold one location of data. Instead, they generally used what's called unrolled linked lists. In an unrolled linked list, the node holds a reference to the next and previous, like normal, but each node holds arrays of data. When you iterate through each node, you iterate through the data in the array linearly, then move on to the next node. This way we can have three or four nodes of data in one while reducing the amount of nodes altogether (therefor saving memory). However, this generally uses contiguous memory to hold nodes so it becomes difficult to move nodes that are in the array. TODO: Give an example.Wikipedia has fantastic pictures: http://en.wikipedia.org/wiki/Linked_list#Linear_and_circular_listsThis is probably the most basic form of a list structure. However, this doesn't show a list being useful in anyway. We can simplify the interface greatly by adding complexity to implementation. std::list uses a parent class while controlling nodes internally using abstract methods (iterators) for access to nodes. It's of my belief that the interface that std::list provides is good so I'll make something that resembles such a thing:This is a huge improvement as far as feature goes. We now have (basic) memory management for our nodes, and ease-of-use iterators to iterate through our nodes without the dangers of pointers. What more could you possibly want?The above is a quick implementation of a singly linked list. If you look at the code, it's relatively straight-forward and self explanatory (through logic). What isn't, has been commented on.On the above, there are *plenty* of things that we can change and customize for our specific needs. For instance, (*)the iterator of the class can contain both the previous and current node to help make erasure a tad more efficient at the cost of memory and iteration time. For instance, if you have a large list and you keep moving in keep having to reiterate through the list, perhaps this isn't quite as efficient because of the added constant of reassigning multiple node references. If you are continuously erasing and/or swapping elements from the list then this would be highly efficient since you need to change the next reference held by the previous node of what is getting swapped or erased.There's also a way to reduce the cost of memory with a doubly-linked list called XOR linking which uses XOR encryption on the pointer to shrink the size of memory used. TODO: Provide example."
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/9tyrc4/implementing_linked_lists_best_practices_and_best",
        "document": "Say I've implemented a queue as a linked list. There are a couple of ways you might do it.\n\nThis style, or something like it, is something I see a lot:\n\nThe advantages are mostly that everybody can tell right off the bat what it does.\n\nBut I like this style:\n\nI think this is more elegant, but now it involves a double de-reference of . Does anybody have any feel for whether or not this extra indirection will be a significant performance loss?\n\nConversely, there are no more conditionals in the \"append\" function, and only one in the \"remove\" function. That could very well be a serious win in any pipelined architecture."
    },
    {
        "link": "https://stackoverflow.com/questions/982388/how-to-implement-a-linked-list-in-c",
        "document": "In your case the head and tail could simply point to the beginning and end of a linked-list. With a singly linked-list, only the head is really needed. At it's most basic, a linked-list can be made by using just a struct like:\n\nand as long as list is always pointing to the beginning of the list and the last item has next set to NULL, you're fine and can use current_node to traverse the list. But sometimes to make traversing the list easier and to store any other data about the list, a head and tail token are used, and wrapped into their own structure, like you have done. So then your add and initialize functions would be something like (minus error detection)\n\nIn this case, since it's a singly linked-list, the tail is only really useful for appending items to the list. To insert an item, you'll have to traverse the list starting at the head. Where the tail really comes in handy is with a doubly-linked list, it allows you to traverse the list starting at either end. You can traverse this list like\n\nOften times, the head and tail are fully constructed nodes themselves used as a sentinel to denote the beginning and end of a list. They don't store data themselves (well rather, their data represent a sentinel token), they are just place holders for the front and back. This can make it easier to code some algorithms dealing with linked lists at the expense of having to have two extra elements. Overall, linked lists are flexible data structures with several ways to implement them.\n\noh yeah, and nik is right, playing with linked-lists are a great way to get good with pointers and indirection. And they are also a great way to practice recursion too! After you have gotten good with linked-list, try building a tree next and use recursion to walk the tree."
    },
    {
        "link": "https://geeksforgeeks.org/doubly-linked-list-in-cpp",
        "document": "A Doubly Linked List (DLL) is a two-way list in which each node has two pointers, the next and previous that have reference to both the next node and previous node respectively. Unlike a singly linked list where each node only points to the next node, a doubly linked list has an extra previous pointer that allows traversal in both the forward and backward directions.\n\nIn this article, we will learn about the doubly linked list representation, implementation of doubly linked list in C++, basic operations that can be performed on doubly linked list, its advantages and disadvantages.\n\nIn a doubly linked list, two pointers are maintained to keep track of the list i.e. head (that points to the first node) and tail (that points to the last node).\n\nImplementation of Doubly Linked List in C++\n\nTo implement all the basic operations that can be performed on a doubly linked list, we need to first define a node. Let's see how we can create a new node in a doubly linked list.\n\nCreating a Node in Doubly Linked List in C++\n\nEach node of a doubly linked list (DLL) consists of three fields:\n• Item or Data: It is the value stored in the node.\n• Next: A reference to the next node in the list.\n• Previous: A reference to the last node in the list.\n\nIn C++, a node of a doubly linked list can be created using the below format:\n\nWe can perform the following basic operations on a doubly linked list:\n\n1. Insertion in Doubly Linked List in C++\n\nIn a doubly linked list, there are three ways in which the insertion operation can be performed:\n• Insertion at the beginning of DLL\n• Insertion at the end of DLL\n\na. Insertion at the Beginning in Doubly Linked List\n\nFirst, create a new node to be inserted and then follow the below approach to insert a new node at the beginning of a doubly linked list:\n\nb. Insertion at the End in Doubly Linked List\n\nFirst, create a new node to be inserted and then follow the below approach to insert a new node at the end of a doubly linked list:\n\nc. Insertion at Specific Position in Doubly Linked List\n\nFirst, create a new node to be inserted and then follow the below approach to insert a new node at a given position in a doubly linked list:\n\n2. Deletion in Doubly Linked List in C++\n\nLike insertion, there are three ways in which the deletion operation can be performed:\n• Deletion at the beginning of DLL\n• Deletion at the end of DLL\n\na. Deletion from the Beginning of Doubly Linked List\n\nTo delete a node from the beginning of the doubly linked list, follow the below approach:\n\nb. Deletion from the End of Doubly Linked List\n\nTo delete a node from the end of a doubly linked list, follow the below approach:\n\nc. Deletion From Specific Position of Doubly Linked List\n\nTo delete a node from a specific position in a doubly linked list, follow the below approach:\n\n3. Traversal in a Doubly Linked List in C++\n\nTraversing a doubly linked list means iterating through the list by visiting each node and performing the desired operations. This can be done by maintaining a temp variable that starts from the head of the doubly linked list and follows the next pointer for traversing until the end of the list. In a doubly linked list, we can traverse in both directions:\n• In forward traversal, traverse from the head to the tail node.\n• In reverse traversal, traverse from the tail to the head node.\n\nTo traverse the doubly linked list in the forward direction, follow the below approach:\n\nTo traverse the doubly linked list in the reverse direction, follow the below approach:\n\nThe below program demonstrates the implementation of all the basic operations on the doubly linked list.\n\n// Define a class named Node to represent a node in the // Pointer to the next node. // Constructor to initialize the node with given data. // Function to insert a node at the beginning of the doubly // Create a new node with the given data. // Check if the doubly linked list is empty. // Update the next and previous pointers to insert the // new node at the beginning. // Function to insert a node at the end of the doubly linked // Create a new node with the given data. // Check if the doubly linked list is empty. // Traverse to the last node of the list. // Update the next and previous pointers to insert the // Function to insert a node at a specified position in the // If inserting at the head position. // Create a new node with the given data. // Traverse to the node before the specified position. // Check if the position is greater than the number of \"Position greater than the number of nodes.\" // Update the next and previous pointers to insert the // new node at the specified position. // Function to delete a node from the beginning of the // Check if the doubly linked list is empty. \"The list is already empty.\" // Update the head pointer and delete the first node. // Function to delete a node from the end of the doubly // Check if the doubly linked list is empty. \"The list is already empty.\" // If there is only one node in the list. // Traverse to the last node of the list. // Update the previous pointer of the second last node // and delete the last node. // Function to delete a node from a specified position in // Check if the doubly linked list is empty. \"The list is already empty.\" // Traverse to the node at the specified position. // Check if the position is greater than the number of \"Position is greater than the number of \" // Update the next and previous pointers and delete the // node at the specified position. // Function to print the doubly linked list in forward // Function to print the doubly linked list in reverse // Move to the end of the list. // Demonstrating various operations on the doubly linked\n\nAdvantages of Doubly Linked List in C++\n\nThe following are the advantages of a doubly linked list in C++:\n• The doubly linked list allows us to traverse in both forward and backward directions.\n• The deletion of a node is more efficient and easy as it has a pointer to the previous node.\n• It is easier to perform the reverse operation.\n• A doubly linked list is dynamic in nature so it can grow or shrink in size.\n\nDisadvantages of Doubly Linked List in C++\n• It requires more memory than arrays, per node due to the additional storage used by the pointers.\n• It is more complex to implement and maintain as compared to the singly-linked list.\n• We have to traverse from the head node to the specific node for insertion and deletion at specific positions.\n\nFrequently Asked Questions on Doubly Linked in C++\n\nWhat is the Primary Advantage of a Doubly Linked List over a Singly Linked List?\n\nHow does the Additional Pointer in a Doubly Linked List Affect its Performance?\n\nQ4. What are the real-world applications of doubly linked lists?"
    },
    {
        "link": "https://stackoverflow.com/questions/70116856/swap-nodes-with-pointers-on-doubly-circular-linked-list",
        "document": "I am trying to write a doubly circular linked list, but I got somewhat stuck in swapping nodes. It's working fine for any node except the head node. I tried adding a check if is the without a luck. Where am I doing wrong ?\n\nWell, I stated earlier but for any other node except head the swap is working just fine, I'm sure this is the key to the problem here, but I cannot see it so far. Appreciate any help.\n\nUpdate: Currently if is the head node, it swaps with . becomes ."
    },
    {
        "link": "https://geeksforgeeks.org/insertion-in-doubly-circular-linked-list",
        "document": "Circular Doubly Linked List has properties of both doubly linked list and circular linked list in which two consecutive elements are linked or connected by the previous and next pointer and the last node points to the first node by the next pointer and also the first node points to the last node by the previous pointer. In this article, we will learn about different ways to insert a node in a doubly circular linked list.\n\nInsertion at the Beginning in Doubly Circular Linked List – O(1) Time and O(1) Space:\n\nTo insert a new node at the front of a doubly circular linked list,\n• None Allocate memory for the new node.\n• None If the list is empty next prev to point to itself, and update the head to this new node.\n• non-empty\n• current prev to the new node.\n• last next to the new node.\n• None Set the new node as the new head\n\n// C++ code of insert node at begin in // Function to insert a node at the // C code of insert node at begin in // Function to insert a node at the // Java code of insert node at begin in // Function to insert a node at the beginning # Python code of insert node at begin in // C# code of insert node at begin in // Function to insert a node at the // Javascript code of insert node at begin in\n\nTime Complexity: O(1), Since we are not traversing the list.\n\nAuxiliary Space: O(1)\n\nInsertion at the End in Doubly Circular Linked List – O(1) Time and O(1) Space:\n\nTo insert a new node at the end of doubly circular linked list,\n• None Allocate memory for the new node.\n• None If the list is empty next prev pointers to point to itself, and update the head to this new node.\n• non-empty\n• current last node (the node whose next head\n• next pointer to point to the head\n• prev pointer to point to the current\n• current last node’s next pointer to point to the new node.\n• prev pointer to point to the new node.\n\n// C++ code of insert node at End in // Function to insert a node at the end of // Insert new node at the end // C code of insert node at End in // Function to insert a node at the end // Insert new node at the end // Java code of insert node at End in // Function to insert a node at the end // Insert new node at the end # Python code of insert node at End in # Insert new node at the end // Python code of insert node at End in // Function to insert a node at the end of // Insert new node at the end // Javascript code of insert node at End in // Function to insert a node at the // Insert new node at the end\n\nTime Complexity: O(1). Since we are not travesing the list.\n\nAuxiliary Space: O(1)\n\nInsertion after a given node in Doubly Circular Linked List – O(n) Time and O(1) Space:\n\nTo insert a new node after a given node in doubly circular linked list,\n• None Allocate memory for the new node.\n• None\n• None If givenNode is the last node (i.e., points to head), update head->prev\n\n// C++ code of insert after given node in // Function to insert a node after a given node in // If the list is empty, return nullptr // Find the node with the given data // Insert the new node after the given node // If the given node was the last node, // C code to insert a node after a given node in // Function to insert a node after a given node in // If the list is empty, return nullptr // Find the node with the given data // Insert the new node after the given node // If the given node was the last node, // Java code to insert after a given node in // Function to insert a node after a given node in // If the list is empty, return null // Find the node with the given data // Insert the new node after the given node // If the given node was the last node, # Python code to insert a node after a given node # Function to insert a node after a given node in # If the list is empty, return None # Find the node with the given data # Insert the new node after the given node # If the given node was the last node, // C# code to insert after a given node in a // Function to insert a node after a given node in // If the list is empty, return null // Find the node with the given data // Insert the new node after the given node // If the given node was the last node, // JavaScript code to insert after a given node // Function to insert a node after a given node in // If the list is empty, return null // Find the node with the given data // Insert the new node after the given node // If the given node was the last node,\n\nTime Complexity: O(n), Traversing over the linked list of size n. \n\nAuxiliary Space: O(1)\n\nInsertion before a given node in Doubly Circular Linked List – O(n) Time and O(1) Space:\n\nTo insert a new node before a specific node in doubly circular linked list,\n• None Allocate memory for the new node.\n• None Update Head (if givenNode is the head node), set head\n\n// C++ code to insert before a given node in // Function to insert a node before a given node in // If the list is empty, return nullptr // Find the node with the given data // Insert the new node before the given node // If the given node was the head, // C code to insert a node befor a given node in // Function to insert a node before a given node in // If the list is empty, return nullptr // Find the node with the given data // Insert the new node before the given node // If the given node was the head, update the head // Java code to insert before a given node in // Function to insert a node before a given node in // If the list is empty, return null // Find the node with the given data // Insert the new node before the given node // If the given node was the head, # Python code to insert before a given node in # Function to insert a node before a given node in # If the list is empty, return None # Find the node with the given data # Insert the new node before the given node # If the given node was the head, // C# code to insert before a given node in // Function to insert a node before a given node in // If the list is empty, return null // Find the node with the given data // Insert the new node before the given node // If the given node was the head, // JavaScript code to insert before a given node in // Function to insert a node before a given node in // If the list is empty, return null // Find the node with the given data // Insert the new node before the given node // If the given node was the head,\n\nTime Complexity: O(n), Traversing over the linked list of size n. \n\nAuxiliary Space: O(1)\n\nInsertion at a specific position in Doubly Circular Linked List – O(n) Time and O(1) Space:\n\nTo insert a new node at a specific position in doubly circular linked list,\n• None Allocate memory for the new node.\n• curr head node and start traversing the list we reach the node just before the desired position . Use a counter to keep track of the curr\n• Head (if the insertion is at position 0 and the list is empty), set head\n\n// C++ code to insert a new node at a specific position in // Function to add a node after a given position in // If the list is empty, return nullptr // New node becomes the only node in the circular list // Insert at the beginning of the list // Insert the new node after the // current node (at the given position) // C code to insert a new node at a specific position in // Function to add a node after a given position in // If the list is empty, return nullptr // New node becomes the only node in the circular list // New node becomes the head // Insert at the beginning of the list // New node becomes the head // Insert the new node after the // current node (at the given position) // Java code to insert a new node at a specific position in // Function to add a node after a given position in // If the list is empty, return null // New node becomes the only node // Insert at the beginning of the list // New node becomes the head // Insert the new node after the current // node (at the given position) # Python code to insert a new node at a specific position in # Function to add a node after a given position in # If the list is empty, return None # New node becomes the only node in # Insert at the beginning of the list # New node becomes the head # Insert the new node after the # current node (at the given position) // C# code to insert a new node at a specific position in // Function to add a node after a given position in // If the list is empty, return null // New node becomes the only node in // Insert at the beginning of the list // New node becomes the head // Insert the new node after the // current node (at the given position) // Javascript code to insert a new node at a specific position in // Function to add a node after a given position in // If the list is empty, return null // New node becomes the only node in // Insert at the beginning of the list // New node becomes the head // Insert the new node after the // current node (at the given position)\n\nTime Complexity: O(n), Traversing over the linked list of size n. \n\nAuxiliary Space: O(1)"
    },
    {
        "link": "https://wscubetech.com/resources/dsa/circular-doubly-linked-list",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/29709747/circularly-double-linked-list-c",
        "document": "It's hard to say exactly what's happening without see how you're using these classes but your MyList constructor overloaded on string is broken right off the bat. It sets count to so you know it will always enter the clause and never the .\n\ninside the if statement, it tries to dereference which has never been assigned a value. You do set it in the default constructor but that one also doesn't seem to do anything else.\n\nThe purpose of a constructor is to construct a valid object from scratch. Sometimes one constructor overload might delegate to another to avoid repeated code but I'm not sure what you're trying to do here.\n\nAssuming the second constructor was meant to actually be a helper method, well it still doesn't work because count never goes above zero (except in the clause but you can't get there with ).\n\nI'll admit I didn't look very carefully but I'm guessing that if execution this far:\n\nis not always going to be set when you try to access it. if cur->next is nullptr then your program dies."
    }
]