[
    {
        "link": "https://reddit.com/r/Cplusplus/comments/e4h978/making_tetris_with_basic_c",
        "document": "Hi. I'm currently taking an intro to cs course and the term project is to make a basic game on c++. I'm planning to do a version of Tetris. Now the stuff that we've covered in the course so far goes from basic syntax, loops and all to arrays and vectors. We're supposed to cover pointers next week but that's also when the project is due. All the code or tutorials that I've found on the internet so far involves classes which is something that we definitely won't learn in the course. I think I can use two-dimensional arrays to make the game but I'm not too sure. Any advice on how to set it up without classes?"
    },
    {
        "link": "https://gbgames.com/2008/12/16/game-programming-tutorial-tetris-in-c",
        "document": "Javier Lopez wrote a beginner’s tutorial to write Tetris in C++. NOTE: It seems this link is broken. I’ll see if I can find a replacement. The tutorial is platform-independent, which I like. While some people have complained that the tutorial isn’t very good C++, I’ve yet to see a more comprehensive and complete Tetris tutorial. Once you’ve followed it and written your own, feel free to spend the time to write a better one.\n\nWHAT?! Haven’t ALL game developers worth their salt made their own Tetris? Didn’t icculus say that it was good for the soul?\n\nI’m not going to say that I’m proud of it, but for some reason the furthest I ever got was to write some notes down. I would think about how to represent the various pieces, but I would get hung up on not easily seeing a general way to do so. I could have hard-coded them the way the tutorial does, but I thought, “Nah, I can do it better than that!”\n\nBut then I never did it. And so I never wrote a Tetris clone at all.\n\nFor new game developers out there, you have to realize that shortcuts and brute force methods are perfectly fine sometimes. It’s more important to get something working, even if it is working badly, than it is to get it right the first time. Otherwise, you spend years tweaking a general purpose game engine.\n\nLopez’s tutorial will do more to help someone understand basic game logic than most game engine tutorials, and the end result will be a pretty good clone of the original Tetris. The player isn’t going to care that you didn’t use every bit of functionality that C++ (or any language) provides. You made a game, and that’s all that matters."
    },
    {
        "link": "https://quora.com/How-can-I-make-a-simple-Tetris-game-in-C-without-using-any-library-or-game-engine",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/q9ssk4/c_tetris_game",
        "document": "Hello i was thinking to make a tetris game with C++ but i dont really know what i need to make the design and graphic things i heard about Qt and OpenGl but i dont know what is that can someone tell me what i need and explain what they do."
    },
    {
        "link": "https://javilop.com/gamedev/tetris-tutorial-in-c-platform-independent-focused-in-game-logic-for-beginners",
        "document": "We are going to learn how to create a Tetris clone from scratch using simple and clean C++. And this will take you less than an hour! This is the perfect tutorial for beginners. Just enjoy it and leave a comment if you want me to explain something better. I know my English sucks, so if you see some mistakes, please, tell me. Let’s go!\n\nHere it is the complete sourcecode.\n\nThe sourcecode comes with SDL includes and libs ready to compile in Visual C++ Express Edition 2008. In «Release» folder there is also an executable file just in case you want to try it directly.\n\nThanks to lmelior and to Javier Santana, there is a Linux version of this tutorial. The sourcecode is platform independent and comes with a «makefile». However, under Linux, you need libsdl-gfx1.2-dev and libsdl1.2-dev (If you are using Ubuntu you can get them this way: sudo apt-get install libsdl1.2-dev libsdl-gfx1.2-dev)\n\nWe are going to focus on the game logic, using only rectangle primitives (SDL) for the rendering. All the game logic is isolated from the drawing, so you can expand the tutorial easily. I’m planning making a second tutorial of how to improve this Tetris clone using sprites, background, effects, etc. But right now, let’s focus on the game logic. This is how your prototype will look after you finish the tutorial:\n\nIn this tutorial you will learn:\n• How to store the pieces and board using matrices (multidimensional arrays).\n• How to solve the rotation problem in Tetris, in a really easy way, without using complex maths or anything difficult, just using an intelligent hack.\n• How to check collisions between the pieces and the board.\n• How the main loop of a Tetris game works.\n\nWhat you are supposed to already know:\n• A little bit of graphical programming if you want expand the tutorial with improved graphics. Don’t worry about that if you just want to learn the Tetris game logic.\n\nWhat do you need?\n• A compiler or programming IDE. I’ve used Visual C++ Express Edition for this tutorial, that is a free C++ IDE. But you can use the one of your choice, of course.\n\nWhat is the license of the sourcecode?\n\nThe sourcecode is under the «Creative Commons – Attribution 3.0 Unported». That means you can copy, distribute and transmit the work and to adapt it. But you must attribute the work (but not in any way that suggests that they endorse you or your use of the work). The manner of attribution is up to you. You can just mention me (Javier López). A backlink would be also appreciated.\n\nFirst, we are going to create a class for storing all the pieces. There are 7 different types of pieces: square, I, L, L-mirrored, N, N-mirrored and T. But, how can we define each piece? Just check out the figure:\n\nAs you can see, this piece is defined in a matrix of 5×5 cells. 0 means «no block», 1 means «normal block» and 2 means «pivot block». The pivot block is the rotation point: yes, the original Tetris game has a rotation point for each piece 🙂\n\nAnd how can we store that using C++? Easy: using a bidimensional array of 5×5 ints (or bytes, if you are a fanatic of optimization). The previous piece is stored like that:\n\nNow that we already now how to store each piece let’s think about rotations. We can solve the rotation problem in a lot of different ways. In other tutorials, I’ve seen them use complex rotation algebra in order to rotate the piece… but we can solve this problem easily. If we can store each piece… why don’t we just store each piece rotated too? There are four possible rotations for each piece:\n\nAs you can see, the longer piece is only 4 block widht. But we are using 5 blocks matrices in order to be able to store all the rotations respeting the pivot block. In a previous version of this tutorial, I was using 4-block matrices, but then it was necessary to store translations of the pivot to the origin. This way, we are using some bytes more but the sourcecode is cleaner. In total we only use 448 bytes to store all the pieces. That’s nothing 🙂\n\nSo, in order to store all this information we need a 4-dimensional array (wow!), in order to store the 4 possible rotations (matrices of 5×5) of each piece:\n\nGreat! Now, in order to rotate a piece we just have to choose the following stored rotated piece.\n\nThere is something important that we have to take in count. Each different piece must be correctly positioned every time it is created on the top of the screen. In other words, it needs to be translated to the correct position (in order to show ONLY one row of blocks in the board and to be centered, upper blocks should be OUTSIDE the board). Like each piece is different (some are lower or smaller than others in the matrices), each one needs a different translation every time it is created. We will store these translations in another array, one translation per rotated piece. Take your time to understand this.\n\nThe translation are two numbers (horizontal tranlastion, vertical translation) that we have to store for each piece. We will use these numbers later in «Game» class when creating the pieces each time a new piece appears, so it will be initialized in the correct position. This is the array that stores these displacements:\n\n[c language=»++»]\n\n // Displacement of the piece to the position where it is first drawn in the board when it is created\n\n int mPiecesInitialPosition [7 /*kind */ ][4 /* r2otation */ ][2 /* position */] =\n\n {\n\n /* Square */\n\n {\n\n {-2, -3},\n\n {-2, -3},\n\n {-2, -3},\n\n {-2, -3}\n\n },\n\n /* I */\n\n {\n\n {-2, -2},\n\n {-2, -3},\n\n {-2, -2},\n\n {-2, -3}\n\n },\n\n /* L */\n\n {\n\n {-2, -3},\n\n {-2, -3},\n\n {-2, -3},\n\n {-2, -2}\n\n },\n\n /* L mirrored */\n\n {\n\n {-2, -3},\n\n {-2, -2},\n\n {-2, -3},\n\n {-2, -3}\n\n },\n\n /* N */\n\n {\n\n {-2, -3},\n\n {-2, -3},\n\n {-2, -3},\n\n {-2, -2}\n\n },\n\n /* N mirrored */\n\n {\n\n {-2, -3},\n\n {-2, -3},\n\n {-2, -3},\n\n {-2, -2}\n\n },\n\n /* T */\n\n {\n\n {-2, -3},\n\n {-2, -3},\n\n {-2, -3},\n\n {-2, -2}\n\n },\n\n };\n\n [/c]\n\nAnd with that we have solved one of the most tricky parts of this tutorial.\n\nWe can now create our Pieces class, this file is called «Pieces.h»:\n\nThe 3 methods that you can see in the header returns some information that we will need later. Their implementation is trivial:\n\n[c language=»++»]\n\n /*\n\n ======================================\n\n Return the type of a block (0 = no-block, 1 = normal block, 2 = pivot block)\n\n>> pPiece: Piece to draw\n\n >> pRotation: 1 of the 4 possible rotations\n\n >> pX: Horizontal position in blocks\n\n >> pY: Vertical position in blocks\n\n ======================================\n\n */\n\n int Pieces::GetBlockType (int pPiece, int pRotation, int pX, int pY)\n\n {\n\n return mPieces [pPiece][pRotation][pX][pY];\n\n }\n\n/*\n\n ======================================\n\n Returns the horizontal displacement of the piece that has to be applied in order to create it in the\n\n correct position.\n\n>> pPiece: Piece to draw\n\n >> pRotation: 1 of the 4 possible rotations\n\n ======================================\n\n */\n\n int Pieces::GetXInitialPosition (int pPiece, int pRotation)\n\n {\n\n return mPiecesInitialPosition [pPiece][pRotation][0];\n\n }\n\n/*\n\n ======================================\n\n Returns the vertical displacement of the piece that has to be applied in order to create it in the\n\n correct position.\n\n>> pPiece: Piece to draw\n\n >> pRotation: 1 of the 4 possible rotations\n\n ======================================\n\n */\n\n int Pieces::GetYInitialPosition (int pPiece, int pRotation)\n\n {\n\n return mPiecesInitialPosition [pPiece][pRotation][1];\n\n }\n\n [/c]\n\nNow we are going to learn how to store the pieces in the board and check collisions. This class stores a bidimensional array of N x N blocks that are initialized to POS_FREE. The pieces will be stored by filling these blocks when they fall down updating the block to POS_FILLED. In this class we need to implement methods in order to store a piece, check if a movement is possible, delete lines, etc. Our board is going to be very flexible, we will be able to choose the amount of horizontal and vertical blocks and the size of each block.\n\nThis is the header of the class («Board.h»):\n\n#define BOARD_LINE_WIDTH 6 // Width of each of the two lines that delimit the board\n\n #define BLOCK_SIZE 16 // Width and Height of each block of a piece\n\n #define BOARD_POSITION 320 // Center position of the board from the left of the screen\n\n #define BOARD_WIDTH 10 // Board width in blocks\n\n #define BOARD_HEIGHT 20 // Board height in blocks\n\n #define MIN_VERTICAL_MARGIN 20 // Minimum vertical margin for the board limit\n\n #define MIN_HORIZONTAL_MARGIN 20 // Minimum horizontal margin for the board limit\n\n #define PIECE_BLOCKS 5 // Number of horizontal and vertical blocks of a matrix piece\n\nenum { POS_FREE, POS_FILLED }; // POS_FREE = free position of the board; POS_FILLED = filled position of the board\n\n int mBoard [BOARD_WIDTH][BOARD_HEIGHT]; // Board that contains the pieces\n\n Pieces *mPieces;\n\n int mScreenHeight;\n\nNow, let’s see each different method.\n\nInitBoard method is just a nested loop that initializes all the board blocks to POS_FREE.\n\n[c language=»++»]\n\n /*\n\n ======================================\n\n Init the board blocks with free positions\n\n ======================================\n\n */\n\n void Board::InitBoard()\n\n {\n\n for (int i = 0; i < BOARD_WIDTH; i++)\n\n for (int j = 0; j < BOARD_HEIGHT; j++)\n\n mBoard[i][j] = POS_FREE;\n\n }\n\n [/c]\n\nStorePiece method, just stores a piece in the board by filling the appropriate blocks as POS_FILLED. There is a nested loop that iterates through the piece matrix and store the blocks in the board.\n\n======================================\n\n Store a piece in the board by filling the blocks\n\n>> pX: Horizontal position in blocks\n\n >> pY: Vertical position in blocks\n\n >> pPiece: Piece to draw\n\n >> pRotation: 1 of the 4 possible rotations\n\n ======================================\n\n */\n\n void Board::StorePiece (int pX, int pY, int pPiece, int pRotation)\n\n {\n\n // Store each block of the piece into the board\n\n for (int i1 = pX, i2 = 0; i1 < pX + PIECE_BLOCKS; i1++, i2++)\n\n {\n\n for (int j1 = pY, j2 = 0; j1 < pY + PIECE_BLOCKS; j1++, j2++)\n\n {\n\n // Store only the blocks of the piece that are not holes\n\n if (mPieces->GetBlockType (pPiece, pRotation, j2, i2) != 0)\n\n mBoard[i1][j1] = POS_FILLED;\n\n }\n\n }\n\n }\n\n [/c]\n\nIsGameOver checks if there are blocks in the first row. That means the game is over.\n\n[c language=»++»]\n\n /*\n\n ======================================\n\n Check if the game is over becase a piece have achived the upper position\n\nReturns true or false\n\n ======================================\n\n */\n\n bool Board::IsGameOver()\n\n {\n\n //If the first line has blocks, then, game over\n\n for (int i = 0; i < BOARD_WIDTH; i++)\n\n {\n\n if (mBoard[i][0] == POS_FILLED) return true;\n\n }\n\nDeleteLine is the method that erases a line and moves all the blocks of upper positions one row down. It just starts from the line that has to be removed, and then, iterating through the board in a nested loop, moves all the blocks of the upper lines one row done.\n\n[c language=»++»]\n\n /*\n\n ======================================\n\n Delete a line of the board by moving all above lines down\n\n>> pY: Vertical position in blocks of the line to delete\n\n ======================================\n\n */\n\n void Board::DeleteLine (int pY)\n\n {\n\n // Moves all the upper lines one row down\n\n for (int j = pY; j > 0; j–)\n\n {\n\n for (int i = 0; i < BOARD_WIDTH; i++)\n\n {\n\n mBoard[i][j] = mBoard[i][j-1];\n\n }\n\n }\n\n }\n\n [/c]\n\nDeletePossibleLines is a method that removes all the lines that should be erased from the board. It works by first checking which lines should be removed (the ones that have all their horizontal blocks filled). Then, it uses the DeleteLine method in order to erase that line and move all the upper lines one row down.\n\n[c language=»++»]\n\n /*\n\n ======================================\n\n Delete all the lines that should be removed\n\n ======================================\n\n */\n\n void Board::DeletePossibleLines ()\n\n {\n\n for (int j = 0; j < BOARD_HEIGHT; j++)\n\n {\n\n int i = 0;\n\n while (i < BOARD_WIDTH)\n\n {\n\n if (mBoard[i][j] != POS_FILLED) break;\n\n i++;\n\n }\n\nIsFreeBlock is a trivial method that checks out if a board block is filled or not.\n\n[c language=»++»]\n\n /*\n\n ======================================\n\n Returns 1 (true) if the this block of the board is empty, 0 if it is filled\n\n>> pX: Horizontal position in blocks\n\n >> pY: Vertical position in blocks\n\n ======================================\n\n */\n\n bool Board::IsFreeBlock (int pX, int pY)\n\n {\n\n if (mBoard [pX][pY] == POS_FREE) return true; else return false;\n\n }\n\n [/c]\n\nUntil now we have been always talking about «blocks». But in order to draw them to the screen we need to specify the position in pixels. So, we need two methods (GetXPosInPixels and GetYPosInPixels ) in order to obtain the horizontal and vertical position in pixels of a given block.\n\n[c language=»++»]\n\n /*\n\n ======================================\n\n Returns the horizontal position (in pixels) of the block given like parameter\n\n>> pPos: Horizontal position of the block in the board\n\n ======================================\n\n */\n\n int Board::GetXPosInPixels (int pPos)\n\n {\n\n return ( ( BOARD_POSITION – (BLOCK_SIZE * (BOARD_WIDTH / 2)) ) + (pPos * BLOCK_SIZE) );\n\n }\n\n/*\n\n ======================================\n\n Returns the vertical position (in pixels) of the block given like parameter\n\n>> pPos: Horizontal position of the block in the board\n\n ======================================\n\n */\n\n int Board::GetYPosInPixels (int pPos)\n\n {\n\n return ( (mScreenHeight – (BLOCK_SIZE * BOARD_HEIGHT)) + (pPos * BLOCK_SIZE) );\n\n }\n\n [/c]\n\nIsPossibleMovement is the last and most complex method of Board class. This method will be used later in the main loop to check if the movement of a piece is possible or not. The method compares all the blocks of a piece with the blocks already stored in the board and with the board limits. That comparison is made by iterating through the piece matrix and comparing with the appropriate 5×5 area in the board. If there is a collision that means the movement is not possible, so it returns false. If there is no collision, the movement is possible and it returns true.\n\n[c language=»++»]\n\n /*\n\n ======================================\n\n Check if the piece can be stored at this position without any collision\n\n Returns true if the movement is possible, false if it not possible\n\n>> pX: Horizontal position in blocks\n\n >> pY: Vertical position in blocks\n\n >> pPiece: Piece to draw\n\n >> pRotation: 1 of the 4 possible rotations\n\n ======================================\n\n */\n\n bool Board::IsPossibleMovement (int pX, int pY, int pPiece, int pRotation)\n\n {\n\n // Checks collision with pieces already stored in the board or the board limits\n\n // This is just to check the 5×5 blocks of a piece with the appropriate area in the board\n\n for (int i1 = pX, i2 = 0; i1 < pX + PIECE_BLOCKS; i1++, i2++)\n\n {\n\n for (int j1 = pY, j2 = 0; j1 < pY + PIECE_BLOCKS; j1++, j2++)\n\n {\n\n // Check if the piece is outside the limits of the board\n\n if ( i1 < 0 ||\n\n i1 > BOARD_WIDTH – 1 ||\n\n j1 > BOARD_HEIGHT – 1)\n\n {\n\n if (mPieces->GetBlockType (pPiece, pRotation, j2, i2) != 0)\n\n return 0;\n\n }\n\n// Check if the piece have collisioned with a block already stored in the map\n\n if (j1 >= 0)\n\n {\n\n if ((mPieces->GetBlockType (pPiece, pRotation, j2, i2) != 0) &&\n\n (!IsFreeBlock (i1, j1)) )\n\n return false;\n\n }\n\n }\n\n }\n\nNow we are going to implement a general class, called «Game», that itializes the game, draws the board and pieces by drawing each block as a rectangle (using another class that we will see later called «IO» that uses SDL) and creates new random pieces.\n\nThis is the header, «Game.h»:\n\n#define WAIT_TIME 700 // Number of milliseconds that the piece remains before going 1 block down */\n\nint mPosX, mPosY; // Position of the piece that is falling down\n\n int mPiece, mRotation; // Kind and rotation the piece that is falling down\n\nint mScreenHeight; // Screen height in pixels\n\n int mNextPosX, mNextPosY; // Position of the next piece\n\n int mNextPiece, mNextRotation; // Kind and rotation of the next piece\n\nAs you can see, the current piece is defined using 4 variables: mPosX, mPosY (the position of the piece in blocks), mPiece (the type of the piece), mRotation (the current matrix that defines the piece, as we have seen, each piece has four matrices, one for each rotation).\n\nLet’s see the implementation of the methods.\n\nGetRand is a trivial method that returns a random number between two boundaries.\n\n[c language=»++»]\n\n /*\n\n ======================================\n\n Get a random int between to integers\n\nParameters:\n\n >> pA: First number\n\n >> pB: Second number\n\n ======================================\n\n */\n\n int Game::GetRand (int pA, int pB)\n\n {\n\n return rand () % (pB – pA + 1) + pA;\n\n }\n\n [/c]\n\nInitGame, takes care of the initialization of the game by selecting the first and next piece randomly. The next piece is shown so the player can see which piece will appear next. This method also sets the position in blocks of that pieces. We use two methods that we have seen before in «Pieces» class: GetXInitialPosition and GetYInitialPosition in order to initialize the piece in the correct position.\n\n[c language=»++»]\n\n /*\n\n ======================================\n\n Initial parameters of the game\n\n ======================================\n\n */\n\n void Game::InitGame()\n\n {\n\n // Init random numbers\n\n srand ((unsigned int) time(NULL));\n\nCreateNewPiece method sets the «next piece» as the current one and resets its position, then selects a new «next piece».\n\n[c language=»++»]\n\n /*\n\n ======================================\n\n Create a random piece\n\n ======================================\n\n */\n\n void Game::CreateNewPiece()\n\n {\n\n // The new piece\n\n mPiece = mNextPiece;\n\n mRotation = mNextRotation;\n\n mPosX = (BOARD_WIDTH / 2) + mPieces->GetXInitialPosition (mPiece, mRotation);\n\n mPosY = mPieces->GetYInitialPosition (mPiece, mRotation);\n\nDrawPiece is a really easy method that iterates through the piece matrix and draws each block of the piece. It uses green for the normal blocks and blue for the pivot block. For drawing the rectangles it calls to DrawRectangle method of the class «IO» that we will see later.\n\n>> pX: Horizontal position in blocks\n\n >> pY: Vertical position in blocks\n\n >> pPiece: Piece to draw\n\n >> pRotation: 1 of the 4 possible rotations\n\n ======================================\n\n */\n\n void Game::DrawPiece (int pX, int pY, int pPiece, int pRotation)\n\n {\n\n color mColor; // Color of the block\n\n// Obtain the position in pixel in the screen of the block we want to draw\n\n int mPixelsX = mBoard->GetXPosInPixels (pX);\n\n int mPixelsY = mBoard->GetYPosInPixels (pY);\n\n// Travel the matrix of blocks of the piece and draw the blocks that are filled\n\n for (int i = 0; i < PIECE_BLOCKS; i++)\n\n {\n\n for (int j = 0; j < PIECE_BLOCKS; j++)\n\n {\n\n // Get the type of the block and draw it with the correct color\n\n switch (mPieces->GetBlockType (pPiece, pRotation, j, i))\n\n {\n\n case 1: mColor = GREEN; break; // For each block of the piece except the pivot\n\n case 2: mColor = BLUE; break; // For the pivot\n\n }\n\nDrawBoard is similiar to the previous method. It draws two blue columns that are used as the limits of the boards. Then draws the board blocks that are flagged as POS_FILLED in a nested loop.\n\nDraw the two lines that delimit the board\n\n ======================================\n\n */\n\n void Game::DrawBoard ()\n\n {\n\n// Calculate the limits of the board in pixels\n\n int mX1 = BOARD_POSITION – (BLOCK_SIZE * (BOARD_WIDTH / 2)) – 1;\n\n int mX2 = BOARD_POSITION + (BLOCK_SIZE * (BOARD_WIDTH / 2));\n\n int mY = mScreenHeight – (BLOCK_SIZE * BOARD_HEIGHT);\n\n// Check that the vertical margin is not to small\n\n //assert (mY > MIN_VERTICAL_MARGIN);\n\n// Rectangles that delimits the board\n\n mIO->DrawRectangle (mX1 – BOARD_LINE_WIDTH, mY, mX1, mScreenHeight – 1, BLUE);\n\n// Check that the horizontal margin is not to small\n\n //assert (mX1 > MIN_HORIZONTAL_MARGIN);\n\n// Drawing the blocks that are already stored in the board\n\n mX1 += 1;\n\n for (int i = 0; i < BOARD_WIDTH; i++)\n\n {\n\n for (int j = 0; j < BOARD_HEIGHT; j++)\n\n {\n\n // Check if the block is filled, if so, draw it\n\n if (!mBoard->IsFreeBlock(i, j))\n\n mIO->DrawRectangle ( mX1 + i * BLOCK_SIZE,\n\n mY + j * BLOCK_SIZE,\n\n (mX1 + i * BLOCK_SIZE) + BLOCK_SIZE – 1,\n\n (mY + j * BLOCK_SIZE) + BLOCK_SIZE – 1,\n\n RED);\n\n }\n\n }\n\n }\n\n [/c]\n\nDrawScene, just calls the previous methods in order to draw everything.\n\nDraw all the objects of the scene\n\n ======================================\n\n */\n\n void Game::DrawScene ()\n\n {\n\n DrawBoard (); // Draw the delimitation lines and blocks stored in the board\n\n DrawPiece (mPosX, mPosY, mPiece, mRotation); // Draw the playing piece\n\n DrawPiece (mNextPosX, mNextPosY, mNextPiece, mNextRotation); // Draw the next piece\n\n }\n\n [/c]\n\nStep 4: Easy drawing, window management and keyboard input using SDL, isolated from the game logic\n\n«IO.cpp» and «IO.h» are the files that implement the «IO» class. It uses SDL in order to create the window, clear it, update the screen and take care of the keyboard input. You can check out «IO.cpp» and «IO.h» files in order to see its implementation. I’m not going to explain the methods that are SDL related. You can change this class in order to use a different renderer (like IndieLib, Allegro, OpenGL, Direct3d, etc).\n\nThis is the header («IO.h»):\n\nThe main loop is quite simple. In each frame we draw everything. Later, we use keyboard input in order to move the piece. Before each movement, we first check out if it is possible. We also measure the time in order to move the piece down every n milliseconds. When the piece fall down one block, we check out if that movement is possible, if not, we store the piece in the board. We also check out if there are blocks in the upper row, if so, the game is over.\n\nFirst, we initialize all the classes. Then, we get the actual milliseconds, which will be used to determine when the piece should move down.\n\n// Class for drawing staff, it uses SDL for the rendering. Change the methods of this class\n\n // in order to use a different renderer\n\n IO mIO;\n\n int mScreenHeight = mIO.GetScreenHeight();\n\n// Get the actual clock milliseconds (SDL)\n\n unsigned long mTime1 = SDL_GetTicks();\n\n [/c]\n\nThis is the main loop. We can exit by pressing ESC. In each frame we clear and update the screen and draw everything.\n\nmIO.ClearScreen (); // Clear screen\n\n mGame.DrawScene (); // Draw staff\n\n mIO.UpdateScreen (); // Put the graphic context in the screen\n\n [/c]\n\nWe start with the input. If we press left, down or right we try to move the piece in that directions. We only move the piece if the movement is possible.\n\nBy pressing «x», the piece will fall down directly to the ground. This is really easy to implement by trying to move the piece down until the movement is not possible. Then we store the piece, delete possible lines and check out if the game is over, if not, we create a new piece.\n\n[c language=»++»]\n\n case (SDLK_x):\n\n {\n\n // Check collision from up to down\n\n while (mBoard.IsPossibleMovement(mGame.mPosX, mGame.mPosY, mGame.mPiece, mGame.mRotation)) { mGame.mPosY++; }\n\nBy pressing «z» we rotate the piece. With the methods that we have already implement this is an easy task. The rotation is in fact to change to the next rotated stored piece. We first should check that the rotated piece will be drawn without colliding, if so, we sets this rotation as the current one.\n\nIf WAIT_TIME passed, the piece should fall down one block. We have to check out if the movement is possible, if not, the piece should be stored and we have to check if we can delete lines. We also see if the game is over, if not, we create a new piece.\n\nAnd that’s all! Please leave a comment if you see some mistakes, language errors or if you have any doubts… or just to say thanks! 🙂\n• Special thanks: Imelior, who fixed English mistakes and compiled the tutorial under Linux.\n• Special thanks: Javier Santana, who added #ifndef sentences and pointed that was necessary to use libsdl-gfx1.2-dev and libsdl1.2-dev under Linux.\n\nDon’t forget to play with the «defines». Crazy example:\n\n[c language=»++»]\n\n #define BLOCK_SIZE 5 // Width and Height of each block of a\n\n #define BOARD_WIDTH 90 // Board width in blocks\n\n #define BOARD_HEIGHT 90 // Board height in blocks\n\n [/c]\n\nYou should follow me on Twitter\n\nDid you like the tutorial? Then you should follow me on twitter here."
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/17wpv3c/what_c_libraries_are_suitable_for_game",
        "document": "Hi, I am learning C++ and plan to create games. I am aware that C++ has numerous graphic libraries such as SFML and OpenGL.\n\nDo you have any experience in game development with C++? Could you recommend cross-platform libraries suitable for creating games on both Android and Windows?\n\nI've read about SFML, but it seems officially unsupported for Android game development. SDL has limited documentation.\n\nHas anyone successfully developed or published games on Steam or the Google Play using such libraries? I prefer not to use game engines at this stage.\n\nP.S. English is not my native language, so there might be some mistakes."
    },
    {
        "link": "https://github.com/raizam/gamedev_libraries",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/ddn4b2/which_c_library_for_game_development",
        "document": "I am totally new to game development but I have good command in c++. I have a project in which I have to create a desktop game and I am not allowed to use any game engines such as unity, so I was thinking of using some libraries which do not force a design on my game.\n\nAs I mentioned before that I am a newbie to game development, so I searched internet for some libraries for game development and I came up with SDL2, SFML, OpenGL. I still don't know which is the easier one to learn and implement my project with, can you guys help me decide?"
    },
    {
        "link": "https://quora.com/Which-are-the-best-libraries-for-game-development-in-c++",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/programming-with-cplusplus-in-unreal-engine",
        "document": "Unreal Engine provides a robust framework for C++ programmers to help bring their vision to life.\n\nThis section covers several powerful features that you can use to accelerate your development workflows. You can learn about:\n• Creating new Gameplay classes in C++, and all changes will be reflected in the Unreal Editor after compiling with either Visual Studio or XCode. Creating classes in Unreal Engine is similar to creating standard C++ classes, functions, and variables. These are defined using standard C++ syntax.\n• Using the Unreal Reflection System to encapsulate your classes with Metadata Property Specifier macros that provide Editor functionality. Each class defines a template for a new Object or Actor.\n• Containers in Unreal Engine provide information on Class and Data Structure collections.\n• Using the Gameplay Architecture to build your projects in Unreal Engine. The Gameplay Framework provides a hierarchy of Objects and Actors. These classes contain boilerplate variables and functions you can use when creating and designing interactive experiences.\n• Creating Delegates to call member functions on C++ objects in a generic, type-safe way. You can dynamically bind a delegate to a member function of an arbitrary object, calling the function on the object at a future time, even if the caller does not know the object`s type."
    }
]