[
    {
        "link": "https://en.wikipedia.org/wiki/C11_(C_standard_revision)",
        "document": "C11 (previously C1X, formally ISO/IEC 9899:2011[1]) is a past standard for the C programming language. It replaced C99 (standard ISO/IEC 9899:1999) and has been superseded by C17 (standard ISO/IEC 9899:2018). C11 mainly standardizes features already supported by common contemporary compilers, and includes a detailed memory model to better support multiple threads of execution. Due to delayed availability of conforming C99 implementations, C11 makes certain features optional, to make it easier to comply with the core language standard.[2][3]\n\nThe final draft, N1570,[4] was published in April 2011. The new standard passed its final draft review on October 10, 2011 and was officially ratified by ISO and published as ISO/IEC 9899:2011 on December 8, 2011, with no comments requiring resolution by participating national bodies.\n\nA standard macro is defined with value to indicate that C11 support is available.[5]\n\nThe standard includes several changes to the C99 language and library specifications, such as[6]\n• The function specifier and the header\n• Type-generic expressions using the keyword. For example, the following macro translates to , or depending on the type of :\n• Multi-threading support ( storage-class specifier, header including thread creation/management functions, mutex, condition variable and thread-specific storage functionality, as well as 7 for atomic operations supporting the C11 memory model).\n• Improved Unicode support based on the C Unicode Technical Report ISO/IEC TR 19769:2004 ( and types for storing UTF-16/UTF-32 encoded data, including conversion functions in and the corresponding and string literal prefixes, as well as the prefix for UTF-8 encoded literals). 8\n• Removal of the function (in favor of safer ), which was deprecated in the previous C language standard revision, ISO/IEC 9899:1999/Cor.3:2007(E).\n• More macros for querying the characteristics of floating-point types, concerning subnormal floating-point numbers and the number of decimal digits the type is able to store.\n• Anonymous structures and unions, useful when unions and structures are nested, e.g. in .\n• Static assertions, which are evaluated during translation at a later phase than and , when types are understood by the translator.\n• An exclusive create-and-open mode ( suffix) for . This behaves like in POSIX, which is commonly used for lock files.\n• The function as a third way to terminate a program, intended to do at least minimal deinitialization. 10\n• A new function and corresponding structure in with a degree of POSIX compatibility.\n• Macros for the construction of complex values (partly because might not yield the expected value if is infinite or NaN). 11\n\nThe new revision allows implementations to not support certain parts of the standard — including some that had been mandatory to support in the 1999 revision.[12] Programs can use predefined macros to determine whether an implementation supports a certain feature or not.\n\nSome features of C11 are supported by the GCC starting with version 4.6,[16] Clang starting with version 3.1,[17] IBM XL C starting with version 12.1,[18] and Microsoft Visual C++ starting with VS 2019 (16.8)[19] in September 2020.\n\nThe optional bounds-checking interfaces (Annex K) remain controversial and have not been widely implemented, and their deprecation or removal from the next standard revision has been proposed.[20] Even Microsoft, a main proponent of this interface, does not conform to the definition.[21] In addition, Annex K does not include the more useful TR24731-2 (dynamic allocation functions), such as and .[22] The few open-source implementations include Open Watcom C/C++'s \"Safer C\" library[23] and safeclib.[24]\n• C++23, C++20, C++17, C++14, C++11, C++03, C++98, versions of the C++ programming language standard\n• Compatibility of C and C++\n• None Plum, Thomas (April 6, 2012). \"C Finally Gets A New Standard\". Dr. Dobb's Journal.\n• Safe C API—Concise solution of buffer overflow, The OWASP Foundation, OWASP AppSec, Beijing 2011"
    },
    {
        "link": "https://ibm.com/docs/en/xl-c-aix/13.1.0?topic=121-c11-features",
        "document": "XL C V12.1 introduces support for selected features of C11, which is a new C programming language standard.\n\nIBM supports selected features of C11, known as C1X before its ratification. IBM will continue to develop and implement the features of this standard. The implementation of the language level is based on IBM's interpretation of the standard. Until IBM's implementation of all the C11 features is complete, including the support of a new C11 standard library, the implementation may change from release to release. IBM makes no attempt to maintain compatibility, in source, binary, or listings and other compiler interfaces, with earlier releases of IBM's implementation of the C11 features.\n\nThis feature enables the declaration of anonymous structures under the extc1x language level. For more information, see \"Anonymous structures\".\n\nMacros CMPLX, CMPLXF, and CMPLXL are defined inside the standard header file complex.h to enable the initialization of complex types under the extc1x language level. For more information, see \"Initialization of complex types (C11)\".\n\nA new suboption has been added to the -qlanglvl option in this release. You can use -qlanglvl=extc1x to enable C11 features that are currently supported by XL C.\n\nThe function specifier declares that a function does not return to its caller. You can define your own functions that do not return using this function specifier. The compiler can produce better code by ignoring what would happen if the function returns. For more information, see \"The _Noreturn function specifier\".\n• Implementations of the C Standard Library can detect and diagnose common usage errors, improving usability. You can declare static assertions to check important program invariants at compile time. The addition of static assertions to the C language has the following benefits:You can declare static assertions to check important program invariants at compile time. For more information, see \"_Static_assert declaration (C11)\"."
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/1gloaxm/what_are_the_differences_between_c11_and_other_c",
        "document": "and what is the best version to learn c on?"
    },
    {
        "link": "https://en.wikipedia.org/wiki/C%2B%2B11",
        "document": "2011 edition of the C++ programming language standard\n\nC++11 is a version of a joint technical standard, ISO/IEC 14882, by the International Organization for Standardization (ISO) and International Electrotechnical Commission (IEC), for the C++ programming language. C++11 replaced the prior version of the C++ standard, named C++03,[1] and was later replaced by C++14. The name follows the tradition of naming language versions by the publication year of the specification, though it was formerly named C++0x because it was expected to be published before 2010.[2]\n\nAlthough one of the design goals was to prefer changes to the libraries over changes to the core language,[3] C++11 does make several additions to the core language. Areas of the core language that were significantly improved include multithreading support, generic programming support, uniform initialization, and performance. Significant changes were also made to the C++ Standard Library, incorporating most of the C++ Technical Report 1 (TR1) libraries, except the library of mathematical special functions.[4]\n\nC++11 was published as ISO/IEC 14882:2011[5] in September 2011 and is available for a fee. The working draft most similar to the published C++11 standard is N3337, dated 16 January 2012;[6] it has only editorial corrections from the C++11 standard.[7]\n\nC++11 is fully supported by Clang 3.3 and later.[8] C++11 is fully supported by GNU Compiler Collection (GCC) 4.8.1 and later.[9]\n\nThe design committee attempted to stick to a number of goals in designing C++11:\n• Prefer introducing new features via the standard library, rather than extending the core language\n• Improve C++ to facilitate systems and library design, rather than introduce new features useful only to specific applications\n• Increase performance and the ability to work directly with hardware\n• Make C++ easy to teach and to learn without removing any utility needed by expert programmers\n\nAttention to beginners is considered important, because most computer programmers will always be such, and because many beginners never widen their knowledge, limiting themselves to work in aspects of the language in which they specialize.[2][3]\n\nOne function of the C++ committee is the development of the language core. Areas of the core language that were significantly improved include multithreading support, generic programming support, uniform initialization, and performance.\n\nThese language features primarily exist to provide some kind of runtime performance benefit, either of memory or of computing speed.[citation needed]\n\nIn C++03 (and before), temporaries (termed \"rvalues\", as they often lie on the right side of an assignment) were intended to never be modifiable — just as in C — and were considered to be indistinguishable from types; nevertheless, in some cases, temporaries could have been modified, a behavior that was even considered to be a useful loophole.[10] C++11 adds a new non-const reference type called an rvalue reference, identified by . This refers to temporaries that are permitted to be modified after they are initialized, for the purpose of allowing \"move semantics\".\n\nA chronic performance problem with C++03 is the costly and unneeded deep copies that can happen implicitly when objects are passed by value. To illustrate the issue, consider that an is, internally, a wrapper around a C-style array with a defined size. If an temporary is created or returned from a function, it can be stored only by creating a new and copying all the rvalue's data into it. Then the temporary and all its memory is destroyed. (For simplicity, this discussion neglects the return value optimization.)\n\nIn C++11, a move constructor of that takes an rvalue reference to an can copy the pointer to the internal C-style array out of the rvalue into the new , then set the pointer inside the rvalue to null. Since the temporary will never again be used, no code will try to access the null pointer, and because the pointer is null, its memory is not deleted when it goes out of scope. Hence, the operation not only forgoes the expense of a deep copy, but is safe and invisible.\n\nRvalue references can provide performance benefits to existing code without needing to make any changes outside the standard library. The type of the returned value of a function returning an temporary does not need to be changed explicitly to to invoke the move constructor, as temporaries are considered rvalues automatically. (However, if is a C++03 version without a move constructor, then the copy constructor will be invoked with a , incurring a significant memory allocation.)\n\nFor safety reasons, some restrictions are imposed. A named variable will never be considered to be an rvalue even if it is declared as such. To get an rvalue, the function template should be used. Rvalue references can also be modified only under certain circumstances, being intended to be used primarily with move constructors.\n\nDue to the nature of the wording of rvalue references, and to some modification to the wording for lvalue references (regular references), rvalue references allow developers to provide perfect function forwarding. When combined with variadic templates, this ability allows for function templates that can perfectly forward arguments to another function that takes those particular arguments. This is most useful for forwarding constructor parameters, to create factory functions that will automatically call the correct constructor for those particular arguments. This is seen in the emplace_back set of the C++ standard library methods.\n\nC++ has always had the concept of constant expressions. These are expressions such as that will always yield the same results, at compile time and at runtime. Constant expressions are optimization opportunities for compilers, and compilers frequently execute them at compile time and hardcode the results in the program. Also, in several places, the C++ specification requires using constant expressions. Defining an array requires a constant expression, and enumerator values must be constant expressions.\n\nHowever, a constant expression has never been allowed to contain a function call or object constructor. So a piece of code as simple as this is invalid:\n\nThis was not valid in C++03, because is not a constant expression. A C++03 compiler has no way of knowing if actually is constant at runtime. In theory, this function could affect a global variable, call other non-runtime constant functions, etc.\n\nC++11 introduced the keyword , which allows the user to guarantee that a function or object constructor is a compile-time constant.[11] The above example can be rewritten as follows:\n\nThis allows the compiler to understand, and verify, that is a compile-time constant.\n\nUsing on a function imposes some limits on what that function can do. First, the function must have a non-void return type. Second, the function body cannot declare variables or define new types. Third, the body may contain only declarations, null statements and a single return statement. There must exist argument values such that, after argument substitution, the expression in the return statement produces a constant expression.\n\nBefore C++11, the values of variables could be used in constant expressions only if the variables are declared const, have an initializer which is a constant expression, and are of integral or enumeration type. C++11 removes the restriction that the variables must be of integral or enumeration type if they are defined with the keyword:\n\nSuch data variables are implicitly const, and must have an initializer which must be a constant expression.\n\nTo construct constant expression data values from user-defined types, constructors can also be declared with . A constructor's function body can contain only declarations and null statements, and cannot declare variables or define types, as with a function. There must exist argument values such that, after argument substitution, it initializes the class's members with constant expressions. The destructors for such types must be trivial.\n\nThe copy constructor for a type with any constructors should usually also be defined as a constructor, to allow objects of the type to be returned by value from a constexpr function. Any member function of a class, such as copy constructors, operator overloads, etc., can be declared as , so long as they meet the requirements for constexpr functions. This allows the compiler to copy objects at compile time, perform operations on them, etc.\n\nIf a constexpr function or constructor is called with arguments which aren't constant expressions, the call behaves as if the function were not constexpr, and the resulting value is not a constant expression. Likewise, if the expression in the return statement of a constexpr function does not evaluate to a constant expression for a given invocation, the result is not a constant expression.\n\ndiffers from , introduced in C++20, in that the latter must always produce a compile time constant, while does not have this restriction.\n\nIn C++03, a class or struct must follow a number of rules for it to be considered a plain old data (POD) type. Types that fit this definition produce object layouts that are compatible with C, and they could also be initialized statically. The C++03 standard has restrictions on what types are compatible with C or can be statically initialized despite there being no technical reason a compiler couldn't accept the program; if someone were to create a C++03 POD type and add a non-virtual member function, this type would no longer be a POD type, could not be statically initialized, and would be incompatible with C despite no change to the memory layout.\n\nC++11 relaxed several of the POD rules, by dividing the POD concept into two separate concepts: trivial and standard-layout.\n\nA type that is trivial can be statically initialized. It also means that it is valid to copy data around via , rather than having to use a copy constructor. The lifetime of a trivial type begins when its storage is defined, not when a constructor completes.\n\nA trivial class or struct is defined as one that:\n• Has a trivial default constructor. This may use the default constructor syntax ( ).\n• Has trivial copy and move constructors, which may use the default syntax.\n• Has trivial copy and move assignment operators, which may use the default syntax.\n• Has a trivial destructor, which must not be virtual.\n\nConstructors are trivial only if there are no virtual member functions of the class and no virtual base classes. Copy/move operations also require all non-static data members to be trivial.\n\nA type that is standard-layout means that it orders and packs its members in a way that is compatible with C. A class or struct is standard-layout, by definition, provided:\n• It has no virtual functions\n• It has no virtual base classes\n• All its non-static data members have the same access control (public, private, protected)\n• All its non-static data members, including any in its base classes, are in the same one class in the hierarchy\n• The above rules also apply to all the base classes and to all non-static data members in the class hierarchy\n• It has no base classes of the same type as the first defined non-static data member\n\nA class/struct/union is considered POD if it is trivial, standard-layout, and all of its non-static data members and base classes are PODs.\n\nBy separating these concepts, it becomes possible to give up one without losing the other. A class with complex move and copy constructors may not be trivial, but it could be standard-layout and thus interoperate with C. Similarly, a class with public and private non-static data members would not be standard-layout, but it could be trivial and thus -able.\n\nIn C++03, the compiler must instantiate a template whenever a fully specified template is encountered in a translation unit. If the template is instantiated with the same types in many translation units, this can dramatically increase compile times. There is no way to prevent this in C++03, so C++11 introduced extern template declarations, analogous to extern data declarations.\n\nC++03 has this syntax to oblige the compiler to instantiate a template:\n\nC++11 now provides this syntax:\n\nwhich tells the compiler not to instantiate the template in this translation unit.\n\nThese features exist for the primary purpose of making the language easier to use. These can improve type safety, minimize code repetition, make erroneous code less likely, etc.\n\nC++03 inherited the initializer-list feature from C. A struct or array is given a list of arguments in braces, in the order of the members' definitions in the struct. These initializer-lists are recursive, so an array of structs or struct containing other structs can use them.\n\nThis is very useful for static lists, or initializing a struct to some value. C++ also provides constructors to initialize an object, but they are often not as convenient as the initializer list. However, C++03 allows initializer-lists only on structs and classes that conform to the Plain Old Data (POD) definition; C++11 extends initializer-lists, so they can be used for all classes including standard containers like .\n\nC++11 binds the concept to a template, called . This allows constructors and other functions to take initializer-lists as parameters. For example:\n\nThis allows to be constructed from a sequence of integers, such as:\n\nThis constructor is a special kind of constructor, called an initializer-list-constructor. Classes with such a constructor are treated specially during uniform initialization (see below)\n\nThe template class is a first-class C++11 standard library type. They can be constructed statically by the C++11 compiler via use of the syntax without a type name in contexts where such braces will deduce to an , or by explicitly specifying the type like (and so on for other varieties of construction syntax).\n\nThe list can be copied once constructed, which is cheap and will act as a copy-by-reference (the class is typically implemented as a pair of begin/end pointers). An is constant: its members cannot be changed once it is created, and nor can the data in those members be changed (which rules out moving from them, requiring copies into class members, etc.).\n\nAlthough its construction is specially treated by the compiler, an is a real type, and so it can be used in other places besides class constructors. Regular functions can take typed s as arguments. For example:\n\nExamples of this in the standard library include the and templates taking s of numeric type.\n\nStandard containers can also be initialized in these ways:\n\nC++03 has a number of problems with initializing types. Several ways to do this exist, and some produce different results when interchanged. The traditional constructor syntax, for example, can look like a function declaration, and steps must be taken to ensure that the compiler's most vexing parse rule will not mistake it for such. Only aggregates and POD types can be initialized with aggregate initializers (using ).\n\nC++11 provides a syntax that allows for fully uniform type initialization that works on any object. It expands on the initializer list syntax:\n\nThe initialization of behaves exactly as though it were aggregate-initialization. That is, each data member of an object, in turn, will be copy-initialized with the corresponding value from the initializer-list. Implicit type conversion will be used where needed. If no conversion exists, or only a narrowing conversion exists, the program is ill-formed. The initialization of invokes the constructor.\n\nOne can also do this:\n\nUniform initialization does not replace constructor syntax, which is still needed at times. If a class has an initializer list constructor ( ), then it takes priority over other forms of construction, provided that the initializer list conforms to the sequence constructor's type. The C++11 version of has an initializer list constructor for its template type. Thus this code:\n\nwill call the initializer list constructor, not the constructor of that takes a single size parameter and creates the vector with that size. To access the latter constructor, the user will need to use the standard constructor syntax directly.\n\nIn C++03 (and C), to use a variable, its type must be specified explicitly. However, with the advent of template types and template metaprogramming techniques, the type of something, particularly the well-defined return value of a function, may not be easily expressed. Thus, storing intermediates in variables is difficult, possibly needing knowledge of the internals of a given metaprogramming library.\n\nC++11 allows this to be mitigated in two ways. First, the definition of a variable with an explicit initialization can use the keyword.[12][13] This creates a variable of the specific type of the initializer:\n\nThe type of is simply whatever the particular template function override of returns for those particular arguments. This type is easily determined procedurally by the compiler as part of its semantic analysis duties, but is not easy for the user to determine upon inspection. The type of is also well-defined, but it is easier for the user to determine. It is an , which is the same type as the integer literal.\n\nThis use of the keyword in C++ re-purposes the semantics of this keyword, which was originally used in the typeless predecessor language B in a related role of denoting an untyped automatic variable definition.\n\nFurther, the keyword can be used to determine the type of expression at compile-time. For example:\n\nThis is more useful in conjunction with , since the type of auto variable is known only to the compiler. However, can also be very useful for expressions in code that makes heavy use of operator overloading and specialized types.\n\nis also useful for reducing the verbosity of the code. For instance, instead of writing\n\nthe programmer can use the shorter\n\nwhich can be further compacted since \"myvec\" implements begin/end iterators:\n\nThis difference grows as the programmer begins to nest containers, though in such cases s are a good way to decrease the amount of code.\n\nThe type denoted by can be different from the type deduced by .\n\nC++11 extends the syntax of the statement to allow for easy iteration over a range of elements:\n\nThis form of , called the “range-based for”, will iterate over each element in the list. It will work for C-style arrays, initializer lists, and any type that has and functions defined for it that return iterators. All the standard library containers that have begin/end pairs will work with the range-based for statement.\n\nC++11 provides the ability to create anonymous functions, called lambda functions.[14] These are defined as follows:\n\nThe return type ( in this example) can be omitted as long as all expressions return the same type. A lambda can optionally be a closure.\n\nStandard C function declaration syntax was perfectly adequate for the feature set of the C language. As C++ evolved from C, it kept the basic syntax and extended it where needed. However, as C++ grew more complex, it exposed several limits, especially regarding template function declarations. For example, in C++03 this is invalid:\n\nThe type is whatever the addition of types and will produce. Even with the aforementioned C++11 functionality of , this is not possible:\n\nThis is not valid C++ because and have not yet been defined; they will not be valid identifiers until after the parser has parsed the rest of the function prototype.\n\nTo work around this, C++11 introduced a new function declaration syntax, with a trailing-return-type:[15]\n\nThis syntax can be used for more mundane function declarations and definitions:\n\nThe use of the “auto” keyword in this case is just part of the syntax and does not perform automatic type deduction in C++11. However, starting with C++14, the trailing return type can be removed entirely and the compiler will deduce the return type automatically.[16]\n\nIn C++03, constructors of a class are not allowed to call other constructors in an initializer list of that class. Each constructor must construct all of its class members itself or call a common member function, as follows:\n\nConstructors for base classes cannot be directly exposed to derived classes; each derived class must implement constructors even if a base class constructor would be appropriate. Non-constant data members of classes cannot be initialized at the site of the declaration of those members. They can be initialized only in a constructor.\n\nC++11 provides solutions to all of these problems.\n\nC++11 allows constructors to call other peer constructors (termed delegation). This allows constructors to utilize another constructor's behavior with a minimum of added code. Delegation has been used in other languages e.g., Java and Objective-C.\n\nThis syntax is as follows:\n\nIn this case, the same effect could have been achieved by making a default parameter. The new syntax, however, allows the default value (42) to be expressed in the implementation rather than the interface — a benefit to maintainers of library code since default values for function parameters are “baked in” to call sites, whereas constructor delegation allows the value to be changed without recompilation of the code using the library.\n\nThis comes with a caveat: C++03 considers an object to be constructed when its constructor finishes executing, but C++11 considers an object constructed once any constructor finishes execution. Since multiple constructors will be allowed to execute, this will mean that each delegating constructor will be executing on a fully constructed object of its own type. Derived class constructors will execute after all delegation in their base classes is complete.\n\nFor base-class constructors, C++11 allows a class to specify that base class constructors will be inherited. Thus, the C++11 compiler will generate code to perform the inheritance and the forwarding of the derived class to the base class. This is an all-or-nothing feature: either all of that base class's constructors are forwarded or none of them are. Also, an inherited constructor will be shadowed if it matches the signature of a constructor of the derived class, and restrictions exist for multiple inheritance: class constructors cannot be inherited from two classes that use constructors with the same signature.\n\nThe syntax is as follows:\n\nFor member initialization, C++11 allows this syntax:\n\nAny constructor of the class will initialize with 5, if the constructor does not override the initialization with its own. So the above empty constructor will initialize as the class definition states, but the constructor that takes an int will initialize it to the given parameter.\n\nIt can also use constructor or uniform initialization, instead of the assignment initialization shown above.\n\nIn C++03, it is possible to accidentally create a new virtual function, when one intended to override a base class function. For example:\n\nSuppose the is intended to replace the base class version. But instead, because it has a different signature, it creates a second virtual function. This is a common problem, particularly when a user goes to modify the base class.\n\nC++11 provides syntax to solve this problem.\n\nThe special identifier means that the compiler will check the base class(es) to see if there is a virtual function with this exact signature. And if there is not, the compiler will indicate an error.\n\nC++11 also adds the ability to prevent inheriting from classes or simply preventing overriding methods in derived classes. This is done with the special identifier . For example:\n\nIn this example, the statement declares a new virtual function, but it also prevents derived classes from overriding it. It also has the effect of preventing derived classes from using that particular function name and parameter combination.\n\nNeither nor are language keywords. They are technically identifiers for declarator attributes:\n• they gain special meaning as attributes only when used in those specific trailing contexts (after all type specifiers, access specifiers, member declarations (for struct, class and enum types) and declarator specifiers, but before initialization or code implementation of each declarator in a comma-separated list of declarators);\n• they do not alter the declared type signature and do not declare or override any new identifier in any scope;\n• the recognized and accepted declarator attributes may be extended in future versions of C++ (some compiler-specific extensions already recognize added declarator attributes, to provide code generation options or optimization hints to the compiler, or to generate added data into the compiled code, intended for debuggers, linkers, and deployment of the compiled code, or to provide added system-specific security attributes, or to enhance reflective programming (reflection) abilities at runtime, or to provide added binding information for interoperability with other programming languages and runtime systems; these extensions may take parameters between parentheses after the declarator attribute identifier; for ANSI conformance, these compiler-specific extensions should use the double underscore prefix convention).\n• In any other location, they can be valid identifiers for new declarations (and later use if they are accessible).\n\nFor the purposes of this section and this section alone, every occurrence of \" \" is meant as \"a constant expression which evaluates to , which is of type int\". In reality, the constant expression can be of any integral type.\n\nSince the dawn of C in 1972, the constant has had the double role of constant integer and null pointer constant. The ambiguity inherent in the double meaning of was dealt with in C by using the preprocessor macro , which commonly expands to either or . C++ forbids implicit conversion from to other pointer types, thus removing the benefit of casting to . As a consequence, only is allowed as a null pointer constant. This interacts poorly with function overloading:\n\nIf is defined as (which is usually the case in C++), the statement will call , which is almost certainly not what the programmer intended, and not what a superficial reading of the code suggests.\n\nC++11 corrects this by introducing a new keyword to serve as a distinguished null pointer constant: . It is of type , which is implicitly convertible and comparable to any pointer type or pointer-to-member type. It is not implicitly convertible or comparable to integral types, except for . While the original proposal specified that an rvalue of type should not be convertible to , the core language working group decided that such a conversion would be desirable, for consistency with regular pointer types. The proposed wording changes were unanimously voted into the Working Paper in June 2008.[1] A similar proposal was also brought to the C standard working group and was accepted for inclusion in C23.[17]\n\nIn C++03, enumerations are not type-safe. They are effectively integers, even when the enumeration types are distinct. This allows the comparison between two enum values of different enumeration types. The only safety that C++03 provides is that an integer or a value of one enum type does not convert implicitly to another enum type. Further, the underlying integral type is implementation-defined; code that depends on the size of the enumeration is thus non-portable. Lastly, enumeration values are scoped to the enclosing scope. Thus, it is not possible for two separate enumerations in the same scope to have matching member names.\n\nC++11 allows a special classification of enumeration that has none of these issues. This is expressed using the ( is also accepted as a synonym) declaration:\n\nThis enumeration is type-safe. Enum class values are not implicitly converted to integers. Thus, they cannot be compared to integers either (the expression gives a compile error).\n\nThe underlying type of enum classes is always known. The default type is ; this can be overridden to a different integral type as can be seen in this example:\n\nWith old-style enumerations the values are placed in the outer scope. With new-style enumerations they are placed within the scope of the enum class name. So in the above example, is undefined, but is defined.\n\nThere is also a transitional syntax to allow old-style enumerations to provide explicit scoping, and the definition of the underlying type:\n\nIn this case the enumerator names are defined in the enumeration's scope ( ), but for backwards compatibility they are also placed in the enclosing scope.\n\nForward-declaring enums is also possible in C++11. Formerly, enum types could not be forward-declared because the size of the enumeration depends on the definition of its members. As long as the size of the enumeration is specified either implicitly or explicitly, it can be forward-declared:\n\nC++03's parser defines “ ” as the right shift operator or stream extraction operator in all cases. However, with nested template declarations, there is a tendency for the programmer to neglect to place a space between the two right angle brackets, thus causing a compiler syntax error.\n\nC++11 improves the specification of the parser so that multiple right angle brackets will be interpreted as closing the template argument list where it is reasonable. This can be overridden by using parentheses around parameter expressions using the “ ”, “ ” or “ ” binary operators:\n\nC++98 added the keyword as a modifier on constructors to prevent single-argument constructors from being used as implicit type conversion operators. However, this does nothing for actual conversion operators. For example, a smart pointer class may have an to allow it to act more like a primitive pointer: if it includes this conversion, it can be tested with (which would be true if the pointer was non-null and false otherwise). However, this allows other, unintended conversions as well. Because C++ is defined as an arithmetic type, it can be implicitly converted to integral or even floating-point types, which allows for mathematical operations that are not intended by the user.\n\nIn C++11, the keyword can now be applied to conversion operators. As with constructors, it prevents using those conversion functions in implicit conversions. However, language contexts that specifically need a Boolean value (the conditions of if-statements and loops, and operands to the logical operators) count as explicit conversions and can thus use a bool conversion operator.\n\nFor example, this feature solves cleanly the safe bool issue.\n\nIn C++03, it is possible to define a typedef only as a synonym for another type, including a synonym for a template specialization with all actual template arguments specified. It is not possible to create a typedef template. For example:\n\nThis will not compile.\n\nC++11 adds this ability with this syntax:\n\nThe syntax can also be used as type aliasing in C++11:\n\nIn C++03, there are restrictions on what types of objects can be members of a . For example, unions cannot contain any objects that define a non-trivial constructor or destructor. C++11 lifts some of these restrictions.[2]\n\nIf a member has a non trivial special member function, the compiler will not generate the equivalent member function for the and it must be manually defined.\n\nThis is a simple example of a union permitted in C++11:\n\nThe changes will not break any existing code since they only relax current rules.\n\nThese features allow the language to do things that were formerly impossible, exceedingly verbose, or needed non-portable libraries.\n\nIn C++11, templates can take variable numbers of template parameters. This also allows the definition of type-safe variadic functions.\n\nC++03 offers two kinds of string literals. The first kind, contained within double quotes, produces a null-terminated array of type . The second kind, defined as , produces a null-terminated array of type , where is a wide-character of undefined size and semantics. Neither literal type offers support for string literals with UTF-8, UTF-16, or any other kind of Unicode encodings.\n\nC++11 supports three Unicode encodings: UTF-8, UTF-16, and UTF-32. The definition of the type has been modified to explicitly express that it is at least the size needed to store an eight-bit coding of UTF-8, and large enough to contain any member of the compiler's basic execution character set. It was formerly defined as only the latter in the C++ standard itself, then relying on the C standard to guarantee at least 8 bits. Furthermore, C++11 adds two new character types: and . These are designed to store UTF-16 and UTF-32 respectively.\n\nCreating string literals for each of the supported encodings can be done thus:\n\nThe type of the first string is the usual . The type of the second string is (note lower case 'u' prefix). The type of the third string is (upper case 'U' prefix).\n\nWhen building Unicode string literals, it is often useful to insert Unicode code points directly into the string. To do this, C++11 allows this syntax:\n\nThe number after the is a hexadecimal number; it does not need the usual prefix. The identifier represents a 16-bit Unicode code point; to enter a 32-bit code point, use and a 32-bit hexadecimal number. Only valid Unicode code points can be entered. For example, code points on the range U+D800–U+DFFF are forbidden, as they are reserved for surrogate pairs in UTF-16 encodings.\n\nIt is also sometimes useful to avoid escaping strings manually, particularly for using literals of XML files, scripting languages, or regular expressions. C++11 provides a raw string literal:\n\nIn the first case, everything between the and the is part of the string. The and characters do not need to be escaped. In the second case, the starts the string, and it ends only when is reached. The string can be any string up to 16 characters in length, including the empty string. This string cannot contain spaces, control characters, , , or the character. Using this delimiter string, the user can have the sequence within raw string literals. For example, is equivalent to .\n\nRaw string literals can be combined with the wide literal or any of the Unicode literal prefixes:\n\nC++03 provides a number of literals. The characters are a literal that is resolved by the compiler as a type with the value of 12.5. However, the addition of the suffix , as in , creates a value of type that contains the value 12.5. The suffix modifiers for literals are fixed by the C++ specification, and C++03 code cannot create new literal modifiers.\n\nBy contrast, C++11 enables the user to define new kinds of literal modifiers that will construct objects based on the string of characters that the literal modifies.\n\nTransformation of literals is redefined into two distinct phases: raw and cooked. A raw literal is a sequence of characters of some specific type, while the cooked literal is of a separate type. The C++ literal , as a raw literal, is this sequence of characters , , , . As a cooked literal, it is the integer 1234. The C++ literal in raw form is , , , while in cooked form it is the integer 10.\n\nLiterals can be extended in both raw and cooked forms, with the exception of string literals, which can be processed only in cooked form. This exception is due to the fact that strings have prefixes that affect the specific meaning and type of the characters in question.\n\nAll user-defined literals are suffixes; defining prefix literals is not possible. All suffixes starting with any character except underscore ( ) are reserved by the standard. Thus, all user-defined literals must have suffixes starting with an underscore ( ).[18]\n\nUser-defined literals processing the raw form of the literal are defined via a literal operator, which is written as . An example follows:\n\nThe assignment statement executes the code defined by the user-defined literal function. This function is passed as a C-style string, so it has a null terminator.\n\nAn alternative mechanism for processing integer and floating point raw literals is via a variadic template:\n\nThis instantiates the literal processing function as . In this form, there is no null character terminating the string. The main purpose for doing this is to use C++11's keyword to ensure that the compiler will transform the literal entirely at compile time, assuming is a constexpr-constructible and copyable type, and the literal processing function is a function.\n\nFor numeric literals, the type of the cooked literal is either for integral literals or for floating point literals. (Note: There is no need for signed integral types because a sign-prefixed literal is parsed as an expression containing the sign as a unary prefix operator and the unsigned number.) There is no alternative template form:\n\nIn accord with the formerly mentioned new string prefixes, for string literals, these are used:\n\nThere is no alternative template form. Character literals are defined similarly.\n\nThere are two parts involved: a memory model which allows multiple threads to co-exist in a program and library support for interaction between threads. (See this article's section on threading facilities.)\n\nThe memory model defines when multiple threads may access the same memory location, and specifies when updates by one thread become visible to other threads.\n\nIn a multi-threaded environment, it is common for every thread to have some unique variables. This already happens for the local variables of a function, but it does not happen for global and static variables.\n\nA new thread-local storage duration (in addition to the existing static, dynamic and automatic) is indicated by the storage specifier .\n\nAny object which could have static storage duration (i.e., lifetime spanning the entire execution of the program) may be given thread-local duration instead. The intent is that like any other static-duration variable, a thread-local object can be initialized using a constructor and destroyed using a destructor.\n\nIn C++03, the compiler provides, for classes that do not provide them for themselves, a default constructor, a copy constructor, a copy assignment operator ( ), and a destructor. The programmer can override these defaults by defining custom versions. C++ also defines several global operators (such as ) that work on all classes, which the programmer can override.\n\nHowever, there is very little control over creating these defaults. Making a class inherently non-copyable, for example, may be done by declaring a private copy constructor and copy assignment operator and not defining them. Attempting to use these functions is a violation of the One Definition Rule (ODR). While a diagnostic message is not required,[19] violations may result in a linker error.\n\nIn the case of the default constructor, the compiler will not generate a default constructor if a class is defined with any constructors. This is useful in many cases, but it is also useful to be able to have both specialized constructors and the compiler-generated default.\n\nC++11 allows the explicit defaulting and deleting of these special member functions.[20] For example, this class explicitly declares that a default constructor can be used:\n\nA function can be explicitly disabled. This is useful for preventing implicit type conversions. The specifier can be used to prohibit calling a function with particular parameter types.[20] For example:\n\nAn attempt to call with an parameter will be rejected by the compiler, instead of performing a silent conversion to . Calling with a still works.\n\nIt is possible to prohibit calling the function with any type other than by using a template:\n\ncalling will work, while will generate a compiler error.\n\nClass member functions and constructors can also be deleted. For example, it is possible to prevent copying class objects by deleting the copy constructor and :\n\nIn C++03, the largest integer type is . It is guaranteed to have at least as many usable bits as . This resulted in having size of 64 bits on some popular implementations and 32 bits on others. C++11 adds a new integer type to address this issue. It is guaranteed to be at least as large as a , and have no fewer than 64 bits. The type was originally introduced by C99 to the standard C, and most C++ compilers supported it as an extension already.[21][22]\n\nC++03 provides two methods to test assertions: the macro and the preprocessor directive . However, neither is appropriate for use in templates: the macro tests the assertion at execution-time, while the preprocessor directive tests the assertion during preprocessing, which happens before instantiation of templates. Neither is appropriate for testing properties that are dependent on template parameters.\n\nThe new utility introduces a new way to test assertions at compile-time, using the new keyword . The declaration assumes this form:\n\nHere are some examples of how can be used:\n\nWhen the constant expression is the compiler produces an error message. The first example is similar to the preprocessor directive , although the preprocessor does only support integral types.[23] In contrast, in the second example the assertion is checked at every instantiation of the template class .\n\nStatic assertions are useful outside of templates also. For instance, a given implementation of an algorithm might depend on the size of a being larger than an , something the standard does not guarantee. Such an assumption is valid on most systems and compilers, but not all.\n\nIn C++03, the operator can be used on types and objects. But it cannot be used to do this:\n\nThis should return the size of . C++03 disallows this, so it is a compile error. C++11 allows it. It is also allowed for the operator introduced in C++11.\n\nC++11 allows variable alignment to be queried and controlled with and .\n\nThe operator takes the type and returns the power of 2 byte boundary on which the type instances must be allocated (as a ). When given a reference type returns the referenced type's alignment; for arrays it returns the element type's alignment.\n\nThe specifier controls the memory alignment for a variable. The specifier takes a constant or a type; when supplied a type is shorthand for . For example, to specify that a char array should be properly aligned to hold a float:\n\nPrior C++ standards provided for programmer-driven garbage collection via , but gave no definition of object reachability for the purpose of automatic garbage collection. C++11 defines conditions under which pointer values are \"safely derived\" from other values. An implementation may specify that it operates under strict pointer safety, in which case pointers that are not derived according to these rules can become invalid.\n\nC++11 provides a standardized syntax for compiler/tool extensions to the language. Such extensions were traditionally specified using directive or vendor-specific keywords (like for GNU and for Microsoft). With the new syntax, added information can be specified in a form of an attribute enclosed in double square brackets. An attribute can be applied to various elements of source code:\n\nIn the example above, attribute applies to the type of variable , and apply to the variable itself, applies to the statement and applies to the return statement. In general (but with some exceptions), an attribute specified for a named entity is placed after the name, and before the entity otherwise, as shown above, several attributes may be listed inside one pair of double square brackets, added arguments may be provided for an attribute, and attributes may be scoped by vendor-specific attribute namespaces.\n\nIt is recommended that attributes have no language semantic meaning and do not change the sense of a program when ignored. Attributes can be useful for providing information that, for example, helps the compiler to issue better diagnostics or optimize the generated code.\n\nC++11 provides two standard attributes itself: to specify that a function does not return, and to help optimizing multi-threaded code by indicating that function arguments or return value carry a dependency.[clarification needed]\n\nA number of new features were introduced in the C++11 standard library. Many of these could have been implemented under the old standard, but some rely (to a greater or lesser extent) on new C++11 core features.\n\nA large part of the new libraries was defined in the document C++ Standards Committee's Library Technical Report (called TR1), which was published in 2005. Various full and partial implementations of TR1 are currently available using the namespace . For C++11 they were moved to namespace . However, as TR1 features were brought into the C++11 standard library, they were upgraded where appropriate with C++11 language features that were not available in the initial TR1 version. Also, they may have been enhanced with features that were possible under C++03, but were not part of the original TR1 specification.\n\nC++11 offers a number of new language features that the currently existing standard library components can benefit from. For example, most standard library containers can benefit from Rvalue reference based move constructor support, both for quickly moving heavy containers around and for moving the contents of those containers to new memory locations. The standard library components were upgraded with new C++11 language features where appropriate. These include, but are not necessarily limited to:\n• Rvalue references and the associated move support\n• Support for the UTF-16 encoding unit, and UTF-32 encoding unit Unicode character types\n• Variadic templates (coupled with Rvalue references to allow for perfect forwarding)\n\nFurther, much time has passed since the prior C++ standard. Much code using the standard library has been written. This has revealed parts of the standard libraries that could use some improving. Among the many areas of improvement considered were standard library allocators. A new scope-based model of allocators was included in C++11 to supplement the prior model.\n\nWhile the C++03 language provides a memory model that supports threading, the primary support for actually using threading comes with the C++11 standard library.\n\nA thread class ( ) is provided, which takes a function object (and an optional series of arguments to pass to it) to run in the new thread. It is possible to cause a thread to halt until another executing thread completes, providing thread joining support via the member function. Access is provided, where feasible, to the underlying native thread object(s) for platform-specific operations by the member function.\n\nFor synchronization between threads, appropriate mutexes ( , , etc.) and condition variables ( and ) are added to the library. These are accessible via Resource Acquisition Is Initialization (RAII) locks ( and ) and locking algorithms for easy use.\n\nFor high-performance, low-level work, communicating between threads is sometimes needed without the overhead of mutexes. This is done using atomic operations on memory locations. These can optionally specify the minimum memory visibility constraints needed for an operation. Explicit memory barriers may also be used for this purpose.\n\nThe C++11 thread library also includes futures and promises for passing asynchronous results between threads, and for wrapping up a function call that can generate such an asynchronous result. The futures proposal was criticized because it lacks a way to combine futures and check for the completion of one promise inside a set of promises.[24]\n\nFurther high-level threading facilities such as thread pools have been remanded to a future C++ technical report. They are not part of C++11, but their eventual implementation is expected to be built entirely on top of the thread library features.\n\nThe new facility provides a convenient method of running tasks and tying them to a . The user can choose whether the task is to be run asynchronously on a separate thread or synchronously on a thread that waits for the value. By default, the implementation can choose, which provides an easy way to take advantage of hardware concurrency without oversubscription, and provides some of the advantages of a thread pool for simple usages.\n\nTuples are collections composed of heterogeneous objects of pre-arranged dimensions. A tuple can be considered a generalization of a struct's member variables.\n\nThe C++11 version of the TR1 tuple type benefited from C++11 features like variadic templates. To implement reasonably, the TR1 version required an implementation-defined maximum number of contained types, and substantial macro trickery. By contrast, the implementation of the C++11 version requires no explicit implementation-defined maximum number of types. Though compilers will have an internal maximum recursion depth for template instantiation (which is normal), the C++11 version of tuples will not expose this value to the user.\n\nUsing variadic templates, the declaration of the tuple class looks as follows:\n\nAn example of definition and use of the tuple type:\n\nIt's possible to create the tuple without defining its contents, but only if the tuple elements' types possess default constructors. Moreover, it's possible to assign a tuple to another tuple: if the two tuples’ types are the same, each element type must possess a copy constructor; otherwise, each element type of the right-side tuple must be convertible to that of the corresponding element type of the left-side tuple or that the corresponding element type of the left-side tuple has a suitable constructor.\n\nJust like for , there exists to automatically create s using type deduction and helps to declare such a tuple. creates tuples of lvalue references to help unpack tuples. also helps here. See the example:\n\nRelational operators are available (among tuples with the same number of elements), and two expressions are available to check a tuple's characteristics (only during compilation):\n• returns the number of elements in the tuple ,\n• returns the type of the object number of the tuple .\n\nIncluding hash tables (unordered associative containers) in the C++ standard library is one of the most recurring requests. It was not adopted in C++03 due to time constraints only. Although hash tables are less efficient than a balanced tree in the worst case (in the presence of many collisions), they perform better in many real applications.\n\nCollisions are managed only via linear chaining because the committee didn't consider it to be opportune to standardize solutions of open addressing that introduce quite a lot of intrinsic problems (above all when erasure of elements is admitted). To avoid name clashes with non-standard libraries that developed their own hash table implementations, the prefix “unordered” was used instead of “hash”.\n\nThe new library has four types of hash tables, differentiated by whether or not they accept elements with the same key (unique keys or equivalent keys), and whether they map each key to an associated value. They correspond to the four existing binary search tree based associative containers, with an unordered_ prefix.\n\nThe new classes fulfill all the requirements of a container class, and have all the methods needed to access elements: , , , .\n\nThis new feature didn't need any C++ language core extensions (though implementations will take advantage of various C++11 language features), only a small extension of the header and the introduction of headers and . No other changes to any existing standard classes were needed, and it doesn't depend on any other extensions of the standard library.\n\nIn addition to the hash tables two more containers was added to the standard library. The std::array is a fixed size container that is more efficient than std::vector but safer and easier to use than a c-style array. The std::forward_list is a single linked list that provides more space efficient storage than the double linked std::list when bidirectional iteration is not needed.\n\nThe new library, defined in the new header , is made of a couple of new classes:\n• regular expressions are represented by instance of the template class ;\n• occurrences are represented by instance of the template class ,\n• std::regex_iterator is used to iterate over all matches of a regex\n\nThe function is used for searching, while for ‘search and replace’ the function is used which returns a new string.[25]\n\nHere is an example of the use of :\n\nThe library requires neither alteration of any existing header (though it will use them where appropriate) nor an extension of the core language. In POSIX C, regular expressions are also available via the C POSIX library#regex.h.\n\nC++11 provides , and improvements to and from TR1. is deprecated.\n\nThe C standard library provides the ability to generate pseudorandom numbers via the function . However, the algorithm is delegated entirely to the library vendor. C++ inherited this functionality with no changes, but C++11 provides a new method for generating pseudorandom numbers.\n\nC++11's random number functionality is split into two parts: a generator engine that contains the random number generator's state and produces the pseudorandom numbers; and a distribution, which determines the range and mathematical distribution of the outcome. These two are combined to form a random number generator object.\n\nUnlike the C standard , the C++11 mechanism will come with three base generator engine algorithms:\n\nC++11 also provides a number of standard distributions:\n\nThe generator and distributions are combined as in this example:\n\nA wrapper reference is obtained from an instance of the class template . Wrapper references are similar to normal references (‘ ’) of the C++ language. To obtain a wrapper reference from any object the function template is used (for a constant reference is used).\n\nWrapper references are useful above all for function templates, where references to parameters rather than copies are needed:\n\nThis new utility was added to the existing header and didn't need further extensions of the C++ language.\n\nPolymorphic wrappers for function objects are similar to function pointers in semantics and syntax, but are less tightly bound and can indiscriminately refer to anything which can be called (function pointers, member function pointers, or functors) whose arguments are compatible with those of the wrapper.\n\nAn example can clarify its characteristics:\n\nThe template class was defined inside the header , without needing any change to the C++ language.\n\nMetaprogramming consists of creating a program that creates or modifies another program (or itself). This can happen during compilation or during execution. The C++ Standards Committee has decided to introduce a library for metaprogramming during compiling via templates.\n\nHere is an example of a meta-program using the C++03 standard: a recursion of template instances for calculating integer exponents:\n\nMany algorithms can operate on different types of data; C++'s templates support generic programming and make code more compact and useful. Nevertheless, it is common for algorithms to need information on the data types being used. This information can be extracted during instantiation of a template class using type traits.\n\nType traits can identify the category of an object and all the characteristics of a class (or of a struct). They are defined in the new header .\n\nIn the next example there is the template function ‘elaborate’ which, depending on the given data types, will instantiate one of the two proposed algorithms ( ).\n\nVia type traits, defined in header , it's also possible to create type transformation operations ( and are insufficient inside a template).\n\nThis type of programming produces elegant and concise code; however, the weak point of these techniques is the debugging: it's uncomfortable during compilation and very difficult during program execution.\n\nDetermining the return type of a template function object at compile-time is not intuitive, particularly if the return value depends on the parameters of the function. As an example:\n\nInstantiating the class template , the function object of will have always the same return type as the function object of . However, given class below:\n\nAttempting to instantiate will cause the return type of to not be the same as that of class . The compiler may generate warnings about the conversion from to and vice versa.\n\nTR1 introduces, and C++11 adopts, the template class that allows one to determine and use the return type of a function object for every declaration. The object uses the object to derive the return type of the function object:\n\nIn this way in instances of function object of there are no conversions, warnings, or errors.\n\nThe only change from the TR1 version of is that the TR1 version allowed an implementation to fail to be able to determine the result type of a function call. Due to changes to C++ for supporting , the C++11 version of no longer needs these special cases; implementations are required to compute a type in all cases.\n\nFor compatibility with C, from C99, these were added:[26]\n• – integer type that is at least 64 bits long.\n• – macro evaluating to the name of the function it is in.\n\nThe term sequence point was removed, being replaced by specifying that either one operation is sequenced before another, or that two operations are unsequenced.[28]\n\nThe former use of the keyword was removed.[29] The keyword itself remains, being reserved for potential future use.\n\nDynamic exception specifications are deprecated.[29] Compile-time specification of non-exception-throwing functions is available with the keyword, which is useful for optimization.\n\nis deprecated, having been superseded by .\n\nFunction object base classes ( , ), adapters to pointers to functions and adapters to pointers to members, and binder classes are all deprecated.\n• C++0X: The New Face of Standard C++\n• A talk on C++0x given by Bjarne Stroustrup at the University of Waterloo Archived 2009-01-23 at the Wayback Machine\n• The State of the Language: An Interview with Bjarne Stroustrup (15 August 2008) Archived 31 January 2009 at the Wayback Machine\n• Wiki page to help keep track of C++ 0x core language features and their availability in compilers\n• More information on C++11 features:range-based for loop, why auto_ptr is deprecated, etc. [usurped]"
    },
    {
        "link": "https://isocpp.org/wiki/faq/cpp11",
        "document": "The purpose of this FAQ’s C++11 sections (including this section) is:\n• To give an overview of the new facilities (language features and standard libraries) offered by C++11 in addition to what is provided by the previous version of the ISO C++ standard.\n• To give an idea of the aims of the ISO C++ standards effort.\n• To present a user’s view of the new facilities\n• To provide references to allow for a more in depth study of features.\n• To name many of the individuals who contributed (mostly as authors of the reports they wrote for the committee). The standard is not written by a faceless organization.\n\nWe often borrow examples from the proposals. In those cases: Thanks to the proposal authors. Many other examples are borrowed from Stroustrup’s talks and papers.\n\nPlease note that the purpose of this FAQ is not to provide comprehensive discussion of individual features or a detailed explanation of how to use them. The aim is to give simple examples to demonstrate what C++11 has to offer (plus references). Our ideal is “max one page per feature” independently of how complex a feature is. Details can often be found in the references.\n\nSee the FAQ Home page for a list of all C++11 sections.\n\nC++11 is the ISO C++ standard formally ratified by a 21-0 national vote in August 2011. This public working paper is the January 2012 working draft, and contains the C++11 standard plus minor editorial changes.\n\nC++11 is a major upgrade over C++98/03, with performance and convenience features that make it feel like a new language.\n\nThe previous (and first) standard is often referred to as C++98 or C++03; the differences between C++98 and C++03 are so few and so technical that they ought not concern users. This FAQ discusses changes between C++98/C++03 to C++11.\n\nThe “under-development” name for C++11. Before its official ratification in 2011, the then-under-development standard was unofficially called C++0x, as it was hoped to be completed in C++08 or C++09. Think of ‘ ’ as hexadecimal (i.e., C++ == C++11).\n\nCurrently shipping compilers (e.g. GCC C++, Clang C++, IBM C++, and Microsoft C++) already implement most or all C++11 features, and are working on C++14 features.\n\nModulo bugs, the first fully conforming C++11 language implementation was GCC 4.8.1 (May 31, 2013) but it still did not have a conforming standard library. The first complete C++11 implementation, including both the language and the standard library, was Clang 3.3 (June 5, 2013).\n\nHere are links to C++11 information from purveyors:\n\nHow did the committee approach picking new language and library features for C++11?\n\nYou don’t improve a language by simply adding every feature that someone considers a good idea. In fact, essentially every feature of most modern languages has been suggested for C++ by someone: Try to imagine what the union of C99, C#, Java, Haskell, Lisp, Python, and Ada would look like. To make the problem more difficult, remember that it is not feasible to eliminate older features, even in the reasonably rare cases when the committee agrees that they are bad: Experience shows that users force every implementer to keep providing deprecated and banned features under compatibility switches (or by default) for decades.\n\nIn addition to the general design goals, to try to select rationally from the flood of suggestions the committee devised a set of specific design goals. The result has been a language with greatly improved abstraction mechanisms. The range of abstractions that C++ can express elegantly, flexibly, and at zero cost compared to hand-crafted specialized code has greatly increased. When we say “abstraction” people often just think “classes” or “objects.” C++11 goes far beyond that: The range of user-defined types that can be cleanly and safely expressed has grown with the addition of features such as initializer-lists, uniform initialization, template aliases, rvalue references, defaulted and deleted functions, and variadic templates. Their implementation eased with features, such as auto, inherited constructors, and decltype. These enhancements are sufficient to make C++11 feel like a new language.\n\nFor information about accepted language features, see the C++11 language extensions sections of this FAQ, listed on the FAQ Home page.\n\nThe standard library definition is already about 70% of the normative text of the standard (and that doesn’t count the C standard library, which is included by reference). Even though some members would have liked to see many more standard libraries, nobody could claim that the Library Working Group has been lazy. It is also worth noting that the C++98 libraries have been significantly improved through the use of new language features, such as initializer-lists, rvalue references, variadic templates, , and . The C++11 standard library is easier to use and provides better performance than the C++98 one.\n\nFor information about accepted library features, see the C++11 library extensions sections of this FAQ, listed on the FAQ Home page.\n\nWhat were the general design goals of the C++11 effort?\n\nC++ has from its inception been a general-purpose programming language with a bias towards systems programming that\n• is a better C\n\nThe overall aims of the C++11 effort was to strengthen that:\n• Make C++ a better language for systems programming and library building – that is, to build directly on C++’s contributions to programming, rather than providing specialized facilities for a particular sub-community (e.g. numeric computation or Windows-style application development).\n• Make C++ easier to teach and learn – through increased uniformity, stronger guarantees, and facilities supportive of novices (there will always be more novices than experts).\n• Naturally, this is done under very stringent compatibility constraints. Only very rarely is the committee willing to break standards conforming code, though that’s done when a new keyword (e.g. , , and ) is introduced.\n\nFor more details see:\n• B. Stroustrup: What is C++11?. CVu. Vol 21, Issues 4 and 5. 2009.\n• B. Stroustrup: Evolving a language in and for the real world: C++ 1991-2006. ACM HOPL-III. June 2007.\n• B. Stroustrup: A History of C++: 1979-1991. Proc ACM History of Programming Languages conference (HOPL-2). March 1993.\n• B. Stroustrup: C and C++: Siblings. The C/C++ Users Journal. July 2002.\n\nNaturally, different people and different organizations involved with the standardization have somewhat different aims, especially when it comes to details and to priorities. Also, detailed aims change over time. Please remember that the committee can’t even do all that everyone agrees would be good things – it consists of volunteers with very limited resources. However, here are a set of criteria that has seen real use in the discussion of which features and libraries were appropriate for C++11:\n• Maintain stability and compatibility – don’t break old code, and if you absolutely must, don’t break it quietly.\n• Prefer libraries to language extensions – an ideal at which the committee wasn’t all that successful; too many people in the committee and elsewhere prefer “real language features.”\n• Prefer generality to specialization – focus on improving the abstraction mechanisms (classes, templates, etc.).\n• Support both experts and novices – novices can be helped by better libraries and through more general rules; experts need general and efficient features.\n• Increase type safety – primarily though facilities that allow programmers to avoid type-unsafe features.\n• Improve performance and ability to work directly with hardware – make C++ even better for embedded systems programming and high-performance computation.\n• Fit into the real world – consider tool chains, implementation cost, transition problems, ABI issues, teaching and learning, etc.\n\nNote that integrating features (new and old) to work in combination is the key – and most of the work. The whole is much more than the simple sum of its parts.\n\nAnother way of looking at detailed aims is to look at areas of use and styles of usage:\n• Machine model and concurrency – provide stronger guarantees for and better facilities for using modern hardware (e.g. multicores and weakly coherent memory models). Examples are threads, futures, thread-local storage, and atomics.\n• Generic programming – GP is among the great success stories of C++98; we needed to improve support for it based on experience. Examples are auto and template aliases.\n• Systems programming – improve the support for close-to-the-hardware programming (e.g. low-level embedded systems programming) and efficiency. Examples are , , and generalized PODs.\n• Library building – remove limitations, inefficiencies, and irregularities from the abstraction mechanisms. Examples are , inherited constructors, and rvalue references.\n\nWhere can I find the committee papers for C++11 features?\n\nGo to the committee papers archive and focus mainly on 2005 through early 2011. There you will most likely drown in details. Look for “issues lists” and “State of” (e.g. State of Evolution (July 2008)) lists. The key groups then active were\n• Evolution (EWG) – dealing with language feature proposals and issues crossing the language/library boundary\n\nWhere can I find academic and technical papers about C++11?\n\nHere is an incomplete list. To suggest additions or corrections, use the Suggestion icon on this FAQ heading (you can do that on any FAQ of course).\n• Bjarne Stroustrup: Software Development for Infrastructure. Computer, vol. 45, no. 1, pp. 47-58, Jan. 2012, doi:10.1109/MC.2011.353. Here is a video interview about that paper and video of a talk on a very similar topic (That’s a 90 minute talk incl. Q&A).\n• Saeed Amrollahi: Modern Programming in the New Millenium: A Technical Survey on Outstanding features of C++0x. Computer Report (Gozaresh-e Computer), No.199, November 2011 (Mehr and Aban 1390), pages 60-82. (in Persian)\n• Mark Batty et al’s: Mathematizing C++ concurrency, POPL 2012. // thorough, precise, and mathematical.\n• Gabriel Dos Reis and Bjarne Stroustrup: General Constant Expressions for System Programming Languages. SAC-2010. The 25th ACM Symposium On Applied Computing.\n• Hans-J. Boehm and Sarita V. Adve: Foundations of the C++ concurrency memory model. ACM PLDI’08.\n• Hans-J. Boehm: Threads Basic. HPL technical report 2009-259 // “what every programmer should know about memory model issues”\n• Douglas Gregor, Jaakko Jarvi, Jeremy Siek, Bjarne Stroustrup, Gabriel Dos Reis, and Andrew Lumsdaine: Concepts: Linguistic Support for Generic Programming in C++. OOPSLA’06, October 2006. // The concept design and implementation as it stood in 2006; it has improved since, though not sufficiently to save it for C++11, and is now being worked on for a future C++ standard.\n• Douglas Gregor and Jaakko Jarvi: Variadic templates for C++0x. Journal of Object Technology, 7(2):31-51, February 2008.\n• M. Paterno and W. E. Brown: Improving Standard C++ for the Physics Community. CHEP’04. // Much has been improved since then!\n• Michael Spertus and Hans J. Boehm: The Status of Garbage Collection in C++0X. ACM ISMM’09.\n• Verity Stob: An unthinking programmer’s guide to the new C++ – Raising the standard. The Register. May 2009. (Humor (I hope)).\n• [N1781=05-0041] Bjarne Stroustrup: Rules of thumb for the design of C++0x.\n• Bjarne Stroustrup: Evolving a language in and for the real world: C++ 1991-2006. ACM HOPL-III. June 2007. (incl. slides and videos). // Covers the design aims of C++0x, the standards process, and the progress up until 2007.\n• B. Stroustrup: What is C++0x?. CVu. Vol 21, Issues 4 and 5. 2009.\n\nWhere else can I read about C++11?\n\nThe amount of information about C++11 is increasing as most C++ implementations provide the new language features and libraries. Here is a short list of sources:\n• The C++11 Wikipedia entry. This seems to be actively maintained, though apparently not by members of the committee.\n\nAre there any videos about C++11?\n• B. Stroustrup, H. Sutter, H-J. Boehm, A. Alexandrescu, S.T.Lavavej, Chandler Carruth, and Andrew Sutton: Several talks and panels from the GoingNative 2012 conference.\n• B. Stroustrup, H. Sutter, S. Meyers, A. Alexandrescu, S.T.Lavavej, Chandler Carruth, S. Parent, and M. Wong: Several talks and panels from the GoingNative 2013 conference.\n• Herb Sutter: Writing Modern C++ Code: How C++ has evolved over the years. September 2011.\n• Herb Sutter: Why C++?. C++ and Beyond 2011, August 2011.\n• Herb Sutter: (Not Your Father’s) C++. Lang.NEXT, April 2012.\n• Herb Sutter: atomic<> Weapons: The C++ Memory Model and Modern Hardware, Part 1, Part 2, Slides, from C++ and Beyond, August 2012.\n• Lawrence Crowl: Lawrence Crowl on C++ Threads. in Sophia Antipolis, June 2008.\n• Bjarne Stroustrup: The design of C++0x. University of Waterloo, 2007.\n• Hans-J. Boehm: Getting C++ Threads Right. December 2007.\n\nC++11 makes C++ easier to learn than ever, and has near-perfect compatibility with C++98/03.\n\nFor those who have never used C++, C++11 is far easier to learn than the previous version of the language. Even though there are more features, the code you write tends to be simpler and many things that used to be hard or obscure aren’t any more. (Of course, like any general-purpose language, there are still some hard or obscure parts.) In fact, Stroustrup now covers the essentials of the entire C++11 language and library in one concise 180-page book, A Tour of C++.\n\nIf you know C++98/03, essentially all your code will continue to work unchanged because C++11 is nearly perfectly backward-compatible with the previous standard. However, as you learn the new features, you will find that they often make your code simpler (e.g., ), clearer (e.g., template aliases instead of ), more powerful and expressive (e.g., lambda functions), and faster than ever (e.g., rvalue references and move semantics will often make your existing C++ code faster simply by recompiling it with a C++11 compiler!). The extra simplicity and clarity really make C++11 feel like a fresh new language.\n\nClearly C++11 is bigger than C++98 and has more features. So how can it be easier to learn? When designing C++11, the committee used several tools for simplification (from the point of view of learners), including:\n• Generalization: In some cases C++11 replaces, say, three rules with one more general rule (e.g., uniform initialization, inheriting constructors, and threads). It also removes special cases so there’s less to learn (as a trivial example, is perfectly legal now without putting a space between ). All of this reduces “concept count” or the number of things to memorize by rote; for example, a rule with three exceptions or special cases has a concept count of four things to memorize, whereas two general rules that just work together in all combinations have a concept count of just two things to memorize, yet can often express much more than the single rule with three special cases.\n• Simpler alternatives: In other cases C++11 provides new facilities that are easier to use than their older alternatives (e.g., , auto, range-for statement, and regex).\n\nA word of caution: People who insist on teaching C++ “from the bottom up” (corner cases first, C subset first, etc.) will nullify any such advantage and make the language appear obscure and hard. This is not necessary or desirable. We are finally getting better materials that teach C++ from the top down, notably Stroustrup’s A Tour of C++. If you see people learning C++ from the bottom up, steer them to the Tour and similar materials as quickly as possible.\n\nIs C++11 the final C++ standard?\n\nNo. The upcoming next C++ International Standard is called C++14 as it is expected to be published in 2014, and as of this writing it is nearly finalized. The committee is also working on issuing numerous Technical Specifications due in 2014 onward, on topics from low-level libraries like File System and Networking to Concurrency and Parallelism and Concepts, and more. Many of these Technical Specifications are expected to become part of the next major actual C++ International Standard, currently expected in about 2017.\n\nFor the latest details, see the current status page."
    },
    {
        "link": "https://geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc",
        "document": "In C, a variable defined in a function is stored in the stack memory. The requirement of this memory is that it needs to know the size of the data to memory at compile time (before the program runs). Also, once defined, we can neither change the size nor completely delete the memory.\n\nTo resolve this, C provides a feature called Dynamic Memory Allocation. It allows you to allocate memory at runtime, giving your program the ability to handle data of varying sizes. Dynamic resources are stored in the heap memory instead of the stack.\n\nThis feature is useful in a variety of situations. For example, changing the size of an array according to our requirement.\n\nAs we know, the size of an array in C is fixed and should be known at compile time. There can be two problems:\n\nThe size of the array is not sufficient to store all the elements. To resolve this, one might set the size to store the maximum theoretically possible elements. This creates another problem.\n\nThis size of the array is much more than what is required to store the elements. This leads to the wastage of memory.\n\nThis is where the dynamic memory allocation comes in. The size of the array can be increased if more elements are to be inserted and decreased of less elements are inserted. Moreover, there is no need to estimate the max possible size. The size can be decided at runtime according to the requirement.\n\nDynamic memory allocation is possible in C by using 4 library functions provided by <stdlib.h> library:\n\nLet’s discuss each of them one by one.\n\nThe malloc() (stands for memory allocation) function is used to allocate a single block of contiguous memory on the heap at runtime. The memory allocated by malloc() is uninitialized, meaning it contains garbage values.\n\nwhere size is the number of bytes to allocate.\n\nThis function returns a void pointer to the allocated memory that needs to be converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nAssume that we want to create an array to store 5 integers. Since the size of int is 4 bytes, we need 5 * 4 bytes = 20 bytes of memory. This can be done as shown:\n\nIn the above malloc call, we hardcoded the number of bytes we need to store 5 integers. But we know that the size of the integer in C depends on the architecture. So, it is better to use the sizeof operator to find the size of type you want to store.\n\nMoreover, if there is no memory available, the malloc will fail and return NULL. So, it is recommended to check for failure by comparing the ptr to NULL.\n\nThe calloc() (stands for contiguous allocation) function is similar to malloc(), but it initializes the allocated memory to zero. It is used when you need memory with default zero values.\n\nwhere n is the number of elements and size is the size of each element in bytes.\n\nThis function also returns a void pointer to the allocated memory that is converted to the pointer of required type to be usable. If allocation fails, it returns NULL pointer.\n\nWe can take the example of malloc() and try to do it with calloc() function.\n\nThe memory allocated using functions malloc() and calloc() is not de-allocated on their own. The free() function is used to release dynamically allocated memory back to the operating system. It is essential to free memory that is no longer needed to avoid memory leaks.\n\nwhere ptr is the pointer to the allocated memory.\n\nAfter freeing a memory block, the pointer becomes invalid, and it is no longer pointing to a valid memory location.\n\nAfter calling free(), it is a good practice to set the pointer to NULL to avoid using a “dangling pointer,” which points to a memory location that has been deallocated.\n\nrealloc() function is used to resize a previously allocated memory block. It allows you to change the size of an existing memory allocation without needing to free the old memory and allocate a new block.\n\nwhere, ptr is the pointer to the previously allocated memory block and new_size is the reallocated size that the memory block should have in bytes.\n\nThis function returns a pointer to the newly allocated memory, or NULL if the reallocation fails. If it fails, the original memory block remains unchanged.\n\nSuppose we initially allocate memory for 5 integers but later need to expand the array to hold 10 integers. We can use realloc() to resize the memory block:\n\nIt is important to note that if realloc() fails and returns NULL, the original memory block is not freed, so you should not overwrite the original pointer until you’ve successfully allocated a new block. To prevent memory leaks, it’s a good practice to handle the NULL return value carefully:\n\nConsider the first scenario where we were having issues with the fixes size array. Let’s see how we can resolve both of these issues using dynamic memory allocation.\n\nIn this program, we are managing the memory allocated to the pointer ptr according to our needs by changing the size using realloc(). It can be a fun exercise to implement an array which grows according to the elements inserted in it. This kind of arrays are called dynamically growing arrays.\n\nAs useful as dynamic memory allocation is, it is also prone to errors that requires careful handling to avoid the high memory usage or even system crashes. Few of the common errors are given below:\n• Dangling Pointers : Using a pointer after freeing its memory can cause undefined behavior or crashes.\n• Fragmentation : Repeated allocations and deallocations can fragment memory, causing inefficient use of heap space.\n• Allocation Failures : If memory allocation fails, the program may crash unless the error is handled properly.\n\nThe functions malloc() and calloc() works very similar to one another. So, why there was the need for two such similar functions.\n\nIt turns out that even though they are similar, they have different use cases due to the minor difference between them regarding the memory initialization. malloc() does not initialize memory while calloc() initializes the memory with zero.\n\nCan we only create arrays dynamically?\n\nWhat happens if memory allocation fails?\n\nWhat happens when you don’t free memory after allocating?\n\nWhat is the limit of memory that we can allocate using these functions?\n\nCan we set the new size of allocated memory to 0 with realloc()?"
    },
    {
        "link": "https://en.cppreference.com/w/c/memory/malloc",
        "document": "If allocation succeeds, returns a pointer that is suitably aligned for any object type with fundamental alignment.\n\nIf is zero, the behavior of is implementation-defined. For example, a null pointer may be returned. Alternatively, a non-null pointer may be returned; but such a pointer should not be dereferenced, and should be passed to free to avoid memory leaks.\n\nis thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage. A previous call to free, free_sized, and free_aligned_sized(since C23) or realloc that deallocates a region of memory synchronizes-with a call to that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by . There is a single total order of all allocation and deallocation functions operating on each particular region of memory.\n\nOn success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with free() or realloc()."
    },
    {
        "link": "https://man7.org/linux/man-pages/man3/free.3.html",
        "document": "Pages that refer to this page: memusage(1), brk(2), clone(2), getrlimit(2), io_uring_register(2), mlock(2), mmap(2), mremap(2), alloca(3), argz_add(3), asprintf(3), ausearch_add_expression(3), avc_init(3), backtrace(3), basename(3), canonicalize_file_name(3), cfree(3), CPU_SET(3), dbopen(3), end(3), exec(3), fopen(3), fseek(3), fts(3), ftw(3), getcwd(3), getgrent(3), getgrnam(3), getifaddrs(3), getline(3), getpwent(3), getpwnam(3), glob(3), hsearch(3), if_nameindex(3), lber-memory(3), ldap_memory(3), mallinfo(3), malloc_get_state(3), malloc_hook(3), malloc_info(3), malloc_stats(3), malloc_trim(3), malloc_usable_size(3), mallopt(3), mcheck(3), mpool(3), mtrace(3), numa(3), open_memstream(3), pam_conv(3), pmaddderived(3), __pmaf(3), pmagetlog(3), pmapi(3), pmarewritedata(3), pmarewritemeta(3), pmdachildren(3), pmdafetch(3), pmdainstance(3), pmdalabel(3), pmdatext(3), pmdatrace(3), pmdiscoverservices(3), pmextractvalue(3), pmfault(3), pmfetch(3), pmfetcharchive(3), pmfetchgroup(3), pmfreelabelsets(3), pmfreeprofile(3), pmfreeresult(3), pmfstring(3), pmgetchildren(3), pmgetchildrenstatus(3), pmgetindom(3), pmgetindomarchive(3), pmhash(3), pmlookupindomtext(3), pmlookuptext(3), pmnameall(3), pmnameid(3), pmnameindom(3), pmnameindomarchive(3), pmnewcontextzone(3), pmnewzone(3), pmnomem(3), __pmparsectime(3), pmparsehostattrsspec(3), pmparsehostspec(3), pmparseinterval(3), pmparsemetricspec(3), __pmparsetime(3), pmparsetimewindow(3), pmparseunitsstr(3), pmregisterderived(3), posix_memalign(3), pthread_setcancelstate(3), random_r(3), readdir(3), readline(3), realpath(3), scandir(3), sd_bus_creds_get_pid(3), sd_bus_error(3), sd_bus_path_encode(3), sd_get_seats(3), sd_journal_get_catalog(3), sd_journal_get_cursor(3), sd-json(3), sd-login(3), sd_machine_get_class(3), sd_path_lookup(3), sd_pid_get_owner_uid(3), sd_seat_get_active(3), sd_session_is_active(3), sd_uid_get_state(3), seccomp_syscall_resolve_name(3), security_class_to_string(3), selabel_get_digests_all_partial_matches(3), selinux_boolean_sub(3), selinux_getpolicytype(3), selinux_raw_context_to_color(3), setbuf(3), sscanf(3), strdup(3), string(3), tempnam(3), tracefs_event_get_file(3), tracefs_instance_set_affinity(3), tracefs_tracers(3), void(3type), wcsdup(3), proc_meminfo(5), environ(7), feature_test_macros(7), signal-safety(7), string_copying(7)"
    },
    {
        "link": "https://en.cppreference.com/w/c/memory",
        "document": ""
    },
    {
        "link": "https://github.com/RAGUL1902/Dynamic-Memory-Allocation-in-C",
        "document": "Dynamic memory allocation is the process of assigning the memory space during runtime of the program. This is implemented in C as the functions malloc, calloc, realloc, and free from stdlib. malloc allocates a single block of memory of specified size and returns the pointer to the allocated block. calloc works similarly to malloc but initializes the allocated memory to zero. realloc is used to change the size of an allocated block of memory. Free deallocates memory associated with a pointer.\n• Each of the functions are implemented in seperate files.\n• The memory is being allocated as different blocks as per the requests.\n• Each block of memory that is being allocated contains two sections.\n• The first part contains the meta information about the block( aka meta_block) and the second part is left to use for storing data.\n• Storing meta information about the block is vital and becomes handy when dealing with freeing the memory allocated.\n• These blocks are maintained in the order they are being allocated.\n• For this purpose, these blocks are made into a doubly linked list.\n• Keeping the list of the blocks of free space and used space as a doubly linked list comes in handy when dealing with fragmentation.\n• The requested size is aligned to the multiple of 4 greater than or equal to the size. Handling the addresses becomes simpler when they are aligned.\n• The system calls and are used to move the break of the heap.\n• contains the structure which stores information about the memory block.\n• Every is a node in the doubly linked list. The head of the doubly linked list in maintained globally in the variable .\n• It stores information such as:\n• Whether the coresponding memory block is free or not.\n• The address of the next and previous node in the doubly linked list.\n• Pointer to the starting of the memory block used to store information.\n• A character array variable which does not store any value but is used to get the address from where data can be stored.\n• The function when invoked finds if there exist a free block of memory with aleast the required amount of space which is free by going through the linked list.\n• The function when invoked splits the memory block into two if it contains enough space that can be used to store data.\n• The function when invoked extends the heap and adds a new memory block to the linked list.\n• When the function is called:\n• Creates a new block by invoking if the is .\n• Else it iterates through the linkedlist to find if any suitable block(block with aleast requested size).\n• If a suitable block is found, it is returned.\n• Else it extends the heap and returns the newly created block.\n• It also check if the block found in the linkedlist has enough extra space to be splited. In this case, is invoked.\n• The function first checks if the pointer passed as argument is a valid pointer or not (i.e., created using malloc()) using .\n• Then using the address of the of that corresponding memory location can be found.\n• The block to be freed is merged with the previous or the next memory block it any of it is free using .\n• If the block to be freed is at the end of the linked list, then it is removed from the linkedlist and the break of the heap is modified using .\n• First is used to allocate the required amount of space.\n• Then by iterating through every byte the value is set to 0.\n• If the pointer to the old address(passed as argument) is , then malloc is used to allocate the required memory.\n• If the memory block of the old address has at least the required size then it is returned as it is.\n• Then the next block is checked if it free and merged using .\n• If the space in the block is more than required after merging, then it is split using .\n• If the next block is not free then new block is allocated using .\n• The data is then copied from the old location to the new location using .\n• The pointer to the new location is returned.\n• Testing code to test all the functions implemented.\n• First two new variables are created and allocated space using .\n• Then the first varaible is freed and is called again to show that space can be reused.\n• Then is used to allocate an int array of size 5. Initially the values will be set to 0 by ;\n• Then the array is resized to size 10 using .\n\nP.S: Please go through the comments in the code for more techincal details on the functions."
    },
    {
        "link": "https://geeksforgeeks.org/linked-list-in-c",
        "document": "A linked list is a linear data structure where each element, known as a node, is connected to the next one using pointers. Unlike array, elements of linked list are stored in random memory locations.\n\nIn this article, we will learn about the linked list, its types, representation of the linked list in C, and discuss what link list offers as compared to the similar data structures.\n\nA linked list is a sequence of nodes where each node contains two parts:\n• Data : The value stored in the node.\n• Pointer : A reference to the next node in the sequence. \n\n(There can be multiple pointers for different kind of linked list.)\n\nUnlike arrays, linked lists do not store elements in contiguous memory locations. Instead, each node points to the next, forming a chain-like structure and to access any element (node), we need to first sequentially traverse all the nodes before it.\n\nIt is a recursive data structure in which any smaller part of it is also a linked list in itself.\n\nRepresentation of Linked List in C\n\nIn C, linked lists are represented as the pointer to the first node in the list. For that reason, the first node is generally called head of the linked list. Each node of the linked list is represented by a structure that contains a data field and a pointer of the same type as itself. Such structure is called self-referential structures.\n\nTypes of Linked List in C\n\nLinked list can be classified on the basis of the type of structure they form as a whole and the direction of access. Based on this classification, there are five types of linked lists:\n\nLet's discuss about each of them.\n\nA linked list or singly linked list is a linear data structure that is made up of a group of nodes in which each node has two parts: the data, and the pointer to the next node. The last node's (also known as tail) pointers point to NULL to indicate the end of the linked list.\n\nRepresentation of Singly Linked List in C\n\nA linked list is represented as a pointer to the first node where each node contains:\n• Data: Here the actual information is stored.\n• Next: Pointer that links to the next node.\n\nA doubly linked list is a bit more complex than singly linked list. In it, each node contains three parts: the data, a pointer to the next node, and one extra pointer which points to the previous node. This allows for traversal in both directions, making it more versatile than a singly linked list.\n\nRepresentation of Doubly Linked List in C\n\nA doubly linked list is represented as a pointer to the first node (head), where each node contains:\n• Data : The actual information stored in the node.\n• Next : A pointer that links to the next node in the sequence.\n• Previous : A pointer that links to the previous node in the sequence.\n\nA circular linked list is a variation of a singly linked list where the last node points back to the first node, forming a circle. This means there is no NULL at the end, and the list can be traversed in a circular manner.\n\nThe structure of the circular linked list node is same as that of singly linked list.\n\nRepresentation of Circular Linked List in C\n\nA circular linked list is represented as a pointer to the first node, where each node contains:\n• Data : The actual information stored in the node.\n• Next : A pointer that links to the next node, with the last node pointing back to the first node.\n\nIt is same as the structure for singly linked list node.\n\n\n\nApplications of Linked Lists in C\n\nThe following are some major applications of linked list:\n• None Dynamic memory allocation efficiently manages and allocates dynamic memory in systems and applications.\n• None Implementing other data structures such as stacks, queues, etc.\n• None Represents and manipulates polynomials, with each node storing terms.\n• None Used in file system management dynamically in operating systems.\n• None Linked lists can grow or shrink in size dynamically, as memory is allocated or deallocated as needed.\n• None Inserting or deleting nodes in a linked list is efficient and does not require shifting elements, unlike arrays.\n• None Memory is utilized more efficiently as linked lists do not require a pre-allocated size, reducing wasted space.\n• None They serve as the foundation for implementing more complex data structures like stacks, queues, and graphs.\n• None They can utilize non-contiguous memory blocks, making them suitable for applications where memory is fragmented.\n• None Linked lists do not allow direct access to elements by index. Accessing a specific node requires traversing from the head, leading to slower access times.\n• None Managing pointers can be tricky, increasing the complexity of coding.\n• None Searching for an element or accessing a node by index takes O(N) time, making linked lists slower for such operations compared to arrays.\n\nHow does a linked list differ from an array?\n\nWhat are the main types of linked lists?\n\nWhy use a linked list instead of an array?\n\nWhat are the limitations of linked lists?\n\nWhat are real-world applications of linked lists?"
    },
    {
        "link": "https://stackoverflow.com/questions/14001652/does-standard-c-library-provides-linked-list-etc-data-structures",
        "document": "There are hash tables, binary trees and binary search stuff in glibc. Those are part of C89, C99 and/or POSIX.1 standards. Some reason linked list is not there.\n\nMore info from man pages: hsearch, tsearch and bsearch\n\nNote: Some of those have bad design. For example: allows only one hash table per process. The GNU compiler, gcc/glibc, provides reentrant versions , , and that allow multiple hash tables. See also Stack Overflow's How to use ."
    },
    {
        "link": "https://quora.com/What-are-some-tips-for-creating-an-efficient-singly-linked-list-implementation-in-C-or-any-programming-language",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "http://cslibrary.stanford.edu/103/LinkedListBasics.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/9555788/what-should-i-use-in-ansi-c-to-create-linked-lists",
        "document": "As others have said, there is no standard library support for linked lists in C. That means you either get to roll your own (like most people have done at one or more times in their C coding career), or you look at other libraries for support.\n\nFor most uses, you will find that an 'intrusive' implementation is appropriate. You modify your existing structure to include a pointer to the next item in the list (and, if you're doing a doubly linked list, the previous item).\n\nYour list now consists of a simple pointer to the head item:\n\nYou have to worry about threading issues if you've got threads access the same list, and so on and so forth.\n\nBecause this code is so simple, this is how it is most frequently handled. Deleting a node from a list is trickier, but you can write a function to do it.\n\nPeople have dressed up this basic scheme with macros of varying degrees of complexity so that the code manipulating different types of lists can use the same macros. The Linux kernel uses a macro-based set of linked lists for managing its linked list data structures.\n\nThe alternative to the 'intrusive' implementation (which is so-called because it requires a change to the structure to include the list pointers) is to have some generic list mechanism:\n\nNow you have the ability to put (pointers to) unmodified structures into the list. You lose some type safety; there is nothing to stop you adding random different structure types to a list that should be homogeneous. You also have to allocate memory for the GenericList structures separately from the pointed at data.\n• One advantage of this is that a single data item can be on multiple separate lists simultaneously. * One disadvantage of this is that a single data item can accidentally be on multiple lists, or multiple times in a single list, simultaneously.\n\nYou also have to make sure you understand the ownership properties for the data, so that the data is released properly (not leaked, not multiply-freed, not accessed after being freed). Managing the memory for the list itself is child's play by comparison.\n\nWith the GenericList mechanism, you will likely have a library of functions that manage the list operations for you. Again, searching should reveal implementations of such lists."
    }
]