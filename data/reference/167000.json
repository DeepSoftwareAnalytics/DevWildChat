[
    {
        "link": "https://sqlshack.com/dynamic-sql-in-sql-server",
        "document": "In this article, we will review how to construct and execute dynamic SQL statements in SQL Server with different examples.\n\nDynamic SQL is the SQL statement that is constructed and executed at runtime based on input parameters passed. Let us go through some examples using the EXEC command and sp_executesql extended stored procedure.\n\nEXEC command executes a stored procedure or string passed to it. Please refer to EXEC SQL overview and examples for more details and examples on the EXEC command.\n\nThe following example demonstrates constructing the SQL statement using the input variable and executing the SQL statement using the EXEC command.\n\nThere is a possibility of SQL injection when you construct the SQL statement by concatenating strings from user input values. I hope to cover the SQL injection and some methods to prevent SQL Injection in my future articles.\n\nWe should take care of null values when concatenating strings from parameters using ‘+’ operator. In the below example, I commented out the statement that sets a value to variable “@pid”.\n\nBy default, the variable “@pid” is NULL as we did not set any value. The final statement constructed after concatenation is blank as ‘+’ operator does not handle null values. Please refer to the below image that shows the final value of “@SQL” variable is blank.\n\nIn this case, use the ISNULL function to construct a proper SQL statement while concatenating strings using ‘+’ operator.\n\nEXEC command does not re-use the compiled plan stored in the plan cache. Execute the following query and check for the cached plans.\n\nPlease refer to the below image that shows two separate plans created when the above query is executed for two different parameters.\n\nsp_executesql is an extended stored procedure that can be used to execute dynamic SQL statements in SQL Server. we need to pass the SQL statement and definition of the parameters used in the SQL statement and finally set the values to the parameters used in the query.\n\nFollowing is the syntax of executing dynamic SQL statements using sp_executesql extended stored procedure.\n\nBelow example demonstrates executing dynamic SQL statement by passing parameters to sp_executesql extended stored procedure.\n\nsp_executesql reuses the compiled plan when the statement is executed for different parameters. Execute the following query and check for the cached plan.\n\nPlease refer to the below image that shows the same plan is being used when the statement is executed with different parameters.\n\nFollowing is the example of using dynamic SQL inside a stored procedure. For demo purpose, I used the Product table from the AdventureWorksLT database. This stored procedure is used to search for products based on different columns like name, color, productid, and the product number. The dynamic SQL statement is constructed based on the input parameters passed to the stored procedure and is executed by the EXEC command.\n\nWhen we execute the stored procedure with input parameter productid only, the SQL statement is constructed as shown in the below image.\n\nPlease refer to the below image that shows a different SQL statement constructed when productid and product number are passed as input parameters to the stored procedure.\n\nLet us re-write the stored procedure to form dynamic SQL and execute it using sp_executesql extended stored procedure. Please refer to the below sample script.\n\nLet us execute below sample thread that will retrieve all the products that are red.\n\nsp_executesql extended stored procedure supports the output parameter to store the value returned by the select query and use the output variable in another statement.\n\nFollowing is the example script which shows the usage of the output variable in sp_executesql.\n\nThe local temp table created by executing dynamic SQL cannot be accessed outside the execution of dynamic SQL. It throws invalid object error as shown in the below image.\n\nA workaround for this is to create the local temp table outside and use it in the dynamic SQL. Following is the example that demonstrates this scenario.\n\nPlease refer to the below image. we can see that the data is inserted in the temp table and can be accessed again.\n\nIn this article, we explored how to construct and execute dynamic SQL in SQL Server using the EXEC command and sp_executesql extended stored procedure with different examples. In case you have any questions, please feel free to ask in the comment section below."
    },
    {
        "link": "https://sqlservercentral.com/articles/dos-and-donts-of-dynamic-sql",
        "document": "Dynamic SQL can be an incredibly powerful tool when used properly, however, it can an incredibly large security flaw or a pain to debug if written poorly. The below is a few of Dos (and Don’ts) that I have that may help you in the future when writing Dynamic Statements.\n\nDon’t use Dynamic SQL if your statement isn’t Dynamic\n\nThis might seem like a silly thing to say, but countless times time I have seen examples of dynamic SQL where the query doesn’t need to be dynamic at all. Take the following procedure, for example:\n\nThere’s actually nothing “dynamic” about this statement. doesn’t need to be injected into the statement, and neither does a variable to hold the statement need to be used. You could easily replace the whole thing with a parametrised statement:\n\nDo quote the names of your objects properly\n\nOne thing that is incredibly important when using dynamic SQL is making sure your object names are properly quoted. That means not injecting the value of your dynamic object straight into your dynamic statement, like in the below:\n\nBoth of these statements are just as bad as the other; simply wrapping the dynamic object’s name in a couple of brackets does not make your code “safe” from injection. Just like with a literal string, brackets can be escaped, and someone malicious will be try to escape the value.\n\nFortunately SQL Server has a handy function to help keep you safer, which is . Simply wrap the function round the variable with the dynamic object’s name and the function will automatically wrap the name in brackets and (just as importantly) escape any characters accordingly.\n\nWhen writing dynamic statements, it’s very likely you’re also going to need to pass the value of a parameter for the query as well. These aren’t values for a dynamic object but are likely something that is going to appear in your clause as part of a Boolean expression. The way to pass there parameters is not like the below example:\n\nDynamic SQL can (and should) be parametrised just like any other SQL statement. This can be achieved by using instead of just executing the dynamic statement using . ‘s second parameter is used to declare any variables that will be passed to the dynamic statement, and then the values for those variables can be passed as further parameters:\n\nThis can even be used to output values as well:\n\nParametrising your Dynamic Statement has the advantage that plans can be reused as well (when the value of the dynamic object is the same). If you inject the parameter's value then the plan won't be reused. The Data Engine would create separate query plans for queries where the clause and ; however a query with would use the same plan, regardless of the value of .\n\nDo take the time to format your Dynamic SQL\n\nOne common reason I hear for why people don’t use dynamic SQL is because it’s difficult to troubleshoot. I personally find this a little untrue. Poorly written and/or formatted dynamic SQL is difficult to troubleshoot, but then the same is true for poorly written SQL in general. Let’s take something that looks like a simple enough query:\n\nThis query look well formatted, and it’s quite easy to read. The problem is that the dynamic SQL is returning an error (perhaps something about an invalid object name). Therefore, before executing the dynamic statement you print out its value, which returns something like this:\n\nNow that “well written” dynamic statement turns out to look like a complete eyesore. So, how do you fix this? My personal preference is to add a carriage returns and line breaks, as well an indents into my dynamic statements, just like I would any “normal” query. I tend to and for carriage return and line break respectively, but you can add the values however you wish. So the above you might write something like this:\n\nWhen you then print out the statement from this query you end up with something far more readable.\n\nIf you’re writing a more “normal” query, then the same logic applies. A query like this “looks” well formatted:\n\nBut, once printed out, turns into a single line of SQL, that can be hard to debug. If, however, you add some formatting into the dynamic statement as well, then it becomes much more readable. Applying the same idea, you could write the above query as:\n\nThis formatting may look a little odd to some, but I've personally found it invaluable when dealing with high complexity dynamic statements. The above statements don't really lose any readability either, although may be a bit confusing to those newer to the language. But would you rather something than looks a little more complex at the generation point, or a huge unreadable mess when you print the dynamic statements value? I know I'd prefer the former.\n\nDo perform whitelist checks to avoid errors on invalid objects and make your statements safer\n\nMaking sure you perform a whitelist process can be really important, especially if you want to avoid passing an error back to the presentation layer. With dynamic object names, this can be achieved my checking the values of the dynamic objects against the system tables, such as or , or your own table of “allowed” values. Passing the value to does not generate an error, but also, it won’t actually run anything; making your statement even safer from any injection attempts.\n\nThe above ends up not printing anything, nor running any dynamic SQL, as it’s going to be very unlikely you have a table with the name in this script.\n\nDon’t use nvarchar(MAX) for your object’s name parameter\n\nThe maximum length of an object’s name in SQL Server is 128 characters, so why do you need space for 2GB worth of characters? Quite simply, you don’t. As you may have seen, I’ve been making use of the data type , which is a synonym for . If you know that the names of your objects are going to be shorter than 128 characters, then certainly use a smaller length, but there is never any need to have a length of more than 128 characters when dealing with SQL Server objects. I do recommend using rather than , as a object can contain Unicode characters. Just because you \"know\" your objects don't contain any of those characters now, doesn't mean they won't in the future (and the parameter to be implicitly cast to a if you're white listing against the system objects as well).\n\nDon’t always debug the code that creates the dynamic SQL first, debug the generated SQL statement instead\n\nContinuing on my earlier point of making your SQL easier to debug by using formatting inside the dynamic statement, often it’s easier to debug the generated statement first and then the code that creates it. Using (or a Statement if your dynamic SQL is over 4,000 characters) you can inspect the SQL that is about to be run. You can then run that code on its own and see where the error is being generated and more importantly why. Once you work out why that’s failing you can then propagate the solution to your SQL that creates the dynamic statement.\n\nSometimes the reason for the error can be very simple, like a space is missing between 2 words. These can be very difficult to spot when all your code looks like a literal string. Getting the value of your dynamic statement means you can view the code as it’s going to be run, with all the fancy colours that your preferred UI provides, and will make debugging the code far easier."
    },
    {
        "link": "https://stackoverflow.com/questions/74466924/best-practice-of-executing-dynamic-sql-strings-via-prepared-statements-and-proce",
        "document": "Background: I am building a Springboot+mySQL app that uses Spring Data JPA native queries (i.e. to retrieve database data.\n\nWe have to use the same SQL in every query we write to enable certain functionality (this can be seen in the example below). And wanted a way to remove this duplicate SQL and instead only declare it once. An option presented was to pass a dynamic SQL string into a stored procedure and then build a prepared statement by concatenating this dynamic SQL string with our static shared SQL string (show in example below).\n\nQuestion: This doesn't seem like a good idea to me, but I am not knowledgeable enough about databases to given the exact technical reasons. Is the below example safe, reasonable, and best-practice? Are there ways to mitigate issues with this approach, or are there other approaches to use instead?"
    },
    {
        "link": "https://medium.com/@navindevan/executing-dynamic-sql-in-sql-server-b072b1c5501b",
        "document": "Dynamic SQL is a powerful feature of SQL Server that allows you to construct and execute SQL statements dynamically at runtime. This capability can be particularly useful in situations where you need to construct complex queries based on varying inputs or conditions. However, it also comes with its own set of challenges and potential pitfalls. This article aims to provide a detailed understanding of dynamic SQL, its various execution methods, and best practices for its usage. We will also discuss scenarios where dynamic SQL is appropriate and situations where it should be avoided.\n\nDynamic SQL refers to SQL code that is generated and executed at runtime rather than being hard-coded in the application. This approach allows for greater flexibility, as the SQL statements can be tailored based on user input, application state, or other runtime conditions. Dynamic SQL is constructed as a string and then executed by the SQL Server.\n\nThere are two ways to execute dynamic SQL in SQL Server, each with its own advantages and considerations. The primary methods are.\n\nThe EXECUTE (or EXEC) statement is a straightforward way to execute dynamic SQL. It is simple and easy to use but has certain limitations.\n\nIn the below example, the EXEC statement executes the dynamic SQL string stored in the @SQL variable.\n• Harder to debug and maintain for complex queries.\n\nThe sp_executesql stored procedure is a more robust and secure way to execute dynamic SQL. It allows for parameterized queries, which enhances security and performance.\n\nIn the below example, sp_executesql executes a parameterized dynamic SQL statement, providing better security and performance.\n• Allows for better query plan reuse, improving performance.\n• More readable and maintainable for complex queries.\n• Slightly more complex to use than EXEC.\n\nWhen to Use Dynamic SQL?\n\nDynamic SQL is particularly useful in the following scenarios.\n• Dynamic Table Names or Column Names: When the table name or column names need to be decided at runtime.\n• Complex Search Conditions: When the search conditions are not known until runtime and can vary significantly.\n• Metadata Queries: When querying system catalog views or system tables where the structure is not known until runtime.\n• Data-Driven Logic: When business logic depends on data that is not known until runtime.\n\nWhen Not to Use Dynamic SQL?\n\nDynamic SQL should be avoided in the following scenarios.\n• Simple Static Queries: When the SQL statements are known and do not change, using static SQL is simpler and more efficient.\n• Security Concerns: If not handled properly, dynamic SQL can lead to SQL injection vulnerabilities.\n• Performance Issues: Excessive use of dynamic SQL can lead to poor performance due to the lack of query plan reuse.\n• Complexity and Maintainability: Dynamic SQL can make the code more complex and harder to maintain.\n\nBest Practices for Using Dynamic SQL\n\nWhen using dynamic SQL, follow these best practices to ensure security, performance, and maintainability.\n• Always use parameterized queries to prevent SQL injection and improve performance.\n• Use the QUOTENAME function to safely include object names (e.g., table names, column names) in dynamic SQL.\n• Always validate and sanitize input values to prevent SQL injection.\n• Minimize the Use of Dynamic SQL, use dynamic SQL only when necessary. For static or known queries, use regular SQL statements.\n• Monitor the performance of dynamic SQL statements and optimize them as needed. Use tools like SQL Server Profiler or Extended Events to analyze performance.\n• Document and comment on your dynamic SQL code to make it easier to understand and maintain.\n\nDynamic SQL can also handle output parameters using sp_executesql.\n\nIn the below example, the sp_executesql procedure is used to execute a dynamic SQL statement with an output parameter.\n\nDynamic SQL can be used to execute dynamic Data Definition Language (DDL) statements, such as creating or altering tables.\n\n In the below example, a table is created dynamically using dynamic SQL.\n\nDynamic SQL can be embedded within stored procedures to add flexibility to the procedure logic.\n\n In the below example, a stored procedure uses dynamic SQL to retrieve employees based on a department ID.\n\nWith careful usage and adherence to best practices, dynamic SQL can be an invaluable tool in your SQL Server development toolkit, enabling you to create flexible, efficient, and secure database applications. By following best practices such as using parameterized queries, validating input, and optimizing performance, you can harness the power of dynamic SQL while mitigating its risks. Always consider the specific requirements and constraints of your application to determine when dynamic SQL is appropriate and when static SQL might be a better choice."
    },
    {
        "link": "https://sqltabletalk.com?p=843",
        "document": "Dynamic SQL is a powerful feature in SQL Server that allows you to build and execute SQL statements on the fly. It’s especially useful when you need flexibility in your queries based on varying conditions. However, a common issue with dynamic SQL is that it can lead to frequent recompilations of execution plans, which can hurt performance. In this post, I’ll explain why this happens, how you can avoid unnecessary recompiles, and provide scripts you can use to test these concepts yourself.\n\nWhen SQL Server runs a query, it creates an execution plan—a roadmap for how to execute the query. These plans are cached so that if the same query runs again, SQL Server can reuse the plan without having to recreate it, saving time and resources.\n\nWith dynamic SQL, especially when building queries by concatenating strings, the actual text of the query can change with each execution. Even small changes in the query text make SQL Server think it’s a new query, so it creates a new execution plan each time. This can lead to:\n• Plan Cache Bloat: The cache fills up with many single-use plans, consuming memory.\n\nInstead of injecting parameters directly into your dynamic SQL string, use to parameterize your queries. This keeps the query text consistent across executions, allowing SQL Server to reuse the execution plan.\n\nExample Without Parameterization (Leads to Recompiles):\n\nBy using parameters, the query text remains the same every time it runs, so SQL Server can cache and reuse the execution plan.\n\n2. Avoid Dynamic SQL When It’s Not Necessary\n\nBefore using dynamic SQL, consider whether you really need it. If your query structure is fixed and only the parameter values change, you can use a regular parameterized query or a stored procedure.\n\nThis method avoids the complexities of dynamic SQL and ensures efficient plan reuse.\n\nIf you must use dynamic SQL, make sure the query text doesn’t change unnecessarily between executions. Avoid incorporating variable elements directly into the SQL string that could alter its text.\n\nUsing parameters ensures the query text stays the same, helping SQL Server recognize it and reuse the plan.\n\nParameter sniffing occurs when SQL Server uses the parameter values from the first execution to generate the execution plan. If subsequent executions use different parameter values that don’t perform well with the cached plan, performance can suffer.\n\nTo handle this, you can:\n• Use : Forces SQL Server to recompile the query plan for each execution, optimizing it for the current parameter values.\n\nUse this sparingly, as it increases CPU usage due to recompilation.\n• Use : Instructs SQL Server to optimize the query without using the initial parameter values, which can result in a more general execution plan.\n\nKeep an eye on your SQL Server to identify queries that are causing recompiles. You can use dynamic management views (DMVs) or Extended Events to monitor recompilation events.\n\nThis query helps you find ad-hoc queries with low reuse counts, indicating they might be causing recompiles.\n\nWhen declaring parameters in , make sure the data types and lengths match those in the database. Mismatches can lead to implicit conversions, which can prevent plan reuse.\n\nAltering session-level SET options within your dynamic SQL can cause SQL Server to treat each execution as a different query. Keep SET options consistent to enable plan reuse.\n\nSet all necessary SET options at the session level before executing the dynamic SQL.\n\nEven minor differences like extra spaces or comments can change the query text and prevent plan reuse. Keep your SQL statements formatted consistently.\n\nWhile not directly related to recompiles, it’s important to protect your dynamic SQL from SQL injection attacks. Use parameterization and functions like for object names.\n\nTo try out these examples, you can create a test database with the following script:\n• Run the script above to create the database and the table.\n• The table includes sample data that we’ll use in the examples.\n• An index is created on to simulate a more realistic scenario.\n\nDynamic SQL doesn’t have to be a performance headache. By following these best practices—like parameterizing your queries with , keeping your SQL statements consistent, and monitoring for recompiles—you can enjoy the flexibility of dynamic SQL without sacrificing performance.\n\nRemember, the goal is to keep the query text consistent so that SQL Server can cache and reuse execution plans. This boosts performance and helps maintain a healthier SQL Server environment. Keep an eye on your queries, and adjust your approach as needed to ensure your dynamic SQL is as efficient as possible."
    },
    {
        "link": "https://learn.microsoft.com/en-us/sql/t-sql/language-elements/set-operators-except-and-intersect-transact-sql?view=sql-server-ver16",
        "document": "Applies to: SQL Server Azure SQL Database Azure SQL Managed Instance Azure Synapse Analytics Analytics Platform System (PDW) SQL analytics endpoint in Microsoft Fabric Warehouse in Microsoft Fabric SQL database in Microsoft Fabric\n\nReturns distinct rows by comparing the results of two queries.\n\nEXCEPT returns distinct rows from the left input query that aren't output by the right input query.\n\nINTERSECT returns distinct rows that are output by both the left and right input queries operator.\n\nTo combine the result sets of two queries that use EXCEPT or INTERSECT, the basic rules are:\n• None The number and the order of the columns must be the same in all queries.\n• None The data types must be compatible.\n\n<query_specification> | ( <query_expression> )\n\n Is a query specification or query expression that returns data to be compared with the data from another query specification or query expression. The definitions of the columns that are part of an EXCEPT or INTERSECT operation don't have to be the same. But, they must be comparable through implicit conversion. When data types differ, the rules for data type precedence determine the data type that is run for comparison.\n\nThe result is based on the same rules for combining expressions when the types are the same but differ in precision, scale, or length. For more information, see Precision, Scale, and Length (Transact-SQL).\n\nThe query specification or expression can't return xml, text, ntext, image, or nonbinary CLR user-defined type columns because these data types aren't comparable.\n\nEXCEPT\n\n Returns any distinct values from the query left of the EXCEPT operator. Those values return as long the right query doesn't return those values as well.\n\nINTERSECT\n\n Returns any distinct values that are returned by both the query on the left and right sides of the INTERSECT operator.\n\nThe data types of comparable columns are returned by the queries left and right of the EXCEPT or INTERSECT operators. These data types can include character data types with different collations. When they do, the required comparison is run according to the rules of collation precedence. If you can't run this conversion, the SQL Server Database Engine returns an error.\n\nWhen comparing column values for determining DISTINCT rows, two NULL values are considered equal.\n\nEXCEPT and INTERSECT return the result set's column names that are the same as the column names that the query on the operator's left side returns.\n\nColumn names or aliases in ORDER BY clauses must reference column names returned by the left-side query.\n\nThe nullability of any column in the result set returned by EXCEPT or INTERSECT is the same as the nullability of the corresponding column that is returned by the query on the operator's left side.\n\nIf EXCEPT or INTERSECT is used together with other operators in an expression, it's evaluated in the context of the following precedence:\n• None EXCEPT and UNION evaluated from left to right based on their position in the expression\n\nYou can use EXCEPT or INTERSECT to compare more than two sets of queries. When you do, data type conversion is determined by comparing two queries at a time, and following the previously mentioned rules of expression evaluation.\n\nEXCEPT and INTERSECT can't be used in distributed partitioned view definitions, query notifications.\n\nEXCEPT and INTERSECT may be used in distributed queries, but are only executed on the local server and not pushed to the linked server. As such, using EXCEPT and INTERSECT in distributed queries may affect performance.\n\nYou can use fast forward-only and static cursors in the result set when they're used with an EXCEPT or INTERSECT operation. You can also use a keyset-driven or dynamic cursor together with an EXCEPT or INTERSECT operation. When you do, the cursor of the operation result set is converted to a static cursor.\n\nWhen an EXCEPT operation is displayed by using the Graphical Showplan feature in SQL Server Management Studio, the operation appears as a left anti semi join, and an INTERSECT operation appears as a left semi join.\n\nThe following examples show using the and operators. The first query returns all values from the table for comparison to the results with and .\n\nThe following query returns any distinct values that are returned by both the query on the left and right sides of the operator.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query. The tables are reversed from the previous example.\n\nThe following examples show how to use the and operators. The first query returns all values from the table for comparison to the results with and .\n\nThe following query returns any distinct values that are returned by both the query on the left and right sides of the operator.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query."
    },
    {
        "link": "https://red-gate.com/simple-talk/databases/sql-server/performance-sql-server/the-except-and-intersect-operators-in-sql-server",
        "document": "Quite often, you’re faced with the task of comparing two or more tables, or query results, to determine which information is the same and which isn’t. One of the most common approaches to doing such a comparison is to use the UNION or UNION ALL operator to combine the relevant columns of the results that you want to compare. As long as you adhere to the restrictions placed on either of those operators, you can combine data sets whether they come from different databases or even different servers. With the UNION operator, you end up with a result containing every distinct row from the two results combined. However, it becomes more difficult to use UNION to return only the common data that is held in both results, or the different data that exists in one table but not the other(s). To get the results you need, you must use UNION ALL with a GROUP BY clause, though the logic isn’t always obvious on how to do this. And it isn’t any easier to use a JOIN operator to get the result you want. .\n\nEnter the INTERSECT and EXCEPT operators. Beginning with SQL Server 2005, you can use these operators to combine queries and get the results you need. For instance, you can use the INTERSECT operator to return only values that match within both data sets, as shown in the following illustration .\n\nThe illustration shows how the INTERSECT operator returns data that is common to both results set; the common data is represented by the area where the two circles intersect. The illustration also shows how the EXCEPT operator works; only data that exists in one of the data sets outside the intersecting area is returned. For instance, if Set A is specified to the left of the EXCEPT operator, only values that are not in Set B are returned. In the illustration above, that would be the data in the left circle, outside the section where the two data sets intersect. The following bullets sum up which operator to use to return different combinations of data:\n• To return the data in Set A that doesn’t overlap with B, use A EXCEPT B.\n• To return only the data that overlaps in the two sets, use A INTERSECT B.\n• To return the data in Set B that doesn’t overlap with A, use B EXCEPT A.\n• To return the data in all three areas without duplicates, use A UNION B.\n• To return the data in all three areas, including duplicates, use A UNION ALL B.\n• To return the data in the non-overlapping areas of both sets, use (A UNION B) except (A INTERSECT B), or perhaps (A EXCEPT B) UNION (B EXCEPT A)\n\nThe differences between the INTERSECT and EXCEPT operators and how to use each of them will become clearer as we work through the examples in the article. Just to give you a basic idea of how they work, we’ll start with a rather unrealistic example. To demonstrate those, however, we must first create two test views (using SQL Server 2005-compatible syntax). The first view contains a single column that describes what you might have had for lunch:\n\nThe second view also contains a single column and describes what you might have had for dinner:\n\nNow we can use these two views to demonstrate how to use the UNION, INTERSECT, and EXCEPT operators. I’ve also included a couple examples that use the JOIN operator to demonstrate the differences.\n\nThe first example uses the UNION operator to join the two views in order to return everything you’ve eaten today:\n\nNow we return the same data by using a full outer join:\n\nNotice that the join requires more complex syntax; however, both statements return the same results, as shown in the following table:\n\nNow let’s look at how you would return only the food you ate (or drank) for lunch, but did not have for dinner:\n\nIn this case, I used the EXCEPT operator to return the lunch-only items. I could have achieved the same results using the following left outer join:\n\nOnce again, you can see that the join is more complex, though the results are the same, as shown in the following table:\n\nIf you wanted to return those items you had for dinner but not lunch, you can again use the EXCEPT operator, but you must reverse the order of the queries, as shown in the following example:\n\nNotice that I first retrieve the data from the Dinner view. To use the left outer join, you would again have to reverse the order of the tables:\n\nAs expected, the results are the same for both SELECT statements:\n\nIn the next example, I use the INTERSECT operator to return only the food that was eaten at both meals:\n\nAs you can see, I simply connect the two queries with the INTERSECT operator, as I did with the EXCEPT operator. You can achieve the same results by using an inner join:\n\nAs the following results show, the only items you had at both meals were olives, bread, and coffee:\n\nNow let’s look at how you would return a list of food that you ate at one of the meals, but not both meals, in other words, the food you ate other than bread, olives, and coffee. In the following statement, I use a UNION operator to join two SELECT statements:\n\nNotice that first statement retrieves only the food you ate for lunch, and the second statement retrieves only the food ate for dinner. I achieve this in the same way I did in previous examples-by using the EXCEPT operator. I then used the UNION operator to join the two result sets. You can achieve the same results by using a full outer join:\n\nIn both examples, the statements return the following results:\n\nFrom this point on, I developed the examples on a local instance of SQL Server 2008 and the AdventureWorks2008 database. Each example uses either the INTERSECT or EXCEPT operator to compare data between the Employee and JobCandidate tables, both part of the HumanResources schema. The comparison is based on the BusinessEntityID column in each table. The BusinessEntityID column in the Employee table is the primary key. In the JobCandidate table, the BusinessEntityID column is a foreign key that references the BusinessEntityID column in the Employee table. The column in the JobCandidate table also permits null values.\n\nAs I mentioned above, when you use the INTERSECT operator to combine queries, the data returned is only that which matches between the two data sets. That means, with regard to the Employee and JobCandidate tables, the result set will include only rows in which the BusinessEntityID value in the Employee table matches the BusinessEntityID value in the JobCandidate table.\n\nIn the following example, I create two queries that retrieve data from the Employee and JobCandidate tables and use the INTERSECT operator to combine those queries:\n\nThe first SELECT statement, as you can see, retrieves the BusinessEntityID column from the Employee table, and the second SELECT statement retrieves the BusinessEntityID column from the JobCandidate table. The INTERSECT operator combines the two queries.\n\nWhen you use the INTERSECT operator to combine queries (or EXCEPT, for that matter), the number of columns must be the same in both queries and the columns must be in the same order. In addition, the corresponding columns between the queries must be configured with compatible data types. The example above meets these conditions because each query returns only one column of the same data type (INT). When the INTERSECT operator is used to combine these the two queries, the statement returns the following results:\n\nAs it turns out, the Employee table and JobCandidate table have only two BusinessEntityID values in common. If you were to examine the data in the JobCandidate table, you would find that the query results here are consistent with the data in that table. The table contains only 13 rows, and the BusinessEntityID column is NULL for all but two of the rows. The BusinessEntityID values in those rows are 212 and 274. And, as you would expect, the Employee table also contains a row with a BusinessEntityID value of 212 and a row with a value of 274.\n\nCertainly, as the above example indicates, using the INTERSECT operator to combine the results of two queries together is a straightforward process. The key, as I’ve stated, is to make sure the SELECT lists in the two queries are in sync with each other.\n\nHowever, that also points out one of the limitations of using the INTERSECT operator to combine queries-and that is, you cannot include columns in one query that are not included of the second query. If you do include multiple matching columns in each query, all the column values must match in order for a row to be returned. For example, suppose you’re retrieving data from two tables that each include columns for employee IDs, first names, and last names. If you want to match the two tables based on those three columns, the three values in the first table must match the three values in the second table for a row to be returned. (At this point, you might be asking yourself what you’re doing with all that redundant data in your database.)\n\nInstead of taking this approach, you may decide to compare the IDs in both tables, but pull the first and last name from only one of the tables. Or you might decide that you want to pull information from one table that is not stored in the other table. However, because columns must correspond between the two queries when using an INTERSECT operator to combine them, you have to find a way to work around this limitation. One of the easiest ways to do that is to put your INTERSECT construction into a common table expression (CTE) and then join the expression to one of the tables to pull the additional data. For instance, the following example includes a CTE that contains the same INTERSECT construction you saw in the example above:\n\nNotice that I’ve created a CTE named cteCandidates. As you would expect, the CTE returns the BusinessEntityID values that are contained in both the Employee and JobCandidate tables. In the primary SELECT statement, I then join the Employee table to the CTE in order to also retrieve the LoginID and JobTitle values from the Employee table. Because I put the INTERSECT join in the CTE, the statement can now return the following results:\n\nAs you can see, I’ve gotten around the limitations of the INTERSECT operator and am now returning additional information from one of the tables. I could have also joined the CTE to a different table in order to include additional information. For example, I might have joined what I have here to the Person table to retrieve the employee’s first and last names. The point is, the CTE let’s you be quite flexible when working with the INTERSECT operator; you can still determine which rows match but also return all the data you need, regardless of the source table.\n\nWorking with the EXCEPT Operator\n\nOnce you’ve mastered the INTERSECT operator, you have, for the most part, mastered the EXCEPT operator. As I stated earlier, the EXCEPT operator returns only those rows that do not have a match in the joined table. The important point to remember when using the EXCEPT operator is that it makes a difference which side of the operator you place the query. Only data from the query to the left of the operator (before the operator) is returned. Let’s look at an example to demonstrate how this works.\n\nIn the following statement, I again combine two queries, one that retrieves data from the Employee table and one that retrieves data from the JobCandidate table:\n\nThis statement is nearly identical to the INTERSECT construction you saw in the first two examples, except, of course, for the use of the EXCEPT operator. However, because the query to the left of the operator is retrieving data from the Employee table, the final result set will include data only from that table, and not the JobCandidate table.\n\nThe Employee table, as it turns out, contains 290 rows. As you’ll recall from the previous examples, the two rows in the table with the BusinessEntityID values of 212 and 274 match the two rows in the JobCandidate table that also have BusinessEntityID values of 212 and 274. That means, these two rows should be excluded from the result set of the query above, which is exactly what happens. The query returns 288 rows that have BusinessEntityID values of 1 through 290. However, IDs 212 and 274 are not included in those results.\n\nNow let’s look at what happens when you reverse the order of the queries, as I’ve done in the following example:\n\nNotice that the query that retrieves data from the JobCandidate table now comes first, that is, sits to the left of the EXCEPT operator. The results from this statement, as you would expect, are quite different from the previous example. All that is returned is a single NULL value. In other words, according to the results, the JobCandidate table contains no BusinessEntityID values that are not contained in the Employee table. This is, of course, exactly the case.\n\nAs with the CTE example above, which uses the INTERSECT operator, you can also use CTEs with EXCEPT operators. But as the last example points out, if your CTE returns no data, your main query will also return no data (at least if you’re using an inner join), but that’s true with either operator. Overall, in fact, you’ll find there’s little difference between the INTERSECT and EXCEPT operators, in terms of how you use them. The difference, of course, is in the results. INTERSECT returns rows common to both queries, and EXCEPT returns only rows in the left query. Both operators, however, are useful additions to the types of joins that the UNION and UNION ALL operators provide. You can find more details about the INTERSECT and EXCEPT operators by referring to the topic “EXCEPT and INTERSECT (Transact-SQL)” in SQL Server Books Online. There you’ll find additional information about each operator and additional examples of how to use them."
    },
    {
        "link": "https://learn.microsoft.com/pl-pl/SQL/t-sql/language-elements/set-operators-except-and-intersect-transact-sql?view=sql-server-ver15",
        "document": "Applies to: SQL Server Azure SQL Database Azure SQL Managed Instance Azure Synapse Analytics Analytics Platform System (PDW) SQL analytics endpoint in Microsoft Fabric Warehouse in Microsoft Fabric SQL database in Microsoft Fabric\n\nReturns distinct rows by comparing the results of two queries.\n\nEXCEPT returns distinct rows from the left input query that aren't output by the right input query.\n\nINTERSECT returns distinct rows that are output by both the left and right input queries operator.\n\nTo combine the result sets of two queries that use EXCEPT or INTERSECT, the basic rules are:\n• None The number and the order of the columns must be the same in all queries.\n• None The data types must be compatible.\n\n<query_specification> | ( <query_expression> )\n\n Is a query specification or query expression that returns data to be compared with the data from another query specification or query expression. The definitions of the columns that are part of an EXCEPT or INTERSECT operation don't have to be the same. But, they must be comparable through implicit conversion. When data types differ, the rules for data type precedence determine the data type that is run for comparison.\n\nThe result is based on the same rules for combining expressions when the types are the same but differ in precision, scale, or length. For more information, see Precision, Scale, and Length (Transact-SQL).\n\nThe query specification or expression can't return xml, text, ntext, image, or nonbinary CLR user-defined type columns because these data types aren't comparable.\n\nEXCEPT\n\n Returns any distinct values from the query left of the EXCEPT operator. Those values return as long the right query doesn't return those values as well.\n\nINTERSECT\n\n Returns any distinct values that are returned by both the query on the left and right sides of the INTERSECT operator.\n\nThe data types of comparable columns are returned by the queries left and right of the EXCEPT or INTERSECT operators. These data types can include character data types with different collations. When they do, the required comparison is run according to the rules of collation precedence. If you can't run this conversion, the SQL Server Database Engine returns an error.\n\nWhen comparing column values for determining DISTINCT rows, two NULL values are considered equal.\n\nEXCEPT and INTERSECT return the result set's column names that are the same as the column names that the query on the operator's left side returns.\n\nColumn names or aliases in ORDER BY clauses must reference column names returned by the left-side query.\n\nThe nullability of any column in the result set returned by EXCEPT or INTERSECT is the same as the nullability of the corresponding column that is returned by the query on the operator's left side.\n\nIf EXCEPT or INTERSECT is used together with other operators in an expression, it's evaluated in the context of the following precedence:\n• None EXCEPT and UNION evaluated from left to right based on their position in the expression\n\nYou can use EXCEPT or INTERSECT to compare more than two sets of queries. When you do, data type conversion is determined by comparing two queries at a time, and following the previously mentioned rules of expression evaluation.\n\nEXCEPT and INTERSECT can't be used in distributed partitioned view definitions, query notifications.\n\nEXCEPT and INTERSECT may be used in distributed queries, but are only executed on the local server and not pushed to the linked server. As such, using EXCEPT and INTERSECT in distributed queries may affect performance.\n\nYou can use fast forward-only and static cursors in the result set when they're used with an EXCEPT or INTERSECT operation. You can also use a keyset-driven or dynamic cursor together with an EXCEPT or INTERSECT operation. When you do, the cursor of the operation result set is converted to a static cursor.\n\nWhen an EXCEPT operation is displayed by using the Graphical Showplan feature in SQL Server Management Studio, the operation appears as a left anti semi join, and an INTERSECT operation appears as a left semi join.\n\nThe following examples show using the and operators. The first query returns all values from the table for comparison to the results with and .\n\nThe following query returns any distinct values that are returned by both the query on the left and right sides of the operator.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query. The tables are reversed from the previous example.\n\nThe following examples show how to use the and operators. The first query returns all values from the table for comparison to the results with and .\n\nThe following query returns any distinct values that are returned by both the query on the left and right sides of the operator.\n\nThe following query returns any distinct values from the query left of the operator that aren't also found on the right query."
    },
    {
        "link": "https://stratascratch.com/blog/understanding-sql-s-intersect-command",
        "document": "What is INTERSECT in SQL? How does it work? When to use it? How to write an INTERSECT query? You can find all these questions answered in this article.\n\nThe diversity of SQL’s set of commands is widely celebrated, as it offers so many possibilities to SQL users. However, there’s one drawback: some operators get unjustly talked about less and neglected.\n\nOne such operator is INTERSECT. I will use this article to try and right this wrong.\n\nWhat Is an INTERSECT Operator in SQL?\n\nThe INTERSECT in SQL is one of the four set operators in SQL. The other three are:\n\nThe set operators combine the outputs of two or more queries into one result. SQL INTERSECT does that by finding common data between the query outputs. In other words, it returns an intersection of data. It inherently removes duplicates.\n\n\n\nIt comes in handy when you want to identify overlapping data between multiple tables or queries.\n\nSome database systems also support INTERSECT ALL. It does the same thing as INTERSECT, only it doesn’t remove duplicates.\n\nThe basic syntax of SQL INTERSECT is quite simple.\n\nIf you want to collate more datasets, simply write the INTERSECT keyword between each SELECT statement. Or use INTERSECT ALL if you want to include duplicates.\n\nLike other set operators, INTERSECT compares the results of two or more SELECT statements.\n\nFor it to work, there are two important rules you must follow.\n• The number of columns must be the same in every SELECT.\n• The columns across the SELECT statements must be the same data type. Explained differently, column_1 in the first SELECT must be the same data type as column_1 in the second SELECT. This is logical as the columns will be vertically merged into one dataset.\n\n\n\nLet me show you an example of how INTERSECT works. We have two tables: employees and ex_employees. We want to find the employees’ IDs and names that are in both tables so we can inspect the data.\n\nThe GIF below shows how this works.\n\nAs you already learned, INTERSECT is used to output the intersection of data between two or more queries. This has many practical applications in business, so let’s look at them.\n\nThe question by MetLife, Credit Acceptance, and Credit Karma wants you to find the user ID of all users that have created at least one ‘Refinance’ submission and at least one ‘InSchool’ submission.\n\nIn this example, you will work with only one table, namely loans. It contains information about loans, such as user ID, date of creation, loan status, and loan type.\n\nYou can now apply what you learned when I explained how SQL INTERSECT works. It’s not much different from this example. Write the first SELECT, which will show user IDs. Additionally, filter data so it shows only those IDs whose loan is categorized as ‘Refinance’.\n\nWrite the second SELECT that does the same, only for the ‘InSchool’ category, and separate the two queries with INTERSECT.\n\nThe output shows there’s only one user who has loans in both categories.\n\nSQL INTERSECT Example #2: Price Of Wines In Each Country\n\nThis question by Wine Magazine asks you to find the minimum, average, and maximum price of the wines per country. However, I’ll change the requirements a bit. Yes, I’ll still output the country name along with the corresponding minimum, maximum, and average prices. But, I want to include in the calculation only wines that are found in both tables of the dataset. We will define that the wines are the same if they come from the same country and have the same price.\n\nThe question provides you with the tables winemag_p1 and winemag_p2. They both hold various info about the wines.\n\nThe official solution uses UNION ALL. However, since I modified the question, I’ll use INTERSECT instead.\n\nLet me first write the subquery part and then build the solution from there. So, the subquery part consists of two SELECT statements with INTERSECT. I use it to get the countries and prices from both tables. This way, I get only the wines that can be found in both tables.\n\nI also convert the price values to decimal numbers. This is because I’ll use them in aggregations later. While it makes no difference with the MIN() and MAX() functions, it does with AVG() as it sums the values and divides them with the number of occurrences.\n\nAdditionally, I want to remove all the records with no price, as I don’t want to consider all NULLs as one wine. This is to build a robust code that considers the edge case where the price is NULL. (I know for a fact that there are some rows without a price.)\n\nThis is now a list of countries and prices of wines that can be found in both tables.\n\n\n\nNow, I’ll use this result in the main query. I select the country from the subquery part and then calculate the minimum, average, and maximum wine price.\n\nWe use WHERE to exclude the countries whose names are missing. This is not necessary with our dataset, but again, let’s build a robust query that will survive edge cases.\n\nAs a final step, I group the output by country to get all the calculations for each country separately.\n\nThe code gives us five countries and the minimum, average, and maximum prices for the wines from both tables.\n\nSQL INTERSECT Example #3: Find the List of Intersections Between Both Word Lists\n\nThe question by Google asks you to find the list of intersections between both word lists. The wording here is quite straightforward: it mentions the list of intersections, so it’s an obvious clue we should use INTERSECT.\n\nThere’s only one table in this question: google_word_lists. It gives you a list of words separated by a comma in both words1 and words2 columns.\n\nThe most complicated part is not INTERSECT, but how to turn the list of words from each column into one word per row. Luckily, there are two functions in PostgreSQL you can combine to do that.\n\nFirst, use the STRING_TO_ARRAY() function that does the obvious: turns the string values into an array. You specify the column word1 and the separator (a comma in this case) in the function.\n\nSecond, embed this function in the UNNEST() function. It’s a function used to explode the array into a set of rows.\n\nThen, use INTERSECT and repeat all the steps above, but this time for column words2.\n\nThe output shows all the words that can be found in both columns of the provided table.\n\nDifferences Between INTERSECT and Other SQL Operations\n\nSometimes, it can be difficult for beginners to discern the difference between INTERSECT, other set operators, and JOINs in SQL.\n\nLet me talk about those differences and show you the examples.\n\nWhile INTERSECT finds the common data from two or more SELECT statements, UNION ALL the queries’ result sets, including duplicates. In other words, it just merges all the data vertically.\n\nLet’s go back to the first INTERSECT example. This is a code we used to output the loan submission types.\n\n\n\nThe code returns only one user whose loan submissions belong to both the ‘Refinance’ and ‘InSchool’ categories.\n\nNow, if I wanted to rewrite this code using UNION ALL, this is how it would look.\n\nThe output shows ID 108 from the INTERSECT query and all other IDs, including duplicates.\n\nThe UNION set operator does the same thing as UNION ALL; only it excludes duplicates.\n\nSo, again, I can rework the query by using UNION.\n\nThe output shows the ID 108 – like the INTERSECT query – and all other IDs, like UNION ALL, but without duplicate values.\n\nEXCEPT is the opposite version of INTERSECT. Whereas INTERSECT returns the common data between the query outputs, EXCEPT returns only data from the first data set that does not exist in the second dataset.\n\nIf we rework the previous queries this way\n\nit will output all the users with the ‘Refinance’ loan submissions that don’t have the ‘InSchool’ submissions.\n\nINTERSECT finds common rows in query outputs and combines data vertically. On the other hand, JOIN operations combine rows and columns from two or more tables and stack data horizontally.\n\nThe INTERSECT solution to the submission types of interview questions can be rewritten this way.\n\nI gave the loans table two different aliases (l_1 and l_2) so I can join the table with itself. The tables are joined on the common column, which is user_id.\n\nI’m looking for the distinct user_id, so I’ll remove duplicates using the DISTINCT keyword.\n\n\n\nAlso, I’ll set the conditions regarding the submission types in the WHERE clause.\n\nThe output is the same as with INTERSECT. In other words, the interview question can be solved using INNER JOIN instead of INTERSECT.\n\nTips for Optimizing Queries That Use INTERSECT\n\nWhile SQL INTERSECT is a very helpful tool, you should also have in mind that optimizing the queries that use it might be crucial for getting the best from it.\n\nHere are some tips on how to do this.\n\n1. Indexing: Ensure that the columns used in INTERSECT are indexed. This is particularly important for columns that are part of the WHERE clause in the individual SELECT statements. Indexes can significantly speed up the process of finding and intersecting rows.\n\n2. Limit Columns in SELECT Statements: Try to limit the number of columns in the SELECT statements that are part of the INTERSECT. The more columns you include, the more work the database has to do to compare each row. If possible, only include the columns that are absolutely necessary for the intersection.\n\n3. Simplify Conditions: Simplify the conditions in the WHERE clause as much as possible. Complex conditions can slow down the query. If you have complex filters, consider whether they can be simplified or if some can be applied after the INTERSECT operation.\n\n4. Use Subqueries Effectively: If your INTERSECT query involves large tables, it might be beneficial to use subqueries first to reduce the dataset size on which INTERSECT operates. By filtering the data in each table to a smaller subset, the INTERSECT will have less data to process.\n\n5. Consider INTERSECT Alternatives: In some cases, alternative SQL constructs like INNER JOIN, EXISTS, or even temporary tables might perform better than INTERSECT, depending on the specific database system and the data involved. Testing different approaches can help identify the most efficient one.\n\n6. Optimize Individual Queries: Ensure each query used in the INTERSECT is optimized individually. This includes using efficient joins, avoiding unnecessary columns, and applying filters early.\n\n7. Analyze Execution Plans: Use your database system's query execution plan tool to understand how your query is being executed. The execution plan provides insights into how indexes are used, how joins are performed, and where potential bottlenecks lie.\n\n8. Database-Specific Features: Different databases may have specific optimizations or settings that can impact the performance of INTERSECT queries. Check your database's documentation for any such features or recommendations.\n\n9. Keep Statistics Updated: Ensure that the database statistics are up to date. Database query optimizers rely on statistics to choose the best execution plan. Outdated statistics can lead to suboptimal query plans.\n\n10. Reduce Dataset Size: If possible, reduce the size of the datasets being intersected by filtering out unnecessary rows early in the process.\n\nLimitations or Special Considerations When Using INTERSECT in SQL\n\nSome of its limitations might thwart your plans of using INTERSECT in SQL.\n\n1. Column Matching: The SELECT statements involved in INTERSECT must have the same number of columns, and the corresponding columns must have compatible data types. This requirement can sometimes limit the flexibility of using INTERSECT, especially when dealing with tables of different structures.\n\n2. Performance Implications: INTERSECT can be less efficient than other methods, like INNER JOIN or EXISTS, especially with large datasets. The database must process the entire result set of each query involved before the intersection can occur, which can be resource-intensive.\n\n3. Order and Sorting: The order of the rows in the result set of an INTERSECT operation is not guaranteed unless an ORDER BY clause is used. Additionally, applying ORDER BY to large result sets can further impact query performance.\n\n4. Distinct Results: The INTERSECT operator inherently returns distinct rows (similar to SELECT DISTINCT). This means it automatically removes duplicates within each result set before performing the intersection. This behavior is useful for some queries but can be a limitation if you need to consider duplicate rows in your analysis.\n\n5. NULL Handling: In SQL, INTERSECT treats NULL values as equal when comparing columns. This means that two NULL values are considered a match, which might not always be the intended behavior in certain contexts.\n\n6. Combining With Other Operations: When using INTERSECT in conjunction with other set operators like UNION or EXCEPT, it's important to understand the precedence and how these operations are evaluated to ensure the correct results are obtained. Parentheses can be used to define the order explicitly.\n\n7. No Additional Conditions: Unlike JOIN operations, INTERSECT does not allow for specifying additional join conditions. It strictly compares the result sets for identical rows.\n\n8. Subquery Considerations: When using INTERSECT with subqueries, especially correlated subqueries, it's important to be mindful of the potential for increased query complexity and decreased performance.\n\n9. Use in Complex Queries: In more complex queries, especially those involving multiple set operations or subqueries, INTERSECT can make the query harder to read and understand, which can impact maintainability.\n\nDifferences in How INTERSECT Is Implemented Across Various SQL Database Systems\n\nHowever, there might be differences in how they are implemented and executed.\n• PostgreSQL: Fully supports INTERSECT. Its query planner evaluates the most efficient way to execute these queries, which may include different types of join algorithms. PostgreSQL also supports INTERSECT ALL, in case you want to include duplicate rows in your output. Here's the official documentation.\n• MySQL: It does support INTERSECT, even though it wasn’t supported for a long time. It was only introduced with the 8.0. 31 release. Same as PostgreSQL, you can use INTERSECT ALL, too. Here’s the official documentation.\n• Oracle: Also fully supports INTERSECT, but not INTERSECT ALL. Oracle's optimizer can utilize various strategies to execute INTERSECT queries, such as hash or sort-based approaches, depending on the specific query and data involved. Here's the official documentation.\n• MS SQL Server: This database also supports INTERSECT, but not INTERSECT ALL. It performs well in scenarios where the result sets being intersected are large, as it typically employs efficient algorithms for set operations. SQL Server's execution plan may use methods like hashing or sorting to process INTERSECT queries. Here's the official documentation.\n\nSQL INTERSECT can be a handy tool in your work with data. Of course, you need to know how to use it, when, and when not to use it.\n\nI covered all that in this article, with also several coding examples that can lead you even deeper into practicalities.\n\nIn some situations, you can also use INTERSECT alternatives. Again, it’s essential to know how they work and when to use them. All these commands, including INTERSECT, are crucial components of your becoming an advanced SQL user.\n\nTo achieve this and get very fluent in SQL, you should write plenty of code. You won’t lack the opportunities for that at StrataScratch, as there are 1,000+ real coding interview questions you can use for practice. And our blog is a rich resource for almost any SQL topic and concept, which is also helpful when solving SQL interview questions."
    },
    {
        "link": "https://geeksforgeeks.org/sql-server-intersect-and-except-operator",
        "document": "Multiple SQL Queries may return duplicate values in recordsets from each query result. There could be situations when a single resultset is needed to be returned by combining multiple SQL queries. In SQL Server, there are many SET operators like UNION, EXCEPT, and INTERSECT to merge multiple results of select statements to a single result set. The INTERSECT operator is one of them which is used to filter distinct values.\n\nStructured Query Language (SQL) is a powerful tool for managing and manipulating relational databases. In SQL Server, various operators allow you to perform different types of set operations on your data. Two such operators are and , which are used to compare and combine the results of two queries.\n\nThe INTERSECT operator is one of the Set Operators in SQL Server which is used to filter out duplicates and return only distinct rows of data. The INTERSET operator combines two or more SELECT statements and returns a single dataset with common and distinct data between the SELECT statements on the right and the left of the INTERSECT operator.\n• query_specification query_expression is a SELECT statement with or without a where clause.\n• None INTERSECT is the operator used to filter distinct or unique data common to the queries specified.\n\nEXCEPT keyword is an operator that is used to retrieve distinct rows from the left query result set that are not present in the right query result set in a given query. It can be useful in finding the difference between two sets of data. The syntax for the EXCEPT operator is given as follows\n\nExamples of SQL Server INTERSECT and EXCEPT Operator\n\nThere are 3 tables used in the examples below and the queries to create tables and insert data are given below:\n\nExample 1: Identifying Employees Who Also Serve as Managers\n\nIn the above example, there are two tables namely Employees and Managers. Using the INTERSECT operator the resultant dataset will return data of employees who are managers, meaning the names which exists in both Employees and Managers tables.\n\nExample 2: Identifying Employees with Java Technology Who Also Serve as Managers\n\nThe above example has where clause combining 2 SQL Queries, to all employees with Technology 'Java' and are managers.\n\nExample 3: We use EXCEPT Operator to Find the employees in the Employee Table that do not have any Project Assignments\n\nIn the example below, we use EXCEPT operator to find the employees in the Employee table that do not have any project assignments. In the Projects table, we use JOIN to find the employees that have project assignments.\n\nIn SQL Server, the INTERSECT and EXCEPT operators are used to get the common rows of two SELECT statements. The first SELECT statement retrieves the rows that are common to both SELECT statements. The second SELECT statement retrieves different rows that are not common to the two SELECT statements. These operators help to compare and analyze the data between two pairs of results in an SQL query."
    }
]