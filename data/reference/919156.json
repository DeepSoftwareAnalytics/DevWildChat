[
    {
        "link": "https://docs.python.org/3/library/math.html",
        "document": "This module provides access to the mathematical functions defined by the C standard.\n\nThese functions cannot be used with complex numbers; use the functions of the same name from the module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don’t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place.\n\nThe following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats.\n\nReturn the number of ways to choose k items from n items without repetition and without order. Evaluates to when and evaluates to zero when . Also called the binomial coefficient because it is equivalent to the coefficient of k-th term in polynomial expansion of . Raises if either of the arguments are not integers. Raises if either of the arguments are negative. Return n factorial as an integer. Raises if n is not integral or is negative. Changed in version 3.10: Floats with integral values (like ) are no longer accepted. Return the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is . without arguments returns . Changed in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported. Return the integer square root of the nonnegative integer n. This is the floor of the exact square root of n, or equivalently the greatest integer a such that a² ≤ n. For some applications, it may be more convenient to have the least integer a such that n ≤ a², or in other words the ceiling of the exact square root of n. For positive n, this can be computed using . Return the least common multiple of the specified integer arguments. If all arguments are nonzero, then the returned value is the smallest positive integer that is a multiple of all arguments. If any of the arguments is zero, then the returned value is . without arguments returns . Return the number of ways to choose k items from n items without repetition and with order. Evaluates to when and evaluates to zero when . If k is not specified or is , then k defaults to n and the function returns . Raises if either of the arguments are not integers. Raises if either of the arguments are negative.\n\nReturn the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to , which should return an value. Return the absolute value of x. Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to , which should return an value. Fused multiply-add operation. Return , computed as though with infinite precision and range followed by a single round to the format. This operation often provides better accuracy than the direct expression . This function follows the specification of the fusedMultiplyAdd operation described in the IEEE 754 standard. The standard leaves one case implementation-defined, namely the result of and . In these cases, returns a NaN, and does not raise any exception. Return the floating-point remainder of , as defined by the platform C library function . Note that the Python expression may not return the same result. The intent of the C standard is that be exactly (mathematically; to infinite precision) equal to for some integer n such that the result has the same sign as x and magnitude less than . Python’s returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, is , but the result of Python’s is , which cannot be represented exactly as a float, and rounds to the surprising . For this reason, function is generally preferred when working with floats, while Python’s is preferred when working with integers. Return the fractional and integer parts of x. Both results carry the sign of x and are floats. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return the IEEE 754-style remainder of x with respect to y. For finite x and finite nonzero y, this is the difference , where is the closest integer to the exact value of the quotient . If is exactly halfway between two consecutive integers, the nearest even integer is used for . The remainder thus always satisfies . Special cases follow IEEE 754: in particular, is x for any finite x, and and raise for any non-NaN x. If the result of the remainder operation is zero, that zero will have the same sign as x. On platforms using IEEE 754 binary floating point, the result of this operation is always exactly representable: no rounding error is introduced. Return x with the fractional part removed, leaving the integer part. This rounds toward 0: is equivalent to for positive x, and equivalent to for negative x. If x is not a float, delegates to , which should return an value. For the , , and functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with necessarily has no fractional bits.\n\nReturn a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, returns -1.0. Return the mantissa and exponent of x as the pair . m is a float and e is an integer such that exactly. If x is zero, returns , otherwise . This is used to “pick apart” the internal representation of a float in a portable way. Note that has a different call/return pattern than its C equivalents: it takes a single argument and return a pair of values, rather than returning its second return value through an ‘output parameter’ (there is no such thing in Python). Return if the values a and b are close to each other and otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. If no errors occur, the result will be: . rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass . The default tolerance is , which assures that the two values are the same within about 9 decimal digits. rel_tol must be nonnegative and less than . abs_tol is the absolute tolerance; it defaults to and it must be nonnegative. When comparing to , is computed as , which is for any nonzero and rel_tol less than . So add an appropriate positive abs_tol argument to the call. The IEEE 754 special values of , , and will be handled according to IEEE rules. Specifically, is not considered close to any other value, including . and are only considered close to themselves. Return if x is neither an infinity nor a NaN, and otherwise. (Note that is considered finite.) Return if x is a positive or negative infinity, and otherwise. Return if x is a NaN (not a number), and otherwise. Return . This is essentially the inverse of function . Return the floating-point value steps steps after x towards y. If x is equal to y, return y, unless steps is zero.\n• None goes up: towards positive infinity.\n• None goes down: towards minus infinity.\n• None goes towards zero.\n• None goes away from zero. Return the value of the least significant bit of the float x:\n• None If x is a NaN (not a number), return x.\n• None If x is equal to zero, return the smallest positive denormalized representable float (smaller than the minimum positive normalized float, ).\n• None If x is equal to the largest positive representable float, return the value of the least significant bit of x, such that the first float smaller than x is .\n• None Otherwise (x is a positive finite number), return the value of the least significant bit of x, such that the first float bigger than x is . ULP stands for “Unit in the Last Place”. See also and .\n\nReturn e raised to the power x, where e = 2.718281… is the base of natural logarithms. This is usually more accurate than or . Return e raised to the power x, minus 1. Here e is the base of natural logarithms. For small floats x, the subtraction in can result in a significant loss of precision; the function provides a way to compute this quantity to full precision: With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as . Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. Return the base-2 logarithm of x. This is usually more accurate than . returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. Return the base-10 logarithm of x. This is usually more accurate than . Return x raised to the power y. Exceptional cases follow the IEEE 754 standard as far as possible. In particular, and always return , even when x is a zero or a NaN. If both x and y are finite, x is negative, and y is not an integer then is undefined, and raises . Unlike the built-in operator, converts both its arguments to type . Use or the built-in function for computing exact integer powers. Changed in version 3.11: The special cases and were changed to return instead of raising , for consistency with IEEE 754.\n\nReturn the Euclidean distance between two points p and q, each given as a sequence (or iterable) of coordinates. The two points must have the same dimension. Return an accurate floating-point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums. The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating-point summation. Return the Euclidean norm, . This is the length of the vector from the origin to the point given by the coordinates. For a two dimensional point , this is equivalent to computing the hypotenuse of a right triangle using the Pythagorean theorem, . Changed in version 3.8: Added support for n-dimensional points. Formerly, only the two dimensional case was supported. Changed in version 3.10: Improved the algorithm’s accuracy so that the maximum error is under 1 ulp (unit in the last place). More typically, the result is almost always correctly rounded to within 1/2 ulp. Calculate the product of all the elements in the input iterable. The default start value for the product is . When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types. Return the sum of products of values from two iterables p and q. Raises if the inputs do not have the same length. For float and mixed int/float inputs, the intermediate products and sums are computed with extended precision.\n\nThe mathematical constant π = 3.141592…, to available precision. The mathematical constant e = 2.718281…, to available precision. The mathematical constant τ = 6.283185…, to available precision. Tau is a circle constant equal to 2π, the ratio of a circle’s circumference to its radius. To learn more about Tau, check out Vi Hart’s video Pi is (still) Wrong, and start celebrating Tau day by eating twice as much pie! A floating-point positive infinity. (For negative infinity, use .) Equivalent to the output of . A floating-point “not a number” (NaN) value. Equivalent to the output of . Due to the requirements of the IEEE-754 standard, and are not considered to equal to any other numeric value, including themselves. To check whether a number is a NaN, use the function to test for NaNs instead of or . Example: Changed in version 3.11: It is now always available. CPython implementation detail: The module consists mostly of thin wrappers around the platform C math library functions. Behavior in exceptional cases follows Annex F of the C99 standard where appropriate. The current implementation will raise for invalid operations like or (where C99 Annex F recommends signaling invalid operation or divide-by-zero), and for results that overflow (for example, ). A NaN will not be returned from any of the functions above unless one or more of the input arguments was a NaN; in that case, most functions will return a NaN, but (again following C99 Annex F) there are some exceptions to this rule, for example or . Note that Python makes no effort to distinguish signaling NaNs from quiet NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior is to treat all NaNs as though they were quiet. Complex number versions of many of these functions."
    },
    {
        "link": "https://w3schools.com/python/module_math.asp",
        "document": "Python has a built-in module that you can use for mathematical tasks.\n\nThe module has a set of methods and constants."
    },
    {
        "link": "https://docs.python.org/3.6/library/math.html",
        "document": "This module is always available. It provides access to the mathematical functions defined by the C standard.\n\nThese functions cannot be used with complex numbers; use the functions of the same name from the module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don’t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place.\n\nThe following functions are provided by this module. Except when explicitly noted otherwise, all return values are floats.\n\nReturn the ceiling of x, the smallest integer greater than or equal to x. If x is not a float, delegates to , which should return an value. Return a float with the magnitude (absolute value) of x but the sign of y. On platforms that support signed zeros, returns -1.0. Return the absolute value of x. Return x factorial. Raises if x is not integral or is negative. Return the floor of x, the largest integer less than or equal to x. If x is not a float, delegates to , which should return an value. Return , as defined by the platform C library. Note that the Python expression may not return the same result. The intent of the C standard is that be exactly (mathematically; to infinite precision) equal to for some integer n such that the result has the same sign as x and magnitude less than . Python’s returns a result with the sign of y instead, and may not be exactly computable for float arguments. For example, is , but the result of Python’s is , which cannot be represented exactly as a float, and rounds to the surprising . For this reason, function is generally preferred when working with floats, while Python’s is preferred when working with integers. Return the mantissa and exponent of x as the pair . m is a float and e is an integer such that exactly. If x is zero, returns , otherwise . This is used to “pick apart” the internal representation of a float in a portable way. Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums: The algorithm’s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit. For further discussion and two alternative approaches, see the ASPN cookbook recipes for accurate floating point summation. Return the greatest common divisor of the integers a and b. If either a or b is nonzero, then the value of is the largest positive integer that divides both a and b. returns . Return if the values a and b are close to each other and otherwise. Whether or not two values are considered close is determined according to given absolute and relative tolerances. rel_tol is the relative tolerance – it is the maximum allowed difference between a and b, relative to the larger absolute value of a or b. For example, to set a tolerance of 5%, pass . The default tolerance is , which assures that the two values are the same within about 9 decimal digits. rel_tol must be greater than zero. abs_tol is the minimum absolute tolerance – useful for comparisons near zero. abs_tol must be at least zero. If no errors occur, the result will be: . The IEEE 754 special values of , , and will be handled according to IEEE rules. Specifically, is not considered close to any other value, including . and are only considered close to themselves. Return if x is neither an infinity nor a NaN, and otherwise. (Note that is considered finite.) Return if x is a positive or negative infinity, and otherwise. Return if x is a NaN (not a number), and otherwise. Return . This is essentially the inverse of function . Return the fractional and integer parts of x. Both results carry the sign of x and are floats. Return the value x truncated to an (usually an integer). Delegates to . Note that and have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an ‘output parameter’ (there is no such thing in Python). For the , , and functions, note that all floating-point numbers of sufficiently large magnitude are exact integers. Python floats typically carry no more than 53 bits of precision (the same as the platform C double type), in which case any float x with necessarily has no fractional bits.\n\nReturn . For small floats x, the subtraction in can result in a significant loss of precision; the function provides a way to compute this quantity to full precision: With one argument, return the natural logarithm of x (to base e). With two arguments, return the logarithm of x to the given base, calculated as . Return the natural logarithm of 1+x (base e). The result is calculated in a way which is accurate for x near zero. Return the base-2 logarithm of x. This is usually more accurate than . returns the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros. Return the base-10 logarithm of x. This is usually more accurate than . Return raised to the power . Exceptional cases follow Annex ‘F’ of the C99 standard as far as possible. In particular, and always return , even when is a zero or a NaN. If both and are finite, is negative, and is not an integer then is undefined, and raises . Unlike the built-in operator, converts both its arguments to type . Use or the built-in function for computing exact integer powers.\n\nThe mathematical constant π = 3.141592…, to available precision. The mathematical constant e = 2.718281…, to available precision. The mathematical constant τ = 6.283185…, to available precision. Tau is a circle constant equal to 2π, the ratio of a circle’s circumference to its radius. To learn more about Tau, check out Vi Hart’s video Pi is (still) Wrong, and start celebrating Tau day by eating twice as much pie! A floating-point positive infinity. (For negative infinity, use .) Equivalent to the output of . A floating-point “not a number” (NaN) value. Equivalent to the output of . CPython implementation detail: The module consists mostly of thin wrappers around the platform C math library functions. Behavior in exceptional cases follows Annex F of the C99 standard where appropriate. The current implementation will raise for invalid operations like or (where C99 Annex F recommends signaling invalid operation or divide-by-zero), and for results that overflow (for example, ). A NaN will not be returned from any of the functions above unless one or more of the input arguments was a NaN; in that case, most functions will return a NaN, but (again following C99 Annex F) there are some exceptions to this rule, for example or . Note that Python makes no effort to distinguish signaling NaNs from quiet NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior is to treat all NaNs as though they were quiet. Complex number versions of many of these functions."
    },
    {
        "link": "https://makeblock-micropython-api.readthedocs.io/en/latest/library/math.html",
        "document": "This module implements a subset of the corresponding module, as described below. For more information, refer to the original CPython documentation: .\n\nThe module provides some basic mathematical functions for working with floating-point numbers.\n\nNote: On the pyboard, floating-point numbers have 32-bit precision.\n\nAvailability: not available on WiPy. Floating point support required for this module.\n\nReturn the principal value of the inverse tangent of . Return an integer, being rounded towards positive infinity. Return with the sign of . Return the absolute value of . Return an integer, being rounded towards negative infinity. Decomposes a floating-point number into its mantissa and exponent. The returned value is the tuple such that exactly. If then the function returns , otherwise the relation holds. Return the natural logarithm of the gamma function of . Return a tuple of two floats, being the fractional and integral parts of . Both return values have the same sign as . Returns to the power of . Return an integer, being rounded towards 0."
    },
    {
        "link": "https://geeksforgeeks.org/python-math-function-sqrt",
        "document": "math.sqrt() returns the square root of a number. It is an inbuilt function in the Python programming language, provided by the math module. In this article, we will learn about how to find the square root using this function.\n\nWe need to import before using this function.\n• None x: A number greater than or equal to 0.\n• None The square root of the number x.\n\nLet’s look at some different uses of math.sqrt() .\n\nExample 1: Check if number is prime\n\nmath.sqrt() can be used to optimize prime number checking. We only need to check divisibility up to the square root of the number.\n• n > 1, we check for factors from 2 to sqrt(n).\n• None If any divisor is found, it prints “Not prime”.\n• None If no divisors are found, it prints “Prime”.\n\nWe can use math.sqrt() to find the hypotenuse of a right-angled triangle using the Pythagorean theorem.\n• None The formula used is c = sqrt(a^2 + b^2)\n• None It calculates the hypotenuse c using the values of a b\n\nmath.sqrt() does not work for negative numbers. It raises a ValueError if we pass a number less than 0.\n• None Square roots of negative numbers are not real numbers."
    },
    {
        "link": "https://stackoverflow.com/questions/15017734/using-static-methods-in-python-best-practice",
        "document": "The glib answer is: Not very often.\n\nThe even glibber but not quite as useless answer is: When they make your code more readable.\n\nFirst, let's take a detour to the docs:\n\nSo, when you need a static method in C++, you need a static method in Python, right?\n\nIn Java, there are no functions, just methods, so you end up creating pseudo-classes that are just bundles of static methods. The way to do the same thing in Python is to just use free functions.\n\nThat's pretty obvious. However, it's good Java style to look as hard as possible for an appropriate class to wedge a function into, so you can avoid writing those pseudo-classes, while doing the same thing is bad Python style—again, use free functions—and this is much less obvious.\n\nC++ doesn't have the same limitation as Java, but many C++ styles are pretty similar anyway. (On the other hand, if you're a \"Modern C++\" programmer who's internalized the \"free functions are part of a class's interface\" idiom, your instincts for \"where are static methods useful\" are probably pretty decent for Python.)\n\nBut if you're coming at this from first principles, rather than from another language, there's a simpler way to look at things:\n\nA is basically just a global function. If you have a function that would be more readable for some reason if it were spelled as , make it a . If not, don't. That's really all there is to it. The only problem is building up your instincts for what's more readable to an idiomatic Python programmer.\n\nAnd of course use a when you need access to the class, but not the instance—alternate constructors are the paradigm case for that, as the docs imply. Although you often can simulate a with a just by explicitly referencing the class (especially when you don't have much subclassing), you shouldn't.\n\nFinally, getting to your specific question:\n\nIf the only reason clients ever need to look up data by ID is to construct an , that sounds like an implementation detail you shouldn't be exposing, and it also makes client code more complex. Just use a constructor. If you don't want to modify your (and you're right that there are good reasons you might not want to), use a as an alternate constructor: .\n\nOn the other hand, if that lookup is something that's inherently useful to clients in other cases that have nothing to do with construction, it seems like this has nothing to do with the class (or at least no more than anything else in the same module). So, just make it a free function."
    },
    {
        "link": "https://realpython.com/instance-class-and-static-methods-demystified",
        "document": "Instance, class, and static methods each serve a distinct role in Python, and knowing when to use one over another is key to writing clean, maintainable code. Instance methods operate on individual objects using , while class methods use to access class-level data. Static methods, on the other hand, provide organizational structure without relying on class or instance state.\n\nWhen you understand the differences between these three method types, you’ll be in a better spot to know when to write an instance method, class method, or a static method. Ultimately, this’ll help you design better maintainable object-oriented Python code.\n\nBy the end of this tutorial, you’ll understand that:\n• Instance methods access the state of a specific object through the parameter.\n• You create class methods with the decorator and use them for operations that involve class-level data.\n• You use static methods for utility functionality that doesn’t need class or instance data, and you create them with the decorator.\n• Using class methods and static methods in your classes can improve class design and code maintainability.\n\nKeep reading to see all three method types in action. You’ll even bake some digital pizza while working on a real-world example with all three method types in a class. If you develop an intuitive understanding for their differences, you’ll be able to write object-oriented Python code that communicates its intent more clearly and is easier to maintain in the long run.\n\nIf you’re here for a quick reminder of how the three method types differ from one another, then consider the following overview that compares them:\n• Instance methods use a parameter pointing to an instance of the class. They can access and modify instance state through and class state through . These are the most common methods in Python classes.\n• Class methods use a parameter pointing to the class itself. They can modify class-level state through , but they can’t modify individual instance state.\n• Static methods don’t take or parameters. They can’t modify instance or class state directly, and you’ll mainly use them for organizational purposes and namespacing. If you need to revisit information quickly, there’s nothing quite like a table. So here are the most important aspects of the three different types of methods in Python classes summed up in a table: Factory methods, alternative constructors, or any method that deals with class-level data. Utility methods that don’t need instance or class data. That’s enough super-condensed, repetitive reference information! If you want to know what all of this means in practice, and you like to learn by running code snippets and reasoning about them, then keep on reading. Next, you’ll explore the differences between instance, class, and static methods in a somewhat abstract code example. Abstract you say? Don’t worry—it involves runnable code, and it’s there to set the stage for a more practical example later on.\n\nGain Insight Through an Abstract Example To get warmed up, you’ll write a small Python file called with a bare-bones Python class that contains stripped-down examples of all three method types: Inside , you create —a descriptively named custom class with the sole purpose of demoing the differences between instance methods, class methods, and static methods. Consequently, you also implement one of each of the three method types and name them accordingly. They each return a tuple containing information to help you trace what’s going on, as well as the arguments the method received, such as and . The output will help you understand which objects each of the methods can access. Note: Naming these parameters and is just a convention—but it’s a strong one in the Python community! You could name them and and get the same result. However, if you stray from the convention, then you may get disapproving looks from your coworkers or anyone reading your code. For functionality, all that matters is that you position them first in the parameter list for the method. For maintainability, sanity, and out of respect for others, you should always use and in the classes you define. Now it’s time to call these demo methods in a new REPL session. Import and create an instance of it, then start by calling the instance method: The output confirms that has access to the object instance through the argument. Python prints the object instance as . When you call the instance method, Python replaces the argument with the instance object, . Instance methods can also access the class itself through the attribute. This makes instance methods powerful in terms of access restrictions. They can modify state on the object instance and on the class itself. Next, you can try out the class method: Calling shows that the method doesn’t have access to the instance object that the instance method had access to. However, it can access the class, which you can see by the output . This output represents the class object itself. Remember that everything in Python is an object, even classes themselves! Notice how Python automatically passes the class as the first argument to the function when you call . Calling a class method in Python through the dot notation triggers this behavior. The parameter on instance methods works in the same way. Now, Python automatically passes the instance as the first argument when you call an instance method on an instance object. You get your information message as output but no additional objects. This confirms that static methods can neither access the object instance state nor the class state. They work like regular functions but belong to the namespace of the class. They also belong to the namespace of each instance. Note: Were you surprised that you can successfully call directly on the instance object? Behind the scenes, Python enforces access restrictions by not passing in or when you call a static method using the dot notation. Now, take a look at what happens when you attempt to call these methods on the class itself without creating an object instance beforehand. To do this properly, you should start a new REPL session to ensure there are no existing instances of the class: You’re able to call and just fine, but attempting to call fails with a . This is to be expected because in this case, you didn’t create an object instance and tried calling an instance method directly on the class itself. Since there’s no way for Python to populate the argument, the call fails. However, you don’t need to call an instance method on the instance object like you did previously. In the end, that’s just syntactic sugar that Python implements to make the call more intuitive. If you want, you can ignore the syntactic sugar of the dot notation syntax and pass the instance object manually to get the same result: In this case, you manually pass the instance to the instance method while calling the instance method on the class object. Doing so produces the same result as calling the instance method on the instance, without explicitly passing . Now that you’ve worked through this bare-bones example and have a better understanding of how the different method types work, you’re ready to look at a more realistic example of when to use each of the three method types.\n\nApply Your Knowledge With a Practical Example The basic example from the previous section shows the distinction between instance methods, class methods, and static methods. However, it’s quite abstract and doesn’t give you a good idea of why and when you might want to use one method type over another. To connect what you learned with the real world, you’ll now explore this topic with a more realistic example. Everyone loves pizza, so it’ll be your delicious and circular gateway to implementing instance methods, class methods, and a static method in the real world. Go ahead and define a basic class in : The class contains the two special methods and . Both of these methods operate on the instance, so you don’t need to add a decorator. It’s common to set up these two special methods for most of your custom Python classes:\n• provides a string representation for when you need to display an object. If you’re not familiar with these two special methods, then you may want to first read more about class constructors and customizing object rerpresentation. But feel free to skip that and keep going with this tutorial. Understanding special methods isn’t crucial to grasp how to distinguish between instance, class, and static methods. The class defines a data attribute called . You can use any iterable containing the pizza toppings when you create an instance of the class. However, the method casts this into a list, as your class definition will assume this attribute is a list. You can explore your new class in a REPL session: Yum! Cheese and tomato pizza. That’s already a good start, but of course there’s a lot more to pizza. You want to customize the toppings on your pizza, so it’s time to add two instance methods that can handle the task. When to Use Instance Methods Instance methods are the most common methods in Python classes. You use them when you want to implement functionality that can access and change the state of an instance. Maybe you’ll have to deal with fussy customers in a pizza restaurant who want to change the toppings on their pizza. So, you’ll go ahead and add two instance methods to your class. As you learned earlier, an instance method is a function that has access to a specific instance of the class. Therefore, an instance method can change the data stored in the object. The Python community uses the parameter name by convention to refer to the instance within an instance method. It’s so common that your integrated development environment (IDE) may automatically fill this parameter for you. Add two instance methods called and to the class: With this edit to , you add two new instance methods that can change the state of a instance—allowing you to add and remove toppings to satisfy your customers’ every taste bud. You can now call these instance methods in a new REPL session to try out their functionality: The data contained within the attribute changes when you call these instance methods. Therefore, a instance contains the data about the toppings and the ability to make changes to the data. This is the key principle of objects in object-oriented programming. So, when should you use instance methods? In short, you should use instance methods when you need to access and edit the data that an instance of your class holds. When to Use Class Methods You use a class method when you need to access or modify class-level data, such as class attributes. Another common use case for is to create factory methods that return class instances with specific configurations. Everyone has their favorite pizza variation, and with the existing code you can already create an endless number of delicious pizza variations: However, the Italians figured out their pizza taxonomy centuries ago, so each delicious type of pizza has its own name. It’s a good idea to take advantage of that rich pizza history and give the users of your class a better interface for creating the types of pizza they crave. A nice, clean way to do that is by using class methods as factory methods for the different kinds of pizza you can create: Note how the and factory methods use the argument instead of calling the constructor directly. This is a trick you can use to follow the Don’t Repeat Yourself (DRY) principle. If you decide to rename this class at some point, you won’t have to remember to update the constructor name in all of the factory methods. Now, what can you do with these factory methods? It’s time to try them out. Since you made changes to , you’ll need a new REPL session: You can use the factory methods to create new objects that are configured the way you want them. They all use the same constructor internally and simply provide a shortcut for remembering the various toppings. Since these methods still create an instance of the class, you can also use other methods on the instances they create, such as : Another way to look at this use of class methods is that they allow you to define alternative constructors for your classes. Python only allows one method per class, but it’s possible to add as many alternative constructors as necessary by using class methods. This can make the interface for your classes self-documenting and simplify their usage. So, when should you use class methods? In short, you should use class methods when you need to access and edit the data that’s tied to your class object rather than an instance of it. You can also use them to create alternative constructors for your class. When to Use Static Methods You can use static methods when you need utility functions that don’t access or modify class or instance data, but where the functionality they provide still logically belongs within the class’s namespace. Let’s stretch the pizza analogy even thinner, and add a static method that allows users to quickly fetch the diameter in inches based on common pizza sizes: \"\"\"Returns the diameter in inches for common pizza sizes.\"\"\" You added a static method that allows you to input a string describing a pizza size. The method then returns the diameter of that size in inches. The static method doesn’t have access to the instance or the class—and it doesn’t need that access. All that the method does is perform a dictionary lookup to return a number. You can call the static method both on a instance and the class itself: That functionality makes sense because the toppings on a pizza won’t influence what size your medium pizza will be—even though you may wish that it did! It’s purely for convenience and organizational purposes that static methods are part of the namespaces of the class and the instance. That convenience can be helpful because as a programmer-turned-pizza-baker, you may still sometimes need to look up how large a specific size of pizza should be. With , you can do that quickly. Static methods can’t access class or instance state because they don’t take a or argument. While this may seem like a limitation, it also clearly signals that the method is independent of everything else in the class. Flagging a method as a static method is a hint that a method won’t modify class or instance state. This restriction is also enforced by the Python runtime. Using enables you to communicate clearly about parts of your class architecture so that new development work is naturally guided to happen within these set boundaries. Note: Of course, it’s possible to defy these restrictions. But in practice, static methods can often help prevent accidental modifications that would go against the original design intent. Static methods also have benefits when it comes to writing test code since they’re completely independent from the rest of the class. You don’t have to worry about setting up a complete class instance before you can test the static method in a unit test. You can just fire away like you would to test a regular function. This can make future maintenance less of an effort. So, when should you use static methods? In short, you should use static methods when you want to tie utility functionality related to your class right into its namespace."
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/18p3vo8/best_practices_for_overloading_in_python",
        "document": "How to override methods based on complex types such as list of strings versus a list of ints?\n\nSometimes we might have the same method, but the method would act differently depending on parameters type.\n\nJust to test it, assume we can have a class that initiates from and integer or a string, and we want to do so explicitly, and raise an error if the argument is of any other type.\n\nWe want an error raised\n\nUp until now I was implementing it with if conditions:\n\nNow, I would like to learn a proper way for overriding a method in python. I tried with . It works beautifully for simple types, but I don't know how to express more complex use cases such as a list of ints versus a list of strings\n\nFollowing input works for the first three usecases, but how can I introduce a new method to process Sequence of strings differently?\n\nI tried but get an error TypeError: Invalid annotation for 'x'. collections.abc.Sequence[str] is not a class.\n\nI found a work around by declaring empty classes, but there must be a better way, right?\n\nAlso, would be happy to hear your opinion of multipledispatch, it worth learning and using?"
    },
    {
        "link": "https://geeksforgeeks.org/operator-overloading-in-python",
        "document": "Operator Overloading means giving extended meaning beyond their predefined operational meaning. For example operator + is used to add two integers as well as join two strings and merge two lists. It is achievable because ‘+’ operator is overloaded by int class and str class. You might have noticed that the same built-in operator or function shows different behavior for objects of different classes, this is called Operator Overloading.\n\nHow to overload the operators in Python?\n\nConsider that we have two objects which are a physical representation of a class (user-defined data type) and we have to add two objects with binary ‘+’ operator it throws an error, because compiler don’t know how to add two objects. So we define a method for an operator and that process is called operator overloading. We can overload all existing operators but we can’t create a new operator. To perform operator overloading, Python provides some special function or magic function that is automatically invoked when it is associated with that particular operator. For example, when we use + operator, the magic method __add__ is automatically invoked in which the operation for + operator is defined.\n\nWhen we use an operator on user-defined data types then automatically a special function or magic function associated with that operator is invoked. Changing the behavior of operator is as simple as changing the behavior of a method or function. You define methods in your class and operators work according to that behavior defined in methods. When we use + operator, the magic method __add__ is automatically invoked in which the operation for + operator is defined. Thereby changing this magic method’s code, we can give extra meaning to the + operator.\n\nHow Does the Operator Overloading Actually work?\n\nWhenever you change the behavior of the existing operator through operator overloading, you have to redefine the special function that is invoked automatically when the operator is used with the objects.\n\nHere, We defined the special function “__add__( )” and when the objects are coded as “ob1 + ob2“, the special function is automatically called as ob1.__add__(ob2) which simply means that ob1 calls the __add__( ) function with ob2 as an Argument and It actually means A .__add__(ob1, ob2). Hence, when the Binary operator is overloaded, the object before the operator calls the respective function with object after operator as parameter.\n\nOverloading equality and less than operators:\n\nNote: It is not possible to change the number of operands of an operator. For example: If we can not overload a unary operator as a binary operator. The following code will throw a syntax error.\n\nIn Python, you can overload the Boolean operators and, or, and not by defining the __and__, __or__, and __not__ special methods in your class.\n\nHere’s an example of how to overload the and operator for a custom class:\n\nIn this example, we define a MyClass that has a single attribute value, which is a boolean. We then overload the & operator by defining the __and__ method to perform a logical and operation on the value attribute of two MyClass instances.\n\nWhen we call a & b, the __and__ method is called with a as the first argument and b as the second argument. The method returns a new instance of MyClass with a value attribute that is the logical and of a.value and b.value.\n\nNote that Python also provides built-in boolean operators that can be used with any object. For example, you can use the bool() function to convert any object to a boolean value, and the all() and any() functions to perform logical and and or operations on a sequence of boolean values. Overloading the boolean operators in a custom class can be useful to provide a more natural syntax and semantics for your class.\n\nOverloading boolean operators in a custom class can provide several advantages, including:\n• None Improved readability: By overloading boolean operators, you can provide a more natural syntax and semantics for your class that makes it easier to read and understand.\n• None Consistency with built-in types: Overloading boolean operators can make your class behave more like built-in types in Python, which can make it easier to use and integrate with other code.\n• None Operator overloading: Overloading boolean operators is an example of operator overloading in Python, which can make your code more concise and expressive by allowing you to use familiar operators to perform custom operations on your objects.\n• None Custom behavior: Overloading boolean operators can allow you to define custom behavior for your class that is not available in built-in types or other classes.\n• None Enhanced functionality: By overloading boolean operators, you can add new functionality to your class that was not available before, such as the ability to perform logical and or or operations on instances of your class.\n\nOverall, overloading boolean operators in a custom class can make your code more readable, consistent, concise, expressive, and functional. However, it’s important to use operator overloading judiciously and only when it makes sense for the semantics of your class.\n\nWhat is the Plus Operator in Python?\n\nWhat is Operator Overloading in Python?\n\nWhat Are the Different Types of Overloading in Python?\n\nWhat Are the 7 Operators in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/73381209/how-do-i-call-an-operator-overload-method-inside-my-static-method",
        "document": "I'm slowly teaching myself Classes in Python and have hit a brick wall. I could desperately use some help.\n\nI have created the base class, Number, and would like to figure out how to do two things:\n• Overload the function of of the class through the child class , and update the object from which it is called\n• Create a static method that calls the overload function in its return statement and serves as a method override of its parent class\n\nI've managed to write the following lines of code:\n\nIf I type the basic operation in the static method's return statement , I don't get an error. But how can I leverage the overload method I already created?\n\nAny support is much appreciated!"
    }
]