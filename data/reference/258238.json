[
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/db/models",
        "document": "A model is the single, definitive source of information about your data. It contains the essential fields and behaviors of the data you’re storing. Generally, each model maps to a single database table.\n• None Each model is a Python class that subclasses .\n• None Each attribute of the model represents a database field.\n• None With all of this, Django gives you an automatically-generated database-access API; see Making queries.\n\nDefine custom methods on a model to add custom “row-level” functionality to your objects. Whereas methods are intended to do “table-wide” things, model methods should act on a particular model instance. This is a valuable technique for keeping business logic in one place – the model. For example, this model has a few custom methods: The last method in this example is a property. The model instance reference has a complete list of methods automatically given to each model. You can override most of these – see overriding predefined model methods, below – but there are a couple that you’ll almost always want to define: A Python “magic method” that returns a string representation of any object. This is what Python and Django will use whenever a model instance needs to be coerced and displayed as a plain string. Most notably, this happens when you display an object in an interactive console or in the admin. You’ll always want to define this method; the default isn’t very helpful at all. This tells Django how to calculate the URL for an object. Django uses this in its admin interface, and any time it needs to figure out a URL for an object. Any object that has a URL that uniquely identifies it should define this method. There’s another set of model methods that encapsulate a bunch of database behavior that you’ll want to customize. In particular you’ll often want to change the way and work. You’re free to override these methods (and any other model method) to alter behavior. A classic use-case for overriding the built-in methods is if you want something to happen whenever you save an object. For example (see for documentation of the parameters it accepts): You can also prevent saving: # Yoko shall never have her own blog! It’s important to remember to call the superclass method – that’s that business – to ensure that the object still gets saved into the database. If you forget to call the superclass method, the default behavior won’t happen and the database won’t get touched. It’s also important that you pass through the arguments that can be passed to the model method – that’s what the bit does. Django will, from time to time, extend the capabilities of built-in model methods, adding new keyword arguments. If you use in your method definitions, you are guaranteed that your code will automatically support those arguments when they are added. If you wish to update a field value in the method, you may also want to have this field added to the keyword argument. This will ensure the field is saved when is specified. For example: See Specifying which fields to save for more details. Overridden model methods are not called on bulk operations Note that the method for an object is not necessarily called when deleting objects in bulk using a QuerySet or as a result of a . To ensure customized delete logic gets executed, you can use and/or signals. Unfortunately, there isn’t a workaround when or objects in bulk, since none of , , and are called. Another common pattern is writing custom SQL statements in model methods and module-level methods. For more details on using raw SQL, see the documentation on using raw SQL.\n\nModel inheritance in Django works almost identically to the way normal class inheritance works in Python, but the basics at the beginning of the page should still be followed. That means the base class should subclass . The only decision you have to make is whether you want the parent models to be models in their own right (with their own database tables), or if the parents are just holders of common information that will only be visible through the child models. There are three styles of inheritance that are possible in Django.\n• None Often, you will just want to use the parent class to hold information that you don’t want to have to type out for each child model. This class isn’t going to ever be used in isolation, so Abstract base classes are what you’re after.\n• None If you’re subclassing an existing model (perhaps something from another application entirely) and want each model to have its own database table, Multi-table inheritance is the way to go.\n• None Finally, if you only want to modify the Python-level behavior of a model, without changing the models fields in any way, you can use Proxy models. Abstract base classes are useful when you want to put some common information into a number of other models. You write your base class and put in the Meta class. This model will then not be used to create any database table. Instead, when it is used as a base class for other models, its fields will be added to those of the child class. The model will have three fields: , and . The model cannot be used as a normal Django model, since it is an abstract base class. It does not generate a database table or have a manager, and cannot be instantiated or saved directly. Fields inherited from abstract base classes can be overridden with another field or value, or be removed with . For many uses, this type of model inheritance will be exactly what you want. It provides a way to factor out common information at the Python level, while still only creating one database table per child model at the database level. When an abstract base class is created, Django makes any Meta inner class you declared in the base class available as an attribute. If a child class does not declare its own Meta class, it will inherit the parent’s Meta. If the child wants to extend the parent’s Meta class, it can subclass it. For example: Django does make one adjustment to the Meta class of an abstract base class: before installing the Meta attribute, it sets . This means that children of abstract base classes don’t automatically become abstract classes themselves. To make an abstract base class that inherits from another abstract base class, you need to explicitly set on the child. Some attributes won’t make sense to include in the Meta class of an abstract base class. For example, including would mean that all the child classes (the ones that don’t specify their own Meta) would use the same database table, which is almost certainly not what you want. Due to the way Python inheritance works, if a child class inherits from multiple abstract base classes, only the Meta options from the first listed class will be inherited by default. To inherit Meta options from multiple abstract base classes, you must explicitly declare the Meta inheritance. For example: Be careful with and ¶ If you are using or on a or , you must always specify a unique reverse name and query name for the field. This would normally cause a problem in abstract base classes, since the fields on this class are included into each of the child classes, with exactly the same values for the attributes (including and ) each time. To work around this problem, when you are using or in an abstract base class (only), part of the value should contain and .\n• None is replaced by the lowercased name of the child class that the field is used in.\n• None is replaced by the lowercased name of the app the child class is contained within. Each installed application name must be unique and the model class names within each app must also be unique, therefore the resulting name will end up being different. For example, given an app : Along with another app : The reverse name of the field will be and the reverse query name will be . The reverse name of the field will be and the reverse query name will be . Finally, the reverse name of the field will be and the reverse query name will be . It’s up to you how you use the and portion to construct your related name or related query name but if you forget to use it, Django will raise errors when you perform system checks (or run ). If you don’t specify a attribute for a field in an abstract base class, the default reverse name will be the name of the child class followed by , just as it normally would be if you’d declared the field directly on the child class. For example, in the above code, if the attribute was omitted, the reverse name for the field would be in the case and for the field. The second type of model inheritance supported by Django is when each model in the hierarchy is a model all by itself. Each model corresponds to its own database table and can be queried and created individually. The inheritance relationship introduces links between the child model and each of its parents (via an automatically-created ). For example: All of the fields of will also be available in , although the data will reside in a different database table. So these are both possible: If you have a that is also a , you can get from the object to the object by using the lowercase version of the model name: # If p is a Restaurant object, this will give the child class: However, if in the above example was not a (it had been created directly as a object or was the parent of some other class), referring to would raise a exception. The automatically-created on that links it to looks like this: You can override that field by declaring your own with on . In the multi-table inheritance situation, it doesn’t make sense for a child class to inherit from its parent’s Meta class. All the Meta options have already been applied to the parent class and applying them again would normally only lead to contradictory behavior (this is in contrast with the abstract base class case, where the base class doesn’t exist in its own right). So a child model does not have access to its parent’s Meta class. However, there are a few limited cases where the child inherits behavior from the parent: if the child does not specify an attribute or a attribute, it will inherit these from its parent. If the parent has an ordering and you don’t want the child to have any natural ordering, you can explicitly disable it: Because multi-table inheritance uses an implicit to link the child and the parent, it’s possible to move from the parent down to the child, as in the above example. However, this uses up the name that is the default value for and relations. If you are putting those types of relations on a subclass of the parent model, you must specify the attribute on each such field. If you forget, Django will raise a validation error. For example, using the above class again, let’s create another subclass with a : This results in the error: Reverse query name for 'Supplier.customers' clashes with reverse query HINT: Add or change a related_name argument to the definition for Adding to the field as follows would resolve the error: . As mentioned, Django will automatically create a linking your child class back to any non-abstract parent models. If you want to control the name of the attribute linking back to the parent, you can create your own and set to indicate that your field is the link back to the parent class. When using multi-table inheritance, a new database table is created for each subclass of a model. This is usually the desired behavior, since the subclass needs a place to store any additional data fields that are not present on the base class. Sometimes, however, you only want to change the Python behavior of a model – perhaps to change the default manager, or add a new method. This is what proxy model inheritance is for: creating a proxy for the original model. You can create, delete and update instances of the proxy model and all the data will be saved as if you were using the original (non-proxied) model. The difference is that you can change things like the default model ordering or the default manager in the proxy, without having to alter the original. Proxy models are declared like normal models. You tell Django that it’s a proxy model by setting the attribute of the class to . For example, suppose you want to add a method to the model. You can do it like this: The class operates on the same database table as its parent class. In particular, any new instances of will also be accessible through , and vice-versa: You could also use a proxy model to define a different default ordering on a model. You might not always want to order the model, but regularly order by the attribute when you use the proxy: Now normal queries will be unordered and queries will be ordered by . Proxy models inherit attributes in the same way as regular models. s still return the model that was requested¶ There is no way to have Django return, say, a object whenever you query for objects. A queryset for objects will return those types of objects. The whole point of proxy objects is that code relying on the original will use those and your own code can use the extensions you included (that no other code is relying on anyway). It is not a way to replace the (or any other) model everywhere with something of your own creation. A proxy model must inherit from exactly one non-abstract model class. You can’t inherit from multiple non-abstract models as the proxy model doesn’t provide any connection between the rows in the different database tables. A proxy model can inherit from any number of abstract model classes, providing they do not define any model fields. A proxy model may also inherit from any number of proxy models that share a common non-abstract parent class. If you don’t specify any model managers on a proxy model, it inherits the managers from its model parents. If you define a manager on the proxy model, it will become the default, although any managers defined on the parent classes will still be available. Continuing our example from above, you could change the default manager used when you query the model like this: If you wanted to add a new manager to the Proxy, without replacing the existing default, you can use the techniques described in the custom manager documentation: create a base class containing the new managers and inherit that after the primary base class: # Create an abstract class for the new manager. You probably won’t need to do this very often, but, when you do, it’s possible. Proxy model inheritance might look fairly similar to creating an unmanaged model, using the attribute on a model’s class. With careful setting of you could create an unmanaged model that shadows an existing model and adds Python methods to it. However, that would be very repetitive and fragile as you need to keep both copies synchronized if you make any changes. On the other hand, proxy models are intended to behave exactly like the model they are proxying for. They are always in sync with the parent model since they directly inherit its fields and managers.\n• None If you are mirroring an existing model or database table and don’t want all the original database table columns, use . That option is normally useful for modeling database views and tables not under the control of Django.\n• None If you are wanting to change the Python-only behavior of a model, but keep all the same fields as in the original, use . This sets things up so that the proxy model is an exact copy of the storage structure of the original model when data is saved. Just as with Python’s subclassing, it’s possible for a Django model to inherit from multiple parent models. Keep in mind that normal Python name resolution rules apply. The first base class that a particular name (e.g. Meta) appears in will be the one that is used; for example, this means that if multiple parents contain a Meta class, only the first one is going to be used, and all others will be ignored. Generally, you won’t need to inherit from multiple parents. The main use-case where this is useful is for “mix-in” classes: adding a particular extra field or method to every class that inherits the mix-in. Try to keep your inheritance hierarchies as simple and straightforward as possible so that you won’t have to struggle to work out where a particular piece of information is coming from. Note that inheriting from multiple models that have a common primary key field will raise an error. To properly use multiple inheritance, you can use an explicit in the base models: Or use a common ancestor to hold the . This requires using an explicit from each parent model to the common ancestor to avoid a clash between the fields that are automatically generated and inherited by the child: Field name “hiding” is not permitted¶ In normal Python class inheritance, it is permissible for a child class to override any attribute from the parent class. In Django, this isn’t usually permitted for model fields. If a non-abstract model base class has a field called , you can’t create another model field or define an attribute called in any class that inherits from that base class. This restriction doesn’t apply to model fields inherited from an abstract model. Such fields may be overridden with another field or value, or be removed by setting . Model managers are inherited from abstract base classes. Overriding an inherited field which is referenced by an inherited may cause subtle bugs. See custom managers and model inheritance. Some fields define extra attributes on the model, e.g. a defines an extra attribute with appended to the field name, as well as and on the foreign model. These extra attributes cannot be overridden unless the field that defines it is changed or removed so that it no longer defines the extra attribute. Overriding fields in a parent model leads to difficulties in areas such as initializing new instances (specifying which field is being initialized in ) and serialization. These are features which normal Python class inheritance doesn’t have to deal with in quite the same way, so the difference between Django model inheritance and Python class inheritance isn’t arbitrary. This restriction only applies to attributes which are instances. Normal Python attributes can be overridden if you wish. It also only applies to the name of the attribute as Python sees it: if you are manually specifying the database column name, you can have the same column name appearing in both a child and an ancestor model for multi-table inheritance (they are columns in two different database tables). Django will raise a if you override any model field in any ancestor model. Note that because of the way fields are resolved during class definition, model fields inherited from multiple abstract parent models are resolved in a strict depth-first order. This contrasts with standard Python MRO, which is resolved breadth-first in cases of diamond shaped inheritance. This difference only affects complex model hierarchies, which (as per the advice above) you should try to avoid."
    },
    {
        "link": "https://stackoverflow.com/questions/50525301/django-inheritance-and-polymorphism-with-proxy-models",
        "document": "I'm working on a Django project that I did not start and I am facing a problem of inheritance.\n\n I have a big model (simplified in the example) called that is supposed to represents different kind of items.\n\nAll the instance objects of should have the same fields but the methods behaviours varies a lot depending on the item type.\n\nUp to this moment this has been designed using a single field called .\n\n Then methods defined in MyModel check for this field and perform different logic using multiple if:\n\nEven more, some of the sub-types have many things in common, so let's say the subtypes and represents a 1st level of inheritance. Then these types have sub-types being for example , , , (better explained in the example code below).\n\nI would say that's not the best approach to perform polymorphism.\n\nNow I want to change these models to use real inheritance.\n\nSince all submodels have the same fields I think multi-table inheritance is not necessary. I was thinking to use proxy models because only their behaviour should change depending on their types.\n\nThis a pseudo-solution I came up to:\n\nThis might work if we already know the type of the object we are working on.\n\n Let's say we want to instantiate a MyModel object of type C1 then we could simply instantiate a and the item_type would be set up correctly.\n\nThe problem is how to get the correct proxy model from the generic MyModel instances?\n\nThe most common case is when we get a queryset result: , all these objects are instances of MyModel and they don't know anything about the proxies.\n\nI've seen around different solution like django-polymorphic but as I've understood that relies on multi-table inheritance, isn't it?\n\nSeveral SO answers and custom solutions I've seen:\n• Creating instances of Django proxy models from their base class\n\nbut none of them convinced me 100%..\n\nConsidering this might be a common scenario did anyone came up with a better solution?"
    },
    {
        "link": "https://stackoverflow.com/questions/52794656/django-proxy-model-parent-class-accessing-sub-class-methods",
        "document": "I am trying to wrap my head around how proxy model works. Supposed I have a base class called Animal, and I would like to implement two sub-classes: Dog and Cow. They have the same data requirements, so I don't really want to create two separate tables. So I am trying using proxy models:\n\nThe problem I have is, how can I access the sub-class methods from the parent class? I have it as . This is possible in multi-table inheritance, but does not work in a proxy model.\n\nIs proxy model the wrong way to do this? Would prefer to keep one table."
    },
    {
        "link": "https://foysalff.medium.com/understanding-django-model-inheritance-b0c38588ebb4",
        "document": "When building web applications with Django, a powerful feature you can use is model inheritance. This feature allows you to create models that share common fields and behaviors, making your code more organized and easier to manage.\n\nIn this blog post, we’ll explore the basics of Django model inheritance and look at three types: abstract base classes, multi-table inheritance, and proxy models. We’ll keep things simple, so you can quickly grasp the concepts and start using them in your Django projects.\n\nModel inheritance in Django lets you create a base model that other models can inherit from. This is useful when you have several models that share the same fields or logic. Instead of repeating code in each model, you can write it once in a base model and have other models inherit it.\n\nDjango provides three types of model inheritance:\n\nLet’s dive into each one.\n\nAn abstract base class is a model that is not meant to be used directly to create database tables. Instead, it provides common fields or methods that other models can inherit.\n\nIn this example, both Student and Teacher models inherit the name and created_at fields from the CommonInfo abstract base class. This means that Student and Teacher models will have these fields without having to define them again.\n\nWith multi-table inheritance, each model in the inheritance chain creates its own table in the database. This is useful when you want to extend a model with additional fields but still need to keep the original table.\n\nHere, Person has its own table, and Employee has its own table that links back to the Person table. The Employee model extends Person by adding the job_title field.\n\nProxy models do not create new tables. Instead, they allow you to change the behavior of an existing model without altering the model’s fields.\n\nIn this example, PersonProxy is a proxy model that inherits from Person. It changes the default ordering of Person objects and adds a new method, get_uppercase_name, without changing the Person model itself.\n\nWhen to Use Model Inheritance?\n• Abstract Base Classes: Use when you want to share common fields or methods across multiple models, and you don’t need a separate database table for the base class.\n• Multi-Table Inheritance: Use when you need to extend a model with additional fields and keep separate tables for each model in the inheritance chain.\n• Proxy Models: Use when you want to modify the behavior of an existing model without changing its fields or database structure.\n\nModel inheritance in Django is a powerful tool that can help you write cleaner, more maintainable code. By understanding abstract base classes, multi-table inheritance, and proxy models, you can choose the right type of inheritance for your project and simplify your model definitions."
    },
    {
        "link": "https://forum.djangoproject.com/t/forward-signals-from-proxy-models-to-their-concrete-models/29371",
        "document": "# Trac ticket 9318 ticket-[[9318](https://code.djangoproject.com/ticket/931…8)] # Branch description Forwarded model signals - `[pre|post]_init`, `[pre|post]_save`, `[pre|post]_delete` from proxy models to their concrete models. For the `m2m_changed` signal, the sender in the m2m relation is the same whether we start from the proxy model (`ProxyModel.m2m_field.through`) or the concrete model (`ConcreteModel.m2m_field.through`). # Checklist - [x] This PR targets the `main` branch. - [x] The commit message is written in past tense, mentions the ticket number, and ends with a period. - [x] I have checked the \"Has patch\" **ticket flag** in the Trac system. - [ ] I have added or updated relevant **tests**. - [ ] I have added or updated relevant **docs**, including release notes if applicable."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/topics/db/models",
        "document": "A model is the single, definitive source of information about your data. It contains the essential fields and behaviors of the data you’re storing. Generally, each model maps to a single database table.\n• None Each model is a Python class that subclasses .\n• None Each attribute of the model represents a database field.\n• None With all of this, Django gives you an automatically-generated database-access API; see Making queries.\n\nDefine custom methods on a model to add custom “row-level” functionality to your objects. Whereas methods are intended to do “table-wide” things, model methods should act on a particular model instance. This is a valuable technique for keeping business logic in one place – the model. For example, this model has a few custom methods: The last method in this example is a property. The model instance reference has a complete list of methods automatically given to each model. You can override most of these – see overriding predefined model methods, below – but there are a couple that you’ll almost always want to define: A Python “magic method” that returns a string representation of any object. This is what Python and Django will use whenever a model instance needs to be coerced and displayed as a plain string. Most notably, this happens when you display an object in an interactive console or in the admin. You’ll always want to define this method; the default isn’t very helpful at all. This tells Django how to calculate the URL for an object. Django uses this in its admin interface, and any time it needs to figure out a URL for an object. Any object that has a URL that uniquely identifies it should define this method. There’s another set of model methods that encapsulate a bunch of database behavior that you’ll want to customize. In particular you’ll often want to change the way and work. You’re free to override these methods (and any other model method) to alter behavior. A classic use-case for overriding the built-in methods is if you want something to happen whenever you save an object. For example (see for documentation of the parameters it accepts): You can also prevent saving: # Yoko shall never have her own blog! It’s important to remember to call the superclass method – that’s that business – to ensure that the object still gets saved into the database. If you forget to call the superclass method, the default behavior won’t happen and the database won’t get touched. It’s also important that you pass through the arguments that can be passed to the model method – that’s what the bit does. Django will, from time to time, extend the capabilities of built-in model methods, adding new keyword arguments. If you use in your method definitions, you are guaranteed that your code will automatically support those arguments when they are added. If you wish to update a field value in the method, you may also want to have this field added to the keyword argument. This will ensure the field is saved when is specified. For example: See Specifying which fields to save for more details. Overridden model methods are not called on bulk operations Note that the method for an object is not necessarily called when deleting objects in bulk using a QuerySet or as a result of a . To ensure customized delete logic gets executed, you can use and/or signals. Unfortunately, there isn’t a workaround when or objects in bulk, since none of , , and are called. Another common pattern is writing custom SQL statements in model methods and module-level methods. For more details on using raw SQL, see the documentation on using raw SQL.\n\nModel inheritance in Django works almost identically to the way normal class inheritance works in Python, but the basics at the beginning of the page should still be followed. That means the base class should subclass . The only decision you have to make is whether you want the parent models to be models in their own right (with their own database tables), or if the parents are just holders of common information that will only be visible through the child models. There are three styles of inheritance that are possible in Django.\n• None Often, you will just want to use the parent class to hold information that you don’t want to have to type out for each child model. This class isn’t going to ever be used in isolation, so Abstract base classes are what you’re after.\n• None If you’re subclassing an existing model (perhaps something from another application entirely) and want each model to have its own database table, Multi-table inheritance is the way to go.\n• None Finally, if you only want to modify the Python-level behavior of a model, without changing the models fields in any way, you can use Proxy models. Abstract base classes are useful when you want to put some common information into a number of other models. You write your base class and put in the Meta class. This model will then not be used to create any database table. Instead, when it is used as a base class for other models, its fields will be added to those of the child class. The model will have three fields: , and . The model cannot be used as a normal Django model, since it is an abstract base class. It does not generate a database table or have a manager, and cannot be instantiated or saved directly. Fields inherited from abstract base classes can be overridden with another field or value, or be removed with . For many uses, this type of model inheritance will be exactly what you want. It provides a way to factor out common information at the Python level, while still only creating one database table per child model at the database level. When an abstract base class is created, Django makes any Meta inner class you declared in the base class available as an attribute. If a child class does not declare its own Meta class, it will inherit the parent’s Meta. If the child wants to extend the parent’s Meta class, it can subclass it. For example: Django does make one adjustment to the Meta class of an abstract base class: before installing the Meta attribute, it sets . This means that children of abstract base classes don’t automatically become abstract classes themselves. To make an abstract base class that inherits from another abstract base class, you need to explicitly set on the child. Some attributes won’t make sense to include in the Meta class of an abstract base class. For example, including would mean that all the child classes (the ones that don’t specify their own Meta) would use the same database table, which is almost certainly not what you want. Due to the way Python inheritance works, if a child class inherits from multiple abstract base classes, only the Meta options from the first listed class will be inherited by default. To inherit Meta options from multiple abstract base classes, you must explicitly declare the Meta inheritance. For example: Be careful with and ¶ If you are using or on a or , you must always specify a unique reverse name and query name for the field. This would normally cause a problem in abstract base classes, since the fields on this class are included into each of the child classes, with exactly the same values for the attributes (including and ) each time. To work around this problem, when you are using or in an abstract base class (only), part of the value should contain and .\n• None is replaced by the lowercased name of the child class that the field is used in.\n• None is replaced by the lowercased name of the app the child class is contained within. Each installed application name must be unique and the model class names within each app must also be unique, therefore the resulting name will end up being different. For example, given an app : Along with another app : The reverse name of the field will be and the reverse query name will be . The reverse name of the field will be and the reverse query name will be . Finally, the reverse name of the field will be and the reverse query name will be . It’s up to you how you use the and portion to construct your related name or related query name but if you forget to use it, Django will raise errors when you perform system checks (or run ). If you don’t specify a attribute for a field in an abstract base class, the default reverse name will be the name of the child class followed by , just as it normally would be if you’d declared the field directly on the child class. For example, in the above code, if the attribute was omitted, the reverse name for the field would be in the case and for the field. The second type of model inheritance supported by Django is when each model in the hierarchy is a model all by itself. Each model corresponds to its own database table and can be queried and created individually. The inheritance relationship introduces links between the child model and each of its parents (via an automatically-created ). For example: All of the fields of will also be available in , although the data will reside in a different database table. So these are both possible: If you have a that is also a , you can get from the object to the object by using the lowercase version of the model name: # If p is a Restaurant object, this will give the child class: However, if in the above example was not a (it had been created directly as a object or was the parent of some other class), referring to would raise a exception. The automatically-created on that links it to looks like this: You can override that field by declaring your own with on . In the multi-table inheritance situation, it doesn’t make sense for a child class to inherit from its parent’s Meta class. All the Meta options have already been applied to the parent class and applying them again would normally only lead to contradictory behavior (this is in contrast with the abstract base class case, where the base class doesn’t exist in its own right). So a child model does not have access to its parent’s Meta class. However, there are a few limited cases where the child inherits behavior from the parent: if the child does not specify an attribute or a attribute, it will inherit these from its parent. If the parent has an ordering and you don’t want the child to have any natural ordering, you can explicitly disable it: Because multi-table inheritance uses an implicit to link the child and the parent, it’s possible to move from the parent down to the child, as in the above example. However, this uses up the name that is the default value for and relations. If you are putting those types of relations on a subclass of the parent model, you must specify the attribute on each such field. If you forget, Django will raise a validation error. For example, using the above class again, let’s create another subclass with a : This results in the error: Reverse query name for 'Supplier.customers' clashes with reverse query HINT: Add or change a related_name argument to the definition for Adding to the field as follows would resolve the error: . As mentioned, Django will automatically create a linking your child class back to any non-abstract parent models. If you want to control the name of the attribute linking back to the parent, you can create your own and set to indicate that your field is the link back to the parent class. When using multi-table inheritance, a new database table is created for each subclass of a model. This is usually the desired behavior, since the subclass needs a place to store any additional data fields that are not present on the base class. Sometimes, however, you only want to change the Python behavior of a model – perhaps to change the default manager, or add a new method. This is what proxy model inheritance is for: creating a proxy for the original model. You can create, delete and update instances of the proxy model and all the data will be saved as if you were using the original (non-proxied) model. The difference is that you can change things like the default model ordering or the default manager in the proxy, without having to alter the original. Proxy models are declared like normal models. You tell Django that it’s a proxy model by setting the attribute of the class to . For example, suppose you want to add a method to the model. You can do it like this: The class operates on the same database table as its parent class. In particular, any new instances of will also be accessible through , and vice-versa: You could also use a proxy model to define a different default ordering on a model. You might not always want to order the model, but regularly order by the attribute when you use the proxy: Now normal queries will be unordered and queries will be ordered by . Proxy models inherit attributes in the same way as regular models. s still return the model that was requested¶ There is no way to have Django return, say, a object whenever you query for objects. A queryset for objects will return those types of objects. The whole point of proxy objects is that code relying on the original will use those and your own code can use the extensions you included (that no other code is relying on anyway). It is not a way to replace the (or any other) model everywhere with something of your own creation. A proxy model must inherit from exactly one non-abstract model class. You can’t inherit from multiple non-abstract models as the proxy model doesn’t provide any connection between the rows in the different database tables. A proxy model can inherit from any number of abstract model classes, providing they do not define any model fields. A proxy model may also inherit from any number of proxy models that share a common non-abstract parent class. If you don’t specify any model managers on a proxy model, it inherits the managers from its model parents. If you define a manager on the proxy model, it will become the default, although any managers defined on the parent classes will still be available. Continuing our example from above, you could change the default manager used when you query the model like this: If you wanted to add a new manager to the Proxy, without replacing the existing default, you can use the techniques described in the custom manager documentation: create a base class containing the new managers and inherit that after the primary base class: # Create an abstract class for the new manager. You probably won’t need to do this very often, but, when you do, it’s possible. Proxy model inheritance might look fairly similar to creating an unmanaged model, using the attribute on a model’s class. With careful setting of you could create an unmanaged model that shadows an existing model and adds Python methods to it. However, that would be very repetitive and fragile as you need to keep both copies synchronized if you make any changes. On the other hand, proxy models are intended to behave exactly like the model they are proxying for. They are always in sync with the parent model since they directly inherit its fields and managers.\n• None If you are mirroring an existing model or database table and don’t want all the original database table columns, use . That option is normally useful for modeling database views and tables not under the control of Django.\n• None If you are wanting to change the Python-only behavior of a model, but keep all the same fields as in the original, use . This sets things up so that the proxy model is an exact copy of the storage structure of the original model when data is saved. Just as with Python’s subclassing, it’s possible for a Django model to inherit from multiple parent models. Keep in mind that normal Python name resolution rules apply. The first base class that a particular name (e.g. Meta) appears in will be the one that is used; for example, this means that if multiple parents contain a Meta class, only the first one is going to be used, and all others will be ignored. Generally, you won’t need to inherit from multiple parents. The main use-case where this is useful is for “mix-in” classes: adding a particular extra field or method to every class that inherits the mix-in. Try to keep your inheritance hierarchies as simple and straightforward as possible so that you won’t have to struggle to work out where a particular piece of information is coming from. Note that inheriting from multiple models that have a common primary key field will raise an error. To properly use multiple inheritance, you can use an explicit in the base models: Or use a common ancestor to hold the . This requires using an explicit from each parent model to the common ancestor to avoid a clash between the fields that are automatically generated and inherited by the child: Field name “hiding” is not permitted¶ In normal Python class inheritance, it is permissible for a child class to override any attribute from the parent class. In Django, this isn’t usually permitted for model fields. If a non-abstract model base class has a field called , you can’t create another model field or define an attribute called in any class that inherits from that base class. This restriction doesn’t apply to model fields inherited from an abstract model. Such fields may be overridden with another field or value, or be removed by setting . Model managers are inherited from abstract base classes. Overriding an inherited field which is referenced by an inherited may cause subtle bugs. See custom managers and model inheritance. Some fields define extra attributes on the model, e.g. a defines an extra attribute with appended to the field name, as well as and on the foreign model. These extra attributes cannot be overridden unless the field that defines it is changed or removed so that it no longer defines the extra attribute. Overriding fields in a parent model leads to difficulties in areas such as initializing new instances (specifying which field is being initialized in ) and serialization. These are features which normal Python class inheritance doesn’t have to deal with in quite the same way, so the difference between Django model inheritance and Python class inheritance isn’t arbitrary. This restriction only applies to attributes which are instances. Normal Python attributes can be overridden if you wish. It also only applies to the name of the attribute as Python sees it: if you are manually specifying the database column name, you can have the same column name appearing in both a child and an ancestor model for multi-table inheritance (they are columns in two different database tables). Django will raise a if you override any model field in any ancestor model. Note that because of the way fields are resolved during class definition, model fields inherited from multiple abstract parent models are resolved in a strict depth-first order. This contrasts with standard Python MRO, which is resolved breadth-first in cases of diamond shaped inheritance. This difference only affects complex model hierarchies, which (as per the advice above) you should try to avoid."
    },
    {
        "link": "https://stackoverflow.com/questions/57244725/diango-model-property-to-return-list-of-objects-of-other-model",
        "document": "I have 2 models like this:\n\nNow, I need to make a property in Company model which could return a list of all Product Objects, like\n\nWhen I mention products (property) in CompanySerializer fields, it give me an error that it cannot return a list of objects.\n\nCan anyone solve my problem and tell me what is wrong with the code?"
    },
    {
        "link": "https://stackoverflow.com/questions/61831210/django-best-practice-to-show-other-related-models-in-a-view",
        "document": "I'm trying to loop over a related model and show other properties in that model, which includes other relationships, but am having trouble showing that in a view. Any tips would be much appreciated.\n\nThis is a simplification of the actual dataset but hopefully there's enough there. Let me know if you have any questions. Thanks much in advance.\n\nAfter many tweaks and trying out Deniz Kaplan's suggestions, I managed to get it to work. The only adjustment I made was:\n\nHere's a slight modification to try to be more efficient:\n\nIn case this seems confusing to anyone, the lowercase represents the relationship between Model1 and Model3, aka ."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Django/Models",
        "document": "Before you jump in and start coding the models, it's worth taking a few minutes to think about what data we need to store and the relationships between the different objects. We know that we need to store information about books (title, summary, author, written language, category, ISBN) and that we might have multiple copies available (with globally unique id, availability status, etc.). We might need to store more information about the author than just their name, and there might be multiple authors with the same or similar names. We want to be able to sort information based on book title, author, written language, and category. When designing your models, it makes sense to have separate models for every \"object\" (a group of related information). In this case, the obvious objects are books, book instances, and authors. You might also want to use models to represent selection-list options (e.g. like a drop down list of choices), rather than hard coding the choices into the website itself — this is recommended when all the options aren't known up front or may change. Obvious candidates for models, in this case, include the book genre (e.g. Science Fiction, French Poetry, etc.) and language (English, French, Japanese). Once we've decided on our models and field, we need to think about the relationships. Django allows you to define relationships that are one to one ( ), one to many ( ) and many to many ( ). With that in mind, the UML association diagram below shows the models we'll define in this case (as boxes). We've created models for the book (the generic details of the book), book instance (status of specific physical copies of the book available in the system), and author. We have also decided to have a model for the genre so that values can be created/selected through the admin interface. We've decided not to have a model for the — we've hardcoded the values ( ) because we don't expect these to change. Within each of the boxes, you can see the model name, the field names, and types, and also the methods and their return types. The diagram also shows the relationships between the models, including their multiplicities. The multiplicities are the numbers on the diagram showing the numbers (maximum and minimum) of each model that may be present in the relationship. For example, the connecting line between the boxes shows that Book and a Genre are related. The numbers close to the Genre model show that a book must have one or more Genres (as many as you like), while the numbers on the other end of the line next to the Book model show that a Genre can have zero or many associated books. Note: The next section provides a basic primer explaining how models are defined and used. As you read it, consider how we will construct each of the models in the diagram above.\n\nModels are usually defined in an application's models.py file. They are implemented as subclasses of , and can include fields, methods and metadata. The code fragment below shows a \"typical\" model, named : from django.db import models from django.urls import reverse class MyModelName(models.Model): \"\"\"A typical class defining a model, derived from the Model class.\"\"\" # Fields my_field_name = models.CharField(max_length=20, help_text='Enter field documentation') # … # Metadata class Meta: ordering = ['-my_field_name'] # Methods def get_absolute_url(self): \"\"\"Returns the URL to access a particular instance of MyModelName.\"\"\" return reverse('model-detail-view', args=[str(self.id)]) def __str__(self): \"\"\"String for representing the MyModelName object (in Admin site etc.).\"\"\" return self.my_field_name In the below sections we'll explore each of the features inside the model in detail: A model can have an arbitrary number of fields, of any type — each one represents a column of data that we want to store in one of our database tables. Each database record (row) will consist of one of each field value. Let's look at the example seen below: Our above example has a single field called , of type — which means that this field will contain strings of alphanumeric characters. The field types are assigned using specific classes, which determine the type of record that is used to store the data in the database, along with validation criteria to be used when values are received from an HTML form (i.e. what constitutes a valid value). The field types can also take arguments that further specify how the field is stored or can be used. In this case we are giving our field two arguments:\n• — States that the maximum length of a value in this field is 20 characters.\n• — helpful text that may be displayed in a form to help users understand how the field is used. The field name is used to refer to it in queries and templates. Fields also have a label, which is specified using the argument (with a default value of ). If is not set, the label is created from the field name by replacing any underscores with a space, and capitalizing the first letter (for example, the field would have a default label of My field name when used in forms). The order that fields are declared will affect their default order if a model is rendered in a form (e.g. in the Admin site), though this may be overridden. The following common arguments can be used when declaring many/most of the different field types:\n• help_text: Provides a text label for HTML forms (e.g. in the admin site), as described above.\n• verbose_name: A human-readable name for the field used in field labels. If not specified, Django will infer the default verbose name from the field name.\n• default: The default value for the field. This can be a value or a callable object, in which case the object will be called every time a new record is created.\n• null: If , Django will store blank values as in the database for fields where this is appropriate (a will instead store an empty string). The default is .\n• blank: If , the field is allowed to be blank in your forms. The default is , which means that Django's form validation will force you to enter a value. This is often used with , because if you're going to allow blank values, you also want the database to be able to represent them appropriately.\n• choices: A group of choices for this field. If this is provided, the default corresponding form widget will be a select box with these choices instead of the standard text field.\n• unique: If , ensures that the field value is unique across the database. This can be used to prevent duplication of fields that can't have the same values. The default is .\n• primary_key: If , sets the current field as the primary key for the model (A primary key is a special database column designated to uniquely identify all the different table records). If no field is specified as the primary key, Django will automatically add a field for this purpose. The type of auto-created primary key fields can be specified for each app in or globally in the setting. Note: Apps created using manage.py set the type of the primary key to a BigAutoField. You can see this in the local library catalog/apps.py file: There are many other options — you can view the full list of field options here. The following list describes some of the more commonly used types of fields.\n• CharField is used to define short-to-mid sized fixed-length strings. You must specify the of the data to be stored.\n• TextField is used for large arbitrary-length strings. You may specify a for the field, but this is used only when the field is displayed in forms (it is not enforced at the database level).\n• IntegerField is a field for storing integer (whole number) values, and for validating entered values as integers in forms.\n• DateField and DateTimeField are used for storing/representing dates and date/time information (as Python and objects, respectively). These fields can additionally declare the (mutually exclusive) parameters (to set the field to the current date every time the model is saved), (to only set the date when the model is first created), and (to set a default date that can be overridden by the user).\n• EmailField is used to store and validate email addresses.\n• FileField and ImageField are used to upload files and images respectively (the adds additional validation that the uploaded file is an image). These have parameters to define how and where the uploaded files are stored.\n• AutoField is a special type of that automatically increments. A primary key of this type is automatically added to your model if you don't explicitly specify one.\n• ForeignKey is used to specify a one-to-many relationship to another database model (e.g. a car has one manufacturer, but a manufacturer can make many cars). The \"one\" side of the relationship is the model that contains the \"key\" (models containing a \"foreign key\" referring to that \"key\", are on the \"many\" side of such a relationship).\n• ManyToManyField is used to specify a many-to-many relationship (e.g. a book can have several genres, and each genre can contain several books). In our library app we will use these very similarly to , but they can be used in more complicated ways to describe the relationships between groups. These have the parameter to define what happens when the associated record is deleted (e.g. a value of would set the value to ). There are many other types of fields, including fields for different types of numbers (big integers, small integers, floats), booleans, URLs, slugs, unique ids, and other \"time-related\" information (duration, time, etc.). You can view the full list here. You can declare model-level metadata for your Model by declaring , as shown. One of the most useful features of this metadata is to control the default ordering of records returned when you query the model type. You do this by specifying the match order in a list of field names to the attribute, as shown above. The ordering will depend on the type of field (character fields are sorted alphabetically, while date fields are sorted in chronological order). As shown above, you can prefix the field name with a minus symbol (-) to reverse the sorting order. So as an example, if we chose to sort books like this by default: the books would be sorted alphabetically by title, from A-Z, and then by publication date inside each title, from newest to oldest. Another common attribute is , a verbose name for the class in singular and plural form: Class metadata can be used to create and apply new \"access permissions\" for the model (default permissions are applied automatically), allow ordering based on another field, define constraints on possible values of data that can be stored, or to declare that the class is \"abstract\" (a base class that you cannot create records for, and will instead be derived from to create other models). Many of the other metadata options control what database must be used for the model and how the data is stored (these are really only useful if you need to map a model to an existing database). The full list of metadata options are available here: Model metadata options (Django docs). A model can also have methods. Minimally, in every model you should define the standard Python class method to return a human-readable string for each object. This string is used to represent individual records in the administration site (and anywhere else you need to refer to a model instance). Often this will return a title or name field from the model. Another common method to include in Django models is , which returns a URL for displaying individual model records on the website (if you define this method then Django will automatically add a \"View on Site\" button to the model's record editing screens in the Admin site). A typical pattern for is shown below. def get_absolute_url(self): \"\"\"Returns the URL to access a particular instance of the model.\"\"\" return reverse('model-detail-view', args=[str(self.id)]) Note: Assuming you will use URLs like to display individual records for your model (where \"2\" is the for a particular record), you will need to create a URL mapper to pass the response and id to a \"model detail view\" (which will do the work required to display the record). The function above is able to \"reverse\" your URL mapper (in the above case named 'model-detail-view') in order to create a URL of the right format. Of course to make this work you still have to write the URL mapping, view, and template! You can also define any other methods you like, and call them from your code or templates (provided that they don't take any parameters).\n\nOnce you've defined your model classes you can use them to create, update, or delete records, and to run queries to get all records or particular subsets of records. We'll show you how to do that in the tutorial when we define our views, but here is a brief summary. To create a record you can define an instance of the model and then call . # Create a new record using the model's constructor. record = MyModelName(my_field_name=\"Instance #1\") # Save the object into the database. record.save() Note: If you haven't declared any field as a , the new record will be given one automatically, with the field name . You could query this field after saving the above record, and it would have a value of 1. You can access the fields in this new record using the dot syntax, and change the values. You have to call to store modified values to the database. # Access model field values using Python attributes. print(record.id) # should return 1 for the first record. print(record.my_field_name) # should print 'Instance #1' # Change record by modifying the fields, then calling save(). record.my_field_name = \"New Instance Name\" record.save() You can search for records that match certain criteria using the model's attribute (provided by the base class). Note: Explaining how to search for records using \"abstract\" model and field names can be a little confusing. In the discussion below, we'll refer to a model with and fields, where genre is also a model with a single field . We can get all records for a model as a , using . The is an iterable object, meaning that it contains a number of objects that we can iterate/loop through. Django's method allows us to filter the returned to match a specified text or numeric field against particular criteria. For example, to filter for books that contain \"wild\" in the title and then count them, we could do the following: The fields to match and the type of match are defined in the filter parameter name, using the format: (note the double underscore between and above). Above we're filtering with a case-sensitive match. There are many other types of matches you can do: (case insensitive), (case-insensitive exact match), (case-sensitive exact match) and , (greater than), , etc. The full list is here. In some cases, you'll need to filter on a field that defines a one-to-many relationship to another model (e.g. a ). In this case, you can \"index\" to fields within the related model with additional double underscores. So for example to filter for books with a specific genre pattern, you will have to index to the through the field, as shown below: # Will match on: Fiction, Science fiction, non-fiction etc. books_containing_genre = Book.objects.filter(genre__name__icontains='fiction') Note: You can use underscores ( ) to navigate as many levels of relationships ( / ) as you like. For example, a that had different types, defined using a further \"cover\" relationship might have a parameter name: There is a lot more you can do with queries, including backwards searches from related models, chaining filters, returning a smaller set of values, etc. For more information, see Making queries (Django Docs).\n\nCopy the model code shown below and paste it into the bottom of your file. This model is used to store information about the book category — for example whether it is fiction or non-fiction, romance or military history, etc. As mentioned above, we've created the genre as a model rather than as free text or a selection list so that the possible values can be managed through the database rather than being hard coded. from django.urls import reverse # Used in get_absolute_url() to get URL for specified ID from django.db.models import UniqueConstraint # Constrains fields to unique values from django.db.models.functions import Lower # Returns lower cased value of field class Genre(models.Model): \"\"\"Model representing a book genre.\"\"\" name = models.CharField( max_length=200, unique=True, help_text=\"Enter a book genre (e.g. Science Fiction, French Poetry etc.)\" ) def __str__(self): \"\"\"String for representing the Model object.\"\"\" return self.name def get_absolute_url(self): \"\"\"Returns the url to access a particular genre instance.\"\"\" return reverse('genre-detail', args=[str(self.id)]) class Meta: constraints = [ UniqueConstraint( Lower('name'), name='genre_name_case_insensitive_unique', violation_error_message = \"Genre already exists (case insensitive match)\" ), ] The model has a single field ( ), which is used to describe the genre (this is limited to 200 characters and has some ). We've set this field to be unique ( ) because there should only be one record for each genre. After the field, we declare a method, which returns the name of the genre defined by a particular record. No verbose name has been defined, so the field label will be when it is used in forms. Then we declare the method, which returns a URL that can be used to access a detail record for this model (for this to work, we will have to define a URL mapping that has the name , and define an associated view and template). Setting on the field above prevents genres being created with exactly the same name, but not variations such as \"fantasy\", \"Fantasy\", or even \"FaNtAsY\". The last part of the model definition uses a option on the model's metadata to specify that the lower case of the value in the field must be unique in the database, and display the string if it isn't. Here we don't need to do anything else, but you can define multiple constraints against a field or fields. For more information see the Constraints reference, including (and ).\n\nCopy the model below and again paste it into the bottom of your file. The model represents all information about an available book in a general sense, but not a particular physical \"instance\" or \"copy\" available for loan. The model uses a to represent the book's and . For , note how the first unnamed parameter explicitly sets the label as \"ISBN\" (otherwise, it would default to \"Isbn\"). We also set the parameter as to ensure all books have a unique ISBN (the unique parameter makes the field value globally unique in a table). Unlike for the (and the genre name), the is not set to be unique, because it is possible for different books to have the same name. The model uses for the , because this text may need to be quite long. class Book(models.Model): \"\"\"Model representing a book (but not a specific copy of a book).\"\"\" title = models.CharField(max_length=200) author = models.ForeignKey('Author', on_delete=models.RESTRICT, null=True) # Foreign Key used because book can only have one author, but authors can have multiple books. # Author as a string rather than object because it hasn't been declared yet in file. summary = models.TextField( max_length=1000, help_text=\"Enter a brief description of the book\") isbn = models.CharField('ISBN', max_length=13, unique=True, help_text='13 Character <a href=\"https://www.isbn-international.org/content/what-isbn' '\">ISBN number</a>') # ManyToManyField used because genre can contain many books. Books can cover many genres. # Genre class has already been defined so we can specify the object above. genre = models.ManyToManyField( Genre, help_text=\"Select a genre for this book\") def __str__(self): \"\"\"String for representing the Model object.\"\"\" return self.title def get_absolute_url(self): \"\"\"Returns the URL to access a detail record for this book.\"\"\" return reverse('book-detail', args=[str(self.id)]) The genre is a , so that a book can have multiple genres and a genre can have many books. The author is declared as , so each book will only have one author, but an author may have many books (in practice a book might have multiple authors, but not in this implementation!) In both field types the related model class is declared as the first unnamed parameter using either the model class or a string containing the name of the related model. You must use the name of the model as a string if the associated class has not yet been defined in this file before it is referenced! The other parameters of interest in the field are , which allows the database to store a value if no author is selected, and , which will prevent the book's associated author being deleted if it is referenced by any book. Warning: By default , which means that if the author was deleted, this book would be deleted too! We use here, but we could also use to prevent the author being deleted while any book uses it or to set the book's author to if the record is deleted. The model also defines , using the book's field to represent a record. The final method, returns a URL that can be used to access a detail record for this model (we will have to define a URL mapping that has the name , and define an associated view and template)."
    },
    {
        "link": "https://docs.djangoproject.com/en/5.1/ref/models/relations",
        "document": "A “related manager” is a manager used in a one-to-many or many-to-many related context. This happens in two cases:\n• None The “other side” of a relation. That is: In the above example, the methods below will be available on the manager .\n• In this example, the methods below will be available both on and on .\n\nAdds the specified model objects to the related object set. In the example above, in the case of a relationship, is used to perform the update. This requires the objects to already be saved. You can use the argument to instead have the related manager perform the update by calling . Using with a many-to-many relationship, however, will not call any methods (the argument doesn’t exist), but rather create the relationships using . If you need to execute some custom logic when a relationship is created, listen to the signal, which will trigger and actions. Using on a relation that already exists won’t duplicate the relation, but it will still trigger signals. For many-to-many relationships accepts either model instances or field values, normally primary keys, as the argument. Use the argument to specify values for the new intermediate model instance(s), if needed. You can use callables as values in the dictionary and they will be evaluated once before creating any intermediate instance(s).\n\nCreates a new object, saves it and puts it in the related object set. Returns the newly created object: # No need to call e.save() at this point -- it's already been saved. This is equivalent to (but simpler than): Note that there’s no need to specify the keyword argument of the model that defines the relationship. In the above example, we don’t pass the parameter to . Django figures out that the new object’s field should be set to . Use the argument to specify values for the new intermediate model instance, if needed. You can use callables as values in the dictionary.\n\nRemoves the specified model objects from the related object set: Similar to , is called in the example above to perform the update. Using with a many-to-many relationship, however, will delete the relationships using which means no model methods are called; listen to the signal if you wish to execute custom code when a relationship is deleted. For many-to-many relationships accepts either model instances or field values, normally primary keys, as the argument. For objects, this method only exists if . If the related field can’t be set to ( ), then an object can’t be removed from a relation without being added to another. In the above example, removing from is equivalent to doing , and because the doesn’t have , this is invalid. For objects, this method accepts a argument to control how to perform the operation. If (the default), is used. If , the method of each individual model instance is called instead. This triggers the and signals and comes at the expense of performance.\n\nThis method accepts a argument to control how to perform the operation. If (the default), the elements missing from the new set are removed using and only the new ones are added. If , the method is called instead and the whole set is added at once. For objects, the argument is passed on to and . Note that since is a compound operation, it is subject to race conditions. For instance, new objects may be added to the database in between the call to and the call to . For many-to-many relationships accepts a list of either model instances or field values, normally primary keys, as the argument. Use the argument to specify values for the new intermediate model instance(s), if needed. You can use callables as values in the dictionary and they will be evaluated once before creating any intermediate instance(s)."
    }
]