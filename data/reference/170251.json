[
    {
        "link": "https://stackoverflow.com/questions/27188538/how-to-delete-qgraphicsitem-properly",
        "document": "What I should to do to delete QGraphicsItem?\n\nTo remove item from the scene I use\n\nFrom the docs for this method:\n\nSo I see only one way:\n\nBut may be another? For example for QWidget is able to set attribute\n\nThat causes to deleting of the object. May be there is something similar for QGraphicsItem?"
    },
    {
        "link": "https://stackoverflow.com/questions/17433566/deleting-destroying-removing-a-qgraphicsitem-from-a-qgraphicsscene",
        "document": "I feel like this question has been answered somewhere before, but I cannot find the answer for the life of me (particularly because of the synonyms in the title spreading the solutions around). I want a definitive answer to which is the best way to delete a QGraphicsItem from a scene. Let's take the simplest scenario: A simple \"rubberband\" rectangle.\n\nIf you look at the , that's where I'm having my issues. I want to completely and utterly remove it from the scene and update it immediately, but calling does nothing. I want this change to be reflected immediately. In PySide it seems took care of things well, but here's it's unclear."
    },
    {
        "link": "https://forum.qt.io/topic/122643/qgraphicsscene-remove-item-but-sometime-still-in-view",
        "document": "\n• I use a qgraphicsscene additem a QChart and some inhert from the QChart item.I change QChart axisX and axisY range,and removeitem those items,then add new item.But sometime removeitem not working,item still in view.I cannot move it now.\n\n And also call all of items prepareGeometryChange,not work.\n\n So,why? I test long time,found the point is set range.if resize the view,the removed item disappear.\n• @SGaist Having a question regarding calling hide cause i encounter similar problems.\n\n In my scene i want to add some items when another item is clicked, but when i unselect the other items the items added shall be removed aswell. NOW as i figured when just calling remove onto the other items the programm crashes cause there is still the flag \"isVisible\" given back on remove. Is it in this case fine to just case setVisible(false) and than scene()->removeItem(), because than it don't crashes. But im not sure if thats proper way to do it or is it just a whacky fix. Here is my code that draws the items when the Owner item is clicked: void ITMHandleDraw::drawHandlesIfNecessary() { //qDebug() << \"DrawHandles\" << ShouldDrawHandles << ownerItem->isSelected(); if(!ownerItem){ qWarning() << \"ITMHandleDraw : No ownerItem set. Not drawing any\\ handle. Please call setOwnerItem on your ITMHandleDraw subclass\"; return; } if(ownerItem->isSelected()){ drawHandles(); }else if(!ownerItem->isSelected()){ handlesAddedToScene = false; // Ensure handles are removed from the scene before deletion //Remove the handles foreach (ITMHandleLogic * ITMHandleLogic, handleList) { // ITMHandleLogic->setVisible(false); ITMHandleLogic->scene()->removeItem(ITMHandleLogic); qDebug() << ITMHandleLogic->isVisible(); } qDeleteAll(handleList); handleList.clear(); } }"
    },
    {
        "link": "https://tech-artists.org/t/qt-properly-removing-qgraphicitems/3063",
        "document": "Hello, I am stuck with a problem regarding removal of items from a qGraphicsScene.\n\n I have a scene with selectable and movable items in it. Each item have a lot of child items. I want to be able to select an item, press “delete” and remove that item along with it’s children from the scene.\n\n The problem I have is that when I’ve been adding and removing items from the scene for a while, it randomly gets “stuck”. I can still navigate in the scene using my panning and zooming functionality, as well as add new items to the scene without any problem.\n\n I can however not interact with anything in the scene any more, not select and therefore not delete anything. I have been debugging this for a while and figured that maybe something is stuck as a mouseGrabberItem, preventing anything else from receiving mouse events. I can retrieve a mouseGrabberItem from the scene once it’s stuck, the item returned is most often a non visible item (however that is possible) but it once was a visible item that I could hide and show with the corresponding commands. I could NOT remove it from the scene using removeItem though. Trying to remove it didn’t return an error, but nothing got removed and I could still show/hide it. Any suggestions to what may cause this strange lock-up would be very helpful \n\n Thanks in advance!\n\n /Gabriel\n\nOk, so I’ve managed to track down the interaction freeze bug to have something to do with mouse-grabbers, and specifically the following error: The source code for QGraphicsItem leads me to belive that the QGraphicsItem may have lost it’s pointer to the scene? I’m not very experienced with c++, but that’s how I read it: void QGraphicsItem::ungrabMouse() { if (!d_ptr->scene) { qWarning(\"\"QGraphicsItem::ungrabMouse: cannot ungrab mouse without scene\"\"); return; } d_ptr->scene->d_func()->ungrabMouse(this); } Searching for the error on google only results in one un-answered question as well as links to source code and some project specific errors that makes little sense.\n\n Some thoughts on the case would be much appreciated Thanks!\n\nThe problems I’ve seen with Qt that could be related are:\n\n 1- Make sure no thread other than the main thread calls into Qt GUI stuff.\n\n 2- Sometimes, the ‘underlying C++ object’ will be deleted by python/Qt, even though python still has a reference to it somewhere. You can try sticking all your instances into some global list and see if that gets rid of the problem (which is better solved in another way!). I doubt they’re related but I thought I’d post it anyway.\n\nIt’s probably an error on your end and unfortunately without any more details we can’t help you. I’ve had no problems with QGraphicsScene or removing items from it when building a node editor with alot of nodes and hierarchies. What I can suggest is isolate parts of your code so you can have a reproducable bug with minimal code and work your way from there, and even upload that little isolated part here on the forums and let people check it. Though keep it very simple.\n\nI managed to track it down to a certain part of my code and remove that functionality from the application. This functionality that got removed wasn’t essential, and I will not look in to it further at the moment because of it’s big scope. I will however post whatever I find out about it here if I solve it later, for further reference Thanks for the help guys I am actually writing a node editor at the moment LoneWolf. I am having some trouble with performance though when I have more than lets say… 10 nodes in the scene. This is a bit problematic Do you have any general “tips and tricks” regarding performance to share?\n\nYeah sure. The editor I wrote had more than 1000 nodes which had probably 10 or more connections to each other, and I had zero performance issues. It looked beautiful There are a few tricks you can do. 1. Enable caching on QGraphicsItems: self.setCacheMode(QtGui.QGraphicsItem.ItemCoordinateCache )\n\n This allocates GPU memory, basically render targets, for your nodes to efficiently redraw it when needed and keeps it cached as long as the content has not changed. 2. Enable sort caching on QGraphicsScene: self.setSortCacheEnabled( True )\n\n This will speed up parent-child related QGraphicsItems during interaction such as moving them around in the scene. 3. Enable background caching on QGraphicsView: self.setCacheMode( QtGui.QGraphicsView.CacheBackground )\n\n This will allocate one render target for the entire background and reuse it on the GPU. 4. Set the cache size to be used by the pixmaps: QtGui.QPixmapCache.setCacheLimit(101200) # 100 mb GPU cache\n\n This sets the maximum texture memory your software should use when caching on the GPU. 5. Set QGraphicsScene indexing to none: self.setItemIndexMethod( QtGui.QGraphicsScene.NoIndex )\n\n This will speed up interactive scenes where stuff move around such as the user dragging nodes which in turn has children or bezier curve connections etc. Indexing is good for static scene that don’t change. This might give speed or might not. Try it. 6. Play around with ViewportUpdateMode on QGraphicsView: self.setViewportUpdateMode( … )\n\n Here you can tell QGraphicsView how much to update the scene. Minimal, Smart, BoundingRect etc. Play around with these there is no magic choice. 7. Use as little QGraphicsItems as possible and handle the drawing yourself inside the paint method!\n\n The GPU caching is very handy here since it allocates a render target per node which means it only needs to REDRAW the node if the CONTENT changes like within the paint method of QGraphicsItem. So you would draw the text, input knobs, output knobs, headers etc inside the paint method. \n\n This is also true for your bezier curve connections, play around with drawing them yourself inside drawBackground vs using actual QGraphicsItems. I went with using drawBackground on QGraphicsScene as far as I can remember for the bezier curves. 8. Don’t trigger something that would redraw the entire QGraphicsScene.\n\n Don’t do stuff like calling update on the QGraphicsView or QGraphicsScene to redraw everything. You shouldn’t need to anyway when you use methods such as paint on your nodes. If you are going to use paint(…) on QGraphcisItem be sure to reimplement shape() which is used to determine what parts only need to be redrawn in the scene and boundingRect for selection and interaction. These are some stuff that came to my mind that I used at my old job while working on a node editor! Another thing you can do which might not sound like a trivial task is to use the OpenGL widgets that come with Qt. Alot of people had success with it. Basically you make your own node scene with node items But if you follow the advice above you shouldn’t have any problems really! OpenGL stuff should be a last resort thing where you really need every bit of performance. Also not a performance related thing but more of a design choice. You should be able to connect your nodes, serialize, deserialize and stuff without a GUI being present. So design the connections, inputs, outputs, nodes with pure python or QObjects and then do the editor part.\n\n Let the core API allow callback registration which the GUI uses to update itself (Observer Pattern).\n\n This way adding a script editor to the GUI becomes a trivial task. Since the callbacks are already registered to the view (the GUI) any script editor executed stuff will automatically show up on the GUI. This way you can also record scripts and build templates and extend the GUI to automate common stuff and let users kinda build their own “lib” of actions. Also if you don’t like the GUI or rendering, you can easily change it without affecting the core."
    },
    {
        "link": "https://forum.qt.io/topic/25832/solved-remove-a-qgraphicsitem-from-a-qgraphicsscene",
        "document": "Your browser does not seem to support JavaScript. As a result, your viewing experience will be diminished, and you have been placed in read-only mode.\n\nPlease download a browser that supports JavaScript, or enable it if it's disabled (i.e. NoScript)."
    },
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtWidgets/QGraphicsItem.html",
        "document": "Items can contain other items, and also be contained by other items. All items can have a parent item and a list of children. Unless the item has no parent, its position is in parent coordinates (i.e., the parent’s local coordinates). Parent items propagate both their position and their transformation to all children.\n\nThe contains() function can be called to determine whether the item contains a point or not. This function can also be reimplemented by the item. The default behavior of contains() is based on calling shape() .\n\nReimplement collidesWithItem() to provide your own custom item and shape collision algorithm.\n\nReimplement shape() to return an accurate shape for your item, and rely on the default implementation of collidesWithItem() to do shape-shape intersection. This can be rather expensive if the shapes are complex.\n\nCollision detection can be done in two ways:\n\nQGraphicsScene expects all items boundingRect() and shape() to remain unchanged unless it is notified. If you want to change an item’s geometry in any way, you must first call prepareGeometryChange() to allow QGraphicsScene to update its bookkeeping.\n\nThe boundingRect() function has many different purposes. QGraphicsScene bases its item index on boundingRect() , and QGraphicsView uses it both for culling invisible items, and for determining the area that needs to be recomposed when drawing overlapping items. In addition, QGraphicsItem ‘s collision detection mechanisms use boundingRect() to provide an efficient cut-off. The fine grained collision algorithm in collidesWithItem() is based on calling shape() , which returns an accurate outline of the item’s shape as a QPainterPath .\n\nTo write your own graphics item, you first create a subclass of QGraphicsItem , and then start by implementing its two pure virtual public functions: boundingRect() , which returns an estimate of the area painted by the item, and paint() , which implements the actual painting. For example:\n\nYou can set whether an item should be visible (i.e., drawn, and accepting events), by calling setVisible() . Hiding an item will also hide its children. Similarly, you can enable or disable an item by calling setEnabled() . If you disable an item, all its children will also be disabled. By default, items are both visible and enabled. To toggle whether an item is selected or not, first enable selection by setting the ItemIsSelectable flag, and then call setSelected() . Normally, selection is toggled by the scene, as a result of user interaction.\n\nAll of an item’s geometric information is based on its local coordinate system. The item’s position, pos() , is the only function that does not operate in local coordinates, as it returns a position in parent coordinates. The Graphics View Coordinate System describes the coordinate system in detail.\n\nFor convenience, Qt provides a set of standard graphics items for the most common shapes. These are:\n\nIt provides a light-weight foundation for writing your own custom items. This includes defining the item’s geometry, collision detection, its painting implementation and item interaction through its event handlers. QGraphicsItem is part of the Graphics View Framework\n\nThe item is scaled relative to its transform origin point ( scale() , transformOriginPoint() )\n\nThe item is rotated relative to its transform origin point ( rotation() , transformOriginPoint() )\n\nCertain transformation operations produce a different outcome depending on the order in which they are applied. For example, if you scale an transform, and then rotate it, you may get a different result than if the transform was rotated first. However, the order you set the transformation properties on QGraphicsItem does not affect the resulting transformation; QGraphicsItem always applies the properties in a fixed, defined order:\n\nItem transformations accumulate from parent to child, so if both a parent and child item are rotated 90 degrees, the child’s total transformation will be 180 degrees. Similarly, if the item’s parent is scaled to 2x its original size, its children will also be twice as large. An item’s transformation does not affect its own local geometry; all geometry functions (e.g., contains() , update() , and all the mapping functions) still operate in local coordinates. For convenience, QGraphicsItem provides the functions sceneTransform() , which returns the item’s total transformation matrix (including its position and all parents’ positions and transformations), and scenePos() , which returns its position in scene coordinates. To reset an item’s matrix, call resetTransform() .\n\nQGraphicsItem supports projective transformations in addition to its base position, pos() . There are several ways to change an item’s transformation. For simple transformations, you can call either of the convenience functions setRotation() or setScale() , or you can pass any transformation matrix to setTransform() . For advanced transformation control you also have the option of setting several combined transformations by calling setTransformations() .\n\nItems are painted by the view, starting with the parent items and then drawing children, in ascending stacking order. You can set an item’s stacking order by calling setZValue() , and test it by calling zValue() , where items with low z-values are painted before items with high z-values. Stacking order applies to sibling items; parents are always drawn before their children.\n\nThe paint() function is called by QGraphicsView to paint the item’s contents. The item has no background or default fill of its own; whatever is behind the item will shine through all areas that are not explicitly painted in this function. You can call update() to schedule a repaint, optionally passing the rectangle that needs a repaint. Depending on whether or not the item is visible in a view, the item may or may not be repainted; there is no equivalent to repaint() in QGraphicsItem .\n\nThe stacking order of two sibling items also counts for each item’s children and descendant items. So if one item is on top of another, then all its children will also be on top of all the other item’s children as well.\n\nYou can set the ItemStacksBehindParent flag to stack a child item behind its parent.\n\nYou can call stackBefore() to reorder the list of children. This will directly modify the insertion order.\n\nYou can call setZValue() on an item to explicitly stack it on top of, or under, other sibling items. The default Z value for an item is 0. Items with the same Z value are stacked by insertion order.\n\nFor advanced users, there are ways to alter how your items are sorted:\n\nThis example shows the stacking order of all limbs of the robot from the Drag and Drop Robot example. The torso is the root item (all other items are children or descendants of the torso), so it is drawn first. Next, the head is drawn, as it is the first item in the torso’s list of children. Then the upper left arm is drawn. As the lower arm is a child of the upper arm, the lower arm is then drawn, followed by the upper arm’s next sibling, which is the upper right arm, and so on.\n\nAn item’s children are stacked on top of the parent, and sibling items are stacked by insertion order (i.e., in the same order that they were either added to the scene, or added to the same parent). If you add item A, and then B, then B will be on top of A. If you then add C, the items’ stacking order will be A, then B, then C.\n\nAll items are drawn in a defined, stable order, and this same order decides which items will receive mouse input first when you click on the scene. Normally you don’t have to worry about sorting, as the items follow a “natural order”, following the logical structure of the scene.\n\nYou can filter events for any other item by installing event filters. This functionality is separate from Qt’s regular event filters (see installEventFilter() ), which only work on subclasses of QObject . After installing your item as an event filter for another item by calling installSceneEventFilter() , the filtered events will be received by the virtual function sceneEventFilter() . You can remove item event filters by calling removeSceneEventFilter() .\n\nfocusInEvent() and focusOutEvent() handle focus in and out events\n\nQGraphicsItem receives events from QGraphicsScene through the virtual function sceneEvent() . This function distributes the most common events to a set of convenience event handlers:\n\nThis enum describes different flags that you can set on an item to toggle different features in the item’s behavior. All flags are disabled by default. The item supports interactive movement using the mouse. By clicking on the item and then dragging, the item will move together with the mouse cursor. If the item has children, all children are also moved. If the item is part of a selection, all selected items are also moved. This feature is provided as a convenience through the base implementation of ‘s mouse event handlers. The item supports selection. Enabling this feature will enable to toggle selection for the item. It will also let the item be selected automatically as a result of calling , by clicking on an item, or by using rubber band selection in . The item supports keyboard input focus (i.e., it is an input item). Enabling this flag will allow the item to accept focus, which again allows the delivery of key events to and . The item clips to its own shape. The item cannot draw or receive mouse, tablet, drag and drop or hover events outside its shape. It is disabled by default. This behavior is enforced by or . This flag was introduced in Qt 4.3. The item clips the painting of all its descendants to its own shape. Items that are either direct or indirect children of this item cannot draw outside this item’s shape. By default, this flag is disabled; children can draw anywhere. This behavior is enforced by or . This flag was introduced in Qt 4.3. This flag is similar to but in addition enforces the containment by clipping the children. The item ignores inherited transformations (i.e., its position is still anchored to its parent, but the parent or view rotation, zoom or shear transformations are ignored). This flag is useful for keeping text label items horizontal and unscaled, so they will still be readable if the view is transformed. When set, the item’s view geometry and scene geometry will be maintained separately. You must call to map coordinates and detect collisions in the view. By default, this flag is disabled. This flag was introduced in Qt 4.3. With this flag set you can still scale the item itself, and that scale transformation will influence the item’s children. The item ignores its parent’s opacity. The item’s effective opacity is the same as its own; it does not combine with the parent’s opacity. This flags allows your item to keep its absolute opacity even if the parent is semitransparent. This flag was introduced in Qt 4.5. The item doesn’t propagate its opacity to its children. This flag allows you to create a semitransparent item that does not affect the opacity of its children. This flag was introduced in Qt 4.5. The item is stacked behind its parent. By default, child items are stacked on top of the parent item. But setting this flag, the child will be stacked behind it. This flag is useful for drop shadow effects and for decoration objects that follow the parent item’s geometry without drawing on top of it. This flag was introduced in Qt 4.5. The item makes use of either exposedRect or matrix in . By default, the exposedRect is initialized to the item’s and the matrix is untransformed. You can enable this flag for the style options to be set up with more fine-grained values. Note that QStyleOptionGraphicsItem::levelOfDetail is unaffected by this flag and always initialized to 1. Use if you need a higher value. This flag was introduced in Qt 4.6. The item does not paint anything (i.e., calling on the item has no effect). You should set this flag on items that do not need to be painted to ensure that Graphics View avoids unnecessary painting preparations. This flag was introduced in Qt 4.6. The item enables notifications for , , , , , , , , , and . For performance reasons, these notifications are disabled by default. You must enable this flag to receive notifications for position and transform changes. This flag was introduced in Qt 4.6. The item supports input methods typically used for Asian languages. This flag was introduced in Qt 4.6. The item automatically stacks behind it’s parent if it’s z-value is negative. This flag enables to toggle . This flag was introduced in Qt 4.6. The item is a panel. A panel provides activation and contained focus handling. Only one panel can be active at a time (see ). When no panel is active, activates all non-panel items. Window items (i.e., returns ) are panels. This flag was introduced in Qt 4.6. The item enables notifications for . For performance reasons, these notifications are disabled by default. You must enable this flag to receive notifications for scene position changes. This flag was introduced in Qt 4.6. This flag indicates that all of the item’s direct or indirect children only draw within the item’s shape. Unlike , this restriction is not enforced. Set when you manually assure that drawing is bound to the item’s shape and want to avoid the cost associated with enforcing the clip. Setting this flag enables more efficient drawing and collision detection. The flag is disabled by default. If both this flag and are set, the clip will be enforced. This is equivalent to just setting . This flag was introduced in Qt 5.4.\n\nThis enum describes the state changes that are notified by . The notifications are sent as the state changes, and in some cases, adjustments can be made (see the documentation for each change for details). Note: Be careful with calling functions on the itself inside , as certain function calls can lead to unwanted recursion. For example, you cannot call in on an notification, as the function will again call (). Instead, you can return the new, adjusted position from . The item’s enabled state changes. If the item is presently enabled, it will become disabled, and vice verca. The value argument is the new enabled state (i.e., true or false). Do not call in as this notification is delivered. Instead, you can return the new state from . The item’s enabled state has changed. The value argument is the new enabled state (i.e., true or false). Do not call in as this notification is delivered. The return value is ignored. The item’s affine transformation matrix is changing. This value is obsolete; you can use instead. The item’s position changes. This notification is sent if the flag is enabled, and when the item’s local position changes, relative to its parent (i.e., as a result of calling or ). The value argument is the new position (i.e., a ). You can call to get the original position. Do not call or in as this notification is delivered; instead, you can return the new, adjusted position from . After this notification, immediately sends the notification if the position changed. The item’s position has changed. This notification is sent if the flag is enabled, and after the item’s local position, relative to its parent, has changed. The value argument is the new position (the same as ), and ignores the return value for this notification (i.e., a read-only notification). The item’s transformation matrix changes. This notification is sent if the flag is enabled, and when the item’s local transformation matrix changes (i.e., as a result of calling . The value argument is the new matrix (i.e., a ); to get the old matrix, call . Do not call or set any of the transformation properties in as this notification is delivered; instead, you can return the new matrix from . This notification is not sent if you change the transformation properties. The item’s transformation matrix has changed either because is called, or one of the transformation properties is changed. This notification is sent if the flag is enabled, and after the item’s local transformation matrix has changed. The value argument is the new matrix (same as ), and ignores the return value for this notification (i.e., a read-only notification). The item’s rotation property changes. This notification is sent if the flag is enabled, and when the item’s rotation property changes (i.e., as a result of calling ). The value argument is the new rotation (i.e., a double); to get the old rotation, call . Do not call in as this notification is delivered; instead, you can return the new rotation from . The item’s rotation property has changed. This notification is sent if the flag is enabled, and after the item’s rotation property has changed. The value argument is the new rotation (i.e., a double), and ignores the return value for this notification (i.e., a read-only notification). Do not call in as this notification is delivered. The item’s scale property changes. This notification is sent if the flag is enabled, and when the item’s scale property changes (i.e., as a result of calling ). The value argument is the new scale (i.e., a double); to get the old scale, call . Do not call in as this notification is delivered; instead, you can return the new scale from . The item’s scale property has changed. This notification is sent if the flag is enabled, and after the item’s scale property has changed. The value argument is the new scale (i.e., a double), and ignores the return value for this notification (i.e., a read-only notification). Do not call in as this notification is delivered. The item’s transform origin point property changes. This notification is sent if the flag is enabled, and when the item’s transform origin point property changes (i.e., as a result of calling ). The value argument is the new origin point (i.e., a ); to get the old origin point, call . Do not call in as this notification is delivered; instead, you can return the new transform origin point from . The item’s transform origin point property has changed. This notification is sent if the flag is enabled, and after the item’s transform origin point property has changed. The value argument is the new origin point (i.e., a ), and ignores the return value for this notification (i.e., a read-only notification). Do not call in as this notification is delivered. The item’s selected state changes. If the item is presently selected, it will become unselected, and vice verca. The value argument is the new selected state (i.e., true or false). Do not call in as this notification is delivered; instead, you can return the new selected state from . The item’s selected state has changed. The value argument is the new selected state (i.e., true or false). Do not call in as this notification is delivered. The return value is ignored. The item’s visible state changes. If the item is presently visible, it will become invisible, and vice verca. The value argument is the new visible state (i.e., true or false). Do not call in as this notification is delivered; instead, you can return the new visible state from . The item’s visible state has changed. The value argument is the new visible state (i.e., true or false). Do not call in as this notification is delivered. The return value is ignored. The item’s parent changes. The value argument is the new parent item (i.e., a pointer). Do not call in as this notification is delivered; instead, you can return the new parent from . The item’s parent has changed. The value argument is the new parent (i.e., a pointer to a ). Do not call in as this notification is delivered. The return value is ignored. A child is added to this item. The value argument is the new child item (i.e., a pointer). Do not pass this item to any item’s function as this notification is delivered. The return value is unused; you cannot adjust anything in this notification. Note that the new child might not be fully constructed when this notification is sent; calling pure virtual functions on the child can lead to a crash. A child is removed from this item. The value argument is the child item that is about to be removed (i.e., a pointer). The return value is unused; you cannot adjust anything in this notification. The item is moved to a new scene. This notification is also sent when the item is added to its initial scene, and when it is removed. The item’s is the old scene, or if the item has not been added to a scene yet. The value argument is the new scene (i.e., a pointer), or if the item is removed from a scene. Do not override this change by passing this item to as this notification is delivered; instead, you can return the new scene from . Use this feature with caution; objecting to a scene change can quickly lead to unwanted recursion. The item’s scene has changed. The item’s is the new scene. This notification is also sent when the item is added to its initial scene, and when it is removed.The value argument is the new scene (i.e., a pointer to a ). Do not call setScene() in as this notification is delivered. The return value is ignored. The item’s cursor changes. The value argument is the new cursor (i.e., a ). Do not call in as this notification is delivered. Instead, you can return a new cursor from . The item’s cursor has changed. The value argument is the new cursor (i.e., a ). Do not call as this notification is delivered. The return value is ignored. The item’s tooltip changes. The value argument is the new tooltip (i.e., a ). Do not call in as this notification is delivered. Instead, you can return a new tooltip from . The item’s tooltip has changed. The value argument is the new tooltip (i.e., a ). Do not call as this notification is delivered. The return value is ignored. The item’s flags change. The value argument is the new flags (i.e., a quint32). Do not call in as this notification is delivered. Instead, you can return the new flags from . The item’s flags have changed. The value argument is the new flags (i.e., a quint32). Do not call in as this notification is delivered. The return value is ignored. The item’s Z-value changes. The value argument is the new Z-value (i.e., a double). Do not call in as this notification is delivered. Instead, you can return a new Z-value from . The item’s Z-value has changed. The value argument is the new Z-value (i.e., a double). Do not call as this notification is delivered. The return value is ignored. The item’s opacity changes. The value argument is the new opacity (i.e., a double). Do not call in as this notification is delivered. Instead, you can return a new opacity from . The item’s opacity has changed. The value argument is the new opacity (i.e., a double). Do not call as this notification is delivered. The return value is ignored. The item’s scene position has changed. This notification is sent if the flag is enabled, and after the item’s scene position has changed (i.e., the position or transformation of the item itself or the position or transformation of any ancestor has changed). The value argument is the new scene position (the same as ), and ignores the return value for this notification (i.e., a read-only notification)."
    },
    {
        "link": "https://doc.qt.io/qt-6/qgraphicsitem.html",
        "document": "The QGraphicsItem class is the base class for all graphical items in a QGraphicsScene. More...\n\nSometimes it's useful to register custom data with an item, be it a custom item, or a standard item. You can call setData () on any item to store data in it using a key-value pair (the key being an integer, and the value is a QVariant ). To get custom data from an item, call data (). This functionality is completely untouched by Qt itself; it is provided for the user's convenience.\n\nYou can filter events for any other item by installing event filters. This functionality is separate from Qt's regular event filters (see QObject::installEventFilter ()), which only work on subclasses of QObject . After installing your item as an event filter for another item by calling installSceneEventFilter (), the filtered events will be received by the virtual function sceneEventFilter (). You can remove item event filters by calling removeSceneEventFilter ().\n\nQGraphicsItem receives events from QGraphicsScene through the virtual function sceneEvent (). This function distributes the most common events to a set of convenience event handlers:\n\nThe stacking order of two sibling items also counts for each item's children and descendant items. So if one item is on top of another, then all its children will also be on top of all the other item's children as well.\n\nFor advanced users, there are ways to alter how your items are sorted:\n\nThis example shows the stacking order of all limbs of the robot from the Drag and Drop Robot example. The torso is the root item (all other items are children or descendants of the torso), so it is drawn first. Next, the head is drawn, as it is the first item in the torso's list of children. Then the upper left arm is drawn. As the lower arm is a child of the upper arm, the lower arm is then drawn, followed by the upper arm's next sibling, which is the upper right arm, and so on.\n\nAn item's children are stacked on top of the parent, and sibling items are stacked by insertion order (i.e., in the same order that they were either added to the scene, or added to the same parent). If you add item A, and then B, then B will be on top of A. If you then add C, the items' stacking order will be A, then B, then C.\n\nAll items are drawn in a defined, stable order, and this same order decides which items will receive mouse input first when you click on the scene. Normally you don't have to worry about sorting, as the items follow a \"natural order\", following the logical structure of the scene.\n\nItems are painted by the view, starting with the parent items and then drawing children, in ascending stacking order. You can set an item's stacking order by calling setZValue (), and test it by calling zValue (), where items with low z-values are painted before items with high z-values. Stacking order applies to sibling items; parents are always drawn before their children.\n\nThe paint () function is called by QGraphicsView to paint the item's contents. The item has no background or default fill of its own; whatever is behind the item will shine through all areas that are not explicitly painted in this function. You can call update () to schedule a repaint, optionally passing the rectangle that needs a repaint. Depending on whether or not the item is visible in a view, the item may or may not be repainted; there is no equivalent to QWidget::repaint () in QGraphicsItem.\n\nCertain transformation operations produce a different outcome depending on the order in which they are applied. For example, if you scale an transform, and then rotate it, you may get a different result than if the transform was rotated first. However, the order you set the transformation properties on QGraphicsItem does not affect the resulting transformation; QGraphicsItem always applies the properties in a fixed, defined order:\n\nItem transformations accumulate from parent to child, so if both a parent and child item are rotated 90 degrees, the child's total transformation will be 180 degrees. Similarly, if the item's parent is scaled to 2x its original size, its children will also be twice as large. An item's transformation does not affect its own local geometry; all geometry functions (e.g., contains (), update (), and all the mapping functions) still operate in local coordinates. For convenience, QGraphicsItem provides the functions sceneTransform (), which returns the item's total transformation matrix (including its position and all parents' positions and transformations), and scenePos (), which returns its position in scene coordinates. To reset an item's matrix, call resetTransform ().\n\nQGraphicsItem supports projective transformations in addition to its base position, pos (). There are several ways to change an item's transformation. For simple transformations, you can call either of the convenience functions setRotation () or setScale (), or you can pass any transformation matrix to setTransform (). For advanced transformation control you also have the option of setting several combined transformations by calling setTransformations ().\n\nItems can contain other items, and also be contained by other items. All items can have a parent item and a list of children. Unless the item has no parent, its position is in parent coordinates (i.e., the parent's local coordinates). Parent items propagate both their position and their transformation to all children.\n\nThe contains () function can be called to determine whether the item contains a point or not. This function can also be reimplemented by the item. The default behavior of contains () is based on calling shape ().\n\nCollision detection can be done in two ways:\n\nQGraphicsScene expects all items boundingRect () and shape () to remain unchanged unless it is notified. If you want to change an item's geometry in any way, you must first call prepareGeometryChange () to allow QGraphicsScene to update its bookkeeping.\n\nThe boundingRect () function has many different purposes. QGraphicsScene bases its item index on boundingRect (), and QGraphicsView uses it both for culling invisible items, and for determining the area that needs to be recomposed when drawing overlapping items. In addition, QGraphicsItem's collision detection mechanisms use boundingRect () to provide an efficient cut-off. The fine grained collision algorithm in collidesWithItem () is based on calling shape (), which returns an accurate outline of the item's shape as a QPainterPath .\n\nTo write your own graphics item, you first create a subclass of QGraphicsItem, and then start by implementing its two pure virtual public functions: boundingRect (), which returns an estimate of the area painted by the item, and paint (), which implements the actual painting. For example:\n\nYou can set whether an item should be visible (i.e., drawn, and accepting events), by calling setVisible (). Hiding an item will also hide its children. Similarly, you can enable or disable an item by calling setEnabled (). If you disable an item, all its children will also be disabled. By default, items are both visible and enabled. To toggle whether an item is selected or not, first enable selection by setting the ItemIsSelectable flag, and then call setSelected (). Normally, selection is toggled by the scene, as a result of user interaction.\n\nAll of an item's geometric information is based on its local coordinate system. The item's position, pos (), is the only function that does not operate in local coordinates, as it returns a position in parent coordinates. The Graphics View Coordinate System describes the coordinate system in detail.\n\nFor convenience, Qt provides a set of standard graphics items for the most common shapes. These are:\n\nIt provides a light-weight foundation for writing your own custom items. This includes defining the item's geometry, collision detection, its painting implementation and item interaction through its event handlers. QGraphicsItem is part of the Graphics View Framework\n\nSee also QGraphicsScene, QGraphicsView, and Graphics View Framework.\n\nThe value returned by the virtual type () function in standard graphics item classes in Qt. All such standard graphics item classes in Qt are associated with a unique value for Type, e.g. the value returned by QGraphicsPathItem::type () is 2.\n\nThis enum specifies the behavior of a modal panel. A modal panel is one that blocks input to other panels. Note that items that are children of a modal panel are not blocked.\n\nThe GraphicsItemFlags type is a typedef for QFlags <GraphicsItemFlag>. It stores an OR combination of GraphicsItemFlag values.\n\nNote: If both this flag and ItemClipsChildrenToShape are set, the clip will be enforced. This is equivalent to just setting ItemClipsChildrenToShape.\n\nNote: With this flag set you can still scale the item itself, and that scale transformation will influence the item's children.\n\nNote: This flag is similar to ItemContainsChildrenInShape but in addition enforces the containment by clipping the children.\n\nThis enum describes different flags that you can set on an item to toggle different features in the item's behavior.\n\nNote: Be careful with calling functions on the QGraphicsItem itself inside itemChange (), as certain function calls can lead to unwanted recursion. For example, you cannot call setPos () in itemChange () on an ItemPositionChange notification, as the setPos () function will again call itemChange (ItemPositionChange). Instead, you can return the new, adjusted position from itemChange ().\n\nThis enum describes the state changes that are notified by QGraphicsItem::itemChange (). The notifications are sent as the state changes, and in some cases, adjustments can be made (see the documentation for each change for details).\n\nThis enum describes QGraphicsItem 's cache modes. Caching is used to speed up rendering by allocating and rendering to an off-screen pixel buffer, which can be reused when the item requires redrawing. For some paint devices, the cache is stored directly in graphics memory, which makes rendering very quick.\n\nConstructs a QGraphicsItem with the given parent item. It does not modify the parent object returned by QObject::parent().\n\nIf parent is , you can add the item to a scene by calling QGraphicsScene::addItem(). The item will then become a top-level item.\n\nSee also QGraphicsScene::addItem() and setParentItem().\n\nDestroys the QGraphicsItem and all its children. If this item is currently associated with a scene, the item will be removed from the scene before it is deleted.\n\nReturns if this item can accept drag and drop events; otherwise, returns . By default, items do not accept drag and drop events; items are transparent to drag and drop.\n\nReturns if an item accepts hover events (QGraphicsSceneHoverEvent); otherwise, returns . By default, items do not accept hover events.\n\nSee also setAcceptHoverEvents() and setAcceptedMouseButtons().\n\nReturns if an item accepts touch events; otherwise, returns . By default, items do not accept touch events.\n\nReturns the mouse buttons that this item accepts mouse events for. By default, all mouse buttons are accepted.\n\nIf an item accepts a mouse button, it will become the mouse grabber item when a mouse press event is delivered for that mouse button. However, if the item does not accept the button, QGraphicsScene will forward the mouse events to the first item beneath it that does.\n\nSee also setAcceptedMouseButtons() and mousePressEvent().\n\nThis virtual function is called twice for all items by the QGraphicsScene::advance() slot. In the first phase, all items are called with phase == 0, indicating that items on the scene are about to advance, and then all items are called with phase == 1. Reimplement this function to update your item if you need simple scene-controlled animation.\n\nThe default implementation does nothing.\n\nThis function is intended for animations. An alternative is to multiple-inherit from QObject and QGraphicsItem and use the Animation Framework.\n\nSee also QGraphicsScene::advance() and QTimeLine.\n\nThis pure virtual function defines the outer bounds of the item as a rectangle; all painting must be restricted to inside an item's bounding rect. QGraphicsView uses this to determine whether the item requires redrawing.\n\nAlthough the item's shape can be arbitrary, the bounding rect is always rectangular, and it is unaffected by the items' transformation.\n\nIf you want to change the item's bounding rectangle, you must first call prepareGeometryChange(). This notifies the scene of the imminent change, so that it can update its item geometry index; otherwise, the scene will be unaware of the item's new geometry, and the results are undefined (typically, rendering artifacts are left within the view).\n\nReimplement this function to let QGraphicsView determine what parts of the widget, if any, need to be redrawn.\n\nNote: For shapes that paint an outline / stroke, it is important to include half the pen width in the bounding rect. It is not necessary to compensate for antialiasing, though.\n\nSee also boundingRegion(), shape(), contains(), The Graphics View Coordinate System, and prepareGeometryChange().\n\nReturns the bounding region for this item. The coordinate space of the returned region depends on itemToDeviceTransform. If you pass an identity QTransform as a parameter, this function will return a local coordinate region.\n\nThe bounding region describes a coarse outline of the item's visual contents. Although it's expensive to calculate, it's also more precise than boundingRect(), and it can help to avoid unnecessary repainting when an item is updated. This is particularly efficient for thin items (e.g., lines or simple polygons). You can tune the granularity for the bounding region by calling setBoundingRegionGranularity(). The default granularity is 0; in which the item's bounding region is the same as its bounding rect.\n\nitemToDeviceTransform is the transformation from item coordinates to device coordinates. If you want this function to return a QRegion in scene coordinates, you can pass sceneTransform() as an argument.\n\nReturns the item's bounding region granularity; a value between and including 0 and 1. The default value is 0 (i.e., the lowest granularity, where the bounding region corresponds to the item's bounding rectangle).\n\nReturns the cache mode for this item. The default mode is NoCache (i.e., cache is disabled and all painting is immediate).\n\nThe items are sorted by stacking order. This takes into account both the items' insertion order and their Z-values.\n\nSee also setParentItem(), zValue(), and Sorting.\n\nReturns the bounding rect of this item's descendants (i.e., its children, their children, etc.) in local coordinates. The rectangle will contain all descendants after they have been mapped to local coordinates. If the item has no children, this function returns an empty QRectF.\n\nThis does not include this item's own bounding rect; it only returns its descendants' accumulated bounding rect. If you need to include this item's bounding rect, you can add boundingRect() to childrenBoundingRect() using QRectF::operator|().\n\nThis function is linear in complexity; it determines the size of the returned bounding rect by iterating through all descendants.\n\nSee also boundingRect() and sceneBoundingRect().\n\nIf it has focus, a focus out event is sent to this item to tell it that it is about to lose the focus.\n\nOnly items that set the ItemIsFocusable flag, or widgets that set an appropriate focus policy, can accept keyboard focus.\n\nSee also setFocus(), hasFocus(), and QGraphicsWidget::focusPolicy.\n\nReturns this item's clip path, or an empty QPainterPath if this item is not clipped. The clip path constrains the item's appearance and interaction (i.e., restricts the area the item can draw within and receive events for).\n\nYou can enable clipping by setting the ItemClipsToShape or ItemClipsChildrenToShape flags. The item's clip path is calculated by intersecting all clipping ancestors' shapes. If the item sets ItemClipsToShape, the final clip is intersected with the item's own shape.\n\nSee also isClipped(), shape(), and setFlags().\n\nReturns if this item collides with other; otherwise returns .\n\nThe mode is applied to other, and the resulting shape or bounding rectangle is then compared to this item's shape. The default value for mode is Qt::IntersectsItemShape; other collides with this item if it either intersects, contains, or is contained by this item's shape (see Qt::ItemSelectionMode for details).\n\nThe default implementation is based on shape intersection, and it calls shape() on both items. Because the complexity of arbitrary shape-shape intersection grows with an order of magnitude when the shapes are complex, this operation can be noticeably time-consuming. You have the option of reimplementing this function in a subclass of QGraphicsItem to provide a custom algorithm. This allows you to make use of natural constraints in the shapes of your own items, in order to improve the performance of the collision detection. For instance, two untransformed perfectly circular items' collision can be determined very efficiently by comparing their positions and radii.\n\nKeep in mind that when reimplementing this function and calling shape() or boundingRect() on other, the returned coordinates must be mapped to this item's coordinate system before any intersection can take place.\n\nSee also contains() and shape().\n\nReturns if this item collides with path.\n\nThe collision is determined by mode. The default value for mode is Qt::IntersectsItemShape; path collides with this item if it either intersects, contains, or is contained by this item's shape.\n\nNote that this function checks whether the item's shape or bounding rectangle (depending on mode) is contained within path, and not whether path is contained within the items shape or bounding rectangle.\n\nSee also collidesWithItem(), contains(), and shape().\n\nReturns a list of all items that collide with this item.\n\nThe way collisions are detected is determined by applying mode to items that are compared to this item, i.e., each item's shape or bounding rectangle is checked against this item's shape. The default value for mode is Qt::IntersectsItemShape.\n\nReturns the closest common ancestor item of this item and other, or if either other is , or there is no common ancestor.\n\nReturns if this item contains point, which is in local coordinates; otherwise, false is returned. It is most often called from QGraphicsView to determine what item is under the cursor, and for that reason, the implementation of this function should be as light-weight as possible.\n\nBy default, this function calls shape(), but you can reimplement it in a subclass to provide a (perhaps more efficient) implementation.\n\nSee also shape(), boundingRect(), and collidesWithPath().\n\nThis event handler can be reimplemented in a subclass to process context menu events. The event parameter contains details about the event to be handled.\n\nIf you ignore the event (i.e., by calling QEvent::ignore()), event will propagate to any item beneath this item. If no items accept the event, it will be ignored by the scene and propagate to the view.\n\nIt's common to open a QMenu in response to receiving a context menu event. Example:\n\nReturns the current cursor shape for the item. The mouse cursor will assume this shape when it's over this item. See the list of predefined cursor objects for a range of useful shapes.\n\nAn editor item might want to use an I-beam cursor:\n\nIf no cursor has been set, the cursor of the item beneath is used.\n\nSee also setCursor(), hasCursor(), unsetCursor(), QWidget::cursor, and QGuiApplication::overrideCursor().\n\nReturns this item's custom data for the key key as a QVariant.\n\nCustom item data is useful for storing arbitrary properties in any item. Example:\n\nQt does not use this feature for storing data; it is provided solely for the convenience of the user.\n\nReturns this item's device transformation matrix, using viewportTransform to map from scene to device coordinates. This matrix can be used to map coordinates and geometrical shapes from this item's local coordinate system to the viewport's (or any device's) coordinate system. To map coordinates from the viewport, you must first invert the returned matrix.\n\nThis function is the same as combining this item's scene transform with the view's viewport transform, but it also understands the ItemIgnoresTransformations flag. The device transform can be used to do accurate coordinate mapping (and collision detection) for untransformable items.\n\nSee also transform(), setTransform(), scenePos(), The Graphics View Coordinate System, and itemTransform().\n\nThis event handler, for event event, can be reimplemented to receive drag enter events for this item. Drag enter events are generated as the cursor enters the item's area.\n\nBy accepting the event (i.e., by calling QEvent::accept()), the item will accept drop events, in addition to receiving drag move and drag leave. Otherwise, the event will be ignored and propagate to the item beneath. If the event is accepted, the item will receive a drag move event before control goes back to the event loop.\n\nA common implementation of dragEnterEvent accepts or ignores event depending on the associated mime data in event. Example:\n\nItems do not receive drag and drop events by default; to enable this feature, call .\n\nThe default implementation does nothing.\n\nSee also dropEvent(), dragMoveEvent(), and dragLeaveEvent().\n\nThis event handler, for event event, can be reimplemented to receive drag leave events for this item. Drag leave events are generated as the cursor leaves the item's area. Most often you will not need to reimplement this function, but it can be useful for resetting state in your item (e.g., highlighting).\n\nCalling QEvent::ignore() or QEvent::accept() on event has no effect.\n\nItems do not receive drag and drop events by default; to enable this feature, call .\n\nThe default implementation does nothing.\n\nSee also dragEnterEvent(), dropEvent(), and dragMoveEvent().\n\nThis event handler, for event event, can be reimplemented to receive drag move events for this item. Drag move events are generated as the cursor moves around inside the item's area. Most often you will not need to reimplement this function; it is used to indicate that only parts of the item can accept drops.\n\nCalling QEvent::ignore() or QEvent::accept() on event toggles whether or not the item will accept drops at the position from the event. By default, event is accepted, indicating that the item allows drops at the specified position.\n\nItems do not receive drag and drop events by default; to enable this feature, call .\n\nThe default implementation does nothing.\n\nSee also dropEvent(), dragEnterEvent(), and dragLeaveEvent().\n\nThis event handler, for event event, can be reimplemented to receive drop events for this item. Items can only receive drop events if the last drag move event was accepted.\n\nCalling QEvent::ignore() or QEvent::accept() on event has no effect.\n\nItems do not receive drag and drop events by default; to enable this feature, call .\n\nThe default implementation does nothing.\n\nSee also dragEnterEvent(), dragMoveEvent(), and dragLeaveEvent().\n\nReturns this item's effective opacity, which is between 0.0 (transparent) and 1.0 (opaque). This value is a combination of this item's local opacity, and its parent and ancestors' opacities. The effective opacity decides how the item is rendered.\n\nSee also opacity(), setOpacity(), paint(), ItemIgnoresParentOpacity, and ItemDoesntPropagateOpacityToChildren.\n\nIf this item is part of a scene that is viewed by a QGraphicsView, this convenience function will attempt to scroll the view to ensure that rect is visible inside the view's viewport. If rect is a null rect (the default), QGraphicsItem will default to the item's bounding rect. xmargin and ymargin are the number of pixels the view should use for margins.\n\nIf the specified rect cannot be reached, the contents are scrolled to the nearest valid position.\n\nIf this item is not viewed by a QGraphicsView, this function does nothing.\n\nThis convenience function is equivalent to calling ensureVisible(QRectF(x, y, w, h), xmargin, ymargin).\n\nReturns if this item filters child events (i.e., all events intended for any of its children are instead sent to this item); otherwise, false is returned.\n\nThe default value is false; child events are not filtered.\n\nReturns this item's flags. The flags describe what configurable features of the item are enabled and not. For example, if the flags include ItemIsFocusable, the item can accept input focus.\n\nBy default, no flags are enabled.\n\nSee also setFlags() and setFlag().\n\nThis event handler, for event event, can be reimplemented to receive focus in events for this item. The default implementation calls ensureVisible().\n\nSee also focusOutEvent(), sceneEvent(), and setFocus().\n\nIf this item, a child or descendant of this item currently has input focus, this function will return a pointer to that item. If no descendant has input focus, is returned.\n\nSee also hasFocus(), setFocus(), and QWidget::focusWidget().\n\nThis event handler, for event event, can be reimplemented to receive focus out events for this item. The default implementation does nothing.\n\nSee also focusInEvent(), sceneEvent(), and setFocus().\n\nReturns this item's focus proxy, or if this item has no focus proxy.\n\nSee also setFocusProxy(), setFocus(), and hasFocus().\n\nThe item will receive all keyboard input to the scene until one of the following events occur:\n• The item is removed from the scene\n• Another item calls grabKeyboard(); the item will regain the keyboard grab when the other item calls ungrabKeyboard().\n\nWhen an item gains the keyboard grab, it receives a QEvent::GrabKeyboard event. When it loses the keyboard grab, it receives a QEvent::UngrabKeyboard event. These events can be used to detect when your item gains or loses the keyboard grab through other means than gaining input focus.\n\nIt is almost never necessary to explicitly grab the keyboard in Qt, as Qt grabs and releases it sensibly. In particular, Qt grabs the keyboard when your item gains input focus, and releases it when your item loses input focus, or when the item is hidden.\n\nNote that only visible items can grab keyboard input. Calling grabKeyboard() on an invisible item has no effect.\n\nSee also ungrabKeyboard(), grabMouse(), and setFocus().\n\nThis item will receive all mouse events for the scene until any of the following events occurs:\n• The item is removed from the scene\n• Another item calls grabMouse(); the item will regain the mouse grab when the other item calls ungrabMouse().\n\nWhen an item gains the mouse grab, it receives a QEvent::GrabMouse event. When it loses the mouse grab, it receives a QEvent::UngrabMouse event. These events can be used to detect when your item gains or loses the mouse grab through other means than receiving mouse button events.\n\nIt is almost never necessary to explicitly grab the mouse in Qt, as Qt grabs and releases it sensibly. In particular, Qt grabs the mouse when you press a mouse button, and keeps the mouse grabbed until you release the last mouse button. Also, Qt::Popup widgets implicitly call grabMouse() when shown, and ungrabMouse() when hidden.\n\nNote that only visible items can grab mouse input. Calling grabMouse() on an invisible item has no effect.\n\nSee also QGraphicsScene::mouseGrabberItem(), ungrabMouse(), and grabKeyboard().\n\nReturns a pointer to this item's effect if it has one; otherwise .\n\nReturns a pointer to this item's item group, or if this item is not member of a group.\n\nSee also setGroup(), QGraphicsItemGroup, and QGraphicsScene::createItemGroup().\n\nReturns if this item has a cursor set; otherwise, false is returned.\n\nBy default, items don't have any cursor set. cursor() will return a standard pointing arrow cursor.\n\nReturns if this item is active, and it or its focus proxy has keyboard input focus; otherwise, returns .\n\nSee also focusItem(), setFocus(), QGraphicsScene::setFocusItem(), and isActive().\n\nHides the item (items are visible by default).\n\nThis convenience function is equivalent to calling .\n\nSee also show() and setVisible().\n\nThis event handler, for event event, can be reimplemented to receive hover enter events for this item. The default implementation calls update(); otherwise it does nothing.\n\nCalling QEvent::ignore() or QEvent::accept() on event has no effect.\n\nSee also hoverMoveEvent(), hoverLeaveEvent(), sceneEvent(), and setAcceptHoverEvents().\n\nThis event handler, for event event, can be reimplemented to receive hover leave events for this item. The default implementation calls update(); otherwise it does nothing.\n\nCalling QEvent::ignore() or QEvent::accept() on event has no effect.\n\nSee also hoverEnterEvent(), hoverMoveEvent(), sceneEvent(), and setAcceptHoverEvents().\n\nThis event handler, for event event, can be reimplemented to receive hover move events for this item. The default implementation does nothing.\n\nCalling QEvent::ignore() or QEvent::accept() on event has no effect.\n\nSee also hoverEnterEvent(), hoverLeaveEvent(), sceneEvent(), and setAcceptHoverEvents().\n\nThis event handler, for event event, can be reimplemented to receive input method events for this item. The default implementation ignores the event.\n\nSee also inputMethodQuery() and sceneEvent().\n\nReturns the current input method hints of this item.\n\nInput method hints are only relevant for input items. The hints are used by the input method to indicate how it should operate. For example, if the Qt::ImhNumbersOnly flag is set, the input method may change its visual components to reflect that only numbers can be entered.\n\nThe effect may vary between input method implementations.\n\nSee also setInputMethodHints() and inputMethodQuery().\n\nThis method is only relevant for input items. It is used by the input method to query a set of properties of the item to be able to support complex input method operations, such as support for surrounding text and reconversions. query specifies which property is queried.\n\nSee also inputMethodEvent() and QInputMethodEvent.\n\nInstalls an event filter for this item on filterItem, causing all events for this item to first pass through filterItem's sceneEventFilter() function.\n\nTo filter another item's events, install this item as an event filter for the other item. Example:\n\nAn item can only filter events for other items in the same scene. Also, an item cannot filter its own events; instead, you can reimplement sceneEvent() directly.\n\nItems must belong to a scene for scene event filters to be installed and used.\n\nSee also removeSceneEventFilter(), sceneEventFilter(), and sceneEvent().\n\nReturns if this item is active; otherwise returns .\n\nAn item can only be active if the scene is active. An item is active if it is, or is a descendent of, an active panel. Items in non-active panels are not active.\n\nItems that are not part of a panel follow scene activation when the scene has no active panel.\n\nSee also QGraphicsScene::isActive(), QGraphicsScene::activePanel(), panel(), and isPanel().\n\nReturns if this item is an ancestor of child (i.e., if this item is child's parent, or one of child's parent's ancestors).\n\nReturns if this item is blocked by a modal panel, false otherwise. If blockingPanel is non-zero, blockingPanel will be set to the modal panel that is blocking this item. If this item is not blocked, blockingPanel will not be set by this function.\n\nThis function always returns for items not in a scene.\n\nSee also panelModality(), setPanelModality(), and PanelModality.\n\nReturns if this item is clipped. An item is clipped if it has either set the ItemClipsToShape flag, or if it or any of its ancestors has set the ItemClipsChildrenToShape flag.\n\nClipping affects the item's appearance (i.e., painting), as well as mouse and hover event delivery.\n\nSee also clipPath(), shape(), and setFlags().\n\nReturns if the item is enabled; otherwise, false is returned.\n\nThis is an overloaded function.\n\nReturns if rect is completely obscured by the opaque shape of any of colliding items above it (i.e., with a higher Z value than this item).\n\nThis is an overloaded function.\n\nThis convenience function is equivalent to calling isObscured(QRectF(x, y, w, h)).\n\nReturns if this item's bounding rect is completely obscured by the opaque shape of item.\n\nThe base implementation maps item's opaqueArea() to this item's coordinate system, and then checks if this item's boundingRect() is fully contained within the mapped shape.\n\nYou can reimplement this function to provide a custom algorithm for determining whether this item is obscured by item.\n\nSee also opaqueArea() and isObscured().\n\nReturns if the item is a panel; otherwise returns .\n\nSee also QGraphicsItem::panel() and ItemIsPanel.\n\nReturns if this item is selected; otherwise, false is returned.\n\nItems that are in a group inherit the group's selected state.\n\nItems are not selected by default.\n\nSee also setSelected() and QGraphicsScene::setSelectionArea().\n\nReturns if this item is currently under the mouse cursor in one of the views; otherwise, false is returned.\n\nSee also QGraphicsScene::views() and QCursor::pos().\n\nReturns if the item is visible; otherwise, false is returned.\n\nNote that the item's general visibility is unrelated to whether or not it is actually being visualized by a QGraphicsView.\n\nReturns if the item is visible to parent; otherwise, false is returned. parent can be , in which case this function will return whether the item is visible to the scene or not.\n\nAn item may not be visible to its ancestors even if isVisible() is true. It may also be visible to its ancestors even if isVisible() is false. If any ancestor is hidden, the item itself will be implicitly hidden, in which case this function will return false.\n\nSee also isVisible() and setVisible().\n\nReturns if this item is a widget (i.e., QGraphicsWidget); otherwise, returns .\n\nReturns if the item is a QGraphicsWidget window, otherwise returns false.\n\nThis virtual function is called by QGraphicsItem to notify custom items that some part of the item's state changes. By reimplementing this function, you can react to a change, and in some cases (depending on change), adjustments can be made.\n\nchange is the parameter of the item that is changing. value is the new value; the type of the value depends on change.\n\nThe default implementation does nothing, and returns value.\n\nNote: Certain QGraphicsItem functions cannot be called in a reimplementation of this function; see the GraphicsItemChange documentation for details.\n\nReturns a QTransform that maps coordinates from this item to other. If ok is not null, and if there is no such transform, the boolean pointed to by ok will be set to false; otherwise it will be set to true.\n\nThis transform provides an alternative to the mapToItem() or mapFromItem() functions, by returning the appropriate transform so that you can map shapes and coordinates yourself. It also helps you write more efficient code when repeatedly mapping between the same two items.\n\nSee also mapToItem(), mapFromItem(), and deviceTransform().\n\nThis event handler, for event event, can be reimplemented to receive key press events for this item. The default implementation ignores the event. If you reimplement this handler, the event will by default be accepted.\n\nNote that key events are only received for items that set the ItemIsFocusable flag, and that have keyboard input focus.\n\nSee also keyReleaseEvent(), setFocus(), QGraphicsScene::setFocusItem(), and sceneEvent().\n\nThis event handler, for event event, can be reimplemented to receive key release events for this item. The default implementation ignores the event. If you reimplement this handler, the event will by default be accepted.\n\nNote that key events are only received for items that set the ItemIsFocusable flag, and that have keyboard input focus.\n\nSee also keyPressEvent(), setFocus(), QGraphicsScene::setFocusItem(), and sceneEvent().\n\nMaps the path path, which is in item's coordinate system, to this item's coordinate system, and returns the mapped path.\n\nIf item is , this function returns the same as mapFromScene().\n\nSee also itemTransform(), mapFromParent(), mapFromScene(), mapToItem(), and The Graphics View Coordinate System.\n\nMaps the point point, which is in item's coordinate system, to this item's coordinate system, and returns the mapped coordinate.\n\nIf item is , this function returns the same as mapFromScene().\n\nSee also itemTransform(), mapFromParent(), mapFromScene(), transform(), mapToItem(), and The Graphics View Coordinate System.\n\nMaps the polygon polygon, which is in item's coordinate system, to this item's coordinate system, and returns the mapped polygon.\n\nIf item is , this function returns the same as mapFromScene().\n\nSee also itemTransform(), mapToItem(), mapFromParent(), transform(), and The Graphics View Coordinate System.\n\nMaps the rectangle rect, which is in item's coordinate system, to this item's coordinate system, and returns the mapped rectangle as a polygon.\n\nIf item is , this function returns the same as mapFromScene()\n\nSee also itemTransform(), mapToItem(), mapFromParent(), transform(), and The Graphics View Coordinate System.\n\nThis convenience function is equivalent to calling mapFromItem(item, QRectF(x, y, w, h)).\n\nThis is an overloaded function.\n\nThis convenience function is equivalent to calling mapFromItem(item, QPointF(x, y)).\n\nMaps the path path, which is in this item's parent's coordinate system, to this item's coordinate system, and returns the mapped path.\n\nSee also mapFromScene(), mapFromItem(), mapToParent(), and The Graphics View Coordinate System.\n\nMaps the point point, which is in this item's parent's coordinate system, to this item's coordinate system, and returns the mapped coordinate.\n\nSee also mapFromItem(), mapFromScene(), transform(), mapToParent(), and The Graphics View Coordinate System.\n\nMaps the polygon polygon, which is in this item's parent's coordinate system, to this item's coordinate system, and returns the mapped polygon.\n\nSee also mapToParent(), mapToItem(), transform(), and The Graphics View Coordinate System.\n\nMaps the rectangle rect, which is in this item's parent's coordinate system, to this item's coordinate system, and returns the mapped rectangle as a polygon.\n\nSee also mapToParent(), mapFromItem(), transform(), and The Graphics View Coordinate System.\n\nThis convenience function is equivalent to calling mapFromItem(QRectF(x, y, w, h)).\n\nThis is an overloaded function.\n\nThis convenience function is equivalent to calling mapFromParent(QPointF(x, y)).\n\nMaps the path path, which is in this item's scene's coordinate system, to this item's coordinate system, and returns the mapped path.\n\nSee also mapFromParent(), mapFromItem(), mapToScene(), and The Graphics View Coordinate System.\n\nMaps the point point, which is in this item's scene's coordinate system, to this item's coordinate system, and returns the mapped coordinate.\n\nSee also mapFromItem(), mapFromParent(), transform(), mapToScene(), and The Graphics View Coordinate System.\n\nMaps the polygon polygon, which is in this item's scene's coordinate system, to this item's coordinate system, and returns the mapped polygon.\n\nSee also mapToScene(), mapFromParent(), transform(), and The Graphics View Coordinate System.\n\nMaps the rectangle rect, which is in this item's scene's coordinate system, to this item's coordinate system, and returns the mapped rectangle as a polygon.\n\nSee also mapToScene(), mapFromItem(), transform(), and The Graphics View Coordinate System.\n\nThis convenience function is equivalent to calling mapFromScene(QRectF(x, y, w, h)).\n\nThis is an overloaded function.\n\nThis convenience function is equivalent to calling mapFromScene(QPointF(x, y)).\n\nMaps the rectangle rect, which is in item's coordinate system, to this item's coordinate system, and returns the mapped rectangle as a new rectangle (i.e., the bounding rectangle of the resulting polygon).\n\nIf item is , this function returns the same as mapRectFromScene().\n\nSee also itemTransform(), mapToParent(), mapToScene(), mapFromItem(), and The Graphics View Coordinate System.\n\nThis convenience function is equivalent to calling mapRectFromItem(item, QRectF(x, y, w, h)).\n\nMaps the rectangle rect, which is in this item's parent's coordinate system, to this item's coordinate system, and returns the mapped rectangle as a new rectangle (i.e., the bounding rectangle of the resulting polygon).\n\nSee also itemTransform(), mapToParent(), mapToScene(), mapFromItem(), and The Graphics View Coordinate System.\n\nThis convenience function is equivalent to calling mapRectFromParent(QRectF(x, y, w, h)).\n\nMaps the rectangle rect, which is in scene coordinates, to this item's coordinate system, and returns the mapped rectangle as a new rectangle (i.e., the bounding rectangle of the resulting polygon).\n\nSee also itemTransform(), mapToParent(), mapToScene(), mapFromItem(), and The Graphics View Coordinate System.\n\nThis convenience function is equivalent to calling mapRectFromScene(QRectF(x, y, w, h)).\n\nMaps the rectangle rect, which is in this item's coordinate system, to item's coordinate system, and returns the mapped rectangle as a new rectangle (i.e., the bounding rectangle of the resulting polygon).\n\nIf item is , this function returns the same as mapRectToScene().\n\nSee also itemTransform(), mapToParent(), mapToScene(), mapFromItem(), and The Graphics View Coordinate System.\n\nThis convenience function is equivalent to calling mapRectToItem(item, QRectF(x, y, w, h)).\n\nMaps the rectangle rect, which is in this item's coordinate system, to its parent's coordinate system, and returns the mapped rectangle as a new rectangle (i.e., the bounding rectangle of the resulting polygon).\n\nSee also itemTransform(), mapToParent(), mapToScene(), mapFromItem(), and The Graphics View Coordinate System.\n\nThis convenience function is equivalent to calling mapRectToParent(QRectF(x, y, w, h)).\n\nMaps the rectangle rect, which is in this item's coordinate system, to the scene coordinate system, and returns the mapped rectangle as a new rectangle (i.e., the bounding rectangle of the resulting polygon).\n\nSee also itemTransform(), mapToParent(), mapToScene(), mapFromItem(), and The Graphics View Coordinate System.\n\nThis convenience function is equivalent to calling mapRectToScene(QRectF(x, y, w, h)).\n\nMaps the path path, which is in this item's coordinate system, to item's coordinate system, and returns the mapped path.\n\nIf item is , this function returns the same as mapToScene().\n\nSee also itemTransform(), mapToParent(), mapToScene(), mapFromItem(), and The Graphics View Coordinate System.\n\nMaps the point point, which is in this item's coordinate system, to item's coordinate system, and returns the mapped coordinate.\n\nIf item is , this function returns the same as mapToScene().\n\nSee also itemTransform(), mapToParent(), mapToScene(), transform(), mapFromItem(), and The Graphics View Coordinate System.\n\nMaps the polygon polygon, which is in this item's coordinate system, to item's coordinate system, and returns the mapped polygon.\n\nIf item is , this function returns the same as mapToScene().\n\nSee also itemTransform(), mapToParent(), mapToScene(), mapFromItem(), and The Graphics View Coordinate System.\n\nMaps the rectangle rect, which is in this item's coordinate system, to item's coordinate system, and returns the mapped rectangle as a polygon.\n\nIf item is , this function returns the same as mapToScene().\n\nSee also itemTransform(), mapToParent(), mapToScene(), mapFromItem(), and The Graphics View Coordinate System.\n\nThis convenience function is equivalent to calling mapToItem(item, QRectF(x, y, w, h)).\n\nThis is an overloaded function.\n\nThis convenience function is equivalent to calling mapToItem(item, QPointF(x, y)).\n\nMaps the path path, which is in this item's coordinate system, to its parent's coordinate system, and returns the mapped path. If the item has no parent, path will be mapped to the scene's coordinate system.\n\nSee also mapToScene(), mapToItem(), mapFromParent(), and The Graphics View Coordinate System.\n\nMaps the point point, which is in this item's coordinate system, to its parent's coordinate system, and returns the mapped coordinate. If the item has no parent, point will be mapped to the scene's coordinate system.\n\nSee also mapToItem(), mapToScene(), transform(), mapFromParent(), and The Graphics View Coordinate System.\n\nMaps the polygon polygon, which is in this item's coordinate system, to its parent's coordinate system, and returns the mapped polygon. If the item has no parent, polygon will be mapped to the scene's coordinate system.\n\nSee also mapToScene(), mapToItem(), mapFromParent(), and The Graphics View Coordinate System.\n\nMaps the rectangle rect, which is in this item's coordinate system, to its parent's coordinate system, and returns the mapped rectangle as a polygon. If the item has no parent, rect will be mapped to the scene's coordinate system.\n\nSee also mapToScene(), mapToItem(), mapFromParent(), and The Graphics View Coordinate System.\n\nThis convenience function is equivalent to calling mapToParent(QRectF(x, y, w, h)).\n\nThis is an overloaded function.\n\nThis convenience function is equivalent to calling mapToParent(QPointF(x, y)).\n\nMaps the path path, which is in this item's coordinate system, to the scene's coordinate system, and returns the mapped path.\n\nSee also mapToParent(), mapToItem(), mapFromScene(), and The Graphics View Coordinate System.\n\nMaps the point point, which is in this item's coordinate system, to the scene's coordinate system, and returns the mapped coordinate.\n\nSee also mapToItem(), mapToParent(), transform(), mapFromScene(), and The Graphics View Coordinate System.\n\nMaps the polygon polygon, which is in this item's coordinate system, to the scene's coordinate system, and returns the mapped polygon.\n\nSee also mapToParent(), mapToItem(), mapFromScene(), and The Graphics View Coordinate System.\n\nMaps the rectangle rect, which is in this item's coordinate system, to the scene's coordinate system, and returns the mapped rectangle as a polygon.\n\nSee also mapToParent(), mapToItem(), mapFromScene(), and The Graphics View Coordinate System.\n\nThis convenience function is equivalent to calling mapToScene(QRectF(x, y, w, h)).\n\nThis is an overloaded function.\n\nThis convenience function is equivalent to calling mapToScene(QPointF(x, y)).\n\nThis event handler, for event event, can be reimplemented to receive mouse double-click events for this item.\n\nWhen doubleclicking an item, the item will first receive a mouse press event, followed by a release event (i.e., a click), then a double-click event, and finally a release event.\n\nCalling QEvent::ignore() or QEvent::accept() on event has no effect.\n\nThe default implementation calls mousePressEvent(). If you want to keep the base implementation when reimplementing this function, call QGraphicsItem::mouseDoubleClickEvent() in your reimplementation.\n\nNote that an item will not receive double click events if it is neither selectable nor movable (single mouse clicks are ignored in this case, and that stops the generation of double clicks).\n\nSee also mousePressEvent(), mouseMoveEvent(), mouseReleaseEvent(), and sceneEvent().\n\nThis event handler, for event event, can be reimplemented to receive mouse move events for this item. If you do receive this event, you can be certain that this item also received a mouse press event, and that this item is the current mouse grabber.\n\nCalling QEvent::ignore() or QEvent::accept() on event has no effect.\n\nThe default implementation handles basic item interaction, such as selection and moving. If you want to keep the base implementation when reimplementing this function, call QGraphicsItem::mouseMoveEvent() in your reimplementation.\n\nPlease note that mousePressEvent() decides which graphics item it is that receives mouse events. See the mousePressEvent() description for details.\n\nSee also mousePressEvent(), mouseReleaseEvent(), mouseDoubleClickEvent(), and sceneEvent().\n\nThis event handler, for event event, can be reimplemented to receive mouse press events for this item. Mouse press events are only delivered to items that accept the mouse button that is pressed. By default, an item accepts all mouse buttons, but you can change this by calling setAcceptedMouseButtons().\n\nThe mouse press event decides which item should become the mouse grabber (see QGraphicsScene::mouseGrabberItem()). If you do not reimplement this function, the press event will propagate to any topmost item beneath this item, and no other mouse events will be delivered to this item.\n\nIf you do reimplement this function, event will by default be accepted (see QEvent::accept()), and this item is then the mouse grabber. This allows the item to receive future move, release and double-click events. If you call QEvent::ignore() on event, this item will lose the mouse grab, and event will propagate to any topmost item beneath. No further mouse events will be delivered to this item unless a new mouse press event is received.\n\nThe default implementation handles basic item interaction, such as selection and moving. If you want to keep the base implementation when reimplementing this function, call QGraphicsItem::mousePressEvent() in your reimplementation.\n\nThe event is QEvent::ignore()d for items that are neither movable nor selectable.\n\nSee also mouseMoveEvent(), mouseReleaseEvent(), mouseDoubleClickEvent(), and sceneEvent().\n\nThis event handler, for event event, can be reimplemented to receive mouse release events for this item.\n\nCalling QEvent::ignore() or QEvent::accept() on event has no effect.\n\nThe default implementation handles basic item interaction, such as selection and moving. If you want to keep the base implementation when reimplementing this function, call QGraphicsItem::mouseReleaseEvent() in your reimplementation.\n\nPlease note that mousePressEvent() decides which graphics item it is that receives mouse events. See the mousePressEvent() description for details.\n\nSee also mousePressEvent(), mouseMoveEvent(), mouseDoubleClickEvent(), and sceneEvent().\n\nMoves the item by dx points horizontally, and dy point vertically. This function is equivalent to calling setPos(pos() + QPointF(dx, dy)).\n\nReturns this item's local opacity, which is between 0.0 (transparent) and 1.0 (opaque). This value is combined with parent and ancestor values into the effectiveOpacity(). The effective opacity decides how the item is rendered and also affects its visibility when queried by functions such as QGraphicsView::items().\n\nThe opacity property decides the state of the painter passed to the paint() function. If the item is cached, i.e., ItemCoordinateCache or DeviceCoordinateCache, the effective property will be applied to the item's cache as it is rendered.\n\nSee also setOpacity(), paint(), ItemIgnoresParentOpacity, and ItemDoesntPropagateOpacityToChildren.\n\nThis virtual function returns a shape representing the area where this item is opaque. An area is opaque if it is filled using an opaque brush or color (i.e., not transparent).\n\nThis function is used by isObscuredBy(), which is called by underlying items to determine if they are obscured by this item.\n\nThe default implementation returns an empty QPainterPath, indicating that this item is completely transparent and does not obscure any other items.\n\nSee also isObscuredBy(), isObscured(), and shape().\n\nThis function, which is usually called by QGraphicsView, paints the contents of an item in local coordinates.\n\nReimplement this function in a QGraphicsItem subclass to provide the item's painting implementation, using painter. The option parameter provides style options for the item, such as its state, exposed area and its level-of-detail hints. The widget argument is optional. If provided, it points to the widget that is being painted on; otherwise, it is 0. For cached painting, widget is always 0.\n\nThe painter's pen is 0-width by default, and its pen is initialized to the QPalette::Text brush from the paint device's palette. The brush is initialized to QPalette::Window.\n\nMake sure to constrain all painting inside the boundaries of boundingRect() to avoid rendering artifacts (as QGraphicsView does not clip the painter for you). In particular, when QPainter renders the outline of a shape using an assigned QPen, half of the outline will be drawn outside, and half inside, the shape you're rendering (e.g., with a pen width of 2 units, you must draw outlines 1 unit inside boundingRect()). QGraphicsItem does not support use of cosmetic pens with a non-zero width.\n\nAll painting is done in local coordinates.\n\nSee also setCacheMode(), QPen::width(), Item Coordinates, and ItemUsesExtendedStyleOption.\n\nReturns the item's panel, or if this item does not have a panel. If the item is a panel, it will return itself. Otherwise it will return the closest ancestor that is a panel.\n\nSee also isPanel() and ItemIsPanel.\n\nReturns the modality for this item.\n\nReturns a pointer to this item's parent item. If this item does not have a parent, is returned.\n\nSee also setParentItem() and childItems().\n\nReturns a pointer to the item's parent, cast to a QGraphicsObject. Returns if the parent item is not a QGraphicsObject.\n\nSee also parentItem() and childItems().\n\nReturns a pointer to the item's parent widget. The item's parent widget is the closest parent item that is a widget.\n\nSee also parentItem() and childItems().\n\nReturns the position of the item in parent coordinates. If the item has no parent, its position is given in scene coordinates.\n\nThe position of the item describes its origin (local coordinate (0, 0)) in parent coordinates; this function returns the same as mapToParent(0, 0).\n\nFor convenience, you can also call scenePos() to determine the item's position in scene coordinates, regardless of its parent.\n\nSee also x(), y(), setPos(), transform(), and The Graphics View Coordinate System.\n\nPrepares the item for a geometry change. Call this function before changing the bounding rect of an item to keep QGraphicsScene's index up to date.\n\nprepareGeometryChange() will call update() if this is necessary.\n\nRemoves an event filter on this item from filterItem.\n\nResets this item's transformation matrix to the identity matrix or all the transformation properties to their default values. This is equivalent to calling .\n\nSee also setTransform() and transform().\n\nReturns the clockwise rotation, in degrees, around the Z axis. The default value is 0 (i.e., the item is not rotated).\n\nThe rotation is combined with the item's scale(), transform() and transformations() to map the item's coordinate system to the parent item.\n\nSee also setRotation(), transformOriginPoint(), and Transformations.\n\nReturns the scale factor of the item. The default scale factor is 1.0 (i.e., the item is not scaled).\n\nThe scale is combined with the item's rotation(), transform() and transformations() to map the item's coordinate system to the parent item.\n\nSee also setScale(), rotation(), and Transformations.\n\nReturns the current scene for the item, or if the item is not stored in a scene.\n\nTo add or move an item to a scene, call QGraphicsScene::addItem().\n\nReturns the bounding rect of this item in scene coordinates, by combining sceneTransform() with boundingRect().\n\nSee also boundingRect() and The Graphics View Coordinate System.\n\nThis virtual function receives events to this item. Reimplement this function to intercept events before they are dispatched to the specialized event handlers contextMenuEvent(), focusInEvent(), focusOutEvent(), hoverEnterEvent(), hoverMoveEvent(), hoverLeaveEvent(), keyPressEvent(), keyReleaseEvent(), mousePressEvent(), mouseReleaseEvent(), mouseMoveEvent(), and mouseDoubleClickEvent().\n\nReturns if the event was recognized and handled; otherwise, (e.g., if the event type was not recognized,) false is returned.\n\nFilters events for the item watched. event is the filtered event.\n\nReimplementing this function in a subclass makes it possible for the item to be used as an event filter for other items, intercepting all the events sent to those items before they are able to respond.\n\nReimplementations must return true to prevent further processing of a given event, ensuring that it will not be delivered to the watched item, or return false to indicate that the event should be propagated further by the event system.\n\nReturns the item's position in scene coordinates. This is equivalent to calling .\n\nSee also pos(), sceneTransform(), and The Graphics View Coordinate System.\n\nReturns this item's scene transformation matrix. This matrix can be used to map coordinates and geometrical shapes from this item's local coordinate system to the scene's coordinate system. To map coordinates from the scene, you must first invert the returned matrix.\n\nUnlike transform(), which returns only an item's local transformation, this function includes the item's (and any parents') position, and all the transformation properties.\n\nSee also transform(), setTransform(), scenePos(), The Graphics View Coordinate System, and Transformations.\n\nScrolls the contents of rect by dx, dy. If rect is a null rect (the default), the item's bounding rect is scrolled.\n\nScrolling provides a fast alternative to simply redrawing when the contents of the item (or parts of the item) are shifted vertically or horizontally. Depending on the current transformation and the capabilities of the paint device (i.e., the viewport), this operation may consist of simply moving pixels from one location to another using memmove(). In most cases this is faster than rerendering the entire area.\n\nAfter scrolling, the item will issue an update for the newly exposed areas. If scrolling is not supported (e.g., you are rendering to an OpenGL viewport, which does not benefit from scroll optimizations), this function is equivalent to calling update(rect).\n\nNote: Scrolling is only supported when QGraphicsItem::ItemCoordinateCache is enabled; in all other cases calling this function is equivalent to calling update(rect). If you for sure know that the item is opaque and not overlapped by other items, you can map the rect to viewport coordinates and scroll the viewport.\n\nIf on is true, this item will accept drag and drop events; otherwise, it is transparent for drag and drop events. By default, items do not accept drag and drop events.\n\nIf enabled is true, this item will accept hover events; otherwise, it will ignore them. By default, items do not accept hover events.\n\nHover events are delivered when there is no current mouse grabber item. They are sent when the mouse cursor enters an item, when it moves around inside the item, and when the cursor leaves an item. Hover events are commonly used to highlight an item when it's entered, and for tracking the mouse cursor as it hovers over the item (equivalent to QWidget::mouseTracking).\n\nParent items receive hover enter events before their children, and leave events after their children. The parent does not receive a hover leave event if the cursor enters a child, though; the parent stays \"hovered\" until the cursor leaves its area, including its children's areas.\n\nIf a parent item handles child events, it will receive hover move, drag move, and drop events as the cursor passes through its children, but it does not receive hover enter and hover leave, nor drag enter and drag leave events on behalf of its children.\n\nA QGraphicsWidget with window decorations will accept hover events regardless of the value of acceptHoverEvents().\n\nSee also acceptHoverEvents(), hoverEnterEvent(), hoverMoveEvent(), and hoverLeaveEvent().\n\nIf enabled is true, this item will accept touch events; otherwise, it will ignore them. By default, items do not accept touch events.\n\nSets the mouse buttons that this item accepts mouse events for.\n\nBy default, all mouse buttons are accepted. If an item accepts a mouse button, it will become the mouse grabber item when a mouse press event is delivered for that button. However, if the item does not accept the mouse button, QGraphicsScene will forward the mouse events to the first item beneath it that does.\n\nTo disable mouse events for an item (i.e., make it transparent for mouse events), call setAcceptedMouseButtons(Qt::NoButton).\n\nSee also acceptedMouseButtons() and mousePressEvent().\n\nIf active is true, and the scene is active, this item's panel will be activated. Otherwise, the panel is deactivated.\n\nIf the item is not part of an active scene, active will decide what happens to the panel when the scene becomes active or the item is added to the scene. If true, the item's panel will be activated when the item is either added to the scene or the scene is activated. Otherwise, the item will stay inactive independent of the scene's activated state.\n\nSee also isPanel(), QGraphicsScene::setActivePanel(), and QGraphicsScene::isActive().\n\nSets the bounding region granularity to granularity; a value between and including 0 and 1. The default value is 0 (i.e., the lowest granularity, where the bounding region corresponds to the item's bounding rectangle).\n\nThe granularity is used by boundingRegion() to calculate how fine the bounding region of the item should be. The highest achievable granularity is 1, where boundingRegion() will return the finest outline possible for the respective device (e.g., for a QGraphicsView viewport, this gives you a pixel-perfect bounding region). The lowest possible granularity is 0. The value of granularity describes the ratio between device resolution and the resolution of the bounding region (e.g., a value of 0.25 will provide a region where each chunk corresponds to 4x4 device units / pixels).\n\nThe optional logicalCacheSize argument is used only by ItemCoordinateCache mode, and describes the resolution of the cache buffer; if logicalCacheSize is (100, 100), QGraphicsItem will fit the item into 100x100 pixels in graphics memory, regardless of the logical size of the item itself. By default QGraphicsItem uses the size of boundingRect(). For all other cache modes than ItemCoordinateCache, logicalCacheSize is ignored.\n\nCaching can speed up rendering if your item spends a significant time redrawing itself. In some cases the cache can also slow down rendering, in particular when the item spends less time redrawing than QGraphicsItem spends redrawing from the cache.\n\nWhen caching is enabled, an item's paint() function will generally draw into an offscreen pixmap cache; for any subsequent repaint requests, the Graphics View framework will redraw from the cache. This approach works particularly well with QGLWidget, which stores all the cache as OpenGL textures.\n\nBe aware that QPixmapCache's cache limit may need to be changed to obtain optimal performance.\n\nYou can read more about the different cache modes in the CacheMode documentation.\n\nSee also cacheMode(), CacheMode, and QPixmapCache::setCacheLimit().\n\nSets the current cursor shape for the item to cursor. The mouse cursor will assume this shape when it's over this item. See the list of predefined cursor objects for a range of useful shapes.\n\nAn editor item might want to use an I-beam cursor:\n\nIf no cursor has been set, the cursor of the item beneath is used.\n\nSee also cursor(), hasCursor(), unsetCursor(), QWidget::cursor, and QGuiApplication::overrideCursor().\n\nSets this item's custom data for the key key to value.\n\nCustom item data is useful for storing arbitrary properties for any item. Qt does not use this feature for storing data; it is provided solely for the convenience of the user.\n\nIf enabled is true, the item is enabled; otherwise, it is disabled.\n\nDisabled items are visible, but they do not receive any events, and cannot take focus nor be selected. Mouse events are discarded; they are not propagated unless the item is also invisible, or if it does not accept mouse events (see acceptedMouseButtons()). A disabled item cannot become the mouse grabber, and as a result of this, an item loses the grab if it becomes disabled when grabbing the mouse, just like it loses focus if it had focus when it was disabled.\n\nDisabled items are traditionally drawn using grayed-out colors (see QPalette::Disabled).\n\nIf you disable a parent item, all its children will also be disabled. If you enable a parent item, all children will be enabled, unless they have been explicitly disabled (i.e., if you call setEnabled(false) on a child, it will not be re-enabled if its parent is disabled, and then enabled again).\n\nIf enabled is true, this item is set to filter all events for all its children (i.e., all events intended for any of its children are instead sent to this item); otherwise, if enabled is false, this item will only handle its own events. The default value is false.\n\nIf enabled is true, the item flag flag is enabled; otherwise, it is disabled.\n\nSee also flags() and setFlags().\n\nSets the item flags to flags. All flags in flags are enabled; all flags not in flags are disabled.\n\nIf the item had focus and flags does not enable ItemIsFocusable, the item loses focus as a result of calling this function. Similarly, if the item was selected, and flags does not enabled ItemIsSelectable, the item is automatically unselected.\n\nBy default, no flags are enabled. (QGraphicsWidget enables the ItemSendsGeometryChanges flag by default in order to track position changes.)\n\nSee also flags() and setFlag().\n\nGives keyboard input focus to this item. The focusReason argument will be passed into any focus event generated by this function; it is used to give an explanation of what caused the item to get focus.\n\nOnly enabled items that set the ItemIsFocusable flag can accept keyboard focus.\n\nIf this item is not visible, not active, or not associated with a scene, it will not gain immediate input focus. However, it will be registered as the preferred focus item for its subtree of items, should it later become visible.\n\nAs a result of calling this function, this item will receive a focus in event with focusReason. If another item already has focus, that item will first receive a focus out event indicating that it has lost input focus.\n\nSee also clearFocus(), hasFocus(), focusItem(), and focusProxy().\n\nIf an item has a focus proxy, the focus proxy will receive input focus when the item gains input focus. The item itself will still have focus (i.e., hasFocus() will return true), but only the focus proxy will receive the keyboard input.\n\nA focus proxy can itself have a focus proxy, and so on. In such case, keyboard input will be handled by the outermost focus proxy.\n\nThe focus proxy item must belong to the same scene as this item.\n\nSee also focusProxy(), setFocus(), and hasFocus().\n\nSets effect as the item's effect. If there already is an effect installed on this item, QGraphicsItem will delete the existing effect before installing the new effect. You can delete an existing effect by calling setGraphicsEffect( ).\n\nIf effect is the installed effect on a different item, setGraphicsEffect() will remove the effect from the item and install it on this item.\n\nAdds this item to the item group group. If group is , this item is removed from any current group and added as a child of the previous group's parent.\n\nSee also group() and QGraphicsScene::createItemGroup().\n\nSets the current input method hints of this item to hints.\n\nSee also inputMethodHints() and inputMethodQuery().\n\nSets this item's local opacity, between 0.0 (transparent) and 1.0 (opaque). The item's local opacity is combined with parent and ancestor opacities into the effectiveOpacity().\n\nBy default, opacity propagates from parent to child, so if a parent's opacity is 0.5 and the child is also 0.5, the child's effective opacity will be 0.25.\n\nThe opacity property decides the state of the painter passed to the paint() function. If the item is cached, i.e., ItemCoordinateCache or DeviceCoordinateCache, the effective property will be applied to the item's cache as it is rendered.\n\nThere are two item flags that affect how the item's opacity is combined with the parent: ItemIgnoresParentOpacity and ItemDoesntPropagateOpacityToChildren.\n\nSee also opacity(), effectiveOpacity(), and setVisible().\n\nSets the modality for this item to panelModality.\n\nSets this item's parent item to newParent. If this item already has a parent, it is first removed from the previous parent. If newParent is 0, this item will become a top-level item.\n\nNote that this implicitly adds this graphics item to the scene of the parent. You should not add the item to the scene yourself.\n\nThe behavior when calling this function on an item that is an ancestor of newParent is undefined.\n\nSee also parentItem() and childItems().\n\nSets the position of the item to pos, which is in parent coordinates. For items with no parent, pos is in scene coordinates.\n\nThe position of the item describes its origin (local coordinate (0, 0)) in parent coordinates.\n\nSee also pos(), scenePos(), and The Graphics View Coordinate System.\n\nThis is an overloaded function.\n\nThis convenience function is equivalent to calling setPos(QPointF(x, y)).\n\nSets the clockwise rotation angle, in degrees, around the Z axis. The default value is 0 (i.e., the item is not rotated). Assigning a negative value will rotate the item counter-clockwise. Normally the rotation angle is in the range (-360, 360), but it's also possible to assign values outside of this range (e.g., a rotation of 370 degrees is the same as a rotation of 10 degrees).\n\nThe item is rotated around its transform origin point, which by default is (0, 0). You can select a different transformation origin by calling setTransformOriginPoint().\n\nThe rotation is combined with the item's scale(), transform() and transformations() to map the item's coordinate system to the parent item.\n\nSee also rotation(), setTransformOriginPoint(), and Transformations.\n\nSets the scale factor of the item. The default scale factor is 1.0 (i.e., the item is not scaled). A scale factor of 0.0 will collapse the item to a single point. If you provide a negative scale factor, the item will be flipped and mirrored (i.e., rotated 180 degrees).\n\nThe item is scaled around its transform origin point, which by default is (0, 0). You can select a different transformation origin by calling setTransformOriginPoint().\n\nThe scale is combined with the item's rotation(), transform() and transformations() to map the item's coordinate system to the parent item.\n\nSee also scale(), setTransformOriginPoint(), and Transformations Example.\n\nIf selected is true and this item is selectable, this item is selected; otherwise, it is unselected.\n\nIf the item is in a group, the whole group's selected state is toggled by this function. If the group is selected, all items in the group are also selected, and if the group is not selected, no item in the group is selected.\n\nOnly visible, enabled, selectable items can be selected. If selected is true and this item is either invisible or disabled or unselectable, this function does nothing.\n\nBy default, items cannot be selected. To enable selection, set the ItemIsSelectable flag.\n\nThis function is provided for convenience, allowing individual toggling of the selected state of an item. However, a more common way of selecting items is to call QGraphicsScene::setSelectionArea(), which will call this function for all visible, enabled, and selectable items within a specified area on the scene.\n\nSee also isSelected() and QGraphicsScene::selectedItems().\n\nSets the item's tool tip to toolTip. If toolTip is empty, the item's tool tip is cleared.\n\nSee also toolTip() and QToolTip.\n\nIf combine is true, then matrix is combined with the current matrix; otherwise, matrix replaces the current matrix. combine is false by default.\n\nTo simplify interaction with items using a transformed view, QGraphicsItem provides mapTo... and mapFrom... functions that can translate between items' and the scene's coordinates. For example, you can call mapToScene() to map an item coordinate to a scene coordinate, or mapFromScene() to map from scene coordinates to item coordinates.\n\nThe transformation matrix is combined with the item's rotation(), scale() and transformations() into a combined transformation that maps the item's coordinate system to its parent.\n\nSee also transform(), setRotation(), setScale(), setTransformOriginPoint(), The Graphics View Coordinate System, and Transformations.\n\nSets the origin point for the transformation in item coordinates.\n\nSee also transformOriginPoint() and Transformations.\n\nThis is an overloaded function.\n\nSets the origin point for the transformation in item coordinates. This is equivalent to calling setTransformOriginPoint(QPointF(x, y)).\n\nSee also setTransformOriginPoint() and Transformations.\n\nSets a list of graphics transformations (QGraphicsTransform) that currently apply to this item.\n\nIf all you want is to rotate or scale an item, you should call setRotation() or setScale() instead. If you want to set an arbitrary transformation on an item, you can call setTransform().\n\nQGraphicsTransform is for applying and controlling a chain of individual transformation operations on an item. It's particularly useful in animations, where each transform operation needs to be interpolated independently, or differently.\n\nThe transformations are combined with the item's rotation(), scale() and transform() to map the item's coordinate system to the parent item.\n\nSee also transformations(), scale(), setTransformOriginPoint(), and Transformations.\n\nIf visible is true, the item is made visible. Otherwise, the item is made invisible. Invisible items are not painted, nor do they receive any events. In particular, mouse events pass right through invisible items, and are delivered to any item that may be behind. Invisible items are also unselectable, they cannot take input focus, and are not detected by QGraphicsScene's item location functions.\n\nIf an item becomes invisible while grabbing the mouse, (i.e., while it is receiving mouse events,) it will automatically lose the mouse grab, and the grab is not regained by making the item visible again; it must receive a new mouse press to regain the mouse grab.\n\nSimilarly, an invisible item cannot have focus, so if the item has focus when it becomes invisible, it will lose focus, and the focus is not regained by simply making the item visible again.\n\nIf you hide a parent item, all its children will also be hidden. If you show a parent item, all children will be shown, unless they have been explicitly hidden (i.e., if you call setVisible(false) on a child, it will not be reshown even if its parent is hidden, and then shown again).\n\nItems are visible by default; it is unnecessary to call setVisible() on a new item.\n\nSee also isVisible(), show(), hide(), and setOpacity().\n\nSet's the x coordinate of the item's position. Equivalent to calling setPos(x, y()).\n\nSee also x() and setPos().\n\nSet's the y coordinate of the item's position. Equivalent to calling setPos(x(), y).\n\nSee also y(), x(), and setPos().\n\nSets the Z-value of the item to z. The Z value decides the stacking order of sibling (neighboring) items. A sibling item of high Z value will always be drawn on top of another sibling item with a lower Z value.\n\nIf you restore the Z value, the item's insertion order will decide its stacking order.\n\nThe Z-value does not affect the item's size in any way.\n\nSee also zValue(), Sorting, stackBefore(), and ItemStacksBehindParent.\n\nReturns the shape of this item as a QPainterPath in local coordinates. The shape is used for many things, including collision detection, hit tests, and for the QGraphicsScene::items() functions.\n\nThe default implementation calls boundingRect() to return a simple rectangular shape, but subclasses can reimplement this function to return a more accurate shape for non-rectangular items. For example, a round item may choose to return an elliptic shape for better collision detection. For example:\n\nThe outline of a shape can vary depending on the width and style of the pen used when drawing. If you want to include this outline in the item's shape, you can create a shape from the stroke using QPainterPathStroker.\n\nThis function is called by the default implementations of contains() and collidesWithPath().\n\nSee also boundingRect(), contains(), prepareGeometryChange(), and QPainterPathStroker.\n\nShows the item (items are visible by default).\n\nThis convenience function is equivalent to calling .\n\nSee also hide() and setVisible().\n\nStacks this item before sibling, which must be a sibling item (i.e., the two items must share the same parent item, or must both be toplevel items). The sibling must have the same Z value as this item, otherwise calling this function will have no effect.\n\nBy default, all sibling items are stacked by insertion order (i.e., the first item you add is drawn before the next item you add). If two items' Z values are different, then the item with the highest Z value is drawn on top. When the Z values are the same, the insertion order will decide the stacking order.\n\nSee also setZValue(), ItemStacksBehindParent, and Sorting.\n\nReturn the graphics item cast to a QGraphicsObject, if the class is actually a graphics object, 0 otherwise.\n\nReturn the graphics item cast to a QGraphicsObject, if the class is actually a graphics object, 0 otherwise.\n\nReturns the item's tool tip, or an empty QString if no tool tip has been set.\n\nSee also setToolTip() and QToolTip.\n\nReturns this item's top-level item. The top-level item is the item's topmost ancestor item whose parent is . If an item has no parent, its own pointer is returned (i.e., a top-level item is its own top-level item).\n\nReturns a pointer to the item's top level widget (i.e., the item's ancestor whose parent is , or whose parent is not a widget), or if this item does not have a top level widget. If the item is its own top level widget, this function returns a pointer to the item itself.\n\nThe transformation matrix is combined with the item's rotation(), scale() and transformations() into a combined transformations for the item.\n\nThe default transformation matrix is an identity matrix.\n\nSee also setTransform() and sceneTransform().\n\nReturns the origin point for the transformation in item coordinates.\n\nSee also setTransformOriginPoint() and Transformations.\n\nReturns a list of graphics transforms that currently apply to this item.\n\nQGraphicsTransform is for applying and controlling a chain of individual transformation operations on an item. It's particularly useful in animations, where each transform operation needs to be interpolated independently, or differently.\n\nThe transformations are combined with the item's rotation(), scale() and transform() to map the item's coordinate system to the parent item.\n\nSee also setTransformations(), scale(), rotation(), transformOriginPoint(), and Transformations.\n\nReturns the type of an item as an int. All standard graphicsitem classes are associated with a unique value; see QGraphicsItem::Type. This type information is used by qgraphicsitem_cast() to distinguish between types.\n\nTo enable use of qgraphicsitem_cast() with a custom item, reimplement this function and declare a Type enum value equal to your custom item's type. Custom items must return a value larger than or equal to UserType (65536).\n\nSee also grabKeyboard() and ungrabMouse().\n\nSee also grabMouse() and ungrabKeyboard().\n\nClears the cursor from this item.\n\nSee also hasCursor() and setCursor().\n\nSchedules a redraw of the area covered by rect in this item. You can call this function whenever your item needs to be redrawn, such as if it changes appearance or size.\n\nThis function does not cause an immediate paint; instead it schedules a paint request that is processed by QGraphicsView after control reaches the event loop. The item will only be redrawn if it is visible in any associated view.\n\nAs a side effect of the item being repainted, other items that overlap the area rect may also be repainted.\n\nIf the item is invisible (i.e., isVisible() returns ), this function does nothing.\n\nSee also paint() and boundingRect().\n\nThis is an overloaded function.\n\nThis convenience function is equivalent to calling update(QRectF(x, y, width, height)).\n\nThis event handler, for event event, can be reimplemented to receive wheel events for this item. If you reimplement this function, event will be accepted by default.\n\nIf you ignore the event, (i.e., by calling QEvent::ignore(),) it will propagate to any item beneath this item. If no items accept the event, it will be ignored by the scene, and propagate to the view (e.g., the view's vertical scroll bar).\n\nReturns the item's window, or if this item does not have a window. If the item is a window, it will return itself. Otherwise it will return the closest ancestor that is a window.\n\nThis convenience function is equivalent to calling pos().x().\n\nSee also setX() and y().\n\nThis convenience function is equivalent to calling pos().y().\n\nSee also setY() and x().\n\nReturns the Z-value of the item. The Z-value affects the stacking order of sibling (neighboring) items.\n\nSee also setZValue(), Sorting, stackBefore(), and ItemStacksBehindParent."
    },
    {
        "link": "https://pythonguis.com/tutorials/pyqt6-qgraphics-vector-graphics",
        "document": "The Qt Graphics View Framework allows you to develop fast and efficient 2D vector graphic scenes. Scenes can contain millions of items, each with their own features and behaviors. By using the Graphics View via PyQt you get access to this highly performant graphics layer in Python. Whether you're integrating vector graphics views into an existing PyQt application, or simply want a powerful vector graphics interface for Python, Qt's Graphics View is what you're looking for.\n\nSome common uses of the Graphics View include data visualization, mapping applications, 2D design tools, modern data dashboards and even 2D games.\n\nIn this tutorial we'll take our first steps looking at the Qt Graphics View framework, building a scene with some simple vector items. This will allow us to familiarize ourselves with the API and coordinate system, which we'll use later to build more complex examples.\n\nThe Graphics View framework consists of 3 main parts , , and , each with different responsibilities.\n\nThe framework can be interpreted using the Model-View paradigm, with the as the Model and the as the View. Each scene can have multiple views. The QGraphicsItems within the scene can be considered as items within the model, holding the visual data that the scene combines to define the complete image.\n\nis the central component that glues everything together. It acts as a whiteboard on which all items are drawn (circles, rectangles, lines, pixmaps, etc). The has the responsibility of rendering a given scene -- or part of it, with some transformation (scaling, rotating, shearing) -- to display it to the user. The view is a standard Qt widget and can be placed inside any Qt layout.\n\nprovides some important functionalities out of the box, so we can use them to develop advanced applications without struggling with low-level details. For example --\n• Collision Detection, detect a graphics item is collided with another item.\n• Item Selection, gives us the ability to deal with multiple items at the same time, for example, the user can select multiple items, and when pressing delete, a function asks the scene to give the list for all selected items, and then delete them.\n• Items discovery, the scene can tell us what items are present (or part of them) at a specific point or inside some defined region, for example, if the user adds an item that intersects with a forbidden area, the program will detect them and give them another (mostly red) color.\n• Events Propagation, the scene receives the events and then propagates them to items.\n\nTo define a you define it's boundaries or sceneRect which defines the x & y origins and dimensions of the scene. If you don't provide a sceneRect it will default to the minimum bounding rectangle for all child items -- updating as items are added, moved or removed. This is flexible but less efficient.\n\nItems in the scene are represented by objects. These are the basic building block of any 2D scene, representing a shape, pixmap or SVG image to be displayed in the scene. Each item has a relative position inside the and can have different transformation effects (scale, translate, rotate, shear).\n\nFinally, the is the renderer of the scene, taking the scene and displaying it -- either wholly or in part -- to the user. The view itself can have transformations (scale, translate, rotate and shear) applied to modify the display without affecting the underlying scene. By default the view will forward mouse and keyboard events to the scene allowing for user interaction. This can be disabled by calling .\n\nLet's start by creating a simple scene. The following code creates , defining a 400 x 200 scene, and then displays it in a .\n\nIf you run this example you'll see an empty window.\n\nNot very exciting yet -- but this is our displaying our empty scene.\n\nAs mentioned earlier, is a widget. In Qt any widgets without a parent display as windows. This is why our appears as a window on the desktop.\n\nLet's start adding some items to the scene. There are a number of built-in graphics items which you can customize and add to your scene. In the example below we use which draws a rectangle. We create the item passing in it's dimensions, and then set it's position pen and brush before adding it to the scene.\n\nRunning the above you'll see a single, rather ugly colored, rectangle in the scene.\n\nAdding more items is simply a case of creating the objects, customizing them and then adding them to the scene. In the example below we add an circle, using -- a circle is just an ellipse with equal height and width.\n\nThe above code will give the following result.\n\nThe order you add items affects the stacking order in the scene -- items added later will always appear on top of items added first. However, if you need more control you can set the stacking order using .\n\nNow the circle (ellipse) appears above the rectangle.\n\nUsing Zvalue to order items in the scene\n\nTry experimenting with setting the Z value of the two items -- you can set it before or after the items are in the scene, and can change it at any time.\n\nZ in this context refers to the Z coordinate. The X & Y coordinates are the horizontal and vertical position in the scene respectively. The Z coordinate determines the relative position of items toward the front and back of the scene -- coming \"out\" of the screen towards the viewer.\n\nThere are also the convenience methods and which allow you to stack your behind, or in front of another item in the scene.\n\nOur two objects are currently fixed in position where we place them, but they don't have to be! As already mentioned Qt's Graphics View framework allows items to respond to user input, for example allowing them to be dragged and dropped around the scene at will. Simple functionality like is actually already built in, you just need to enable it on each . To do that we need to set the flag on the item.\n\nThe full list of graphics item flags is available here.\n\nIn the above example we've set on the ellipse only. You can drag the ellipse around the scene -- including behind the rectangle -- but the rectangle itself will remain locked in place. Experiment with adding more items and configuring the moveable status.\n\nIf you want an item to be selectable you can enable this by setting the flag, for example here using to set multiple flags at the same time.\n\nIf you click on the ellipse you'll now see it surrounded by a dashed line to indicate that it is selected. We'll look at how to use item selection in more detail in a later tutorial.\n\nA selected item in the scene, highlighted with dashed lines\n\nAnother way to create objects.\n\nSo far we've been creating items by creating the objects and then adding them to the scene. But you can also create an object in the scene directly by calling one of the helper methods on the scene itself, e.g. . This creates the object and returns it so you can modify it as before.\n\nFeel free to use whichever form you find most comfortable in your code.\n\nYou can only use this approach for the built-in object types.\n\nSo far we've built a simple scene using the basic and shapes. Now let's use some other objects to build a more complex scene, including lines, text and (images).\n\nIf you run the example above you'll see the following scene.\n\nLet's step through the code looking at the interesting bits.\n\nPolygons are defined using a series of objects which give the coordinates relative to the items position. So, for example if you create a polygon object with a point at 30, 20 and then move this polygon object X & Y coordinates 50, 40 then the point will be displayed at 80, 60 in the scene.\n\nPoints inside an item are always relative to the item itself, and item coordinates are always relative to the scene -- or the item's parent, if it has one. We'll take a closer look at the Graphics View coordinate system in the next tutorial.\n\nTo add an image to the scene we can open it from a file using . This creates a object, which can then in turn add to the scene using . This returns a which is the type for the pixmap -- a wrapper than handles displaying the pixmap in the scene. You can use this object to perform any changes to item in the scene.\n\nThe multiple layers of objects can get confusing, so it's important to choose sensible variable names which make clear the distinction between, e.g. the pixmap itself and the pixmap item that contains it.\n\nFinally, we set the flag on the view to smooth the edges of diagonal lines. You almost always want to enable this on your views as otherwise any rotated objects will look very ugly indeed. Below is our scene without antialiasing enabled, you can see the jagged lines on the polygon.\n\nAntialiasing has a (small) performance impact however, so if you are building scenes with millions of rotated items it may in some cases make sense to turn it off.\n\nThe is subclassed from , meaning it can be placed in layouts just like any other widget. In the following example we add the view to a simple interface, with buttons which perform a basic effect on the view -- raising and lowering selected item's ZValue. This has the effect of allowing us to move items in front and behind other objects.\n\nThe full code is given below.\n\nIf you run this, you will get a window like that shown below. By selecting an item in the graphics view and then clicking either the \"Up\" or \"Down\" button you can move items up and down within the scene -- behind and in front of one another. The items are all moveable, so you can drag them around too. Clicking on the slider will rotate the currently selected items by the set number of degrees.\n\nThe raising and lowering is handled by our custom methods and , which work by iterating over the currently selected items in the scene -- retrieved using and then getting the items z value and increasing or decreasing it respectively.\n\nWhile rotation is handled using the method. This receives the current angle from the and again, applies it to any currently selected items in the scene.\n\nTake a look at the QGraphicsItem documentation for some other properties you can control with widgets and try extending the interface to allow you to change them dynamically.\n\nHopefully this quick introduction to the Qt Graphics View framework has given you some ideas of what you can do with it. In the next tutorials we'll look at how events and user interaction can be handled on items and how to create custom & compound items for your own scenes."
    },
    {
        "link": "https://stackoverflow.com/questions/78610243/pyqt6-handle-events-on-qgraphicsitem",
        "document": "While, in theory, it could be possible to send a mouse event even to hidden items, it would be wrong to do so, other than difficult and probably either inefficient or unreliable (or both): you'd need to iterate through all items in the scene, including hidden ones, then determine if they are \"normally\" hidden or they should still react to mouse events; then, if the event is not accepted, you should send it to the next one in the scene item stack; and that's for any mouse movement, which is also extremely inefficient considering that it would be done in Python.\n\n As you can see, it's not a good choice.\n\nJust like it happens with events for hidden widgets, the same goes with hidden QGraphicsItems:\n\nSince Qt visibility actually involves other aspects, and, in reality, you just want to make the item not visible but still available for collision detection (including mouse events), the solution is actually quite obvious: if you don't want to see it, don't paint it.\n\nYou're already overriding the function, so you just need to actually paint it only if required. This can be achieved with a custom private flag, and possibly using a dedicated function that resembles :\n\nYou could obviously do that by overwriting (which would not be a real override, unlike the QWidget counterpart), but it's usually better to use separate functions for such purposes.\n\nIn any case, if you still want to use for simplicity, remember that if you then want to use the default behavior (making it actually hidden or visible for Qt and its events), you should then call the default implementation instead ( ):\n\nAbout your mouse move/release note (which is based on your original code), the issue was caused by overriding and still calling the default implementation. Since the default behavior ignores mouse button presses, similarly to widgets, the item will not receive further move or release events. If you want to receive such further events, the press event must be accepted. If you still want to call the default implementation, ensure that you call after doing so.\n\nNote that it makes little point to subclass QGraphicsItem for QPolygonF, since Qt already provides QGraphicsPolygonItem. Your implementation is also inaccurate, since it doesn't properly consider the indications about the pen width, possibly causing painting artifacts (\"ghosts\") if the item geometry changes and even while scrolling, especially if the view uses scaling transforms.\n\n Then, you could still implement the above, but more easily. Here is a more accurate and efficient version of your item (excluding mouse button event handlers):\n\nFinally, if you want a \"fake-gray\" grid pattern made of white and black pixels, setting each pixel color is extremely inefficient (especially considering the Python bottleneck).\n\n Qt already provides such basic patterns with , so you just need to use a QPainter on the pixmap along with :"
    },
    {
        "link": "https://pythonguis.com/tutorials/pyqt-qgraphics-vector-graphics",
        "document": "The Qt Graphics View Framework allows you to develop fast and efficient 2D vector graphic scenes. Scenes can contain millions of items, each with their own features and behaviors. By using the Graphics View via PyQt5 you get access to this highly performant graphics layer in Python. Whether you're integrating vector graphics views into an existing PyQt5 application, or simply want a powerful vector graphics interface for Python, Qt's Graphics View is what you're looking for.\n\nSome common uses of the Graphics View include data visualization, mapping applications, 2D design tools, modern data dashboards and even 2D games.\n\nIn this tutorial we'll take our first steps looking at the Qt Graphics View framework, building a scene with some simple vector items. This will allow us to familiarize ourselves with the API and coordinate system, which we'll use later to build more complex examples.\n\nThe Graphics View framework consists of 3 main parts , , and , each with different responsibilities.\n\nThe framework can be interpreted using the Model-View paradigm, with the as the Model and the as the View. Each scene can have multiple views. The QGraphicsItems within the scene can be considered as items within the model, holding the visual data that the scene combines to define the complete image.\n\nis the central component that glues everything together. It acts as a whiteboard on which all items are drawn (circles, rectangles, lines, pixmaps, etc). The has the responsibility of rendering a given scene -- or part of it, with some transformation (scaling, rotating, shearing) -- to display it to the user. The view is a standard Qt widget and can be placed inside any Qt layout.\n\nprovides some important functionalities out of the box, so we can use them to develop advanced applications without struggling with low-level details. For example --\n• Collision Detection, detect a graphics item is collided with another item.\n• Item Selection, gives us the ability to deal with multiple items at the same time, for example, the user can select multiple items, and when pressing delete, a function asks the scene to give the list for all selected items, and then delete them.\n• Items discovery, the scene can tell us what items are present (or part of them) at a specific point or inside some defined region, for example, if the user adds an item that intersects with a forbidden area, the program will detect them and give them another (mostly red) color.\n• Events Propagation, the scene receives the events and then propagates them to items.\n\nTo define a you define it's boundaries or sceneRect which defines the x & y origins and dimensions of the scene. If you don't provide a sceneRect it will default to the minimum bounding rectangle for all child items -- updating as items are added, moved or removed. This is flexible but less efficient.\n\nItems in the scene are represented by objects. These are the basic building block of any 2D scene, representing a shape, pixmap or SVG image to be displayed in the scene. Each item has a relative position inside the and can have different transformation effects (scale, translate, rotate, shear).\n\nFinally, the is the renderer of the scene, taking the scene and displaying it -- either wholly or in part -- to the user. The view itself can have transformations (scale, translate, rotate and shear) applied to modify the display without affecting the underlying scene. By default the view will forward mouse and keyboard events to the scene allowing for user interaction. This can be disabled by calling .\n\nLet's start by creating a simple scene. The following code creates , defining a 400 x 200 scene, and then displays it in a .\n\nIf you run this example you'll see an empty window.\n\nNot very exciting yet -- but this is our displaying our empty scene.\n\nAs mentioned earlier, is a widget. In Qt any widgets without a parent display as windows. This is why our appears as a window on the desktop.\n\nLet's start adding some items to the scene. There are a number of built-in graphics items which you can customize and add to your scene. In the example below we use which draws a rectangle. We create the item passing in it's dimensions, and then set it's position pen and brush before adding it to the scene.\n\nRunning the above you'll see a single, rather ugly colored, rectangle in the scene.\n\nAdding more items is simply a case of creating the objects, customizing them and then adding them to the scene. In the example below we add an circle, using -- a circle is just an ellipse with equal height and width.\n\nThe above code will give the following result.\n\nThe order you add items affects the stacking order in the scene -- items added later will always appear on top of items added first. However, if you need more control you can set the stacking order using .\n\nNow the circle (ellipse) appears above the rectangle.\n\nUsing Zvalue to order items in the scene\n\nTry experimenting with setting the Z value of the two items -- you can set it before or after the items are in the scene, and can change it at any time.\n\nZ in this context refers to the Z coordinate. The X & Y coordinates are the horizontal and vertical position in the scene respectively. The Z coordinate determines the relative position of items toward the front and back of the scene -- coming \"out\" of the screen towards the viewer.\n\nThere are also the convenience methods and which allow you to stack your behind, or in front of another item in the scene.\n\nOur two objects are currently fixed in position where we place them, but they don't have to be! As already mentioned Qt's Graphics View framework allows items to respond to user input, for example allowing them to be dragged and dropped around the scene at will. Simple functionality like is actually already built in, you just need to enable it on each . To do that we need to set the flag on the item.\n\nThe full list of graphics item flags is available here.\n\nIn the above example we've set on the ellipse only. You can drag the ellipse around the scene -- including behind the rectangle -- but the rectangle itself will remain locked in place. Experiment with adding more items and configuring the moveable status.\n\nIf you want an item to be selectable you can enable this by setting the flag, for example here using to set multiple flags at the same time.\n\nIf you click on the ellipse you'll now see it surrounded by a dashed line to indicate that it is selected. We'll look at how to use item selection in more detail in a later tutorial.\n\nA selected item in the scene, highlighted with dashed lines\n\nAnother way to create objects.\n\nSo far we've been creating items by creating the objects and then adding them to the scene. But you can also create an object in the scene directly by calling one of the helper methods on the scene itself, e.g. . This creates the object and returns it so you can modify it as before.\n\nFeel free to use whichever form you find most comfortable in your code.\n\nYou can only use this approach for the built-in object types.\n\nSo far we've built a simple scene using the basic and shapes. Now let's use some other objects to build a more complex scene, including lines, text and (images).\n\nIf you run the example above you'll see the following scene.\n\nLet's step through the code looking at the interesting bits.\n\nPolygons are defined using a series of objects which give the coordinates relative to the items position. So, for example if you create a polygon object with a point at 30, 20 and then move this polygon object X & Y coordinates 50, 40 then the point will be displayed at 80, 60 in the scene.\n\nPoints inside an item are always relative to the item itself, and item coordinates are always relative to the scene -- or the item's parent, if it has one. We'll take a closer look at the Graphics View coordinate system in the next tutorial.\n\nTo add an image to the scene we can open it from a file using . This creates a object, which can then in turn add to the scene using . This returns a which is the type for the pixmap -- a wrapper than handles displaying the pixmap in the scene. You can use this object to perform any changes to item in the scene.\n\nThe multiple layers of objects can get confusing, so it's important to choose sensible variable names which make clear the distinction between, e.g. the pixmap itself and the pixmap item that contains it.\n\nFinally, we set the flag on the view to smooth the edges of diagonal lines. You almost always want to enable this on your views as otherwise any rotated objects will look very ugly indeed. Below is our scene without antialiasing enabled, you can see the jagged lines on the polygon.\n\nAntialiasing has a (small) performance impact however, so if you are building scenes with millions of rotated items it may in some cases make sense to turn it off.\n\nThe is subclassed from , meaning it can be placed in layouts just like any other widget. In the following example we add the view to a simple interface, with buttons which perform a basic effect on the view -- raising and lowering selected item's ZValue. This has the effect of allowing us to move items in front and behind other objects.\n\nThe full code is given below.\n\nIf you run this, you will get a window like that shown below. By selecting an item in the graphics view and then clicking either the \"Up\" or \"Down\" button you can move items up and down within the scene -- behind and in front of one another. The items are all moveable, so you can drag them around too. Clicking on the slider will rotate the currently selected items by the set number of degrees.\n\nThe raising and lowering is handled by our custom methods and , which work by iterating over the currently selected items in the scene -- retrieved using and then getting the items z value and increasing or decreasing it respectively.\n\nWhile rotation is handled using the method. This receives the current angle from the and again, applies it to any currently selected items in the scene.\n\nTake a look at the QGraphicsItem documentation for some other properties you can control with widgets and try extending the interface to allow you to change them dynamically.\n\nHopefully this quick introduction to the Qt Graphics View framework has given you some ideas of what you can do with it. In the next tutorials we'll look at how events and user interaction can be handled on items and how to create custom & compound items for your own scenes."
    }
]