[
    {
        "link": "https://docs.unity3d.com/Manual/class-CharacterController.html",
        "document": "The Character Controller is mainly used for third-person or first-person player control that does not make use of RigidbodyA component that allows a GameObject to be affected by simulated gravity and other forces. More info\n\nSee in Glossary physics.\n\nThe traditional Doom-style first person controls are not physically realistic. The character runs 90 miles per hour, comes to a halt immediately and turns on a dime. Because it is so unrealistic, use of Rigidbodies and physics to create this behavior is impractical and will feel wrong. The solution is the specialized Character Controller. It is simply a capsule shaped ColliderAn invisible shape that is used to handle physical collisions for an object. A collider doesn’t need to be exactly the same shape as the object’s mesh - a rough approximation is often more efficient and indistinguishable in gameplay. More info\n\nSee in Glossary which can be told to move in some direction from a script. The Controller will then carry out the movement but be constrained by collisionsA collision occurs when the physics engine detects that the colliders of two GameObjects make contact or overlap, when at least one has a Rigidbody component and is in motion. More info\n\nSee in Glossary. It will slide along walls, walk up stairs (if they are lower than the Step Offset) and walk on slopes within the Slope Limit.\n\nThe Controller does not react to forces on its own and it does not automatically push Rigidbodies away.\n\nIf you want to push Rigidbodies or objects with the Character Controller, you can apply forces to any object that it collides with via the OnControllerColliderHit() function through scripting.\n\nOn the other hand, if you want your player character to be affected by physics then you might be better off using a Rigidbody instead of the Character Controller.\n\nYou can modify the Height and Radius to fit your Character’s meshThe main graphics primitive of Unity. Meshes make up a large part of your 3D worlds. Unity supports triangulated or Quadrangulated polygon meshes. Nurbs, Nurms, Subdiv surfaces must be converted to polygons. More info\n\nSee in Glossary. It is recommended to always use around 2 meters for a human-like character. You can also modify the Center of the capsule in case your pivot point is not at the exact center of the Character.\n\nStep Offset can affect this too, make sure that this value is between 0.1 and 0.4 for a 2 meter sized human.\n\nSlope Limit should not be too small. Often using a value of 90 degrees works best. The Character Controller will not be able to climb up walls due to the capsule shape.\n\nThe Skin Width is one of the most critical properties to get right when tuning your Character Controller. If your character gets stuck it is most likely because your Skin Width is too small. The Skin Width will let objects slightly penetrate the Controller but it removes jitter and prevents it from getting stuck.\n\nIt’s good practice to keep your Skin Width at least greater than 0.01 and more than 10% of the Radius.\n\nSee the Character Controller script reference here\n• Try adjusting your Skin Width if you find your character getting stuck frequently.\n• The Character Controller can affect objects using physics if you write your own scripts \n\n A piece of code that allows you to create your own Components, trigger game events, modify Component properties over time and respond to user input in any way you like. More info .\n• The Character Controller can not be affected by objects through physics.\n• Note that changing Character Controller properties in the inspector \n\n A Unity window that displays information about the currently selected GameObject, asset or project settings, allowing you to inspect and edit the values. More info will recreate the controller in the scene \n\n A Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info , so any existing Trigger contacts will get lost, and you will not get any OnTriggerEntered messages until the controller is moved again.\n• The Character Controller’s capsule used in queries such as raycast might shrink by a small factor. Queries therefore could miss in some corner cases, even when they appear to hit the Character Controller’s gizmo \n\n A graphic overlay associated with a GameObject in a Scene, and displayed in the Scene View. Built-in scene tools such as the move tool are Gizmos, and you can create custom Gizmos using textures or scripting. Some Gizmos are only drawn when the GameObject is selected, while other Gizmos are drawn by the Editor regardless of which GameObjects are selected. More info ."
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/CharacterController.html",
        "document": "Suggest a change Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable. Close For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation. Close Switch to Manual\n\nA CharacterController allows you to easily do movement constrained by collisions without having to deal with a rigidbody.\n\nA CharacterController is not affected by forces and will only move when you call the Move function. It will then carry out the movement but be constrained by collisions.\n\n\n\nAdditional resources: Character Controller component and Character animation examples"
    },
    {
        "link": "https://discussions.unity.com/t/how-to-correctly-setup-3d-character-movement-in-unity/811250",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/jumping-with-character-controller-component/802995",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/character-controller-and-movement-issues/903529",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/state-machine-using-all-monobehaviours-bad-idea/901037",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/state-machine-behaviour-best-practices/781104",
        "document": ""
    },
    {
        "link": "https://medium.com/@akb1ggs/structuring-your-unity-monobehaviours-df090b587110",
        "document": "MonoBehaviours, the basic scripts that you write in Unity projects, are often cluttered with functions that are called implicitly and public fields that are accessed and set through the inspector. They quickly become disorganized, making them hard to trace through and understand from the perspective of a developer new to Unity. To fight against this, here are some conventions that I set in the structure of my MonoBehaviours, annotated side-by-side with an example.\n• Document your MonoBehaviours with a quick description at the top. This will make it easy for people to understand what responsibilities your behaviour has when diving through the codebase.\n• If you use GetComponent within your class, annotate the class with the RequireComponent attribute to make this dependency explicit. This will help avoid script setup errors, as the inspector will automatically add the required component when you attach your script to an object, and warn the user when they try to remove a required component. However, be warned that it will not add the component to objects which already have the script attached.\n• Place your constants and static members at the very top of the file. Use constants for any animator parameters that are referenced throughout the file, to ensure that if the parameter name changes, the value in code only needs to be updated in one location that is easy to reference.\n• Group your fields that are exposed within the Unity Inspector sidebar(e.g. public fields or fields annotated with [SerializeField]), into a region called “Unity Inspector Fields”. This will make it very explicit which fields can be configured inside the editor, and help keep your file organized.\n• Document your inspector fields with the Tooltip annotation. Due to the limited amount of display space in the inspector, longer names are often cut off. A simple tooltip goes a long way towards resolving any name ambiguities, making your script easy to reuse.\n• Group your private fields together after the inspector fields. If you end up using a lot of private fields, look into reorganizing the classes to divide up the responsibilities, or separate out groups of fields related to different tasks with a line of whitespace.\n• I like placing properties after fields, before methods, since they are syntax sugar for methods but are used like fields. This is completely personal preference.\n• Annotate any Unity lifecycle methods(Start, Awake, Update, OnDestroy etc.), event methods, and other functions that are implicitly(or automatically) invoked in your code with the [UsedImplicitly] attribute. This attribute, although included in the UnityEngine.dll, is used by ReSharper to disable code cleanup suggestions for methods that are seemingly unreferenced. It also helps to make the code easier to read for people who are newer to Unity and your codebase, especially for events that are referenced via the inspector.\n• Use Awake for hooking up references to other dependencies, e.g. calls to GetComponent, GetComponentInChildren, FindObject etc., and Start for actual startup logic. This ensures that any scripts you access in Start will have all their references hooked up.\n• Not used in the example code, but good to follow anyways: If a field does not need to be public, but you want to control it through the inspector, use the [SerializeField] attribute to expose the field in the editor instead. This will ensure that the public interface for your script is kept as small as possible, which in turn ensures that other scripts can’t mess with your state and break your script.\n\nIt might seem like a fair amount of bloat initially, but I found that sticking to these practices has really made life easier for other developers when rolling them on to large existing Unity codebases. Let me know what you think!\n\nThere’s a good discussion thread for this post on r/gamedev."
    },
    {
        "link": "https://discussions.unity.com/t/general-performance-optimization-tips-for-unity/616926",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/unity/comments/17kdqae/is_it_a_bad_idea_to_use_a_monobehavior_for_each",
        "document": "Hello everyone. I’ve been working on the AI for enemies in a 2D platformer and I had a question regarding how I should organize the code.\n\nCurrently, all states inherit from a base “EnemyState” class that doesn’t inherit from anything. This has worked pretty well, but with how many enemy types are in the game (around 30), it’s been getting a bit annoying to work with.\n\nMany enemies in the game will reuse certain states such as patrol, knockback, stun, etc. but have different property values in them. For these type values I’ve been using ScriptableObjects.\n\nLet’s say Enemy1 and Enemy2 both use the patrol state, but Enemy1 will have a speed of 3 and Enemy2 will have a speed of 1.5. I have a scriptable object called PatrolData that contains information like “Walk speed” “Acceleration” etc and instantiate one for each enemy type with its proper values. This works fine but the problem is that needing to make a scriptable object for each state and then an instance of it for each enemy type that uses said state feels inefficient.\n\nMy proposed solution was to convert EnemyState into being a Monobavior and adding them and their values to the enemy in the inspector. This would remove the need for the ScriptableObjects and make it easier for states that require the use of child objects. Is this an ok solution or is it advised I avoid this idea?\n\nTo note, I wouldn’t be using any of Monobehaviors built in functions like Update or LateUpdate. I would only use Monobehavior as a means of letting myself edit values in the inspector. Also each enemy type only has around 3-5 states. Any suggestions would be appreciated. Thank you!\n\nEdit: Another reason why I was considering this idea is so that I can reuse code more often. Let’s say I have 2 enemy types that both use the same attack, knockback, and stun states, but one uses the patrol state as its neutral and the other uses idle. Rather than needing to have 2 classes that each create either a patrol or idle EnemyState, I can simply have a “neutral state” value in one enemy class and add either the patrol or idle state in the inspector."
    }
]