[
    {
        "link": "https://st.com/resource/en/reference_manual/rm0008-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf",
        "document": ""
    },
    {
        "link": "https://github.com/MaJerle/stm32-usart-uart-dma-rx-tx",
        "document": "This application note contains explanation with examples for distinct topics:\n• Data reception with UART and DMA when application does not know size of bytes to receive in advance\n• Data transmission with UART and DMA to avoid CPU stalling and use CPU for other purposes\n\nGithub supports ToC by default. It is available in the top-left corner of this document.\n\nUART in STM32 allows configurion using different transmit ( ) and receive ( ) modes:\n• Polling mode (no DMA, no IRQ)\n• P: Application is polling for status bits to check if any character has been transmitted/received and read it fast enough in order to not-miss any byte\n• C: Can easily miss received data in complex application if CPU cannot read registers quickly enough\n• C: Works only for low baudrates, or lower\n• Interrupt mode (no DMA)\n• P: UART triggers interrupt and CPU jumps to service routine to handle each received byte separately\n• P: Works well with common baudrates, , up to bauds\n• C: Interrupt service routine is executed for every received character\n• C: May decrease system performance if interrupts are triggered for every character for high-speed baudrates\n• DMA mode\n• DMA is used to transfer data from USART RX data register to user memory on hardware level. No application interaction is needed at this point except processing received data by application once necessary\n• P: Transfer from USART peripheral to memory is done on hardware level without CPU interaction\n• P: Can work very easily with operating systems\n• P: In case of big bursts of data, increasing data buffer size can improve functionality\n• C: Number of bytes to transfer must be known in advance by DMA hardware\n• C: If communication fails, DMA may not notify application about all bytes transferred\n\nEvery STM32 has at least one ( ) UART IP and at least one ( ) DMA controller available in its DNA. This is all we need for successful data transmission. Application uses default features to implement very efficient transmit system using DMA.\n\nWhile implementation happens to be pretty straight-forward for TX (set pointer to data, define its length and go) operation, this may not be the case for receive. Implementing DMA receive, application should understand number of received bytes to process by DMA before its considered done. However, UART protocol does not offer such information (it could work with higher-level protocol, but that's way another story that we don't touch here. We assume we have to implement very reliable low-level communication protocol).\n\nSTM32s have capability in UART to detect when RX line has not been active for period of time. This is achieved using methods:\n• IDLE LINE event: Triggered when RX line has been in idle state (normally high state) for frame time, after last received byte. Frame time is based on baudrate. Higher baudrate means lower frame time for single byte.\n• RTO (Receiver Timeout) event: Triggered when line has been in idle state for programmable time. It is fully configured by firmware.\n\nBoth events can trigger an interrupt which is an essential feature to allow effective receive operation\n\nAn example: To transmit byte at bauds, it takes approximately (for easier estimation) ; for it would be in total. IDLE line event triggers an interrupt when line has been in idle state for frame time (in this case ), after third byte has been received.\n\nThis is a real experiment demo using STM32F4 and IDLE LINE event. After IDLE event is triggered, data are echoed back (loopback mode):\n• RX goes to high state (yellow rectangle) and UART RX detects it has been idle for at least frame time (approx )\n\nDMA in STM32 can be configured in or mode. For each mode, DMA requires number of elements to transfer before its events (half-transfer complete, transfer complete) are triggered.\n• Normal mode: DMA starts with data transfer, once it transfers all elements, it stops and sets enable bit to .\n• Application is using this mode when transmitting data\n• Circular mode: DMA starts with transfer, once it transfers all elements (as written in corresponding length register), it starts from beginning of memory and transfers more\n• Applicaton is using this mode when receiving data\n\nWhile transfer is active, (among others) interrupts may be triggered:\n\nNow it is time to understand which features to use to receive data with UART and DMA to offload CPU. As for the sake of this example, we use memory buffer array of bytes. DMA will transfer data received from UART to this buffer.\n\nListed are steps to begin. Initial assumption is that UART has been initialized prior reaching this step, same for basic DMA setup, the rest:\n• Application puts DMA to circular mode. This is to assure DMA does not stop transferring data after it reaches end of memory. Instead, it will roll over and continue with transferring possible more data from UART to memory\n• Application enables DMA & UART in reception mode. Receive can not start & DMA will wait UART to receive first character and transmit it to array. This is done for every received byte\n• Application is notified by DMA event (or interrupt) after first have been transferred from UART to memory\n• Application is notified by DMA event (or interrupt) after bytes are transferred from UART to memory\n• Application is notified by UART IDLE line (or RTO) in case of IDLE line or timeout detected on RX line\n• Application needs to reach on all of these events for most efficient receive\n\nEverything gets simplier when application transmits data, length of data is known in advance and memory to transmit is ready. For the sake of this example, we use memory for message. In C language it would be:\n• Application writes number of bytes to transmit to relevant DMA register, that would be or\n• Application sets DMA to normal mode. This effectively disables DMA once all the bytes are successfully transferred\n• Application enables DMA & UART in transmitter mode. Transmit starts immediately when UART requests first byte via DMA to be shifted to UART TX register\n• Application is notified by event (or interrupt) after all bytes have been transmitted from memory to UART via DMA\n• DMA is stopped and application may prepare next transfer immediately\n\nThis section describes possible cases and one additional which explains why HT/TC events are necessary by application\n\nAbbrevations used for the image:\n• : ead pointer, used by application to read data from memory. Later also used as\n• : rite pointer, used by DMA to write next byte to. Increased every time DMA writes new byte. Later also used as\n• bytes data length\n• Consequently event gets triggered at bytes being transmitted\n• Consequently event gets triggered at bytes being transmitted\n• Case A: DMA transfers bytes. Application gets notification with event and may process received data\n• Case B: DMA transfers next bytes. Application gets notification thanks to event. Processing now starts from last known position until the end of memory\n• DMA is in circular mode, thus it will continue right from beginning of the buffer, on top of the picture\n• Case C: DMA transfers bytes, but not aligned with nor events\n• Application gets notified with event when first bytes are transfered. Processing may start from last known read location\n• Application receives line event after next bytes are successfully transfered to memory\n• Case D: DMA transfers bytes in overflow mode and but not aligned with nor events\n• Application gets notification by event when first bytes are transfered. Processing may start from last known read location\n• Application gets notification by event after next bytes are transfered. Processing may start from beginning of buffer\n• Case E: Example what may happen when application relies only on event\n• If application receives bytes in burst, bytes get overwritten by DMA as application did not process it quickly enough\n• Application gets line event once there is steady RX line for byte timeframe\n• Red part of data represents first received bytes from burst which were overwritten by last bytes in burst\n• Option to avoid such scenario is to poll for DMA changes quicker than burst of bytes take; or by using and events\n\nExample code to read data from memory and process it, for cases A-D\n\n* \\brief Check for new data received with DMA * User must select context to call this function from: * - Only interrupts (DMA HT, DMA TC, UART IDLE) with same preemption priority level * If called from both context-es, exclusive access protection must be implemented * This mode is not advised as it usually means architecture design problems * When IDLE interrupt is not present, application must rely only on thread context, * by manually calling function as quickly as possible, to make sure * data are read from raw buffer and processed. * Not doing reads fast enough may cause DMA to overflow unread received bytes, * hence application will lost useful data. * - Increase raw buffer size and allow DMA to write more data before this function is called ( ) { * Linker should (with default C configuration) set this variable to `0`. * It is used to keep latest read start position, * transforming this function to not being reentrant or thread-safe ; ; /* Calculate current position in buffer and check for new data available */ ( ) ( , ); ( ) { ( ) { /* Current position is over previous one */ * Processing is done in \"linear\" mode. ( [ ], ); } { * Processing is done in \"overflow\" mode.. * since there are 2 linear memory blocks to handle ( [ ], ( ) ); ( ) { ( [ ], ); } } ; /* Save current position as old for next transfers */ } }\n\nThanks to Cortex-M NVIC's (Nested Vectored Interrupt Controller) flexibility, user can configure priority level for each of the NVIC interrupt lines; it has full control over execution profile for each of the interrupt lines separately.\n\nThere are priority types in Cortex-M:\n• Preemption priority: Interrupt with higher logical priority level can preempt already running lower priority interrupt\n• Subpriority: Interrupt with higher subpriority (but same preemption priority) will execute first when (or more) interrupt lines become active at the same time; such interrupt will also never stop currently executed interrupt (if any) by the CPU.\n\nSTM32s have different interrupt lines (interrupt service routines later too) for DMA and UART, one for each peripheral and its priority could be software configurable.\n\nFunction that gets called to process received data must keep position of last read value, hence processing function is not thread-safe or reentrant and requires special attention.\n\nExamples can be used as reference code to implement your own DMA TX and RX functionality.\n\nThere are 2 sets of examples:\n• Examples for RX only\n• Available in folder with prefix\n• DMA is used to receive data, polling is used to echo data back\n• Examples for RX & TX\n• DMA is used to receive data and to transmit data back\n• It uses ring buffer to copy data from DMA buffer to application before it is sent back\n• Developed in STM32CubeIDE for easier evaluation on STM32 boards\n• Fully developed using LL drivers for various STM32 families\n• All RX examples implement loop-back functionality. Every character received by UART and transfered by DMA is sent back to same UART\n\nExamples demonstrate different use cases for RX only or RX&TX combined.\n• Application must constantly poll for new changes in DMA registers and read received data quick enough to make sure DMA will not overwrite data in buffer\n• Processing of received data is in thread mode (not in interrupt)\n• P: No interrupts, no consideration of priority and race conditions\n• C: Not possible to put application to low-power mode (sleep mode)\n• Same as polling for changes but with dedicated thread in operating system to process data\n• P: Easy to implement to RTOS systems, uses single thread without additional RTOS features (no mutexes, semaphores, memory queues)\n• P: No interrupts, no consideration of priority and race conditions\n• P: Data processing always on-time with maximum delay given by thread delay, thus with known maximum latency between received character and processed time\n• C: Uses memory resources dedicated for separate thread for data processing\n• C: Not possible to put application to low-power mode (sleep mode)\n• Application gets notification by IDLE line detection or DMA TC/HT events\n• Application has to process data only when it receives any of the interrupts\n• P: Application does not need to poll for new changes\n• P: Application may enter low-power modes to increase battery life (if operated on battery)\n• C: Data are read (processed) in the interrupt. We strive to execute interrupt routine as fast as possible\n• C: Long interrupt execution may break other compatibility in the application\n\nProcessing of incoming data is from 2 interrupt vectors, hence it is important that they do not preempt each-other. Set both to the same preemption priority!\n• Application gets notification by IDLE line detection or DMA TC/HT events\n• Application uses separate thread to process the data only when notified in one of interrupts\n• P: Processing is not in the interrupt but in separate thread\n• P: Interrupt only informs processing thread to process (or to wakeup)\n• P: Operating system may put processing thread to blocked state while waiting for event\n• C: Memory usage for separate thread + message queue (or semaphore)\n• Application is using DMA in normal mode to transfer data\n• Application is always using ringbuffer between high-level write and low-level transmit operation\n• DMA TC interrupt is triggered when transfer has finished. Application can then send more data\n\nThis is a demo application available in folder. Its purpose is to show how can application implement output of debug messages without drastically affect CPU performance. It is using DMA to transfer data (no CPU to wait for UART flags) and can achieve very high or very low data rates\n• All debug messages from application are written to intermediate ringbuffer\n• Application will try to start & configure DMA after every successfive write to ringbuffer\n• If transfer is on-going, next start is configured from DMA TC interrupt\n\nAs a result of this demo application for STM32F413-Nucleo board, observations are as following:\n• Demo code sends bytes every second at bauds, which is approx .\n• With DMA disabled, CPU load was , in-line with time to transmit the data\n• DMA can be enabled/disabled with macro configuration in"
    },
    {
        "link": "https://st.com/resource/en/application_note/an2548-introduction-to-dma-controller-for-stm32-mcus-stmicroelectronics.pdf",
        "document": ""
    },
    {
        "link": "https://electronics.stackexchange.com/questions/131525/stm32-usart-with-dma-which-interrupts-to-use",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://deepbluembedded.com/stm32-dma-tutorial-using-direct-memory-access-dma-in-stm32",
        "document": "In this tutorial, we’ll discuss the direct memory access unit (DMA) in STM32 microcontrollers. We’ll begin with an introduction for what is a DMA unit, when, and why to use it. Afterward, we’ll start discussing the STM32 DMA hardware, its features, and how to configure it in your projects. And some example applications that we’ll be building throughout this course.\n\nA Direct Memory Access (DMA) unit is a digital logic element in computer architecture that can be used in conjunction with the main microprocessor on the same chip in order to offload the memory transfer operations. This significantly reduces the CPU load. As the DMA controller can perform memory to memory data transfers as well as peripheral to memory data transfers or vice versa. The existence of DMA with a CPU can accelerate its throughput by orders of magnitude.\n\nIn no-DMA computer architecture, you’d find it looking something like this shown in the diagram below.\n\nAs you can see, the CPU (main processor) has to do all the work of fetching instructions (code) from flash, executing the decoded instructions, and move data to and from peripherals and memory. Imagine having a UART1 data receiver that gets a stream of data that the CPU has to immediately transfer to a local buffer in memory so as not to lose any data packet. This translates into an insane number of interrupts per second being fired by different peripherals like UART, SPI, ADC, etc. And the CPU has to juggle everything and lose more and more time.\n\nThe fact that switching the context to and from interrupt handlers takes up some cycles that are completely wasted and periodically happens as interrupt signals are getting fired continuously is what makes this architecture problematic to an extent. Having a data stream of 10kB/s can make a CPU without a DMA be so busy and miss up the timing constraints for the application. The CPU can be seen as if it’s suppressed, and to unleash its full working power this data transfer task has to be handed over to another unit and here it comes the DMA unit to offload these exhausting data transactions from the CPU.\n\nAs you can see in the diagram above, the existence of the DMA unit can now direct the data stream coming from the UART peripheral directly to the memory while the CPU doing other stuff and calculations. This parallel cooperation between the CPU and the DMA is where the acceleration stems from.\n\nThe existence of the DMA unit can sometimes introduce some issues. For example, in an architecture that has a CPU cache when the DMA unit accesses the data memory and writes to a location that is also mirrored in the cache, this will invalidate the data in cache memory. This a challenge to overcome, and there are other but it’ll be a topic for a future article. I just wanted to spot some light on this point, besides being advantageous the DMA can also introduce some issues.\n\nDirect memory access (DMA) is used in order to provide high-speed data transfer between peripherals and memory as well as memory to memory. Data can be quickly moved by DMA without any CPU actions. This keeps CPU resources free for other operations.\n\nThe two DMA controllers have 12 channels in total (7 for DMA1 and 5 for DMA2), each dedicated to managing memory access requests from one or more peripherals. It has an arbiter for handling the priority between DMA requests.\n\nThe DMA controller performs direct memory transfer by sharing the system bus with the Cortex®-M3 core. The DMA request may stop the CPU access to the system bus for some bus cycles when the CPU and DMA are targeting the same destination (memory or peripheral). The bus matrix implements round-robin scheduling, thus ensuring at least half of the system bus bandwidth (both to memory and peripheral) for the CPU.\n\nThe DMA Units In STM32F103 Have The Following Features\n• None 12 independently configurable channels (requests): 7 for DMA1 and 5 for DMA2\n• None Each of the 12 channels is connected to dedicated hardware DMA requests, software trigger is also supported on each channel. This configuration is done by software.\n• None Priorities between requests from channels of one DMA are software programmable (4 levels consisting of very high, high, medium, low) or hardware in case of equality (request 1 has priority over request 2, etc.)\n• None Independent source and destination transfer size (byte, half-word, word), emulating packing, and unpacking. Source/destination addresses must be aligned on the data size.\n• None 3 event flags (DMA Half Transfer, DMA Transfer complete and DMA Transfer Error) logically ORed together in a single interrupt request for each channel\n• None Access to Flash, SRAM, APB1, APB2 and AHB peripherals as source and destination\n• None Programmable number of data to be transferred: up to 65536\n\nAfter an event, the peripheral sends a request signal to the DMA Controller. The DMA controller serves the request depending on the channel priorities. As soon as the DMA Controller accesses the peripheral, an Acknowledge is sent to the peripheral by the DMA Controller. The peripheral releases its request as soon as it gets the Acknowledge from the DMA Controller. Once the request is de-asserted by the peripheral, the DMA Controller releases the Acknowledge. If there are more requests, the peripheral can initiate the next transaction.\n\nIn summary, each DMA transfer consists of three operations:\n• None The loading of data from the peripheral data register or a location in memory addressed through an internal current peripheral/memory address register. The start address used for the first transfer is the base peripheral/memory address programmed in the DMA_CPARx or DMA_CMARx register\n• None The storage of the data loaded to the peripheral data register or a location in memory addressed through an internal current peripheral/memory address register. The start address used for the first transfer is the base peripheral/memory address programmed in the DMA_CPARx or DMA_CMARx register\n• None The post-decrementing of the DMA_CNDTRx register, which contains the number of transactions that have still to be performed.\n\nThe arbiter manages the channel requests based on their priority and launches the peripheral/memory access sequences. The priorities are managed in two stages:\n• None Software: each channel priority can be configured in the DMA_CCRx register. There are four levels:\n• None Hardware: if 2 requests have the same software priority level, the channel with the lowest number will get priority versus the channel with the highest number. For example, channel 2 gets priority over channel 4.\n\nEach channel can handle DMA transfer between a peripheral register located at a fixed address and a memory address. The amount of data to be transferred (up to 65535) is programmable. The register which contains the amount of data items to be transferred is decremented after each transaction.\n\nThe transfer data sizes of the peripheral and memory are fully programmable through the PSIZE and MSIZE bits in the DMA_CCRx register.\n\nPeripheral and memory pointers can optionally be automatically post-incremented after each transaction depending on the PINC and MINC bits in the DMA_CCRx register. If incremented mode is enabled, the address of the next transfer will be the address of the previous one incremented by 1, 2, or 4 depending on the chosen data size.\n\nThe circular mode is available to handle circular buffers and continuous data flows (e.g. ADC scan mode). This feature can be enabled using the CIRC bit in the DMA_CCRx register. When the circular mode is activated, the number of data to be transferred is automatically reloaded with the initial value programmed during the channel configuration phase, and the DMA requests continue to be served.\n\nThe DMA channels can also work without being triggered by a request from a peripheral. This mode is called Memory to Memory mode. Memory to Memory mode may not be used at the same time as Circular mode.\n\nAn interrupt can be produced on a Half-transfer, Transfer complete, or Transfer error for each DMA channel. Separate interrupt enable bits are available for flexibility.\n\nThe peripheral DMA requests can be independently activated/de-activated by programming the DMA control bit in the registers of the corresponding peripheral.\n\nThe following sequence should be followed to configure a DMA CHANNELx (where x is the channel number).\n• None Set the peripheral register address in the DMA_CPARx register. The data will be moved from/ to this address to/ from the memory after the peripheral event.\n• None Set the memory address in the DMA_CMARx register. The data will be written to or read from this memory after the peripheral event.\n• None Configure the total number of data to be transferred in the DMA_CNDTRx register. After each peripheral event, this value will be decremented.\n• None Configure the channel priority using the PL[1:0] bits in the DMA_CCRx register\n• None Configure data transfer direction, circular mode, peripheral & memory incremented mode, peripheral & memory data size, and interrupt after half and/or full transfer in the DMA_CCRx register\n• None Activate the channel by setting the ENABLE bit in the DMA_CCRx register.\n\nAs soon as the channel is enabled, it can serve any DMA request from the peripheral connected on the channel. Once half of the bytes are transferred, the half-transfer flag (HTIF) is set and an interrupt is generated if the Half Transfer Interrupt Enable bit (HTIE) is set. At the end of the transfer, the Transfer Complete Flag (TCIF) is set and an interrupt is generated if the Transfer Complete Interrupt Enable bit (TCIE) is set.\n\nWe’ll be using the CubeMX software tool and the HAL APIs in order to configure the DMA units and programmatically set the buffer lengths, DMA source, destination, and all that stuff. The exact steps for each configuration will be discussed later on in the future tutorials in which DMA will be used.\n\nThere are several use cases for the DMA units in STM32 microcontrollers. We’ll implement some of them in the upcoming tutorials’ LABs and projects. However, here are a handful of possible scenarios:\n\nStay tuned for the upcoming tutorials and don’t forget to SHARE these tutorials. And consider SUPPORTING this work to keep publishing free content just like this!"
    },
    {
        "link": "https://community.element14.com/technologies/embedded/f/embedded-forum/50006/stm32l4-with-dmx512",
        "document": ""
    },
    {
        "link": "https://electronics.stackexchange.com/questions/397204/questions-about-dmx512-protocol-stm",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "http://emcu.it/STM32/Lighting-Control-using-DMX512-protocol-on-STM32/DOC/led_light_control_dmx512_marketing_pres.pdf",
        "document": ""
    },
    {
        "link": "https://community.st.com/t5/stm32-mcus-products/receive-dmx-512-in-stm32-usart-without-timer/td-p/530731",
        "document": "Perhaps because it has to synchronize data transmissions in the time domain to some reasonable precision.\n\nIf you can't use timers, look at using SysTick and the 32-bit instruction cycle (72 MHz) counter within the trace unit of the core for fine grain measurements.\n\nYou could also generate timing externally, or use some of the timers that don't do PWM"
    },
    {
        "link": "http://emcu.it/STM32/Lighting-Control-using-DMX512-protocol-on-STM32/Lighting-Control-using-DMX512-protocol-on-STM32.html",
        "document": "Besides standard illumination, a peculiar application in the lighting world is related to the control of lights in theatres, lighting stages e.g. during music concerts. \n\n The used lamps are motorized and a protocol called is adopted to remotely control them. \n\n It allows setting the light intensity, light color and lamp rotation and it is based on wired communication systems (twisted pairs + RS485 as PHY).\n\nThe makes the in a simple demonstrator that can be configured as transceiver, receiver or even in stand-alone mode as it embeds also 3 power LED directly driven."
    }
]