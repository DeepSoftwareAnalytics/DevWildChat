[
    {
        "link": "https://geeksforgeeks.org/floyd-warshall-algorithm-dp-16",
        "document": "The Floyd Warshall Algorithm is an all-pair shortest path algorithm that uses Dynamic Programming to find the shortest distances between every pair of vertices in a graph, unlike Dijkstra and Bellman-Ford which are single source shortest path algorithms. This algorithm works for both the directed and undirected weighted graphs and can handle graphs with both positive and negative weight edges. \n\n\n\nNote: It does not work for the graphs with negative cycles (where the sum of the edges in a cycle is negative).\n\nSuppose we have a graph graph[][] with V vertices from 0to V-1. Now we have to evaluate a dist[][] where dist[i][j] represents the shortest path between vertex i to j. Let us assume that vertices i to j have intermediate nodes. The idea behind Floyd Warshall algorithm is to treat each and every vertex k from 0 to V-1 as an intermediate node one by one. When we consider the vertex k, we must have considered vertices from 0 to k-1 already. So we use the shortest paths built by previous vertices to build shorter paths with vertex k included. The following figure shows the above optimal substructure property in Floyd Warshall algorithm:\n• None Initialize the solution matrix same as the input graph matrix as a first step.\n• None Then update the solution matrix by considering all vertices as an intermediate vertex.\n• None The idea is to pick all vertices one by one and updates all shortest paths which include the picked vertex as an intermediate vertex in the shortest path.\n• k as an intermediate vertex, we already have considered vertices {0, 1, 2, .. k-1}\n• (i, j) of the source and destination vertices respectively, there are two possible cases.\n• k is not an intermediate vertex in shortest path from i j . We keep the value of dist[i][j] as it is.\n• k is an intermediate vertex in shortest path from i j . We update the value of dist[i][j] dist[i][k] + dist[k][j], dist[i][j] > dist[i][k] + dist[k][j]\n\n// Add all vertices one by one to // Pick all vertices as source one by one // for the above picked source // If vertex k is on the shortest path from // i to j, then update the value of graph[i][j] // Add all vertices one by one to // Pick all vertices as source one by one // for the above picked source // If vertex k is on the shortest path from // i to j, then update the value of graph[i][j] # Add all vertices one by one to # Pick all vertices as source one by one # for the above picked source # If vertex k is on the shortest path from # i to j, then update the value of graph[i][j] // Add all vertices one by one to // Pick all vertices as source one by one // for the above picked source // If vertex k is on the shortest path from // i to j, then update the value of graph[i,j] // Add all vertices one by one to // Pick all vertices as source one by one // for the above picked source // If vertex k is on the shortest path from // i to j, then update the value of graph[i][j]\n\nTime Complexity: O(V3), where V is the number of vertices in the graph and we run three nested loops each of size V.\n\nAuxiliary Space: O(V2), to create a 2-D matrix in order to store the shortest distance for each pair of nodes.\n\nNote: The above program only prints the shortest distances. We can modify the solution to print the shortest paths also by storing the predecessor information in a separate 2D matrix.\n\nThe algorithm relies on the principle of optimal substructure, meaning:\n• None If the shortest path from i to j passes through some vertex k, then the path from i to k and the path from k to j must also be shortest paths.\n• None The iterative approach ensures that by the time vertex k is considered, all shortest paths using only vertices 0 to k-1 have already been computed.\n\nBy the end of the algorithm, all shortest paths are computed optimally because each possible intermediate vertex has been considered.\n\nWhy Floyd-Warshall Algorithm better for Dense Graphs and not for Sparse Graphs?\n\nDense Graph: A graph in which the number of edges are significantly much higher than the number of vertices.\n\nSparse Graph: A graph in which the number of edges are very much low. No matter how many edges are there in the graph the Floyd Warshall Algorithm runs for O(V3) times therefore it is best suited for Dense graphs. In the case of sparse graphs, Johnson’s Algorithm is more suitable.\n• None In computer networking, the algorithm can be used to find the shortest path between all pairs of nodes in a network. This is termed as network routing\n• None Flight Connectivity In the aviation industry to find the shortest path between the airports.\n• GIS Geographic Information Systems ) applications often involve analyzing spatial data, such as road networks, to find the shortest paths between locations.\n• None which is a generalization of floyd warshall, can be used to find regular expression for a regular language.\n• None How to Detect Negative Cycle in a graph using Floyd Warshall Algorithm?\n• None How is Floyd-warshall algorithm different from Dijkstra’s algorithm?\n• None How is Floyd-warshall algorithm different from Bellman-Ford algorithm?\n• None Shortest path with one curved edge in an undirected Graph\n• None 1st to Kth shortest path lengths in given Graph\n• None Number of ways to reach at destination in shortest time"
    },
    {
        "link": "https://programiz.com/dsa/floyd-warshall-algorithm",
        "document": "Floyd-Warshall Algorithm is an algorithm for finding the shortest path between all the pairs of vertices in a weighted graph. This algorithm works for both the directed and undirected weighted graphs. But, it does not work for the graphs with negative cycles (where the sum of the edges in a cycle is negative).\n\nFloyd-Warhshall algorithm is also called as Floyd's algorithm, Roy-Floyd algorithm, Roy-Warshall algorithm, or WFI algorithm.\n\nThis algorithm follows the dynamic programming approach to find the shortest paths.\n\nLet the given graph be:\n\nFollow the steps below to find the shortest path between all the pairs of vertices.\n• Create a matrix of dimension where n is the number of vertices. The row and the column are indexed as and respectively. and are the vertices of the graph.\n\n \n\n Each cell is filled with the distance from the vertex to the vertex. If there is no path from vertex to vertex, the cell is left as infinity. Fill each cell with the distance between ith and jth vertex\n• Now, create a matrix using matrix . The elements in the first column and the first row are left as they are. The remaining cells are filled in the following way.\n\n \n\n Let be the intermediate vertex in the shortest path from source to destination. In this step, is the first vertex. is filled with .\n\n \n\n That is, if the direct distance from the source to the destination is greater than the path through the vertex , then the cell is filled with .\n\n \n\n In this step, k is vertex 1. We calculate the distance from source vertex to destination vertex through this vertex k. Calculate the distance from the source vertex to destination vertex through this vertex k \n\n For example: For , the direct distance from vertex 2 to 4 is 4 and the sum of the distance from vertex 2 to 4 through vertex (ie. from vertex 2 to 1 and from vertex 1 to 4) is 7. Since , is filled with 4.\n• Similarly, is created using . The elements in the second column and the second row are left as they are.\n\n \n\n In this step, is the second vertex (i.e. vertex 2). The remaining steps are the same as in step 2. Calculate the distance from the source vertex to destination vertex through this vertex 2\n• Similarly, and is also created. Calculate the distance from the source vertex to destination vertex through this vertex 3 Calculate the distance from the source vertex to destination vertex through this vertex 4\n• gives the shortest path between each pair of vertices.\n\nThere are three loops. Each loop has constant complexities. So, the time complexity of the Floyd-Warshall algorithm is .\n\nThe space complexity of the Floyd-Warshall algorithm is .\n• To find the shortest path is a directed graph\n• To find the transitive closure of directed graphs\n• To find the Inversion of real matrices\n• For testing whether an undirected graph is bipartite"
    },
    {
        "link": "https://stackoverflow.com/questions/15540569/floyd-warshall-algorithm-for-shortest-path",
        "document": "There are several problems in your code:\n\nYour is local variable of the cycle which means the highest used mapping index doesn't survive to the next iteration, so the reading in next iteration overrides the previous one. So the distance matrix is not properly filled after data loading.\n\nSolution: move the outside from the loop.\n\nThe roads are bidirectional in the instructions, but you register them only as unidirectional. As the consequence of that are higher on non-existent connections between towns.\n\nSolution: add right after the similar one.\n\nBesides these hard issues I have also couple hints for you. You do not have follow them but as if you want to improve your programming skills then you should think about them.\n\nYour code is hard to read, there are multiple restated information such as indicies, the solving process is in the single method etc. Such code is not only hard to read but also extremely hard to debug and fix. For your own good I recommend you to write it cleaner.\n\nFloyd-Warshall's algorithm has a complexity. The size of problem (amount of towns) is A-M = 13. In this complexity it makes iterations. I know, it might not seem to be a lot, but consider the amount of tasks to solve in a given time limit.\n\nI would recommend you to use Dijkstra's algorithm which has complexity . In this task the worst case with some simplification is . It means, that the final number of iterations is . If I am not wrong and made any mistake, this is significantly less, especially when we consider the total amount of tasks.\n\nI might be wrong but I attended multiple programming contests and competitions and it never forced attendees to work with files. An input was always redirected from files to a standard input. I guess, that the main reason for this is a security, but the simplification is probably also highly beneficial."
    },
    {
        "link": "https://happycoders.eu/algorithms/floyd-warshall-algorithm-java",
        "document": "In this series about pathfinding algorithms, you have read about Dijkstra's algorithm, the A* algorithm, and the Bellman-Ford algorithm. This last part will show you how the Floyd-Warshall algorithm works and what it is used for.\n\nI will address the following topics in detail:\n• What is the intended use of the Floyd-Warshall algorithm?\n• How does the Floyd-Warshall algorithm differ from the pathfinding algorithms presented so far?\n• How does the Floyd-Warshall algorithm work (explained step by step with an example)?\n• How to implement the Floyd-Warshall algorithm in Java?\n• How to determine the time complexity of the Floyd-Warshall algorithm?\n\nYou can find the source code for the entire article series on pathfinding algorithms in this GitHub repository.\n\nWhen to Use the Floyd-Warshall Algorithm?\n\nAll pathfinding algorithms presented so far find the shortest path from a single source node to a destination node (or to all other nodes of a graph).\n\nDijkstra prioritizes the search by total cost from the starting node. A* prioritizes additionally according to estimated remaining costs to the target. And Bellman-Ford does not prioritize at all but can handle negative edge weights.\n\nFloyd-Warshall, on the other hand, finds the shortest paths between all pairs of start and destination nodes (Floyd's variant).\n\nAlternatively, Floyd-Warshall computes the so-called \"transitive closure\" of a graph (Warshall's variant). The transitive closure extends a graph by edges between all indirectly connected pairs of nodes. For example, if the graph has two edges – one from A to B and one from B to C – then the transitive closure extends the graph by the edge from A to C (since a path from A to C via B exists).\n\nThe following graphic shows a somewhat more complex example with four nodes - the initial graph on the left and its transitive closure on the right. The blue arrows represent the added, indirect connections:\n\nBoth tasks are very similar: If a shortest path exists between two node pairs, then this node pair also belongs in the transitive closure – and vice versa. Therefore, the variants of Floyd and Warshall are combined into a single algorithm.\n\nHow Does the Floyd-Warshall Algorithm Work?\n\nThe algorithm is easy to implement, as you will see later. However, the explanation is a bit tricky. I will, therefore, first describe the algorithm with an example.\n\nThe following example graph contains five nodes, labeled A, B, C, D, E, and various directed and weighted edges:\n\nThe numbers on the edges (the edge weights) represent the costs for the respective path. For example, the cost from E to B is 4.\n\nIn preparation, we create an n × n matrix (n is the number of nodes) in which we enter – for each pair of nodes (i, j) – the weight of the edge from i to j if it exists. Otherwise, we enter infinity (∞). On the diagonal (the distance of a node to itself), we enter 0.\n\nFrom the table, we can read, for instance: The cost from A to B is 2 (row A, column B).\n\nWe now perform the following five iterations. In each case, we examine one of the nodes as a potential intermediate node.\n\nFor all node pairs (i, j), we compare the entered costs of the direct path with the costs of the indirect path from i to j via node A – i.e., the costs from node i to node A plus the costs from node A to node j (if such a path exists). If the costs via intermediate node A are lower than the previous ones, we replace the costs in the matrix.\n\nNode pairs where i = j or i = A or j = A can be skipped. The distance of a node to itself is always 0. And if start or destination are already A, there is not also an indirect path via A.\n\nWe thus start with the node pair (B, C). The cost of the direct path is 6 (row B, column C). There is currently no known path from B to A (row B, column A contains infinity). So we cannot find a shorter route via A in this step. Accordingly, we cannot find shorter paths for (B, D) and (B, E) via A.\n\nAlso, from C and D, there are currently no known paths to node A (column A contains infinity for both rows C and D). Thus, we cannot currently find shorter routes for (C, B), (C, D), (C, E), (D, B), (D, C), (D, E).\n\nAt the node pair (E, B), things start to get interesting. The current cost of the direct path E→B is 4. Is there a shorter route via node A? Here is the corresponding section of the graph:\n\nThe cost from E to A is 1 (row E, column A in the table); the cost from A to B is 2 (row A, column B). These add up to 3. The cost of the indirect path from E to B via node A is, therefore, lower than that of the direct path. So we have found the following, shorter path:\n\nWe, therefore, replace the 4 in row E, column B with a 3 (highlighted in bold in the table):\n\nNext, we examine node pair (E, C). The current cost is infinity since no path has been found yet. Is there an indirect path via A, i.e., E→A→C? Since no path from A to C is currently known (row A, column C contains infinity), the answer is \"no\".\n\nFinally, we look at the node pair (E, D). Since no path is known from A to D, we cannot find an indirect way E→A→D in this step.\n\nWe have examined all node pairs; step 1 is now complete. We now know the lowest cost for all node pairs if we also allow indirect paths via intermediate node A. In particular, we have found a shorter route from E to B via node A in this step.\n\nIn the second iteration, we compare the costs entered for all node pairs (i, j) (these are now either the costs of the direct path or those via intermediate node A – whichever is lower) with the costs from i to j via node B.\n\nWe read the costs to and from node B from the matrix. This means that these do not necessarily have to be the costs of the direct path to/from node B. It could also be the lower costs via intermediate node A determined in step 1 (e.g., from E to B: 3 via A instead of 4 directly).\n\nWe start with node pair (A, C). So far, no path has been found (row A, column C contains infinity). Let's look at the indirect route via B:\n\nThe cost from A to B is 2, and the cost from B to C is 6. The sum is 8. This is better than no path at all. We, therefore, enter the 8 in row A, column C:\n\nWe continue with node pair (A, D). Here, too, no path is known so far. Is there a route via intermediate node B? We have just read the costs from A to B as 2. From B to D, however, no path is known so far. Thus, we cannot determine any costs for route A→B→D, and the entry for node pair (A, D) remains unchanged (infinity).\n\nThe same happens with node pair (A, E): there is a path A→B, but no path B→E, hence no path A→B→E and therefore no new entry for node pair (A, E).\n\nWe come to the node pairs (C, A), (C, D), and (C, E): Currently, no path is known for all three pairs. There is a path C→B with a cost of 7, but there is no path from intermediate node B to A, to D, or E, so there can be no paths C→B→A, C→B→D, or C→B→E. Therefore, the entries for the three node pairs remain unchanged (infinity).\n\nNode pairs (D, A), (D, C), and (D, E): Since there is no path from node D to intermediate node B, we cannot find any (or any shorter) paths for these three node pairs either.\n\nNode pair (E, A): There is a path from E to B, but none from B to A, hence no path E→B→A.\n\nNode pair (E, C) provides some momentum again: Currently, no path is known. Is there a route via B? There is a path E→B with a cost of 3 and a path B→C with a cost of 6. Thus, there is a path from E via B to C with a total cost of 9. We enter the 9 in row E, column C:\n\nNote that this does not mean that the route from E to C has to go only via node B. After all, the path from E to B with cost 3 also goes via node A (which we had found in step 1). Strictly speaking, we have now found the path E→A→B→C:\n\nLet us examine the last node pair in this iteration: (E, D). Does a route exist via intermediate node B? There is a path E→B with cost 3, but no path B→D, so there is no path E→B→D.\n\nThe second iteration is finished. We now know the lowest cost for all node pairs if we also allow indirect paths via node B – and indirectly via node A.\n\nWe repeat the whole thing: Now, we compare for all node pairs the entered costs with those via intermediate node C. The costs to/from node C, which we again read from the matrix, can be those of the direct path to/from node C – but also the costs of indirect routes via node A and/or B determined in the previous iterations.\n\nWe start with node pair (A, B). The costs from A to intermediate node C are 8 (we had found this path via B at the beginning of the second iteration). The cost from C to B is 7. The way via intermediate node C thus has a total cost of 8 + 7 = 15. This route is significantly longer than the one currently stored with a cost of 2. You can also see this clearly in the graph: The path A→B is, of course, significantly shorter than A→B→C→B. We, therefore, leave the entry for (A, B) at 2.\n\nNode pairs (A, D) and (A, E): We have just read the costs for A→C, but there are no paths C→D or C→E, so there are none from A via C to D or from A via C to E, respectively.\n\nNode pair (B, A), (B, D), (B, E): the cost from B to C is 6, but from C, there is no path to A, to D, or E. Thus, in this iteration, we do not find any of the paths B→C→A, B→C→D, and B→C→E.\n\nNode pair (D, A): There is a path from D to C, but none from C to A, thus none from D via C to A.\n\nThe cost of the node pair (D, B) is currently infinity, i.e., no path is known. That will change now. There is a path D→C with a cost of 1 and a path C→B with a cost of 7, which adds up to 8:\n\nWe thus enter 8 in row D, column B:\n\nNode pair (D, E): There is no known path from intermediate node C to E; thus, we do not find a way from D via C to E in this iteration.\n\nNode pairs (E, A) and (E, D): Since there are no paths from intermediate node C to A or D, we currently cannot find a path from E via C to A or from E via C to D respectively.\n\nNode pair (E, B): The cost for path E→C is 9, the cost for C→B is 7. In sum, 16. For path E→B, a cost of 3 is already stored. 16 is worse, so we leave the 3 unchanged.\n\nArriving at the end of iteration 3, we know the lowest cost for all node pairs if we also allow indirect paths via node C – and thus via A and B as well.\n\nWe can abbreviate iteration 4: There is no path from any node to intermediate node D. Thus, we will not find a route via D for any node pair.\n\nIn the last iteration, we check for all node pairs if we can find a shorter path via intermediate node E.\n\nWe can handle the node pairs with start nodes A, B, and C quickly: There is no path from any of these nodes to intermediate node E, so we will not find a route via E for any of these node pairs.\n\nNode pair (D, A): the cost of path D→E is 3, and the cost of E→A is 1. Thus, there exists a path from D via E to A with a total cost of 4:\n\nWe enter the 4 in row D, column A:\n\nNode pair (D, B): The cost for the path D→E is still 3, the cost for E→B is also 3. Results in a total of 6. We have thus found a path from D via E to B with a total cost of 6. Currently, a total cost of 8 is entered here. We replace the 8 by 6:\n\nThis case is again an example of the fact that the path via intermediate node E is not the direct path D→E→B, but in fact D→E→A→B, since the shortest path from E to B is via A (we had found the path E→A→B in the first iteration):\n\nThe final node pair is (D, C): the cost for path D→E is still 3, the cost for E→C is 9. Results in a total of 12. That is worse than the cost of 1 currently stored for (D, C), which we thus let stand.\n\nWe have reached the end of the fifth iteration and now know the lowest cost for all node pairs if we also allow indirect paths via node E (and thus also via A, B, C, D) – that is, via any other nodes.\n\nThe goal of the algorithm is thus achieved.\n\nWhat is a negative cycle? And why does it pose a problem? I answered these questions in the article about the Bellman-Ford algorithm. This link leads directly to the corresponding section.\n\nA negative cycle from any node will cause the cost from that node to itself to be negative. The Floyd-Warshall algorithm makes it very easy for us to see this. We can read the cost of all nodes to themselves directly from the matrix diagonal. Here is the matrix from the example above after running through all iterations:\n\nThe diagonal line (highlighted in bold) contains only zeros. That means that there is no negative cycle.\n\nIf there were a negative number in at least one field on the diagonal, a negative cycle would be detected. The algorithm would then terminate with an error message.\n\nIn its basic form described above, the Floyd-Warshall algorithm calculates only the cost of the shortest paths between two nodes but not the paths themselves (i.e., over which intermediate nodes the shortest path passes).\n\nHowever, one can extend the algorithm easily so that determining the shortest path between two nodes is possible.\n\nFor this, we need a second matrix of size n × n, the so-called \"successor matrix\". Here we initially enter, for each node pair (i, j), the respective end node j . That means that the path from i to j initially goes via the successor j.\n\nAs soon as we find a shorter path via intermediate node k for any pair (i, j), we copy the current value of the matrix field (i, k) to position (i, j). That means that the path from i to j now leads through the same successor as the path from i to k. The successor can be k itself, but also another intermediate node on the shortest route to k.\n\nIn the example above, we would initially populate the successor matrix as follows:\n\nIn iteration 1, we find a shorter path from E to B via A. The successor of E on the path to A (row E, column A) is A; thus, we also enter A as the successor of E on the path to B (row E, column B):\n\nFeel free to try updating the matrix yourself across all five iterations (as an exercise).\n\nIn the end, it should look like this (all changes are highlighted in bold):\n\nHow can we read the shortest paths from this matrix?\n\nLet's take the path from D to B that we had calculated in the fifth iteration.\n\nWe read from the matrix step by step:\n• Row D, column B: The direct successor of D on the route to B is: E\n• Row E, column B: The direct successor of E on the route to B is: A\n• Row A, column B: The direct successor of A on the route to B is: B (target node reached)\n\nThus, the complete shortest path is D→E→A→B.\n\nHere again, for comparison, is the graph from the fifth iteration:\n\nThe path read from the successor matrix matches the path drawn.\n\nThe informal description – and the code (following in the next chapter) – are surprisingly simple. The steps for determining the complete paths are marked as optional. To not confuse the two matrices, I refer to them in the following as cost matrix and successor matrix.\n• Create the cost matrix of size n × n (n is the number of nodes).\n• For each node pair (i, j), enter the cost of the direct path from i to j if it exists; otherwise, enter infinity.\n• For each node pair (i, j), enter the value j.\n\nExecute the following iteration n times; let k be the loop counter and refer to the intermediate node:\n• For each node pair (i, j):\n• Calculate the sum of the cost of path i→k (to be read in row i, column k of the cost matrix) and the cost of path k→j (to be read in row k, column j of the cost matrix).\n• If the sum is smaller than the cost of the path i→j (to be read in row i, column j of the cost matrix), then\n• enter the new, lower costs in row i, column j of the cost matrix;\n• (optionally) copy the value from field (i, k) to field (i, j) in the successor matrix.\n\nFinally, check whether there is a negative number on the diagonal of the cost matrix. If so, terminate the algorithm with the error message \"Negative cycle detected\". Otherwise, the algorithm has run successfully.\n\nIn this chapter, I show you step by step how to implement the Floyd-Warshall algorithm in Java. You can find the complete source code in the eu.happycoders.pathfinding.floyd_warshall package of the GitHub repository.\n\nAs in the previous parts of the series, we use the from the Google Core Libraries for Java (Guava). In the following code snippet, you can see how to create the directed graph from the example above (method ):\n\nThe type parameters of are:\n• Type of nodes: we use for the node names \"A\" to \"E\".\n• Type of edge weights: in the example, we use .\n\nIn the method, we first specify the starting node, followed by the target node and the edge weight.\n\nData Structure for the Cost and Successor Matrix\n\nTwo-dimensional arrays are suitable as a data structure for the matrices:\n\nSince we want our algorithm to return both matrices in the end, we encapsulate both in the class. In the repository, you will see that this class also has a method that we can use to print the matrices to the console for testing.\n\nThe rows and columns of the two-dimensional arrays are addressed with indexes 0 to n-1. However, our nodes are identified by names, not by numbers. So we need a mapping rule between index and node name.\n\nThe method returns a of the nodes, i.e., a non-indexable data structure.\n\nHowever, we can convert the set to an array very easily:\n\nUsing , we can now determine the associated node name for row or column i.\n\nWe initially fill the matrices as follows (method ). The variable m represents the instance of the FloydWarshallMatrices class that contains the two matrices.\n\nIn the cost matrix, we use as representation for infinity. Of course, this only works as long as the cost does not get close to this value (231-1). For the demonstration of the algorithm, it is a sufficient abstraction.\n\nIn the successor matrix, we enter -1 if there is no path for a node pair.\n\nWe could also work with objects and values for both matrices, or even with , but that would have lower performance.\n\nFor the iterations, we nest three loops inside each other:\n• The outer one, with loop counter k, iterates over the intermediate nodes.\n• The two inner ones, with loop counters i and j, iterate over all node pairs.\n\nWithin the loops, we add the costs of paths i→k and k→j and compare the sum to the cost of path i→j. If the sum via intermediate node k is smaller, then we set the cost of path i→j to the recalculated lower cost, and we set the successor node of path i→k as the successor node for path i→j.\n\nThe method returns (in the form of ) if either of the two summands is infinity:\n\nAfter running through the iterations, we check for negative cycles:\n\nIn the end, the method returns the instance m.\n\nDetermining the Shortest Path Between Two Nodes\n\nI implemented the calculation of the shortest path from one node to another in the method . i and j are the indices of the start and end nodes:\n\nFirst we check if is equal to -1. If this is the case, no path from i to j exists, and the method returns an empty .\n\nOtherwise, we create a list and fill it with the initial node, and then – one by one – with the successor nodes of the path. Finally, we return a non-modifiable copy of the list (\"defensive copy\").\n\nThe following three examples in the repository show how to invoke the method:\n• TestWithSampleGraph: In this test, we calculate the shortest paths in the example graph from this article.\n• TestWithSampleGraphFromBellmanFord: This test determines the shortest paths in the example graph from the article about the Bellman-Ford algorithm.\n• TestWithNegativeCycle: This test invokes the method on an example graph with a negative cycle (also from the Bellman-Ford article).\n\nThe time complexity of the Floyd-Warshall algorithm is easily determined. We have three nested loops, each counting n passes. In the innermost loop, we have a comparison that can be performed with constant time. The comparison is performed n × n × n times – or n³ times.\n\nThe time complexity of Floyd-Warshall is thus: O(n³)\n\nUsing the program TestFloydWarshallRuntime, we can check whether the algorithm's running time fits the inferred time complexity O(n³). The program creates random graphs of different sizes and calculates the shortest paths in them. The program repeats each test 50 times and outputs the median of all measured values.\n\nThe following diagram shows the runtime as a function of the graph's size:\n\nThe cubic growth can be seen clearly: When the number of nodes doubles (e.g., from 1,000 to 2,000), the time required increases eightfold (from 700 ms to about 6 s).\n\nIn the following diagram, I compare the running times of Floyd-Warshall, Bellman-Ford (optimized and not optimized), and Dijkstra (with Fibonacci Heap):\n\nFloyd-Warshall is, as expected due to its time complexity, even slower than Bellman-Ford.\n\nSo when should which algorithm be used?\n• Floyd-Warshall should only be used when the shortest paths between all node pairs are sought.\n• Bellman-Ford should be used when the graph contains negative edge weights.\n• A* should be used if the graph does not have negative edge weights, and a heuristic can be defined.\n• Without negative edge weights and heuristics, Dijkstra's algorithm should be used.\n\nThis article has shown you when to use the Floyd-Warshall algorithm (when you need the shortest distances between all node pairs), how it works, and how it identifies negative cycles.\n\nThe time complexity of O(n³) is significantly worse than that of all pathfinding algorithms presented so far. Floyd-Warshall should, therefore, only be used for the intended purpose.\n\nThis concludes the series on pathfinding algorithms. If you liked the article, feel free to share it using one of the share buttons at the end. Do you have any questions or suggestions? Then feel free to leave me a comment. Do you want to be informed when the next article is published? Then sign up for the HappyCoders newsletter."
    },
    {
        "link": "https://stackoverflow.com/questions/32208804/floyd-warshall-algorithm-implementation-with-list-of-lists",
        "document": "I want to use the Floyd-Warshall algorithm to find the shortest path between two vertices. The matrix is in an ArrayList<ArrayList<Integer>>. It is always fairly small, such as a 4x4 or 8x8 matrix.\n\nIn my class, I have a distance matrix already. I'm just trying to create the \"shortest path\" matrix. But it doesn't work. It fills my matrix wrong.\n\nI really hope someone can look at this and explain what's wrong.\n\nI've commented out my test output. is my matrix with the integer value of the distances between the vertices. In my matrix, is y and is x."
    },
    {
        "link": "https://stackoverflow.com/questions/13185727/reading-a-txt-file-using-scanner-class-in-java",
        "document": "I am working on a Java program that reads a text file line-by-line, each with a number, takes each number throws it into an array, then tries and use insertion sort to sort the array. I need help with getting the program to read the text file.\n\nI am getting the following error messages:\n\nI have a copy of the .txt file in my \"src\" \"bin\" and main project folder but it still cannot find the file. I am using Eclipse by the way."
    },
    {
        "link": "https://stackoverflow.com/questions/36097555/reading-values-from-a-file-in-java",
        "document": "After playing around with you code a little, you're reading the first ( ), then trying to read the edge data, which reads in , , but because is not an and it breaks.\n\nIf I change your code to something more like...\n\nIt prints out something like...\n\nI don't have enough information about what all the structure of the file to fully correct your code, but you need to make sure you're reading it correctly. You should also use to print the data as you read, so you can check what you're actually reading and a debugger to step through the code so you can inspect the values of your variables more closely"
    },
    {
        "link": "https://geeksforgeeks.org/scanner-class-in-java",
        "document": "In Java, Scanner is a class in java.util package used for obtaining the input of the primitive types like int, double, etc. and strings.\n\nUsing the Scanner class in Java is the easiest way to read input in a Java program, though not very efficient if you want an input method for scenarios where time is a constraint like in competitive programming.\n\nScanner class helps to take the standard input stream in Java. So, we need some methods to extract data from the stream. Methods used for extracting data are mentioned below:\n\nLet us look at the code snippet to read data of various data types.\n\nSometimes, we have to check if the next value we read is of a certain type or if the input has ended (EOF marker encountered).\n\nThen, we check if the scanner’s input is of the type we want with the help of hasNextXYZ() functions where XYZ is the type we are interested in. The function returns true if the scanner has a token of that type, otherwise false. For example, in the below code, we have used hasNextInt(). To check for a string, we use hasNextLine(). Similarly, to check for a single character, we use hasNext().charAt(0).\n\nLet us look at the code snippet to read some numbers from the console and print their mean.\n• None To create an object of Scanner class, we usually pass the predefined object System.in, which represents the standard input stream. We may pass an object of class File if we want to read input from a file.\n• None To read numerical values of a certain data type XYZ, the function to use is nextXYZ(). For example, to read a value of type short, we can use nextShort()\n• None To read strings, we use nextLine().\n• None To read a single character, we use next().charAt(0). next() function returns the next token/word in the input as a string and charAt(0) function returns the first character in that string.\n• None The Scanner class reads an entire line and divides the line into tokens. Tokens are small elements that have some meaning to the Java compiler. For example, Suppose there is an input string: How are you \n\n In this case, the scanner object will read the entire line and divides the string into tokens: “How”, “are” and “you”. The object then iterates over each token and reads each token using its different methods."
    },
    {
        "link": "https://java-success.com/reading-a-text-file-in-java-with-the-scanner",
        "document": "As a Java developer it is a very common task to read file contents to a String object. It is also very common in pre-interview written tests read the contents of a file and apply regex to split string, etc.\n\n4 things to watch-out for in File processing\n\n1) Files must be closed once read. “Try with resources” feauture in java 7 is used to auto close the file once read.\n\n 2) Favor reading from a classpath over loading from an absolute path.\n\n 3) Scanner is for ASCII files, and a line-oriented scanner cannot be used for binary files. You have no guarantee that the binary file even has “lines” delimited by newline characters.\n\n 4) Reading large files directly into memory can cause memory issues. Read Processing large files efficiently in Java\n\nJDK 7 or later must be used to take advantage of the try with resources that auto closes the file.\n\n“\\Z” The end of the input but for the final terminator, if any.\n\n “\\z” The end of the input.\n\nThe extra “\\” is added to escape, since backslash is a special character in Java String. For e.g. to print a \\ or ” which are special in string literal you have to escape it with another \\ which gives us \\\\ and \\”. Similarly, you need to escape “\\” in “\\Z” with another “\\” which becomes “\\\\Z“.\n\n#3. Scanner class reading from the classpath relatively\n\nThe approaches #1 and #2 of reading a file via absolute path is not recommended because if the you move the deployed files to some other location then you will get “FileNotFoundException”. A better approach is to read from your classpath. The method “getResourceAsStream” in the java.lang.Class API to the rescue.\n\nWhy is this a better approach?\n\nIf you build a jar or war packaging of the above “MyFileReader” and “readme.txt” it can be deployed anywhere. For example, let’s build a jar file with Maven.\n\nThe “src/main/resources” folder can be created with right mouse click on “readFileWithScanner” and then “new –> Source Folder” and then typing “src/main/resources” as the source folder.\n\nAfter importing into eclipse looks like:\n\nStep 3: Ensure that the pom.xml uses Java 7 or later\n\nto take advantage of the “Try with resources” feature.\n\nStep 5: The built jar file looks like\n\nStep 6: Copy this built jar file to say c:\\temp folder and run\n\nSo, you can run this jar file in any folder as the lookup of the file is relative to the classpath.\n\n#4. 2 Scanners: one for reading the file line by line & the other for tokenizing the line on spaces\n\nYou may also like other File I/O posts:"
    },
    {
        "link": "https://geeksforgeeks.org/different-ways-reading-text-file-java",
        "document": "There are multiple ways of writing and reading a text file in Java. this is required while dealing with many applications. There are several ways to read a plain text file in Java e.g. you can use FileReader, BufferedReader, or Scanner to read a text file. Every utility provides something special e.g. BufferedReader provides buffering of data for fast reading, and Scanner provides parsing ability.\n• None Reading the whole file in a List\n\nLet us discuss each of the above methods to a deeper depth and most importantly by implementing them via a clean java program.\n\nThis method reads text from a character-input stream. It does buffer for efficient reading of characters, arrays, and lines. The buffer size may be specified, or the default size may be used. The default is large enough for most purposes. In general, each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream. It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders as shown below as follows:\n\nConvenience class for reading character files. The constructors of this class assume that the default character encoding and the default byte-buffer size are appropriate.\n\nConstructors defined in this class are as follows:\n• FileReader(File file): Creates a new FileReader, given the File to read from\n• FileReader(FileDescriptor fd): Creates a new FileReader, given the FileDescriptor to read from\n• FileReader(String fileName): Creates a new FileReader, given the name of the file to read from\n\nA simple text scanner that can parse primitive types and strings using regular expressions. A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace. The resulting tokens may then be converted into values of different types using the various next methods.\n\nExample 1: With using loops\n\nExample 2: Without using loops\n\n4. Reading the whole file in a List\n\nRead all lines from a file. This method ensures that the file is closed when all bytes have been read or an I/O error, or other runtime exception, is thrown. Bytes from the file are decoded into characters using the specified charset.\n\nThis method recognizes the following as line terminators:"
    },
    {
        "link": "https://geeksforgeeks.org/integer-max_value-and-integer-min_value-in-java-with-examples",
        "document": "Most of the times, in competitive programming, there is a need to assign the variable, the maximum or minimum value that data type can hold, but remembering such a large and precise number comes out to be a difficult job. Therefore, Java has constants to represent these numbers, so that these can be directly assigned to the variable without actually typing the whole number.\n• Integer.MAX_VALUE is a constant in the Integer class of java.lang package that specifies that stores the maximum possible value for any integer variable in Java. The actual value of this is Any integer variable cannot store any value beyond this limit. Upon doing so, the memory will overflow and the value will get negative. Example 2: Trying to initialize a variable value Integer.MAX_VALUE + 1 Output: Trying to initialize a N with value Integer.MAX_VALUE + 1 N = -2147483648\n• Integer.MIN_VALUE is a constant in the Integer class of java.lang package that specifies that stores the minimum possible value for any integer variable in Java. The actual value of this is Any integer variable cannot store any value below this limit. Upon doing so, the memory will overflow and the value will get positive. Example 2: Trying to initialize a variable value Integer.MIN_VALUE – 1 Output: Trying to initialize a N with value Integer.MIN_VALUE - 1 N = 2147483647"
    },
    {
        "link": "https://designgurus.io/answers/detail/what-is-integermax_value",
        "document": "In Java, represents the maximum value that an type can hold. This constant is defined in the class, which is part of the Java standard library ( package). The type in Java is a 32-bit signed integer, and is the largest positive value an can represent.\n• Value: has a value of (2^{31} - 1), which equals 2,147,483,647.\n• Type: It is a constant of the primitive type .\n\nis often used in programming scenarios where you need to initialize a variable to the highest possible integer value, often in algorithms where you compare values to find a minimum, or when you need a practical \"infinity\" value within the range of . Here are some common uses:\n• Boundary Conditions: Checking if adding two numbers would overflow an integer:\n• Algorithmic Constraints: Used as an initial \"infinite\" distance in graph algorithms like Dijkstra's:"
    },
    {
        "link": "https://stackoverflow.com/questions/32367741/what-does-int-integer-max-value-int-do-in-java",
        "document": "There are two parts here:\n• What the function actually does from a Java perspective, and\n• What purpose the function actually serves, from a Hadoop perspective.\n\nLet's cover the Java side of it first. It's fairly straightforward bitwise math, in that it clears the sign bit and turns the value into a positive integer.\n\nThat's easy enough to demonstrate here; let's assume that our key is -128876912, which is . The max value for an int is .\n\nIf we look at the actual math operation, the sign bit is cleared (along with quite a few other bits, in this case), and we get a positive integer value.\n\nIf the value is positive, then the net result is that we get back the same value.\n\nThis is important, since a hash code can come back negative; I don't believe that you want a negative value for a reason that's important a bit later.\n\nFor the partitioning bit, this is a bit more Hadoop knowledge than I can truly claim, but after reading the docs, it informs you which partition the value falls under. That is where the modulo comes in; you're guaranteed to get a value between , thus specifying which reducer the particular bit of data is processed by.\n\nFrom my reading of it, this is one of the default supplied partitioners, and may not be entirely suitable for your uses (you may want to group your data in a different way, for instance)."
    },
    {
        "link": "https://stackoverflow.com/questions/12333541/java-integer-max-value-min-value-overflow",
        "document": "Ok maybe I am just tired because of this but how can I accomplish this?\n\nI just want the if statement to catch if x is \"within range\" kinda like this:\n\nBut the problem is that if the value is as mentioned above, like MAX_VALUE + 10, the value ends up being neither higher than the MAX VALUE nor lower than the MIN_VALUE and the if-conditions aren't met...\n\nEdit: To clarify what I meant: I don't want to actually store any values bigger than the max/min value. Imagine this:\n\nA field, you write 10+10 and it says like \"Ok, that's 20\" Next up, someone maybe will write 1000000100000 and it will respond with the answer as well but then someone might write something that exceeds the max/min values like, 100000001000000*1000000 or someyhing like that and then the program should be all like \"Hold up, that's way too high! here's a \"0\" for you instead\""
    },
    {
        "link": "https://codegym.cc/groups/posts/integermax_value-in-java-with-examples",
        "document": "What is Integer MAX_VALUE in Java?\n\nThe Integer MAX_VALUE in Java is a constant that represents the maximum positive integer value.\n\nWhat are Integers in Java?\n\nWhy is Integer.MAX_VALUE in Java Required?\n\nis a number in the Javaсlass ofpackage. It is the maximum possible Integer number that can be represented in 32 bits. Its exact value is 2147483647 i.e. 2^31-1.Integers are numbers that have no fractional part. In Java, Integers are represented in 32 bits space. In addition, they are represented in 2’s complement binary form, which means that one bit out of these 32 is a sign bit. Thus, there are 2^31-1 possible values. Hence, there is no integer greater than the number 2^31-1 in Java.It is used to automatically assign any variable the maximum integer possible without requiring to remember the exact number. There are many times when we need a maximum or minimum number. It can be for comparative reasons or any other. It can be difficult to remember the exact constant. This job is made easy byin Java.In the code snippet above, we take a variableand assign it maximum integer value using. Then we take another variableand assign it a value one smaller than the maximum. We compare the two and print the results.By the end of this post, we hope you have got yourself familiarized with thein Java in detail. You have learned how to usein Java with examples. You can try assigning other values to different variables and see how this concept works to understand it in more depth. Keep practicing for a deeper command of the concept. Till then, keep growing and keep shining!"
    }
]