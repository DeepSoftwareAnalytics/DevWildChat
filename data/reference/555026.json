[
    {
        "link": "https://docs.python.org/3/library/binascii.html",
        "document": "The module contains a number of methods to convert between binary and various ASCII-encoded binary representations. Normally, you will not use these functions directly but use wrapper modules like instead. The module contains low-level functions written in C for greater speed that are used by the higher-level modules.\n\nThe module defines the following functions:\n\nConvert a block of base64 data back to binary and return the binary data. More than one line may be passed at a time. If strict_mode is true, only valid base64 data will be converted. Invalid base64 data will raise .\n• None Contains only characters from the base64 alphabet.\n• None Contains no excess data after padding (including excess padding, newlines, etc.).\n• None Does not start with a padding.\n\nConvert binary data to a line(s) of ASCII characters in quoted-printable encoding. The return value is the converted line(s). If the optional argument quotetabs is present and true, all tabs and spaces will be encoded. If the optional argument istext is present and true, newlines are not encoded but trailing whitespace will be encoded. If the optional argument header is present and true, spaces will be encoded as underscores per RFC 1522. If the optional argument header is present and false, newline characters will be encoded as well; otherwise linefeed conversion might corrupt the binary data stream.\n\nReturn the hexadecimal representation of the binary data. Every byte of data is converted into the corresponding 2-digit hex representation. The returned bytes object is therefore twice as long as the length of data. Similar functionality (but returning a text string) is also conveniently accessible using the method. If sep is specified, it must be a single character str or bytes object. It will be inserted in the output after every bytes_per_sep input bytes. Separator placement is counted from the right end of the output by default, if you wish to count from the left, supply a negative bytes_per_sep value. Changed in version 3.8: The sep and bytes_per_sep parameters were added."
    },
    {
        "link": "https://stackless.readthedocs.io/en/3.8-slp/library/binascii.html",
        "document": "The module contains a number of methods to convert between binary and various ASCII-encoded binary representations. Normally, you will not use these functions directly but use wrapper modules like , , or instead. The module contains low-level functions written in C for greater speed that are used by the higher-level modules.\n\nThe module defines the following functions:\n\nConvert binary data to a line(s) of ASCII characters in quoted-printable encoding. The return value is the converted line(s). If the optional argument quotetabs is present and true, all tabs and spaces will be encoded. If the optional argument istext is present and true, newlines are not encoded but trailing whitespace will be encoded. If the optional argument header is present and true, spaces will be encoded as underscores per RFC 1522. If the optional argument header is present and false, newline characters will be encoded as well; otherwise linefeed conversion might corrupt the binary data stream.\n\nCompute CRC-32, the 32-bit checksum of data, starting with an initial CRC of value. The default initial CRC is zero. The algorithm is consistent with the ZIP file checksum. Since the algorithm is designed for use as a checksum algorithm, it is not suitable for use as a general hash algorithm. Use as follows: Changed in version 3.0: The result is always unsigned. To generate the same numeric value across all Python versions and platforms, use .\n\nReturn the hexadecimal representation of the binary data. Every byte of data is converted into the corresponding 2-digit hex representation. The returned bytes object is therefore twice as long as the length of data. Similar functionality (but returning a text string) is also conveniently accessible using the method. If sep is specified, it must be a single character str or bytes object. It will be inserted in the output after every bytes_per_sep input bytes. Separator placement is counted from the right end of the output by default, if you wish to count from the left, supply a negative bytes_per_sep value. Changed in version 3.8: The sep and bytes_per_sep parameters were added."
    },
    {
        "link": "https://docs.python.org/uk/3.13/library/binascii.html",
        "document": "Функції приймають рядки Unicode, що містять лише символи ASCII. Інші функції приймають лише байтоподібні об’єкти (такі як , та інші об’єкти, які підтримують протокол буфера). Змінено в версії 3.3: Функції тепер приймають рядки Unicode тільки ASCII.\n\nПеретворити один рядок uuencoded даних назад у двійкові та повернути двійкові дані. Рядки зазвичай містять 45 (двійкових) байт, за винятком останнього рядка. Після рядкових даних може стояти пробіл.\n\nПеретворити блок даних, які можна роздрукувати в лапках, назад у двійкові та повернути двійкові дані. Одночасно можна передати більше одного рядка. Якщо необов’язковий аргумент header присутній і має значення true, підкреслення розшифровуватимуться як пробіли.\n\nПеретворюйте двійкові дані на рядки символів ASCII у кодуванні, що друкується в лапках. Поверненим значенням є перетворені рядки. Якщо необов’язковий аргумент quotetabs присутній і вірний, усі символи табуляції та пробіли будуть закодовані. Якщо необов’язковий аргумент istext присутній і має значення true, нові рядки не кодуються, але кінцеві пробіли кодуються. Якщо необов’язковий аргумент header присутній і відповідає дійсності, пробіли будуть закодовані як підкреслення відповідно до RFC 1522. Якщо необов’язковий аргумент header присутній і false, символи нового рядка також будуть закодовані; інакше перетворення переводу рядка може пошкодити двійковий потік даних.\n\nОбчисліть 16-бітне значення CRC data, починаючи з value як початкового CRC, і поверніть результат. Тут використовується поліном CRC-CCITT x16 + x12 + x5 + 1, який часто представляється як 0x1021. Цей CRC використовується у форматі binhex4.\n\nОбчисліть CRC-32, беззнакову 32-бітну контрольну суму даних, починаючи з початкового CRC значення. Початковий CRC за умовчанням дорівнює нулю. Алгоритм узгоджується з контрольною сумою файлу ZIP. Оскільки алгоритм розроблено для використання як алгоритм контрольної суми, він не підходить для використання як загальний алгоритм хешування. Використовуйте наступним чином:\n\nПовертає шістнадцяткове представлення двійкових даних. Кожен байт даних перетворюється у відповідне 2-значне шістнадцяткове представлення. Тому повернутий об’єкт bytes вдвічі довший за довжину data. Подібні функції (але повернення текстового рядка) також зручно доступні за допомогою методу . Якщо вказано sep, це має бути односимвольний об’єкт str або bytes. Його буде вставлено у вивід після кожного вхідного байта bytes_per_sep. Розташування роздільника за замовчуванням відраховується від правого кінця виводу. Якщо ви бажаєте відраховувати зліва, укажіть від’ємне значення bytes_per_sep.\n\nПовертає двійкові дані, представлені шістнадцятковим рядком hexstr. Ця функція є зворотною до . hexstr має містити парну кількість шістнадцяткових цифр (які можуть бути великими чи нижніми регістрами), інакше виникає виняткова ситуація . Подібна функціональність (приймає лише текстові рядкові аргументи, але більш вільна щодо пробілів) також доступна за допомогою методу класу .\n\nВинятком є неповні дані. Зазвичай це не помилки програмування, але їх можна вирішити, прочитавши трохи більше даних і повторивши спробу."
    },
    {
        "link": "https://docs.python.domainunion.de/3/library/binascii.html",
        "document": "The module contains a number of methods to convert between binary and various ASCII-encoded binary representations. Normally, you will not use these functions directly but use wrapper modules like instead. The module contains low-level functions written in C for greater speed that are used by the higher-level modules.\n\nThe module defines the following functions:\n\nConvert a block of base64 data back to binary and return the binary data. More than one line may be passed at a time. If strict_mode is true, only valid base64 data will be converted. Invalid base64 data will raise .\n• None Contains only characters from the base64 alphabet.\n• None Contains no excess data after padding (including excess padding, newlines, etc.).\n• None Does not start with a padding.\n\nConvert binary data to a line(s) of ASCII characters in quoted-printable encoding. The return value is the converted line(s). If the optional argument quotetabs is present and true, all tabs and spaces will be encoded. If the optional argument istext is present and true, newlines are not encoded but trailing whitespace will be encoded. If the optional argument header is present and true, spaces will be encoded as underscores per RFC 1522. If the optional argument header is present and false, newline characters will be encoded as well; otherwise linefeed conversion might corrupt the binary data stream.\n\nCompute CRC-32, the unsigned 32-bit checksum of data, starting with an initial CRC of value. The default initial CRC is zero. The algorithm is consistent with the ZIP file checksum. Since the algorithm is designed for use as a checksum algorithm, it is not suitable for use as a general hash algorithm. Use as follows: Changed in version 3.0: The result is always unsigned.\n\nReturn the hexadecimal representation of the binary data. Every byte of data is converted into the corresponding 2-digit hex representation. The returned bytes object is therefore twice as long as the length of data. Similar functionality (but returning a text string) is also conveniently accessible using the method. If sep is specified, it must be a single character str or bytes object. It will be inserted in the output after every bytes_per_sep input bytes. Separator placement is counted from the right end of the output by default, if you wish to count from the left, supply a negative bytes_per_sep value. Changed in version 3.8: The sep and bytes_per_sep parameters were added."
    },
    {
        "link": "https://stackoverflow.com/questions/27772538/binascii-unhexlify-working-differently-in-python-3-2-and-python3-4",
        "document": "I used to work on , and the latest version of embedded in it is . My program takes a hex string as input, decodes it and creates a so I can decode several information using . For example:\n\nLast week my computer crashed, so I had to build a new machine. I decided to give a try to . However, I discovered that the only version of is . I installed using , but I noticed that the version installed is only . When I run the exact same code as above, I get a on the line:\n\nI don't understand this error, what does it mean? I checked on Google but couldn't find anything: have there been any changes on between the two versions? Do I have to change something in 3.2?\n\nI really don't see how to solve this... Maybe there is a better way to achieve that?\n\nPS: I could go back to , or install on , but I think my production server is a fresh install of , so with ... so I'd better target that version (and I am glad I discovered it now!)."
    },
    {
        "link": "https://stackoverflow.com/questions/3283984/decode-hex-string-in-python-3",
        "document": "In Python 2, converting the hexadecimal form of a string into the corresponding unicode was straightforward:\n\nwhere the variable 'comments' is a part of a line in a file (the rest of the line does not need to be converted, as it is represented only in ASCII.\n\nNow in Python 3, however, this doesn't work (I assume because of the bytes/string vs. string/unicode switch. I feel like there should be a one-liner in Python 3 to do the same thing, rather than reading the entire line as a series of bytes (which I don't want to do) and then converting each part of the line separately. If it's possible, I'd like to read the entire line as a unicode string (because the rest of the line is in unicode) and only convert this one part from a hexadecimal representation."
    },
    {
        "link": "https://stackoverflow.com/questions/9641440/convert-from-ascii-string-encoded-in-hex-to-plain-ascii",
        "document": "Tested in Python 3.3.2 There are many ways to accomplish this, here's one of the shortest, using only python-provided stuff:\n\nOf course, if you don't want to import anything, you can always write your own code. Something very basic like this:"
    },
    {
        "link": "https://geeksforgeeks.org/convert-hexadecimal-value-string-ascii-value-string",
        "document": "Given the Hexadecimal value string as input, the task is to convert the given hexadecimal value string into its corresponding ASCII format string.\n\nThe “Hexadecimal” or simply “Hex” numbering system uses the Base of 16 system. Being a Base-16 system, there are 16 possible digit symbols. The hexadecimal number uses 16 symbols {0, 1, 2, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F} to represent all numbers. Here, (A, B, C, D, E, F) represents (10, 11, 12, 13, 14, 15).\n\nASCII stands for American Standard Code for Information Interchange. ASCII is a standard that assigns letters, numbers, and other characters within the 256 slots available in the 8-bit code. E.g the lower case “h” character (Char) has a decimal value of 104, which is “01101000” in binary and “68” in hexadecimal.\n\nTime complexity: O(N), where N is the length of the given string\n\nAuxiliary space: O(N)\n\nThis approach is to use bitwise operations to directly convert the hexadecimal string to an ASCII string. In this approach, we would start by converting the hexadecimal string to a series of bytes. We can do this by iterating through the string and converting each pair of hexadecimal digits to a byte. Once we have the bytes, we can use bitwise operations to convert them to characters in the ASCII string.\n\nIn this implementation, we use a stringstream to build the ASCII string. We iterate through the hexadecimal string, converting each pair of hexadecimal digits to a byte using stoi. Then, we append the byte to the stringstream. Finally, we return the contents of the stringstream as the ASCII string.\n\nHere is the code of this approach:\n\nTime complexity: O(n), where N is the length of the given string\n\nAuxiliary space: O(n)"
    },
    {
        "link": "https://python-forum.io/thread-194.html",
        "document": "Weighs the Same as a Duck\n\n \n\n \n\n '707974686f6e2d666f72756d2e696f' -> 'python-forum.io'\n\n \n\n in python 2 i can do .decode('hex') but this is gone in python3. so, i found this:\n\n anything simpler that works in either python 2 or python 3 ? given a string of hexadecimal characters that represent ASCII characters, i want to convert it to those ASCII characters. for example:'707974686f6e2d666f72756d2e696f' -> 'python-forum.io'in python 2 i can do .decode('hex') but this is gone in python3. so, i found this:anything simpler that works in either python 2 or python 3 ? Tradition is peer pressure from dead people\n\n \n\n What do you call someone who speaks three languages? Trilingual. Two languages? Bilingual. One language? American.\n\n \n\n Does it give the result you want? How aboutDoes it give the result you want? \n\n \n\n Personally, I've found the fromhex method of bytes to be useful. \n\n Weighs the Same as a Duck\n\n How about\n\n Does it give the result you want? \n\n not in py 3. i want an ASCII or UTF-8 string, not an array of bytes. this why i added the 2nd call to codecs.decode(,\"ascii\"). not in py 3. i want an ASCII or UTF-8 string, not an array of bytes. this why i added the 2nd call to codecs.decode(,\"ascii\"). Tradition is peer pressure from dead people\n\n \n\n What do you call someone who speaks three languages? Trilingual. Two languages? Bilingual. One language? American.\n\n this why i added the 2nd call to codecs.decode(,\"ascii\") You don't need a second call,just add \n\n It will work the same in Python 2.x\n\n Strings are Unicode by default in Python 3.x.\n\n You don't need a second call,just addIt will work the same in Python 2.xStrings are Unicode by default in Python 3.x."
    },
    {
        "link": "https://quora.com/How-do-I-convert-hex-into-a-string-using-Python",
        "document": "Something went wrong. Wait a moment and try again."
    }
]