[
    {
        "link": "https://reddit.com/r/golang/comments/rh2d0n/append_extends_your_slice_capacity_beyond_what_it",
        "document": "I just ran into something which drove me crazy for a good 20 minutes.\n\nincreases the capacity of the slice beyond what it just needs. It usually adds 8 bytes of capacity. However, this depends on the existing slice length and capacity.\n\nSo that increased the slice capacity by . Not sure why exactly, but I thought I would share.\n\nEDIT: for people downvoting this, just try it. It's not that simple and obvious. This capacity extension also depends on the slice type, sometimes it extends by 1 only depending on the type. Not saying this is a bug, but it is definitely interesting and not-that-simple."
    },
    {
        "link": "https://dev.to/andyhaskell/a-closer-look-at-go-s-slice-append-function-3bhb",
        "document": "Appending items onto arrays and array-like objects is common in many programming languages, with functions like JavaScript's and Python's to add items. In Go, the function for adding items to its slice type is called , and it looks pretty similar to what you'd expect from another language.\n\nIn this code snippet, we add the numbers 250, 2071, and 1123 to a slice of int, and then print out its content.\n\nMost of the time, it's easy think of as just adding items onto a slice. However, knowing what goes on behind the scenes when you append to a slice helps you both write Go code that runs faster, and avoid an easy to miss pitfall of working with slices and the append function. So in this tutorial, we're going to take a closer look at what your computer is doing when you run .\n\nWhen you have a slice, there are five things it can tell you:\n\nüêõ Its length; \n\n üì¶ Its capacity; \n\n üéä What's inside it; \n\n üó∫Ô∏è Where, in your computer's memory, it is; \n\n ‚ùì What type its items are;\n\nSo let's take a look at what happens in the first four of those if we append to a slice five times:\n\nHere's my output when I ran this. Any time you run it, the memory addresses should be different, but everything else should be the same:\n‚Ä¢ Every time we add an item, both and the items in the slice always change, just as we'd expect.\n‚Ä¢ Each time and are the same, the slice is at maximum capacity. If we add another item to a slice at maximum capacity, then the slice's capacity grows.\n‚Ä¢ Not only that, but when we add to a slice that's at maximum capacity, its address also changes!\n\nOn that last point, that means that when that fifth number is added to the slice, your computer is allocating a new piece of memory for our slice. The variable now points to whatever section of memory just got allocated for the slice. To understand why we need that allocation, let's take a look at the data structure behind slices: Go arrays!\n\nIf you're working with a contiguous, ordered collection of items in Go, chances are you're using a slice. However, that doesn't mean there's no such thing as Go arrays. Go uses arrays, but the reason we don't often use them directly is that arrays are mainly used for storing the underlying data for slices.\n\nOne big difference between a Go array and a Go slice is that you have to say the size of an array up front when you declare it. For example, you would declare an array of two strings with the type instead of :\n\nThese look similar, and you can access items in an array or a slice the same way. For example, to see all your vehicles, this loop would work for both and :\n\nHowever, besides syntax, the big difference between a slice and an array, and why you have to declare an array's size up front, is that while a slice can change sizes, arrays are fixed-size. And because a fixed-size array is where the items in a slice live, when you append to a slice with a line of code like , what actually happens is:\n\n1) The slice increments its length, so is now 3\n\n 2a) If there is still space left in the underlying array, our slice isn't at maximum capacity, so the item is just added to a new slot in the array:\n\n2b) But if the underlying array was already full, because arrays are fixed-size, that means we need to allocate a new, bigger array in memory and then copy everything over to it.\n\nEither way, from the perspective of a slice's items, the result will be the same; the slice will have an underlying array containing this well-drawn Catbus:\n\nYou won't notice it in examples with just a few items, but the reason these re-allocations from appending are a big deal is that if you have millions of items in your slice, you can end up spending a lot of time on allocating memory and re-copying it. And memory allocations are a slow operation from the computer's perspective.\n\nTo see this in action, try running this Go testing benchmark that fills a slice with a billion 8-bit integers (if you have more than four gigabytes of RAM).\n\nOn my Mac, adding a billion items to a slice where the memory isn't pre-allocated typically took around .5-.6 seconds, while adding them to a slice that started out empty took around 2.5-2.8 seconds, with six times as many bytes being processed!\n\nThis shows how much the extra allocations and repeated data copying can slow down your code. Because of this, if you are looking to improve the performance of code that works heavily with a slice, you should look into preventing unnecessary re-allocations.\n\nFor example, here is a code snippet where we fill a slice up and then process its data, but we use the slicing operator to allow us to reuse its underlying array when we fill it up again.\n\nWhen we say , that means that we are assigning a slice, with the same underlying array, but with the slice's length reset. Because of this, no new memory allocations have to happen, so we'll see the same address both times we print it.\n\nBe safe with appending to slices\n\nIn addition to performance, there is one other implication a slice's underlying array has on how we use append. It's that to use slice append safely, we need to be sure we know where in the array we are appending to. If we take this sloth family's grocery list:\n\nThis looks correct so far; we print out the foodstuffs slice and get our first two items, and we print out the personalCare slice and get our third item.\n\nAt the memory level we have three slices in-play, and all of them are working with the same underlying array:\n\nHowever, that can spell trouble if we try to then append to the foodstuffs slice. If we appended \"avocados\" to like this (ancient giant sloths helped disperse the seeds of what would evolve to be today's avocados):\n\nThen even though the statements and look like they're making fresh arrays, we're still using the same sections of memory. This means when we append to the slice, what we're actually doing looks like this:\n\nWe put into the third slot of the underlying array, and in memory, that is also the location of first slot of the slice. So now the foodstuffs slice is , but the personalCare slice is . We wiped \"Green Sheen shampoo\" out of the array!\n\nBecause of this, to append to slices safely in Go, you need to be sure you are appending to the slice containing every item we have added, in this case . This means that in general, the and slices should really only be read from, not appended to.\n\nIf you need a copy of the slice to append to, you can use Go's built-in function, like this:\n\nNow, with having a different underlying array, avocados can be added to the foodstuffs slice, and that won't overwrite Green Sheen shampoo on the grocery list! The sloths are ready to go to the store, and you're ready to write code with that's both performant and safe. Until next time,\n\nImage credit for the sloth picture to Stevenj on Wikipedia, original photographer is Leyo on Wikipedia; picture is licensed CC-BY-2.5.\n\nThe Go Gopher on the title banner was originally drawn by Renee French and is licensed CC-BY-3.0.\n\nAlso shoutout to Nicole Archambault's MetroWest freeCodeCampers meetup, which is where I drew that Catbus drawing to demonstrate slice re-allocation!"
    },
    {
        "link": "https://tour.ardanlabs.com/tour/eng/slices",
        "document": ""
    },
    {
        "link": "https://rezakhademix.medium.com/slices-in-golang-common-mistakes-and-best-practices-76c30857d4e4",
        "document": "In this story we want to discuss about slices in Golang and see some different scenarios to avoid common mistakes. Let‚Äôs dive in!\n\nA slice in Golang is a dynamically size data structure that is a reference to an underlying array. We must consider passing a slice to a function that modifies it will affect the original slice outside the function.\n\nSince we already know the fundamental of slices in Golang, we will skip the part of introducing , and other basic concepts about slices.\n\nAlthough nil slices and empty slices have the same behavior, it is important to know a slice has no underlying array while an empty slice referencing an underlying array with zero length.\n\nBe aware appending to a or zero-length slice needs allocation even though appending to a non-nil slice with enough capacity doesn‚Äôt need allocation. So, in most situations having a non-zero capacity (with well predicted value) is advantageous.\n\nLet‚Äôs imagine, we want to pop an item from an original slice to a new one, as below example: (we want to modify that only contains )\n\nAs we saw in the above code this result could be dangerous to our program so the correct way of doing this kind of operation could be:\n\nIf we define a new slice and set it equal to an existing slice, the new defined slice is of a reference type.\n\nThe correct way to make a separate copy of an existing slice is by using function, as below:\n\nAnother quick note is referencing new slice to an existing array, like below:\n\nThis will create a slice referencing . Modifying will also modify .\n\nSince Golang 1.21, we can use a generic function from the standard library like below:\n\nBut In previous versions of Golang we could use .\n\nslices in Golang are not thread safe. Passing slices without managing the potential race conditions will make our program to behave unpredictable.\n\nWe must use to protect concurrency.\n\nUsing function inside a for loop can lead our program to a reallocation iteration and it will consume too much resource so we should avoid it as long as we can.\n\nPreallocating with function is a viable option when we are working with large datasets.\n\nThat‚Äôs it. Here is the summary of what we have reviewed so far about slices in Golang.\n‚Ä¢ We should be careful about loops and\n\nIf you like this article please Clap üëè and follow me to get more of these Golang contents.\n‚Ä¢ Defer functions in Golang: Common Mistakes and Best Practices\n‚Ä¢ Strings in Golang: Common Mistakes and Best Practices\n‚Ä¢ Slices in Golang: Common Mistakes and Best Practices"
    },
    {
        "link": "https://stackoverflow.com/questions/16248241/concatenate-two-slices-in-go",
        "document": "I think it's important to point out and to know that if the destination slice (the slice you append to) has sufficient capacity, the append will happen \"in-place\", by reslicing the destination (reslicing to increase its length in order to be able to accommodate the appendable elements).\n\nThis means that if the destination was created by slicing a bigger array or slice which has additional elements beyond the length of the resulting slice, they may get overwritten.\n\nTo demonstrate, see this example:\n\nOutput (try it on the Go Playground):\n\nWe created a \"backing\" array with length . Then we create the destination slice by slicing this array, slice is created using the composite literal . Now when we append to , the result is the expected , but what may be surprising is that the backing array also changed, because capacity of is which is sufficient to append to it, so is resliced which will also use the same backing array, and will copy elements of into there.\n\nIf you want to avoid this, you may use a full slice expression which has the form\n\nwhich constructs a slice and also controls the resulting slice's capacity by setting it to .\n\nSee the modified example (the only difference is that we create like this: :\n\nOutput (try it on the Go Playground)\n\nAs you can see, we get the same result but the backing array did not change, because capacity of was \"only\" (thanks to the full slice expression ). So to do the append, a new backing array is allocated that can store the elements of both and , which is distinct from ."
    },
    {
        "link": "https://pkg.go.dev/time",
        "document": "Package time provides functionality for measuring and displaying time. The calendrical calculations always assume a Gregorian calendar, with no leap seconds. Operating systems provide both a ‚Äúwall clock,‚Äù which is subject to changes for clock synchronization, and a ‚Äúmonotonic clock,‚Äù which is not. The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time. Rather than split the API, in this package the Time returned by time.Now contains both a wall clock reading and a monotonic clock reading; later time-telling operations use the wall clock reading, but later time-measuring operations, specifically comparisons and subtractions, use the monotonic clock reading. For example, this code always computes a positive elapsed time of approximately 20 milliseconds, even if the wall clock is changed during the operation being timed: Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets. The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package. The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0). If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings. On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u. The same applies to other functions and methods that subtract times, such as Since, Until, Time.Before, Time.After, Time.Add, Time.Equal and Time.Compare. In some cases, you may need to strip the monotonic clock to get accurate results. Because the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading. The monotonic clock reading exists only in Time values. It is not a part of Duration values or the Unix times returned by t.Unix and friends. Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values. For debugging, the result of t.String does include the monotonic clock reading if present. If t != u because of different monotonic clock readings, that difference will be visible when printing t.String() and u.String(). Timer resolution varies depending on the Go runtime, the operating system and the underlying hardware. On Unix, the resolution is ~1ms. On Windows version 1803 and newer, the resolution is ~0.5ms. On older Windows versions, the default resolution is ~16ms, but a higher resolution may be requested using golang.org/x/sys/windows.TimeBeginPeriod.\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: (January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. Note that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the RFC1123 or RFC1123Z formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. To define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. Year: \"2006\" \"06\" Month: \"Jan\" \"January\" \"01\" \"1\" Day of the week: \"Mon\" \"Monday\" Day of the month: \"2\" \"_2\" \"02\" Day of the year: \"__2\" \"002\" Hour: \"15\" \"3\" \"03\" (PM or AM) Minute: \"4\" \"04\" Second: \"5\" \"05\" AM/PM mark: \"PM\" Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: \"Z0700\" Z or ¬±hhmm \"Z07:00\" Z or ¬±hh:mm \"Z07\" Z or ¬±hh \"Z070000\" Z or ¬±hhmmss \"Z07:00:00\" Z or ¬±hh:mm:ss Within the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision. Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. Common durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions. To count the number of units in a Duration, divide: To convert an integer number of units to a Duration, multiply:\n\nA Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years. ParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"¬µs\"), \"ms\", \"s\", \"m\", \"h\". package main import ( \"fmt\" \"time\" ) func main() { hours, _ := time.ParseDuration(\"10h\") complex, _ := time.ParseDuration(\"1h10m10s\") micro, _ := time.ParseDuration(\"1¬µs\") // The package also accepts the incorrect but common prefix u for micro. micro2, _ := time.ParseDuration(\"1us\") fmt.Println(hours) fmt.Println(complex) fmt.Printf(\"There are %.0f seconds in %v.\n\n\", complex.Seconds(), complex) fmt.Printf(\"There are %d nanoseconds in %v.\n\n\", micro.Nanoseconds(), micro) fmt.Printf(\"There are %6.2e seconds in %v.\n\n\", micro2.Seconds(), micro2) } 10h0m0s 1h10m10s There are 4210 seconds in 1h10m10s. There are 1000 nanoseconds in 1¬µs. There are 1.00e-06 seconds in 1¬µs. Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t). Until returns the duration until t. It is shorthand for t.Sub(time.Now()). Abs returns the absolute value of d. As a special case, Duration(math.MinInt64) is converted to Duration(math.MaxInt64), reducing its magnitude by 1 nanosecond. package main import ( \"fmt\" \"math\" \"time\" ) func main() { positiveDuration := 5 * time.Second negativeDuration := -3 * time.Second minInt64CaseDuration := time.Duration(math.MinInt64) absPositive := positiveDuration.Abs() absNegative := negativeDuration.Abs() absSpecial := minInt64CaseDuration.Abs() == time.Duration(math.MaxInt64) fmt.Printf(\"Absolute value of positive duration: %v\n\n\", absPositive) fmt.Printf(\"Absolute value of negative duration: %v\n\n\", absNegative) fmt.Printf(\"Absolute value of MinInt64 equal to MaxInt64: %t\n\n\", absSpecial) } Absolute value of positive duration: 5s Absolute value of negative duration: 3s Absolute value of MinInt64 equal to MaxInt64: true Hours returns the duration as a floating point number of hours. Microseconds returns the duration as an integer microsecond count. One second is 1000000 microseconds. Milliseconds returns the duration as an integer millisecond count. One second is 1000 milliseconds. Minutes returns the duration as a floating point number of minutes. Nanoseconds returns the duration as an integer nanosecond count. Round returns the result of rounding d to the nearest multiple of m. The rounding behavior for halfway values is to round away from zero. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, Round returns the maximum (or minimum) duration. If m <= 0, Round returns d unchanged. Seconds returns the duration as a floating point number of seconds. Take off in t-90 seconds. String returns a string representing the duration in the form \"72h3m0.5s\". Leading zero units are omitted. As a special case, durations less than one second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure that the leading digit is non-zero. The zero duration formats as 0s. Truncate returns the result of rounding d toward zero to a multiple of m. If m <= 0, Truncate returns d unchanged. A Location maps time instants to the zone in use at that time. Typically, the Location represents the collection of time offsets in use in a geographical area. For many Locations the time offset varies depending on whether daylight savings time is in use at the time instant. Location is used to provide a time zone in a printed Time value and for calculations involving intervals that may cross daylight savings time boundaries. package main import ( \"fmt\" \"time\" ) func main() { // China doesn't have daylight saving. It uses a fixed 8 hour offset from UTC. secondsEastOfUTC := int((8 * time.Hour).Seconds()) beijing := time.FixedZone(\"Beijing Time\", secondsEastOfUTC) // If the system has a timezone database present, it's possible to load a location // from that, e.g.: // newYork, err := time.LoadLocation(\"America/New_York\") // Creating a time requires a location. Common locations are time.Local and time.UTC. timeInUTC := time.Date(2009, 1, 1, 12, 0, 0, 0, time.UTC) sameTimeInBeijing := time.Date(2009, 1, 1, 20, 0, 0, 0, beijing) // Although the UTC clock time is 1200 and the Beijing clock time is 2000, Beijing is // 8 hours ahead so the two dates actually represent the same instant. timesAreEqual := timeInUTC.Equal(sameTimeInBeijing) fmt.Println(timesAreEqual) } Local represents the system's local time zone. On Unix systems, Local consults the TZ environment variable to find the time zone to use. No TZ means use the system default /etc/localtime. TZ=\"\" means use UTC. TZ=\"foo\" means use file foo in the system timezone directory. FixedZone returns a Location that always uses the given zone name and offset (seconds east of UTC). LoadLocation returns the Location with the given name. If the name is \"\" or \"UTC\", LoadLocation returns UTC. If the name is \"Local\", LoadLocation returns Local. Otherwise, the name is taken to be a location name corresponding to a file in the IANA Time Zone database, such as \"America/New_York\". LoadLocation looks for the IANA Time Zone database in the following locations in order:\n‚Ä¢ the directory or uncompressed zip file named by the ZONEINFO environment variable\n‚Ä¢ the time/tzdata package, if it was imported LoadLocationFromTZData returns a Location with the given name initialized from the IANA Time Zone database-formatted data. The data should be in the format of a standard IANA time zone file (for example, the content of /etc/localtime on Unix systems). String returns a descriptive name for the time zone information, corresponding to the name argument to LoadLocation or FixedZone. String returns the English name of the month (\"January\", \"February\", ...). A Ticker holds a channel that delivers ‚Äúticks‚Äù of a clock at intervals. NewTicker returns a new Ticker containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Before Go 1.23, the garbage collector did not recover tickers that had not yet expired or been stopped, so code often immediately deferred t.Stop after calling NewTicker, to make the ticker recoverable when it was no longer needed. As of Go 1.23, the garbage collector can recover unreferenced tickers, even if they haven't been stopped. The Stop method is no longer necessary to help the garbage collector. (Code may of course still want to call Stop to stop the ticker for other reasons.) package main import ( \"fmt\" \"time\" ) func main() { ticker := time.NewTicker(time.Second) defer ticker.Stop() done := make(chan bool) go func() { time.Sleep(10 * time.Second) done <- true }() for { select { case <-done: fmt.Println(\"Done!\") return case t := <-ticker.C: fmt.Println(\"Current time: \", t) } } } Reset stops a ticker and resets its period to the specified duration. The next tick will arrive after the new period elapses. The duration d must be greater than zero; if not, Reset will panic. Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous \"tick\". A Time represents an instant in time with nanosecond precision. Programs using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type time.Time, not *time.Time. A Time value can be used by multiple goroutines simultaneously except that the methods Time.GobDecode, Time.UnmarshalBinary, Time.UnmarshalJSON and Time.UnmarshalText are not concurrency-safe. Time instants can be compared using the Time.Before, Time.After, and Time.Equal methods. The Time.Sub method subtracts two instants, producing a Duration. The Time.Add method adds a Time and a Duration, producing a Time. The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the Time.IsZero method gives a simple way of detecting a time that has not been initialized explicitly. Each time has an associated Location. The methods Time.Local, Time.UTC, and Time.In return a Time with a specific Location. Changing the Location of a Time value with these methods does not change the actual instant it represents, only the time zone in which to interpret it. Representations of a Time value saved by the Time.GobEncode, Time.MarshalBinary, Time.AppendBinary, Time.MarshalJSON, Time.MarshalText and Time.AppendText methods store the Time.Location's offset, but not the location name. They therefore lose information about Daylight Saving Time. In addition to the required ‚Äúwall clock‚Äù reading, a Time may contain an optional reading of the current process's monotonic clock, to provide additional precision for comparison or subtraction. See the ‚ÄúMonotonic Clocks‚Äù section in the package documentation for details. Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. Therefore, Time values should not be used as map or database keys without first guaranteeing that the identical Location has been set for all values, which can be achieved through use of the UTC or Local method, and that the monotonic clock reading has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u) to t == u, since t.Equal uses the most accurate comparison available and correctly handles the case when only one of its arguments has a monotonic clock reading. Date returns the Time corresponding to in the appropriate zone for that time in the given location. The month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1. A daylight savings time transition skips or repeats times. For example, in the United States, March 13, 2011 2:15am never occurred, while November 6, 2011 1:15am occurred twice. In such cases, the choice of time zone, and therefore the time, is not well-defined. Date returns a time that is correct in one of the two zones involved in the transition, but it does not guarantee which. Parse parses a formatted string and returns the time value it represents. See the documentation for the constant called Layout to see how to represent the format. The second argument must be parseable using the format string (layout) provided as the first argument. The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. When parsing (only), the input may contain a fractional second field immediately after the seconds field, even if the layout does not signify its presence. In that case either a comma or a decimal point followed by a maximal series of digits is parsed as a fractional second. Fractional seconds are truncated to nanosecond precision. Elements omitted from the layout are assumed to be zero or, when zero is impossible, one, so parsing \"3:04pm\" returns the time corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is 0, this time is before the zero Time). Years must be in the range 0000..9999. The day of the week is checked for syntax but it is otherwise ignored. For layouts specifying the two-digit year 06, a value NN >= 69 will be treated as 19NN and a value NN < 69 will be treated as 20NN. The remainder of this comment describes the handling of time zones. In the absence of a time zone indicator, Parse returns a time in UTC. When parsing a time with a zone offset like -0700, if the offset corresponds to a time zone used by the current location (Local), then Parse uses that location and zone in the returned time. Otherwise it records the time as being in a fabricated location with time fixed at the given zone offset. When parsing a time with a zone abbreviation like MST, if the zone abbreviation has a defined offset in the current location, then that offset is used. The zone abbreviation \"UTC\" is recognized as UTC regardless of location. If the zone abbreviation is unknown, Parse records the time as being in a fabricated location with the given zone abbreviation and a zero offset. This choice means that such a time can be parsed and reformatted with the same layout losslessly, but the exact instant used in the representation will differ by the actual zone offset. To avoid such problems, prefer time layouts that use a numeric zone offset, or use ParseInLocation. package main import ( \"fmt\" \"time\" ) func main() { // See the example for Time.Format for a thorough description of how // to define the layout string to parse a time.Time value; Parse and // Format use the same model to describe their input and output. // longForm shows by example how the reference time would be represented in // the desired layout. const longForm = \"Jan 2, 2006 at 3:04pm (MST)\" t, _ := time.Parse(longForm, \"Feb 3, 2013 at 7:54pm (PST)\") fmt.Println(t) // shortForm is another way the reference time would be represented // in the desired layout; it has no time zone present. // Note: without explicit zone, returns time in UTC. const shortForm = \"2006-Jan-02\" t, _ = time.Parse(shortForm, \"2013-Feb-03\") fmt.Println(t) // Some valid layouts are invalid time values, due to format specifiers // such as _ for space padding and Z for zone information. // For example the RFC3339 layout 2006-01-02T15:04:05Z07:00 // contains both Z and a time zone offset in order to handle both valid options: // 2006-01-02T15:04:05Z // 2006-01-02T15:04:05+07:00 t, _ = time.Parse(time.RFC3339, \"2006-01-02T15:04:05Z\") fmt.Println(t) t, _ = time.Parse(time.RFC3339, \"2006-01-02T15:04:05+07:00\") fmt.Println(t) _, err := time.Parse(time.RFC3339, time.RFC3339) fmt.Println(\"error\", err) // Returns an error as the layout is not a valid time value } ParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location. package main import ( \"fmt\" \"time\" ) func main() { loc, _ := time.LoadLocation(\"Europe/Berlin\") // This will look for the name CEST in the Europe/Berlin time zone. const longForm = \"Jan 2, 2006 at 3:04pm (MST)\" t, _ := time.ParseInLocation(longForm, \"Jul 9, 2012 at 5:02am (CEST)\", loc) fmt.Println(t) // Note: without explicit zone, returns time in given location. const shortForm = \"2006-Jan-02\" t, _ = time.ParseInLocation(shortForm, \"2012-Jul-09\", loc) fmt.Println(t) } Unix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range [0, 999999999]. Not all sec values have a corresponding time value. One such value is 1<<63-1 (the largest int64 value). UnixMicro returns the local Time corresponding to the given Unix time, usec microseconds since January 1, 1970 UTC. UnixMilli returns the local Time corresponding to the given Unix time, msec milliseconds since January 1, 1970 UTC. AddDate returns the time corresponding to adding the given number of years, months, and days to t. For example, AddDate(-1, 2, 3) applied to January 1, 2011 returns March 4, 2010. Note that dates are fundamentally coupled to timezones, and calendrical periods like days don't have fixed durations. AddDate uses the Location of the Time value to determine these durations. That means that the same AddDate arguments can produce a different shift in absolute time depending on the base Time value and its Location. For example, AddDate(0, 0, 1) applied to 12:00 on March 27 always returns 12:00 on March 28. At some locations and in some years this is a 24 hour shift. In others it's a 23 hour shift due to daylight savings time transitions. AddDate normalizes its result in the same way that Date does, so, for example, adding one month to October 31 yields December 1, the normalized form for November 31. After reports whether the time instant t is after u. AppendFormat is like Time.Format but appends the textual representation to b and returns the extended buffer. AppendText implements the encoding.TextAppender interface. The time is formatted in RFC 3339 format with sub-second precision. If the timestamp cannot be represented as valid RFC 3339 (e.g., the year is out of range), then an error is returned. Before reports whether the time instant t is before u. Clock returns the hour, minute, and second within the day specified by t. Compare compares the time instant t with u. If t is before u, it returns -1; if t is after u, it returns +1; if they're the same, it returns 0. Date returns the year, month, and day in which t occurs. Day returns the day of the month specified by t. Equal reports whether t and u represent the same time instant. Two times can be equal even if they are in different locations. For example, 6:00 +0200 and 4:00 UTC are Equal. See the documentation on the Time type for the pitfalls of using == with Time values; most code should use Equal instead. package main import ( \"fmt\" \"time\" ) func main() { secondsEastOfUTC := int((8 * time.Hour).Seconds()) beijing := time.FixedZone(\"Beijing Time\", secondsEastOfUTC) // Unlike the equal operator, Equal is aware that d1 and d2 are the // same instant but in different time zones. d1 := time.Date(2000, 2, 1, 12, 30, 0, 0, time.UTC) d2 := time.Date(2000, 2, 1, 20, 30, 0, 0, beijing) datesEqualUsingEqualOperator := d1 == d2 datesEqualUsingFunction := d1.Equal(d2) fmt.Printf(\"datesEqualUsingEqualOperator = %v\n\n\", datesEqualUsingEqualOperator) fmt.Printf(\"datesEqualUsingFunction = %v\n\n\", datesEqualUsingFunction) } Format returns a textual representation of the time value formatted according to the layout defined by the argument. See the documentation for the constant called Layout to see how to represent the layout format. The executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference. package main import ( \"fmt\" \"time\" ) func main() { // Parse a time value from a string in the standard Unix format. t, err := time.Parse(time.UnixDate, \"Wed Feb 25 11:06:39 PST 2015\") if err != nil { // Always check errors even if they should not happen. panic(err) } tz, err := time.LoadLocation(\"Asia/Shanghai\") if err != nil { // Always check errors even if they should not happen. panic(err) } // time.Time's Stringer method is useful without any format. fmt.Println(\"default format:\", t) // Predefined constants in the package implement common layouts. fmt.Println(\"Unix format:\", t.Format(time.UnixDate)) // The time zone attached to the time value affects its output. fmt.Println(\"Same, in UTC:\", t.UTC().Format(time.UnixDate)) fmt.Println(\"in Shanghai with seconds:\", t.In(tz).Format(\"2006-01-02T15:04:05 -070000\")) fmt.Println(\"in Shanghai with colon seconds:\", t.In(tz).Format(\"2006-01-02T15:04:05 -07:00:00\")) // The rest of this function demonstrates the properties of the // layout string used in the format. // The layout string used by the Parse function and Format method // shows by example how the reference time should be represented. // We stress that one must show how the reference time is formatted, // not a time of the user's choosing. Thus each layout string is a // representation of the time stamp, // Jan 2 15:04:05 2006 MST // An easy way to remember this value is that it holds, when presented // in this order, the values (lined up with the elements above): // 1 2 3 4 5 6 -7 // There are some wrinkles illustrated below. // Most uses of Format and Parse use constant layout strings such as // the ones defined in this package, but the interface is flexible, // as these examples show. // Define a helper function to make the examples' output look nice. do := func(name, layout, want string) { got := t.Format(layout) if want != got { fmt.Printf(\"error: for %q got %q; expected %q\n\n\", layout, got, want) return } fmt.Printf(\"%-16s %q gives %q\n\n\", name, layout, got) } // Print a header in our output. fmt.Printf(\"\n\nFormats:\n\n\n\n\") // Simple starter examples. do(\"Basic full date\", \"Mon Jan 2 15:04:05 MST 2006\", \"Wed Feb 25 11:06:39 PST 2015\") do(\"Basic short date\", \"2006/01/02\", \"2015/02/25\") // The hour of the reference time is 15, or 3PM. The layout can express // it either way, and since our value is the morning we should see it as // an AM time. We show both in one format string. Lower case too. do(\"AM/PM\", \"3PM==3pm==15h\", \"11AM==11am==11h\") // When parsing, if the seconds value is followed by a decimal point // and some digits, that is taken as a fraction of a second even if // the layout string does not represent the fractional second. // Here we add a fractional second to our time value used above. t, err = time.Parse(time.UnixDate, \"Wed Feb 25 11:06:39.1234 PST 2015\") if err != nil { panic(err) } // It does not appear in the output if the layout string does not contain // a representation of the fractional second. do(\"No fraction\", time.UnixDate, \"Wed Feb 25 11:06:39 PST 2015\") // Fractional seconds can be printed by adding a run of 0s or 9s after // a decimal point in the seconds value in the layout string. // If the layout digits are 0s, the fractional second is of the specified // width. Note that the output has a trailing zero. do(\"0s for fraction\", \"15:04:05.00000\", \"11:06:39.12340\") // If the fraction in the layout is 9s, trailing zeros are dropped. do(\"9s for fraction\", \"15:04:05.99999999\", \"11:06:39.1234\") } default format: 2015-02-25 11:06:39 -0800 PST Unix format: Wed Feb 25 11:06:39 PST 2015 Same, in UTC: Wed Feb 25 19:06:39 UTC 2015 in Shanghai with seconds: 2015-02-26T03:06:39 +080000 in Shanghai with colon seconds: 2015-02-26T03:06:39 +08:00:00 Formats: Basic full date \"Mon Jan 2 15:04:05 MST 2006\" gives \"Wed Feb 25 11:06:39 PST 2015\" Basic short date \"2006/01/02\" gives \"2015/02/25\" AM/PM \"3PM==3pm==15h\" gives \"11AM==11am==11h\" No fraction \"Mon Jan _2 15:04:05 MST 2006\" gives \"Wed Feb 25 11:06:39 PST 2015\" 0s for fraction \"15:04:05.00000\" gives \"11:06:39.12340\" 9s for fraction \"15:04:05.99999999\" gives \"11:06:39.1234\" package main import ( \"fmt\" \"time\" ) func main() { // Parse a time value from a string in the standard Unix format. t, err := time.Parse(time.UnixDate, \"Sat Mar 7 11:06:39 PST 2015\") if err != nil { // Always check errors even if they should not happen. panic(err) } // Define a helper function to make the examples' output look nice. do := func(name, layout, want string) { got := t.Format(layout) if want != got { fmt.Printf(\"error: for %q got %q; expected %q\n\n\", layout, got, want) return } fmt.Printf(\"%-16s %q gives %q\n\n\", name, layout, got) } // The predefined constant Unix uses an underscore to pad the day. do(\"Unix\", time.UnixDate, \"Sat Mar 7 11:06:39 PST 2015\") // For fixed-width printing of values, such as the date, that may be one or // two characters (7 vs. 07), use an _ instead of a space in the layout string. // Here we print just the day, which is 2 in our layout string and 7 in our // value. do(\"No pad\", \"<2>\", \"<7>\") // An underscore represents a space pad, if the date only has one digit. do(\"Spaces\", \"<_2>\", \"< 7>\") // A \"0\" indicates zero padding for single-digit values. do(\"Zeros\", \"<02>\", \"<07>\") // If the value is already the right width, padding is not used. // For instance, the second (05 in the reference time) in our value is 39, // so it doesn't need padding, but the minutes (04, 06) does. do(\"Suppressed pad\", \"04:05\", \"06:39\") } Unix \"Mon Jan _2 15:04:05 MST 2006\" gives \"Sat Mar 7 11:06:39 PST 2015\" No pad \"<2>\" gives \"<7>\" Spaces \"<_2>\" gives \"< 7>\" Zeros \"<02>\" gives \"<07>\" Suppressed pad \"04:05\" gives \"06:39\" GoString implements fmt.GoStringer and formats t to be printed in Go source code. Hour returns the hour within the day specified by t, in the range [0, 23]. ISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1. In returns a copy of t representing the same time instant, but with the copy's location information set to loc for display purposes. IsDST reports whether the time in the configured location is in Daylight Savings Time. IsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC. Local returns t with the location set to local time. Location returns the time zone information associated with t. MarshalJSON implements the encoding/json.Marshaler interface. The time is a quoted string in the RFC 3339 format with sub-second precision. If the timestamp cannot be represented as valid RFC 3339 (e.g., the year is out of range), then an error is reported. MarshalText implements the encoding.TextMarshaler interface. The output matches that of calling the Time.AppendText method. See Time.AppendText for more information. Minute returns the minute offset within the hour specified by t, in the range [0, 59]. Month returns the month of the year specified by t. Nanosecond returns the nanosecond offset within the second specified by t, in the range [0, 999999999]. Round returns the result of rounding t to the nearest multiple of d (since the zero time). The rounding behavior for halfway values is to round up. If d <= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged. Round operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Round(Hour) may return a time with a non-zero minute, depending on the time's Location. Second returns the second offset within the minute specified by t, in the range [0, 59]. String returns the time formatted using the format string If the time has a monotonic clock reading, the returned string includes a final field \"m=¬±<value>\", where value is the monotonic clock reading formatted as a decimal number of seconds. The returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string. Sub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d). Truncate returns the result of rounding t down to a multiple of d (since the zero time). If d <= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged. Truncate operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Truncate(Hour) may return a time with a non-zero minute, depending on the time's Location. package main import ( \"fmt\" \"time\" ) func main() { t, _ := time.Parse(\"2006 Jan 02 15:04:05\", \"2012 Dec 07 12:15:30.918273645\") trunc := []time.Duration{ time.Nanosecond, time.Microsecond, time.Millisecond, time.Second, 2 * time.Second, time.Minute, 10 * time.Minute, } for _, d := range trunc { fmt.Printf(\"t.Truncate(%5s) = %s\n\n\", d, t.Truncate(d).Format(\"15:04:05.999999999\")) } // To round to the last midnight in the local timezone, create a new Date. midnight := time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, time.Local) _ = midnight } UTC returns t with the location set to UTC. Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t. Unix-like operating systems often record time as a 32-bit count of seconds, but since the method here returns a 64-bit value it is valid for billions of years into the past or future. package main import ( \"fmt\" \"time\" ) func main() { // 1 billion seconds of Unix, three ways. fmt.Println(time.Unix(1e9, 0).UTC()) // 1e9 seconds fmt.Println(time.Unix(0, 1e18).UTC()) // 1e18 nanoseconds fmt.Println(time.Unix(2e9, -1e18).UTC()) // 2e9 seconds - 1e18 nanoseconds t := time.Date(2001, time.September, 9, 1, 46, 40, 0, time.UTC) fmt.Println(t.Unix()) // seconds since 1970 fmt.Println(t.UnixNano()) // nanoseconds since 1970 } UnixMicro returns t as a Unix time, the number of microseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in microseconds cannot be represented by an int64 (a date before year -290307 or after year 294246). The result does not depend on the location associated with t. UnixMilli returns t as a Unix time, the number of milliseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in milliseconds cannot be represented by an int64 (a date more than 292 million years before or after 1970). The result does not depend on the location associated with t. UnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t. UnmarshalJSON implements the encoding/json.Unmarshaler interface. The time must be a quoted string in the RFC 3339 format. UnmarshalText implements the encoding.TextUnmarshaler interface. The time must be in the RFC 3339 format. Weekday returns the day of the week specified by t. Year returns the year in which t occurs. YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years, and [1,366] in leap years. Zone computes the time zone in effect at time t, returning the abbreviated name of the zone (such as \"CET\") and its offset in seconds east of UTC. ZoneBounds returns the bounds of the time zone in effect at time t. The zone begins at start and the next zone begins at end. If the zone begins at the beginning of time, start will be returned as a zero Time. If the zone goes on forever, end will be returned as a zero Time. The Location of the returned times will be the same as t. The Timer type represents a single event. When the Timer expires, the current time will be sent on C, unless the Timer was created by AfterFunc. A Timer must be created with NewTimer or AfterFunc. AfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that can be used to cancel the call using its Stop method. The returned Timer's C field is not used and will be nil. NewTimer creates a new Timer that will send the current time on its channel after at least duration d. Before Go 1.23, the garbage collector did not recover timers that had not yet expired or been stopped, so code often immediately deferred t.Stop after calling NewTimer, to make the timer recoverable when it was no longer needed. As of Go 1.23, the garbage collector can recover unreferenced timers, even if they haven't expired or been stopped. The Stop method is no longer necessary to help the garbage collector. (Code may of course still want to call Stop to stop the timer for other reasons.) Before Go 1.23, the channel associated with a Timer was asynchronous (buffered, capacity 1), which meant that stale time values could be received even after Timer.Stop or Timer.Reset returned. As of Go 1.23, the channel is synchronous (unbuffered, capacity 0), eliminating the possibility of those stale values. The GODEBUG setting asynctimerchan=1 restores both pre-Go 1.23 behaviors: when set, unexpired timers won't be garbage collected, and channels will have buffered capacity. This setting may be removed in Go 1.27 or later. Reset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped. For a func-based timer created with AfterFunc(d, f), Reset either reschedules when f will run, in which case Reset returns true, or schedules f to run again, in which case it returns false. When Reset returns false, Reset neither waits for the prior f to complete before returning nor does it guarantee that the subsequent goroutine running f does not run concurrently with the prior one. If the caller needs to know whether the prior execution of f is completed, it must coordinate with f explicitly. For a chan-based timer created with NewTimer, as of Go 1.23, any receive from t.C after Reset has returned is guaranteed not to receive a time value corresponding to the previous timer settings; if the program has not received from t.C already and the timer is running, Reset is guaranteed to return true. Before Go 1.23, the only safe way to use Reset was to call Timer.Stop and explicitly drain the timer first. See the NewTimer documentation for more details. Stop prevents the Timer from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped. For a func-based timer created with AfterFunc(d, f), if t.Stop returns false, then the timer has already expired and the function f has been started in its own goroutine; Stop does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly. For a chan-based timer created with NewTimer(d), as of Go 1.23, any receive from t.C after Stop has returned is guaranteed to block rather than receive a stale time value from before the Stop; if the program has not received from t.C already and the timer is running, Stop is guaranteed to return true. Before Go 1.23, the only safe way to use Stop was insert an extra <-t.C if Stop returned false to drain a potential stale value. See the NewTimer documentation for more details. String returns the English name of the day (\"Sunday\", \"Monday\", ...)."
    },
    {
        "link": "https://go.dev/pkg/time?m=old",
        "document": "Package time provides functionality for measuring and displaying time. The calendrical calculations always assume a Gregorian calendar, with no leap seconds. Operating systems provide both a ‚Äúwall clock,‚Äù which is subject to changes for clock synchronization, and a ‚Äúmonotonic clock,‚Äù which is not. The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time. Rather than split the API, in this package the Time returned by time.Now contains both a wall clock reading and a monotonic clock reading; later time-telling operations use the wall clock reading, but later time-measuring operations, specifically comparisons and subtractions, use the monotonic clock reading. For example, this code always computes a positive elapsed time of approximately 20 milliseconds, even if the wall clock is changed during the operation being timed: Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets. The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package. The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0). If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings. On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u. The same applies to other functions and methods that subtract times, such as Since, Until, Time.Before, Time.After, Time.Add, Time.Equal and Time.Compare. In some cases, you may need to strip the monotonic clock to get accurate results. Because the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading. The monotonic clock reading exists only in Time values. It is not a part of Duration values or the Unix times returned by t.Unix and friends. Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values. For debugging, the result of t.String does include the monotonic clock reading if present. If t != u because of different monotonic clock readings, that difference will be visible when printing t.String() and u.String(). Timer resolution varies depending on the Go runtime, the operating system and the underlying hardware. On Unix, the resolution is ~1ms. On Windows version 1803 and newer, the resolution is ~0.5ms. On older Windows versions, the default resolution is ~16ms, but a higher resolution may be requested using golang.org/x/sys/windows.TimeBeginPeriod.\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp:\n\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as:\n\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day.\n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference.\n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the RFC1123 or RFC1123Z formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted.\n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string.\n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value.\n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse.\n\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus:\n\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value.\n\nThe formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format.\n\nA comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision.\n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information.\n\nCommon durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions.\n\nTo count the number of units in a Duration, divide:\n\nTo convert an integer number of units to a Duration, multiply:\n\nAfter waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to NewTimer(d).C.\n\nBefore Go 1.23, this documentation warned that the underlying Timer would not be recovered by the garbage collector until the timer fired, and that if efficiency was a concern, code should use NewTimer instead and call Timer.Stop if the timer is no longer needed. As of Go 1.23, the garbage collector can recover unreferenced, unstopped timers. There is no reason to prefer NewTimer when After will do.\n\nSleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately.\n\nTick is a convenience wrapper for NewTicker providing access to the ticking channel only. Unlike NewTicker, Tick will return nil if d <= 0.\n\nBefore Go 1.23, this documentation warned that the underlying Ticker would never be recovered by the garbage collector, and that if efficiency was a concern, code should use NewTicker instead and call Ticker.Stop when the ticker is no longer needed. As of Go 1.23, the garbage collector can recover unreferenced tickers, even if they haven't been stopped. The Stop method is no longer necessary to help the garbage collector. There is no longer any reason to prefer NewTicker when Tick will do.\n\nA Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.\n\nParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"¬µs\"), \"ms\", \"s\", \"m\", \"h\".\n\nSince returns the time elapsed since t. It is shorthand for time.Now().Sub(t).\n\nUntil returns the duration until t. It is shorthand for t.Sub(time.Now()).\n\nAbs returns the absolute value of d. As a special case, Duration(math.MinInt64) is converted to Duration(math.MaxInt64), reducing its magnitude by 1 nanosecond.\n\nHours returns the duration as a floating point number of hours.\n\nMicroseconds returns the duration as an integer microsecond count.\n\nMilliseconds returns the duration as an integer millisecond count.\n\nMinutes returns the duration as a floating point number of minutes.\n\nNanoseconds returns the duration as an integer nanosecond count.\n\nRound returns the result of rounding d to the nearest multiple of m. The rounding behavior for halfway values is to round away from zero. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, Round returns the maximum (or minimum) duration. If m <= 0, Round returns d unchanged.\n\nSeconds returns the duration as a floating point number of seconds.\n\nString returns a string representing the duration in the form \"72h3m0.5s\". Leading zero units are omitted. As a special case, durations less than one second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure that the leading digit is non-zero. The zero duration formats as 0s.\n\nTruncate returns the result of rounding d toward zero to a multiple of m. If m <= 0, Truncate returns d unchanged.\n\nA Location maps time instants to the zone in use at that time. Typically, the Location represents the collection of time offsets in use in a geographical area. For many Locations the time offset varies depending on whether daylight savings time is in use at the time instant.\n\nLocation is used to provide a time zone in a printed Time value and for calculations involving intervals that may cross daylight savings time boundaries.\n\nLocal represents the system's local time zone. On Unix systems, Local consults the TZ environment variable to find the time zone to use. No TZ means use the system default /etc/localtime. TZ=\"\" means use UTC. TZ=\"foo\" means use file foo in the system timezone directory.\n\nFixedZone returns a Location that always uses the given zone name and offset (seconds east of UTC).\n\nLoadLocation returns the Location with the given name.\n\nIf the name is \"\" or \"UTC\", LoadLocation returns UTC. If the name is \"Local\", LoadLocation returns Local.\n\nOtherwise, the name is taken to be a location name corresponding to a file in the IANA Time Zone database, such as \"America/New_York\".\n\nLoadLocation looks for the IANA Time Zone database in the following locations in order:\n‚Ä¢ the directory or uncompressed zip file named by the ZONEINFO environment variable\n‚Ä¢ the time/tzdata package, if it was imported\n\nLoadLocationFromTZData returns a Location with the given name initialized from the IANA Time Zone database-formatted data. The data should be in the format of a standard IANA time zone file (for example, the content of /etc/localtime on Unix systems).\n\nString returns a descriptive name for the time zone information, corresponding to the name argument to LoadLocation or FixedZone.\n\nString returns the English name of the month (\"January\", \"February\", ...).\n\nA Ticker holds a channel that delivers ‚Äúticks‚Äù of a clock at intervals.\n\nNewTicker returns a new Ticker containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic.\n\nBefore Go 1.23, the garbage collector did not recover tickers that had not yet expired or been stopped, so code often immediately deferred t.Stop after calling NewTicker, to make the ticker recoverable when it was no longer needed. As of Go 1.23, the garbage collector can recover unreferenced tickers, even if they haven't been stopped. The Stop method is no longer necessary to help the garbage collector. (Code may of course still want to call Stop to stop the ticker for other reasons.)\n\nReset stops a ticker and resets its period to the specified duration. The next tick will arrive after the new period elapses. The duration d must be greater than zero; if not, Reset will panic.\n\nStop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous \"tick\".\n\nA Time represents an instant in time with nanosecond precision.\n\nPrograms using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type time.Time, not *time.Time.\n\nA Time value can be used by multiple goroutines simultaneously except that the methods Time.GobDecode, Time.UnmarshalBinary, Time.UnmarshalJSON and Time.UnmarshalText are not concurrency-safe.\n\nTime instants can be compared using the Time.Before, Time.After, and Time.Equal methods. The Time.Sub method subtracts two instants, producing a Duration. The Time.Add method adds a Time and a Duration, producing a Time.\n\nThe zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the Time.IsZero method gives a simple way of detecting a time that has not been initialized explicitly.\n\nEach time has an associated Location. The methods Time.Local, Time.UTC, and Time.In return a Time with a specific Location. Changing the Location of a Time value with these methods does not change the actual instant it represents, only the time zone in which to interpret it.\n\nRepresentations of a Time value saved by the Time.GobEncode, Time.MarshalBinary, Time.AppendBinary, Time.MarshalJSON, Time.MarshalText and Time.AppendText methods store the Time.Location's offset, but not the location name. They therefore lose information about Daylight Saving Time.\n\nIn addition to the required ‚Äúwall clock‚Äù reading, a Time may contain an optional reading of the current process's monotonic clock, to provide additional precision for comparison or subtraction. See the ‚ÄúMonotonic Clocks‚Äù section in the package documentation for details.\n\nNote that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. Therefore, Time values should not be used as map or database keys without first guaranteeing that the identical Location has been set for all values, which can be achieved through use of the UTC or Local method, and that the monotonic clock reading has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u) to t == u, since t.Equal uses the most accurate comparison available and correctly handles the case when only one of its arguments has a monotonic clock reading.\n\nDate returns the Time corresponding to\n\nin the appropriate zone for that time in the given location.\n\nThe month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1.\n\nA daylight savings time transition skips or repeats times. For example, in the United States, March 13, 2011 2:15am never occurred, while November 6, 2011 1:15am occurred twice. In such cases, the choice of time zone, and therefore the time, is not well-defined. Date returns a time that is correct in one of the two zones involved in the transition, but it does not guarantee which.\n\nParse parses a formatted string and returns the time value it represents. See the documentation for the constant called Layout to see how to represent the format. The second argument must be parseable using the format string (layout) provided as the first argument.\n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference.\n\nWhen parsing (only), the input may contain a fractional second field immediately after the seconds field, even if the layout does not signify its presence. In that case either a comma or a decimal point followed by a maximal series of digits is parsed as a fractional second. Fractional seconds are truncated to nanosecond precision.\n\nElements omitted from the layout are assumed to be zero or, when zero is impossible, one, so parsing \"3:04pm\" returns the time corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is 0, this time is before the zero Time). Years must be in the range 0000..9999. The day of the week is checked for syntax but it is otherwise ignored.\n\nFor layouts specifying the two-digit year 06, a value NN >= 69 will be treated as 19NN and a value NN < 69 will be treated as 20NN.\n\nThe remainder of this comment describes the handling of time zones.\n\nIn the absence of a time zone indicator, Parse returns a time in UTC.\n\nWhen parsing a time with a zone offset like -0700, if the offset corresponds to a time zone used by the current location (Local), then Parse uses that location and zone in the returned time. Otherwise it records the time as being in a fabricated location with time fixed at the given zone offset.\n\nWhen parsing a time with a zone abbreviation like MST, if the zone abbreviation has a defined offset in the current location, then that offset is used. The zone abbreviation \"UTC\" is recognized as UTC regardless of location. If the zone abbreviation is unknown, Parse records the time as being in a fabricated location with the given zone abbreviation and a zero offset. This choice means that such a time can be parsed and reformatted with the same layout losslessly, but the exact instant used in the representation will differ by the actual zone offset. To avoid such problems, prefer time layouts that use a numeric zone offset, or use ParseInLocation.\n\nParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location.\n\nUnix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range [0, 999999999]. Not all sec values have a corresponding time value. One such value is 1<<63-1 (the largest int64 value).\n\nUnixMicro returns the local Time corresponding to the given Unix time, usec microseconds since January 1, 1970 UTC.\n\nUnixMilli returns the local Time corresponding to the given Unix time, msec milliseconds since January 1, 1970 UTC.\n\nAddDate returns the time corresponding to adding the given number of years, months, and days to t. For example, AddDate(-1, 2, 3) applied to January 1, 2011 returns March 4, 2010.\n\nNote that dates are fundamentally coupled to timezones, and calendrical periods like days don't have fixed durations. AddDate uses the Location of the Time value to determine these durations. That means that the same AddDate arguments can produce a different shift in absolute time depending on the base Time value and its Location. For example, AddDate(0, 0, 1) applied to 12:00 on March 27 always returns 12:00 on March 28. At some locations and in some years this is a 24 hour shift. In others it's a 23 hour shift due to daylight savings time transitions.\n\nAddDate normalizes its result in the same way that Date does, so, for example, adding one month to October 31 yields December 1, the normalized form for November 31.\n\nAfter reports whether the time instant t is after u.\n\nAppendFormat is like Time.Format but appends the textual representation to b and returns the extended buffer.\n\nAppendText implements the encoding.TextAppender interface. The time is formatted in RFC 3339 format with sub-second precision. If the timestamp cannot be represented as valid RFC 3339 (e.g., the year is out of range), then an error is returned.\n\nBefore reports whether the time instant t is before u.\n\nClock returns the hour, minute, and second within the day specified by t.\n\nCompare compares the time instant t with u. If t is before u, it returns -1; if t is after u, it returns +1; if they're the same, it returns 0.\n\nDate returns the year, month, and day in which t occurs.\n\nDay returns the day of the month specified by t.\n\nEqual reports whether t and u represent the same time instant. Two times can be equal even if they are in different locations. For example, 6:00 +0200 and 4:00 UTC are Equal. See the documentation on the Time type for the pitfalls of using == with Time values; most code should use Equal instead.\n\nFormat returns a textual representation of the time value formatted according to the layout defined by the argument. See the documentation for the constant called Layout to see how to represent the layout format.\n\nThe executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.\n\nGoString implements fmt.GoStringer and formats t to be printed in Go source code.\n\nHour returns the hour within the day specified by t, in the range [0, 23].\n\nISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1.\n\nIn returns a copy of t representing the same time instant, but with the copy's location information set to loc for display purposes.\n\nIn panics if loc is nil.\n\nIsDST reports whether the time in the configured location is in Daylight Savings Time.\n\nIsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC.\n\nLocal returns t with the location set to local time.\n\nLocation returns the time zone information associated with t.\n\nMarshalJSON implements the encoding/json.Marshaler interface. The time is a quoted string in the RFC 3339 format with sub-second precision. If the timestamp cannot be represented as valid RFC 3339 (e.g., the year is out of range), then an error is reported.\n\nMarshalText implements the encoding.TextMarshaler interface. The output matches that of calling the Time.AppendText method.\n\nSee Time.AppendText for more information.\n\nMinute returns the minute offset within the hour specified by t, in the range [0, 59].\n\nMonth returns the month of the year specified by t.\n\nNanosecond returns the nanosecond offset within the second specified by t, in the range [0, 999999999].\n\nRound returns the result of rounding t to the nearest multiple of d (since the zero time). The rounding behavior for halfway values is to round up. If d <= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.\n\nRound operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Round(Hour) may return a time with a non-zero minute, depending on the time's Location.\n\nSecond returns the second offset within the minute specified by t, in the range [0, 59].\n\nString returns the time formatted using the format string\n\nIf the time has a monotonic clock reading, the returned string includes a final field \"m=¬±<value>\", where value is the monotonic clock reading formatted as a decimal number of seconds.\n\nThe returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string.\n\nSub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d).\n\nTruncate returns the result of rounding t down to a multiple of d (since the zero time). If d <= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.\n\nTruncate operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Truncate(Hour) may return a time with a non-zero minute, depending on the time's Location.\n\nUTC returns t with the location set to UTC.\n\nUnix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t. Unix-like operating systems often record time as a 32-bit count of seconds, but since the method here returns a 64-bit value it is valid for billions of years into the past or future.\n\nUnixMicro returns t as a Unix time, the number of microseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in microseconds cannot be represented by an int64 (a date before year -290307 or after year 294246). The result does not depend on the location associated with t.\n\nUnixMilli returns t as a Unix time, the number of milliseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in milliseconds cannot be represented by an int64 (a date more than 292 million years before or after 1970). The result does not depend on the location associated with t.\n\nUnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t.\n\nUnmarshalJSON implements the encoding/json.Unmarshaler interface. The time must be a quoted string in the RFC 3339 format.\n\nUnmarshalText implements the encoding.TextUnmarshaler interface. The time must be in the RFC 3339 format.\n\nWeekday returns the day of the week specified by t.\n\nYear returns the year in which t occurs.\n\nYearDay returns the day of the year specified by t, in the range [1,365] for non-leap years, and [1,366] in leap years.\n\nZone computes the time zone in effect at time t, returning the abbreviated name of the zone (such as \"CET\") and its offset in seconds east of UTC.\n\nZoneBounds returns the bounds of the time zone in effect at time t. The zone begins at start and the next zone begins at end. If the zone begins at the beginning of time, start will be returned as a zero Time. If the zone goes on forever, end will be returned as a zero Time. The Location of the returned times will be the same as t.\n\nThe Timer type represents a single event. When the Timer expires, the current time will be sent on C, unless the Timer was created by AfterFunc. A Timer must be created with NewTimer or AfterFunc.\n\nAfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that can be used to cancel the call using its Stop method. The returned Timer's C field is not used and will be nil.\n\nNewTimer creates a new Timer that will send the current time on its channel after at least duration d.\n\nBefore Go 1.23, the garbage collector did not recover timers that had not yet expired or been stopped, so code often immediately deferred t.Stop after calling NewTimer, to make the timer recoverable when it was no longer needed. As of Go 1.23, the garbage collector can recover unreferenced timers, even if they haven't expired or been stopped. The Stop method is no longer necessary to help the garbage collector. (Code may of course still want to call Stop to stop the timer for other reasons.)\n\nBefore Go 1.23, the channel associated with a Timer was asynchronous (buffered, capacity 1), which meant that stale time values could be received even after Timer.Stop or Timer.Reset returned. As of Go 1.23, the channel is synchronous (unbuffered, capacity 0), eliminating the possibility of those stale values.\n\nThe GODEBUG setting asynctimerchan=1 restores both pre-Go 1.23 behaviors: when set, unexpired timers won't be garbage collected, and channels will have buffered capacity. This setting may be removed in Go 1.27 or later.\n\nReset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped.\n\nFor a func-based timer created with AfterFunc(d, f), Reset either reschedules when f will run, in which case Reset returns true, or schedules f to run again, in which case it returns false. When Reset returns false, Reset neither waits for the prior f to complete before returning nor does it guarantee that the subsequent goroutine running f does not run concurrently with the prior one. If the caller needs to know whether the prior execution of f is completed, it must coordinate with f explicitly.\n\nFor a chan-based timer created with NewTimer, as of Go 1.23, any receive from t.C after Reset has returned is guaranteed not to receive a time value corresponding to the previous timer settings; if the program has not received from t.C already and the timer is running, Reset is guaranteed to return true. Before Go 1.23, the only safe way to use Reset was to call Timer.Stop and explicitly drain the timer first. See the NewTimer documentation for more details.\n\nStop prevents the Timer from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped.\n\nFor a func-based timer created with AfterFunc(d, f), if t.Stop returns false, then the timer has already expired and the function f has been started in its own goroutine; Stop does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly.\n\nFor a chan-based timer created with NewTimer(d), as of Go 1.23, any receive from t.C after Stop has returned is guaranteed to block rather than receive a stale time value from before the Stop; if the program has not received from t.C already and the timer is running, Stop is guaranteed to return true. Before Go 1.23, the only safe way to use Stop was insert an extra <-t.C if Stop returned false to drain a potential stale value. See the NewTimer documentation for more details.\n\nString returns the English name of the day (\"Sunday\", \"Monday\", ...)."
    },
    {
        "link": "https://golang.google.cn/pkg/time",
        "document": "Package time provides functionality for measuring and displaying time. The calendrical calculations always assume a Gregorian calendar, with no leap seconds. Operating systems provide both a ‚Äúwall clock,‚Äù which is subject to changes for clock synchronization, and a ‚Äúmonotonic clock,‚Äù which is not. The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time. Rather than split the API, in this package the Time returned by time.Now contains both a wall clock reading and a monotonic clock reading; later time-telling operations use the wall clock reading, but later time-measuring operations, specifically comparisons and subtractions, use the monotonic clock reading. For example, this code always computes a positive elapsed time of approximately 20 milliseconds, even if the wall clock is changed during the operation being timed: Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets. The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package. The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0). If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings. On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u. The same applies to other functions and methods that subtract times, such as Since, Until, Time.Before, Time.After, Time.Add, Time.Equal and Time.Compare. In some cases, you may need to strip the monotonic clock to get accurate results. Because the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading. The monotonic clock reading exists only in Time values. It is not a part of Duration values or the Unix times returned by t.Unix and friends. Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values. For debugging, the result of t.String does include the monotonic clock reading if present. If t != u because of different monotonic clock readings, that difference will be visible when printing t.String() and u.String(). Timer resolution varies depending on the Go runtime, the operating system and the underlying hardware. On Unix, the resolution is ~1ms. On Windows version 1803 and newer, the resolution is ~0.5ms. On older Windows versions, the default resolution is ~16ms, but a higher resolution may be requested using golang.org/x/sys/windows.TimeBeginPeriod.\n\nThese are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp:\n\n(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as:\n\nIt is a regrettable historic error that the date uses the American convention of putting the numerical month before the day.\n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference.\n\nNote that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use \"UTC\" as the time zone abbreviation, while strictly speaking those RFCs require the use of \"GMT\" in that case. When using the RFC1123 or RFC1123Z formats for parsing, note that these formats define a leading zero for the day-in-month portion, which is not strictly allowed by RFC 1123. This will result in an error when parsing date strings that occur in the first 9 days of a given month. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted.\n\nMost programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string.\n\nTo define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value.\n\nHere is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse.\n\nReplacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus:\n\nWithin the format string, the underscores in \"_2\" and \"__2\" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value.\n\nThe formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format.\n\nA comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example \"15:04:05,000\" or \"15:04:05.000\" formats or parses with millisecond precision.\n\nSome valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information.\n\nCommon durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions.\n\nTo count the number of units in a Duration, divide:\n\nTo convert an integer number of units to a Duration, multiply:\n\nAfter waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to NewTimer(d).C.\n\nBefore Go 1.23, this documentation warned that the underlying Timer would not be recovered by the garbage collector until the timer fired, and that if efficiency was a concern, code should use NewTimer instead and call Timer.Stop if the timer is no longer needed. As of Go 1.23, the garbage collector can recover unreferenced, unstopped timers. There is no reason to prefer NewTimer when After will do.\n\nSleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately.\n\nTick is a convenience wrapper for NewTicker providing access to the ticking channel only. Unlike NewTicker, Tick will return nil if d <= 0.\n\nBefore Go 1.23, this documentation warned that the underlying Ticker would never be recovered by the garbage collector, and that if efficiency was a concern, code should use NewTicker instead and call Ticker.Stop when the ticker is no longer needed. As of Go 1.23, the garbage collector can recover unreferenced tickers, even if they haven't been stopped. The Stop method is no longer necessary to help the garbage collector. There is no longer any reason to prefer NewTicker when Tick will do.\n\nA Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.\n\nParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as \"300ms\", \"-1.5h\" or \"2h45m\". Valid time units are \"ns\", \"us\" (or \"¬µs\"), \"ms\", \"s\", \"m\", \"h\".\n\nSince returns the time elapsed since t. It is shorthand for time.Now().Sub(t).\n\nUntil returns the duration until t. It is shorthand for t.Sub(time.Now()).\n\nAbs returns the absolute value of d. As a special case, Duration(math.MinInt64) is converted to Duration(math.MaxInt64), reducing its magnitude by 1 nanosecond.\n\nHours returns the duration as a floating point number of hours.\n\nMicroseconds returns the duration as an integer microsecond count.\n\nMilliseconds returns the duration as an integer millisecond count.\n\nMinutes returns the duration as a floating point number of minutes.\n\nNanoseconds returns the duration as an integer nanosecond count.\n\nRound returns the result of rounding d to the nearest multiple of m. The rounding behavior for halfway values is to round away from zero. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, Round returns the maximum (or minimum) duration. If m <= 0, Round returns d unchanged.\n\nSeconds returns the duration as a floating point number of seconds.\n\nString returns a string representing the duration in the form \"72h3m0.5s\". Leading zero units are omitted. As a special case, durations less than one second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure that the leading digit is non-zero. The zero duration formats as 0s.\n\nTruncate returns the result of rounding d toward zero to a multiple of m. If m <= 0, Truncate returns d unchanged.\n\nA Location maps time instants to the zone in use at that time. Typically, the Location represents the collection of time offsets in use in a geographical area. For many Locations the time offset varies depending on whether daylight savings time is in use at the time instant.\n\nLocation is used to provide a time zone in a printed Time value and for calculations involving intervals that may cross daylight savings time boundaries.\n\nLocal represents the system's local time zone. On Unix systems, Local consults the TZ environment variable to find the time zone to use. No TZ means use the system default /etc/localtime. TZ=\"\" means use UTC. TZ=\"foo\" means use file foo in the system timezone directory.\n\nFixedZone returns a Location that always uses the given zone name and offset (seconds east of UTC).\n\nLoadLocation returns the Location with the given name.\n\nIf the name is \"\" or \"UTC\", LoadLocation returns UTC. If the name is \"Local\", LoadLocation returns Local.\n\nOtherwise, the name is taken to be a location name corresponding to a file in the IANA Time Zone database, such as \"America/New_York\".\n\nLoadLocation looks for the IANA Time Zone database in the following locations in order:\n‚Ä¢ the directory or uncompressed zip file named by the ZONEINFO environment variable\n‚Ä¢ the time/tzdata package, if it was imported\n\nLoadLocationFromTZData returns a Location with the given name initialized from the IANA Time Zone database-formatted data. The data should be in the format of a standard IANA time zone file (for example, the content of /etc/localtime on Unix systems).\n\nString returns a descriptive name for the time zone information, corresponding to the name argument to LoadLocation or FixedZone.\n\nString returns the English name of the month (\"January\", \"February\", ...).\n\nA Ticker holds a channel that delivers ‚Äúticks‚Äù of a clock at intervals.\n\nNewTicker returns a new Ticker containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic.\n\nBefore Go 1.23, the garbage collector did not recover tickers that had not yet expired or been stopped, so code often immediately deferred t.Stop after calling NewTicker, to make the ticker recoverable when it was no longer needed. As of Go 1.23, the garbage collector can recover unreferenced tickers, even if they haven't been stopped. The Stop method is no longer necessary to help the garbage collector. (Code may of course still want to call Stop to stop the ticker for other reasons.)\n\nReset stops a ticker and resets its period to the specified duration. The next tick will arrive after the new period elapses. The duration d must be greater than zero; if not, Reset will panic.\n\nStop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous \"tick\".\n\nA Time represents an instant in time with nanosecond precision.\n\nPrograms using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type time.Time, not *time.Time.\n\nA Time value can be used by multiple goroutines simultaneously except that the methods Time.GobDecode, Time.UnmarshalBinary, Time.UnmarshalJSON and Time.UnmarshalText are not concurrency-safe.\n\nTime instants can be compared using the Time.Before, Time.After, and Time.Equal methods. The Time.Sub method subtracts two instants, producing a Duration. The Time.Add method adds a Time and a Duration, producing a Time.\n\nThe zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the Time.IsZero method gives a simple way of detecting a time that has not been initialized explicitly.\n\nEach time has an associated Location. The methods Time.Local, Time.UTC, and Time.In return a Time with a specific Location. Changing the Location of a Time value with these methods does not change the actual instant it represents, only the time zone in which to interpret it.\n\nRepresentations of a Time value saved by the Time.GobEncode, Time.MarshalBinary, Time.AppendBinary, Time.MarshalJSON, Time.MarshalText and Time.AppendText methods store the Time.Location's offset, but not the location name. They therefore lose information about Daylight Saving Time.\n\nIn addition to the required ‚Äúwall clock‚Äù reading, a Time may contain an optional reading of the current process's monotonic clock, to provide additional precision for comparison or subtraction. See the ‚ÄúMonotonic Clocks‚Äù section in the package documentation for details.\n\nNote that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. Therefore, Time values should not be used as map or database keys without first guaranteeing that the identical Location has been set for all values, which can be achieved through use of the UTC or Local method, and that the monotonic clock reading has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u) to t == u, since t.Equal uses the most accurate comparison available and correctly handles the case when only one of its arguments has a monotonic clock reading.\n\nDate returns the Time corresponding to\n\nin the appropriate zone for that time in the given location.\n\nThe month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1.\n\nA daylight savings time transition skips or repeats times. For example, in the United States, March 13, 2011 2:15am never occurred, while November 6, 2011 1:15am occurred twice. In such cases, the choice of time zone, and therefore the time, is not well-defined. Date returns a time that is correct in one of the two zones involved in the transition, but it does not guarantee which.\n\nParse parses a formatted string and returns the time value it represents. See the documentation for the constant called Layout to see how to represent the format. The second argument must be parseable using the format string (layout) provided as the first argument.\n\nThe example for Time.Format demonstrates the working of the layout string in detail and is a good reference.\n\nWhen parsing (only), the input may contain a fractional second field immediately after the seconds field, even if the layout does not signify its presence. In that case either a comma or a decimal point followed by a maximal series of digits is parsed as a fractional second. Fractional seconds are truncated to nanosecond precision.\n\nElements omitted from the layout are assumed to be zero or, when zero is impossible, one, so parsing \"3:04pm\" returns the time corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is 0, this time is before the zero Time). Years must be in the range 0000..9999. The day of the week is checked for syntax but it is otherwise ignored.\n\nFor layouts specifying the two-digit year 06, a value NN >= 69 will be treated as 19NN and a value NN < 69 will be treated as 20NN.\n\nThe remainder of this comment describes the handling of time zones.\n\nIn the absence of a time zone indicator, Parse returns a time in UTC.\n\nWhen parsing a time with a zone offset like -0700, if the offset corresponds to a time zone used by the current location (Local), then Parse uses that location and zone in the returned time. Otherwise it records the time as being in a fabricated location with time fixed at the given zone offset.\n\nWhen parsing a time with a zone abbreviation like MST, if the zone abbreviation has a defined offset in the current location, then that offset is used. The zone abbreviation \"UTC\" is recognized as UTC regardless of location. If the zone abbreviation is unknown, Parse records the time as being in a fabricated location with the given zone abbreviation and a zero offset. This choice means that such a time can be parsed and reformatted with the same layout losslessly, but the exact instant used in the representation will differ by the actual zone offset. To avoid such problems, prefer time layouts that use a numeric zone offset, or use ParseInLocation.\n\nParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location.\n\nUnix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range [0, 999999999]. Not all sec values have a corresponding time value. One such value is 1<<63-1 (the largest int64 value).\n\nUnixMicro returns the local Time corresponding to the given Unix time, usec microseconds since January 1, 1970 UTC.\n\nUnixMilli returns the local Time corresponding to the given Unix time, msec milliseconds since January 1, 1970 UTC.\n\nAddDate returns the time corresponding to adding the given number of years, months, and days to t. For example, AddDate(-1, 2, 3) applied to January 1, 2011 returns March 4, 2010.\n\nNote that dates are fundamentally coupled to timezones, and calendrical periods like days don't have fixed durations. AddDate uses the Location of the Time value to determine these durations. That means that the same AddDate arguments can produce a different shift in absolute time depending on the base Time value and its Location. For example, AddDate(0, 0, 1) applied to 12:00 on March 27 always returns 12:00 on March 28. At some locations and in some years this is a 24 hour shift. In others it's a 23 hour shift due to daylight savings time transitions.\n\nAddDate normalizes its result in the same way that Date does, so, for example, adding one month to October 31 yields December 1, the normalized form for November 31.\n\nAfter reports whether the time instant t is after u.\n\nAppendFormat is like Time.Format but appends the textual representation to b and returns the extended buffer.\n\nAppendText implements the encoding.TextAppender interface. The time is formatted in RFC 3339 format with sub-second precision. If the timestamp cannot be represented as valid RFC 3339 (e.g., the year is out of range), then an error is returned.\n\nBefore reports whether the time instant t is before u.\n\nClock returns the hour, minute, and second within the day specified by t.\n\nCompare compares the time instant t with u. If t is before u, it returns -1; if t is after u, it returns +1; if they're the same, it returns 0.\n\nDate returns the year, month, and day in which t occurs.\n\nDay returns the day of the month specified by t.\n\nEqual reports whether t and u represent the same time instant. Two times can be equal even if they are in different locations. For example, 6:00 +0200 and 4:00 UTC are Equal. See the documentation on the Time type for the pitfalls of using == with Time values; most code should use Equal instead.\n\nFormat returns a textual representation of the time value formatted according to the layout defined by the argument. See the documentation for the constant called Layout to see how to represent the layout format.\n\nThe executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference.\n\nGoString implements fmt.GoStringer and formats t to be printed in Go source code.\n\nHour returns the hour within the day specified by t, in the range [0, 23].\n\nISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1.\n\nIn returns a copy of t representing the same time instant, but with the copy's location information set to loc for display purposes.\n\nIn panics if loc is nil.\n\nIsDST reports whether the time in the configured location is in Daylight Savings Time.\n\nIsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC.\n\nLocal returns t with the location set to local time.\n\nLocation returns the time zone information associated with t.\n\nMarshalJSON implements the encoding/json.Marshaler interface. The time is a quoted string in the RFC 3339 format with sub-second precision. If the timestamp cannot be represented as valid RFC 3339 (e.g., the year is out of range), then an error is reported.\n\nMarshalText implements the encoding.TextMarshaler interface. The output matches that of calling the Time.AppendText method.\n\nSee Time.AppendText for more information.\n\nMinute returns the minute offset within the hour specified by t, in the range [0, 59].\n\nMonth returns the month of the year specified by t.\n\nNanosecond returns the nanosecond offset within the second specified by t, in the range [0, 999999999].\n\nRound returns the result of rounding t to the nearest multiple of d (since the zero time). The rounding behavior for halfway values is to round up. If d <= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.\n\nRound operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Round(Hour) may return a time with a non-zero minute, depending on the time's Location.\n\nSecond returns the second offset within the minute specified by t, in the range [0, 59].\n\nString returns the time formatted using the format string\n\nIf the time has a monotonic clock reading, the returned string includes a final field \"m=¬±<value>\", where value is the monotonic clock reading formatted as a decimal number of seconds.\n\nThe returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string.\n\nSub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d).\n\nTruncate returns the result of rounding t down to a multiple of d (since the zero time). If d <= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.\n\nTruncate operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Truncate(Hour) may return a time with a non-zero minute, depending on the time's Location.\n\nUTC returns t with the location set to UTC.\n\nUnix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t. Unix-like operating systems often record time as a 32-bit count of seconds, but since the method here returns a 64-bit value it is valid for billions of years into the past or future.\n\nUnixMicro returns t as a Unix time, the number of microseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in microseconds cannot be represented by an int64 (a date before year -290307 or after year 294246). The result does not depend on the location associated with t.\n\nUnixMilli returns t as a Unix time, the number of milliseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in milliseconds cannot be represented by an int64 (a date more than 292 million years before or after 1970). The result does not depend on the location associated with t.\n\nUnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t.\n\nUnmarshalJSON implements the encoding/json.Unmarshaler interface. The time must be a quoted string in the RFC 3339 format.\n\nUnmarshalText implements the encoding.TextUnmarshaler interface. The time must be in the RFC 3339 format.\n\nWeekday returns the day of the week specified by t.\n\nYear returns the year in which t occurs.\n\nYearDay returns the day of the year specified by t, in the range [1,365] for non-leap years, and [1,366] in leap years.\n\nZone computes the time zone in effect at time t, returning the abbreviated name of the zone (such as \"CET\") and its offset in seconds east of UTC.\n\nZoneBounds returns the bounds of the time zone in effect at time t. The zone begins at start and the next zone begins at end. If the zone begins at the beginning of time, start will be returned as a zero Time. If the zone goes on forever, end will be returned as a zero Time. The Location of the returned times will be the same as t.\n\nThe Timer type represents a single event. When the Timer expires, the current time will be sent on C, unless the Timer was created by AfterFunc. A Timer must be created with NewTimer or AfterFunc.\n\nAfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that can be used to cancel the call using its Stop method. The returned Timer's C field is not used and will be nil.\n\nNewTimer creates a new Timer that will send the current time on its channel after at least duration d.\n\nBefore Go 1.23, the garbage collector did not recover timers that had not yet expired or been stopped, so code often immediately deferred t.Stop after calling NewTimer, to make the timer recoverable when it was no longer needed. As of Go 1.23, the garbage collector can recover unreferenced timers, even if they haven't expired or been stopped. The Stop method is no longer necessary to help the garbage collector. (Code may of course still want to call Stop to stop the timer for other reasons.)\n\nBefore Go 1.23, the channel associated with a Timer was asynchronous (buffered, capacity 1), which meant that stale time values could be received even after Timer.Stop or Timer.Reset returned. As of Go 1.23, the channel is synchronous (unbuffered, capacity 0), eliminating the possibility of those stale values.\n\nThe GODEBUG setting asynctimerchan=1 restores both pre-Go 1.23 behaviors: when set, unexpired timers won't be garbage collected, and channels will have buffered capacity. This setting may be removed in Go 1.27 or later.\n\nReset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped.\n\nFor a func-based timer created with AfterFunc(d, f), Reset either reschedules when f will run, in which case Reset returns true, or schedules f to run again, in which case it returns false. When Reset returns false, Reset neither waits for the prior f to complete before returning nor does it guarantee that the subsequent goroutine running f does not run concurrently with the prior one. If the caller needs to know whether the prior execution of f is completed, it must coordinate with f explicitly.\n\nFor a chan-based timer created with NewTimer, as of Go 1.23, any receive from t.C after Reset has returned is guaranteed not to receive a time value corresponding to the previous timer settings; if the program has not received from t.C already and the timer is running, Reset is guaranteed to return true. Before Go 1.23, the only safe way to use Reset was to call Timer.Stop and explicitly drain the timer first. See the NewTimer documentation for more details.\n\nStop prevents the Timer from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped.\n\nFor a func-based timer created with AfterFunc(d, f), if t.Stop returns false, then the timer has already expired and the function f has been started in its own goroutine; Stop does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly.\n\nFor a chan-based timer created with NewTimer(d), as of Go 1.23, any receive from t.C after Stop has returned is guaranteed to block rather than receive a stale time value from before the Stop; if the program has not received from t.C already and the timer is running, Stop is guaranteed to return true. Before Go 1.23, the only safe way to use Stop was insert an extra <-t.C if Stop returned false to drain a potential stale value. See the NewTimer documentation for more details.\n\nString returns the English name of the day (\"Sunday\", \"Monday\", ...)."
    },
    {
        "link": "https://hostman.com/tutorials/working-with-date-and-time-in-go-using-the-time-package",
        "document": "Variables are named values stored in specific areas of memory and used during program execution. Go (also known as Golang) is a statically typed programming language. This means that once a variable is declared, its type is fixed and cannot be changed. Variables can have various types, each with its own purpose and characteristics.Go provides several basic data types, which form the foundation of the language's logic: Integer Floating-point String Boolean Additionally, Go supports composite data types: Arrays Slices Structures Maps There are also several auxiliary types: Pointers Interfaces Besides these, Go (similar to C++) includes a Standard Library (std) containing many predefined types. You can find more detailed information about variable types in Go in a separate article. For instructions on installing Go on Linux, Windows, or macOS, refer to the Hostman guides. All the code examples in this tutorial were tested using Go version 1.21.3. Compiling and Running Code All the code examples in this guide are run in separate files with the .go extension. First, create a new file: sudo nano example.go Next, fill it with code inside the main() function, including any necessary modules: package main import \"fmt\" func main() { // start of example var number int = 10 fmt.Println(number) // end of example } Then run the file: go run example.go Declaring a Variable There are different ways to declare a variable in Go before using it‚Äîranging from a full form, explicitly specifying the parameters (or multiple parameters) of the variable, to a shorthand form that uses automatic type inference and initialization. The choice of declaration method depends on the context. However, it‚Äôs generally recommended to use the most concise and automatic form whenever possible, as this reduces the likelihood of programmer errors by shifting some of the responsibility to the language's interpreter. Using the var Keyword The most explicit way to declare a variable in Golang is by using the var keyword, followed by the variable name, type, and value: var some_variable int = 5 However, if the variable is initialized with a value, you can omit the explicit type: var some_variable = 5 You can also declare a variable without assigning a value, but in this case, you must specify the type: var some_variable intsome_variable = 5 In all of these examples: var ‚Äî the keyword for declaring a variable some_variable ‚Äî the variable's name int ‚Äî the variable's type 5 ‚Äî the variable's value For example, this is how you can declare string variables: var some_name string = \"John\" The following declaration will result in an error: // ERROR: no value or type specified during declarationvar some_namesome_name = \"John\" It‚Äôs important to note that type inference is only possible during the initial declaration of the variable when the interpreter allocates the appropriate amount of memory for its value. Short Form := Despite Go's strict static typing, it allows variables to be declared in a more concise form without explicitly specifying their parameters: some_variable := 5 In this case, the interpreter understands that it needs to automatically infer the variable type based on the assigned value. However, this shorthand declaration is only allowed inside a function (including main()); it cannot be used outside a function: package main // ERROR: short form declaration outside of a function some_variable := 5 func main() { // OK: short form declaration inside a function other_variable := 10 } It‚Äôs important to understand the distinction between declaring a variable (with initialization) and assigning a value to it: package main func main() { some_variable := 5 // this is declaration and initialization (colon is present) some_variable = 50 // this is assignment (no colon) other_variable = 7 // ERROR: this is assignment (no colon) to an undeclared variable } For example, you can declare (and initialize) several variables sequentially: age := 50 // variable of type int name := \"John\" // variable of type string occupation := \"Just a guy\" // variable of type string height := 190.5 // variable of type float32 You cannot use the := operator together with the var keyword. Doing so will result in an error: var someVariable int := 5 // ERRORvar someVariable := 5 // ERROR Excluding the var keyword but still explicitly specifying the type will still result in an error: someVariable int := 5 // ERROR Multiple Variables In Go, you can declare multiple variables in one line or block. For example, you can use the var keyword with a single type for all declared variables: var width, height, depth int = 100, 200, 300 You can also separate the declaration of variables and their assignment: var width, height, depth intwidth, height, depth = 100, 200, 300 If the variable types differ, the interpreter can automatically infer their types: var name, age, fired = \"John\", 50, false Similarly, you can use the short form for multiple variables: name, age, fired := \"John\", 50, false In this case, there is no var keyword, nor are the types of the variables specified. Another way to declare multiple variables is by using a block: var ( name string = \"John\" age int = 50 height float64 = 190 fired bool = false ) By the way, you can format block declarations using spaces in such a way that names, types, and values align in columns, improving code readability: var ( name string = \"John\" age int = 50 height float64 = 190.5 fired bool = false ) The block declaration has no particular utility significance. It‚Äôs just syntactic sugar that: Improves code readability by grouping important variables in one place. Improves code cleanliness by avoiding repeated use of the var keyword for each variable. Improves code maintainability by simplifying the search and modification of variable parameters. Thus, block declaration is justified only when you need to group several key variables, simplifying their visual perception in a code editor. No Initialization In Go, it is possible to create a variable without initializing it. In this case, the variable is assigned a zero value corresponding to the specified type: For int, float32, float64: 0, 0.0, 0.0 For bool: false For string: \"\" For pointers: nil We can demonstrate this behavior of Go regarding variable declaration and initialization in the following script: package main import \"fmt\" func main() { // Integer var numberInt int fmt.Println(\"Integer:\", numberInt) // Floating-point number var numberFloat float32 fmt.Println(\"Floating-point number:\", numberFloat) // String var text string fmt.Println(\"String:\", text) // Boolean var condition bool fmt.Println(\"Boolean:\", condition) // Array var array [5]int fmt.Println(\"Array:\", array) // Slice var cut []int fmt.Println(\"Slice:\", cut) // Struct type S struct { name string size int address string } var structure S fmt.Println(\"Struct:\", structure) // Map var dictionary map[int]int fmt.Println(\"Map:\", dictionary) // Pointer var pointer *int fmt.Println(\"Pointer:\", pointer) } The console output will be as follows: Integer: 0 Floating-point number: 0 String: Boolean: false Array: [0 0 0 0 0] Slice: [] Struct: { 0} Map: map[] Pointer: <nil> As you can see, variables of different types are automatically initialized with zero (or empty) values wherever possible. Naming Conventions In Golang, variable names can either start with a Latin letter or an underscore (_): onething := 123 // OK Onething := 123 // OK _onething := 123 // OK __onething := 123 // OK 1thing := 123 // ERROR Additionally, variable names have a functional feature: names starting with an uppercase letter are visible in other packages, while names starting with a lowercase letter are not. There are also several universal naming conventions across programming languages, including Go: Snake Case Camel Case Pascal Case Kebab Case (not supported in Go) Snake Case In Snake Case, the variable name looks like this: some_random_variable := 123 // lowercaseSOME_RANDOM_VARIABLE := 123 // uppercase Camel Case In Camel Case, the variable name looks like this: someRandomVariable := 12 Pascal Case In Pascal Case, the variable name looks like this: SomeRandomVariable := 123 Kebab Case In Kebab Case, the variable name looks like this: // ERRORsome-random-variable := 123 // lowercaseSOME-RANDOM-VARIABLE := 123 // uppercase However, Go doesn't support the Kebab Case style due to the hyphen character, which is reserved for the subtraction operation. Example: Declaring Multiple Variables Let‚Äôs further explore all the aforementioned ways of declaring variables in Golang in this script example: package main import \"fmt\" func main() { // Explicit declaration with type specification var age int = 50 fmt.Println(\"Age:\", age) // Explicit declaration with type inference var height = 190.5 fmt.Println(\"Height:\", height) // Short declaration name := \"John\" fmt.Println(\"Name:\", name) // Explicit declaration of multiple variables var width, depth int = 100, 200 fmt.Println(\"Width:\", width, \"Depth:\", depth) // Explicit declaration without initialization var distance int fmt.Println(\"Distance:\", distance) // Block declaration of multiple variables var ( occupation string = \"Welder\" category float32 = 3.4 license bool ) fmt.Println(\"Occupation:\", occupation, \"Category:\", category, \"License:\", license) } The result of running this code will be the following output in the console: Age: 50 Height: 190.5 Name: John Width: 100 Depth: 200 Distance: 0 Occupation: Welder Category: 3.4 License: false The var keyword is required for explicit variable declaration, especially in the global scope. The := operator is used for short variable declarations, particularly within functions. The block () syntax is used for readable declaration of multiple variables. It's important to remember that Go emphasizes minimalism and concise syntax. Therefore, the most compact form of notation should be used wherever possible. This reduces errors and issues while maintaining the cleanliness and readability of the code. Variable Initialization Typically, when a variable is declared, it is manually initialized with a specific value. The initialization of different types has syntactic differences. Number Numerical variables are initialized by assigning a numerical value, which is syntactically simple: // int var someNumber int = 5 // float32 otherNumber := 10.0 A number can be initialized with another number: // int var someNumber int = 5 var otherNumber int = someNumber // int oneMoreNumber := someNumber String String variables are initialized by assigning a sequence of characters enclosed in double quotes: // stringvar someString string = \"Some programmer was here\" A string can also be initialized with another string: // string var someString string = \"Some programmer was here\" var otherString string = someString // string oneMoreString := someString Boolean Initializing boolean variables is similar to initializing numeric and string variables, except that the value used is the keyword true or false: // boolvar someBool bool = true Similarly, boolean variables can be initialized with other boolean variables: // bool var someBool bool = true var otherBool bool = someBool // bool oneMoreBool := someBool Array There are several ways to initialize an array. The simplest one is through sequential access to the elements: // array var languages [3]string languages[0] = \"Golang\" languages[1] = \"Python\" languages[2] = \"Rust\" A more complex method is using a composite literal. A composite literal is a compact syntax for initializing any composite (struct-like) type, which avoids assigning each element individually. Thus, the array can be initialized in one step: var languages = [3]string{\"Golang\", \"Python\", \"Rust\"} Or using the shorthand form: languages := [3]string{\"Golang\", \"Python\", \"Rust\"} You can also partially initialize array elements: // array size 5, but only 3 elements initialized languages := [5]string{\"Golang\", \"Python\", \"Rust\"} languages[3] = \"Java\" languages[4] = \"C++\" To make the initialization of a large array more readable, you can format it like this: languages := [5]string{ \"Golang\", \"Python\", \"Rust\", \"Java\", \"C++\", // the comma at the end is REQUIRED } By the way, an array can be initialized with another array, copying all of its elements: languages := [3]string{\"Golang\", \"Python\", \"Rust\"}otherLanguages := languages It‚Äôs important to understand that copying an array also occurs when it is passed to a function: package main import \"fmt\" func change(languages [5]string) { for i := range languages { languages[i] = \"[\" + languages[i] + \"]\" } } func main() { languages := [5]string{ \"Golang\", \"Python\", \"Rust\", \"Java\", \"C++\", } change(languages) fmt.Println(languages) } The output in the console will be: [Golang Python Rust Java C++] Thus, only the copy of the array inside the change() function was modified, not the original array from the main() function. However, explicit initialization of an array with another array is possible only if both arrays have the same length and type: languages := [3]string{\"Golang\", \"Python\", \"Rust\"} var otherLanguages [3]string = languages // OK var oneMoreLanguages [4]string = languages // ERROR Additionally, in Go, you can create arrays from an arbitrary number of other arrays. You can initialize elements of such arrays both sequentially: var matrix [2][2]string matrix[0][0] = \"a\" matrix[0][1] = \"b\" matrix[1][0] = \"c\" matrix[1][1] = \"d\" Or using a composite literal: var matrix = [2][2][2]string{{{\"a\", \"b\"}, {\"c\", \"d\"}}, {{\"e\", \"f\"}, {\"g\", \"h\"}}} As shown, the second option takes up less space, but the syntax is more complex. Slice A slice is initialized the same way as an array: var languages = []string{\"Golang\", \"Python\", \"Rust\"} However, unlike an array, a slice can be initialized with another slice of arbitrary length: var languages = []string{\"Golang\", \"Python\", \"Rust\"}var otherLanguages []string = languages Map Maps are initialized using a composite literal with the type of the key and value specified. The content is listed using commas and separated by a colon: var languages = map[string]string{\"first\": \"Golang\", \"second\": \"Python\", \"third\": \"Rust\"} You can also use the shorthand declaration and a more readable initialization format: languages := map[string]string{ \"first\": \"Golang\", \"second\": \"Python\", \"third\": \"Rust\", // the comma at the end is MANDATORY } However, initializing a map with another map does not copy the elements; instead, it makes them shared: package main import \"fmt\" func main() { languages := map[string]string{\"first\": \"Golang\", \"second\": \"Python\", \"third\": \"Rust\"} otherLanguages := languages fmt.Println(languages) fmt.Println(otherLanguages) otherLanguages[\"first\"] = \"C++\" fmt.Println(languages) fmt.Println(otherLanguages) delete(otherLanguages, \"second\") fmt.Println(languages) fmt.Println(otherLanguages) } The console output of this example will be: map[first:Golang second:Python third:Rust] map[first:Golang second:Python third:Rust] map[first:C++ second:Python third:Rust] map[first:C++ second:Python third:Rust] map[first:C++ third:Rust] map[first:C++ third:Rust] Pointer Pointers can only be initialized with the address of a variable of the same type: var variable int = 15var pointer *int = &variable The ampersand (&) symbol is used to get the address of any variable: package main import \"fmt\" func main() { var variable int = 15 var pointer *int = &variable fmt.Println(pointer) } The console output of this example will look something like: 0xc000104040 You can also use shorthand notation to initialize pointers: variable := 15pointer := &variable To access the value stored at the address of a pointer, you need to dereference it using the asterisk (*): package main import \"fmt\" func main() { var variable int = 15 var pointer *int = &variable fmt.Println(*pointer) } In this case, the console output will show: 15 Thus, you can assign new values to a variable located at the address of the pointer: package main import \"fmt\" func main() { var variable int = 15 var pointer *int = &variable *pointer = 5 fmt.Println(*pointer) } The console will display: 5 Finally, a pointer can be initialized with an anonymous object in memory. This is done using the new() function, which returns the address of the allocated memory: variable := new(int)*variable = 15 You don't need to manually delete the allocated memory ‚Äî the garbage collector automatically handles this. Structure A structure can be initialized either with explicitly specified values in order: type something struct { first string second int } var structure something = something{\"John\", 15} Or with explicitly specified values by key names: type something struct { first string second int } var structure something = something{second: 15, first: \"John\"} Alternatively, you can choose not to specify any values, which will automatically initialize all fields to their zero values: package main import \"fmt\" type something struct { first string second int } func main() { var structure something = something{} fmt.Println(structure) structure.first = \"John\" structure.second = 15 fmt.Println(structure) } In this case, the console output will be: { 0} {John 15} Branching Based on Variables Variables play a central role in branching. Different parts of the program's code are executed based on their values (conditions). if/else The most basic conditional construct is created using the if/else statements. Here's the simplest condition: a := 5 b := 10 if a < b { fmt.Println(\"A is less than B\") } For example, you can use a simple condition to check a pointer: var pointer *int if pointer == nil { fmt.Println(\"No address\") } A more complex form would look like this: a := 10 b := 5 if a < b { fmt.Println(\"A is less than B\") } else { fmt.Println(\"A is greater than B\") } You can create even more complex constructs by combining else and if: a := 10 b := 5 if a < b { fmt.Println(\"A is less than B\") } else if a > b { fmt.Println(\"A is greater than B\") } else { fmt.Println(\"A is equal to B\") } Multiple if/else expressions can be used: a := 12 if a < 5 { fmt.Println(\"A is less than 5\") } else if a < 10 { fmt.Println(\"A is less than 10\") } else if a < 20 { fmt.Println(\"A is less than 20\") } else { fmt.Println(\"A is in superposition\") } switch Another way to branch is using the switch construct, where possible values of a variable are defined, and actions are performed if there's a match: a := 1 switch a { case 0: fmt.Println(\"A is 0\") case 1: fmt.Println(\"A is 1\") case 2: fmt.Println(\"A is 2\") } The default section can be used to define an action that runs if no match occurs: a := 3 switch a { case 0: fmt.Println(\"A is 0\") case 1: fmt.Println(\"A is 1\") case 2: fmt.Println(\"A is 2\") default: fmt.Println(\"A is in superposition\") } You can also combine multiple possible matches into one section: a := 1 switch a { case 0, 1, 2: fmt.Println(\"A is either 0, 1, or 2\") default: fmt.Println(\"A is in superposition\") } Useful Functions Go has many utility functions for working with variables. In this guide, we'll cover just the basic ones. Environment Variables Go provides special system functions that allow you to set and get environment variables: package main import ( \"fmt\" \"os\" ) func main() { os.Setenv(\"SOMEVAR\", \"1\") // Set an environment variable fmt.Println(\"SOMEVAR:\", os.Getenv(\"SOMEVAR\")) // Read an environment variable } Time Variables Often, the program logic requires measuring time. Go has a corresponding tool for this ‚Äî the time type. Time is a broad topic by itself. To learn more about the time package, you can check the official documentation. This guide will show how to get the current time in different formats: package main import ( \"fmt\" \"time\" ) func main() { fmt.Println(\"Current time:\", time.Now()) fmt.Println(\"Current time (UTC):\", time.Now().UTC()) fmt.Println(\"Current time (Unix):\", time.Now().Unix()) } The console output will look something like this: Current time: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001 Current time (UTC): 2009-11-10 23:00:00 +0000 UTC Current time (Unix): 1257894000 You can also specify specific time parameters: package main import ( \"fmt\" \"time\" ) func main() { timeNow := time.Now() fmt.Println(\"Full time:\", timeNow) fmt.Println(\"Year:\", timeNow.Year()) fmt.Println(\"Month:\", timeNow.Month()) fmt.Println(\"Day:\", timeNow.Day()) fmt.Println(\"Hour:\", timeNow.Hour()) fmt.Println(\"Minutes:\", timeNow.Minute()) fmt.Println(\"Seconds:\", timeNow.Second()) } In this case, the console output will be: Full time: 2024-11-15 23:46:09.157929822 +0000 UTC m=+0.000031801 Year: 2024 Month: November Day: 15 Hour: 23 Minutes: 23 Seconds: 9 Adding and Removing Elements from a Slice You can add elements to slices: var languages = []string{\"Golang\", \"Python\", \"Rust\"} languages = append(languages, \"Java\", \"C++\") fmt.Println(languages) This will append \"Java\" and \"C++\" to the languages slice. You can also remove elements from slices: var languages = []string{\"Golang\", \"Python\", \"Rust\"} // Remove the 2nd element (index 1) n := 1 languages = append(languages[:n], languages[n+1:]...) fmt.Println(languages) In this example, the second element is removed from the languages slice using slice operators, which create a new sequence from parts of the original slice. Here‚Äôs an example of slicing a sequence: package main import \"fmt\" func main() { var sequence = []string{\"One\", \"Two\", \"Three\", \"Four\", \"Five\"} newSequence := sequence[1:4] // Elements from index 1 to 3 become the new slice fmt.Println(newSequence) } The output in the console will be: [Two Three Four] Checking the Type of a Variable You can check the type of a variable using the TypeOf() function from the reflect package: package main import ( \"fmt\" \"reflect\" // Package to determine the type ) func main() { variableString := \"string\" variableInt := 5 variableFloat64 := 1.5 variableBool := true fmt.Println(reflect.TypeOf(variableString)) fmt.Println(reflect.TypeOf(variableInt)) fmt.Println(reflect.TypeOf(variableFloat64)) fmt.Println(reflect.TypeOf(variableBool)) } The console output for this example will be: string int float64 bool Variables in Strings Often, you need to insert a variable into a string. There are several ways to do this: package main import \"fmt\" func main() { // METHOD 1 stringPre := \"human-readable\" stringEnd1 := fmt.Sprintf(\"This is a %s string\", stringPre) fmt.Println(stringEnd1) // METHOD 2 stringEnd2 := \"This is \" + stringPre + \" string\" fmt.Println(stringEnd2) } The output in the console will be: This is a human-readable stringThis is a human-readable string You can also combine numeric variables with strings: package main import \"fmt\" func main() { name := \"John\" age := 50 fmt.Printf(\"Hi, my name is %v and I'm %v years old.\n\n\", name, age) } The output will be: Hi, my name is John and I'm 50 years old. Conclusion Like in most other programming languages, variables in Go are essential for storing data. Since data types differ from each other, Golang variables have several basic types, each having a specific representation in the computer's memory. In this guide, we only covered the basic ways to work with variables. You can find more detailed (and comprehensive) information about types and their specifics in the official Golang documentation. Additionally, the official Go package manager catalog provides information on many useful modules available for import into your project. One such module is the Standard Library. Check out our app platform to deploy Go applications (such as Beego and Gin)."
    },
    {
        "link": "https://docs.python.org/3/library/time.html",
        "document": "This module provides various time-related functions. For related functionality, see also the and modules.\n\nAlthough this module is always available, not all functions are available on all platforms. Most of the functions defined in this module call platform C library functions with the same name. It may sometimes be helpful to consult the platform documentation, because the semantics of these functions varies among platforms.\n\nAn explanation of some terminology and conventions is in order.\n‚Ä¢ None The epoch is the point where the time starts, the return value of . It is January 1, 1970, 00:00:00 (UTC) on all platforms.\n‚Ä¢ None The term seconds since the epoch refers to the total number of elapsed seconds since the epoch, typically excluding leap seconds. Leap seconds are excluded from this total on all POSIX-compliant platforms.\n‚Ä¢ None The functions in this module may not handle dates and times before the epoch or far in the future. The cut-off point in the future is determined by the C library; for 32-bit systems, it is typically in 2038.\n‚Ä¢ None Function can parse 2-digit years when given format code. When 2-digit years are parsed, they are converted according to the POSIX and ISO C standards: values 69‚Äì99 are mapped to 1969‚Äì1999, and values 0‚Äì68 are mapped to 2000‚Äì2068.\n‚Ä¢ None UTC is Coordinated Universal Time and superseded Greenwich Mean Time or GMT as the basis of international timekeeping. The acronym UTC is not a mistake but conforms to an earlier, language-agnostic naming scheme for time standards such as UT0, UT1, and UT2.\n‚Ä¢ None DST is Daylight Saving Time, an adjustment of the timezone by (usually) one hour during part of the year. DST rules are magic (determined by local law) and can change from year to year. The C library has a table containing the local rules (often it is read from a system file for flexibility) and is the only source of True Wisdom in this respect.\n‚Ä¢ None The precision of the various real-time functions may be less than suggested by the units in which their value or argument is expressed. E.g. on most Unix systems, the clock ‚Äúticks‚Äù only 50 or 100 times a second.\n‚Ä¢ None On the other hand, the precision of and is better than their Unix equivalents: times are expressed as floating-point numbers, returns the most accurate time available (using Unix where available), and will accept a time with a nonzero fraction (Unix is used to implement this, where available).\n‚Ä¢ None The time value as returned by , , and , and accepted by , and , is a sequence of 9 integers. The return values of , , and also offer attribute names for individual fields. See for a description of these objects. Changed in version 3.3: The type was extended to provide the and attributes when platform supports corresponding members. Changed in version 3.6: The attributes and are now available on all platforms.\n‚Ä¢ None Use the following functions to convert between time representations:\n\nConvert a tuple or representing a time as returned by or to a string of the following form: . The day field is two characters long and is space padded if the day is a single digit, e.g.: . If t is not provided, the current time as returned by is used. Locale information is not used by . Unlike the C function of the same name, does not add a trailing newline. Return the clk_id of the thread-specific CPU-time clock for the specified thread_id. Use or the attribute of objects to get a suitable value for thread_id. Passing an invalid or expired thread_id may result in undefined behavior, such as segmentation fault. See the man page for pthread_getcpuclockid(3) for further information. Return the resolution (precision) of the specified clock clk_id. Refer to Clock ID Constants for a list of accepted values for clk_id. Return the time of the specified clock clk_id. Refer to Clock ID Constants for a list of accepted values for clk_id. Use to avoid the precision loss caused by the type. Similar to but return time as nanoseconds. Set the time of the specified clock clk_id. Currently, is the only accepted value for clk_id. Use to avoid the precision loss caused by the type. Similar to but set time with nanoseconds. Convert a time expressed in seconds since the epoch to a string of a form: representing local time. The day field is two characters long and is space padded if the day is a single digit, e.g.: . If secs is not provided or , the current time as returned by is used. is equivalent to . Locale information is not used by . Get information on the specified clock as a namespace object. Supported clock names and the corresponding functions to read their value are: The result has the following attributes:\n‚Ä¢ None adjustable: if the clock can be changed automatically (e.g. by a NTP daemon) or manually by the system administrator, otherwise\n‚Ä¢ None implementation: The name of the underlying C function used to get the clock value. Refer to Clock ID Constants for possible values.\n‚Ä¢ None monotonic: if the clock cannot go backward, otherwise\n‚Ä¢ None resolution: The resolution of the clock in seconds ( ) Convert a time expressed in seconds since the epoch to a in UTC in which the dst flag is always zero. If secs is not provided or , the current time as returned by is used. Fractions of a second are ignored. See above for a description of the object. See for the inverse of this function. Like but converts to local time. If secs is not provided or , the current time as returned by is used. The dst flag is set to when DST applies to the given time. may raise , if the timestamp is outside the range of values supported by the platform C or functions, and on or failure. It‚Äôs common for this to be restricted to years between 1970 and 2038. This is the inverse function of . Its argument is the or full 9-tuple (since the dst flag is needed; use as the dst flag if it is unknown) which expresses the time in local time, not UTC. It returns a floating-point number, for compatibility with . If the input value cannot be represented as a valid time, either or will be raised (which depends on whether the invalid value is caught by Python or the underlying C libraries). The earliest date for which it can generate a time is platform-dependent. Return the value (in fractional seconds) of a monotonic clock, i.e. a clock that cannot go backwards. The clock is not affected by system clock updates. The reference point of the returned value is undefined, so that only the difference between the results of two calls is valid. Use to avoid the precision loss caused by the type. Changed in version 3.5: The function is now always available and always system-wide. Changed in version 3.10: On macOS, the function is now system-wide. Similar to , but return time as nanoseconds. Return the value (in fractional seconds) of a performance counter, i.e. a clock with the highest available resolution to measure a short duration. It does include time elapsed during sleep and is system-wide. The reference point of the returned value is undefined, so that only the difference between the results of two calls is valid. CPython implementation detail: On CPython, use the same clock as and is a monotonic clock, i.e. a clock that cannot go backwards. Use to avoid the precision loss caused by the type. Changed in version 3.10: On Windows, the function is now system-wide. Changed in version 3.13: Use the same clock as . Similar to , but return time as nanoseconds. Return the value (in fractional seconds) of the sum of the system and user CPU time of the current process. It does not include time elapsed during sleep. It is process-wide by definition. The reference point of the returned value is undefined, so that only the difference between the results of two calls is valid. Use to avoid the precision loss caused by the type. Similar to but return time as nanoseconds. Suspend execution of the calling thread for the given number of seconds. The argument may be a floating-point number to indicate a more precise sleep time. If the sleep is interrupted by a signal and no exception is raised by the signal handler, the sleep is restarted with a recomputed timeout. The suspension time may be longer than requested by an arbitrary amount, because of the scheduling of other activity in the system. On Windows, if secs is zero, the thread relinquishes the remainder of its time slice to any other thread that is ready to run. If there are no other threads ready to run, the function returns immediately, and the thread continues execution. On Windows 8.1 and newer the implementation uses a high-resolution timer which provides resolution of 100 nanoseconds. If secs is zero, is used.\n‚Ä¢ None Use if available (resolution: 1 nanosecond);\n‚Ä¢ None Or use if available (resolution: 1 nanosecond); To emulate a ‚Äúno-op‚Äù, use instead of . To voluntarily relinquish the CPU, specify a real-time scheduling policy and use instead. Changed in version 3.5: The function now sleeps at least secs even if the sleep is interrupted by a signal, except if the signal handler raises an exception (see PEP 475 for the rationale). Changed in version 3.11: On Unix, the and functions are now used if available. On Windows, a waitable timer is now used. Convert a tuple or representing a time as returned by or to a string as specified by the format argument. If t is not provided, the current time as returned by is used. format must be a string. is raised if any field in t is outside of the allowed range. 0 is a legal argument for any position in the time tuple; if it is normally illegal the value is forced to a correct one. The following directives can be embedded in the format string. They are shown without the optional field width and precision specification, and are replaced by the indicated characters in the result: Day of the month as a decimal number [01,31]. Day of the year as a decimal number [001,366]. Locale‚Äôs equivalent of either AM or PM. Week number of the year (Sunday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Sunday are considered to be in week 0. Day of the week (Monday is 1; Sunday is 7) as a decimal number [1, 7]. Week number of the year (Monday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Monday are considered to be in week 0. Time zone offset indicating a positive or negative time difference from UTC/GMT of the form +HHMM or -HHMM, where H represents decimal hour digits and M represents decimal minute digits [-23:59, +23:59]. Time zone name (no characters if no time zone exists). Deprecated. ISO 8601 year (similar to but follows the rules for the ISO 8601 calendar year). The year starts with the week that contains the first Thursday of the calendar year. ISO 8601 week number (as a decimal number [01,53]). The first week of the year is the one that contains the first Thursday of the year. Weeks start on Monday.\n‚Ä¢ None The format directive only applies to , not to . However, see also and where the format directive applies to microseconds.\n‚Ä¢ None When used with the function, the directive only affects the output hour field if the directive is used to parse the hour.\n‚Ä¢ None The range really is to ; value is valid in timestamps representing leap seconds and value is supported for historical reasons.\n‚Ä¢ None When used with the function, and are only used in calculations when the day of the week and the year are specified. Here is an example, a format for dates compatible with that specified in the RFC 2822 Internet email standard. Additional directives may be supported on certain platforms, but only the ones listed here have a meaning standardized by ANSI C. To see the full set of format codes supported on your platform, consult the strftime(3) documentation. On some platforms, an optional field width and precision specification can immediately follow the initial of a directive in the following order; this is also not portable. The field width is normally 2 except for where it is 3. Parse a string representing a time according to a format. The return value is a as returned by or . The format parameter uses the same directives as those used by ; it defaults to which matches the formatting returned by . If string cannot be parsed according to format, or if it has excess data after parsing, is raised. The default values used to fill in any missing data when more accurate values cannot be inferred are . Both string and format must be strings. Support for the directive is based on the values contained in and whether is true. Because of this, it is platform-specific except for recognizing UTC and GMT which are always known (and are considered to be non-daylight savings timezones). Only the directives specified in the documentation are supported. Because is implemented per platform it can sometimes offer more directives than those listed. But is independent of any platform and thus does not necessarily support all directives available that are not documented as supported. The type of the time value sequence returned by , , and . It is an object with a named tuple interface: values can be accessed by index and by attribute name. The following values are present: Note that unlike the C structure, the month value is a range of [1, 12], not [0, 11]. In calls to , may be set to 1 when daylight savings time is in effect, and 0 when it is not. A value of -1 indicates that this is not known, and will usually result in the correct state being filled in. When a tuple with an incorrect length is passed to a function expecting a , or having elements of the wrong type, a is raised. Return the time in seconds since the epoch as a floating-point number. The handling of leap seconds is platform dependent. On Windows and most Unix systems, the leap seconds are not counted towards the time in seconds since the epoch. This is commonly referred to as Unix time. Note that even though the time is always returned as a floating-point number, not all systems provide time with a better precision than 1 second. While this function normally returns non-decreasing values, it can return a lower value than a previous call if the system clock has been set back between the two calls. The number returned by may be converted into a more common time format (i.e. year, month, day, hour, etc‚Ä¶) in UTC by passing it to function or in local time by passing it to the function. In both cases a object is returned, from which the components of the calendar date may be accessed as attributes. Use to avoid the precision loss caused by the type. Similar to but returns time as an integer number of nanoseconds since the epoch. Return the value (in fractional seconds) of the sum of the system and user CPU time of the current thread. It does not include time elapsed during sleep. It is thread-specific by definition. The reference point of the returned value is undefined, so that only the difference between the results of two calls in the same thread is valid. Use to avoid the precision loss caused by the type. Similar to but return time as nanoseconds. Reset the time conversion rules used by the library routines. The environment variable specifies how this is done. It will also set the variables (from the environment variable), (non-DST seconds West of UTC), (DST seconds west of UTC) and (to 0 if this timezone does not have any daylight saving time rules, or to nonzero if there is a time, past, present or future when daylight saving time applies). Although in many cases, changing the environment variable may affect the output of functions like without calling , this behavior should not be relied on. The environment variable should contain no whitespace. The standard format of the environment variable is (whitespace added for clarity): Where the components are: Three or more alphanumerics giving the timezone abbreviations. These will be propagated into time.tzname The offset has the form: . This indicates the value added the local time to arrive at UTC. If preceded by a ‚Äò-‚Äô, the timezone is east of the Prime Meridian; otherwise, it is west. If no offset follows dst, summer time is assumed to be one hour ahead of standard time. Indicates when to change to and back from DST. The format of the start and end dates are one of the following: The Julian day n (1 <= n <= 365). Leap days are not counted, so in all years February 28 is day 59 and March 1 is day 60. The zero-based Julian day (0 <= n <= 365). Leap days are counted, and it is possible to refer to February 29. The d‚Äôth day (0 <= d <= 6) of week n of month m of the year (1 <= n <= 5, 1 <= m <= 12, where week 5 means ‚Äúthe last d day in month m‚Äù which may occur in either the fourth or the fifth week). Week 1 is the first week in which the d‚Äôth day occurs. Day zero is a Sunday. has the same format as except that no leading sign (‚Äò-‚Äô or ‚Äò+‚Äô) is allowed. The default, if time is not given, is 02:00:00. On many Unix systems (including *BSD, Linux, Solaris, and Darwin), it is more convenient to use the system‚Äôs zoneinfo (tzfile(5)) database to specify the timezone rules. To do this, set the environment variable to the path of the required timezone datafile, relative to the root of the systems ‚Äòzoneinfo‚Äô timezone database, usually located at . For example, , , or .\n\nThe offset of the local DST timezone, in seconds west of UTC, if one is defined. This is negative if the local DST timezone is east of UTC (as in Western Europe, including the UK). Only use this if is nonzero. See note below. Nonzero if a DST timezone is defined. See note below. The offset of the local (non-DST) timezone, in seconds west of UTC (negative in most of Western Europe, positive in the US, zero in the UK). See note below. A tuple of two strings: the first is the name of the local non-DST timezone, the second is the name of the local DST timezone. If no DST timezone is defined, the second string should not be used. See note below. For the above Timezone constants ( , , , and ), the value is determined by the timezone rules in effect at module load time or the last time is called and may be incorrect for times in the past. It is recommended to use the and results from to obtain timezone information. More object-oriented interface to dates and times. Internationalization services. The locale setting affects the interpretation of many format specifiers in and . General calendar-related functions. is the inverse of from this module."
    }
]