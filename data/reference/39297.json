[
    {
        "link": "https://doc.qt.io/qt-6/qtmultimedia-index.html",
        "document": "Qt Multimedia is an add-on module that provides a rich set of QML types and C++ classes to handle multimedia content. It contains an easy to use API for playing back audio and video files and rendering those on screen, as well as a comprehensive API for recording audio and video from various sources, including system cameras and microphones, screen or window captures, and audio or video memory buffers.\n\nThe functionality of this module is divided into the following submodules:\n\nIf you are porting from Qt 5 to Qt 6, see Changes to Qt Multimedia.\n\nIf you are new to Qt Multimedia, the QML types can be imported into an application using the following statement in your file.\n\nTo link against the C++ libraries, add the following to your project's file. Substitute with the name of your project.\n\nSee Building Qt Multimedia from sources for guidance on building Qt Multimedia from sources.\n\nThe following table outlines some important QML types.\n\nThe following table outlines some important C++ classes.\n\nFor playback of audio and video, QMediaPlayer, QAudioOutput, and QVideoWidget contain all necessary functionality. Other classes are dedicated to capturing audio and video content, with QMediaCaptureSession serving as the central class that manages the entire capture and recording process.\n\nThe Qt Multimedia module is available under commercial licenses from The Qt Company. In addition, it is available under free software licenses. Since Qt 5.6, these free software licenses are GNU Lesser General Public License, version 3, or the GNU General Public License, version 2. See Qt Licensing for further details.\n\nFurthermore, Qt Multimedia in Qt 6.8.2 may contain third-party modules under the following permissive licenses:\n\nNote that video compression standards, such as the H.264 media compression standard, may be covered by patents and can incur royalty fees. This can apply to any implementation, also if the implementation is provided as an operating system service, through a third-party library, or any of Qt Multimedia's backends. The Qt licenses do not cover such fees.\n\nQt Multimedia offers user-friendly, cross-platform APIs for media playback, recording, and device management. The implementation of core APIs, including QMediaDevices, QAudioDevice, QSoundEffect, QAudioSink, and QAudioSource are integrated into the main Qt Multimedia library, eliminating the need for additional libraries. Other Qt Multimedia APIs are implemented using plugin libraries known as media backends. The main media backend, built on FFmpeg, ensures seamless cross-platform functionality, and is the default on all platforms except WebAssembly and embedded Linux/Boot2Qt. With Boot2Qt, the default backend is built on top of GStreamer, but the FFmpeg media backend can be enabled using the environment variable.\n\nThe FFmpeg media backend relies on the FFmpeg 7.1 libraries, which are included with the Qt Online Installer and tested by the maintainers. The binary packages from the online installer use dynamic linking to FFmpeg. Therefore, applications must either bundle FFmpeg binaries in their installer or depend on FFmpeg being installed on the operating system. The FFmpeg libraries are automatically deployed using Qt's deployment tools as described in the Deploying Qt Applications documentation, except for Linux/X11. Applications can also deploy their own build of FFmpeg, either as shared or static libraries, provided the FFmpeg major version matches the version used by Qt.\n\nWhile Qt Multimedia leverages the FFmpeg media backend on most operating systems, platform specific functional or visual differences may arise between applications on different platforms. FFmpeg does not provide identical codec and format support across all platforms, and the performance of Qt Multimedia features may depend on hardware support that is only available on certain platforms. For instance, FFmpeg encounters specific issues with hardware acceleration on Linux targets with ARM architectures. Therefore, it is recommended to test Qt Multimedia applications on all target platforms.\n\nTo ease development and debugging, some FFmpeg functionality is configurable via environment varibles which are part of the private Qt Multimedia API.\n\nFor compatibility with existing applications, we maintain native media backends for each operating system:\n\nQt Maintainers will strive to fix critical issues with the native backends but don't guarantee fixing minor issues, including inconsistent behavior across platforms. New features will only be implemented on the FFmpeg media backend.\n\nThe GStreamer backend has some private APIs to allow more fine-grained control. However, there are known bugs in the GStreamer backend. More details can be found in GStreamer.\n\nBackend limitations will be documented, and their status will be maintained in the respective classes.\n\nIn the case of issues with the default FFmpeg backend, we suggest testing with a native backend. You can switch to native backends by setting the environment variable to , (on Linux), (on macOS and iOS), or :\n\nTo force assign FFmpeg as the used backend, set the variable to :\n\nOn the Qt Multimedia compilation stage, the default media backend can be configured via cmake variable .\n\nThe following pages list issues for specific target platforms that are not related to the multimedia backend.\n\nStarting from Qt 6.6, the Qt Multimedia module uses the new QPermission API to handle camera and microphone permissions. This means that Qt itself no longer queries for these permissions, so this needs to be done directly from the client application.\n\nPlease refer to the Application Permissions page for an example of how to integrate the new QPermission API into the application."
    },
    {
        "link": "https://doc.qt.io/qt-6/qtmultimedia-changes-qt6.html",
        "document": "Qt 6 is a result of the conscious effort to make the framework more efficient and easy to use.\n\nWe try to maintain binary and source compatibility for all the public APIs in each release. But some changes were inevitable in an effort to make Qt a better framework.\n\nThe module has been refactored significantly and has changed classification, from essential to add-on. The Qt Multimedia module in Qt 6 replaces the Qt Multimedia module from Qt 5.x. Existing code that uses Qt Multimedia from Qt 5 can be ported with limited effort.\n\nThere are a number of new features in Qt Multimedia:\n• QMediaCaptureSession class is the central object for media capture.\n• QMediaRecorder class is now a class limited to recording audio and video. It handles encoding of data produced in a capture session.\n• Using QMediaFormat and QMediaRecorder, setting up the desired encoding when recording has changed significantly.\n• You can now also monitor the audio recorded by a capture session.\n• Support for selection of audio, video and subtitle tracks when playing back media files has been added.\n• QAudioDecoder is now supported on all platforms.\n\nA number of classes previously offered in Qt Multimedia have changed in ways that may affect previously written code. The following table highlights these changes."
    },
    {
        "link": "https://felgo.com/doc/qt/qtmultimedia-index",
        "document": "Qt Multimedia is an add-on module that provides a rich set of QML types and C++ classes to handle multimedia content. It contains an easy to use API for playing back audio and video files and rendering those on screen, as well as a comprehensive API for recording audio and video from the systems cameras and microphones.\n\nThe functionality of this module is divided into the following submodules:\n\nIf you are porting from Qt 5 to Qt 6 see Changes to Qt Multimedia.\n\nIf you are new to Qt Multimedia, the QML types can be imported into an application using the following statement in your file.\n\nTo link against the C++ libraries, add the following to your project's file. Substitute with the name of your project.\n\nThe following table outlines some important QML types.\n\nThe following table outlines some important C++ Classes\n\nFor playback QMediaPlayer, QAudioOutput and QVideoOutput contain all the required functionality. The other classes are used for capturing audio and video content, where the QMediaCaptureSession is the central class managing the whole capture/recording process.\n\nThe Qt Multimedia module is available under commercial licenses from The Qt Company. In addition, it is available under free software licenses. Since Qt 5.6, these free software licenses are GNU Lesser General Public License, version 3, or the GNU General Public License, version 2. See Qt Licensing for further details.\n\nThe FFmpeg backend uses the FFmpeg framework. FFmpeg is licensed under LGPLv2.1, GPLv2, or later versions of the licenses. Some optional components of FFmpeg are only available under GPL. The FFmpeg backend shipped with the Qt binary packages is configured to not contain any of the components that are available under GPLv2 only. See the FFmpeg licensing page for further details.\n\nOn most platforms, there are two different backends that can be used for Qt Multimedia.\n\nThe first one is the backend built on the native multimedia framework of the underlying operating system. This is currently the default, and will use gstreamer on Linux, AVFoundation on macOS/iOS, WMF on Windows, and the MediaCodec framework on Android.\n\nWhile we try to support our full API on all backends using the native multimedia framework, platform specific limitations do exist in a few places. This is due to the fact that the feature set supported by those frameworks varies, implying that some functionality might not be available on all platforms. This is especially true for the set of supported file formats and codecs, as well as advanced camera functionality.\n\nWhere limitations exist, we aim to document those in the respective classes and methods.\n\nWith Qt 6.4, we are adding a new, more platform independent backend based on the FFmpeg framework. The FFmpeg backend is currently available as a technology preview. This backend has the advantage that we can offer proper cross-platform support for all features of Qt Multimedia, going beyond the limitations that exist with many of the native frameworks.\n\nYou can test the FFmpeg backend right now by using a Qt build that has FFmpeg enabled and setting the environment variable to ffmpeg:"
    },
    {
        "link": "https://felgo.com/doc/qt/cameraoverview",
        "document": "The Qt Multimedia API provides a number of camera related classes, so you can access images and videos from mobile device cameras or web cameras. There are both C++ and QML APIs for common tasks.\n\nIn order to use the camera classes, a quick overview of the way a camera works is needed. If you're already familiar with this, you can skip ahead to Camera implementation details. For a more detailed explanations of how a camera works, see the following YouTube clip.\n\nAt one end of the camera assembly is the lens assembly (one or more lenses, arranged to focus light onto the sensor). The lenses themselves can sometimes be moved to adjust things like focus and zoom. They might also be fixed in an arrangement for a good balance between maintaining focus and cost.\n\nSome lens assemblies can automatically be adjusted so that an object at different distances from the camera can be kept in focus. This is usually done by measuring how sharp a particular area of the frame is, and then adjusting the lens assembly to find the peak sharpness. In some cases, the camera will always use the center of the frame for this. In other cases, a camera may also allow this target focus region to be specified. Some examples of this feature include:\n• Face zoom: Using computer vision to detect and use one or more faces as the target.\n• Touch to zoom: Enabling the user to manually select an area via the preview screen.\n\nOnce light arrives at the sensor, it gets converted into digital pixels. This process can depend on a number of things but ultimately comes down to two things:\n• The length of time conversion is allowed to take. Also known as exposure time.\n• How bright the light is.\n\nThe longer a conversion is allowed to take, the better the resulting image quality. Using a flash can assist with letting more light hit the sensor, allowing it to convert pixels faster, giving better quality for the same amount of time. Conversely, allowing a longer conversion time can let you take photos in darker environments, as long as the camera is steady. If the camera moves while the sensor is recording, the resulting image is blurred.\n\nAfter the image has been captured by the sensor, the camera firmware performs various image processing tasks on it to compensate for various sensor characteristics, current lighting, and desired image properties. Faster sensor pixel conversion times may introduce digital noise, so some amount of image processing can be done to remove this, based on the camera sensor settings.\n\nThe color of the image can also be adjusted at this stage to compensate for different light sources - fluorescent lights and sunlight give very different appearances to the same object, so the image can be adjusted based on the white balance of the picture (due to the different color temperatures of the light sources).\n\nSome forms of \"special effects\" can also be performed at this stage. Black and white, sepia, or \"negative\" style images can be produced.\n\nFinally, once a perfectly focused, exposed and processed image has been created, it can be put to good use. Camera images can be further processed by application code (for example, to detect bar-codes, or to stitch together a panoramic image), or saved to a common format like JPEG, or used to create a movie. Many of these tasks have classes to assist them.\n\nBefore using the camera APIs, you should check that a camera is available at runtime. If there is none available, you could disable camera related features in your application. To perform this check in C++, use the QMediaDevices::videoInputs() function, as shown in the example below:\n\nAccess a camera using the QCamera class in C++ or the Camera type in QML.\n\nWhen multiple cameras are available, you can specify which one to use.\n\nIn QML, you can select the camera by setting the Camera::cameraDevice property. You can also select a camera by its physical position on the system rather than by camera info. This is useful on mobile devices, which often have a front-facing and a back-facing camera.\n\nIn QML, you can set the cameraDevice property. Available cameras can be retrieved with MediaDevices.videoInputs\n\nIf both QCameraDevice and position aren't specified, the default camera will be used. On desktop platforms, the default camera is set by the user in the system settings. On a mobile device, the back-facing camera is usually the default camera. You can get the default camera with QMediaDevices::defaultVideoInput() or MediaDevices.defaultVideoInput in QML.\n\nWhile not strictly necessary, it's often useful to be able to see what the camera is pointing at. This is known as a preview.\n\nDepending on whether you're using QML or C++, you can do this in multiple ways. In QML, you can use Camera and videoOutput together to monitor a captureSession.\n\nIn C++, your choice depends on whether you are using widgets, or QGraphicsView. The QVideoWidget class is used in the widgets case, and QGraphicsVideoItem is useful for QGraphicsView.\n\nFor advanced usage (like processing preview frames as they come, which enables detection of objects or patterns), you can also use your own QVideoSink and set that as the videoOutput for the QMediaCaptureSession. In this case, you will need to render the preview image yourself by processing the data received from the videoFrameChanged() signal.\n\nOn mobile devices, the preview image is by default oriented in the same way as the device. Thus, as the user rotates the device, the preview image will switch between portrait and landscape mode. Once you start recording, the orientation will be locked. To avoid a poor user experience, you should also lock the orientation of the applications user interface while recording. This can be achieved using the contentOrientation property of QWindow.\n\nAfter setting up a viewfinder and finding something photogenic, to capture an image we need to initialize a new QImageCapture object. All that is then needed is to start the camera and capture the image.\n\nPreviously we saw code that allowed the capture of a still image. Recording video requires the use of a QMediaRecorder object.\n\nTo record video we need to create a camera object as before but this time as well as creating a viewfinder, we will also initialize a media recorder object.\n\nSignals from the QMediaRecorder can be connected to slots to react to changes in the state of the encoding process or error events. Recording starts when QMediaRecorder::record() is called. This causes the signal recorderStateChanged() to be emitted. Recording is controlled by the record(), stop(), and pause() slots of QMediaRecorder.\n\nNow that the basics of capturing images and movies are covered, there are a number of ways to control the imaging pipeline to implement some interesting techniques. As explained earlier, several physical and electronic elements combine to determine the final images, and you can control them with different classes.\n\nQCamera allows you to set the general focus policy by means of the enums for the FocusMode. FocusMode deals with settings such as QCamera::FocusModeAuto, and QCamera::FocusModeInfinity.\n\nFor camera hardware that supports it, QCamera::FocusModeAutoNear allows imaging of things that are close to the sensor. This is useful in applications like bar-code recognition, or business card scanning.\n\nIn addition to focus, QCamera allows you to control any available zoom functionality using setZoomFactor() or zoomTo(). The available zoom range might be limited or entirely fixed to unity (1:1). The allowed range can be checked with minimumZoomFactor() and maximumZoomFactor().\n\nThere are a number of settings that affect the amount of light that hits the camera sensor, and hence the quality of the resulting image.\n\nThe main settings for automatic image taking are the exposure mode and flash mode. Several other settings (such as: ISO setting and exposure time) are usually managed automatically, but can also be overridden if desired.\n\nFinally, you can control the flash hardware (if present) using this class. In some cases the hardware may also double as a torch.\n\nThe QCamera class lets you adjust the image processing part of the pipeline. These settings include:\n• white balance (also known as color temperature)\n\nMost cameras support automatic settings for all of these, so you shouldn't need to adjust them unless the user wants a specific setting.\n\nVarious operations, such as image capture and auto focusing, occur asynchronously. These operations can often be canceled by the start of a new operation, as long as this is supported by the camera.\n\nThere are both C++ and QML examples available."
    },
    {
        "link": "https://stackoverflow.com/questions/78264965/how-to-receive-frame-from-qcamera-directly-in-qt6",
        "document": "I am trying to capture image without QVideoWidget. But it seems does not work. When I call after , it gives me an error: .\n\nIs it possible to receive frame from QCamera directly? I don't want to use QVideoWidget. I just need to receive frames one by one, and process every frame, display on QLabel or QGrachiphisView."
    },
    {
        "link": "https://forum.qt.io/topic/122271/best-practice-c-qobjects-and-qml",
        "document": "Hi there,\n\n I hope to get some advice from an experienced developer, which way to use QObjects is the smartest.\n\n Currently I’m getting values in a separate C++ Runtime, send them to a QObject, where it does some very simple calculation and then sends a signal to a Qml “sourcevalues” file, where the values and properties of some Objects are getting change, which I display in my GUI.\n\nNow I want to send more values from my separate Runtime to change more qml Objects.\n\n All of it should be kind of modular, so it should be very easy to add more Values in my separate Runtime and add more Qml Objects which again are changed by the values.\n\n So, is it smarter to have one Qml Object, which has many Slots and Signals, do all of the work? Or is it smarter to have several Qml Objects, which all have one signal and one slot, and take care of one Qml Object?\n\n Option 1: One QObject, One Connection.\n\n \n\n Option 2: Several QObjects, each handling its own Qml Object\n\n\n\nI tend to implement the second approach, because i think it might be more transparent and flexible, to add a QObject each time i want extract another values in the runtime and create another object that displays it instead of putting my different slots and signals in one QObject.\n\n But I don't know whether it slows the GUI down, by adding a connection for each new QObject."
    },
    {
        "link": "https://doc.qt.io/qt-6/signalsandslots.html",
        "document": "In GUI programming, when we change one widget, we often want another widget to be notified. More generally, we want objects of any kind to be able to communicate with one another. For example, if a user clicks a Close button, we probably want the window's close() function to be called.\n\nOther toolkits achieve this kind of communication using callbacks. A callback is a pointer to a function, so if you want a processing function to notify you about some event you pass a pointer to another function (the callback) to the processing function. The processing function then calls the callback when appropriate. While successful frameworks using this method do exist, callbacks can be unintuitive and may suffer from problems in ensuring the type-correctness of callback arguments.\n\nIn Qt, we have an alternative to the callback technique: We use signals and slots. A signal is emitted when a particular event occurs. Qt's widgets have many predefined signals, but we can always subclass widgets to add our own signals to them. A slot is a function that is called in response to a particular signal. Qt's widgets have many pre-defined slots, but it is common practice to subclass widgets and add your own slots so that you can handle the signals that you are interested in.\n\nThe signals and slots mechanism is type safe: The signature of a signal must match the signature of the receiving slot. (In fact a slot may have a shorter signature than the signal it receives because it can ignore extra arguments.) Since the signatures are compatible, the compiler can help us detect type mismatches when using the function pointer-based syntax. The string-based SIGNAL and SLOT syntax will detect type mismatches at runtime. Signals and slots are loosely coupled: A class which emits a signal neither knows nor cares which slots receive the signal. Qt's signals and slots mechanism ensures that if you connect a signal to a slot, the slot will be called with the signal's parameters at the right time. Signals and slots can take any number of arguments of any type. They are completely type safe.\n\nAll classes that inherit from QObject or one of its subclasses (e.g., QWidget) can contain signals and slots. Signals are emitted by objects when they change their state in a way that may be interesting to other objects. This is all the object does to communicate. It does not know or care whether anything is receiving the signals it emits. This is true information encapsulation, and ensures that the object can be used as a software component.\n\nSlots can be used for receiving signals, but they are also normal member functions. Just as an object does not know if anything receives its signals, a slot does not know if it has any signals connected to it. This ensures that truly independent components can be created with Qt.\n\nYou can connect as many signals as you want to a single slot, and a signal can be connected to as many slots as you need. It is even possible to connect a signal directly to another signal. (This will emit the second signal immediately whenever the first is emitted.)\n\nTogether, signals and slots make up a powerful component programming mechanism.\n\nSignals are emitted by an object when its internal state has changed in some way that might be interesting to the object's client or owner. Signals are public access functions and can be emitted from anywhere, but we recommend to only emit them from the class that defines the signal and its subclasses.\n\nWhen a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. Execution of the code following the statement will occur once all slots have returned. The situation is slightly different when using queued connections; in such a case, the code following the keyword will continue immediately, and the slots will be executed later.\n\nIf several slots are connected to one signal, the slots will be executed one after the other, in the order they have been connected, when the signal is emitted.\n\nSignals are automatically generated by the moc and must not be implemented in the file.\n\nA note about arguments: Our experience shows that signals and slots are more reusable if they do not use special types. If QScrollBar::valueChanged() were to use a special type such as the hypothetical QScrollBar::Range, it could only be connected to slots designed specifically for QScrollBar. Connecting different input widgets together would be impossible.\n\nA slot is called when a signal connected to it is emitted. Slots are normal C++ functions and can be called normally; their only special feature is that signals can be connected to them.\n\nSince slots are normal member functions, they follow the normal C++ rules when called directly. However, as slots, they can be invoked by any component, regardless of its access level, via a signal-slot connection. This means that a signal emitted from an instance of an arbitrary class can cause a private slot to be invoked in an instance of an unrelated class.\n\nYou can also define slots to be virtual, which we have found quite useful in practice.\n\nCompared to callbacks, signals and slots are slightly slower because of the increased flexibility they provide, although the difference for real applications is insignificant. In general, emitting a signal that is connected to some slots, is approximately ten times slower than calling the receivers directly, with non-virtual function calls. This is the overhead required to locate the connection object, to safely iterate over all connections (i.e. checking that subsequent receivers have not been destroyed during the emission), and to marshall any parameters in a generic fashion. While ten non-virtual function calls may sound like a lot, it's much less overhead than any or operation, for example. As soon as you perform a string, vector or list operation that behind the scene requires or , the signals and slots overhead is only responsible for a very small proportion of the complete function call costs. The same is true whenever you do a system call in a slot; or indirectly call more than ten functions. The simplicity and flexibility of the signals and slots mechanism is well worth the overhead, which your users won't even notice.\n\nNote that other libraries that define variables called or may cause compiler warnings and errors when compiled alongside a Qt-based application. To solve this problem, the offending preprocessor symbol.\n\nThe QObject-based version has the same internal state, and provides public methods to access the state, but in addition it has support for component programming using signals and slots. This class can tell the outside world that its state has changed by emitting a signal, , and it has a slot which other objects can send signals to.\n\nAll classes that contain signals or slots must mention Q_OBJECT at the top of their declaration. They must also derive (directly or indirectly) from QObject.\n\nSlots are implemented by the application programmer. Here is a possible implementation of the slot:\n\nThe line emits the signal from the object, with the new value as argument.\n\nIn the following code snippet, we create two objects and connect the first object's signal to the second object's slot using QObject::connect():\n\nCalling makes emit a signal, which will receive in its slot, i.e. is called. Then emits the same signal, but since no slot has been connected to 's signal, the signal is ignored.\n\nNote that the function sets the value and emits the signal only if . This prevents infinite looping in the case of cyclic connections (e.g., if were connected to ).\n\nBy default, for every connection you make, a signal is emitted; two signals are emitted for duplicate connections. You can break all of these connections with a single disconnect() call. If you pass the Qt::UniqueConnection type, the connection will only be made if it is not a duplicate. If there is already a duplicate (exact same signal to the exact same slot on the same objects), the connection will fail and connect will return .\n\nThis example illustrates that objects can work together without needing to know any information about each other. To enable this, the objects only need to be connected together, and this can be achieved with some simple QObject::connect() function calls, or with uic's automatic connections feature.\n\nThe following is an example of the header of a simple widget class without member functions. The purpose is to show how you can utilize signals and slots in your own applications.\n\ninherits QObject, which has most of the signal-slot knowledge, via QFrame and QWidget. It is somewhat similar to the built-in QLCDNumber widget.\n\nThe Q_OBJECT macro is expanded by the preprocessor to declare several member functions that are implemented by the ; if you get compiler errors along the lines of \"undefined reference to vtable for \", you have probably forgotten to run the moc or to include the moc output in the link command.\n\nAfter the class constructor and members, we declare the class . The class emits a signal, , when it is asked to show an impossible value.\n\nIf you don't care about overflow, or you know that overflow cannot occur, you can ignore the signal, i.e. don't connect it to any slot.\n\nIf on the other hand you want to call two different error functions when the number overflows, simply connect the signal to two different slots. Qt will call both (in the order they were connected).\n\nA slot is a receiving function used to get information about state changes in other widgets. uses it, as the code above indicates, to set the displayed number. Since is part of the class's interface with the rest of the program, the slot is public.\n\nSeveral of the example programs connect the valueChanged() signal of a QScrollBar to the slot, so the LCD number continuously shows the value of the scroll bar.\n\nNote that is overloaded; Qt will select the appropriate version when you connect a signal to the slot. With callbacks, you'd have to find five different names and keep track of the types yourself.\n\nThe signatures of signals and slots may contain arguments, and the arguments can have default values. Consider QObject::destroyed():\n\nWhen a QObject is deleted, it emits this QObject::destroyed() signal. We want to catch this signal, wherever we might have a dangling reference to the deleted QObject, so we can clean it up. A suitable slot signature might be:\n\nTo connect the signal to the slot, we use QObject::connect(). There are several ways to connect signal and slots. The first is to use function pointers:\n\nThere are several advantages to using QObject::connect() with function pointers. First, it allows the compiler to check that the signal's arguments are compatible with the slot's arguments. Arguments can also be implicitly converted by the compiler, if needed.\n\nYou can also connect to functors or C++11 lambdas:\n\nIn both these cases, we provide this as context in the call to connect(). The context object provides information about in which thread the receiver should be executed. This is important, as providing the context ensures that the receiver is executed in the context thread.\n\nThe lambda will be disconnected when the sender or context is destroyed. You should take care that any objects used inside the functor are still alive when the signal is emitted.\n\nThe other way to connect a signal to a slot is to use QObject::connect() and the and macros. The rule about whether to include arguments or not in the and macros, if the arguments have default values, is that the signature passed to the macro must not have fewer arguments than the signature passed to the macro.\n\nAll of these would work:\n\nBut this one won't work:\n\n...because the slot will be expecting a QObject that the signal will not send. This connection will report a runtime error.\n\nNote that signal and slot arguments are not checked by the compiler when using this QObject::connect() overload.\n\nFor cases where you may require information on the sender of the signal, Qt provides the QObject::sender() function, which returns a pointer to the object that sent the signal.\n\nLambda expressions are a convenient way to pass custom arguments to a slot:\n\nUsing Qt with 3rd Party Signals and Slots\n\nIt is possible to use Qt with a 3rd party signal/slot mechanism. You can even use both mechanisms in the same project. To do that, write the following into your CMake project file:\n\nIn a qmake project (.pro) file, you need to write:\n\nIt tells Qt not to define the moc keywords , , and , because these names will be used by a 3rd party library, e.g. Boost. Then to continue using Qt signals and slots with the flag, simply replace all uses of the Qt moc keywords in your sources with the corresponding Qt macros Q_SIGNALS (or Q_SIGNAL), Q_SLOTS (or Q_SLOT), and Q_EMIT.\n\nThe public API of Qt-based libraries should use the keywords and instead of and . Otherwise it is hard to use such a library in a project that defines .\n\nTo enforce this restriction, the library creator may set the preprocessor define when building the library.\n\nThis define excludes signals and slots without affecting whether other Qt-specific keywords can be used in the library implementation."
    },
    {
        "link": "https://stackoverflow.com/questions/13362551/qt-signal-slot-design-and-performance",
        "document": "I've recently started using Qt and I need some clarification on signal/slot mechanism. I understand how it's a great tool for the GUI and communication between objects living in separate threads, but I'm not quite sure whether I should use it in a simple cases like the following one.\n\nI have three classes, let's call them MainWindow, DataManager and DataWorker. DataWorker lives in a separate thread and signals when new data is ready for collection. It is then visualised in MainWindow widgets after some processing. I've created DataManager class as to not pollute the GUI class with processing code.\n\nNow, how should I handle the communication between DataManager and the MainWindow.\n\nOption #1 - have a pointer to MainWindow as a member and just call its method\n\nOption 1 seems more intuitive to me, but then again I don't know Qt very well. I can see the benefit of using signals and slots if there will be more classes that I'd like to react to a newData() signal.\n\nSo what's a better option and is there any difference in performance between the two?"
    },
    {
        "link": "https://stackoverflow.com/questions/29636263/qt-oo-best-practices-connecting-signals-and-slots",
        "document": "I'm relatively light on Qt experience, though I definitely like it. One thing I'm uncertain of is where the best place is to connect signals to slots. Here's an example from my small device with a touchscreen:\n\nI have a class called RadioModel that is owned by my QApplication. My QApplication also owns what I call a ViewController. The ViewController owns the view - i.e. all of the widgets that make up the user interface. There is some hierarchy to the UI widgets, of course. The top-level widget is a QHBoxLayout, which has indicator labels at the top, and a QTabWidget at the bottom. The QTabWidget has 3 screens, each with things like QLabels, QGroupBoxes, QComboBoxes, etc.\n\nThe model needs to be signaled when values in the QGroupBoxes and QComboBoxes change. My initial thought was to have a chain like this:\n\nQRadioButton (part of QGroupBox) signals clicked(), this goes to SLOT of the current tab of the QTabWidget, which looks at the sender to determine the value (which radio button) that was clicked, then emits its own signal like RadioChanged. This RadioChanged signal would get connected to the ViewController's RadioChanged signal, which would in turn be connected to the Model's UpdateRadio slot.\n\nGenerally speaking, when a widget that is fairly isolated from the model emits a signal of interest, is it fair to have this long chain of signals and slots to get that value change back to the model? Would it be better to pass the model into the ViewController and possibly some of its objects so that the signals can be connected with a shorter path?\n\nThanks - hope that was understandable and hopefully not too subjective.."
    },
    {
        "link": "https://medium.com/@arsenmargaryan38/signals-and-slots-in-qt-4496792d409b",
        "document": "Signals: A signal is emitted when a particular event occurs. In the context of a button, for example, a signal is emitted when the button is clicked. Signals do not have any return value, and they can be connected to multiple slots (functions) that will be executed when the signal is emitted.\n\nSlots: A slot is a function that is called in response to a particular signal. Slots can be used for any regular function, but they have a special connection to signals. In Qt, slots can have parameters that match the parameters emitted by the signal, and multiple signals can be connected to a single slot.\n\nSignals are declared in a class using a special section marked signals:. A signal in Qt is similar to a function declaration but without a body. You don’t need to define its implementation, as signals are automatically handled by the Qt meta-object system. Here’s an example of a signal definition:\n\n. A signal in Qt is similar to a function declaration but without a body. You don’t need to define its implementation, as signals are automatically handled by the Qt meta-object system. Here’s an example of a signal definition:\n\nAny function that matches the signature of a signal can be used as a slot. However, for clarity and explicitness, you can mark certain functions as slots using the slots:\n\nMultiple slots can be connected to a single signal, and a single slot can be connected to multiple signals. It’s also possible to connect a signal directly to another signal.\n\nsenderObject: The object emitting the signal.\n\nsignalName: The name of the signal being emitted.\n\nreceiverObject: The object receiving the signal.\n\nslotName: The method (slot) that processes the signal.\n\ntype: Defines the type of connection, controlling how the signal is delivered.\n\nQt::AutoConnection: The default connection type. If both the sender and the receiver are in the same thread, a direct connection (Qt::DirectConnection) is used. Otherwise, a queued connection (Qt::QueuedConnection) is applied\n\nQt::DirectConnection: If the signal and slot are in the same thread, the slot is called immediately after the signal is emitted.\n\nQt::QueuedConnection: If the signal and slot belong to different threads, the slot is invoked once control returns to the event loop of the receiver’s thread.\n\nQt::BlockingQueuedConnection: Similar to Qt::QueuedConnection, but the emitting thread is blocked until the slot is executed. This cannot be used if both sender and receiver are in the same thread to avoid deadlocks.\n\nQt::UniqueConnection: Prevents the creation of duplicate connections. It can be combined with any other connection type using bitwise OR. The connection fails if it already exists.\n\nQt::SingleShotConnection: Ensures that the slot is invoked only once. The connection is automatically disconnected after the signal is emitted. This type can be combined with other connection types and was introduced in Qt 6.0.\n\nThere are several ways to establish connections between signals and slots. The classic syntax looks like this:\n\nIn this form, the SIGNAL() and SLOT() macros are used to specify the signal and the slot, respectively. This syntax has been used since the earliest versions of Qt and may still be found in legacy code.\n\nHowever, in modern Qt versions, a more robust and type-safe syntax is recommended:\n\nThis newer syntax relies on function pointers and offers better compile-time checks. It ensures that mismatches between signal and slot signatures are caught by the compiler.\n\nAlternatively, a lambda expression can be used as a slot:\n\nThis allows for inline handling of signals without the need for a dedicated slot method, which can be useful in cases where the logic is simple or one-time.\n\nTo ensure that the connection has been successfully established, it is possible to check the return value of connect(). The function returns a QMetaObject::Connection object, which can be tested for validity. A failed connection could indicate incompatible signatures, missing signals, or missing slots.\n\nHowever, the following connection would fail because the slot expects more arguments than the signal provides:\n\nTo disconnect a signal from a slot, the disconnect() function is used. It can take several forms, with the simplest form accepting a connection to be removed:\n\nIf multiple slots are connected to the same signal, the slots will be executed in the order in which they were connected.\n\nIn order for a class to use signals and slots, it must inherit from QObject and include the Q_OBJECT macro at the top of the class definition. The Q_OBJECT macro is essential as it enables the Qt Meta-Object Compiler (MOC) to generate additional code required for the signal-slot mechanism.The MOC tool reads the C++ header files, and when it finds the Q_OBJECT macro, it generates additional C++ code (known as meta-object code). This code enables runtime introspection and dynamic interaction with the object, allowing Qt to handle signals and slots, dynamic property access, and more.\n\nWhat is the emit Keyword?\n\nA signal is emitted when a particular event occurs, while a slot is a function that gets executed in response to a signal. The emit keyword is used to emit (or trigger) signals from within a class. Although it doesn’t perform any logic on its own, it plays a crucial role in dispatching signals.\n\nTechnically, emit is simply a preprocessor macro provided by Qt. It serves as a hint for the developer, enhancing code readability by explicitly indicating that a signal is being emitted. Without the emit keyword, the code would still function correctly, but it would be less intuitive.\n\nWe’ll create a simple class that emits a signal whenever a button is “clicked”. The signal will be caught by a connected slot, which will print a message.\n\nNow, we’ll create an instance of Button in the main() function, connect the clicked signal to the onButtonClicked slot, and simulate a button click.\n\nSignal Declaration: In the Button class, the clicked() signal is declared using the signals section. It is a function-like declaration without a body.\n\nSlot Implementation: The slot onButtonClicked() is a regular function defined in the public slots section. When the clicked signal is emitted, this function gets called.\n\nEmitting the Signal: Inside the simulateClick() method, the emit clicked(); line triggers the clicked signal.\n\nSignal-Slot Connection: In the main() function, we use QObject::connect to link the clicked signal to the onButtonClicked slot.\n\nWhen the simulateClick() function is called, the emit clicked() line is executed. This emits the clicked() signal, and since it is connected to the onButtonClicked() slot, the slot function is executed. As a result, “Button clicked!” is printed to the console.\n\nIn modern application development, especially in GUI programming, concurrency is essential for maintaining responsiveness and improving performance. Qt provides an elegant way to handle communication between threads using its powerful signal-slot mechanism.\n\nThread safety refers to the ability of a program or piece of code to function correctly when accessed by multiple threads simultaneously. In a multi-threaded environment, accessing shared resources (such as variables or objects) can lead to race conditions, deadlocks, or inconsistent behavior if proper synchronization techniques are not used.\n\nIn Qt, signals and slots provide a convenient way to communicate between objects, often across threads. However, when dealing with threads, ensuring that this communication is thread-safe becomes crucial.\n\nQt offers several types of connections between signals and slots:\n\nThe slot is called immediately when the signal is emitted, within the same thread.\n\nIt’s equivalent to calling the slot as a normal function.\n\nNot thread-safe when used between different threads, as both the signal and slot are executed in the sender’s thread.\n\nThe signal is placed in the event queue of the receiving thread, and the slot is invoked when the event is processed.\n\nThread-safe, as the communication happens asynchronously, and the slot runs in the receiver’s thread.\n\nSimilar to a queued connection, but the signal emitter blocks until the slot has finished executing.\n\nUsed for synchronizing threads.\n\nThread-safe, but should be used cautiously as it can lead to performance issues due to blocking.\n\nAutomatically decides whether to use a direct or queued connection based on the thread context.\n\nIf the signal and slot are in the same thread, it behaves like a direct connection. Otherwise, it behaves like a queued connection.\n\nBy default, when the signal and slot are in different threads, Qt uses a queued connection. This ensures thread safety because the signal is sent to the receiving thread’s event loop, which processes the slot asynchronously.\n\nThe Importance of Queued Connection for Thread Safety\n\nWhen you use queued connections, the signal is placed in the event queue of the receiver’s thread, ensuring that the slot is executed in the right thread without interfering with other threads. This prevents potential race conditions that might arise if both the signal and slot were executed in different threads simultaneously.\n\nIn the above example, Worker::doWork() will be executed in the worker thread, not the main thread, because of the QueuedConnection type.\n\nWhile Qt provides a powerful and safe mechanism for threading using signals and slots, there are still some potential pitfalls that developers must be aware of.\n• Non-Reentrant Slots\n\nA slot that modifies shared data without proper synchronization can lead to race conditions. Qt itself provides thread-safe classes like QMutex, QMutexLocker, and QReadWriteLock to handle synchronization between threads.\n\n2. Long-Running Slots\n\nSlots that take a long time to execute can block the event loop, causing delays or UI freezes. It’s better to offload long-running tasks to worker threads using QtConcurrent::run() or move the object to a separate thread.\n\n3. Blocking Queued Connection Misuse\n\nUsing BlockingQueuedConnection can lead to deadlocks if not used carefully, especially if the sender and receiver are interdependent.\n• Always Use Queued Connection for Cross-Thread Communication:\n\nWhen dealing with signals and slots between threads, always use Qt::QueuedConnection. It ensures that the slot is executed in the correct thread and avoids race conditions.\n\nUse synchronization mechanisms (e.g., QMutex) when accessing shared data between threads.\n\nIf an object needs to handle signals in a different thread, ensure that you move it to the correct thread using QObject::moveToThread().\n\nLong-running operations should be done in worker threads to prevent UI freezes.\n\nQt provides thread-safe versions of many classes (QMutex, QThread, QAtomicInt, etc.). Use these whenever dealing with multi-threading.\n\nIn summary, the signal-slot mechanism is a cornerstone of Qt’s event-driven architecture, offering a powerful, intuitive, and thread-safe way to handle communication between objects. It not only simplifies development but also lays the foundation for creating dynamic, responsive, and efficient applications across platforms. Whether you are building desktop applications, embedded systems, or mobile apps, mastering the signal-slot mechanism is essential for leveraging the full potential of the Qt framework."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/algorithm/max_element",
        "document": "Finds the greatest element in the range first last .\n\nElements are compared using the comparison function .\n\nSame as , but executed according to .\n\nthe pair of iterators defining the range of elements to examine the execution policy to use comparison function object (i.e. an object that satisfies the requirements of ) which returns if the first argument is less than the second.\n\n The signature of the comparison function should be equivalent to the following: While the signature does not need to have const&, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) and regardless of value category (thus, Type1& is not allowed, nor is Type1 unless for a move is equivalent to a copy(since C++11)).\n\n The types Type1 and Type2 must be such that an object of type ForwardIt can be dereferenced and then implicitly converted to both of them. - must meet the requirements of .\n\nIterator to the greatest element in the range first last . If several elements in the range are equivalent to the greatest element, returns the iterator to the first such element. Returns last if the range is empty.\n\nGiven \\(\\scriptsize N\\)N as std::distance(first, last):\n\nExactly applications of the comparison function .\n\nThe overloads with a template parameter named report errors as follows:\n• If execution of a function invoked as part of the algorithm throws an exception and is one of the standard policies, is called. For any other , the behavior is implementation-defined.\n• If the algorithm fails to allocate memory, is thrown.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/max_element-in-cpp",
        "document": "The std::max_element() in C++ is an STL algorithm that is used to find the maximum element in the given range. It is defined inside the <algorithm> header file. In this article, we will learn how to find the maximum element in the range using std::max_element() in C++.\n• first : Iterator to the first element of the range.\n• last : Iterator to the element just after the last element of the range.\n• comp: that compares two elements in the range. By default, it is set as < operator.\n• None When the range is empty, it returns iterator to the last.\n\nWe can find the maximum element of the given range using std::max_element(). This range can be std::vector, array, list or any other container.\n\nTime Complexity: O(n), where n is the number of elements in array.\n\nAuxiliary Space: O(1)\n\nExample 2: Findi ng Element Having Maximum Remainder After Division with 5\n\nFor this purpose, we have to use the custom comparator function.\n\nTime Complexity: O(n), where n is the number of elements in vector.\n\nAuxiliary Space: O(1)\n\nWe have to use custom comparator again to determine how to compare user defined data type on any of its property.\n\nTime Complexity: O(n), where n is the number of elements in the vector.\n\nAuxiliary Space: O(1)\n\nstd::max_element() implements linear search algorithm to find the largest element in the range. It compares each element of the range one by one using the iterator/pointer provided to it as arguments. This is the reason why it gives O(n) linear time complexity.\n\nstd::max_element() not specialized for sorted containers such as std::set, std::map, etc. and still will compare all the elements of these containers to find the maximum element.\n\nWhat happens if multiple elements are maximum in the range?\n\nHow can I get the index of the maximum element in a vector?\n\nCan I use std::max_element() for ordered containers such as set, maps, etc?"
    },
    {
        "link": "https://cpp-lang.net/docs/std/algo/ordinary/max_element",
        "document": "Finds the greatest element in the range [ ; ).\n• (2) Elements are compared using the given binary comparison function .\n\nThe range to find the largest element in. The execution policy to use. See execution policy for details. Comparison function object (i.e. an object that satisfies the requirements of Compare). The signature of the comparison function should be equivalent to the following:\n• The signature does not need to have , but must not modify arguments.\n• Must accept all values of type (possibly const) and , regardless of value category (so is not allowed, nor is unless for a move is equivalent to a copy )\n• The types and must be such that an object of type can be implicitly converted to both of them.\n\nIterator to the greatest element in the range [ ; ).\n\n If several elements in the range are equivalent to the greatest element, returns the iterator to the first such element.\n\nReturns if the range is empty.\n\nThe overloads with a template parameter named report errors as follows:\n• If execution of a function invoked as part of the algorithm throws an exception and is one of the standard policies, is called. For any other , the behavior is .\n• If the algorithm fails to allocate memory, is thrown."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/algorithm/ranges/max_element",
        "document": "Finds the greatest element in the range .\n\nThe function-like entities described on this page are algorithm function objects (informally known as niebloids), that is:\n• Explicit template argument lists cannot be specified when calling any of them.\n• None of them are visible to argument-dependent lookup.\n• When any of them are found by normal unqualified lookup as the name to the left of the function-call operator, argument-dependent lookup is inhibited.\n\nIterator to the greatest element in the range first last . If several elements in the range are equivalent to the greatest element, returns the iterator to the first such element. Returns last if the range is empty (i.e. if first == last).\n\nExactly max(N - 1, 0) comparisons, where N = ranges::distance(first, last)."
    },
    {
        "link": "https://stackoverflow.com/questions/41110906/how-can-i-get-maximum-minimum-and-position-of-the-vector-complex-value-in-c",
        "document": "In Matlab, we can get the max, min, and also the position of the complex vector:\n\nI know that we can do the similar with C++ because Matlab is build from C++. But I could not figure it out. I also have incomplete code, and still working on it:\n\nI also look at the sample code from this link: http://www.cplusplus.com/reference/algorithm/max_element/ but it work only for vector.\n\nAlso when I calculate the I am expecting size = 8 (because of 8 vector complex above) but I gave me only size = 6."
    }
]