[
    {
        "link": "https://medium.com/@simon.swartout/procedural-generation-in-unity-part-1-introduction-to-the-art-48deaeaaf44a",
        "document": "In short, procedural generation is a method of creating content algorithmically rather than manually. This allows us to do virtually anything automatically from producing textures, 3D models, and large in-game environments, it speeds up the development workflow. This technique utilizes pseudo-randomized, often rule-based algorithms to generate data, offering significant advantages when we consider the alternative manual implementation. Here are just a few advantages of using procedural generation in your game:\n• Enhanced Replayability: One use case for procedural generation is level generation. This is especially common in the Rogue-Like genre. By generating unique content in each playthrough, procedural generation ensures that players encounter new experiences by allowing developers to create more content more efficiently and rapidly. Another factor is that it allows for the math to specify how “creative” the levels are, allowing for easier content production at a larger scale.\n• Resource Efficiency: With procedural generation, Developers can create vast amounts of content without the need for extensive manual design, saving time and reducing overall development costs. This can enable small development teams to create enormous and rich experiences without immense funding or time resources.\n• Dynamic Content Creation: Procedural methods allow for the creation of complex and expansive game worlds that would be impractical to design manually. Take the examples, No Man’s Sky or Subnautica.\n\nProcedural generation in gaming has its roots in tabletop role-playing games. Perhaps the best example is the classic Advanced Dungeons & Dragons, which provided mechanisms for dungeon masters to generate dungeons and terrains using random die rolls, which in later editions, were expanded to include complex branching procedural tables. Character generation, likewise is driven in large part by random dice rolls, or rolling and allowing players to select attributes to increase or decrease. (Source: https://en.wikipedia.org/wiki/Procedural_generation?utm_source=chatgpt.com)\n\nIn video games, procedural generation has evolved significantly over the years, with numerous research contributions shaping its development. One notable advancement is the creation of Perlin noise by Ken Perlin in 1983. Perlin noise or gradient noise is a function that has become a fundamental tool in computer graphics, enabling the realistic simulation of natural textures and terrains. Perlin’s work had a large impact on the complexity of CGI, he earned the Academy Award for Technical Achievement in 1997. (Source: https://en.wikipedia.org/wiki/Perlin_noise?utm_source=chatgpt.com)\n\nAdditionally, don’t you remember Rogue (1980) it utilized procedural generation to create fresh dungeons for each of your playthroughs, laying the foundation for an entire genre of video games that is still arguably thriving as we enter 2025. The games simply are easy to sink hundreds if not thousands of hours into because you can, the content is always fresh…to an extent. And this isn’t easy to accomplish.\n\nWe will learn how to use Perlin noise in the context of procedural terrain and prefab generation. It also has other use cases, I particularly like the fact that I can use it for wind.\n\nIn 2016 another pivotal contribution to procedural generation was made, the Wave Function Collapse algorithm by Maxim Gumin.(Source: https://en.wikipedia.org/wiki/Model_synthesis?utm_source=chatgpt.com) Inspired by earlier concepts in model synthesis, WFC is a constraint-solving algorithm widely used in video games. It facilitates the creation of complex patterns and structures by propagating constraints across a grid, ensuring that the generated content adheres to specified rules, entropically. Games like Bad North and Townscaper, showcase the versatility of the method for generating intricate and coherent game environments.\n\nWhen it comes to PCG there are two approaches that are usually employed: constructive generation and the Generate-and-Test methods.\n• This approach involves creating content in a single pass without subsequent evaluation. For this reason, the algorithm ensures that each step contributes to a valid final product, often using predefined rules or patterns to guarantee quality. For example, fractal algorithms can generate terrains recursively applying formulas to produce natural-looking landscapes. In this case, the fractal is our stable pattern. (Source: https://www.cse.unr.edu/~adamsc/Papers%20Referenced/Search-Based%20Procedural%20Content%20Generation.pdf?utm_source=chatgpt.com)\n• These methods generate content and then evaluate it against specific criteria. If the content doesn’t meet the desired standards, it is discarded or modified and the process repeats until a more acceptable outcome is produced. This approach allows for flexibility and the potential to create more diverse content but can be computationally intensive due to the iterative nature of the testing process. (Source: https://www.cse.unr.edu/~adamsc/Papers%20Referenced/Search-Based%20Procedural%20Content%20Generation.pdf?utm_source=chatgpt.com)\n• A specialized form of the generate and test approach is Search-Based Procedural Content Generation (SBPCG). In SBPCG, the evaluation function assigns a fitness value to the generated content rather than a simple pass/fail. This fitness value guides the search algorithm to iteratively improve content quality, often employing techniques like evolutionary algorithms to evolve content towards optimal solutions. (Source: https://www.pcgbook.com/chapter02.pdf)\n• μ: Number of parents in the current generation.\n• λ: Number of offspring generated in each generation.\n• Selection: Both parents (μ\\muμ) and offspring (λ\\lambdaλ) compete to form the next generation of μ\\muμ individuals.\n• This is known as plus selection (hence the “+”), where both parents and offspring are eligible to survive into the next generation.\n\nThe equation above is a common way to describe ES models. It specifies the parental population size and the offspring size, as well as how the selection operates (subtracted from these values).\n\nIn sum, while constructive generation and generate-and-test methods are fundamental to PCG, SBPCG represents an advanced, search-based algorithm that refines the generate-and-test approach by incorporating fitness evaluations to guide content generation more effectively.\n• Unity offers a robust suite of tools and features that empower developers like us to implement procedural generation across various aspects of game development.\n• Procedural Mesh Generation — Unity’s scripting API allows for the dynamic creation and manipulation of meshes at runtime. Developers can define vertices, edges, and triangles through scripts, enabling the generation of complex geometries like terrains, buildings, and characters.\n• Noise Functions for Natural Patterns — Unity provides built-in functions like Mathf.PerlinNoise that are instrumental in generating natural- looking patterns. These functions are commonly used to create terrains, textures, and other environmental features that require organic variability.\n\nImplementing procedural terrain generation in Unity is fairly straightforward. We are modifying one object, the terrain, and ultimately the initial algorithm does not need to be precise, in fact we can completely rely on the Unity API here.\n\nCreate a new terrain gameobject in your scene, create a new script called TerrainGenerator and attach it to that gameobject.\n\nThis is applying perlin noise as a heightmap on the terrain. Next we are going to improve the appearance of the effect by implementing a couple of different algorithms in our TerrainGenerator script. Then we will be ready to convert it to an editor utility that you can use as a tool in your projects."
    },
    {
        "link": "https://discussions.unity.com/t/best-unity-procedural-generation-tutorials/565595",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Unity3D/comments/4jiqo7/procedural_generation_how_do_you_do_it",
        "document": "Hello fellow unity programmers! (Need to think of a better intro I guess)\n\nI have seen a lot of Unity projects use Procedural generation lately, for many different purposes, but most of them were for world generation. So I was wondering. How did you guys learn about it? How did you learn how to use/make it? I have no idea how to do it and would like to know. Is there some sort of tutorial (but I don't really want a tutorial that says how to make a certain world, I want to really know how to do it so I can fully adapt and make my own without having to look at different tutorials for different types of world.)"
    },
    {
        "link": "https://kentpawson123.medium.com/procedural-generation-an-overview-1b054a0f8d41",
        "document": "Procedural Generation, also known as Procedural Content Generation (PCG), is the creation of data using an algorithm, as opposed to manually creating the data. This data is generated during runtime.\n\nImagine you’re walking in a meadow with mountains surrounding you, birds chirping, elk grazing on the grass nearby, and wildflowers all around your feet. You feel alive and say to yourself, “Wow… This is beautiful!” As you arrive back home from this amazing experience, you remember your game development skills that you’ve been learning. After quickly booting up your PC, you open your favorite game engine and try to manually recreate this extraordinary mountain meadow experience. You fail miserably after realizing the amount of work involved in manually creating a landscape. Just as all seems lost, the term procedural generation comes into your head. After conducting enough research, you become an expert in procedural generation and soon generate your beautiful mountain landscape using an algorithmic approach rather than manual creation. Success!\n\nNow, the scenario I gave above is a bit extreme. Landscapes or environments can very well be created through a manual process without even using procedural generation. Likely with enough experience, you could manually create a similar setup to the mountain landscape I explained in my scenario, instead of using procedural generation. However, the point I was trying to get across was that procedural generation is often desired in the generation of terrain or landscapes to reduce the amount of manual labor. Moreover, if you intended to create a very detailed landscape that appeared to be infinite in size, this would be close to impossible to create manually. This is where procedural generation can be used to generate this type of landscape.\n\nThe reason I chose landscape generation for my scenario is because I’m very passionate about it. Apparently a lot of other people are too because this seems to be one of the most common topics for PCG when searching the web. Landscape generation is not the only form of PCG however. In fact, there are many forms ranging from generating animations to music and more!\n\nAh yes, our favorite topic. History! It seems that people either love it or hate it. I’ll keep this section relatively short, but I believe it’s always important to know the history of something that you’re learning.\n\nWhile its difficult to find on the web which game was the first to use PCG, two of the most notable games are Rogue(1980) and Elite(1984). Rogue started a new genre of video games called rogue-like games. These featured procedurally generated levels where the player navigates a labyrinth type environment (referred to as a dungeon). Although some of these games predate Rogue, such as Beneath Apple Manor(1978), Rogue is considered the ancestor of all rogue-like games.\n\nThe early history of games had memory limitations which is one of the driving factors of their decision to use procedural generation so they could compress the data and decrease their file sizes.\n\nNowadays, computers are more advanced and don’t have as many memory or hardware restrictions. Even still, PCG is commonly used as a way for data compression. Modern uses of PCG often include creating terrain, levels, storylines, or other data that is unique for each playthrough.\n\nProcedural generation is generally used for increasing the replay value, data compression, reusing data, and for greater scalability in games.\n\nWithin game development there are many areas where procedural generation can be used. I’ve listed a few of these areas below, and although these are not all of them, they seem to be the most common ones used in games.\n\nOften 2D games will use algorithms to generate levels in their games. This approach is seen in rogue-like games.\n\nMany open world games procedural generate their landscape in some way. No Man’s Sky, a game developed by Hello Games, used procedural generation to create an entire galaxy of planets, each containing their own atmosphere and wildlife.\n\nAnimation, such as character animation, is another use of procedural generation. PCG may help the animation appear more unique and flow smoothly.\n\nOften to create a unique playthrough, games will procedurally generate the dialogue. Moreover, the decisions the player makes in the game may affect the storyline and allow the storyline to generate its own content based on how the character responds to a certain event.\n\nInstantiating objects is one of the most common uses of PCG in games. Often this is referred to as spawning. The objects that are spawned may be enemies, animals, trees, loot, particle systems, and more!\n\nOften quest-based games will use an algorithm to create a loot system. This algorithm may generate loot based on the player’s current level. If the player has a high rank, the generated loot will likely be more rare as opposed to that of a low ranked player."
    },
    {
        "link": "https://upcommons.upc.edu/bitstream/2117/397579/2/406_Memoria_TFG.pdf",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/creating-objects-dynamically/526040",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/how-do-i-dynamically-generate-scenes/83183",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/16183457/how-to-randomly-generate-gameobjects-programmatically",
        "document": "I'd like some help with the following issue. I'm making a simple game where you have a character running and he has to jump over obstacles coming at him.\n\nAnd I'm currently stuck when it comes to creating GameObjects and randomly generating them within the game scene at run time.\n\nI've written a class to help accomplish this:\n\nThe above code is what I wrote to simply create Objects, one after the other. But when I run the game, it comes up empty -_- !\n\nCan anyone please tell me where am going wrong, and from the look of it my code doesn't seem to do what I am hoping to achieve :(\n\nI've attached the above script into an empty GameObject as I saw in a tutorial from the Unity Community forum, but that did not help either. (I've looked around and it seems like no one has come across such an issue - I could bee wrong)"
    },
    {
        "link": "https://medium.com/geekculture/unity-shorts-1-instantiating-game-objects-63533c96b381",
        "document": "When you work with the Unity game engine, one of the most fundamental concepts you’ll have to wrap your head around is the game object. Everything is based around them, from your on-screen characters to the sound effects, the UI and even the execution of your C# scripts.\n\nBasically, a game object is an empty container that is filled with components to gradually compose a more complex behaviour. Some of those components are for rendering, others for physics collisions and gravity computation, others for emitting sounds, and of course you also usually want to drag and slap your own scripts on your game objects, to actually play your logic in the game!\n\nSo — game objects are essential, ok.\n\nBut how exactly do you create them? How do you spawn game objects in your Unity scenes, be it in edit mode or at runtime?"
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Object.Instantiate.html",
        "document": "This function makes a copy of an object in a similar way to the Duplicate command in the editor. If you are cloning a GameObject you can specify its position and rotation (these default to the original GameObject's position and rotation otherwise). If you are cloning a Component the GameObject it is attached to is also cloned, again with an optional position and rotation.\n\n\n\nWhen you clone a GameObject or Component, all child objects and components are also cloned with their properties set like those of the original object.\n\n\n\nNote: When this method clones a child object, it also clones the child's own children. To prevent stack overflow, Unity limits this nested cloning. If you exceed more than half your stack size, Unity throws an .\n\n\n\nBy default the parent of the new object is null; it is not a \"sibling\" of the original. However, you can still set the parent using the overloaded methods. If a parent is specified and no position and rotation are specified, the original object's position and rotation are used for the cloned object's local position and rotation, or its world position and rotation if the parameter is true. If the position and rotation are specified, they are used as the object's position and rotation in world space.\n\n\n\nThe active status of a GameObject at the time of cloning is maintained, so if the original is inactive the clone is created in an inactive state too. Additionally for the object and all child objects in the hierarchy, each of their Monobehaviours and Components will have their Awake and OnEnable methods called only if they are active in the hierarchy at the time of this method call.\n\n\n\nFor more flexibility, there are generic overrides that take an InstantiateParameters struct, allowing to pass any combination of parameters like parent, target scene or world space positions.\n\n\n\nThese methods do not create a prefab connection to the new instantiated object. Creating objects with a prefab connection can be achieved using PrefabUtility.InstantiatePrefab.\n\n\n\nAdditional resources:\n\n\n\nInstantiating prefabs at run time\n\n PrefabUtility.InstantiatePrefab"
    }
]