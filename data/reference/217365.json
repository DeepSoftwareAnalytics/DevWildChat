[
    {
        "link": "https://developer.x.com/en/docs/x-api",
        "document": "With the volume of different endpoints and features available on the X API, it’s not always easy to know what to use it for.\n\nWe’ve made it easy for you. Check out our 'what to build\" page to learn more."
    },
    {
        "link": "https://docs.x.com/x-api/enterprise-gnip-2.0/fundamentals/account-activity",
        "document": "The Account Activity API provides you the ability to subscribe to realtime activities related to a user account via webhooks. This means that you can receive realtime Posts, Direct Messages, and other account events from one or more of your owned or subscribed accounts through a single connection.\n\nYou will receive all related activities below for each user subscription on your webhook registration:\n\nPlease note - We do not deliver home timeline data via the Account Activity API. Please use the GET statuses/home_timeline to pull this data.\n\nCheck out our four-part video series on the Account Activity API to get up to speed!\n• \n• Enterprise Account Activity API dashboard, a node web app that displays webhook events using the enterprise tier of the Account Activity API and includes Replay functionality.\n• The SnowBot chatbot, a Ruby web app built on the enterprise Account Activity and Direct Message APIs.\n\nThe enterprise Account Activity API provides you webhook-based JSON messages any time there are events associated with X accounts subscribed to your service. X delivers those activities to your registered webhook. In the following steps, you will learn how to manage webhooks and subscribed users.\n\nYou will learn how to register, view, and remove, both webhooks and subscribed users. We’ll be using simple cURL commands to make requests to the various API endpoints. cURL is a command-line tool for getting or sending requests using the URL syntax.\n\nYou will need:\n\nBefore you get started, we recommend you check out our Github repo here that provides a sample web app and helper scripts to get started with X’s Account Activity API\n\nUsing a webhook provides you the ability to subscribe to realtime activities related to a user account through a single connection.\n\nOnce you’ve registered a Webhook, you can add a subscribed user to the Account Activity API to begin receiving their account activities.\n\nGreat job! You should now able to manage your webhooks and subscribed users.\n\nIn this video walkthrough, you will learn about the capabilities of the premium and enterprise tiers of the Account Activity API.\n\nBy the end of this video, you will learn about the following capabilities.\n• \n• Enterprise Account Activity API dashboard, a node web app that displays webhook events using the enterprise tier of the Account Activity API and includes Replay functionality.\n• The SnowBot chatbot, a Ruby web app built on the enterprise Account Activity and Direct Message APIs.\n\nThe Account Activity API is a webhook-based API that sends account events to a web app you develop, deploy and host.\n\nThere are several ‘plumbing’ details that need attention before you can start receiving webhook events in your event consumer application. As described below, you will need to create a X app, obtain Account Activity API access, and develop a web app that consumes webhook events.\n• Create a X app with an approved developer account from the developer portal. If you are creating the app on behalf of your company, it is recommended you create the app with a corporate X account. To apply for a developer account, click here.\n• Enable “Read, Write and Access direct messages” on the permissions tab of your app page.\n• On the “Keys and Access Tokens” tab, take note of your app’s Consumer Key (API Key) and Consumer Token (API Secret).\n• On the same tab, generate your app’s Access Token and Access Token Secret. You will need these Access Tokens to register your webhook URL, which is where X will send account events.\n• If you are unfamiliar with X Sign-in and how user contexts work with the X API review Obtaining Access Tokens. As you add accounts for which to receive events, you will subscribe them using that account’s access tokens.\n• Take note of your app’s numeric ID, as seen in the “Apps” page of the developer portal. When you apply for Account Activity API access, you’ll need this app ID.\n\nAfter creating a X app, the next step is applying for Account Activity API access.\n\nAccount Activity API is only availble on Enterprise, so you will need to submit an application using the link below.\n\nOnce you have received Account Activity API access, you need to develop, deploy and host a web app that will receive X webhook events.\n• Create a web app with a URL to use as your webhook to receive events. This is the endpoint deployed on your server to listen for incoming X webhook events.\n• The URI path is completely up to you. This example would be valid: https://mydomain.com_/service/listen_\n• If you are listening for webhooks from a variety of sources, a common pattern is: https://mydomain.com/webhook/twitter\n• Note that the specified URL can not include a port specification (https://mydomain.com:5000/NoWorkie).\n• As described in our Securing Webhooks guide, a first step is writing code that receives a X Challenge Response Check (CRC) GET request and responds with a properly formatted JSON response.\n• Register your webhook URL. You will make a POST request to a /webhooks.json?url= endpoint. When you make this request X will issue a CRC request to your web app. When a webhook is successfully registered, the response will include a webhook id. This webhook id is needed later when making some requests to the Account Activity API.\n• X will send account webhook events to the URL you registered. Make sure your web app supports POST requests for incoming events. These events will be encoded in JSON. See HERE for example webhook JSON payloads.\n• Once your web app is ready, the next step is adding accounts to receive activities for. When adding (or deleting) accounts you will make POST requests referencing the account id. See our guide on adding subscriptions for more information.\n• To validate your app and webhook are configured correctly, favorite a Post posted by one of the X accounts your app is subscribed to. You should receive a via a POST request to your webhook URL for each Favorite your subscribers receive.\n• Note that it may take up to 10 seconds for events to start being delivered after a subscription has been added.\n• When registering your webhook URL, your web app must authenticate with its consumer token and secret and the app owner’s user access token and secret.\n• All incoming Direct Messages will be delivered via webhooks. All Direct Messages sent via POST direct_messages/events/new (message_create) will also be delivered via webhooks. This is so your web app can be aware of Direct Messages sent via a different client.\n• Note that every webhook event includes a for_user_id user ID that indicates which subscription the event was delivered for.\n• If you have two users using your web app for Direct Messages in the same conversation, your webhook will receive two duplicate events (one for each user). Your web app should account for this.\n• If you have more than one web app sharing the same webhook URL and the same user mapped to each app, the same event will be sent to your webhook multiple times (once per web app).\n• In some cases, your webhook may receive duplicate events. Your webhook app should be tolerant of this and dedupe by event ID.\n• Do not expect Quick Reply response to directly follow a request. A user has the ability to ignore a Quick Reply request and may respond via traditional Direct Message. The user may also provide a Quick Reply response to a request they have not replied to earlier in the message thread.\n• \n• Enterprise Account Activity API dashboard, a node web app that displays webhook events using the enterprise tier of the Account Activity API and includes Replay functionality.\n• The SnowBot chatbot, a Ruby web app built on the Account Activity and Direct Message APIs. This code base includes a script to help set up Account Activity API webhooks.\n\nX’s webhook-based APIs provide two methods for confirming the security of your webhook server:\n• The challenge-response checks enable X to confirm the ownership of the web app receiving webhook events.\n• The signature header in each POST request enables you to confirm that X is the source of the incoming webhooks.\n\nIn order to verify that you are both the owner of the app and the webhook URL, X will perform a Challenge-Response Check (CRC), which is not to be confused with a cyclic redundancy check. When a CRC is sent, X will make a GET request of your web app with a ; parameter. When that request is received, your web app needs to build an encrypted based on the parameter and your app’s Consumer Secret (details below). The response_token must be encoded in JSON (see example below) and returned within three seconds. When successful, a webhook will be returned.\n\nA CRC will be sent when you register your webhook URL, so implementing your CRC response code is a fundamental first step. Once your webhook is established, X will trigger a CRC roughly every 24 hours from the last time we received a successful response. Your app can also trigger a CRC when needed by making a PUT request with your webhook . Triggering a CRC is useful as you develop your webhook application, after deploying new code and restarting your service.\n\nThe should be expected to change for each incoming CRC request and should be used as the message in the calculation, where your Consumer Secret is the key.\n\nIn the event that the response is not posted within 3 seconds or becomes invalid, events will cease to be sent to the registered webhook.\n• You can manually trigger a CRC by making a PUT request. As you develop your webhook client, you should plan on manually triggering the CRC as you develop your CRC response.\n• A base64 encoded HMAC SHA-256 hash created from the and your app Consumer Secret\n\nThe following defines a route in a Python 2.7 Flask webapp that will respond to the challenge response check correctly.\n\nWith the route defined as above your webapp should return a response similar to below when navigating to https://your-app-domain/webhooks/twitter?crc_token=foo in your web browser.\n• HERE is an example CRC response method written in Node/JS.\n• HERE is an example CRC response method written in Ruby (see the generate_crc_response and the /GET route that receives CRC events).\n\nWhen receiving a POST request from X, sending a GET request to create a webhook, or sending a GET request to perform a manual CRC, a hash signature will be passed in the headers as x-twitter-webhooks-signature. This signature can be used to validate the source of the data is X. The POST hash signature starts with sha256= indicating the use of HMAC SHA-256 to encrypt your X App Consumer Secret and payload. The GET hash is calculated from the query parameter string crc_token=token&nonce=nonce.\n• Create a hash using your consumer secret and incoming payload body.\n• Compare created hash with the base64 encoded x-twitter-webhooks-signature value. Use a method like compare_digest to reduce the vulnerability to timing attacks.\n\nThe following are additional security guidelines to consider for your web application. Not having these guidelines implemented will not prevent your webhook from functioning, but are highly reccomended by the X Information Security team. If you are unfamilair with the below recommendations consult with your server administrator.\n\nFor added security you may wish to add the following aggregate network blocks to an allowlist:\n• Turn off SSLv3 (because of POODLE)\n• Turn off Session Tickets unless you rotate session ticket keys.\n• Set the “ssl_prefer_server_ciphers” or “SSLHonorCipherOrder” option in the SSL Configuration “on”.\n• Ensure the list of ciphers is a modern list such as:\n\nIn order to change webhook URLs, you must delete your existing webhook and then create a new one. Note that when you do this, you will be required to re-add user subscriptions to the new webhook.\n\nWhy are webhook configurations immutable? X takes security very seriously. If your webhook URL is changed, there is a possibility that your application consumer key and consumer secret have been compromised. By requiring you to create a new webhook configuration, you are also required to re-subscribe to your user’s events. This requires the use of access tokens that a malicious party is less likely to possess. As a result, the likelihood that another party will receive your user’s private information is reduced.\n\nSupport for thousands of subscriptions is available with the enterprise tier. If you already have an account manager, please reach out to them with questions. To apply for access to the enterprise APIs, click here.\n\nThe Account Activity API consists of a set of endpoints that allow you to create and manage user subscriptions to receive real-time account activities for all of your subscribed accounts through a single connection.\n\nThere are two authentication methods available with the Account Activity API (OAuth 1.0a and OAuth 2.0 Bearer Token. The authentication method that you should use will depend on which endpoint you are using.\n\n*_ Authentication requires the access tokens of the subscribing user. _\n\nFor those endpoints that require OAuth 1.0a user context authentication, you will need to provide the following credentials to authenticate the request:\n\nIn the case of the following three endpoints, you perform write actions within the context of your application (no X users are involved). Therefore, the Access Tokens you need to provide are the ones belonging to your developer App. These can be generated directly from within the developer portal, under the “Keys and tokens” tab for your App.\n• POST account_activity/webhooks: Register a new webhook URL for the given application context\n\nOn the other hand, in the case of the following three endpoints, you are making a request that allows your application to access protected data on behalf of a X user (for example, Direct Messages). You must therefore provide the Access Tokens that belong to the subscribing user in question. The required Access tokens can be obtained using the 3-legged OAuth flow (see OAuth 1.0a: how to obtain a user’s Access Tokens). These endpoints have been marked with an asterisk in the above table (*).\n• GET account_activity/webhooks/:webhook_id/subscriptions/all: Check if a webhook configuration is subscribed to a user’s events\n• DELETE account_activity/webhooks/:webhook_id/subscriptions/all: Deactivate a subscription for the provided user context and application [DEPRECATED]\n\nA list of all endpoints available with the Account Activity API, including associated description and example cURL requests with authentication implementation examples, can be found inthe API reference documentation.\n\nFor additional information, check out XDev’s sample web app and helper scripts to get started with the Enterprise Account Activity API.\n\nThe Account Activity API consists of a set of endpoints that allow you to create and manage user subscriptions to receive real-time account activities for all of your subscribed accounts through a single connection.\n\nThere are two authentication methods available with the Account Activity API (OAuth 1.0a and OAuth 2.0 Bearer Token). The authentication method that you should use will depend on which endpoint you are using.\n\n*_ Authentication requires the access tokens of the subscribing user. _\n\nFor those endpoints that require OAuth 1.0a user context authentication, you will need to provide the following credentials to authenticate the request:\n\nIn the case of the following three endpoints, you perform write actions within the context of your application (no X users are involved). Therefore, the Access Tokens you need to provide are the ones belonging to your developer App. These can be generated directly from within the developer portal, under the “Keys and tokens” tab for your App.\n• POST account_activity/webhooks: Register a new webhook URL for the given application context\n\nOn the other hand, in the case of the following three endpoints, you are making a request that allows your application to access protected data on behalf of a X user (for example, Direct Messages). You must therefore provide the Access Tokens that belong to the subscribing user in question. The required Access tokens can be obtained using the 3-legged OAuth flow (see OAuth 1.0a: how to obtain a user’s Access Tokens). These endpoints have been marked with an asterisk in the above table (*).\n• GET account_activity/webhooks/:webhook_id/subscriptions/all: Check if a webhook configuration is subscribed to a user’s events\n• DELETE account_activity/webhooks/:webhook_id/subscriptions/all: Deactivate a subscription for the provided user context and application [DEPRECATED]\n\nA list of all endpoints available with the Account Activity API, including associated description and example cURL requests with authentication implementation examples, can be found inthe API reference documentation.\n\nFor additional information, check out XDev’s sample web app and helper scripts to get started with the Enterprise Account Activity API.\n\nOne of the benefits of the enterprise tier of the Account Activity API is a retry mechanism for webhook events. If a ‘success’ 200 HTTP response code is not received, the X server will initiate a retry mechanism, resending the webhook event up to three times over a five-minute period. This webhook event retry service helps provide reliability and event recovery when network problems occur and during client-side service interruptions and deploys.\n\nThe Account Activity API provides a retry feature when the client’s web app does not return a ‘success’ 200 response for an account activity webhook event. When the client-side does not confirm the successful receipt of an event, X assumes the event was not received. If a non-200 response is received, a response isn’t received within three seconds, or we don’t receive a response at all, we retry the request and leave that open for three seconds. This means that you have roughly five seconds over two attempts to respond to receive the activity that we are trying to send to your webhook URL. In the event that your server doesn’t response or returns a transient error, we will retry for five minutes. There will be a total of three retry attempts to confirm validation. This allows redundancy and insurance that you receive all webhook events. Note that subscriptions with retries will get retried events for any/all activities for all subscribed users on their webhook.\n\nIf you do not confirm validation within these eight attempts, the activity will no longer be available via the Account Activity API.\n\nThe Account Activity API will retry up to three times over a five-minute period until a 200 response is received. Refer to the table below for more details. After around five minutes, the activity cannot be resent through the Account Activity API. You will need to use other X endpoints to collect missed data. For example, the search APIs can be used to retrieve relevant Posts, Retweets, Quote Tweets, Mentions, and Replies. Missed Direct Messages can be retrieved with this endpoint.\n\nSee the payload examples below for each Account Activity event described in the table above.\n\nThe Account Activity Replay API is a data recovery tool that allows you to retrieve events from as far back as five days. It should be utilized to recover data in scenarios where your webhook server misses events, — whether due to disconnections lasting longer than the retry window, or for those disaster recovery scenarios where you need a few days to restore your system back to normal.\n\nThe Account Activity Replay API was developed for any scenario where you fail to ingest activities for a period of time. It delivers activities to the same webhook used for the original real-time delivery of activities. This product is a recovery tool and not a backfill tool, which means events will only be replayed if a previous delivery of them was attempted. The Account Activity Replay API cannot deliver events for a time period prior to a subscription’s creation time.\n\nIf your account is configured with Replay functionality, you can make requests in a similar manner as requests to the Account Activity API. It is important to note that your request must specify a webhook id parameter to indicate which webhook’s activities you would like to replay. In other words, a Replay request asks Account Activity Replay API to retrieve events from a start date and time to an end date and time based on the webhook id and application id.\n\nPlease note that UTC time is expected. These activities are delivered through the registered webhook associated with the id at a rate of up to 2,500 events per second. Also keep in mind that only one Replay job per webhook may be running at a time, although all subscriptions that were active during the date/time specified on that webhook will be replayed.\n\nEvents are delivered beginning with the first (oldest) minute of the specified time period, continuing chronologically (as best as possible) until the final minute is delivered. At that point, Replay will deliver a job completion event to the webhook. Because we work chronologically in delivering activities, if there are little or no matching results near the start time, there will likely be a period of time before the first results are delivered.\n\nReplay is intended as a tool for easily recovering activities as far back as five days ago, but it will not deliver events prior to a subscription’s creation time. For example, if three days ago, you added a new subscription and ran a Replay job with a window for five days prior to today, you would only receive data for the three days that this new subscription was active.\n\nActivities from the Account Activity Replay API are available five days from the initiation of the request, with new data becoming available roughly 10 minutes after a given activity is created. You will be able to make requests specifying a timeframe within this five day window using the from_date and to_date parameters within the request. Events that were originally delivered prior to having access to Replay cannot be replayed. For example, if your account was enabled for access to the Account Activity Replay API on June 1, 2019 at 3:30PM UTC, you would not be able to use Replay to retrieve any events prior to that date and time.\n\nWe retired the Site Streams, User Streams, and standard beta version of the Account Activity API - DM Only products in 2018. If you had been using those products, please make sure to migrate over to the premium or enterprise version of the Account Activity API.\n\n**We have also retired the legacy Direct Message endpoints. If you had been using those endpoints, please make sure to migrate over to either the new DM endpoints, or to the premium or enterprise version of the Account Activity API. **\n\nPlease review this announcment to learn more.\n\nHere are the endpoints that will be affected by these changes:\n\nWe have new endpoints and services available that provide similar access and, for Direct Messages, some additional functionality:\n\nTo help you make a smooth migration to these new endpoints and services we have two migration guides:\n• Account Activity API migration guide for those going from User Streams and Site Streams to our new webhooks based service\n• Direct Message migration guide for those migrating between Direct Message REST endpoints\n\nAdditionally, we have a series of videos about the Account Activity API and how to get started.\n\nAnd, finally, we have code samples to further your understanding and help you get started quickly:\n• The Account Activity Dashboard is a sample Node.js web app with helper scripts to get started with the Account Activity API.\n• SnowBot is a sample chatbot using the Account Activity API and REST Direct Message endpoints. It’s written in Ruby, uses the Sinatra web app framework, and is deployed on Heroku.\n\nAs of August 23rd, 2018, we retired both Site Streams and User Streams. Please make sure to migrate over to the Account Activity API.\n\nPlease review this announcement to learn more.\n\nThis guide is designed to help you migrate from legacy User Streams and Site Streams APIs to their replacement, the Account Activity API. Below you will find a summary of the changes, new features list, as well as key differences and considerations to help with the transition. For guidance in migrating from basic DM endpoints, please refer to the Direct Message migration guide.\n\nThe Account Activity API will deliver you events for authenticated and subscribed accounts via webhooks as opposed to a streaming connection like with User Streams and Site Streams.\n\nGET site (including control streams: GET site/c/:stream_id, GET site/c/:stream_id/info.json, GET site/c/:stream_id/friends/ids.json, POST site/c/:stream_id/add_user.json, POST /site/c/:stream_id/remove_user.json)\n\nAPI format: The new Account Activity API operates differently than User Streams and Site Streams. You will need to alter your web app to receive data with webhooks. You can find more information on webhooks here.\n\nData Available: Another key difference you will notice is in regards to the data being delivered. X will no longer send events from people that you follow on X (aka your home timeline). This was an intentional change and is not something we plan to alter going forward.\n\nReliability: Unlike streaming, webhooks enable confirmation of delivery and options to retry POSTed activities that do not make it to the webhook URL. This gives more assurance that the app is receiving all applicable activities, even if there are brief disconnections or periods of downtime.\n\nThe Account Activity API offers many new features, most notably that data is now delivered via webhooks as opposed to streaming. Webhooks offer many benefits compared to streaming, but the most prominent are speed and reliability. The API will send you data in the form of JSON events as they become available and you will no longer need to maintain an active connection or poll the endpoint. This limits the need for redundancy features and increases efficiency overall. More information on webhooks can be found in the technical documentation.\n\nThe Account Activity API allows multiple subscriptions for a single registered webhook. This allows multiple user subscriptions activities to be delivered to the same location, similar to the Site Streams architecture, with webhooks. This means you can track subscriptions, as they pertain to your subscription limits, independently from the webhook connection. This also allows scalability from only one or a few subscriptions to thousands of subscriptions for a single webhook.\n\nFollow the steps below to easily migrate from the Site Streams API to the Account Activity API\n\nDepending on how you are currently operating with User Streams or Site Streams, you should consider moving to either the enterprise or premium version of the Account Activity API. Consider the number of applications or authorized users you are currently supporting and scale appropriately to the volume and reliability needed. When deciding on the package that best suits your needs, some things worth considering are:\n• The level of support you’d prefer from X (forum support or managed enterprise level 1:1 support)\n\nStep 2: Check the Setup of your X app in the developer portal\n\nThe X app currently used for User Streams or Site Streams will be listed for the owning user within the developer portal. This X app can also be used for Account Activity API to retain authorized users for that application. A new app can also be created, and users can be re-authorized for this new app if desired. If you are creating a new app on behalf of a business, it is recommended that you create the app with a corporate X @handle account.\n• Enable “Read, Write and Access direct messages” on the permissions tab of your X app page. *Note that changing these settings is not retroactive, any authorized users will keep the authorization settings from the time at which they were authorized. If a user has not already given you read, write and direct message access, you will need to have that user re-authorize your application.\n• If you are unfamiliar with X Sign-in and how user contexts work with the X API review Obtaining Access Tokens.\n• Generate access tokens for the X app owner at the bottom of the “Keys and Tokens” tab. On this same tab take note of your Consumer Key, Consumer Secret, Access Token and Access Token Secret. You will need these to use the API.\n• Generate a bearer token using your Consumer Key and Consumer Secret for application-only API methods.\n• Create a web app with an endpoint to use as your webhook to receive events (e.g. https://your\\_domain.com/webhook/twitter or https://webhooks.your\\_domain.com).\n• Use your Consumer Key, Consumer Secret, Access Token and Access Token Secret when creating your webhook, Note that your endpoint must return a JSON response with a response_token that is a base64 encoded HMAC SHA-256 hash created from the crc_token and your app Consumer Secret.\n• Make sure your webhook supports POST requests for incoming events and GET requests for the CRC.\n• Make sure your webhook has low latency (<3 seconds to respond to POST requests)\n• Webhook APIs will secure your webhooks in two ways:\n\n- Require challenge response checks to validate that the webhook owner is the web app owner.\n\n- A signature header in each POST request for your web app to validate the source.\n• In order to verify that you are both the owner of the web app and the webhook URL, X will perform a Challenge Response Check (CRC), which is not to be confused with a cyclic redundancy check.\n• A GET request with a parameter named crc_token will be sent to your webhook URL. Your endpoint must return a JSON response with a response_token that is a base64 encoded HMAC SHA-256 hash created from the crc_token and your app Consumer Secret.\n• The crc_token should be expected to change for each incoming CRC request. The crc_token should be used as the message in the calculation, where your Consumer Secret is the key.\n• In the event that the response is invalid, events will cease to be sent to the registered webhook.\n\nStep 5: Create Subscriptions for Each User Stream or Site Streams Authorized User\n\nConverting to the Account Activity API from User Streams:\n• Generate a list of your current user subscriptions on User Streams\n• Set up your new Account Activity API subscriptions using the request: POST account_activity/all/:env_name/subscriptions\n• Confirm your Account Activity API subscriptions using the request: _GET account_activity/all/:env_name/subscriptions/list _\n\nConverting to the Account Activity API from Site Streams: (using control streams):\n• Generate a list of your current subscriptions on Site Streams using the request: GET /1.1/site/c/:stream_id/info.json\n• Set up your new Account Activity API subscriptions using the request: POST account_activity/all/:env_name/subscriptions\n• Confirm your Account Activity API subscriptions using the request: _GET account_activity/all/:env_name/subscriptions/list _\n\nRegistering a Webhook and Creating Subscriptions (not migrating from Site Streams or User Streams)\n• Register your webhook URL with your app using POST webhooks and receive a webhook_id.\n• Use the returned webhook_id to add user subscriptions with POST webhooks/:webhook_id/subscriptions/all.\n\nWe’ve created a sample app to make testing the Account Activity API a little quicker:\n• Download the Account Activity Dashboard sample application here (it uses Node.js)\n• Follow the instructions on the README to install and launch the app\n• Once the application has been launched, you can use the UI to easily set up your webhook and create a new subscription\n\nOn September 17th, 2018 we retired the legacy Direct Message endpoints. If you had been using those endpoints, please make sure to migrate over to the new Direct Message endpoints or the Account Activity API.\n\nPlease review this announcment to learn more.\n\nThis guide is designed to help you migrate from legacy Direct Message REST APIs to their enhanced replacements which have graduated from beta. Below you will find a summary of the changes, a new features list, and key differences and considerations to help with the transition. The new Direct Message endpoints are available now to all developers. For guidance in migrating from User Streams or Site Streams, see the migration guide to Account Activity API.\n\nIf you are still using the following DM endpoints, you will have to migrate to the newer endpoints.\n\nThe new Direct Message API endpoints support a number of new capabilities and provide improved access to previous Direct Messages. New features include:\n• Ability to prompt users for structured replies with a predefined options list.\n• Up to 30 days of access to past Direct Messages.\n\nFor a full list of new Direct Message features and additional new API endpoints refer to the technical documentation.\n\nThe new API endpoints behave very differently from their previous counterparts. Simply updating the endpoint URLs will result in errors in your application. Consider the following when updating your application for the migration.\n\nThe first thing you are likely to notice is the new object structure of Direct Messages. This new Message Create object structure has been introduced to support new capabilities like Quick Replies and Attachments. The new object also contains a smaller condensed user object. Your application will need to be updated to account for this new object structure when parsing and potentially in data models or storage. For descriptions of each property see the full documentation on the Message Create Object.\n\nPOST direct_messages/events/new is a direct replacement for sending Direct Messages. The most significant difference with this endpoint is that all information is now sent as JSON in the POST request body as opposed to individual POST params.\n\nNote in the above request that the content-type is set to application/json as opposed to application/x-www-form-urlencoded. Additionally, if you are constructing the OAuth 1.0a signature, note that the JSON body is not included in the generation of the signature. Most OAuth libraries already account for this. If you are using twurl, ensure you are using at least version 0.9.3.\n• Content-type header must be set to application/json\n• JSON body is not included in the generation of the OAuth signature.\n\nRetrieving past Direct Message is now accomplished with a single API endpoint: GET direct_messages/events/list. The significant difference with this new endpoint is that it now returns both sent and received messages in reverse chronological order. This may make it easier to rebuild a conversation. However, if you are only looking for sent or received messages you will need to post-process the response by referring to the sender_id property.\n\nPagination is now based on a cursor value rather an ID of a Direct Message. A cursor property is returned with each response. GET direct_messages/events/list will return up to 30 days of past messages, regardless of how many messages exist within the past 30 days. When a cursor is not returned, there are no more messages to be returned. The method for accessing individual Direct Messages with GET direct_messages/events/show remains the same, although the Direct Message object returned has a different structure as described previously.\n\nFinally, real-time access to Direct Messages will now be accomplished via webhook with the Account Activity API. For guidance in migrating from User Streams or Site Streams, see the migration guide to Account Activity API for more information.\n• Sent and Received messages are now returned on the same endpoint.\n• Up to 30 days of messages returned.\n\nDirect Messages can now be deleted with DELETE direct_messages/events/destroy. The interface is largely the same requiring the ID of the message to delete. The key differences is the endpoint now requires a DELETE request instead of a POST request.\n\nHow deleted Direct Messages are reflected in official X clients remains the same. Direct Messages are only removed from the interface of the user context provided. Other members of the conversation can still access the Direct Message.\n• How deleted Direct Messages are reflected in official X clients remains unchanged.\n\n**Questions about migrating to the new Direct Message endpoints? **Post your question to the developer community forum on devcommunity.com.\n\nWhat are the advantages of using the Account Activity API?\n\nThe Account Activity API uses webhooks, meaning that unlike for the streaming APIs we don’t require you to have an open connection for us to send you information. Webhooks are also different from Rest APIs because you don’t have to pull us hundreds of times every 15 minutes to get the data you care about. This increases the efficiency between a user and your app, as it delivers data when it happens.\n\nThe Account Activity API has a number of benefits:\n• Speed: we deliver data at the speed of X.\n• Simplicity: we deliver all of an account’s events, through one single webhook connection. The activities delivered in the API include Posts, @mentions, replies, Retweets, Quote Tweets, Retweets of Quote Tweets, favorites, Direct Messages sent, Direct Messages received, follows, blocks, mutes.\n• Scale: you receive all of the activities for an account that you manage without being restricted by any rate limits of event caps.\n\nThe Account Activity API is available as a premium sandbox, premium paid, and enterprise offering, so you can scale as you require more accounts for liability features or additional functionality.\n\nTo get started, download sample code snippets from GitHub.\n\nHow do I identify which product tier is best for me?\n\nPlease read through our Account Activity API Overview page to learn more about the differences between the Premium options and the Enterprise option.\n\nWhat is the difference between a Premium environment and an Enterprise webhook?\n\nThere is no difference. Each Premium environment will have its own webhook_id.\n\nI need a development, staging and production environment for Account Activity API, is this possible?\n\nYes! With the paid tiers of Account Activity API (Paid Premium and Enterprise), it’s possible to register multiple webhook URLs and manage subscriptions separately for each through the API methods. Additionally, multiple client apps may be added to an allowlist to maintain authorization for your current authorized users.\n\nDo you have any step-by-step guides on how to get set up with the Account Activity API?\n\nAs a matter of fact, we do!\n• If you are just getting started, we recommend that you visit our Getting started with webhooks guide\n• Follow along with our X Dev supported scripts:\n• The SnowBot chatbot, a Ruby web app built on the Account Activity and Direct Message APIs. This code base includes a script to help set up Account Activity API webhooks.\n\nIs there a way to recover data if our system goes down for a period of time?\n\nWith the paid tiers of Account Activity API (Paid Premium and Enterprise), our system will retry to send the activities to you several times over a four hour period. If your system does not respond within that four hour period, then the activity will be lost and you will have to use other REST endpoints to recover data within 7 days.\n\nWe suggest that you use your different webhooks, or environments, as a redundancy tool like the Account Activity Replay API to ensure that you don’t miss any activities if one of your systems goes down.\n\nWhat authentication do I have to use with the Account Activity API?\n\nThe authorization methods required for Account Activity API is described per method in the API reference pages. If you are just starting out with X authentication, we recommend that you read through this section.\n\nThe Account Activity API challenge response check is a security feature put in place to ensure that the Account Activity API’s activities are being sent to the proper developer. It also can be used by developers to ensure that the data that they are receiving is coming from X. X will automatically send a CRC to your webhook URL once every 24 hours, starting the last time the webhook URL was validated. Your system must respond with a valid response within 3 seconds to remain validated.\n\nPlease visit our page Securing webhooks for more details.\n\nIs there anything that would immediately invalidate my webhook URL?\n\nIf one of the following occurs, we will immediately mark your webhook as invalid:\n• The server responds to a CRC with an incorrect token. In this case, our system will not retry to send you the activity.\n• The webhook URL has an incorrect certificate configured. In this case, our system will not retry to send you the activity.\n• You specify the use of gzip without actually sending it.\n• You do not specify the use of gzip, but actually send it in the response.\n\nWill I get duplicate activities if subscribed to users that are interacting with each other?\n\nYes. If your web app has active subscriptions for User A and User B, and User A mentions User B in a Post, there will be two POST activities sent to the registered webhook. Each activity will have an indicator of “for_user_id” to show which subscription the activity belongs to.\n\n**When I make a subscription to my webhook, can I replace the portion of the following endpoint with other account activity data objects to limit the activities the API delivers? **\n\nNo, this is not possible. As it currently stands, we only have the product available.\n\n**Is there any way of using the Account Activity API without requesting Direct Messages permissions from users? **\n\nAt this point, Direct Messages permissions are required because there is no way to ‘filter out’ the Direct Messages activities for this API.\n\nIs there a free version of the Account Activity API?\n\nYes, we offer the sandbox version as a free tier. Our sandbox option is limited to a single webhook with a limit of a maximum of 15 subscriptions. You can read more about the sandbox option in our documentation.\n\n**Is it possible to use the Account Activity API to get Retweets of Posts that mention subscribed users? **\n\nUnfortunately, this is not part of the activities delivered with this API. For this, we suggest using the Streaming API instead.\n\nWhat are the possible activity types that are represented by a tweet_create_event?\n\nA tweet_create_event payload will be sent:\n\nIf the subscription user does any of the following actions:\n\n*Note: The Account Activity API only delivers events when the subscription user would receive a notification from X and could see the event publicly. This means, If the mentioned account (@userA) follows the protected account (@userB) then UserA will get a notification UserB mentioned them. If UserA is not following UserB (and approved by UserB) UserA will not get a notification, and therefore a tweet_create_event would not be sent via AAA if @userA had a subscription.\n\nIf a blocked user mentions my subscribed user, how can I identify this?\n\nYou will see a boolean field `user_has_blocked` on the top level of the json response, set to either “true” or “false”. This field will only be exposed on Post mentions.\n\nHow can I add my app to an allowlist or check if my app is already on the allowlist?\n\nTo manage the X apps that you have added to an allowlist for access via the Enterprise APIs, please reach out to your account manager with your app ID. You can find your app ID by navigating to the “Apps” page in the developer portal.\n\nIf I have access to three webhooks, can I use three webhooks for each of the apps that I have registered for enterprise use?\n\nThe webhook limit is set on the account level, not the app level. If you have access to three webhooks and two apps registered for enterprise use, you can use two webhooks on one app and the third on the other app, but not three on each app.\n\nCan I specify which types of events will be redelivered using the Account Activity Replay API?\n\nThe types of events to replay cannot be specified. All events delivered during the date and time window specified will be replayed.\n\nWill there be any retries if my application fails to ingest an Account Activity Replay API event?\n\nNo, there will not be any retries. If an application fails to ingest an event sent by the Account Activity Replay API, another Replay job can be submitted for the same time period to attempt redelivery of any missed Replay events.\n\nWhat should I do when I receive a partial success completion event?\n\nWe suggest making note of the timestamps for the events that were received and requesting another Replay job for the events that were missed.\n\nHow many Account Activity Replay API jobs can I have running at a time?\n\nOnly one Account Activity Replay API job per webhook may be running at a time.\n\nHow can I differentiate Account Activity Replay API events from real-time production events as they are delivered to my webhook?\n\nSince the Account Activity Replay API will always deliver events from the past, events can be differentiated from real-time production events based on the event’s timestamp.\n\nHow soon can I start using the Account Activity Replay API to redeliver an activity my application dropped or missed?\n\nAn activity becomes available for redelivery about 10 minutes after it was created.\n\nThis error generally means that something is either malformed in the request, headers, authorization, or url that you are specifying. This is not an Account Activity API error, it’s an authorization error and X isn’t getting the proper Oauth setup or url.\n• Enterprise - Make sure the consumer keys and access tokens you are using belong to a X app that has been registered for use of Enterprise products. If you don’t have your consumer keys and access tokens, or need to add your X app to the allowlist, please reach out to your account manager.\n• If authenticating with user context, make sure you have properly authorized your request with the proper , , and .\n• Make sure that your access tokens have the proper permission level.\n• When on the ‘Keys and tokens’ tab in the app dashboard, please make sure that your access tokens have the ‘Read, write, and direct messages’ permission level.\n• If the tokens’ permission level is set to anything less than this, please navigate to the ‘Permissions’ tab, adjust the access permission to ‘Read, write, and direct messages’, then regenerate your access tokens and secret from the ‘Keys and tokens’ tab.\n• Make sure that your URL is formed properly.\n• Please keep in mind that is case sensitive.\n• Premium - Make sure that you have an approved developer account before you try to make a request to the API. You also must use the proper :env_name in the request, which you can setup on the dev environments page.\n• Enterprise - Make sure that your account manager has set you up with access to the Account Activity API.\n• Make sure you have set up your URI properly. This error can trigger if you have entered the incorrect URI in your request.\n\nCode 214 - Webhook URL does not meet the requirements.\n• Please make sure that you are using https.\n• Your webhook URL could be malformed.\n• Learn more about how to set up your webhook URL under the Develop webhook consumer app section on Getting started with webhooks page.\n\nCode 214 - High latency on CRC GET request. Your webhook should respond in less than 3 seconds.\n• This means that your server is slow. Make sure that you are responding to the CRC within 3 seconds.\n\nCode 214 - Non-200 response code during CRC GET request (i.e. 404, 500, etc).\n• Your server is down. Make sure that your server is running properly.\n\nCode 214 - Too many resources already created.\n• Enterprise - You have already used all of your webhooks. Use the GET webhooks endpoint with each of your registered apps to identify where your webhooks are distributed.\n• The app that you are using with the API does not have the proper permission level set for its access token and access token secret. Please navigate to the ‘Keys and tokens’ tab on the X apps dashboard and check the permission levels assigned to your access token and access token secret. If it is set to anything other than ‘Read, write and Direct Messages,’ then you are going to have to adjust the settings under the ‘Permission’ tab and regenerate your access token and access token secret to apply the new settings.\n• Alternatively, you are trying to register a webhook using app-only authentication, which is not supported. Please authenticate with user context instead as noted in the API reference sections for registering a webhook for Enterprise Account Activity API.\n\nRegisters a new webhook URL for the given application context. The URL will be validated via CRC request before saving. In case the validation failed, returns comprehensive error message to the requester.\n\nThe number of allowed webhooks is determined by billing package.\n\nReturns all URLs and their statuses for the given application.\n\nWe mark a URL as invalid if it fails the daily validation check. In order to re-enable the URL, call the update endpoint.\n\nTriggers the challenge response check (CRC) for the given webhook’s URL. If the check is successful, returns 204 and reenables the webhook by setting its status to .\n\nSubscribes the provided application to all events for the provided user context for all message types. After activation, all events for the requesting user will be sent to the application’s webhook via POST request.\n\nSubscriptions are currently limited based on your account configuration. If you have a need to add more subscriptions, please contact your account manager.\n\nReturns the count of subscriptions that are currently active on your account. Note that the /count endpoint requires application-only OAuth, so that you should make requests using a bearer token instead of user context.\n\nProvides a way to determine if a webhook configuration is subscribed to the provided user’s events. If the provided user context has an active subscription with provided application, returns 204 OK. If the response code is not 204, then the user does not have an active subscription. See HTTP Response code and error messages below for details.\n\nReturns a list of the current All Activity type subscriptions for the specified webhook. Note that the /list endpoint requires application-only OAuth, so requests should be made using a bearer token instead of user context.\n\nRemoves the webhook from the provided application’s configuration. The webhook ID can be accessed by making a call to GET /1.1/account_activity/webhooks.\n\nDeactivates subscription(s) for the provided user context and application. After deactivation, all events for the requesting user will no longer be sent to the webhook URL.\n\nDeactivates subscription for the specified webhook and user id. After deactivation, all events for the requesting user will no longer be sent to the webhook URL. Note, that this endpoint requires application-only OAuth, so requests should be made using a bearer token instead of user context.\n\nSubmits a request to retrieve activities from up to the past five days from all subscriptions present during the date and time windows specified in the request. If your webhook has active user subscriptions, you will concurrently receive those events as well. Note: We do perform a CRC before delivering replay events.\n\nThe following responses may be returned by the API. Most error codes are returned with a string including additional details in the body. For non-200 responses, you should resolve the error and try again.\n\nOnce your job successfully completes, Account Activity Replay API will deliver the following job completion event. Once you receive this event, the job has finished running and another can be submitted.\n\nIn the event your job does not complete successfully, we will return the following message encouraging you to retry your Replay job. Once you receive this event, the job has finished running and another can be submitted."
    },
    {
        "link": "https://apidog.com/blog/what-is-twitter-api-2024-guide",
        "document": "Are you a web developer who interacts a lot with Twitter? Look no further - enhance your Twitter experience by utilizing Twitter's API!\n\nTwitter API (Application Programming Interface) can be thought of as a bridge between the programs you develop and all the data that Twitter has to offer!\n\nTwitter APIs allow you to read and write information on the platform without having to manually interact with Twitter's website or application\n• Track real-time trends and conversations through posts (better known as tweets).\n• Post tweets and updates on behalf of a user or application.\n• Automate tasks: With Twitter API, you can schedule tweets, track mentions, and respond automatically to other users' replies\n• Enhance your applications: Integrate Twitter features into your projects, such as user tweets and statistics.\n• Reach a wider audience: Share your content and connect with more users. Convert the data obtainable from Twitter into something unique - present it in a way that attracts an audience.\n\nBefore committing to use Twitter API, ask yourself these questions:\n• What kind of data do you want to obtain from Twitter API? (Are they tweets, profiles, or hot trends?)\n• What actions would you like to perform with Twitter API? (You can post tweets, observe tweet likes, and record retweet count)\n• What is the scale of my project? (If you need better services and higher limits to provide a service using your application)\n\nFirstly, enter the Twitter API website for developers. The URL is .\n\nOn this page, press the button. This should redirect you to Twitter and prompt you to log in to a Twitter account. If you have not, do so.\n\nThen, select the link to start using Twitter API for free. The image is a zoom-out of the entire page. When you initially reach this webpage, you may need to scroll down to see the mentioned link.\n\nNext, fill in the Developer Agreement and Policy form to gain access to Twitter API. It seems that anything can be inserted, but it is always better to be honest with your intentions of using Twitter API. You do not want to get involved with legality problems.\n\nOnce you have submitted the Developer Agreement and Policy, you will be redirected to the Twitter API Developer Dashboard! This is where you can start exploring what the Twitter API has to offer.\n\nTwitter API immediately sets up an app the moment you sign up and enter their Developer Dashboard webpage.\n\nYou can view this by pressing the \"Projects and Apps\" section, which will produce a drop-down menu. Select the choice that is found below the Default project section (followed by a series of random numbers).\n\nOn this section of the app page, you can:\n• Personalize the name of your app. (The name of the project in this article is )\n• Find the authentication documentation, that also includes the authentication methods and v2 endpoints available with OAuth 2.0.\n\nThe section displays important components of your Twitter API app. This includes:\n\nAPI Key and Secret: Also known as the Consumer Key and Secret, The API Key and Secret are the most fundamental credentials needed for accessing the Twitter API. They can be thought of as the username and password for your Twitter App, and are used by Twitter API to understand the location whose Twitter App is requesting something.\n\nYou must keep your API Key and Secret like a password. It is not to be shared with anyone at any time.\n\nBearer Token: Twitter API's bearer token permits developers to have a secure point of entry for using the Twitter API.\n\nOn a more technical side, a Bearer Token is a byte array of an unspecified format, generated using a script.\n\nTo read more about how to use the Bearer Token, take a look at the OAuth 2.0 Bearer Token documentation.\n\nAccess Token and Secret: Access Token and Secret are needed to request on behalf of your account. It is made possible with the 3-legged OAuth flow.\n\nThe 3-legged OAuth flow is occasionally referred to as \"Sign-in With Twitter\". To function, it has three parties involved, which are:\n\nTo find out more about Access Tokens, make sure to head to the OAuth 1.0a article regarding the topic.\n\nOn the page, you can access many official documentation regarding Twitter API. The documentation originates from the developers of Twitter API themselves, so you can trust its legitimacy.\n\nThere is documentation for the following topics:\n\n\n\nFind out what other web developers have created with the help of Twitter API!\n\nOnce you click on the , you will be redirected to a GitHub website.\n\nBeware that the programming language may differ from each application you find. The most common languages that you may see are:\n\nApidog: The Best Way to Use and Test Twitter API\n\nApidog is an intuitive and easy-to-learn API platform with a design-first emphasis. With Apidog, you can design, debug, test, and create documents for your API - they have the entire API lifecycle process covered for developers!\n\nIf you are planning to use Twitter API, Apidog is an excellent choice for you to start creating your application - not to mention that it is free to use.\n\nFirstly, we can download the Twitter API collection from GitHub through the link that is provided. The Twitter API downloadable from this link is in the form of a Postman Collection, however, Apidog can accommodate Postman-type files, supporting Postman imports!\n\nThis guide will show how to import the Twitter API v2 to Apidog.\n\nFirstly, open the GitHub link so that you can download the Twitter API Postman Collection.\n\nUnzip the file and open the Apidog application. On the left vertical toolbar, select and press \"Import Data\" under the Data Management section. Here, you can select the various file types to import to Apidog. Select and click the area below to import Twitter API.\n\nYou will be prompted to select which elements to import. Here, you can proceed by pressing .\n\nAs the Twitter API consists of other functionalities, you can choose which ones to include during the import stage. If it does not bother you, it is suggested to import all, and immediately continue - so press .\n\nAnd the import is complete! Now, you can view the Twitter API through Apidog!\n\nTo understand how to utilize the Twitter API, you have to have an idea of the response structure provided in each scenario.\n\nThe image above displays the GET method. As you can see, there are many different responses you can receive, such as and to name a few.\n\nApidog provides a service called API Hub, which collects a large number of third-party API projects. With Apidog, you can even easily access and use Twitter API online using the following link.\n\nAs the picture above shows, you can freely switch between all the endpoints that Twitter API provides, and click \"Try it out\" to use and test it. If you want any of endpoints to be included in your own project, you can generate client codes in many languages (JavaScript, Java, Go, Python, etc.) here.\n\nYou can even click \"Run in Apidog\" to open Twitter API project with Apidog desktop version to freely customize your Twitter API request.\n\nTwitter API is an excellent tool to learn if you are planning to process data that Twitter possesses. It is useful to developers who are trying to leverage topics and trends online for their online businesses. Furthermore, Twitter API has a free version for you to try out first - and if you feel that you need higher limits for requests, then feel free to pay for their subscription.\n\nApidog is also a free-to-use API platform that supports importing and viewing the Twitter API. If developers are required to test the Twitter API, Apidog also has testing features for you!"
    },
    {
        "link": "https://developer.x.com/en/docs/x-api/early-access",
        "document": "We’re building a new Twitter API with a modern and more sustainable foundation as well as an improved developer experience. The first endpoints are now available within Early Access, and enable you to listen to and analyze the public conversation. Additional endpoints, features, and access levels will be released soon!\n\nThe functionality available within Twitter API v2 is in development and serves adequate access for the majority of developers on the platform. While elevated levels of access are coming soon, developers in need of higher levels of access can explore our the standard v1.1, premium v1.1, and enterprise APIs.\n\nFor more detail about our plans for the new Twitter API, visit our “Guide to the future”."
    },
    {
        "link": "https://stackoverflow.com/questions/59481478/use-twitter-api-from-one-account-to-tweet-from-another-account",
        "document": "Yes, you'd simply have to authenticate as account Y using OAuth 1.0a.\n\n See https://developer.twitter.com/en/docs/basics/authentication/overview and https://developer.twitter.com/en/docs/basics/authentication/oauth-1-0a for more information.\n\nIf you're using Tweepy, see https://tweepy.readthedocs.io/en/latest/auth_tutorial.html."
    },
    {
        "link": "https://auth0.com/learn/social-login",
        "document": "Auth0 supports 30+ social providers: Facebook, Twitter, Google, Yahoo, Windows Live, LinkedIn, GitHub, PayPal, Amazon, vKontakte, Yandex, 37signals, Box, Salesforce, Salesforce (sandbox), Salesforce Community, Fitbit, Baidu, RenRen, Weibo, AOL, Shopify, WordPress, Dwolla, miiCard, Yammer, SoundCloud, Instagram, The City, The City (sandbox), Planning Center, Evernote, Evernote (sandbox), and Exact. Additionally, you can add any OAuth2 Authorization Server you need.\n\nEvery provider has its own profile properties, required headers, and response format, and some use OAuth1 (Twitter) while others use OAuth2. Auth0 simplifies this for you, encapsulating the differences, and unifying the way to call providers and the information retrieved from all of them.\n\nHow about including Social Login in your application for free? Try our new free production-ready plan, which includes support for two social network providers of your choice. For more information, check our pricing page."
    },
    {
        "link": "https://sparkminds.net/social-login-integration-with-google-twitter-and-github-account",
        "document": "As we know, social login serves as a common feature in modern apps and websites. Check out our article to understand the steps to implement social login integration into an app or website. But first, let’s move on to the definition and working principle before we get started.\n\nSocial login is a process that allows users to use an existing account from any creatable social media platform (such as Facebook, Google, Twitter, etc.) to log into another application or website without registering for a new one. And it’s convenient and fast for users to log in with ease. On top of that, it helps the applications and websites easily collect basic information about the users.\n\nThe Social Login process is performed through OAuth — a protocol for access authorization. The app will require the user’s social account to access some information. After the user agrees, the social media platform will provide a token to the application that enables access to permitted information.\n\nTo accomplish social login integration, firstly, we have to create account and configure on social platforms that we want to use for login on our app or website, in this article that are Google, Twitter, and Github. Then, we will set up a third party for login verification, such as Firebase.\n\nThe chart illustrates a social login workflow for a web application. Here’s a step-by-step explanation:\n\n1. Login – The user begins to sign up for an account on a random social media platform. ● If the login attempt fails:\n\nThe user is directed back to the localhost:3000/login page to try logging in again.\n\n● If the login attempt is successful:\n\nThe system redirects to localhost:3000 and goes to Decision: Check login. 2. Decision: Check Login Status – The system checks whether the user is already logged in. ● If the user is logged in:\n\nIt proceeds to display a logged-in screen tailored to the specific social media platform the user is accessing.\n\nThis leads to a success endpoint.\n\n● If the user is not logged in:\n\nThe system navigates to the login page at localhost:3000/login. We made a diagram as shown below to describe how social login works\n\nFinally, after reading this article, I hope you can implement social login integration by yourself. They are very easy steps to follow. If want to develop a web or applicaton that relating to social login you can learn more about our Custom Web/App Implementation Service and contact us to get the quotation."
    },
    {
        "link": "https://stackoverflow.com/questions/23303465/best-practice-login-with-facebook-twitter-google-or-register",
        "document": "I've managed to program a login with Facebook system in my PHP webapplication. But now I'm a bit stuck in best practices.\n\nDo I have to save the user's userID to my Database, the user's e-mail-address and/or name and surname? I'm asking this because I'm thinking about users changing their e-mailaddress, who aren't being able to login the next time if so.\n\nAnd how can I know that when a user logs in with Facebook, and the next time with Twitter for example, that it's the same user? Probably based on he's e-mail address? But I think if you haven't changed it your standard Facebook e-mail is [email protected], right?\n\nI'm not asking for code here, please provide me some experiences or best practices."
    },
    {
        "link": "https://bettermode.com/blog/social-login",
        "document": "Imagine you're trying to join a cool new website, but you have to fill out a long form with lots of information. Boring, right? Well, what if you could join with just one click using your favorite social media account? That's what social login is all about! It's like having a magic key that opens many doors with one simple touch.In this blog post, we're going to explore the awesome world of social login and how it's changing the way we join and use websites and apps. So, buckle up and get ready for an exciting journey into the future of logging in!\n\nThe Friendly Doorman of the Internet\n\nThink of social login as a super friendly doorman who knows you from your favorite hangout spot. Instead of asking for your ID every time you want to enter a new place, this doorman just needs to see that you're coming from that familiar spot, and voila! You're in!\n\nIn more grown-up terms:Social login is a cool way for people to use their existing social media accounts (like Facebook, Twitter, or Google) to sign up for or log into other websites or apps. It's fast, easy, and means you don't have to remember a bunch of different passwords.\n\nLet's break it down into simple steps:\n• You Click the Magic Button: You see a \"Login with Facebook\" (or another social network) button on a website.\n• The Website Asks Permission: The website sends a message to Facebook saying, \"Hey, can this person come in?\"\n• Facebook Checks Your ID: Facebook looks at your account and says, \"Yep, we know this person!\"\n• Facebook Shares (Some) Info: With your okay, Facebook tells the website, \"This person is cool. Here's their name and email.\"\n• You're In!: The website says, \"Welcome!\" and lets you in without having to fill out any long forms.\n\nIt's like your social media account is giving you a special backstage pass to other websites!\n\nFor Users (That's You!)\n• Super Fast Sign-Up: No more filling out long, boring forms. Just one click, and you're in!\n• Less Password Stress: Forget about creating and remembering new passwords for every site.\n• Instant Personalization: Websites can use your social info to make your experience more fun and personal right away.\n• More People Join: When it's easier to sign up, more people do it!\n• Happier Users: People like things that are quick and easy, so they're more likely to come back.\n• Better Info: Websites get more accurate information about their users.\n\nThe Big Players in the Game\n• Facebook: The social network giant that everyone knows.\n• Google: Not just for searching anymore!\n• Twitter: For those who love short and sweet messages.\n\nEach of these options has its own superpowers. For example, logging in with LinkedIn might be perfect for a job-hunting website, while Facebook could be great for a game or social app.\n\nHow to Add Social Login to Your Website\n\nIf you're a website owner or just really interested in how things work, here's a simple guide to adding social login:\n• Choose Your Social Networks: Decide which social logins you want to offer.\n• Get Developer Accounts: Sign up for developer accounts on those social networks.\n• Follow the Instructions: Each social network has a guide on how to set up social login.\n• Add the Buttons: Put the social login buttons on your website's sign-up page.\n• Test, Test, Test: Make sure everything works smoothly before inviting everyone in.\n\nRemember, it's always a good idea to ask a grown-up or an expert for help with this kind of stuff!\n\nWhen we use social login, we're sharing some of our information. So, it's super important that websites keep this info safe. Here are some ways they do that:\n• Encryption: This is like putting your info in a secret code that only the right people can understand.\n• Limited Access: Websites should only ask for the information they really need.\n• Clear Rules: There should be easy-to-understand rules about how your info will be used.\n\nAlways remember: It's okay to ask questions about how your information will be used and kept safe!\n\nWhat's Next in the World of Easy Access?\n\nThe world of technology is always changing, and social login is no exception. Here are some cool things we might see in the future:\n• More Options: New social networks might join the social login party.\n• Smarter Systems: Social logins might get even better at knowing it's really you.\n• Voice and Face Recognition: Imagine logging in just by speaking or showing your face!\n• Read the Permissions: Always check what information you're sharing.\n• Use Strong Passwords: Keep your social media accounts super secure.\n• Don't Over-Share: Only connect with sites you really trust.\n• Regular Check-Ups: Sometimes look at which apps are connected to your social accounts.\n• Spotify's Smooth Moves: Spotify lets you sign up with Facebook, making it easy to find and share music with friends.\n• Pinterest's Picture-Perfect Plan: Pinterest's use of social login helped it grow super fast and connect people with similar interests.\n• Airbnb's Trust Builder: By letting people log in with Facebook, Airbnb helps hosts and guests feel more comfortable with each other.\n\nThese stories show how social login can make websites and apps more fun, friendly, and successful!\n\nEvery Superhero Has Its Kryptonite\n\nEven though social login is awesome, it's not perfect. Here are some challenges and how to deal with them:\n• Challenge: What if someone doesn't have a social media account?\n\nSolution: Always offer a regular sign-up option too.\n• Challenge: Some people worry about privacy when using social login.\n\nSolution: Be very clear about what information you're using and why.\n• Challenge: What if a social network has problems?\n\nSolution: Offer multiple social login options and a backup regular login.\n• ✅ Test your social login regularly to make sure it works\n• ❌ Don't ask for more information than you need\n\nThe Impact of Social Login on User Engagement\n\nSocial login doesn't just make signing up easier; it can also help create a more engaging experience for users. Here's how:\n• Personalized Content: Websites can use social data to show content users are more likely to enjoy.\n• Social Sharing: It's easier for users to share content with their friends when they're connected through social login.\n• Community Building: Users can find and connect with friends who are also using the same website or app.\n\nHow to Know If It's Working\n\nIf you're a website owner or just curious about how well social login is doing, here are some things to look at:\n• Sign-Up Rate: Are more people joining since you added social login?\n• Login Frequency: Are people coming back more often?\n• Completion Rate: Do more people finish signing up when using social login?\n• User Feedback: What are people saying about the login process?\n\nBy keeping an eye on these things, you can tell if social login is helping make the website or app better for everyone.\n\nTaking Easy Access on the Go\n\nIn today's world, we use our phones for almost everything. Social login is super helpful for mobile apps because:\n• It's faster to tap a social login button than to type a long email and password on a tiny keyboard.\n• Many people are already logged into social apps on their phones, making the process even quicker.\n• It can help apps work better with the phone's features, like sharing photos or finding friends nearby.\n\nThe Role of Social Login in Building Trust\n\nWhen a website offers social login, it can help users feel more comfortable and trusting. Here's why:\n• Familiar Faces: Using a known and trusted social network makes the new site feel more friendly.\n• Less Information Sharing: Users don't have to give out as much personal info to a new site.\n• Easy Control: People can manage their connections through their social media accounts.\n\nRemember, trust is super important online, and social login can be a big help in building it!\n\nMaking It Your Own\n\nFor website owners, it's important to make social login fit perfectly with the rest of the site. Here are some cool ways to do that:\n• Clear Instructions: Explain why social login is helpful and how it works.\n• Smart Defaults: Choose the most popular social network for your users as the main option.\n• Smooth Flow: Make sure the process from clicking the button to being logged in feels quick and easy.\n\nAs social login becomes more popular, there are new rules to make sure everyone's information is protected. Some important things to know:\n• GDPR: This is a big set of rules in Europe about protecting people's data.\n• Consent: Websites need to ask permission before using your social data.\n\nIt's a bit complicated, but the main idea is to make sure your information is used fairly and safely!\n\nAs we wrap up our journey through the world of social login, let's remember the key points:\n• Social login makes it super easy to join new websites and apps.\n• It's safe when used correctly and can help build trust online.\n• There are challenges, but also lots of solutions and best practices.\n• The future of social login looks exciting, with new technologies on the horizon.\n\nWhether you're a curious user or someone thinking about adding social login to your website, we hope this guide has been helpful and fun!\n\nRemember, the internet is always changing, and social login is just one way it's becoming easier and more fun to use. Stay curious, stay safe, and enjoy the convenience of your digital \"magic key\"! Ready to enhance your community's login experience? Explore Bettermode's powerful social login features and take your online community to the next level. Get Started Today"
    },
    {
        "link": "https://medium.com/nybles/integrating-social-logins-in-web-apps-c09da30737f0",
        "document": "Now enough of the boring talks, let’s get our hands dirty by coding our very own social login!\n\nFirst, ensure that you have npm and NodeJS installed in your system. You can check that by running and on the terminal.\n\nWe will now initiate our node App and install the dependencies we need, by using the command, and by adding the flag we accept all the default settings. We will set the entry point to be app.js.\n\nWe are using express for handling our requests and response, we are also using the npm package, passport to integrate social logins. You are read the further documentation on the link below.\n\nOn the passport website, we can search for strategies i.e. unique authentication methods for different techniques. Here, we have integrated Google OAuth2.0, you can search any other social media which you want to add to your project. For example, searching Facebook results in the passport-facebook package which can be installed using the npm package manager.\n\nThe next step is to set up a project tree. Feel free to set it up as you feel comfortable, I have given mine to avoid confusion.\n\nWe will be storing all of our HTML documents in the pages folder. And writing all of our server code in the . Now we will be adding boilerplate code to our app.js file.\n\nIn the boilerplate code, we have set up our MongoDB database with mongoose and set up a User Schema, with a String for an email address and password. Next, we have set a get route to the home link and set our port to .\n\nBefore we begin integrating our app with social accounts we need to register our application on the developer console of the social media provider. Luckily most of the social media apps require only minimal information and are free to use social logins. Here I will show how you can do the same for Google OAuth, but the process is the same for most service providers.\n• Log in to the developer console of Google here.\n• Once you have set up your account and accept the terms and conditions you need to create a new app.\n• Once done, set up the consent screen, which the users see when they log in with a Google account. You can add an App image and configure the permissions required.\n• After this go to the credentials tab of your app and click Create credentials, for Google OAuth Client ID. Set up the hosting link for your app (you can put it as localhost:3000 also if you are not yet hosting it). Then you need to set up a redirect link, in this case, I have set it as https://localhost:3000/auth/google/home.\n• Once done you will get a Client Id along with a client secret, keep them safe as they are unique to your app and should not be exploited by other developers. (Safe practices can be implemented with the dotenv npm package)\n\nNow that you have set up your app on the developer console, we just have to add some code to our back-end to integrate social logins. Most of the below steps are just from the documentation, so if you feel confident you can open up the documentation of passport and try doing it by yourself!\n\nNow since we have all the required tools that we needed, it’s time to finish up our project.\n\nFirst, we will set up the passport package and add a GoogleId to the User Schema which stores the unique id that Google OAuth will return once the user is authenticated.\n\nWe have now used the Google Auth2.0 strategy with the passport package, while setting up you will have to replace and with the id and secret given when we set up the app on the Google developer console.\n\nIt's important that the sequence of the code must remain the same, i.e. for example you can’t set up the GoogleStrategy before you make your User Schema, this will result in improper functioning of the code.\n\nIf you look carefully at the above code there is a big error. Inside the GoogleStrategy, within the function, we have used which in actuality is not a real mongoose function! The passport documentation has given this function as a dummy function and expects the developers to implement it on their own. If we look at the below Stack Overflow thread you will find a solution for this problem too.\n\nOne of the difficult methods is to implement the but a much simpler solution is to use the findOrCreate npm package that includes the functionality on its own. We here are implementing the findOrCreate method without using any other npm package.\n\nNow that this is taken care of, we will add the get routes to implement the login function.\n\nThis concludes our backend, now all that’s left is to add buttons and a login form in the index.html file. (I am adding the register page in my index.html) We will be using bootstrap forms and fontawesome icons for styling and adding social icons. The final index.html should look something like this.\n\nAfter you have set up all the files we will start our server by running command. The page should look something like this."
    }
]