[
    {
        "link": "https://docs.python.org/3/tutorial/classes.html",
        "document": "Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state. Class instances can also have methods (defined by its class) for modifying its state.\n\nCompared with other programming languages, Python’s class mechanism adds classes with a minimum of new syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3. Python classes provide all the standard features of Object Oriented Programming: the class inheritance mechanism allows multiple base classes, a derived class can override any methods of its base class or classes, and a method can call the method of a base class with the same name. Objects can contain arbitrary amounts and kinds of data. As is true for modules, classes partake of the dynamic nature of Python: they are created at runtime, and can be modified further after creation.\n\nIn C++ terminology, normally class members (including the data members) are public (except see below Private Variables), and all member functions are virtual. As in Modula-3, there are no shorthands for referencing the object’s members from its methods: the method function is declared with an explicit first argument representing the object, which is provided implicitly by the call. As in Smalltalk, classes themselves are objects. This provides semantics for importing and renaming. Unlike C++ and Modula-3, built-in types can be used as base classes for extension by the user. Also, like in C++, most built-in operators with special syntax (arithmetic operators, subscripting etc.) can be redefined for class instances.\n\nBefore introducing classes, I first have to tell you something about Python’s scope rules. Class definitions play some neat tricks with namespaces, and you need to know how scopes and namespaces work to fully understand what’s going on. Incidentally, knowledge about this subject is useful for any advanced Python programmer. A namespace is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries, but that’s normally not noticeable in any way (except for performance), and it may change in the future. Examples of namespaces are: the set of built-in names (containing functions such as , and built-in exception names); the global names in a module; and the local names in a function invocation. In a sense the set of attributes of an object also form a namespace. The important thing to know about namespaces is that there is absolutely no relation between names in different namespaces; for instance, two different modules may both define a function without confusion — users of the modules must prefix it with the module name. By the way, I use the word attribute for any name following a dot — for example, in the expression , is an attribute of the object . Strictly speaking, references to names in modules are attribute references: in the expression , is a module object and is an attribute of it. In this case there happens to be a straightforward mapping between the module’s attributes and the global names defined in the module: they share the same namespace! Attributes may be read-only or writable. In the latter case, assignment to attributes is possible. Module attributes are writable: you can write . Writable attributes may also be deleted with the statement. For example, will remove the attribute from the object named by . Namespaces are created at different moments and have different lifetimes. The namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted. The global namespace for a module is created when the module definition is read in; normally, module namespaces also last until the interpreter quits. The statements executed by the top-level invocation of the interpreter, either read from a script file or interactively, are considered part of a module called , so they have their own global namespace. (The built-in names actually also live in a module; this is called .) The local namespace for a function is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function. (Actually, forgetting would be a better way to describe what actually happens.) Of course, recursive invocations each have their own local namespace. A scope is a textual region of a Python program where a namespace is directly accessible. “Directly accessible” here means that an unqualified reference to a name attempts to find the name in the namespace. Although scopes are determined statically, they are used dynamically. At any time during execution, there are 3 or 4 nested scopes whose namespaces are directly accessible:\n• None the innermost scope, which is searched first, contains the local names\n• None the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contain non-local, but also non-global names\n• None the next-to-last scope contains the current module’s global names\n• None the outermost scope (searched last) is the namespace containing built-in names If a name is declared global, then all references and assignments go directly to the next-to-last scope containing the module’s global names. To rebind variables found outside of the innermost scope, the statement can be used; if not declared nonlocal, those variables are read-only (an attempt to write to such a variable will simply create a new local variable in the innermost scope, leaving the identically named outer variable unchanged). Usually, the local scope references the local names of the (textually) current function. Outside functions, the local scope references the same namespace as the global scope: the module’s namespace. Class definitions place yet another namespace in the local scope. It is important to realize that scopes are determined textually: the global scope of a function defined in a module is that module’s namespace, no matter from where or by what alias the function is called. On the other hand, the actual search for names is done dynamically, at run time — however, the language definition is evolving towards static name resolution, at “compile” time, so don’t rely on dynamic name resolution! (In fact, local variables are already determined statically.) A special quirk of Python is that – if no or statement is in effect – assignments to names always go into the innermost scope. Assignments do not copy data — they just bind names to objects. The same is true for deletions: the statement removes the binding of from the namespace referenced by the local scope. In fact, all operations that introduce new names use the local scope: in particular, statements and function definitions bind the module or function name in the local scope. The statement can be used to indicate that particular variables live in the global scope and should be rebound there; the statement indicates that particular variables live in an enclosing scope and should be rebound there. This is an example demonstrating how to reference the different scopes and namespaces, and how and affect variable binding: The output of the example code is: After local assignment: test spam After nonlocal assignment: nonlocal spam After global assignment: nonlocal spam In global scope: global spam Note how the local assignment (which is default) didn’t change scope_test's binding of spam. The assignment changed scope_test's binding of spam, and the assignment changed the module-level binding. You can also see that there was no previous binding for spam before the assignment.\n\nA First Look at Classes¶ Classes introduce a little bit of new syntax, three new object types, and some new semantics. The simplest form of class definition looks like this: Class definitions, like function definitions ( statements) must be executed before they have any effect. (You could conceivably place a class definition in a branch of an statement, or inside a function.) In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful — we’ll come back to this later. The function definitions inside a class normally have a peculiar form of argument list, dictated by the calling conventions for methods — again, this is explained later. When a class definition is entered, a new namespace is created, and used as the local scope — thus, all assignments to local variables go into this new namespace. In particular, function definitions bind the name of the new function here. When a class definition is left normally (via the end), a class object is created. This is basically a wrapper around the contents of the namespace created by the class definition; we’ll learn more about class objects in the next section. The original local scope (the one in effect just before the class definition was entered) is reinstated, and the class object is bound here to the class name given in the class definition header ( in the example). Class objects support two kinds of operations: attribute references and instantiation. Attribute references use the standard syntax used for all attribute references in Python: . Valid attribute names are all the names that were in the class’s namespace when the class object was created. So, if the class definition looked like this: then and are valid attribute references, returning an integer and a function object, respectively. Class attributes can also be assigned to, so you can change the value of by assignment. is also a valid attribute, returning the docstring belonging to the class: . Class instantiation uses function notation. Just pretend that the class object is a parameterless function that returns a new instance of the class. For example (assuming the above class): creates a new instance of the class and assigns this object to the local variable . The instantiation operation (“calling” a class object) creates an empty object. Many classes like to create objects with instances customized to a specific initial state. Therefore a class may define a special method named , like this: When a class defines an method, class instantiation automatically invokes for the newly created class instance. So in this example, a new, initialized instance can be obtained by: Of course, the method may have arguments for greater flexibility. In that case, arguments given to the class instantiation operator are passed on to . For example, Now what can we do with instance objects? The only operations understood by instance objects are attribute references. There are two kinds of valid attribute names: data attributes and methods. data attributes correspond to “instance variables” in Smalltalk, and to “data members” in C++. Data attributes need not be declared; like local variables, they spring into existence when they are first assigned to. For example, if is the instance of created above, the following piece of code will print the value , without leaving a trace: The other kind of instance attribute reference is a method. A method is a function that “belongs to” an object. Valid method names of an instance object depend on its class. By definition, all attributes of a class that are function objects define corresponding methods of its instances. So in our example, is a valid method reference, since is a function, but is not, since is not. But is not the same thing as — it is a method object, not a function object. Usually, a method is called right after it is bound: In the example, this will return the string . However, it is not necessary to call a method right away: is a method object, and can be stored away and called at a later time. For example: will continue to print until the end of time. What exactly happens when a method is called? You may have noticed that was called without an argument above, even though the function definition for specified an argument. What happened to the argument? Surely Python raises an exception when a function that requires an argument is called without any — even if the argument isn’t actually used… Actually, you may have guessed the answer: the special thing about methods is that the instance object is passed as the first argument of the function. In our example, the call is exactly equivalent to . In general, calling a method with a list of n arguments is equivalent to calling the corresponding function with an argument list that is created by inserting the method’s instance object before the first argument. In general, methods work as follows. When a non-data attribute of an instance is referenced, the instance’s class is searched. If the name denotes a valid class attribute that is a function object, references to both the instance object and the function object are packed into a method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list. Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class: As discussed in A Word About Names and Objects, shared data can have possibly surprising effects with involving mutable objects such as lists and dictionaries. For example, the tricks list in the following code should not be used as a class variable because just a single list would be shared by all Dog instances: Correct design of the class should use an instance variable instead: # creates a new empty list for each dog\n\nIf the same attribute name occurs in both an instance and in a class, then attribute lookup prioritizes the instance: Data attributes may be referenced by methods as well as by ordinary users (“clients”) of an object. In other words, classes are not usable to implement pure abstract data types. In fact, nothing in Python makes it possible to enforce data hiding — it is all based upon convention. (On the other hand, the Python implementation, written in C, can completely hide implementation details and control access to an object if necessary; this can be used by extensions to Python written in C.) Clients should use data attributes with care — clients may mess up invariants maintained by the methods by stamping on their data attributes. Note that clients may add data attributes of their own to an instance object without affecting the validity of the methods, as long as name conflicts are avoided — again, a naming convention can save a lot of headaches here. There is no shorthand for referencing data attributes (or other methods!) from within methods. I find that this actually increases the readability of methods: there is no chance of confusing local variables and instance variables when glancing through a method. Often, the first argument of a method is called . This is nothing more than a convention: the name has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention. Any function object that is a class attribute defines a method for instances of that class. It is not necessary that the function definition is textually enclosed in the class definition: assigning a function object to a local variable in the class is also ok. For example: Now , and are all attributes of class that refer to function objects, and consequently they are all methods of instances of — being exactly equivalent to . Note that this practice usually only serves to confuse the reader of a program. Methods may call other methods by using method attributes of the argument: Methods may reference global names in the same way as ordinary functions. The global scope associated with a method is the module containing its definition. (A class is never used as a global scope.) While one rarely encounters a good reason for using global data in a method, there are many legitimate uses of the global scope: for one thing, functions and modules imported into the global scope can be used by methods, as well as functions and classes defined in it. Usually, the class containing the method is itself defined in this global scope, and in the next section we’ll find some good reasons why a method would want to reference its own class. Each value is an object, and therefore has a class (also called its type). It is stored as .\n\nOf course, a language feature would not be worthy of the name “class” without supporting inheritance. The syntax for a derived class definition looks like this: The name must be defined in a namespace accessible from the scope containing the derived class definition. In place of a base class name, other arbitrary expressions are also allowed. This can be useful, for example, when the base class is defined in another module: Execution of a derived class definition proceeds the same as for a base class. When the class object is constructed, the base class is remembered. This is used for resolving attribute references: if a requested attribute is not found in the class, the search proceeds to look in the base class. This rule is applied recursively if the base class itself is derived from some other class. There’s nothing special about instantiation of derived classes: creates a new instance of the class. Method references are resolved as follows: the corresponding class attribute is searched, descending down the chain of base classes if necessary, and the method reference is valid if this yields a function object. Derived classes may override methods of their base classes. Because methods have no special privileges when calling other methods of the same object, a method of a base class that calls another method defined in the same base class may end up calling a method of a derived class that overrides it. (For C++ programmers: all methods in Python are effectively .) An overriding method in a derived class may in fact want to extend rather than simply replace the base class method of the same name. There is a simple way to call the base class method directly: just call . This is occasionally useful to clients as well. (Note that this only works if the base class is accessible as in the global scope.) Python has two built-in functions that work with inheritance:\n• None Use to check an instance’s type: will be only if is or some class derived from .\n• None Use to check class inheritance: is since is a subclass of . However, is since is not a subclass of . Python supports a form of multiple inheritance as well. A class definition with multiple base classes looks like this: For most purposes, in the simplest cases, you can think of the search for attributes inherited from a parent class as depth-first, left-to-right, not searching twice in the same class where there is an overlap in the hierarchy. Thus, if an attribute is not found in , it is searched for in , then (recursively) in the base classes of , and if it was not found there, it was searched for in , and so on. In fact, it is slightly more complex than that; the method resolution order changes dynamically to support cooperative calls to . This approach is known in some other multiple-inheritance languages as call-next-method and is more powerful than the super call found in single-inheritance languages. Dynamic ordering is necessary because all cases of multiple inheritance exhibit one or more diamond relationships (where at least one of the parent classes can be accessed through multiple paths from the bottommost class). For example, all classes inherit from , so any case of multiple inheritance provides more than one path to reach . To keep the base classes from being accessed more than once, the dynamic algorithm linearizes the search order in a way that preserves the left-to-right ordering specified in each class, that calls each parent only once, and that is monotonic (meaning that a class can be subclassed without affecting the precedence order of its parents). Taken together, these properties make it possible to design reliable and extensible classes with multiple inheritance. For more detail, see The Python 2.3 Method Resolution Order.\n\n“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. ) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice. Since there is a valid use-case for class-private members (namely to avoid name clashes of names with names defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier of the form (at least two leading underscores, at most one trailing underscore) is textually replaced with , where is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, as long as it occurs within the definition of a class. The private name mangling specifications for details and special cases. Name mangling is helpful for letting subclasses override methods without breaking intraclass method calls. For example: # provides new signature for update() # but does not break __init__() The above example would work even if were to introduce a identifier since it is replaced with in the class and in the class respectively. Note that the mangling rules are designed mostly to avoid accidents; it still is possible to access or modify a variable that is considered private. This can even be useful in special circumstances, such as in the debugger. Notice that code passed to or does not consider the classname of the invoking class to be the current class; this is similar to the effect of the statement, the effect of which is likewise restricted to code that is byte-compiled together. The same restriction applies to , and , as well as when referencing directly."
    },
    {
        "link": "https://dev.to/ogwurujohnson/creating-and-instantiating-a-simple-class-in-python-79b",
        "document": "Last month i started taking a course on python and i stumbled on a tutorial on object oriented programming from the python perspective, and through out this week and coming weeks i would be sharing what i have been able to learn.\n\nToday we would be looking at class creation and instantiation. To help us understand this better we would be creating an employee class, each employee would have attributes like name,email,pay,etc. Now lets have a head first attempt at creating and instantiating a class.\n\nThe above code snippet shows how to create a class in python, the pass keyword under tells python to neglect the class, without this keyword, python would see the class as an empty one and return an error. A class is a blue print for creating instances and each unique employee that we create would be an instance of that class.\n\nThey above code shows the creation of unique instances of the Employee class and to assign data to this instances we would be using instance variables. Instance variables contain data that is unique to the instance alone. To create instance variables for each employee we would do the following:\n\nImagine a situation we have 1000 employees to create, trying to set the variables each time we want to create an employee would mean having a-lot of code and errors. But python allows you to be able to create instances automatically and this we could do using its (init) method.\n\nthe init method after creation receives an instance automatically called (self), and we also pass in other attributes of the Employee class like name and pay. Next stop we would be looking at setting the instance.\n\n\n\n with that done, when we create our employee, the instance would be passed in automatically, all we would bother ourselves with would be to provide the employee attributes.\n\n \n\n on running this script (emp_1) would be passed into the (init) method as self.\n\n Now suppose we want to print each users fullname, we could actually use the format function in python to concatenate strings to get the fullname, but this would require doing this every time we want to print an employees fullname, but to better enjoy the advantage of code re-use, we would be creating a method to help us generate each employees fullname.\n\n\n\nThat is it for class and instance of a class creation. Below is the full source code for the piece. \n\n\n\n(Note)\n\n while trying to print employees fullname, you could either do this--> (emp_1.fullname()) or you could try (Employee.fullname(emp_1)), they both mean the-same thing, in-fact the later is what happens in the background when you run the program.\n\nTomorrow we would be looking at the difference between instance variables and class variables, the difference between regular,static and instance methods"
    },
    {
        "link": "https://realpython.com/python-class-constructor",
        "document": "Creating a class constructor in Python involves understanding the instantiation process, which consists of two steps: instance creation and instance initialization. You start this process by calling the class like a function, which triggers the method to create an instance and the method to initialize it. Mastering these methods allows you to customize how Python constructs and initializes objects of your classes.\n\nBy the end of this tutorial, you’ll understand that:\n• A class constructor in Python triggers the instantiation process, creating and initializing objects.\n• Python handles instantiation internally with for creation and for initialization.\n• You can customize object initialization by overriding the method in your class.\n• The difference between and is that creates the instance, while initializes it.\n• Common use cases for overriding include subclassing immutable types or implementing singletons.\n\nTo better understand the examples and concepts in this tutorial, you should be familiar with object-oriented programming and special methods in Python.\n\nLike many other programming languages, Python supports object-oriented programming. At the heart of Python’s object-oriented capabilities, you’ll find the keyword, which allows you to define custom classes that can have attributes for storing data and methods for providing behaviors. Once you have a class to work with, then you can start creating new instances or objects of that class, which is an efficient way to reuse functionality in your code. Creating and initializing objects of a given class is a fundamental step in object-oriented programming. This step is often referred to as object construction or instantiation. The tool responsible for running this instantiation process is commonly known as a class constructor. Getting to Know Python’s Class Constructors In Python, to construct an object of a given class, you just need to call the class with appropriate arguments, as you would call any function: # Call the class to construct an object In this example, you define using the keyword. This class is currently empty because it doesn’t have attributes or methods. Instead, the class’s body only contains a statement as a placeholder statement that does nothing. Then you create a new instance of by calling the class with a pair of parentheses. In this example, you don’t need to pass any argument in the call because your class doesn’t take arguments yet. In Python, when you call a class as you did in the above example, you’re calling the class constructor, which creates, initializes, and returns a new object by triggering Python’s internal instantiation process. A final point to note is that calling a class isn’t the same as calling an instance of a class. These are two different and unrelated topics. To make a class’s instance callable, you need to implement a special method, which has nothing to do with Python’s instantiation process. You trigger Python’s instantiation process whenever you call a Python class to create a new instance. This process runs through two separate steps, which you can describe as follows:\n• Create a new instance of the target class\n• Initialize the new instance with an appropriate initial state To run the first step, Python classes have a special method called , which is responsible for creating and returning a new empty object. Then another special method, , takes the resulting object, along with the class constructor’s arguments. The method takes the new object as its first argument, . Then it sets any required instance attribute to a valid state using the arguments that the class constructor passed to it. In short, Python’s instantiation process starts with a call to the class constructor, which triggers the instance creator, , to create a new empty object. The process continues with the instance initializer, , which takes the constructor’s arguments to initialize the newly created object. To explore how Python’s instantiation process works internally, consider the following example of a class that implements a custom version of both methods, and , for demonstration purposes: \"2. Initialize the new instance of Point.\" Here’s a breakdown of what this code does:\n• Line 1 defines the class using the keyword followed by the class name.\n• Line 2 defines the method, which takes the class as its first argument. Note that using as the name of this argument is a strong convention in Python, just like using to name the current instance is. The method also takes and , which allow for passing an undefined number of initialization arguments to the underlying instance.\n• Line 4 creates a new instance by calling the parent class’s method with as an argument. In this example, is the parent class, and the call to gives you access to it. Then the instance is returned. This instance will be the first argument to .\n• Line 6 defines , which is responsible for the initialization step. This method takes a first argument called , which holds a reference to the current instance. The method also takes two additional arguments, and . These arguments hold initial values for the instance attributes and . You need to pass suitable values for these arguments in the call to , as you’ll learn in a moment.\n• Lines 8 and 9 initialize and , respectively. To do this, they use the provided input arguments and .\n• Lines 11 and 12 implement the special method, which provides a proper string representation for your class. With in place, you can uncover how the instantiation process works in practice. Save your code to a file called and start your Python interpreter in a command-line window. Then run the following code: 2. Initialize the new instance of Point. Calling the class constructor creates, initializes, and returns a new instance of the class. This instance is then assigned to the variable. In this example, the call to the constructor also lets you know the steps that Python internally runs to construct the instance. First, Python calls and then , resulting in a new and fully initialized instance of , as you confirmed at the end of the example. To continue learning about class instantiation in Python, you can try running both steps manually: # The point object is not initialized : : 2. Initialize the new instance of Point. In this example, you first call on your class, passing the class itself as the first argument to the method. This call only runs the first step of the instantiation process, creating a new and empty object. Note that creating an instance this way bypasses the call to . Note: The code snippet above is intended to be a demonstrative example of how the instantiation process works internally. It’s not something that you would typically do in real code. Once you have the new object, then you can initialize it by calling with an appropriate set of arguments. After this call, your object is properly initialized, with all its attributes set up. A subtle and important detail to note about is that it can also return an instance of a class different from the class that implements the method itself. When that happens, Python doesn’t call in the current class, because there’s no way to unambiguously know how to initialize an object of a different class. Consider the following example, in which the method of the class returns an instance of the class: \"Initialize the new instance of A.\" \"Initialize the new instance of B.\" Because returns an instance of a different class, Python doesn’t run . To confirm this behavior, save the code into a file called and then run the following code in an interactive Python session: Initialize the new instance of A. : The call to the class constructor runs , which returns an instance of instead of . That’s why never runs. Note that doesn’t have a attribute. In contrast, does have an attribute with a value of . Now that you know the steps that Python internally takes to create instances of a given class, you’re ready to dig a little deeper into other characteristics of , , and the steps that they run.\n\nIn Python, the method is probably the most common special method that you’ll ever override in your custom classes. Almost all your classes will need a custom implementation of . Overriding this method will allow you to initialize your objects properly. The purpose of this initialization step is to leave your new objects in a valid state so that you can start using them right away in your code. In this section, you’ll learn the basics of writing your own methods and how they can help you customize your classes. The most bare-bones implementation of that you can write will just take care of assigning input arguments to matching instance attributes. For example, say you’re writing a class that requires and attributes. In that case, you can do something like this: As you learned before, runs the second step of the object instantiation process in Python. Its first argument, , holds the new instance that results from calling . The rest of the arguments to are normally used to initialize instance attributes. In the above example, you initialized the rectangle’s and using the and arguments to . It’s important to note that, without counting , the arguments to are the same ones that you passed in the call to the class constructor. So, in a way, the signature defines the signature of the class constructor. Additionally, keep in mind that must not explicitly return anything different from , or you’ll get a exception: : __init__() should return None, not 'int' In this example, the method attempts to return an integer number, which ends up raising a exception at run time. The error message in the above example says that should return . However, you don’t need to return explicitly, because methods and functions without an explicit statement just return implicitly in Python. With the above implementation of , you ensure that and get initialized to a valid state when you call the class constructor with appropriate arguments. That way, your rectangles will be ready for use right after the construction process finishes. In , you can also run any transformation over the input arguments to properly initialize the instance attributes. For example, if your users will use directly, then you might want to validate the supplied and and make sure that they’re correct before initializing the corresponding attributes: In this updated implementation of , you make sure that the input and arguments are positive numbers before initializing the corresponding and attributes. If either validation fails, then you get a . Note: A more Pythonic technique to tackle attribute validation is to turn attributes into properties. To learn more about properties, check out Python’s property(): Add Managed Attributes to Your Classes. Now say that you’re using inheritance to create a custom class hierarchy and reuse some functionality in your code. If your subclasses provide a method, then this method must explicitly call the base class’s method with appropriate arguments to ensure the correct initialization of instances. To do this, you should use the built-in function like in the following example: The first line in the method of calls with and as arguments. This call ensures the initialization of and in the parent class, . This technique allows you to extend the base class with new attributes and functionality. To wrap up this section, you should know that the base implementation of comes from the built-in class. This implementation is automatically called when you don’t provide an explicit method in your classes. You can make your objects’ initialization step flexible and versatile by tweaking the method. To this end, one of the most popular techniques is to use optional arguments. This technique allows you to write classes in which the constructor accepts different sets of input arguments at instantiation time. Which arguments to use at a given time will depend on your specific needs and context. As a quick example, check out the following class: In this example, takes a regular argument called . It also takes an optional argument called , which defaults to . Because has a default value, you can construct objects by relying on this value or by providing your own. The class’s final behavior will depend on the value of . If this argument is , then you’ll get an informal greeting when you call . Otherwise, you’ll get a more formal greeting. To try out, go ahead and save the code into a file. Then open an interactive session in your working directory and run the following code: In the first example, you create an object by passing a value to the argument and relying on the default value of . You get an informal greeting on your screen when you call on the object. In the second example, you use a and a argument to instantiate . Because is , the result of calling is a formal greeting. Even though this is a toy example, it showcases how default argument values are a powerful Python feature that you can use to write flexible initializers for your classes. These initializers will allow you to instantiate your classes using different sets of arguments depending on your needs. Okay! Now that you know the basics of and the object initialization step, it’s time to change gears and start diving deeper into and the object creation step.\n\nWhen writing Python classes, you typically don’t need to provide your own implementation of the special method. Most of the time, the base implementation from the built-in class is sufficient to build an empty object of your current class. However, there are a few interesting use cases for this method. For example, you can use to create subclasses of immutable types, such as , , , and . In the following sections, you’ll learn how to write custom implementations of in your classes. To do this, you’ll code a few examples that’ll give you an idea of when you might need to override this method. Typically, you’ll write a custom implementation of only when you need to control the creation of a new instance at a low level. Now, if you need a custom implementation of this method, then you should follow a few steps:\n• Create a new instance by calling with appropriate arguments.\n• Customize the new instance according to your specific needs.\n• Return the new instance to continue the instantiation process. With these three succinct steps, you’ll be able to customize the instance creation step in the Python instantiation process. Here’s an example of how you can translate these steps into Python code: This example provides a sort of template implementation of . As usual, takes the current class as an argument that’s typically called . Note that you’re using and to make the method more flexible and maintainable by accepting any number of arguments. You should always define with and , unless you have a good reason to follow a different pattern. In the first line of , you call the parent class’s method to create a new instance and allocate memory for it. To access the parent class’s method, you use the function. This chain of calls takes you up to , which is the base implementation of for all Python classes. Note: The built-in class is the default base class of all Python classes. The next step is to customize your newly created instance. You can do whatever you need to do to customize the instance at hand. Finally, in the third step, you need to return the new instance to continue the instantiation process with the initialization step. It’s important to note that itself only accepts a single argument, the class to instantiate. If you call with more arguments, then you get a : : object.__new__() takes exactly one argument (the type to instantiate) In this example, you hand over and as additional arguments in the call to . The underlying accepts only the class as an argument, so you get a when you instantiate the class. However, still accepts and passes over extra arguments to if your class doesn’t override , as in the following variation of : In this implementation of , you don’t override . The object creation is then delegated to , which now accepts and passes it over to to finalize the instantiation. Now you can create new and fully initialized instances of , just like in the example. Cool! Now that you know the basics of writing your own implementations of , you’re ready to dive into a few practical examples that feature some of the most common use cases of this method in Python programming. To kick things off, you’ll start with a use case of that consists of subclassing an immutable built-in type. As an example, say you need to write a class as a subclass of Python’s type. Your class will have an additional attribute to store the unit that’s used to measure the distance. Here’s a first approach to this problem, using the method: : float expected at most 1 argument, got 2 When you subclass an immutable built-in data type, you get an error. Part of the problem is that the value is set during creation, and it’s too late to change it during initialization. Additionally, is called under the hood, and it doesn’t deal with extra arguments in the same way as . This is what raises the error in your example. To work around this issue, you can initialize the object at creation time with instead of overriding . Here’s how you can do this in practice: In this example, runs the three steps that you learned in the previous section. First, the method creates a new instance of the current class, , by calling . This time, the call rolls back to , which creates a new instance and initializes it using as an argument. Then the method customizes the new instance by adding a attribute to it. Finally, the new instance gets returned. Note: The class in the example above doesn’t provide a proper unit conversion mechanism. This means that something like won’t attempt at converting units before adding the values. If you’re interested in converting units, then check out the Pint project on PyPI. That’s it! Now your class works as expected, allowing you to use an instance attribute for storing the unit in which you’re measuring the distance. Unlike the floating-point value stored in a given instance of , the attribute is mutable, so you can change its value any time you like. Finally, note how a call to the function reveals that your class inherits features and methods from . Returning an object of a different class is a requirement that can raise the need for a custom implementation of . However, you should be careful because in this case, Python skips the initialization step entirely. So, you’ll have the responsibility of taking the newly created object into a valid state before using it in your code. Check out the following example, in which the class uses to return instances of randomly selected classes: In this example, provides a method that creates a new instance by randomly selecting a class from a list of existing classes. Here’s how you can use this class as a factory of pet objects: Every time you instantiate , you get a random object from a different class. This result is possible because there’s no restriction on the object that can return. Using in such a way transforms a class into a flexible and powerful factory of objects, not limited to instances of itself. Finally, note how the method of never runs. That’s because always returns objects of a different class rather than of itself. Allowing Only a Single Instance in Your Classes Sometimes you need to implement a class that allows the creation of a single instance only. This type of class is commonly known as a singleton class. In this situation, the method comes in handy because it can help you restrict the number of instances that a given class can have. Note: Most experienced Python developers would argue that you don’t need to implement the singleton design pattern in Python unless you already have a working class and need to add the pattern’s functionality on top of it. The rest of the time, you can use a module-level constant to get the same singleton functionality without having to write a relatively complex class. Here’s an example of coding a class with a method that allows the creation of only one instance at a time. To do this, checks the existence of previous instances cached on a class attribute: The class in this example has a class attribute called that defaults to and works as a cache. The method checks if no previous instance exists by testing the condition . Note: In the example above, doesn’t provide an implementation of . If you ever need a class like this with a method, then keep in mind that this method will run every time you call the constructor. This behavior can cause weird initialization effects and bugs. If this condition is true, then the code block creates a new instance of and stores it to . Finally, the method returns the new or the existing instance to the caller. Then you instantiate twice to try to construct two different objects, and . If you compare the identity of these objects with the operator, then you’ll note that both objects are the same object. The names and just hold references to the same object. As a final example of how to take advantage of in your code, you can push your Python skills and write a factory function that partially emulates . The function allows you to create subclasses of with the additional feature of having named fields for accessing the items in the tuple. The code below implements a function that partially emulates this functionality by overriding the method of a nested class called : Here’s how this factory function works line by line:\n• Line 1 imports from the module. This function allows you to retrieve items using their index in the containing sequence.\n• Line 3 defines . This function takes a first argument called , which will hold the name of the tuple subclass that you want to create. The argument allows you to pass an undefined number of field names as strings.\n• Line 4 defines a local variable to hold the number of named fields provided by the user.\n• Line 6 defines a nested class called , which inherits from the built-in class.\n• Line 7 provides a class attribute. This attribute defines a tuple for holding instance attributes. This tuple saves memory by acting as a substitute for the instance’s dictionary, , which would otherwise play a similar role.\n• Line 9 implements with as its first argument. This implementation also takes the argument to accept an undefined number of field values.\n• Lines 10 to 14 define a conditional statement that checks if the number of items to store in the final tuple differs from the number of named fields. If that’s the case, then the conditional raises a with an error message.\n• Line 15 sets the attribute of the current class to the value provided by .\n• Lines 16 and 17 define a loop that turns every named field into a property that uses to return the item at the target . The loop uses the built-in function to perform this action. Note that the built-in function provides the appropriate value.\n• Line 18 returns a new instance of the current class by calling as usual.\n• Lines 20 and 21 define a method for your tuple subclass. To try your out, fire up an interactive session in the directory containing the file and run the following code: In this code snippet, you create a new class by calling . The first argument in this call represents the name that the resulting class object will use. The second and third arguments are the named fields available in the resulting class. Then you create a object by calling the class constructor with appropriate values for the and fields. To access the value of each named field, you can use the dot notation. You can also use indices to retrieve the values because your class is a tuple subclass. Because tuples are immutable data types in Python, you can’t assign new values to the point’s coordinates in place. If you try to do that, then you get an . Finally, calling with your instance as an argument reveals that your object inherits all the attributes and methods that regular tuples have in Python."
    },
    {
        "link": "https://geeksforgeeks.org/python-classes-and-objects",
        "document": "A class in Python is a user-defined template for creating objects. It bundles data and functions together, making it easier to manage and use them. When we create a new class, we define a new type of object. We can then create multiple instances of this object type.\n\nClasses are created using class keyword. Attributes are variables defined inside the class and represent the properties of the class. Attributes can be accessed using the dot . operator (e.g., MyClass.my_attribute).\n\nAn Object is an instance of a Class. It represents a specific implementation of the class and holds its own data.\n\nNow, let’s create an object from Dog class.\n\nsound attribute is a class attribute. It is shared across all instances of Dog class, so can be directly accessed through instance dog1.\n\nIn Python, class has __init__() function. It automatically initializes object attributes when an object is created.\n• species: A class attribute shared by all instances of the class.\n• __init__ method: Initializes the name and age attributes when a new object is created.\n• dog1 = Dog(“Buddy”, 3): Creates an object of the Dog class with name as “Buddy” and age as 3.\n• dog1.name: Accesses the instance attribute name of the dog1 object.\n• dog1.species: Accesses the class attribute species of the dog1 object.\n\nself parameter is a reference to the current instance of the class. It allows us to access the attributes and methods of the object.\n• None Inside bark(), self.name accesses the specific dog’s name and prints it.\n• None When we call dog1.bark(), Python automatically passes dog1 as self, allowing access to its attributes.\n\n__str__ method in Python allows us to define a custom string representation of an object. By default, when we print an object or convert it to a string using str(), Python uses the default implementation, which returns a string like <__main__.ClassName object at 0x00000123>.\n• __str__ Implementation: Defined as a method in the Dog class. Uses the self parameter to access the instance’s attributes (name and age).\n• Readable Output: When print(dog1) is called, Python automatically uses the __str__ method to get a string representation of the object. Without __str__, calling print(dog1) would produce something like <__main__.Dog object at 0x00000123>.\n\nIn Python, variables defined in a class can be either class variables or instance variables, and understanding the distinction between them is crucial for object-oriented programming.\n\nThese are the variables that are shared across all instances of a class. It is defined at the class level, outside any methods. All objects of the class share the same value for a class variable unless explicitly overridden in an object.\n\nVariables that are unique to each instance (object) of a class. These are defined within __init__ method or other instance methods. Each object maintains its own copy of instance variables, independent of other objects.\n• Class Variable (species): Shared by all instances of the class. Changing Dog.species affects all objects, as it’s a property of the class itself.\n• Instance Variables (name, age): Defined in the __init__ method. Unique to each instance (e.g., dog1.name and dog2.name are different).\n• Accessing Variables: Class variables can be accessed via the class name (Dog.species) or an object (dog1.species). Instance variables are accessed via the object (dog1.name).\n• Updating Variables: Changing Dog.species affects all instances. Changing dog1.name only affects dog1 and does not impact dog2.\n\nWhat are classes and objects in Python?\n\nWhy use classes in Python?\n\nHow to define a class in Python?\n\nWhat is an object in OOP?\n\nWhy do we need classes and objects?"
    },
    {
        "link": "https://w3schools.com/python/python_classes.asp",
        "document": "Almost everything in Python is an object, with its properties and methods.\n\nA Class is like an object constructor, or a \"blueprint\" for creating objects.\n\nTo create a class, use the keyword :\n\nNow we can use the class named MyClass to create objects:\n\nThe examples above are classes and objects in their simplest form, and are not really useful in real life applications.\n\nTo understand the meaning of classes we have to understand the built-in function.\n\nAll classes have a function called , which is always executed when the class is being initiated.\n\nUse the function to assign values to object properties, or other operations that are necessary to do when the object is being created:\n\nThe function controls what should be returned when the class object is represented as a string.\n\nIf the function is not set, the string representation of the object is returned:\n\nObjects can also contain methods. Methods in objects are functions that belong to the object.\n\nLet us create a method in the Person class:\n\nThe parameter is a reference to the current instance of the class, and is used to access variables that belong to the class.\n\nIt does not have to be named , you can call it whatever you like, but it has to be the first parameter of any function in the class:\n\nYou can modify properties on objects like this:\n\nYou can delete properties on objects by using the keyword:\n\nYou can delete objects by using the keyword:\n\ndefinitions cannot be empty, but if you for some reason have a definition with no content, put in the statement to avoid getting an error."
    },
    {
        "link": "https://medium.com/@poppyseedDev/mastering-object-oriented-programming-best-practices-and-design-patterns-e570d511b3b1",
        "document": "Object-oriented programming (OOP) is a paradigm that uses “objects” — data structures that consist of data fields and methods together with their interactions — to design applications and computer programs. Mastering OOP involves not just understanding the theory behind it but also adopting the best practices and design patterns that make your code efficient, reusable, and easy to maintain. This article outlines the best practices and design patterns for mastering object-oriented programming.\n\nSome best practice examples would include: encapsulation, inheritance, polymorphism, proper class design, and composition over inheritance. Here are more details about each one of them:\n• Encapsulation: This practice involves hiding the implementation details of an object. This can be done in Python using private members with double underscore prefixes.\n\nIn this example, the bank account number and balance are private to the class and can't be accessed directly from outside the class.\n• Inheritance: Inheritance is used to create a new class that has all the properties and behaviours of another class, with the potential to add or override them.\n\nHere, is a subclass of , inheriting the and properties and adding a property.\n• Polymorphism: This principle allows methods to act differently based on the object type they are acting on.\n\nIn this example, the function uses the method, which behaves differently depending on whether it's called on a or a object.\n• Proper Class Design: Each class should have a single responsibility. The following is an example of a class that only handles operations related to a bank account:\n\nIn this example, is only responsible for handling operations related to the bank account.\n• Composition over Inheritance: While inheritance can be useful, it can lead to overly complex hierarchies. Composition, on the other hand, promotes flexibility.\n\nIn this example, instead of inheriting from , the class is composed with an object, demonstrating the principle of composition over inheritance.\n\nDesign patterns provide general solutions or flexible ways to solve common design problems. These are some of the most important ones in OOP:\n• Factory Pattern: The factory pattern involves creating an object factory to abstract the object creation process.\n\nIn this example, the function is a factory function that creates and returns an instance of or depending on the input.\n• Singleton Pattern: The Singleton pattern ensures that a class has only one instance and provides a global point of access to it.\n\nIn this example, is a singleton class that always returns the same instance.\n• Strategy Pattern: The Strategy pattern enables an algorithm’s behaviour to be selected at runtime.\n\nIn this example, the class's method can be replaced with different functions at runtime.\n• Observer Pattern: The Observer pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified.\n\nIn this example, the class notifies all registered observers when its method is called.\n• Decorator Pattern: The Decorator pattern allows behaviour to be added to an individual object, either statically or dynamically, without affecting the behaviour of other objects from the same class.\n\nIn this example, and are decorators that add responsibilities to without changing its interface. Decorators are a flexible alternative to subclassing for extending functionality.\n\nIn conclusion, design patterns are proven solutions to common software design problems. They are not classes or libraries that can be plugged into an application and automatically solve problems. Instead, they are templates that provide guidance on how to solve various design problems in object-oriented software.\n\nMastering object-oriented programming requires understanding the fundamental principles and best practices, as well as how and when to use common design patterns. Through careful application of encapsulation, inheritance, polymorphism, and proper class design, along with the judicious use of design patterns, you can write code that is efficient, reusable, and easy to maintain. Remember, the ultimate goal of mastering OOP is to write code that not only works, but is also clean and manageable. This makes your software easier to read, understand, and modify, leading to more robust and maintainable applications."
    },
    {
        "link": "https://reddit.com/r/Python/comments/6xs6od/best_practices_oop_in_python",
        "document": "I sure this question is nothing new but I want to hear your answers anyways. I am actually new to object-oriented programming (even though I know the theoretical concepts; OOP has a lot of resemblance in pure math, particularly in set theory).\n\nWhat are some best practices in creating OOP systems in Python? And what are some bad practices to avoid?\n\nThroughout my programming experience, I spent most of my time organizing my programs into functions/definitions, not necessarily relying much on classes. But I think OOP, as a paradigm, is pretty good for implementing mathematical structures."
    },
    {
        "link": "https://geeksforgeeks.org/8-tips-for-object-oriented-programming-in-python",
        "document": "OOP or Object-Oriented Programming is a programming paradigm that organizes software design around data or objects and relies on the concept of classes and objects, rather than functions and logic. Object-oriented programming ensures code reusability and prevents Redundancy, and hence has become very popular even in the fields outside software engineering like Machine Learning, Artificial Intelligence, Data Science, etc. There are many object-oriented programming languages like Java, JavaScript, C++, Python, and many others.\n\nAs stated earlier, OOP is a programming paradigm that uses objects and classes and aims to implement real-world entities in programming. The main concepts of OOP are stated below:\n\n1. Inheritance: It is the process in which one class inherits the methods and attributes from another class. The class whose properties and methods are inherited is known as the Parent class and the class which inherits from the parent class is called the Child class. Inheritance is the most important aspect of object-oriented programming and provides the reusability of the code.\n\n2. Encapsulation: The word, “encapsulate” means to enclose something and the principle of encapsulation works in the same way. In OOP, the data and functions which operate on that data are wrapped together into a single unit by encapsulation. By this method, we can hide private details of a class and can only expose the functionality that is needed for interfacing with it.\n\n3. Polymorphism: Polymorphism is taken from the Greek words Poly and morph which means many and shape respectively. Hence in OOP, Polymorphism refers to the functions having the same names but having different functionalities. Polymorphism helps in making programming more intuitive and easier.\n\n4. Data Abstraction: Abstraction is another functionality of OOP in which we hide the internal details or implementations of a function and show the functionalities only. In other words, the users know “what the function does” but they don’t know “how it does” because they only get to see the basic implementation of the function, whereas the inner working is hidden.\n\nTo know more about the 4 pillars of Object-oriented programming click here. In this blog, we will discuss the 8 Tips for Object-Oriented Programming in Python. So Let’s take a look.\n\nTo under inheritance, learning to differentiate between class-level and instance-level data is very crucial, as inheritance is one of the core concepts of OOP. An instance attribute is a Python variable belonging to one object and is unique to it. It is accessible only in the scope of this object and is defined inside the constructor function of the class. Whereas, a class attribute is unique to a class rather than a particular object and is defined outside the constructor function. While writing a code, Instance-level data should be kept separate from class-level data and should not interfere with it.\n\nOne of the best practices to follow while writing Object-Oriented Programming is to use meaningful names keeping in mind that the naming convention must follow camel casing. There are rules which apply while naming attributes and functions as well. Hence, we should always name the design in such a way that one class, attribute, or function is responsible for one particular task only.\n\n3. Knowing the Use of Static\n\nStatic means that the member is bound to a class level rather than to an instance level. A static method can not access or modify the state of the class. By using static, the method doesn’t need access to the class instance. Also, using static methods improves code readability and saves a lot of memory.\n\nAccess specifiers in Python play an important role in securing data from unauthorized access and from being exploited. All data members and member functions of a class are declared public by default whereas to declare an internal method or attribute, a leading underscore ‘_’ is used. On the other hand, to declare a private one a double leading underscore ‘__’ is used. This practice helps in determining the access control of a specific data member or a member function of a class and tells the users which parts of the code are not public and should not be relied on.\n\nDevelopers are used to writing comments in the code but comments do not always provide the most structured way of workflows. For this inconvenience, Python structured documentation or docstrings provide a convenient way of associating documentation with Python public modules, functions, classes, methods, etc. Unlike source code comments, the docstring describes what the function does and not how. Docstrings in python are declared using ”’triple single quotes”’ or “””triple double quotes”””.\n\nPython Enterprise Proposal also called PEP are coding conventions for python packages. Besides writing a code with proper logic, many other important factors affect a code’s quality. PEP 8 is a document that was written in 2001 by Guido van Rossum, Barry Warsaw, and Nick Coghlan with its main aim to enhance the readability and consistency of code. One should keep in mind three important pep8 guidelines that are, to ensure that each line of code is limited to 80 characters, all libraries should be imported at the beginning, and to eliminate redundant variables or intermediary variables present in the code.\n\nAttributes of a class are function objects that are used to implement access controls of the classes and define corresponding methods of its instances. To access and manipulate the attributes of a class, python has some in-built methods. Those are getattr(), hasattr(), setattr() and delattr(). The getattr() function helps in accessing the attribute of the object. The hasattr() function is used in checking if an attribute exists or not. Setattr() is used to set an attribute. In case the attribute does not exist, then one would be created, whereas, delattr() is used to delete an attribute.\n\nAn abstract class provides a common interface for different implementations of a component. In object-oriented programming, developers need to reduce the amount of coding, and hence, abstract classes are used. An abstract class is used as it applies to a wide variety of objects and helps in the creation of a set of methods that must be created within any child classes built from that abstract class."
    },
    {
        "link": "https://realpython.com/python3-object-oriented-programming",
        "document": "Object-oriented programming (OOP) in Python helps you structure your code by grouping related data and behaviors into objects. You start by defining classes, which act as blueprints, and then create objects from them. OOP simplifies modeling real-world concepts in your programs and enables you to build systems that are more reusable and scalable.\n\nBy the end of this tutorial, you’ll understand that:\n• Object-oriented programming in Python involves creating classes as blueprints for objects. These objects contain data and the methods needed to manipulate that data.\n• The four key concepts of OOP in Python are encapsulation, inheritance, abstraction, and polymorphism.\n• You create an object in Python by instantiating a class, which involves calling the class name followed by parentheses.\n• Class inheritance in Python allows a class to inherit attributes and methods from another class, known as the parent class.\n• You use super() in Python to call a method from the parent class, allowing you to extend or modify inherited behavior.\n\nYou’ll explore how to define classes, instantiate classes to create objects, and leverage inheritance to build robust systems in Python.\n\nWhat Is Object-Oriented Programming in Python? Object-oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects. For example, an object could represent a person with properties like a name, age, and address and behaviors such as walking, talking, breathing, and running. Or it could represent an email with properties like a recipient list, subject, and body and behaviors like adding attachments and sending. Put another way, object-oriented programming is an approach for modeling concrete, real-world things, like cars, as well as relations between things, like companies and employees or students and teachers. OOP models real-world entities as software objects that have some data associated with them and can perform certain operations. OOP also exists in other programming languages and is often described to center around the four pillars, or four tenants of OOP:\n• Encapsulation allows you to bundle data (attributes) and behaviors (methods) within a class to create a cohesive unit. By defining methods to control access to attributes and its modification, encapsulation helps maintain data integrity and promotes modular, secure code.\n• Inheritance enables the creation of hierarchical relationships between classes, allowing a subclass to inherit attributes and methods from a parent class. This promotes code reuse and reduces duplication.\n• Abstraction focuses on hiding implementation details and exposing only the essential functionality of an object. By enforcing a consistent interface, abstraction simplifies interactions with objects, allowing developers to focus on what an object does rather than how it achieves its functionality.\n• Polymorphism allows you to treat objects of different types as instances of the same base type, as long as they implement a common interface or behavior. Python’s duck typing make it especially suited for polymorphism, as it allows you to access attributes and methods on objects without needing to worry about their actual class. In this tutorial you’ll take a practical approach to understanding OOP in Python. But keeping these four concepts of object-oriented programming in mind may help you to remember the information that you gather. The key takeaway is that objects are at the center of object-oriented programming in Python. In other programming paradigms, objects only represent the data. In OOP, they additionally inform the overall structure of the program.\n\nHow Do You Define a Class in Python? In Python, you define a class by using the keyword followed by a name and a colon. Then you use to declare which attributes each instance of the class should have: But what does all of that mean? And why do you even need classes in the first place? Take a step back and consider using built-in, primitive data structures as an alternative. Primitive data structures—like numbers, strings, and lists—are designed to represent straightforward pieces of information, such as the cost of an apple, the name of a poem, or your favorite colors, respectively. What if you want to represent something more complex? For example, you might want to track employees in an organization. You need to store some basic information about each employee, such as their name, age, position, and the year they started working. One way to do this is to represent each employee as a list: There are a number of issues with this approach. First, it can make larger code files more difficult to manage. If you reference several lines away from where you declared the list, will you remember that the element with index is the employee’s name? Second, it can introduce errors if employees don’t have the same number of elements in their respective lists. In the list above, the age is missing, so will return instead of Dr. McCoy’s age. A great way to make this type of code more manageable and more maintainable is to use classes. Classes allow you to create user-defined data structures. Classes define functions called methods, which identify the behaviors and actions that an object created from the class can perform with its data. In this tutorial, you’ll create a class that stores some information about the characteristics and behaviors that an individual dog can have. A class is a blueprint for how to define something. It doesn’t actually contain any data. The class specifies that a name and an age are necessary for defining a dog, but it doesn’t contain the name or age of any specific dog. While the class is the blueprint, an instance is an object that’s built from a class and contains real data. An instance of the class is not a blueprint anymore. It’s an actual dog with a name, like Miles, who’s four years old. Put another way, a class is like a form or questionnaire. An instance is like a form that you’ve filled out with information. Just like many people can fill out the same form with their own unique information, you can create many instances from a single class. You start all class definitions with the keyword, then add the name of the class and a colon. Python will consider any code that you indent below the class definition as part of the class’s body. Here’s an example of a class: The body of the class consists of a single statement: the keyword. Python programmers often use as a placeholder indicating where code will eventually go. It allows you to run this code without Python throwing an error. Note: Python class names are written in CapitalizedWords notation by convention. For example, a class for a specific breed of dog, like the Jack Russell Terrier, would be written as . The class isn’t very interesting right now, so you’ll spruce it up a bit by defining some properties that all objects should have. There are several properties that you can choose from, including name, age, coat color, and breed. To keep the example small in scope, you’ll just use name and age. You define the properties that all objects must have in a method called . Every time you create a new object, sets the initial state of the object by assigning the values of the object’s properties. That is, initializes each new instance of the class. You can give any number of parameters, but the first parameter will always be a variable called . When you create a new class instance, then Python automatically passes the instance to the parameter in so that Python can define the new attributes on the object. Update the class with an method that creates and attributes: Make sure that you indent the method’s signature by four spaces, and the body of the method by eight spaces. This indentation is vitally important. It tells Python that the method belongs to the class. In the body of , there are two statements using the variable:\n• creates an attribute called and assigns the value of the parameter to it.\n• creates an attribute called and assigns the value of the parameter to it. Attributes created in are called instance attributes. An instance attribute’s value is specific to a particular instance of the class. All objects have a name and an age, but the values for the and attributes will vary depending on the instance. On the other hand, class attributes are attributes that have the same value for all class instances. You can define a class attribute by assigning a value to a variable name outside of . For example, the following class has a class attribute called with the value : You define class attributes directly beneath the first line of the class name and indent them by four spaces. You always need to assign them an initial value. When you create an instance of the class, then Python automatically creates and assigns class attributes to their initial values. Use class attributes to define properties that should have the same value for every class instance. Use instance attributes for properties that vary from one instance to another. Now that you have a class, it’s time to create some dogs!\n\nHow Do You Instantiate a Class in Python? Creating a new object from a class is called instantiating a class. You can create a new object by typing the name of the class, followed by opening and closing parentheses: You first create a new class with no attributes or methods, and then you instantiate the class to create a object. In the output above, you can see that you now have a new object at . This funny-looking string of letters and numbers is a memory address that indicates where Python stores the object in your computer’s memory. Note that the address on your screen will be different. Now instantiate the class a second time to create another object: The new instance is located at a different memory address. That’s because it’s an entirely new instance and is completely unique from the first object that you created. To see this another way, type the following: In this code, you create two new objects and assign them to the variables and . When you compare and using the operator, the result is . Even though and are both instances of the class, they represent two distinct objects in memory. Now create a new class with a class attribute called and two instance attributes called and : To instantiate this class, you need to provide values for and . If you don’t, then Python raises a : To pass arguments to the and parameters, put values into the parentheses after the class name: This creates two new instances—one for a four-year-old dog named Miles and one for a nine-year-old dog named Buddy. The class’s method has three parameters, so why are you only passing two arguments to it in the example? When you instantiate the class, Python creates a new instance of and passes it to the first parameter of . This essentially removes the parameter, so you only need to worry about the and parameters. Note: Behind the scenes, Python both creates and initializes a new object when you use this syntax. If you want to dive deeper, then you can read the dedicated tutorial about the Python class constructor. After you create the instances, you can access their instance attributes using dot notation: You can access class attributes the same way: One of the biggest advantages of using classes to organize data is that instances are guaranteed to have the attributes you expect. All instances have , , and attributes, so you can use those attributes with confidence, knowing that they’ll always return a value. Although the attributes are guaranteed to exist, their values can change dynamically: In this example, you change the attribute of the object to . Then you change the attribute of the object to , which is a species of cat. That makes Miles a pretty strange dog, but it’s valid Python! The key takeaway here is that custom objects are mutable by default. An object is mutable if you can alter it dynamically. For example, lists and dictionaries are mutable, but strings and tuples are immutable. Instance methods are functions that you define inside a class and can only call on an instance of that class. Just like , an instance method always takes as its first parameter. Open a new editor window in IDLE and type in the following class: This class has two instance methods:\n• returns a string displaying the name and age of the dog.\n• has one parameter called and returns a string containing the dog’s name and the sound that the dog makes. Save the modified class to a file called and press to run the program. Then open the interactive window and type the following to see your instance methods in action: In the above class, returns a string containing information about the instance . When writing your own classes, it’s a good idea to have a method that returns a string containing useful information about an instance of the class. However, isn’t the most Pythonic way of doing this. When you create a object, you can use to display a string that looks like the list: Go ahead and print the object to see what output you get: When you print , you get a cryptic-looking message telling you that is a object at the memory address . This message isn’t very helpful. You can change what gets printed by defining a special instance method called . In the editor window, change the name of the class’s method to : Save the file and press . Now, when you print , you get a much friendlier output: Methods like and are called dunder methods because they begin and end with double underscores. There are many dunder methods that you can use to customize classes in Python. Understanding dunder methods is an important part of mastering object-oriented programming in Python, but for your first exploration of the topic, you’ll stick with these two dunder methods. Note: Check out When Should You Use vs in Python? to learn more about and its cousin . If you want to reinforce your understanding with a practical exercise, then you can click on the block below and work on solving the challenge:\n• , which stores the name of the car’s color as a string\n• , which stores the number of miles on the car as an integer Then create two objects—a blue car with twenty thousand miles and a red car with thirty thousand miles—and print out their colors and mileage. Your output should look like this: There are multiple ways to solve this challenge. To effectively practice what you’ve learned so far, try to solve the task with the information about classes in Python that you’ve gathered in this section. When you’re done with your own implementation of the challenge, then you can expand the block below to see a possible solution: First, create a class with and instance attributes, and a method to format the display of objects when you pass them to : The and parameters of are assigned to and , which creates the two instance attributes. The method interpolates both instance attributes into an f-string and uses the format specifier to print the mileage grouped by thousands and separated with a comma. Now you can create the two instances: You create the instance by passing the value to the parameter and to the parameter. Similarly, you create with the values and . To print the color and mileage of each object, you can loop over a containing both objects and print each object: Because you’ve defined their string representation in , printing the objects gives you the desired text output. When you’re ready, you can move on to the next section. There, you’ll see how to take your knowledge one step further and create classes from other classes.\n\nHow Do You Inherit From Another Class in Python? Inheritance is the process by which one class takes on the attributes and methods of another. Newly formed classes are called child classes, and the classes that you derive child classes from are called parent classes. You inherit from a parent class by creating a new class and putting the name of the parent class into parentheses: In this minimal example, the child class inherits from the parent class . Because child classes take on the attributes and methods of parent classes, is also without your explicitly defining that. Note: This tutorial is adapted from the chapter “Object-Oriented Programming (OOP)” in Python Basics: A Practical Introduction to Python 3. If you enjoy what you’re reading, then be sure to check out the rest of the book and the learning path. You can also check out the Python Basics: Building Systems With Classes video course to reinforce the skills that you’ll develop in this section of the tutorial. Child classes can override or extend the attributes and methods of parent classes. In other words, child classes inherit all of the parent’s attributes and methods but can also specify attributes and methods that are unique to themselves. Although the analogy isn’t perfect, you can think of object inheritance sort of like genetic inheritance. You may have inherited your hair color from your parents. It’s an attribute that you were born with. But maybe you decide to color your hair purple. Assuming that your parents don’t have purple hair, you’ve just overridden the hair color attribute that you inherited from your parents: If you change the code example like this, then will be . You also inherit, in a sense, your language from your parents. If your parents speak English, then you’ll also speak English. Now imagine you decide to learn a second language, like German. In this case, you’ve extended your attributes because you’ve added an attribute that your parents don’t have: You’ll learn more about how the code above works in the sections below. But before you dive deeper into inheritance in Python, you’ll take a walk to a dog park to better understand why you might want to use inheritance in your own code. Pretend for a moment that you’re at a dog park. There are many dogs of different breeds at the park, all engaging in various dog behaviors. Suppose now that you want to model the dog park with Python classes. The class that you wrote in the previous section can distinguish dogs by name and age but not by breed. You could modify the class in the editor window by adding a attribute: Press to save the file. Now you can model the dog park by creating a bunch of different dogs in the interactive window: Each breed of dog has slightly different behaviors. For example, bulldogs have a low bark that sounds like woof, but dachshunds have a higher-pitched bark that sounds more like yap. Using just the class, you must supply a string for the argument of every time you call it on a instance: Passing a string to every call to is repetitive and inconvenient. Moreover, the attribute should determine the string representing the sound that each instance makes, but here you have to manually pass the correct string to every time you call it. You can simplify the experience of working with the class by creating a child class for each breed of dog. This allows you to extend the functionality that each child class inherits, including specifying a default argument for . In this section, you’ll create a child class for each of the three breeds mentioned above: Jack Russell terrier, dachshund, and bulldog. For reference, here’s the full definition of the class that you’re currently working with: After doing the dog park example in the previous section, you’ve removed again. You’ll now write code to keep track of a dog’s breed using child classes instead. To create a child class, you create a new class with its own name and then put the name of the parent class in parentheses. Add the following to the file to create three new child classes of the class: Press to save and run the file. With the child classes defined, you can now create some dogs of specific breeds in the interactive window: Instances of child classes inherit all of the attributes and methods of the parent class: To determine which class a given object belongs to, you can use the built-in : What if you want to determine if is also an instance of the class? You can do this with the built-in : Notice that takes two arguments, an object and a class. In the example above, checks if is an instance of the class and returns . The , , , and objects are all instances, but isn’t a instance, and isn’t a instance: More generally, all objects created from a child class are instances of the parent class, although they may not be instances of other child classes. Now that you’ve created child classes for some different breeds of dogs, you can give each breed its own sound. Since different breeds of dogs have slightly different barks, you want to provide a default value for the argument of their respective methods. To do this, you need to override in the class definition for each breed. To override a method defined on the parent class, you define a method with the same name on the child class. Here’s what that looks like for the class: Now is defined on the class with the default argument for set to . Update with the new class and press to save and run the file. You can now call on a instance without passing an argument to : Sometimes dogs make different noises, so if Miles gets angry and growls, you can still call with a different sound: One thing to keep in mind about class inheritance is that changes to the parent class automatically propagate to child classes. This occurs as long as the attribute or method being changed isn’t overridden in the child class. For example, in the editor window, change the string returned by in the class: Save the file and press . Now, when you create a new instance named , returns the new string: However, calling on a instance won’t show the new style of output: Sometimes it makes sense to completely override a method from a parent class. But in this case, you don’t want the class to lose any changes that you might make to the formatting of the output string. To do this, you still need to define a method on the child class. But instead of explicitly defining the output string, you need to call the class’s from inside the child class’s using the same arguments that you passed to . You can access the parent class from inside a method of a child class by using : When you call inside , Python searches the parent class, , for a method and calls it with the variable . Update with the new class. Save the file and press so you can test it in the interactive window: Now when you call , you’ll see output reflecting the new formatting in the class. Note: In the above examples, the class hierarchy is very straightforward. The class has a single parent class, . In real-world examples, the class hierarchy can get quite complicated. The function does much more than just search the parent class for a method or an attribute. It traverses the entire class hierarchy for a matching method or attribute. If you aren’t careful, can have surprising results. If you want to check your understanding of the concepts that you learned about in this section with a practical exercise, then you can click on the block below and work on solving the challenge: Start with the following code for your parent class: Create a class that inherits from the class. Give the argument of a default value of . When you’re done with your own implementation of the challenge, then you can expand the block below to see a possible solution: Create a class called that inherits from the class and overrides the method: You give as the default value to the parameter in . Then you use to call the method of the parent class with the same argument passed to as the class’s method. Nice work! In this section, you’ve learned how to override and extend methods from a parent class, and you worked on a small practical example to cement your new skills."
    },
    {
        "link": "https://codebricks.co.nz/python-oop-07",
        "document": "[Python OOP] 7. Best Practices and Tips for OOP in Python\n\n7. Best Practices and Tips for OOP in Python\n\nObject-Oriented Programming (OOP) can lead to powerful, maintainable, and scalable code. Here are best practices and tips to make the most of OOP in Python.\n\nWriting clean code is not just about aesthetics; it is about maintainability and scalability. Here are some guidelines for writing clean OOP code in Python:\n• Methods and variables should be lowercase with words separated by underscores (e.g., ).\n\nKeep It DRY (Don’t Repeat Yourself)\n• Avoid duplicate code by abstracting repetitive logic into a method or a class.\n• Each class should have one responsibility and thus only one reason to change.\n• If a class is handling too many tasks, it might be time to break it down into more specialized classes.\n• Use comments sparingly, only when the code is not self-explanatory.\n\nWhile Python is not known for raw performance, you can still design your OOP structure to be as efficient as possible.\n• By defining in a class, you can significantly reduce the memory overhead for instances.\n• Instead of loading resources when an object is created, consider loading them on-demand.\n\nHere are additional tips to refine your OOP skills in Python:\n• Use duck typing and polymorphism to write more flexible and integrated code.\n• Deep inheritance hierarchies can become very difficult to understand and maintain.\n• Favor composition over inheritance to create more decoupled and flexible designs.\n• Mixins can be a great way to reuse code across unrelated classes.\n• Write unit tests for your classes to ensure that changes do not break functionality.\n\nFollowing these best practices and tips will not only make your code cleaner and easier to maintain but also more efficient and reliable."
    }
]