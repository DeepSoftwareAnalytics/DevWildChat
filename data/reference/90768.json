[
    {
        "link": "https://stackoverflow.com/questions/34523091/how-do-vga-control-signals-work-in-verilog-hdl",
        "document": "I'm an FPGA beginner and have trouble understanding how VGA control signals and VGA interact, and how to correctly generate VGA control signals (with Verilog) for more complicated specifications:\n• None Seemingly, the low portions in horizontal- and vertical- sync signals correspond to transitioning from one row to the next, and transitioning from the bottom-right corner to the upper-left corner, respectively. But is the VGA \"controlled\" by those low signals? Do those low signals \"tell\" the VGA to switch to next row or jump back to the starting point?\n• None Are the back porch and front porch there to satisfy setup time and hold time? Are the durations of porches given in VGA timing table only required minima (i.e. can I set the porches to be much longer than the given values in the timing table?)\n• None This is what confuses me the most: From the two continuous horizontal- and vertical- sync signals, how on earth does the VGA know (or do I know) exactly which point on screen it is displaying? If timing is the only factor, does that mean I must pay a lot of attention to match RPG control signals and h-sync and v-sync signals perfectly? If the answer is yes, then I have even more problems which I can only describe using my assignment as an example:\n\nIn this assignment we use a built-in 50MHz clock of an FPGA (Spartan starter board) and the pixels of the VGA is specified to be 800x600. The framerate is specified to be 72Hz.\n\nThe VGA timing table gives the following sync signal structures:\n\nThis seems to mean that for each pixel in a row on screen I spend 1 clock cycle (20ns) on it. However, for many complicated cases, I would want to control the color of a pixel depending on its location on screen and perhaps a lot of additional conditions such as the relation of current position with another location, certain states, etc. Now, if the location of the pixel depends on horizontal and vertical pixel counters, and the color depends further on the location, how can I match them in time? Also, what if my logic has to spend more than 20ns to decide the color of a pixel? Will that completely crash the image on the VGA screen?\n\nActually I've somehow completed my assignment, but I find my code messy and I totally have no idea why it worked:\n\nFor example, a portion of the assignment required us to show a star that changes its color every 0.5sec. My implementation looks like:\n\nIt seems to me that my h_count and v_count directly decides my VGA_HSYNC and VGA_VSYNC. But my VGA_RGB depends at least on color_flag, which further depends on frame_count, which depends on h_count and v_count. Shouldn't that cause delay of a few clock cycles? The code was synthesizable and did produced what I wanted to display. But how on earth did my VGA_RGB sync with VGA_HSYNC and VGA_VSYNC in time??? Am I overthinking this issue? Or was I just lucky? What did I miss?"
    },
    {
        "link": "https://forum.digikey.com/t/implementing-a-clock-boundary-synchronizer-in-verilog/35809",
        "document": "In this post we will explore a Verilog description of a clock synchronizer. From your introduction to digital electronics, you may recall the concept of metastability. This is an undesirable condition where a digital signal enters an indeterminate state; neither one nor zero. The purpose of the clock boundary synchronizer is to mitigate this metastability.\n\nTo better understand the synchronizer logic, let’s start by answering a few common questions:\n\nMany logic designs are designed to be synchronous which implies that all logic moves with the same heartbeat. In an FPGA this is implemented as a series of registers. Data is often transferred between registers on the rising edge of the clock. All logic that is synchronous with this single clock is said to be in the same clock domain. There may be multiple domains within an FPGA. There may also be domains outside the FPGA such as an external microcontroller.\n\nOne of the primary reasons to maintain clear clock boundaries is to prevent a metastable condition; a condition where a register (flip-flop) enters an intermediate state. This is mitigated for a single clock domain as all elements transition at the same time such as on rising edge of clock. At this point, all elements have a period of time to settle before the next rising edge occurs. Provided the gate propagation delays aren’t excessive, the chance of metastability is reduced.\n\nA challenging situation arises when signals cross clock boundaries. These boundaries are like two musical instruments that are slightly out of tune. The edges slide relative to each other. Sometimes the rising edges are coincident and other times, they are far apart. The metastability problem occurs when the signals between boundaries are close to each other. This is a hazard because a register in the receiving clock domain does not have time to stabilize before it is read. In extreme cases, this instability can cascade across the clock domain causing unpredictable operation.\n\nA block diagram representation of the Verilog implementation of a synchronizer is included as Figure 1. This is a classic design where the asynchronous signal flows through the registers. Each register is clocked by the master clock for the new domain. Stated another way, the asynchronous signal is made synchronous in the new domain. Here the number of registers is a design compromise. It’s a question of statistics. More synchronizing registers will reduce the chance of metastability. However, an overly complicated design will consume precious FPGA fabric and reduce speed.\n\nAt this point we will explore some of the highlights of the Verilog code which is attached to the end of this note. The first thing you will notice an ASCII art representation of the Synchronizer included here as Figure 2. This is followed by a sample instantiation and a header that provides a brief description of all input and output signals.\n\nIn the middle of Figure 2, you will notice a parameters and defaults section. Parameters are one of the great hidden gems of Verilog. They allow you to modify the operation of a (Register Transfer Level) RTL design as they are instantiated. For every parameter, a default value is defined. This may be overridden if desired. In this example, the parameter determines the number of flip-flops included in the synchronizer. It has a default of two and as seen in this sample instantiation, it remains at two.\n\nThis line of Verilog code declares and initializes the synchronous flip-flops:\n\nThis is a single register with a width determined by [SYNC_STAGES-1:0]. For example, with the SYNC_STAGES parameter is set to 2 the vector is understood as [1:0]. The {SYNC_STAGES{0’b0}}; statement is Verilog replication operator. It is a clever way of initializing each element of the sync_reg flip-flops with a binary zero.\n\nThis may not seem like a flip-flop. However, the FPGA synthesis tools will certainly interpret the description as a cascade of flip-flops as show in the VIVADO schematic representation of the synthesizer captured in Figure 3.\n\nIn this particular example, defining a register and then using a shift operation as seen in the next code snippet allows easy expansion of the circuit. It uses a parameter to determine the number of flip-flops.\n\nThe synchronizing chain and the rise / fall detectors are implemented inside an always @(posedge clk) block. Note the use of non-blocking code. Everything in this always block occurs at the same time. This is synchronous operation is a critical consideration for this design.\n\nThe operation (sensitivity) is controlled by the positive edge of the master clock associated with the receiving domain. A Verilog concatenation operator performs the equivalent of a microcontroller’s shift left operation. The left most bit is discarded, and the latest asynchronous input is placed into the lowest bit position.\n\nObserve that each vector and bit operation is dependent on the value of the SYNC_STAGES parameter. Consequently, the number of synchronizing flip-flops is easily changed with no modification to the module. These changes are made as the module is instantiated. As designed, they cannot be changed at run time.\n\nThe sync_out for the module is the derived from the leftmost bit in the shift register. Again, notice that this is non-blocking code. In this example, there are two synchronizers and an output register. The sync_out value is locked in on the rising edge of the 3rd clock pulse.\n\nThe rising and falling edge detector are constructed using the last two lines of code. Here we use the ternary operator ? : . This is a Verilog shorthand way of implementing an if else statement. The statements may be understood by referring to Figure 1. Observe that the edge trigger block monitors the output reg (last out) and the soon to be output. On the rising edge of clock, the block determines if the value of the output register has changed. It they are different, and the new output is positive, there is a rising edge. Same thought for falling edge.\n\nLet’s shift focus and explore the performance of the RTL. This included the testbench results as well as real world performance. This hardware was developed on the VIVADO platform for a Xilinx Artix FPGA as installed on a Digilent Basys 3. More on that topic another day.\n\nThe testbench results are captured in this testbench included as Figure 4. Clock 1 is considered the synchronous clock and clock 2 is the asynchronous clock. They have simulated frequencies of 100 MHz and 59 MHz respectively. Observe that sync_out follows the in signal by three rising edges of clk_1. It’s as if sync_out is a replica; albeit a delayed replica that is stretched to by 3 rising edges of clk_1. Also observe that rise_edge_tick and fall_edge_tick are synchronous with the rising edge of clk_1. The term “tick” refers to a pulsed signal that is high for one clock cycle. This rising edge trigger or the falling edge trigger may be for downstream edge triggered circuits. The sync_out signal may be used for level sensitive circuits.\n\nFigure 5 is an attempt to capture the real-world signals using a Digilent Analog Discovery (legacy) instrument. It’s difficult to see as the 100 MHz signals are fleeting and hard to capture. However, the various delays and pulsed signals can be seen. You can’t see in this still picture but know that there was an observable jitter between the signals. This is true because the Analog Discovery’s signal generator that produced the test pulse was not in sync with the BASYS 3 board’s 100 MHz clock. But that’s the point, we crossed clock boundaries – the synchronizer did its job.\n\nFigure 5: Real-world operation of the synchronizer on a Digilent BASYS 3 FPGA.\n\nModern FPGA “compilers” are designed to optimize your code with user assigned weights for power consumption, speed, and fabric consumption. It’s not uncommon for the synthesis tools to trim away parts of your logic. For example, you may need the rise_edge_tick and fall_edge_tick outputs. If you instantiate the synchronizer without connecting these outputs, they will automatically be trimmed. You will see this as an unused logic warning.\n\nYou can generally disregard this type of warning. However, when developing your logic, you should make all efforts to identify and eliminate the warnings. I ran headlong into this problem while constructing the rise and fall edge detector for this synchronizer. Originally, I had used a register to remember the last value of sync_out. This is a perfectly natural way of coding in the microcontroller world:\n\nIf (present != last) do something\n\nThat’s a good solution and it worked but the synthesizing tool constantly presented the logic trimmed warning. Turns out I was thinking about this from the wrong perspective. To understand why, look back at Figure 1. Notice that the last flip-flop is special. It’s not part of the synchronizer per say. Instead, it’s the output register for the module. It is the source of synchronous stability presented to the other FPGA logic. Here stable implies that it is a register, under control of the master clock wrapped in a always@(posedge clk) block.\n\nWhen you think about it, that register I has used to capture the “last output” was redundant. The signal of interest was held in the sync_out register. The synthesizer tools observed this and warned me about the redundancy.\n\nThis observation may help explain the positioning of the rise and fall block inputs shown in Figure 1. Notice that monitors the input and output of the last flip-flop. If the signals are different, the block sends the appropriate pulse.\n\nAaron Dahlen, LCDR USCG (Ret.), serves as an application engineer at DigiKey. He has a unique electronics and automation foundation built over a 27-year military career as a technician and engineer which was further enhanced by 12 years of teaching (interwoven). With an MSEE degree from Minnesota State University, Mankato, Dahlen has taught in an ABET accredited EE program, served as the program coordinator for an EET program, and taught component-level repair to military electronics technicians. Dahlen has returned to his Northern Minnesota home and thoroughly enjoys researching and writing articles such as this."
    },
    {
        "link": "https://electronics.stackexchange.com/questions/124694/synchronizing-input-and-output",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://reddit.com/r/FPGA/comments/jdjgcd/synchronizing_a_fast_pulse_into_a_slow_clock",
        "document": "Hello. I was hoping to clarify another synchronization question.\n\nCummings paper here goes over multiple ways to reliably synchronize a fast pulse into a slow domain. Starting with section 4.2.\n\nSection 4.3 goes over the fallacy of trying to stretch a signal from the fast domain to something that is only slightly wider than the destination clock domain, with expectation it to always be at least sampled once by the the destination domain. However, this is not accurate as you can completely miss the pulse due to violations of both setup and hold. I've drawn it out myself as well here in Picture 1 and understand this.\n\nOne assertion to reliably do this is to ensure the fast pulse you're trying to synchronize is at least 1.5x the destination clock frequency if passing through a double flop synchronizer. My question is, even if the source \"fast clk\" pulses are spaced apart relatively apart, how is this useful in terms of representing in the slower domain the number of events that really happened in the fast domain? Or is this never the intent?\n\nThe expectation can't be that the number of samples in the destination domain is equal to the number of stretched pulses in the source domain. I drew it out here in Picture 2 where the slow_clk can sample correctly once, and in here in Picture 3 where the slow_clk can sample correctly twice. The source fast_clk domain in both cases has asserted the signal for 2 fast_clk cycles. Since the number of samples in the destination clock domain do not match the number of assertions of the signal in the source domain (posedge only), what is the use of transferring a pulse from fast to slow clocks this way? The replication of information is not 1 to 1. If I have 50 single cycle wide \"fast_clk\" pulses that I each stretched to 2 cycles wide to be sampled in \"slow_clk\", I won't necessarily have 50 slow clock pulses. It will be pulses in the slow domain that can be 1 or 2 cycles wide."
    },
    {
        "link": "https://01signal.com/verilog-design/reset/synchronous-vs-asynchronous",
        "document": "This is the second page in a series about resets in FPGAs. After explaining why asynchronous resets are not what many people think in the previous page, this page discusses the different options for resets and initialization of the FPGA.\n\nFirst and foremost: What is a reset?\n\nLike, come on, we all know what a reset is! It's like that button on the computer that you press and everything starts from clean. It's that signal that goes into a chip that ensures that no matter what happened before, from now on everything will be fine. Some people refer to the reset as the signal that brings the system to a known state.\n\nTo FPGA designers, the reset is often just that extra input to add to every module and use in a repeated code pattern. Something we just do, not necessarily paying attention to what this reset signal actually ensures, if at all, or if it can be omitted altogether.\n\nThe most common misconception is to focus on the fact that the reset signal brings the system to a known state. That's true, of course, but the important part is what happens after the reset is deactivated. The logic must be ensured to begin working in a predictable manner. Or at least, predictable enough to ensure it works properly. It's pointless to reset a system if we're not sure about its behavior after we've deactivated the reset.\n\nWhat makes this topic difficult in particular is that there's luck involved: Generally speaking, the state of the system when the reset was activated is unknown and random, and so is the timing of the reset's deactivation. An improper handling of the reset signal can therefore result in rare malfunctions that appear in random occasions, which may seem to be a completely different sort of problem. Likewise, it's possible to neglect this issue without any visible consequences, except for occasional problems that are usually treated with witchcraft.\n\nJust like proper timing constraints, proper handling of clocks and clock domains, a proper treatment of the FPGA's wakeup and reset is a necessity to ensure that the FPGA works reliably. Common to all of these topics is that one can sort-of get away with neglecting them, and quite some engineers do, but unfortunately at the cost of an FPGA that behaves like it's haunted every now and then.\n\nThis page focuses on how decisions about resets influence the design when it's loaded into the FPGA. But obviously, these decisions also have an impact on the simulation of the logic.\n\nIt's important to distinguish between these two situations. Simulators assign the X (unknown) initial value to all registers, in particular in behavioral simulation. These X values then propagate to any register that depends on an X value in its logic function. Hence it happens that even a single register with an X value swamps the entire design with X's, and the simulation becomes useless.\n\nA common incorrect solution to this problem is putting an asynchronous reset on all registers in the design, in order to get rid of all X's. This is usually done by enabling the reset briefly at the beginning of the simulation. As a result, all registers get a known value, and everything looks perfect. Unfortunately, this incorrect solution often gives an illusion of a clean start, by hiding the problems discussed in the previous page.\n\nEven if the resets are used correctly, it's still a lazy choice to reset all registers in order to avoid chasing the source of X values in the simulation. This doesn't only waste resources and possibly makes it harder to achieve the timing constraints: Resetting registers unnecessarily can also hide bugs, because a flood of X values may origin from an unintentional dependency from one register to another. Hence this flood of X's can be a warning that something is wrong with the design.\n\nComparing with a simulation, the hardware is much more forgiving about not using resets. But when resets are used incorrectly, or not used at all when they are necessary, the hardware may behave quite unexpectedly.\n\nIn conclusion, resets should be used with the hardware in mind, and not for getting rid of annoying X's during the simulation. And because the focus should be on the hardware, these few words are all I have to say about simulations.\n\nThe decision on if and how to apply resets on registers requires considering the case of each register separately. Doing this doesn't just avoid an unnecessarily high fan-out of the reset signals, but it's also a good opportunity to think about whether the logic is guaranteed to start off correctly after the reset, no matter its previous state.\n\nIn principle, there are four options:\n• Accept that the initial value of the register is unknown.\n• Rely on the initial value setting of the FPGA's synchronous element. So the there is no explicit reset.\n• Use an asynchronous reset. For example:\n\n\n\nEach of these options is discussed below, so I'll first present what I consider to be the correct way, and then elaborate:\n• Go through each register (and other logic elements that have a reset input) in the design separately, and check if the first two options make sense. In other words, if a reset can be avoided.\n• Use asynchronous resets only with logic elements that explicitly require that (in particular complex FPGA primitives and IP cores, e.g. transceivers and bus controllers), and even so, try to use the synchronous reset signal if possible.\n• Always reset state machines properly. Even if its behavioral definition ensures that it reaches a known state sooner or later, be sure that an explicit and safe reset brings it to a known state. This is mainly because the synthesizer may implement the state variable in an different way due to optimization (one-hot in particular). This representation of the state variable may hence never converge into a legal state unless the state machine is reset explicitly.\n• Always reset IP cores, design blocks and primitives that have reset inputs if the documentation requires that (and it's a good idea to do so in either case). They might very well work without the reset, but that can be just pure luck. Even if the reset is related to functionality that you don't use, and even if the reset appears to merely zero some outputs which are unnecessary for your design, the rule is simple: When it comes to resets, follow the documentation carefully. Even if there's no apparent reason why it should be necessary.\n\nThese suggestions are pretty much in line with what FPGA vendors recommend these days.\n\nI'll also add a very general guideline: Always reset control logic explicitly and let data paths flush themselves from their initial junk data.\n\nAnd now the lengthy discussion on each option.\n\nSome registers don't need any reset nor initial value. This applies in particular to shift registers and similar logic elements. Generally speaking, data paths are likely to fit this option.\n\nThis is clearly five delay registers with 32 bits each. On some FPGAs (Xilinx in particular), the synthesizer detects this as a shift register if only the last value (@d4) is used, and there's no reset on any of these registers. This can reduce the consumption of logic considerably.\n\nClearly, the logic that is connected to the output of these delay registers must be able to tolerate some initial random data. A typical case when this is no problem is when there's some other register or state machine, that is properly reset and makes sure that uninitialized values are ignored as they arrive. For example, if these delay lines are related to a pipeline, the pipeline's control logic will naturally ignore invalid data.\n\nMore generally speaking, the opportunity to not reset nor initialize a register is easily recognized when there's an accompanying flag or state that indicates its validity. Or when there's a clear sequence of first assigning the register with a value and then consuming this value. In short, when it's easy to tell that the register's value is ignored until it has been assigned a proper value.\n\nAnother type of unknown initial value is when it may depend on the synthesizer. For example:\n\nThe synthesizer may decide that @val is a wire that has a constant value of 1. Another possibility is to assign a register with zero as the initial value, so it changes to 1 on the first clock. What actually happens depends on the synthesizer. So even though the value of @val is always known, except for the first clock cycle, the initial value should be considered unknown.\n\nThe initial value of the basic synchronous elements in an FPGA (commonly flip-flops, shift registers and memories) is given in the configuration bitstream. The well-known use of this feature is to create a ROM by assigning a block RAM with initial values and never write to it.\n\nAnother well-known aspect of this feature is that an FPGA typically wakes up from configuration with apparently all registers having the value zero. This is because the synthesizer usually assigns all registers with zero as their initial value, but there can be surprises unless the initial value is set explicitly.\n\nSome synchronous elements, in particular shift registers and dedicated RAM blocks, can be created by describing their behavior in Verilog or VHDL (by inference): The synthesizer usually creates a shift register when the code looks like a delay line. Likewise, a RAM logic element is created in response to an array. However, if a reset is used on these registers (synchronous reset or asynchronous reset), the synthesizer is prevented from using the logic resources this way. This is because neither shift registers nor RAMs have a reset input that sets the values of the internal memory.\n\nSo how are the initial values set? During the configuration process, all synchronous elements are given their initial values just before the FPGA is about to become active, i.e. before the synchronous elements start responding to their clocks and asynchronous reset inputs. For Xilinx devices, this is implemented by virtue of the Global Set Reset (GSR) signal, which puts all synchronous elements in their initial state. After this, Global Write Enable (GWE) is activated, which makes the synchronous elements operate normally.\n\nSince the configuration process is carried out regardless of any of the clocks that are used by the FPGA's application logic, the FPGA's transition into its operational state is asynchronous to any of these clocks. Consequently, the synchronous elements behave exactly as if an asynchronous reset was deactivated regardless to any clock. In other words, it's possible that some synchronous elements respond to the first clock edge that arrives after the transition to operational state, and other synchronous elements don't respond to this clock edge due to a violation of timing. This can cause nasty bugs, as discussed in the first page in this series.\n\nIt's important to note that the clocks aren't necessarily stable when the FPGA wakes up. If they are generated by the FPGA's own PLLs, they may violate the timing constraints wildly. As discussed above, this is not a problem if the clock is ignored until it's stable (e.g. by virtue of a clock enable), or if it's known to be stable when the FPGA wakes up. Also, if the design ensures that no synchronous element has a reason to change its value until the clock is stable, it's fine. Otherwise, setting an initial value doesn't guarantee much.\n\nDespite the limitations of setting the initial value, it is good enough in many scenarios, and an explicit reset isn't required. And in some cases, there is simply no choice, because a reset signal isn't available. For example, the logic that creates the FPGA's reset signals immediately after the FPGA wakes up. An example of such logic is shown on the third page of this series.\n\nWith most synthesizers, setting a register's initial value is quite simple: Use Verilog's \"initial\":\n\nIt may come as a surprise that \"initial\" can be used in Verilog code for synthesis, but as it turns out, this usage is widely supported. So this keyword is definitely the preferred method if the synthesizer supports it (in other words, this usage of \"initial\" is explicitly mentioned in the documentation). Besides, the alternative method tends to be vendor-specific, and sometimes even specific to an FPGA family. So even if \"initial\" isn't always portable, it's probably still the most portable choice.\n\nThe alternative method for setting the initial value depends on the FPGA that is used. This method usually consists of an instantiation of the synchronous element as a primitive, and the assignment of the initial value as an instantiation parameter. For example, a Xilinx' flip-flop:\n\nUsing \"initial\" is nicer, isn't it?\n\nIf you haven't read the page on why asynchronous resets are often used incorrectly, I suggest doing that first. Unless you don't intend to use this kind of reset anyhow.\n\nFor some reason, a lot of people consider the asynchronous reset as the right solution for all purposes. Maybe because it often appears in code examples, maybe because of the illusion of a simple way to achieve a global reset that reaches all synchronous elements. Maybe because in the old ASIC world, the asynchronous reset was useful for the chip test in the manufacturing process, because it allows to reset the entire chip and begin applying test vectors.\n\nSo to reality: The proper and clean way to use an asynchronous reset is to do that with the clocks turned off. That's what the \"asynchronous\" part really means. In a practical design, this consists of the following stages:\n• Deactivate all clocks (except the clock that is used by the logic that controls this procedure). This deactivation is often done by turning off the clock enable input of the global clock buffers (clock gating).\n• Activate and deactivate the asynchronous reset signal. Make sure that the pulse is long enough to reset all synchronous elements.\n• Wait enough time to ensure that all synchronous elements are ready for receiving clocks.\n\nThis sequence isn't difficult to implement, but it might be harder to ensure that the first edge of each clock is properly formed, so there are no glitches: A common problem with clock buffers is that there's a requirement on the timing between the activation of the clock buffer's output enable and the first clock edge to pass through the clock buffer. If this timing requirement is violated, the clock buffer may output a glitch (a short pulse that violates the FPGA's requirements on the clock). This can cause unpredictable behavior of all synchronous elements that depend on this clock.\n\nUnfortunately, the documentation that is offered by FPGA vendors doesn't always offer an explanation on how to ensure this timing requirement. As a result, it may not be possible to be ensure that the first clock edge after the reset behaves correctly. And without a guarantee on the first clock edge, the reset is pointless.\n\nIf you use this method, be sure that no timing constraints are enforced on the paths that are related to the asynchronous reset. Such enforcement is unnecessary in this case, and it may be activated by default.\n\nThere's an alternative method for applying an asynchronous reset reliably, which is commonly suggested. This method doesn't involve clock gating, and hence doesn't rely on the clock buffers: The idea is to add a few flip-flops which let through the activation of the asynchronous reset signal directly, but these flip-flops deactivate the reset synchronously. In other words, a synchronized asynchronous reset.\n\nFor example, if the original asynchronous reset is @external_resetn, this generates a reset of this sort:\n\nNote that @clk is the clock that is used by the synchronous elements that are reset by @resetn.\n\nWhen @external_resetn is active (i.e. low), all three registers become active (i.e. zero) asynchronously. However when @external_resetn is deactivated, only @pre_rstn1 becomes inactive on the next clock edge, and this propagates to @pre_rstn2 and @resetn on the clocks that follow.\n\nThe purpose of the two extra registers is to protect against metastability, so that @resetn deactivates in a safe manner. This is necessary if and when @external_resetn becomes inactive with bad timing relative to @clk, which may result in a metastable condition on @pre_rstn1 (this page explains metastability).\n\nThe benefit of this synchronizer is that @external_resetn can be used as an asynchronous reset: It works even if no clock is active. Nevertheless, the synchronous elements receive a reset signal that becomes inactive synchronously, so timing can be ensured.\n\nAlmost needless to say, each clock needs its own synchronized asynchronous reset.\n\nIt's important to note that generating @resetn as shown above is not enough. The timing constraints for @clk must be enforced on the paths from @resetn to the synchronous elements. The default of some FPGA tools is to ignore the timing of paths that end at a synchronous element's asynchronous reset input. It's may be necessary to make a change in the tool's settings for this purpose.\n\nSo if @resetn is used as a regular asynchronous reset, e.g.\n\nthen the synchronizer that is shown above is not enough to ensure a reliable recovery from reset. It's your responsibility to verify that the paths that start at @resetn and end at the flip-flops' asynchronous reset inputs are indeed timed.\n\nIt's also important to note that this synchronizer doesn't help against glitches on @external_resetn: If the length of @external_resetn's active pulse is shorter than the specification of the FPGA's flip-flops, anything can happen. So @external_resetn must be generated by some logic or external electronics that ensures a long pulse. If this is not possible, the only solution is to synchronize the reset completely, as with this example for @sync_resetn:\n\nBut this synchronizer ignores @external_resetn if @clk is inactive. This is problematic if the logic is supposed to treat @external_resetn like an asynchronous reset. In other words, that it should work even when the clocks aren't active.\n\nLet's go back to the first synchronizer. What about using @resetn as a plain synchronous reset? Something like this:\n\nThis is more or less fine, because @resetn's deactivation is surely timed by virtue of the timing constraints. However, the asynchronous activation of @resetn is not timed, so the related synchronous elements may behave randomly just before the reset takes effect. It's better to use a fully synchronized reset for this purpose, e.g. @sync_resetn as defined above.\n\nI'll finish this topic with a general comment: I've chosen to use active-low resets in the examples above, mainly because of a tradition that stems from the days when the reset signal was generated with a capacitor that was connected to the power supply voltage through a resistor. As the capacitor had no voltage initially, the reset input was '0'. This capacitor built up enough charge quite soon, and consequently the reset input changed to '1'. This ancient type of power-up reset is the reason many resets are active low to this day.\n\nIn conclusion, it is possible to use an asynchronous reset reliably, however achieving this is definitely not as simple as many believe. I've presented two ways to ensure for a reliable asynchronous reset: Either by turning off the clocks temporarily in order to avoid problems with timing, or by using a synchronizer in order to ensure the timing. As usual with FPGAs, timing is the name of the game.\n\nIn most designs that rely on an asynchronous reset in the real world, none of these methods is used. As a result, the reliability of the FPGA design depends on pure luck.\n\nThe synchronous reset is most known with the following code pattern:\n\nI'll suggest what I consider a better code pattern further on, but for now we'll stick with this one. Regardless, note that I chose active-high reset here, as this is the more common choice with synchronous resets. Or so is my impression.\n\nA synchronous reset is better than the asynchronous reset in almost all aspects, except for these:\n• The synchronous reset signal can reach huge fan-outs, and timing constraints are enforced on all its paths. So this kind of reset can make it difficult to achieve the timing constraints.\n• The synchronous reset can't be used when the clock isn't active.\n• Some FPGAs have dedicated resources for global routing, which can be used only with asynchronous resets (I'm not sure this is really the case, but since I've seen this mentioned for Intel FPGAs, I added this comment).\n\nSince FPGAs are rarely used with no active clock (unlike ASICs, which traditionally need this for testing), and it's not clear if the issue with dedicated resources for routing even exists, I'll focus on the main topic: Fan-out. Luckily, this is easy to solve.\n\nIt's also worth mentioning that the same fan-out problem influences the asynchronous reset just the same, if the synchronizer that was suggested above is used. So the only ones that can truly say that fan-out is a disadvantage of the synchronous reset are those who use the asynchronous reset with the clocks turned off (i.e. gated).\n\nThe first thing that comes to mind for solving a fan-out problem is with a synthesizer constraint or attribute to limit the fan-out. This is however the less preferred way, because the synthesizer just duplicates the flip-flop when the limit is reached. Therefore, it often happens that the output of a duplicated flip-flops go to modules with completely different purposes, hence the destinations of this output can be scattered all over the FPGA. This results in long routing and a significant propagation delay.\n\nA simple and efficient solution is to create a local reset for each significant part of the logic. Something like\n\nThe idea is that @local_reset is a local copy of @reset (delayed by one clock). Using @local_reset instead of @reset from this module and downwards holds the fan-out at a reasonable level. As the consumers of this local reset are expected to be interconnected tightly anyhow, odds are that they will be placed in a certain region of the FPGA. Hence the local reset won't need to travel long distances across the logic fabric.\n\nIt's important to prevent the synthesizer from removing the local reset registers for the sake of optimizing the logic. The synthesizer usually does this when there are registers with identical behavior, even if they belong to different modules. In the example above, Vivado's synthesis attribute is shown, i.e. \"dont_touch\". Each synthesizer has its own way to do this (for Quartus, the same is achieved with \"dont_merge\" as the synthesis attribute).\n\nTo verify that the synthesizer indeed retained all registers, it's useful to give all these registers the same name (e.g. local_reset as suggested above) and then search for registers with this name in the implemented design.\n\nThere's of course no need to create a local reset for each and every module. As an approximate figure, a fan-out of 50-100 is reasonable for a local reset, in particular when it reaches logic elements within a small physical region on the FPGA.\n\nThe topic of reducing fan-out is also discussed in the context of timing closure.\n\nA common myth about synchronous resets is that if the synthesizer encounters a Verilog code pattern that matches that of a synchronous reset, it will connect the reset signal to the flip-flop's synchronous reset input. This can be the case, but it will often not be.\n\nThis is different from an asynchronous reset, which must be connected to the flip-flop's asynchronous reset input. Otherwise, the reset won't work without a clock.\n\nSynthesizers tend to give no special meaning to the coding pattern, but rather calculate the logic equation that is derived from the Verilog code. Consider this example:\n\nOne way to read this code is that the always statement begins with a standard code pattern that asks for a synchronous reset, and then comes a specific definition for the register's behavior. Consequently, one could have expected that @reset would be connected to the synchronous reset input of the relevant flip-flop, and also that the output of a logic function (that is implemented as a LUT) would go to the flip-flop's data input.\n\nIn reality, synthesizers usually implement the value of @the_register on the next clock as concisely as possible. For example, the flip-flop's reset input may be connected to a logic function (i.e. a LUT) that implements the expression (reset || (some_other_condition && !some_condition) ).\n\nBut there an even more interesting possibility: The flip-flop's reset input might not be used at all. Instead, only the data input is used, and the logic function uses the @reset signal as one of its inputs. So if @reset is high, the logic function's output is zero. This way @reset indeed brings @the_register to zero, but it's not treated differently from any other signal.\n\nSo to reiterate: Even though the flip-flop has a synchronous reset input, synthesizers tend not to treat the synchronous reset's code pattern specially, and neither treat the reset signal any different from any other signal. The flip-flop's reset input is used in the best way to implement the behavior that is required by the Verilog code. That can sometimes mean to connect the reset input directly to the reset signal, sometimes to some logic function that may involve the reset signal, and sometimes not use the reset input at all. The synthesizer does whatever helps it meet its performance goals better, nothing else.\n\nUsers of Xilinx' Vivado can get better control on this issue with two synthesis attributes, which are DIRECT_RESET and EXTRACT_RESET.\n\nI'll wrap this up with another disadvantage of asynchronous resets: In most FPGAs, a flip-flop only has one reset/set input. This input can behave synchronously or asynchronously. If the reset is synchronous, the synthesizer might find tricks to use this input for using less LUTs in the effort to fulfill the requested behavior. A shortcut of this sort is impossible when there is an asynchronous reset. So an asynchronous reset ties the hands of the synthesizer, forcing it to waste more logic resources.\n\nThere's a pitfall with the commonly used code patterns for implementing resets, as shown in this code example:\n\nAs implied by the comment, @reg3 doesn't appear in the begin-end clause for an active @resetn. As a result, the Verilog code above requires that @reg3 won't change value as long as @resetn is active. It's the same as if @reg3 would be defined with\n\nor in other words, @resetn functions as a clock enable for @reg3: The clock is effective only when @resetn is high.\n\nExactly the same happens with synchronous resets:\n\nThis is actually easier to understand, because this is just a pair of begin-end clauses, with the second clause coming to effect only when @reset is inactive. So the definition of @reg3 for this example is clearly\n\nSo the obvious (and not necessarily clever) conclusion is not to forget any register in the begin-end clause for the reset. In fact, many FPGA designers reset all registers, whether needed or not, because they believe that's the only way to do it. Or alternatively, they adopt a coding style where each register has its own \"always\" statement.\n\nBut what if you intentionally want to reset some registers and not others?\n\nWith an asynchronous reset, only choice is to put those registers in a separate \"always\" statement. But with a synchronous reset, there's a simple way to work this out:\n\nInstead of an \"if (reset)\" sentence at the beginning, and having the interesting part under the \"else\" statement, the \"if (reset)\" is put last, so the assignments for the reset override everything that came before them.\n\nNote that this is not equivalent to any of the examples above: @reg1 and @reg2 are reset when @reset is active, however @reg3 is not influenced by the reset at all.\n\nIf you feel uncomfortable with this alternative way to apply a synchronous reset, I can understand that, and there are a few reasons for it: To begin with, it's generally good practice to stick to commonly used coding patterns in FPGA design. Otherwise, the synthesizer might expose an exotic bug, something that is much less likely to happen with well-established code patterns (see Golden Rule #4). So even though the Verilog standard explicitly requires that this method works, one could argue that it's not necessarily a good idea to rely on this feature.\n\nThis is a strong argument, but for what it's worth, I'm here to tell you that I've been using code patterns like this heavily for more than a decade, with a large range of synthesizers. In particular, this is how I define synchronous resets in my own code. I have never had a single problem with this.\n\nAnother possible reason for not liking this method is to think that the synthesizer might miss the hint that a synchronous reset is desired, because it's not the regular code pattern. However as already mentioned above, most synthesizers don't take the hint anyway, and consider the synchronous reset as just another definition of the logic's required behavior. So this reason has no grounds.\n\nSo if you want to take my word for it that it's safe, you'll save yourself some headache.\n\nCan the same be done with an asynchronous reset? For example, what will this do?\n\nThis is of course a diversion from the asynchronous reset's common coding pattern. An anecdotal test on Vivado's synthesizer revealed this it got the hint, and assigned an asynchronous reset for @reg1.\n\nBut the behavior that is required for @reg2 is can't be achieved on an FPGA: As written above, it means that both @clk and @resetn are clocks, and that @reg2 samples a new value on their rising edges and falling edges, respectively. Since flip-flops with two clock inputs are not available in any FPGA that I know of, there's no possibility for a synthesis of @reg2's definition.\n\nVivado's synthesizer reacted to this by ignoring the \"negedge resetn\" part, and created a flip-flop that uses only @clk as a clock. There were no traces of this oddity in the result of the syntheses, and neither did the synthesizer issue any warning or otherwise complain. That's despite the fact that the synthesizer created logic that doesn't behave as defined by the Verilog code.\n\nSo specifically with Vivado's synthesizer, the same code pattern actually works even for an asynchronous reset, but this shouldn't be relied upon: The Verilog code should say what you want the logic to do. Otherwise, the synthesizer is perfectly entitled to misinterpret it as it prefers.\n\nThis concludes the second page in this series about resets. The next page goes through different aspects of starting up the FPGA after powerup and external reset."
    },
    {
        "link": "https://dvcon-proceedings.org/wp-content/uploads/asynchronous-behaviors-meet-their-match-with-systemverilog-assertions.pdf",
        "document": ""
    },
    {
        "link": "https://electronics.stackexchange.com/questions/163018/asynchronous-reset-in-verilog",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "http://sunburst-design.com/papers/CummingsSNUG2003Boston_Resets.pdf",
        "document": ""
    },
    {
        "link": "https://sciencedirect.com/topics/computer-science/asynchronous-reset",
        "document": ""
    },
    {
        "link": "https://edaboard.com/threads/flop-with-sync-async-reset.224800",
        "document": "@Sitansh Thanks you for clarifying. I have one more doubt. Suppose we are using active high async reset and its high right from the start. Hence w/o the dependence on the clock the circuit will reset to the initial conditions, while in sync reset the circuit will reset to initial conditions only after the first clock edge arrives. Will this be a disadvantage of some kind like formation of latches because of default conditions not being me or any other?\n\nThis is the very reason why we need asynchronously resettable flops.Most of the chip have multiple levels of clock muxes, selecting PLL clock or xtal clk or whatever clocks, and those muxes are controlled by registers which are clocked.If the state of this register depends on a running clock, you'll never know if you can get a stable clock after power on and the chip may not boot up properly.Most of the flops in the chip not required to be with async reset, but some MUST be on async reset."
    }
]