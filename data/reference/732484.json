[
    {
        "link": "https://ibm.com/docs/en/aix/7.1?topic=s-strlen-strnlen-strchr-strrchr-strpbrk-strspn-strcspn-strstr-strtok-strsep-subroutine",
        "document": "Do not use the strtok subroutine in a multithreaded environment. Use the strtok_r subroutine instead.\n\nThe strlen, strnlen, strchr, strrchr, strpbrk, strspn, strcspn, strstr, and strtok subroutines determine such values as size, location, and the existence of strings in memory.\n\nThe String1, String2, and String parameters point to strings. A string is an array of characters terminated by a null character.\n\nThe strlen subroutine returns the number of bytes in the string pointed to by the String parameter, not including the terminating null bytes.\n\nThe strnlen function returns an integer containing the smaller of either the length of the string pointed to by String, or maxlen, not including the terminating null bytes.\n\nThe strchr subroutine returns a pointer to the first occurrence of the character specified by the Character (converted to an unsigned character) parameter in the string pointed to by the String parameter. A null pointer is returned if the character does not occur in the string. The null byte that terminates a string is considered to be part of the string.\n\nThe strrchr subroutine returns a pointer to the last occurrence of the character specified by the Character (converted to a character) parameter in the string pointed to by the String parameter. A null pointer is returned if the character does not occur in the string. The null byte that terminates a string is considered to be part of the string.\n\nThe strpbrk subroutine returns a pointer to the first occurrence in the string pointed to by the String1 parameter of any bytes from the string pointed to by the String2 parameter. A null pointer is returned if no bytes match.\n\nThe strspn subroutine returns the length of the initial segment of the string pointed to by the String1 parameter, which consists entirely of bytes from the string pointed to by the String2 parameter.\n\nThe strcspn subroutine returns the length of the initial segment of the string pointed to by the String1 parameter, which consists entirely of bytes not from the string pointed to by the String2 parameter.\n\nThe strstr subroutine finds the first occurrence in the string pointed to by the String1 parameter of the sequence of bytes specified by the string pointed to by the String2 parameter (excluding the terminating null character). It returns a pointer to the string found in the String1 parameter, or a null pointer if the string was not found. If the String2 parameter points to a string of 0 length, the strstr subroutine returns the value of the String1 parameter.\n\nThe strtok subroutine breaks the string pointed to by the String1 parameter into a sequence of tokens, each of which is delimited by a byte from the string pointed to by the String2 parameter. The first call in the sequence takes the String1 parameter as its first argument and is followed by calls that take a null pointer as their first argument. The separator string pointed to by the String2 parameter may be different from call to call.\n\nThe first call in the sequence searches the String1 parameter for the first byte that is not contained in the current separator string pointed to by the String2 parameter. If no such byte is found, no tokens exist in the string pointed to by the String1 parameter, and a null pointer is returned. If such a byte is found, it is the start of the first token.\n\nThe strtok subroutine then searches from the first token for a byte that is contained in the current separator string. If no such byte is found, the current token extends to the end of the string pointed to by the String1 parameter, and subsequent searches for a token return a null pointer. If such a byte is found, the strtok subroutine overwrites it with a null byte, which terminates the current token. The strtok subroutine saves a pointer to the following byte, from which the next search for a token will start. The subroutine returns a pointer to the first byte of the token.\n\nEach subsequent call with a null pointer as the value of the first argument starts searching from the saved pointer, using it as the first token. Otherwise, the subroutine's behavior does not change.\n\nThe strsep subroutine returns the next token from the string String1 which is delimited by String2. The token is terminated with a character and String1 is updated to point past the token. The strsep subroutine returns a pointer to the token, or NULL if String2 is not found in String1.\n\nThe index, rindex and strsep subroutines are included for compatibility with BSD and are not part of the ANSI C Library. The index subroutine is implemented as a call to the strchr subroutine. The rindex subroutine is implemented as a call to the strrchr subroutine."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/string/byte/strtok",
        "document": "A sequence of calls to breaks the string pointed to by str into a sequence of tokens, each of which is delimited by a character from the string pointed to by delim. Each call in the sequence has a search target ﻿:\n• If is non-null, the call is the first call in the sequence. The search target is null-terminated byte string pointed to by .\n• If is null, the call is one of the subsequent calls in the sequence. The search target is determined by the previous call in the sequence.\n\nEach call in the sequence searches the search target for the first character that is not contained in the separator string pointed to by delim, the separator string can be different from call to call.\n• If no such character is found, then there are no tokens in the search target. The search target for the next call in the sequence is unchanged.[1]\n• If such a character is found, it is the start of the current token. then searches from there for the first character that is contained in the separator string.\n• If no such character is found, the current token extends to the end of search target. The search target for the next call in the sequence is an empty string.[2]\n• If such a character is found, it is overwritten by a null character, which terminates the current token. The search target for the next call in the sequence starts from the following character.\n\nIf str or delim is not a pointer to a null-terminated byte string, the behavior is undefined.\n• A token may still be formed in a subsequent call with a different separator string.\n• No more tokens can be formed in subsequent calls.\n\nReturns a pointer to the first character of the next token, or a null pointer if there is no token.\n\nThis function is destructive: it writes the '\\0' characters in the elements of the string str. In particular, a string literal cannot be used as the first argument of .\n\nEach call to this function modifies a static variable: is not thread safe.\n\nUnlike most other tokenizers, the delimiters in can be different for each subsequent token, and can even depend on the contents of the previous tokens.\n\nActual C++ library implementations of this function delegate to the C library, where it may be implemented directly (as in MUSL libc), or in terms of its reentrant version (as in GNU libc)."
    },
    {
        "link": "https://geeksforgeeks.org/c-library-string-h",
        "document": "string.h is a standard header file in the C language that contains functions for manipulating strings (arrays of characters). <string.h> header file contains some useful string functions that can be directly used in a program by invoking the #include preprocessor directive.\n\n<string.h> header file contains the following functions:"
    },
    {
        "link": "https://en.cppreference.com/w/c/string/byte/strtok",
        "document": "If or is not a pointer to a null-terminated byte string, the behavior is undefined.\n\nIf both points to a character array which lacks the null character and points to a value which is greater than the size of that character array, the behavior is undefined.\n• A token may still be formed in a subsequent call with a different separator string.\n• No more tokens can be formed in subsequent calls.\n\nReturns a pointer to the first character of the next token, or a null pointer if there is no token.\n\nReturns a pointer to the first character of the next token, or a null pointer if there is no token or there is a runtime-constraint violation.\n\nThis function is destructive: it writes the '\\0' characters in the elements of the string str. In particular, a string literal cannot be used as the first argument of .\n\nEach call to modifies a static variable: is not thread safe.\n\nUnlike most other tokenizers, the delimiters in can be different for each subsequent token, and can even depend on the contents of the previous tokens.\n\nThe function differs from the POSIX function by guarding against storing outside of the string being tokenized, and by checking runtime constraints. The Microsoft CRT signature matches this POSIX definition, not the C11 ."
    },
    {
        "link": "https://w3schools.com/c/c_ref_string.php",
        "document": "The library has many functions that allow you to perform tasks on strings.\n\nA list of all string functions can be found in the table below:"
    },
    {
        "link": "https://geeksforgeeks.org/reverse-string-in-c",
        "document": "In C, reversing a string means rearranging the characters such that the last character becomes the first, the second-to-last character becomes the second, and so on. In this article, we will learn how to reverse string in C.\n\nThe most straightforward method to reverse string is by using two pointers to swap the corresponding characters starting from beginning and the end while moving the indexes towards each other till they meet each other.\n\nApart from the simple method mentioned above, there are few more methods which we can use to reverse the string. Some of them are:\n\nThe two-pointer approach can also be implemented using recursion. Just pass the left and the right index pointer as argument to the recursive function and move them towards each other in each recursive call.\n\nStore the reverse of string in a temporary array by traversing it from the back and copying each character to the other array. Then copy the reversed string from another array into the original string.\n\nIn C, strrev() defined inside <string.h> can be used to reverse a string. This function provides the simplest method to reverse the string."
    },
    {
        "link": "https://stackoverflow.com/questions/784417/reversing-a-string-in-c",
        "document": "If you want to practice advanced features of C, how about pointers? We can toss in macros and xor-swap for fun too!\n\nA pointer (e.g. , read from right-to-left as a pointer to a ) is a data type in C that is used to refer to location in memory of another value. In this case, the location where a is stored. We can dereference pointers by prefixing them with an , which gives us the value stored at that location. So the value stored at is .\n\nWe can do simple arithmetic with pointers. When we increment (or decrement) a pointer, we simply move it to refer to the next (or previous) memory location for that type of value. Incrementing pointers of different types may move the pointer by a different number of bytes because different values have different byte sizes in C.\n\nHere, we use one pointer to refer to the first unprocessed of the string ( ) and another to refer to the last ( ). We swap their values ( and ), and move the pointers inwards to the middle of the string. Once , either they both point to the same , which means our original string had an odd length (and the middle doesn't need to be reversed), or we've processed everything.\n\nTo do the swapping, I've defined a macro. Macros are text substitution done by the C preprocessor. They are very different from functions, and it's important to know the difference. When you call a function, the function operates on a copy of the values you give it. When you call a macro, it simply does a textual substitution - so the arguments you give it are used directly.\n\nSince I only used the macro once, it was probably overkill to define it, but it made more clear what I was doing. After the C preprocessor expands the macro, the while loop looks like this:\n\nNote that the macro arguments show up once for each time they're used in the macro definition. This can be very useful - but can also break your code if used incorrectly. For example, if I had compressed the increment/decrement instructions and the macro call into a single line, like\n\nThen this would expand to\n\nWhich has triple the increment/decrement operations, and doesn't actually do the swap it's supposed to do.\n\nWhile we're on the subject, you should know what xor ( ) means. It's a basic arithmetic operation - like addition, subtraction, multiplication, division, except it's not usually taught in elementary school. It combines two integers bit by bit - like addition, but we don't care about the carry-overs. , , , .\n\nA well known trick is to use xor to swap two values. This works because of three basic properties of xor: , and for all values and . So say we have two variables and that are initially storing two values and .\n\nSo the values are swapped. This does have one bug - when and are the same variable:\n\nSince we , this never happens in the above code, so we're okay.\n\nWhile we're concerned about correctness we should check our edge cases. The line should make sure we weren't given a pointer for string. What about the empty string ? Well , so we'll initialize as , which means that the condition is never true, so we don't do anything. Which is correct.\n\nThere's a bunch of C to explore. Have fun with it!\n\nUpdate: mmw brings up a good point, which is you do have to be slightly careful how you invoke this, as it does operate in-place.\n\nThis works fine, since is an array, whose contents are initialized to the given string constant. However\n\nWill cause your code to flame and die at runtime. That's because merely points to the string that is stored as part of your executable - which is normally memory that you are not allowed to edit by the OS. In a happier world, your compiler would know this, and cough an error when you tried to compile, telling you that needs to be of type since you can't modify the contents. However, this is not the world my compiler lives in.\n\nThere are some hacks you could try to make sure that some memory is on the stack or in the heap (and is therefore editable), but they're not necessarily portable, and it could be pretty ugly. However, I'm more than happy to throw responsibility for this to the function invoker. I've told them that this function does in place memory manipulation, it's their responsibility to give me an argument that allows that."
    },
    {
        "link": "https://geeksforgeeks.org/reverse-a-string",
        "document": "Given a string s, the task is to reverse the string. Reversing a string means rearranging the characters such that the first character becomes the last, the second character becomes second last and so on.\n\nInput: s = “GeeksforGeeks”\n\nOutput: “skeeGrofskeeG”\n\nExplanation : The first character G moves to last position, the second character e moves to second-last and so on. Input: s = “abdcfe”\n\nOutput: “efcdba”\n\nExplanation: The first character a moves to last position, the second character b moves to second-last and so on.\n\nUsing backward traversal – O(n) Time and O(n) Space\n\n// C++ program to reverse a string using backward traversal // and add each charecter to a new string // C program to reverse a string using backward traversal // and add each character to a new string // and add each character to a new string # and add each character to the list // C# program to reverse a string using backward traversal // and add each character to a new string // and add each character to the array\n\nTime Complexity: O(n) for backward traversal\n\nAuxiliary Space: O(n) for storing the reversed string.\n\nUsing Two Pointers – O(n) Time and O(n) Space\n\nThe idea is to maintain two pointers: left and right, such that left points to the beginning of the string and right points to the end of the string. While left pointer is less than the right pointer, swap the characters at these two positions. After each swap, increment the left pointer and decrement the right pointer to move towards the center of the string. This will swap all the characters in the first half with their corresponding character in the second half.\n\n// C++ program to reverse a string using two pointers // Swap characters from both ends till we reach // the middle of the string // C program to reverse a string using two pointers // Swap characters from both ends till we reach // the middle of the string // Java program to reverse a string using two pointers // Swap characters from both ends till we reach // the middle of the string # Python program to reverse a string using two pointers # Function to reverse a string using two pointers # Swap characters from both ends till we reach # the middle of the string // C# program to reverse a string using two pointers // Swap characters from both ends till we reach // the middle of the string // JavaScript program to reverse a string using two pointers // Swap characters from both ends till we reach // the middle of the string\n\nUsing Recursion – O(n) Time and O(n) Space\n\nTime Complexity: O(n) where n is length of string\n\nAuxiliary Space: O(n)\n\nUsing Stack – O(n) Time and O(n) Space\n\n// C++ program to reverse a string using stack // Pop the characters of stack into the original string // Pop the characters of stack into the original string # Pop the characters from stack into the reversed list # Join the list to form the reversed string // C# program to reverse a string using stack // Pop the characters from stack into the StringBuilder // To store the characters of the original string. // Push the characters into the stack. // Create an array to hold the reversed characters // Pop the characters of the stack and store in the array // Join the array to form the reversed string\n\nUsing Inbuilt methods – O(n) Time and O(1) Space\n\nTime Complexity: O(n)\n\nAuxiliary Space: O(1) in C++ and python and O(n) in Java, C# and JavaScript (extra space is used to store in array or list or StringBuilder for reversal)."
    },
    {
        "link": "https://stackoverflow.com/questions/27064485/manipulating-strings-in-c-with-user-input",
        "document": "I am working on a program for my comp sci classes and the problem asks to take a command from the user and the string that. Then, use either \"reverse \" to reverse the string that follows or \"create \" to print the string that follows. The reverse output should keep the words reverse, then print the string that follows in reverse.\n\nThe following function is used to reverse the word:\n\nThe output reverses all the words and prints. Is there a way to break off the reverse part of the string before it is passed to the reverse function?"
    },
    {
        "link": "https://bito.ai/resources/reverse-a-string-in-c-a-comprehensive-guide",
        "document": "Reversing a string is a fundamental operation in programming, and it is a common task that programmers encounter in various applications. Whether you are a beginner or an experienced C programmer, understanding how to reverse a string in C is essential. In this comprehensive guide, we will explore different methods and techniques to reverse a string in the C programming language.\n• Methods to Reverse a String in C\n• Choosing the Right Method for Your Needs\n\nReversing a string involves changing the order of characters in a given string from “left-to-right” to “right-to-left.” While it might seem like a simple task, it has various practical applications in programming:\n• Data Manipulation: Reversing a string can be useful in data manipulation tasks, such as parsing and formatting.\n• String Palindromes: Checking if a string is a palindrome (reads the same forwards and backwards) often requires reversing it.\n• Encryption: Some encryption algorithms involve reversing strings as part of their process.\n\nMethods to Reverse a String in C\n\nThere are several methods to reverse a string in C, each with its advantages and use cases. In this guide, we will explore three primary methods:\n• Using Iteration: This method involves using loops to iterate through the string and reverse it character by character.\n• Using Recursion: Recursion is a technique where a function calls itself to solve a problem. We’ll explore how to use recursion to reverse a string.\n• Using the Standard Library Function: The C Standard Library provides a built-in function, , in the header that can reverse a string.\n\nNow, let’s dive into these methods one by one.\n\nIn the iterative approach, we use a loop (such as a or loop) to traverse the string from the beginning to the end while simultaneously reversing it.\n\nHere’s a C code example that demonstrates the iterative approach to reverse a string:\n\nIn the recursive approach, we break down the string into smaller parts, recursively reverse those parts, and combine them to get the reversed string.\n\nHere’s a C code example that demonstrates the recursive approach to reverse a string:\n\nThe C Standard Library provides a convenient function called in the header, which can be used to reverse a string. This function directly modifies the input string.\n\nHere’s a C code example that demonstrates the use of :\n\nWhen choosing a method to reverse a string in C, consider the following performance factors:\n• Iterative Approach: This method is efficient and has a time complexity of O(n/2) because it processes only half of the characters.\n• Recursive Approach: While elegant, the recursive approach may consume more memory due to function call overhead. It’s not recommended for very long strings.\n• Standard Library Function ( ): Convenient, but not available in all C compilers. Also, it modifies the original string, which may not be desired in some scenarios.\n\nChoosing the Right Method for Your Needs\n\nThe choice of method depends on the specific requirements of your application:\n• If you need a simple and efficient solution, the iterative approach is a good choice.\n• If you want to explore recursion or need to reverse relatively short strings, the recursive approach can be used.\n• If you are working with a C compiler that supports and don’t mind modifying the original string, it provides a straightforward solution.\n\nWhen reversing strings, ensure that you handle the null terminator ( ) correctly. It should remain at the end of the reversed string to maintain proper string termination.\n\nIn the case of the recursive approach, be cautious about stack overflow errors when working with extremely long strings. Recursive function calls consume stack memory, and deep recursion can lead to program crashes.\n\nReversing a string in C is a fundamental programming task with practical applications in various domains. In this comprehensive guide, we explored three methods to reverse a string: iterative, recursive, and using the standard library function ( ). Each method has its advantages and considerations, allowing you to choose the one that best fits your project’s requirements.\n\nBy mastering the art of string reversal in C, you enhance your problem-solving skills and expand your repertoire of programming techniques. Whether you’re building data processing tools, working on algorithms, or simply honing your C programming skills, the ability to reverse strings is a valuable addition to your toolkit."
    }
]