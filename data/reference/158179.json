[
    {
        "link": "https://docs.python.org/3/library/zipfile.html",
        "document": "The ZIP file format is a common archive and compression standard. This module provides tools to create, read, write, append, and list a ZIP file. Any advanced use of this module will require an understanding of the format, as defined in PKZIP Application Note.\n\nThis module does not currently handle multi-disk ZIP files. It can handle ZIP files that use the ZIP64 extensions (that is ZIP files that are more than 4 GiB in size). It supports decryption of encrypted files in ZIP archives, but it currently cannot create an encrypted file. Decryption is extremely slow as it is implemented in native Python rather than C.\n\nThe module defines the following items:\n\nOpen a ZIP file, where file can be a path to a file (a string), a file-like object or a path-like object. The mode parameter should be to read an existing file, to truncate and write a new file, to append to an existing file, or to exclusively create and write a new file. If mode is and file refers to an existing file, a will be raised. If mode is and file refers to an existing ZIP file, then additional files are added to it. If file does not refer to a ZIP file, then a new ZIP archive is appended to the file. This is meant for adding a ZIP archive to another file (such as ). If mode is and the file does not exist at all, it is created. If mode is or , the file should be seekable. compression is the ZIP compression method to use when writing the archive, and should be , , or ; unrecognized values will cause to be raised. If , or is specified but the corresponding module ( , or ) is not available, is raised. The default is . If allowZip64 is (the default) zipfile will create ZIP files that use the ZIP64 extensions when the zipfile is larger than 4 GiB. If it is will raise an exception when the ZIP file would require ZIP64 extensions. The compresslevel parameter controls the compression level to use when writing files to the archive. When using or it has no effect. When using integers through are accepted (see for more information). When using integers through are accepted (see for more information). The strict_timestamps argument, when set to , allows to zip files older than 1980-01-01 at the cost of setting the timestamp to 1980-01-01. Similar behavior occurs with files newer than 2107-12-31, the timestamp is also set to the limit. When mode is , metadata_encoding may be set to the name of a codec, which will be used to decode metadata such as the names of members and ZIP comments. If the file is created with mode , or and then without adding any files to the archive, the appropriate ZIP structures for an empty archive will be written to the file. ZipFile is also a context manager and therefore supports the statement. In the example, myzip is closed after the statement’s suite is finished—even if an exception occurs: metadata_encoding is an instance-wide setting for the ZipFile. It is not currently possible to set this on a per-member basis. This attribute is a workaround for legacy implementations which produce archives with names in the current locale encoding or code page (mostly on Windows). According to the .ZIP standard, the encoding of metadata may be specified to be either IBM code page (default) or UTF-8 by a flag in the archive header. That flag takes precedence over metadata_encoding, which is a Python-specific extension. Changed in version 3.2: Added the ability to use as a context manager. Changed in version 3.3: Added support for and compression. Changed in version 3.4: ZIP64 extensions are enabled by default. Changed in version 3.5: Added support for writing to unseekable streams. Added support for the mode. Changed in version 3.6: Previously, a plain was raised for unrecognized compression values. Changed in version 3.11: Added support for specifying member name encoding for reading metadata in the zipfile’s directory and file headers. Close the archive file. You must call before exiting your program or essential records will not be written. Return a object with information about the archive member name. Calling for a name not currently contained in the archive will raise a . Return a list containing a object for each member of the archive. The objects are in the same order as their entries in the actual ZIP file on disk if an existing archive was opened. Return a list of archive members by name. Access a member of the archive as a binary file-like object. name can be either the name of a file within the archive or a object. The mode parameter, if included, must be (the default) or . pwd is the password used to decrypt encrypted ZIP files as a object. is also a context manager and therefore supports the statement: With mode the file-like object ( ) is read-only and provides the following methods: , , , , , , . These objects can operate independently of the ZipFile. With , a writable file handle is returned, which supports the method. While a writable file handle is open, attempting to read or write other files in the ZIP file will raise a . In both cases the file-like object has also attributes , which is equivalent to the name of a file within the archive, and , which is or depending on the input mode. When writing a file, if the file size is not known in advance but may exceed 2 GiB, pass to ensure that the header format is capable of supporting large files. If the file size is known in advance, construct a object with set, and use that as the name parameter. The , and methods can take a filename or a object. You will appreciate this when trying to read a ZIP file that contains members with duplicate names. Changed in version 3.6: Removed support of . Use for reading compressed text files in universal newlines mode. Changed in version 3.6: can now be used to write files into the archive with the option. Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Changed in version 3.13: Added attributes and for the writeable file-like object. The value of the attribute for the readable file-like object was changed from to . Extract a member from the archive to the current working directory; member must be its full name or a object. Its file information is extracted as accurately as possible. path specifies a different directory to extract to. member can be a filename or a object. pwd is the password used for encrypted files as a object. Returns the normalized path created (a directory or new file). If a member filename is an absolute path, a drive/UNC sharepoint and leading (back)slashes will be stripped, e.g.: becomes on Unix, and becomes on Windows. And all components in a member filename will be removed, e.g.: becomes . On Windows illegal characters ( , , , , , , and ) replaced by underscore ( ). Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Extract all members from the archive to the current working directory. path specifies a different directory to extract to. members is optional and must be a subset of the list returned by . pwd is the password used for encrypted files as a object. Never extract archives from untrusted sources without prior inspection. It is possible that files are created outside of path, e.g. members that have absolute filenames starting with or filenames with two dots . This module attempts to prevent that. See note. Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Print a table of contents for the archive to . Return the bytes of the file name in the archive. name is the name of the file in the archive, or a object. The archive must be open for read or append. pwd is the password used for encrypted files as a object and, if specified, overrides the default password set with . Calling on a ZipFile that uses a compression method other than , , or will raise a . An error will also be raised if the corresponding compression module is not available. Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Read all the files in the archive and check their CRC’s and file headers. Return the name of the first bad file, or else return . Changed in version 3.6: Calling on a closed ZipFile will raise a . Previously, a was raised. Write the file named filename to the archive, giving it the archive name arcname (by default, this will be the same as filename, but without a drive letter and with leading path separators removed). If given, compress_type overrides the value given for the compression parameter to the constructor for the new entry. Similarly, compresslevel will override the constructor if given. The archive must be open with mode , or . The ZIP file standard historically did not specify a metadata encoding, but strongly recommended CP437 (the original IBM PC encoding) for interoperability. Recent versions allow use of UTF-8 (only). In this module, UTF-8 will automatically be used to write the member names if they contain any non-ASCII characters. It is not possible to write member names in any encoding other than ASCII or UTF-8. Archive names should be relative to the archive root, that is, they should not start with a path separator. If (or , if is not given) contains a null byte, the name of the file in the archive will be truncated at the null byte. A leading slash in the filename may lead to the archive being impossible to open in some zip programs on Windows systems. Changed in version 3.6: Calling on a ZipFile created with mode or a closed ZipFile will raise a . Previously, a was raised. Write a file into the archive. The contents is data, which may be either a or a instance; if it is a , it is encoded as UTF-8 first. zinfo_or_arcname is either the file name it will be given in the archive, or a instance. If it’s an instance, at least the filename, date, and time must be given. If it’s a name, the date and time is set to the current date and time. The archive must be opened with mode , or . If given, compress_type overrides the value given for the compression parameter to the constructor for the new entry, or in the zinfo_or_arcname (if that is a instance). Similarly, compresslevel will override the constructor if given. When passing a instance as the zinfo_or_arcname parameter, the compression method used will be that specified in the compress_type member of the given instance. By default, the constructor sets this member to . Changed in version 3.6: Calling on a ZipFile created with mode or a closed ZipFile will raise a . Previously, a was raised. Create a directory inside the archive. If zinfo_or_directory is a string, a directory is created inside the archive with the mode that is specified in the mode argument. If, however, zinfo_or_directory is a instance then the mode argument is ignored. The archive must be opened with mode , or . The following data attributes are also available: The level of debug output to use. This may be set from (the default, no output) to (the most output). Debugging information is written to . The comment associated with the ZIP file as a object. If assigning a comment to a instance created with mode , or , it should be no longer than 65535 bytes. Comments longer than this will be truncated.\n\nConstruct a Path object from a zipfile (which may be a instance or suitable for passing to the constructor). specifies the location of this Path within the zipfile, e.g. ‘dir/file.txt’, ‘dir/’, or ‘’. Defaults to the empty string, indicating the root. The class does not sanitize filenames within the ZIP archive. Unlike the and methods, it is the caller’s responsibility to validate or sanitize filenames to prevent path traversal vulnerabilities (e.g., filenames containing “..” or absolute paths). When handling untrusted archives, consider resolving filenames using and checking against the target directory with . Path objects expose the following features of objects: Path objects are traversable using the operator or . Invoke on the current path. Allows opening for read or write, text or binary through supported modes: ‘r’, ‘w’, ‘rb’, ‘wb’. Positional and keyword arguments are passed through to when opened as text and ignored otherwise. is the parameter to . Changed in version 3.9: Added support for text and binary modes for open. Default mode is now text. Changed in version 3.11.2: The parameter can be supplied as a positional argument without causing a . As it could in 3.9. Code needing to be compatible with unpatched 3.10 and 3.11 versions must pass all arguments, included, as keywords. Enumerate the children of the current directory. Return if the current context references a file or directory in the zip file. The last dot-separated portion of the final component, if any. This is commonly called the file extension. The final path component, without its suffix. Read the current file as unicode text. Positional and keyword arguments are passed through to (except , which is implied by the context). Changed in version 3.11.2: The parameter can be supplied as a positional argument without causing a . As it could in 3.9. Code needing to be compatible with unpatched 3.10 and 3.11 versions must pass all arguments, included, as keywords. Return a new Path object with each of the other arguments joined. The following are equivalent: Changed in version 3.10: Prior to 3.10, was undocumented and accepted exactly one parameter. The zipp project provides backports of the latest path object functionality to older Pythons. Use in place of for early access to changes.\n\nThe module provides a simple command-line interface to interact with ZIP archives. If you want to create a new ZIP archive, specify its name after the option and then list the filename(s) that should be included: If you want to extract a ZIP archive into the specified directory, use the option: For a list of the files in a ZIP archive, use the option: Test whether the zipfile is valid or not. Specify encoding of member names for , and .\n\nThe extraction in zipfile module might fail due to some pitfalls listed below. Decompression may fail due to incorrect password / CRC checksum / ZIP format or unsupported compression method / decryption. Exceeding limitations on different file systems can cause decompression failed. Such as allowable characters in the directory entries, length of the file name, length of the pathname, size of a single file, and number of files, etc. The lack of memory or disk volume would lead to decompression failed. For example, decompression bombs (aka ZIP bomb) apply to zipfile library that can cause disk volume exhaustion. Interruption during the decompression, such as pressing control-C or killing the decompression process may result in incomplete decompression of the archive. Not knowing the default extraction behaviors can cause unexpected decompression results. For example, when extracting the same archive twice, it overwrites files without asking."
    },
    {
        "link": "https://realpython.com/python-zipfile",
        "document": "Python’s module allows you to efficiently manipulate ZIP files, a standard format for compressing and archiving data. With this module, you can create, read, write, extract, and list files within ZIP archives.\n\nBy the end of this tutorial, you’ll understand that:\n• You can extract specific files or all contents from a ZIP archive using .\n• Reading metadata about ZIP contents is straightforward with .\n• You can compress files in ZIP archives using different algorithms.\n• allows you to bundle Python modules and packages into ZIP files for distribution.\n\nThis tutorial teaches you how to handle ZIP files using Python’s , making file management and data exchange over networks more efficient. Understanding these concepts will enhance your ability to work with compressed files in Python, optimizing both data storage and transfer.\n\nTo get the most out of this tutorial, you should know the basics of working with files, using the statement, handling file system paths with , and working with classes and object-oriented programming.\n\nTo get the files and archives that you’ll use to code the examples in this tutorial, click the link below:\n\nZIP files are a well-known and popular tool in today’s digital world. These files are fairly popular and widely used for cross-platform data exchange over computer networks, notably the Internet. You can use ZIP files for bundling regular files together into a single archive, compressing your data to save some disk space, distributing your digital products, and more. In this tutorial, you’ll learn how to manipulate ZIP files using Python’s module. Because the terminology around ZIP files can be confusing at times, this tutorial will stick to the following conventions regarding terminology: A physical file that uses the ZIP file format A file that is part of an existing ZIP file Having these terms clear in your mind will help you avoid confusion while you read through the upcoming sections. Now you’re ready to continue learning how to manipulate ZIP files efficiently in your Python code! You’ve probably already encountered and worked with ZIP files. Yes, those with the file extension are everywhere! ZIP files, also known as ZIP archives, are files that use the ZIP file format. PKWARE is the company that created and first implemented this file format. The company put together and maintains the current format specification, which is publicly available and allows the creation of products, programs, and processes that read and write files using the ZIP file format. The ZIP file format is a cross-platform, interoperable file storage and transfer format. It combines lossless data compression, file management, and data encryption. Data compression isn’t a requirement for an archive to be considered a ZIP file. So you can have compressed or uncompressed member files in your ZIP archives. The ZIP file format supports several compression algorithms, though Deflate is the most common. The format also supports information integrity checks with CRC32. Even though there are other similar archiving formats, such as RAR and TAR files, the ZIP file format has quickly become a common standard for efficient data storage and for data exchange over computer networks. ZIP files are everywhere. For example, office suites such as Microsoft Office and Libre Office rely on the ZIP file format as their document container file. This means that , , , , , and files are actually ZIP archives containing several files and folders that make up each document. Other common files that use the ZIP format include , , and files. You may be familiar with GitHub, which provides web hosting for software development and version control using Git. GitHub uses ZIP files to package software projects when you download them to your local computer. For example, you can download the exercise solutions for Python Basics: A Practical Introduction to Python 3 book in a ZIP file, or you can download any other project of your choice. ZIP files allow you to aggregate, compress, and encrypt files into a single interoperable and portable container. You can stream ZIP files, split them into segments, make them self-extracting, and more. Knowing how to create, read, write, and extract ZIP files can be a useful skill for developers and professionals who work with computers and digital information. Among other benefits, ZIP files allow you to:\n• Reduce the size of files and their storage requirements without losing information\n• Improve transfer speed over the network due to reduced size and single-file transfer\n• Pack several related files together into a single archive for efficient management\n• Bundle your code into a single archive for distribution purposes\n• Secure your data by using encryption, which is a common requirement nowadays\n• Guarantee the integrity of your information to avoid accidental and malicious changes to your data These features make ZIP files a useful addition to your Python toolbox if you’re looking for a flexible, portable, and reliable way to archive your digital files. Yes! Python has several tools that allow you to manipulate ZIP files. Some of these tools are available in the Python standard library. They include low-level libraries for compressing and decompressing data using specific compression algorithms, such as , , , and others. Python also provides a high-level module called specifically designed to create, read, write, extract, and list the content of ZIP files. In this tutorial, you’ll learn about Python’s and how to use it effectively.\n\nPython’s provides convenient classes and functions that allow you to create, read, write, extract, and list the content of your ZIP files. Here are some additional features that supports:\n• Several compression algorithms, such as Deflate, Bzip2, and LZMA Be aware that does have a few limitations. For example, the current data decryption feature can be pretty slow because it uses pure Python code. The module can’t handle the creation of encrypted ZIP files. Finally, the use of multi-disk ZIP files isn’t supported either. Despite these limitations, is still a great and useful tool. Keep reading to explore its capabilities. In the module, you’ll find the class. This class works pretty much like Python’s built-in function, allowing you to open your ZIP files using different modes. The read mode ( ) is the default. You can also use the write ( ), append ( ), and exclusive ( ) modes. You’ll learn more about each of these in a moment. implements the context manager protocol so that you can use the class in a statement. This feature allows you to quickly open and work with a ZIP file without worrying about closing the file after you finish your work. Before writing any code, make sure you have a copy of the files and archives that you’ll be using: Get Materials: Click here to get a copy of the files and archives that you’ll use to run the examples in this zipfile tutorial. To get your working environment ready, place the downloaded resources into a directory called in your home folder. Once you have the files in the right place, move to the newly created directory and fire up a Python interactive session there. To warm up, you’ll start by reading the ZIP file called . To do that, you can use in reading mode: The first argument to the initializer of can be a string representing the path to the ZIP file that you need to open. This argument can accept file-like and path-like objects too. In this example, you use a string-based path. The second argument to is a single-letter string representing the mode that you’ll use to open the file. As you learned at the beginning of this section, can accept four possible modes, depending on your needs. The positional argument defaults to , so you can get rid of it if you want to open the archive for reading only. Inside the statement, you call on . The variable now holds the instance of itself. This function provides a quick way to display the content of the underlying ZIP file on your screen. The function’s output has a user-friendly tabular format with three informative columns: If you want to make sure that you’re targeting a valid ZIP file before you try to open it, then you can wrap in a … statement and catch any exception: The first example successfully opens without raising a exception. That’s because has a valid ZIP format. On the other hand, the second example doesn’t succeed in opening , because the file is not a valid ZIP file. To check for a valid ZIP file, you can also use the function: In these examples, you use a conditional statement with as a condition. This function takes a argument that holds the path to a ZIP file in your file system. This argument can accept string, file-like, or path-like objects. The function returns if is a valid ZIP file. Otherwise, it returns . Now say you want to add to a archive using . To do that, you can use the write mode ( ). This mode opens a ZIP file for writing. If the target ZIP file exists, then the mode truncates it and writes any new content you pass in. Note: If you’re using with existing files, then you should be careful with the mode. You can truncate your ZIP file and lose all the original content. If the target ZIP file doesn’t exist, then creates it for you when you close the archive: After running this code, you’ll have a file in your directory. If you list the file content using , then you’ll notice that will be there. In this example, you call on the object. This method allows you to write member files into your ZIP archives. Note that the argument to should be an existing file. Note: is smart enough to create a new archive when you use the class in writing mode and the target archive doesn’t exist. However, the class doesn’t create new directories in the path to the target ZIP file if those directories don’t already exist. That explains why the following code won’t work: : [Errno 2] No such file or directory: 'missing/hello.zip' Because the directory in the path to the target file doesn’t exist, you get a exception. The append mode ( ) allows you to append new member files to an existing ZIP file. This mode doesn’t truncate the archive, so its original content is safe. If the target ZIP file doesn’t exist, then the mode creates a new one for you and then appends any input files that you pass as an argument to . To try out the mode, go ahead and add the file to your newly created archive: Here, you use the append mode to add to the file. Then you run to confirm that the new file is present in the ZIP file. also supports an exclusive mode ( ). This mode allows you to exclusively create new ZIP files and write new member files into them. You’ll use the exclusive mode when you want to make a new ZIP file without overwriting an existing one. If the target file already exists, then you get . Finally, if you create a ZIP file using the , , or mode and then close the archive without adding any member files, then creates an empty archive with the appropriate ZIP format. You’ve already put into action. It’s a useful method that you can use to list the content of your ZIP files quickly. Along with , the class provides several handy methods for extracting metadata from existing ZIP files. Returns a object with information about the member file provided by . Note that must hold the path to the target file inside the underlying ZIP file. Returns a list of objects, one per member file. Returns a list holding the names of all the member files in the underlying archive. The names in this list are valid arguments to . With these three tools, you can retrieve a lot of useful information about the content of your ZIP files. For example, take a look at the following example, which uses : As you learned in the table above, takes a member file as an argument and returns a object with information about it. Note: isn’t intended to be instantiated directly. The and methods return objects automatically when you call them. However, includes a class method called , which allows you to instantiate the class explicitly if you ever need to do it. objects have several attributes that allow you to retrieve valuable information about the target member file. For example, and hold the size, in bytes, of the original and compressed files, respectively. The class also has some other useful attributes, such as and , which return the filename and the last modification date. Note: By default, doesn’t compress the input files to add them to the final archive. That’s why the size and the compressed size are the same in the above example. You’ll learn more about this topic in the Compressing Files and Directories section below. With , you can extract information from all the files in a given archive. Here’s an example that uses this method to generate a minimal report with information about all the member files in your archive: The loop iterates over the objects from , retrieving the filename, the last modification date, the normal size, and the compressed size of each member file. In this example, you’ve used to format the date in a human-readable way. Note: The example above was adapted from zipfile — ZIP Archive Access. If you just need to perform a quick check on a ZIP file and list the names of its member files, then you can use : Because the filenames in this output are valid arguments to , you can combine these two methods to retrieve information about selected member files only. For example, you may have a ZIP file containing different types of member files ( , , , and so on). Instead of getting the complete information with , you just need to get the information about the files. Then you can filter the files by their extension and call on your files only. Go ahead and give it a try! Reading From and Writing to Member Files Sometimes you have a ZIP file and need to read the content of a given member file without extracting it. To do that, you can use . This method takes a member file’s and returns that file’s content as bytes: To use , you need to open the ZIP file for reading or appending. Note that returns the content of the target file as a stream of bytes. In this example, you use to split the stream into lines, using the line feed character as a separator. Because is operating on a byte object, you need to add a leading to the string used as an argument. also accepts a second positional argument called . This argument allows you to provide a password for reading encrypted files. To try this feature, you can rely on the file that you downloaded with the material for this tutorial: In the first example, you provide the password to read your encrypted file. The argument accepts values of the bytes type. If you use on an encrypted file without providing the required password, then you get a , as you can note in the second example. Note: Python’s supports decryption. However, it doesn’t support the creation of encrypted ZIP files. That’s why you would need to use an external file archiver to encrypt your files. Some popular file archivers include 7z and WinRAR for Windows, Ark and GNOME Archive Manager for Linux, and Archiver for macOS. For large encrypted ZIP files, keep in mind that the decryption operation can be extremely slow because it’s implemented in pure Python. In such cases, consider using a specialized program to handle your archives instead of using . If you regularly work with encrypted files, then you may want to avoid providing the decryption password every time you call or another method that accepts a argument. If that’s the case, you can use to set a global password: With , you just need to provide your password once. uses that unique password for decrypting all the member files. In contrast, if you have ZIP files with different passwords for individual member files, then you need to provide the specific password for each file using the argument of : In this example, you use as a password to read and to read . A final detail to consider is that when you use the argument, you’re overriding whatever archive-level password you may have set with . Note: Calling on a ZIP file that uses an unsupported compression method raises a . You also get an error if the required compression module isn’t available in your Python installation. If you’re looking for a more flexible way to read from member files and create and add new member files to an archive, then is for you. Like the built-in function, this method implements the context manager protocol, and therefore it supports the statement: In this example, you open for reading. The first argument to is , indicating the member file that you want to open. The second argument is the mode, which defaults to as usual. also accepts a argument for opening encrypted files. This argument works the same as the equivalent argument in . You can also use with the mode. This mode allows you to create a new member file, write content to it, and finally append the file to the underlying archive, which you should open in append mode: In the first code snippet, you open in append mode ( ). Then you create by calling with the mode. This function returns a file-like object that supports , which allows you to write bytes into the newly created file. Note: You need to supply a non-existing filename to . If you use a filename that already exists in the underlying archive, then you’ll end up with a duplicated file and a exception. In this example, you write into . When the execution flow exits the inner statement, Python writes the input bytes to the member file. When the outer statement exits, Python writes to the underlying ZIP file, . The second code snippet confirms that is now a member file of . A detail to notice in the output of this example is that sets the date of the newly added file to , which is a weird behavior that you should keep in mind when using this method. Reading the Content of Member Files as Text As you learned in the above section, you can use the and methods to read from and write to member files without extracting them from the containing ZIP archive. Both of these methods work exclusively with bytes. However, when you have a ZIP archive containing text files, you may want to read their content as text instead of as bytes. There are at least two way to do this. You can use: Because returns the content of the target member file as bytes, can operate on these bytes directly. The method decodes a object into a string using a given character encoding format. Here’s how you can use to read text from the file in your archive: In this example, you read the content of as bytes. Then you call to decode the bytes into a string using UTF-8 as encoding. To set the argument, you use the string. However, you can use any other valid encoding, such as UTF-16 or cp1252, which can be represented as case-insensitive strings. Note that is the default value of the argument to . It’s important to keep in mind that you need to know beforehand the character encoding format of any member file that you want to process using . If you use the wrong character encoding, then your code will fail to correctly decode the underlying bytes into text, and you can end up with a ton of indecipherable characters. The second option for reading text out of a member file is to use an object, which provides a buffered text stream. This time you need to use instead of . Here’s an example of using to read the content of the member file as a stream of text: In the inner statement in this example, you open the member file from your archive. Then you pass the resulting binary file-like object, , as an argument to . This creates a buffered text stream by decoding the content of using the UTF-8 character encoding format. As a result, you get a stream of text directly from your target member file. Just like with , the class takes an argument. You should always specify a value for this argument because the default text encoding depends on the system running the code and may not be the right value for the file that you’re trying to decode. Extracting the content of a given archive is one of the most common operations that you’ll do on ZIP files. Depending on your needs, you may want to extract a single file at a time or all the files in one go. allows you to accomplish the first task. This method takes the name of a file and extracts it to a given directory signaled by . The destination defaults to the current directory: Now will be in your directory. If the target filename already exists in the output directory, then overwrites it without asking for confirmation. If the output directory doesn’t exist, then creates it for you. Note that returns the path to the extracted file. The name of the member file must be the file’s full name as returned by . It can also be a object containing the file’s information. You can also use with encrypted files. In that case, you need to provide the required argument or set the archive-level password with . When it comes to extracting all the member files from an archive, you can use . As its name implies, this method extracts all the member files to a destination path, which is the current directory by default: After running this code, all the current content of will be in your directory. If you pass a non-existing directory to , then this method automatically creates the directory. Finally, if any of the member files already exist in the destination directory, then will overwrite them without asking for your confirmation, so be careful. If you only need to extract some of the member files from a given archive, then you can use the argument. This argument accepts a list of member files, which should be a subset of the whole list of files in the archive at hand. Finally, just like , the method also accepts a argument to extract encrypted files. Sometimes, it’s convenient for you to open a given ZIP file without using a statement. In those cases, you need to manually close the archive after use to complete any writing operations and to free the acquired resources. To do that, you can call on your object: # Use archive in different parts of your code # Close the archive when you're done The call to closes for you. You must call before exiting your program. Otherwise, some writing operations might not be executed. For example, if you open a ZIP file for appending ( ) new member files, then you need to close the archive to write the files.\n\nCreating, Populating, and Extracting Your Own ZIP Files So far, you’ve learned how to work with existing ZIP files. You’ve learned to read, write, and append member files to them by using the different modes of . You’ve also learned how to read relevant metadata and how to extract the content of a given ZIP file. In this section, you’ll code a few practical examples that’ll help you learn how to create ZIP files from several input files and from an entire directory using and other Python tools. You’ll also learn how to use for file compression and more. Sometimes you need to create a ZIP archive from several related files. This way, you can have all the files in a single container for distributing them over a computer network or sharing them with friends or colleagues. To this end, you can create a list of target files and write them into an archive using and a loop: Here, you create a object with the desired archive name as its first argument. The mode allows you to write member files into the final ZIP file. The loop iterates over your list of input files and writes them into the underlying ZIP file using . Once the execution flow exits the statement, automatically closes the archive, saving the changes for you. Now you have a archive containing all the files from your original list of files. Bundling the content of a directory into a single archive is another everyday use case for ZIP files. Python has several tools that you can use with to approach this task. For example, you can use to read the content of a given directory. With that information, you can create a container archive using . In the directory, you have a subdirectory called , with the following content: In , you only have three regular files. Because the directory doesn’t contain subdirectories, you can use to iterate over its content directly. With this idea in mind, here’s how you can build a ZIP file from the content of : In this example, you create a object from your source directory. The first statement creates a object ready for writing. Then the call to returns an iterator over the entries in the underlying directory. Because you don’t have any subdirectories in , the function yields only files. The loop iterates over the files and writes them into the archive. In this case, you pass to the second argument of . This argument is called and holds the name of the member file inside the resulting archive. All the examples that you’ve seen so far rely on the default value of , which is the same filename you pass as the first argument to . If you don’t pass to , then your source directory will be at the root of your ZIP file, which can also be a valid result depending on your needs. Now check out the folder in your working directory. In this case, you’ll find the following structure: You have the usual files and a subdirectory with a single file in it. If you want to create a ZIP file with this same internal structure, then you need a tool that recursively iterates through the directory tree under . Here’s how to zip a complete directory tree, like the one above, using along with from the module: In this example, you use to recursively traverse the directory tree under . Then you write every file and subdirectory to the target ZIP archive. This time, you use to get the relative path to each file and then pass the result to the second argument of . This way, the resulting ZIP file ends up with the same internal structure as your original source directory. Again, you can get rid of this argument if you want your source directory to be at the root of your ZIP file. If your files are taking up too much disk space, then you might consider compressing them. Python’s supports a few popular compression methods. However, the module doesn’t compress your files by default. If you want to make your files smaller, then you need to explicitly supply a compression method to . Typically, you’ll use the term stored to refer to member files written into a ZIP file without compression. That’s why the default compression method of is called ZIP_STORED, which actually refers to uncompressed member files that are simply stored in the containing archive. The method is the third argument to the initializer of . If you want to compress your files while you write them into a ZIP archive, then you can set this argument to one of the following constants: These are the compression methods that you can currently use with . A different method will raise a . There are no additional compression methods available to as of Python 3.13. As an additional requirement, if you choose one of these methods, then the compression module that supports it must be available in your Python installation. Otherwise, you’ll get a exception, and your code will break. Another relevant argument of when it comes to compressing your files is . This argument controls which compression level you use. With the Deflate method, can take integer numbers from through . With the Bzip2 method, you can pass integers from through . In both cases, when the compression level increases, you get higher compression and lower compression speed. Note: Binary files, such as PNG, JPG, MP3, and the like, already use some kind of compression. As a result, adding them to a ZIP file may not make the data any smaller, because it’s already compressed to some level. Now say you want to archive and compress the content of a given directory using the Deflate method, which is the most commonly used method in ZIP files. To do that, you can run the following code: In this example, you pass to to get maximum compression. To provide this argument, you use a keyword argument. You need to do this because isn’t the fourth positional argument to the initializer. Note: The initializer of takes a fourth argument called . It’s a Boolean argument that tells to create ZIP files with the extension for files larger than 4 GB. After running this code, you’ll have a file in your current directory. If you compare the size of that file with the size of your original file, then you’ll note a significant size reduction. Creating ZIP files sequentially can be another common requirement in your day-to-day programming. For example, you may need to create an initial ZIP file with or without content and then append new member files as soon as they become available. In this situation, you need to open and close the target ZIP file multiple times. To solve this problem, you can use in append mode ( ), as you have already done. This mode allows you to safely append new member files to a ZIP archive without truncating its current content: In this example, is a function that appends a file ( ) to the input ZIP archive ( ). To perform this action, the function opens and closes the target archive every time you call it. Using a function to perform this task allows you to reuse the code as many times as you need. The function is a generator function simulating a stream of files to process. Meanwhile, the loop sequentially adds member files to using . If you check your working directory after running this code, then you’ll find an archive containing the three files that you passed into the loop. One of the most common operations you’ll ever perform on ZIP files is to extract their content to a given directory in your file system. You already learned the basics of using and to extract one or all the files from an archive. As an additional example, get back to your file. At this point, the archive contains four files of different types. You have two files and two files. Now say you want to extract only the files. To do so, you can run the following code: The statement opens for reading. The loop iterates over each file in the archive using , while the conditional statement checks if the filename ends with the extension. If it does, then you extract the file at hand to a target directory, , using .\n\nSo far, you’ve learned about and , which are two of the classes available in . This module also provides two more classes that can be handy in some situations. Those classes are and . In the following two sections, you’ll learn the basics of these classes and their main features. When you open a ZIP file with your favorite archiver application, you see the archive’s internal structure. You may have files at the root of the archive. You may also have subdirectories with more files. The archive looks like a normal directory on your file system, with each file located at a specific path. The class allows you to construct path objects to quickly create and manage paths to member files and directories inside a given ZIP file. The class takes two arguments:\n• accepts a ZIP file, either as a object or a string-based path to a physical ZIP file.\n• holds the location of a specific member file or directory inside the archive. It defaults to the empty string, representing the root of the archive. With your old friend as the target, run the following code: This code shows that implements several features that are common to a object. You can get the name of the file with . You can check if the path points to a regular file with . You can check if a given file exists inside a particular ZIP file, and more. also provides an method to open a member file using different modes. For example, the code below opens for reading: With , you can quickly create a path object pointing to a specific member file in a given ZIP file and access its content immediately using . Just like with a object, you can list the content of a ZIP file by calling on a object: It’s clear that provides many useful features that you can use to manage member files in your ZIP archives in almost no time. Another useful class in is . This class is pretty similar to , and it’s especially handy when you need to bundle Python modules and packages into ZIP files. The main difference from is that the initializer of takes an optional argument called , which allows you to optimize the Python code by compiling it to bytecode before archiving it. provides the same interface as , with the addition of . This method can take a Python file ( ) as an argument and add it to the underlying ZIP file. If is (the default), then the file is automatically compiled to a file and then added to the target archive. Why does this happen? Since version 2.3, the Python interpreter has supported importing Python code from ZIP files, a capability known as Zip imports. This feature is quite convenient. It allows you to create importable ZIP files to distribute your modules and packages as a single archive. Note: You can also use the ZIP file format to create and distribute Python executable applications, which are commonly known as Python Zip applications. To learn how to create them, check out Python’s zipapp: Build Executable Zip Applications. is helpful when you need to generate importable ZIP files. Packaging the file rather than the file makes the importing process way more efficient because it skips the compilation step. Inside the directory, you have a module with the following content: This code defines a function called , which takes as an argument and prints a greeting message to the screen. Now say you want to package this module into a ZIP file for distribution purposes. To do that, you can run the following code: In this example, the call to automatically compiles to and stores it in . This becomes clear when you list the archive’s content using . Once you have bundled into a ZIP file, then you can use Python’s import system to import this module from its containing archive: # Import and use the code Hello, Pythonista! Welcome to Real Python! The first step to import code from a ZIP file is to make that file available in . This variable holds a list of strings that specifies Python’s search path for modules. To add a new item to , you can use . For this example to work, you need to change the placeholder path and pass the path to on your file system. Once your importable ZIP file is in this list, then you can import your code just like you’d do with a regular module. Finally, consider the subdirectory in your working folder. It contains a small Python package with the following structure: The module turns the directory into a Python package. The module is the same one that you used in the example above. Now suppose you want to bundle this package into a ZIP file. If that’s the case, then you can do the following: The call to takes the package as an argument, searches for files inside it, compiles them to files, and finally adds them to the target ZIP file, . Again, you can import your code from this archive by following the steps that you learned before: Hello, Pythonista! Welcome to Real Python! Because your code is in a package now, you first need to import the module from the package. Then you can access your function normally."
    },
    {
        "link": "https://datacamp.com/tutorial/zip-file",
        "document": "Master the basics of data analysis with Python in just four hours. This online course will introduce the Python interface and explore popular packages."
    },
    {
        "link": "https://geeksforgeeks.org/unzipping-files-in-python",
        "document": "In this article we will see how to unzip the files in python we can achieve this functionality by using zipfile module in Python.\n\nZIP file is a file format that is used for compressing multiple files together into a single file. It is used in an archive file format that supports lossless data compression and reduces storage requirements it also improves data transfer over standard connections. Zip files make the task of sharing multiple files easy by comprising them into one. The ZipFile class contains extractall() and extract() methods which are used for unzipping the files.\n\nThe extractall() method is used to extract all the files present in the zip file to the current working directory. Files can also be extracted to a different location bypassing the path parameter.\n\nThe extract() method is used to Extract a member from the zip to the current working directory. The file can also be extracted to a different location bypassing the path parameter.\n\nExample 1: Extracting all the files present in the zip\n\nImport the zipfile module Create a zip file object using ZipFile class. Call the extractall() method on zip file object and pass the path where the files needed to be extracted and Extracting the specific file present in the zip.\n\nExample 2: Extracting the specific file present in the zip\n\nImport the zipfile module Create a zip file object using ZipFile class. Call the extract() method on the zip file object and pass the name of the file to be extracted and the path where the file needed to be extracted and Extracting the specific file present in the zip."
    },
    {
        "link": "https://ioflood.com/blog/python-unzip",
        "document": "Ever found yourself stuck with a zipped file in Python? You’re not alone. Many developers find themselves in a similar situation, but Python, just like a skilled locksmith, can unlock the contents of zipped files with ease.\n\nPython’s built-in libraries offer a robust set of tools to handle file compression and decompression, making it a go-to language for such tasks. From handling simple .zip files to dealing with more complex formats like .tar, .gz, and .rar, Python has got you covered.\n\nIn this guide, we’ll walk you through the process of unzipping files in Python, from the basics to more advanced techniques. We’ll cover everything from using the module, handling different types of zipped files, to troubleshooting common issues and exploring alternative approaches.\n\nSo, let’s dive in and start mastering Python unzip!\n\nTL;DR: How Do I Unzip Files in Python?\n\nIn this example, we import the module and use the class to open the zip file in read mode (‘r’). We then call the method to extract all files from the zip file.\n\nPython’s module is a versatile tool for working with zip files. It provides classes and methods that allow you to create, read, write, append, and list a ZIP file. For the purpose of this guide, we’ll focus on how to use it to unzip files.\n\nHere’s a simple example of how to use the module to unzip a file:\n\nIn this code block, we first import the module. We then use the class from the module to open the zip file in read mode (‘r’). The statement ensures that the file is properly closed after it is no longer needed. The method is used to extract all files from the zip file to the current working directory.\n\nThe main advantage of using the module is that it is part of Python’s standard library. This means you don’t have to install any additional packages to use it. It’s also easy to use and provides a high level of control over zip file operations.\n\nHowever, the module has its limitations. For one, it can only handle zip files. If you need to work with other types of compressed files (like .tar or .gz), you’ll need to use other modules or third-party libraries. Additionally, while the module can handle large files, it can be slow if you’re working with very large zip files.\n\nPython’s built-in modules can handle a variety of compressed file formats. Beyond the standard .zip files, Python can also handle .tar, .gz, and .rar files. Let’s take a look at how to handle these different types of zipped files.\n\nFor .tar and .gz files, Python provides the module. Here’s an example of how to use it:\n\nIn this example, we use the module’s method to open the .tar.gz file in read mode (‘r:gz’). The method is then used to extract all files from the .tar.gz file.\n\nHandling .rar files is a bit more complex as Python’s standard library does not provide a way to extract .rar files. However, there are third-party libraries like that can handle .rar files. Here’s how to use it:\n\nIn this example, we use the module’s class to open the .rar file in read mode (‘r’). The method is then used to extract all files from the .rar file.\n\nWhen working with zip files in Python, you might encounter errors. One common error is the error, which occurs when Python cannot open a file because it’s not a zip file or it is corrupted. Here’s how to handle this error:\n\nIn this example, we use a try/except block to catch the error. If Python encounters this error when trying to open or extract the zip file, it will print a message and continue with the rest of the program.\n\nPython’s standard library offers a robust suite of modules for handling zip files, but there are also alternative approaches that can provide additional functionality or handle specific use cases.\n\nUsing the and Modules\n\nPython’s and modules are great alternatives for handling .tar and .gz files, respectively. Here’s a quick example of how to use the module to unzip a .gz file:\n\nIn this example, we open the .gz file in read mode (‘rb’) with the method. We then open a new file in write mode (‘wb’) and use the method to copy the contents of the .gz file to the new file.\n\nis a third-party library that supports a wide variety of archive formats, including .zip, .tar, .rar, and .7z files. Here’s how to use it:\n\nIn this example, we use the class from to open the zip file, and then call the method to extract all files from the zip file to the specified destination.\n\nWhile is a powerful tool, it’s worth noting that it depends on other tools like , , and to handle different archive formats. This means you’ll need to install these tools on your system to use .\n\nAs you work with Python to unzip files, you may encounter a few common issues. Here, we’ll discuss these potential pitfalls and provide tips on how to handle them effectively.\n\nOne of the most common issues when unzipping files in Python is the ‘BadZipFile’ error. This error typically occurs when Python cannot open a file because it’s not a zip file or it is corrupted.\n\nYou can handle this error using a try/except block. Here’s an example:\n\nIn this code block, we attempt to open and extract a zip file. If Python encounters a ‘BadZipFile’ error, it will print a helpful message and continue with the rest of the program. This approach allows your program to continue running even if one zip file fails.\n\nWhile Python’s module can handle large files, it can be slow if you’re working with very large zip files. If speed is a concern, you may want to consider alternative approaches, such as using the or modules for .tar and .gz files, respectively, or using third-party libraries like .\n\nPython’s module is a powerful tool for working with zip files. It provides a high level of control over zip file operations, including creating, reading, writing, appending, and listing a ZIP file.\n\nThe module works by providing a class that you can use to open and manipulate zip files. Here’s a quick example:\n\nIn this example, we use the class to open the zip file in read mode (‘r’). We then call the method to extract all files from the zip file.\n\nThe Concepts Behind File Compression and Decompression\n\nFile compression is the process of reducing the size of a file or a group of files. It’s a common technique for saving storage space and reducing the time it takes to transfer files over a network.\n\nDecompression, on the other hand, is the process of restoring compressed files back to their original state. When you unzip a file, you’re decompressing it.\n\nPython’s module uses the ZIP file format for compression and decompression. The ZIP file format is a common file format that uses lossless data compression. A ZIP file may contain one or more files or directories that may have been compressed.\n\nThe module provides a simple interface to compress and decompress files in Python. It provides methods for reading, writing, and extracting files from a zip file, making it a versatile tool for handling zip files in Python.\n\nUnzipping Files in Python: Beyond the Basics\n\nUnzipping files in Python is a fundamental skill, but its relevance extends far beyond just extracting data from compressed files. It plays a critical role in various applications such as data analysis, web scraping, and more.\n\nThe Role of File Decompression in Data Analysis\n\nIn data analysis, you often need to work with large datasets that are usually compressed to save storage space and bandwidth. Knowing how to unzip files in Python enables you to access and analyze this data efficiently.\n\nWeb scraping often involves downloading and extracting data from the web. Some of this data may be in the form of compressed files. With Python’s module, you can easily extract this data for further processing.\n\nWhile unzipping files is a crucial skill, it’s also worth exploring related concepts. For instance, understanding file I/O (input/output) in Python can help you manipulate the data you’ve extracted from a zip file. Additionally, learning how to work with binary data can be useful, especially when dealing with non-text files like images or audio files.\n\nFurther Resources for Mastering File Decompression in Python\n\nTo deepen your understanding of working with zip files and other compressed file formats in Python, check out the following resources:\n• IOFlood’s Python Modules Article – Discover best practices for documenting and structuring modules.\n• None Python Module Integration Made Easy – Discover how to organize and reuse code effectively with “import.”\n• None Networking Made Easy with Python Socket – Discover how to create client-server interactions with Python sockets.\n• None Python’s Official Documentation on The Zipfile Module is essential for handling zip archives.\n• None Python’s Official Documentation on The Tarfile Module – Explore the tarfile module, fundamental to manage tar archive files.\n• None Reading and Writing Files in Python – Informative guide from Real Python about reading and writing files in Python, critical to file manipulation.\n\nIn this comprehensive guide, we’ve explored the process of unzipping files in Python, delving into the usage of the module, dealing with common issues, and providing solutions. We’ve also looked into alternative approaches to handle file decompression in Python, giving you a well-rounded understanding of the topic.\n\nWe began with the basics, learning how to use the module to unzip .zip files. We then ventured into more advanced territory, discussing how to handle different types of zipped files such as .tar, .gz, and .rar.\n\nAlong the way, we tackled common challenges you might encounter when unzipping files in Python, such as ‘BadZipFile’ errors, and provided solutions for each issue.\n\nWe also explored alternative approaches to unzipping files in Python, discussing the use of other built-in modules like and , as well as third-party libraries like .\n\nWhether you’re just starting out with unzipping files in Python or you’re looking to level up your skills, we hope this guide has given you a deeper understanding of the process and its related concepts.\n\nWith the ability to handle a wide variety of compressed file formats and deal with common issues, Python proves to be a powerful tool for file decompression. Happy unzipping!"
    },
    {
        "link": "https://docs.python.org/3/library/shutil.html",
        "document": "The module offers a number of high-level operations on files and collections of files. In particular, functions are provided which support file copying and removal. For operations on individual files, see also the module.\n\nChanged in version 3.5: Added support for the xztar format. High-level utilities to create and read compressed and archived files are also provided. They rely on the and modules. Create an archive file (such as zip or tar) and return its name. base_name is the name of the file to create, including the path, minus any format-specific extension. format is the archive format: one of “zip” (if the module is available), “tar”, “gztar” (if the module is available), “bztar” (if the module is available), or “xztar” (if the module is available). root_dir is a directory that will be the root directory of the archive, all paths in the archive will be relative to it; for example, we typically chdir into root_dir before creating the archive. base_dir is the directory where we start archiving from; i.e. base_dir will be the common prefix of all files and directories in the archive. base_dir must be given relative to root_dir. See Archiving example with base_dir for how to use base_dir and root_dir together. root_dir and base_dir both default to the current directory. If dry_run is true, no archive is created, but the operations that would be executed are logged to logger. owner and group are used when creating a tar archive. By default, uses the current owner and group. logger must be an object compatible with PEP 282, usually an instance of . The verbose argument is unused and deprecated. This function is not thread-safe when custom archivers registered with do not support the root_dir argument. In this case it temporarily changes the current working directory of the process to root_dir to perform archiving. Changed in version 3.8: The modern pax (POSIX.1-2001) format is now used instead of the legacy GNU format for archives created with . Changed in version 3.10.6: This function is now made thread-safe during creation of standard and tar archives. Return a list of supported formats for archiving. Each element of the returned sequence is a tuple . By default provides these formats:\n• None zip: ZIP file (if the module is available).\n• None tar: Uncompressed tar file. Uses POSIX.1-2001 pax format for new archives.\n• None gztar: gzip’ed tar-file (if the module is available).\n• None bztar: bzip2’ed tar-file (if the module is available).\n• None xztar: xz’ed tar-file (if the module is available). You can register new formats or provide your own archiver for any existing formats, by using . Register an archiver for the format name. function is the callable that will be used to unpack archives. The callable will receive the base_name of the file to create, followed by the base_dir (which defaults to ) to start archiving from. Further arguments are passed as keyword arguments: owner, group, dry_run and logger (as passed in ). If function has the custom attribute set to , the root_dir argument is passed as a keyword argument. Otherwise the current working directory of the process is temporarily changed to root_dir before calling function. In this case is not thread-safe. If given, extra_args is a sequence of pairs that will be used as extra keywords arguments when the archiver callable is used. description is used by which returns the list of archivers. Defaults to an empty string. Changed in version 3.12: Added support for functions supporting the root_dir argument. Remove the archive format name from the list of supported formats. Unpack an archive. filename is the full path of the archive. extract_dir is the name of the target directory where the archive is unpacked. If not provided, the current working directory is used. format is the archive format: one of “zip”, “tar”, “gztar”, “bztar”, or “xztar”. Or any other format registered with . If not provided, will use the archive file name extension and see if an unpacker was registered for that extension. In case none is found, a is raised. The keyword-only filter argument is passed to the underlying unpacking function. For zip files, filter is not accepted. For tar files, it is recommended to set it to , unless using features specific to tar and UNIX-like filesystems. (See Extraction filters for details.) The filter will become the default for tar files in Python 3.14. Never extract archives from untrusted sources without prior inspection. It is possible that files are created outside of the path specified in the extract_dir argument, e.g. members that have absolute filenames starting with “/” or filenames with two dots “..”. Changed in version 3.7: Accepts a path-like object for filename and extract_dir. Registers an unpack format. name is the name of the format and extensions is a list of extensions corresponding to the format, like for Zip files. function is the callable that will be used to unpack archives. The callable will receive:\n• None the path of the archive, as a positional argument;\n• None the directory the archive must be extracted to, as a positional argument;\n• None possibly a filter keyword argument, if it was given to ;\n• None additional keyword arguments, specified by extra_args as a sequence of tuples. description can be provided to describe the format, and will be returned by the function. Unregister an unpack format. name is the name of the format. Return a list of all registered formats for unpacking. Each element of the returned sequence is a tuple . By default provides these formats:\n• None zip: ZIP file (unpacking compressed files works only if the corresponding module is available).\n• None gztar: gzip’ed tar-file (if the module is available).\n• None bztar: bzip2’ed tar-file (if the module is available).\n• None xztar: xz’ed tar-file (if the module is available). You can register new formats or provide your own unpacker for any existing formats, by using . In this example, we create a gzip’ed tar-file archive containing all files found in the directory of the user: In this example, similar to the one above, we show how to use , but this time with the usage of base_dir. We now have the following directory structure: In the final archive, should be included, but should not. Therefore we use the following: Listing the files in the resulting archive gives us:"
    },
    {
        "link": "https://geeksforgeeks.org/shutil-module-in-python",
        "document": "Shutil module offers high-level operation on a file like a copy, create, and remote operation on the file. It comes under Python’s standard utility modules. This module helps in automating the process of copying and removal of files and directories. In this article, we will learn this module.\n\nshutil.copy() method in Python is used to copy the content of the source file to the destination file or directory. It also preserves the file’s permission mode but other metadata of the file like the file’s creation and modification times is not preserved.\n\nThe source must represent a file but the destination can be a file or a directory. If the destination is a directory then the file will be copied into the destination using the base filename from the source. Also, the destination must be writable. If the destination is a file and already exists then it will be replaced with the source file otherwise a new file will be created.\n\nExample 2: If the destination is a directory.\n\nCopying the Metadata along with File\n\nshutil.copy2() method in Python is used to copy the content of the source file to the destination file or directory. This method is identical to shutil.copy() method but it also tries to preserve the file’s metadata.\n\nExample 2: If the destination is a directory\n\nCopying the content of one file to another\n\nshutil.copyfile() method in Python is used to copy the content of the source file to the destination file. The metadata of the file is not copied. Source and destination must represent a file and destination must be writable. If the destination already exists then it will be replaced with the source file otherwise a new file will be created.\n\nIf source and destination represent the same file then SameFileError exception will be raised.\n\nshutil.copytree() method recursively copies an entire directory tree rooted at source (src) to the destination directory. The destination directory, named by (dst) must not already exist. It will be created during copying.\n\nParameters:\n\nsrc: A string representing the path of the source directory.\n\ndest: A string representing the path of the destination.\n\nsymlinks (optional) : This parameter accepts True or False, depending on which the metadata of the original links or linked links will be copied to the new tree.\n\nignore (optional) : If ignore is given, it must be a callable that will receive as its arguments the directory being visited by copytree(), and a list of its contents, as returned by os.listdir().\n\ncopy_function (optional): The default value of this parameter is copy2. We can use other copy function like copy() for this parameter.\n\nignore_dangling_symlinks (optional) : This parameter value when set to True is used to put a silence on the exception raised if the file pointed by the symlink doesn’t exist. Return Value: This method returns a string which represents the path of newly created directory.\n\nshutil.rmtree() is used to delete an entire directory tree, the path must point to a directory (but not a symbolic link to a directory).\n\nshutil.which() method tells the path to an executable application that would be run if the given cmd was called. This method can be used to find a file on a computer which is present on the PATH.\n\nSyntax: shutil.which(cmd, mode = os.F_OK | os.X_OK, path = None)\n\nParameters:\n\ncmd: A string representing the file.\n\nmode: This parameter specifies mode by which method should execute. os.F_OK tests existence of the path and os.X_OK Checks if path can be executed or we can say mode determines if the file exists and executable.\n\npath: This parameter specifies the path to be used, if no path is specified then the results of os.environ() are used\n\nReturn Value: This method returns the path to an executable application"
    },
    {
        "link": "https://docs.python.org/3/library/os.html",
        "document": "This module provides a portable way of using operating system dependent functionality. If you just want to read or write a file see , if you want to manipulate paths, see the module, and if you want to read all the lines in all the files on the command line see the module. For creating temporary files and directories see the module, and for high-level file and directory handling see the module.\n\nNotes on the availability of these functions:\n• None The design of all built-in operating system dependent modules of Python is such that as long as the same functionality is available, it uses the same interface; for example, the function returns stat information about path in the same format (which happens to have originated with the POSIX interface).\n• None Extensions peculiar to a particular operating system are also available through the module, but using them is of course a threat to portability.\n• None All functions accepting path or file names accept both bytes and string objects, and result in an object of the same type, if a path or file name is returned.\n• None On VxWorks, os.popen, os.fork, os.execv and os.spawn*p* are not supported.\n• None On WebAssembly platforms, Android and iOS, large parts of the module are not available or behave differently. APIs related to processes (e.g. , ) and resources (e.g. ) are not available. Others like and are emulated or stubs. WebAssembly platforms also lack support for signals (e.g. , )."
    },
    {
        "link": "https://icpc.student.cs.uwaterloo.ca/~acm00/python3-doc/library/shutil.html",
        "document": ""
    },
    {
        "link": "https://docs.python.org/3/whatsnew/3.10.html",
        "document": "This article explains the new features in Python 3.10, compared to 3.9. Python 3.10 was released on October 4, 2021. For full details, see the changelog.\n\nUsing enclosing parentheses for continuation across multiple lines in context managers is now supported. This allows formatting a long collection of context managers in multiple lines in a similar way as it was previously possible with import statements. For instance, all these examples are now valid: it is also possible to use a trailing comma at the end of the enclosed group: This new syntax uses the non LL(1) capacities of the new parser. Check PEP 617 for more details. When parsing code that contains unclosed parentheses or brackets the interpreter now includes the location of the unclosed bracket of parentheses instead of displaying SyntaxError: unexpected EOF while parsing or pointing to some incorrect location. For instance, consider the following code (notice the unclosed ‘{‘): Previous versions of the interpreter reported confusing places as the location of the syntax error: but in Python 3.10 a more informative error is emitted: In a similar way, errors involving unclosed string literals (single and triple quoted) now point to the start of the string instead of reporting EOF/EOL. These improvements are inspired by previous work in the PyPy interpreter. exceptions raised by the interpreter will now highlight the full error range of the expression that constitutes the syntax error itself, instead of just where the problem is detected. In this way, instead of displaying (before Python 3.10): now Python 3.10 will display the exception as: This improvement was contributed by Pablo Galindo in bpo-43914. A considerable amount of new specialized messages for exceptions have been incorporated. Some of the most notable ones are as follows:\n• File , line : did you forget parentheses around the comprehension target?\n• None Missing commas in collection literals and between expressions:\n• None Usage of instead of in comparisons: File , line : cannot assign to attribute here. Maybe you meant '==' instead of '='?\n• File , line : f-string: cannot use starred expression here Many exceptions now have more context regarding what kind of block was expecting an indentation, including the location of the statement: File , line : expected an indented block after 'if' statement in line 2 When printing , will offer suggestions of similar attribute names in the object that the exception was raised from: File , line , in : module 'collections' has no attribute 'namedtoplo'. Did you mean: namedtuple? Notice this won’t work if is not called to display the error which can happen if some other custom error display function is used. This is a common scenario in some REPLs like IPython. When printing raised by the interpreter, will offer suggestions of similar variable names in the function that the exception was raised from: File , line , in : name 'schwarschild_black_hole' is not defined. Did you mean: schwarzschild_black_hole? Notice this won’t work if is not called to display the error, which can happen if some other custom error display function is used. This is a common scenario in some REPLs like IPython. Structural pattern matching has been added in the form of a match statement and case statements of patterns with associated actions. Patterns consist of sequences, mappings, primitive data types as well as class instances. Pattern matching enables programs to extract information from complex data types, branch on the structure of data, and apply specific actions based on different forms of data. The generic syntax of pattern matching is: A match statement takes an expression and compares its value to successive patterns given as one or more case blocks. Specifically, pattern matching operates by:\n• None using data with type and shape (the )\n• None evaluating the in the statement\n• None comparing the subject with each pattern in a statement from top to bottom until a match is confirmed.\n• None executing the action associated with the pattern of the confirmed match\n• None If an exact match is not confirmed, the last case, a wildcard , if provided, will be used as the matching case. If an exact match is not confirmed and a wildcard case does not exist, the entire match block is a no-op. Readers may be aware of pattern matching through the simple example of matching a subject (data object) to a literal (pattern) with the switch statement found in C, Java or JavaScript (and many other languages). Often the switch statement is used for comparison of an object/expression with case statements containing literals. More powerful examples of pattern matching can be found in languages such as Scala and Elixir. With structural pattern matching, the approach is “declarative” and explicitly states the conditions (the patterns) for data to match. While an “imperative” series of instructions using nested “if” statements could be used to accomplish something similar to structural pattern matching, it is less clear than the “declarative” approach. Instead the “declarative” approach states the conditions to meet for a match and is more readable through its explicit patterns. While structural pattern matching can be used in its simplest form comparing a variable to a literal in a case statement, its true value for Python lies in its handling of the subject’s type and shape. Let’s look at this example as pattern matching in its simplest form: a value, the subject, being matched to several literals, the patterns. In the example below, is the subject of the match statement. The patterns are each of the case statements, where literals represent request status codes. The associated action to the case is executed after a match: If the above function is passed a of 418, “I’m a teapot” is returned. If the above function is passed a of 500, the case statement with will match as a wildcard, and “Something’s wrong with the internet” is returned. Note the last block: the variable name, , acts as a wildcard and insures the subject will always match. The use of is optional. You can combine several literals in a single pattern using (“or”): If we modify the above example by removing the last case block, the example becomes: Without the use of in a case statement, a match may not exist. If no match exists, the behavior is a no-op. For example, if of 500 is passed, a no-op occurs. Patterns can look like unpacking assignments, and a pattern may be used to bind variables. In this example, a data point can be unpacked to its x-coordinate and y-coordinate: The first pattern has two literals, , and may be thought of as an extension of the literal pattern shown above. The next two patterns combine a literal and a variable, and the variable binds a value from the subject ( ). The fourth pattern captures two values, which makes it conceptually similar to the unpacking assignment . If you are using classes to structure your data, you can use as a pattern the class name followed by an argument list resembling a constructor. This pattern has the ability to capture class attributes into variables: and the point is on the y-axis.\" and the point is on the x-axis.\" \"The point is located somewhere else on the plane.\" You can use positional parameters with some builtin classes that provide an ordering for their attributes (e.g. dataclasses). You can also define a specific position for attributes in patterns by setting the special attribute in your classes. If it’s set to (“x”, “y”), the following patterns are all equivalent (and all bind the attribute to the variable): Patterns can be arbitrarily nested. For example, if our data is a short list of points, it could be matched like this: \"The origin is the only point in the list.\" \"Two points on the Y axis at \"Something else is found in the list.\" To this point, the examples have used alone in the last case statement. A wildcard can be used in more complex patterns, such as . For example: In the above case, will match for (‘error’, code, 100) and (‘error’, code, 800). We can add an clause to a pattern, known as a “guard”. If the guard is false, goes on to try the next case block. Note that value capture happens before the guard is evaluated: \"The point is located on the diagonal Y=X at \"Point is not on the diagonal.\"\n• None Like unpacking assignments, tuple and list patterns have exactly the same meaning and actually match arbitrary sequences. Technically, the subject must be a sequence. Therefore, an important exception is that patterns don’t match iterators. Also, to prevent a common mistake, sequence patterns don’t match strings.\n• None Sequence patterns support wildcards: and work similar to wildcards in unpacking assignments. The name after may also be , so matches a sequence of at least two items without binding the remaining items.\n• None Mapping patterns: captures the and values from a dict. Unlike sequence patterns, extra keys are ignored. A wildcard is also supported. (But would be redundant, so is not allowed.)\n• None Subpatterns may be captured using the keyword: This binds x1, y1, x2, y2 like you would expect without the clause, and p2 to the entire second item of the subject.\n• None Most literals are compared by equality. However, the singletons , and are compared by identity.\n• None Named constants may be used in patterns. These named constants must be dotted names to prevent the constant from being interpreted as a capture variable: For the full specification see PEP 634. Motivation and rationale are in PEP 635, and a longer tutorial is in PEP 636. The default encoding of and is platform and locale dependent. Since UTF-8 is used on most Unix platforms, omitting option when opening UTF-8 files (e.g. JSON, YAML, TOML, Markdown) is a very common bug. For example: # BUG: \"rb\" mode or encoding=\"utf-8\" should be used. To find this type of bug, an optional is added. It is emitted when is true and locale-specific default encoding is used. option and are added to enable the warning. See Text Encoding for more information.\n• None Currently Python accepts numeric literals immediately followed by keywords, for example , , . It allows confusing and ambiguous expressions like (which can be interpreted as or ). Starting in this release, a deprecation warning is raised if the numeric literal is immediately followed by one of keywords , , , , , and . In future releases it will be changed to syntax warning, and finally to syntax error. (Contributed by Serhiy Storchaka in bpo-43833.)\n• None Starting in this release, there will be a concerted effort to begin cleaning up old import semantics that were kept for Python 2.7 compatibility. Specifically, / (superseded by ), (superseded by ), (which the import system takes care of for you), the attribute (superseded by ), the attribute (superseded by ), and the attribute (superseded by ) will slowly be removed (as well as other classes and methods in ). and/or will be raised as appropriate to help identify code which needs updating during this transition.\n• None The entire namespace is deprecated, to be removed in Python 3.12. Refer to the module changes section for more information.\n• None Non-integer arguments to are deprecated. The is deprecated in favor of a . (Contributed by Serhiy Storchaka and Raymond Hettinger in bpo-37319.)\n• None The various methods of have been documented as deprecated since Python 3.6, but will now also trigger a . Use instead. (Contributed by Brett Cannon in bpo-26131.)\n• None has been deprecated in preference for . (Contributed by Brett Cannon in bpo-26131.)\n• None The use of by the import system now triggers an as is preferred. (Contributed by Brett Cannon in bpo-26131.)\n• None The use of and by the import system now trigger an as and are preferred, respectively. You can use to help in porting. (Contributed by Brett Cannon in bpo-42134.)\n• None The use of by the import system now triggers an as is preferred. You can use to help in porting. (Contributed by Brett Cannon in bpo-43672.)\n• None The various implementations of ( , , , , ), ( ), and ( ) now raise and are slated for removal in Python 3.12 (previously they were documented as deprecated in Python 3.4). (Contributed by Brett Cannon in bpo-42135.)\n• None is deprecated (including its sole method, ). Both and no longer inherit from the class. Users should inherit from one of these two classes as appropriate instead. (Contributed by Brett Cannon in bpo-42135.)\n• None The deprecations of , , , , , , and have all been updated to list Python 3.12 as the slated version of removal (they began raising in previous versions of Python). (Contributed by Brett Cannon in bpo-43720.)\n• None The import system now uses the attribute on modules before falling back on for a module’s method. Removal of the use of is scheduled for Python 3.12. (Contributed by Brett Cannon in bpo-42137.)\n• None , , and are deprecated and slated for removal in Python 3.12. (Contributed by Brett Cannon in bpo-42136.)\n• None has been undocumented and obsolete since Python 3.3, when it was made an alias to . It is now deprecated, scheduled for removal in Python 3.12. (Contributed by Erlend E. Aasland in bpo-42264.)\n• None The undocumented built-in function is now deprecated, scheduled for removal in Python 3.12. Its use is strongly discouraged by the SQLite3 documentation. See the SQLite3 docs for more details. If a shared cache must be used, open the database in URI mode using the query parameter. (Contributed by Erlend E. Aasland in bpo-24464.)\n• None The following methods are now deprecated:\n• None is deprecated and slated for removal in Python 3.12. Use instead. (Contributed by Barney Gale in bpo-39950.)\n• None is deprecated and slated for removal in Python 3.12. (Contributed by Inada Naoki in bpo-41139.)\n• None The following features have been deprecated since Python 3.6, Python 3.7, or OpenSSL 1.1.0 and will be removed in 3.11:\n• None , , , , , and are replaced by and .\n• None , , , , , , and are deprecated in favor of and\n• None NPN features like and are replaced by ALPN.\n• None The threading debug ( environment variable) is deprecated in Python 3.10 and will be removed in Python 3.12. This feature requires a debug build of Python. (Contributed by Victor Stinner in bpo-44584.)\n• None Importing from the and submodules will now emit . These submodules will be removed in a future version of Python. Anything belonging to these submodules should be imported directly from instead. (Contributed by Sebastian Rittau in bpo-38291.)"
    },
    {
        "link": "https://docs.python.org/3/library/os.html",
        "document": "This module provides a portable way of using operating system dependent functionality. If you just want to read or write a file see , if you want to manipulate paths, see the module, and if you want to read all the lines in all the files on the command line see the module. For creating temporary files and directories see the module, and for high-level file and directory handling see the module.\n\nNotes on the availability of these functions:\n• None The design of all built-in operating system dependent modules of Python is such that as long as the same functionality is available, it uses the same interface; for example, the function returns stat information about path in the same format (which happens to have originated with the POSIX interface).\n• None Extensions peculiar to a particular operating system are also available through the module, but using them is of course a threat to portability.\n• None All functions accepting path or file names accept both bytes and string objects, and result in an object of the same type, if a path or file name is returned.\n• None On VxWorks, os.popen, os.fork, os.execv and os.spawn*p* are not supported.\n• None On WebAssembly platforms, Android and iOS, large parts of the module are not available or behave differently. APIs related to processes (e.g. , ) and resources (e.g. ) are not available. Others like and are emulated or stubs. WebAssembly platforms also lack support for signals (e.g. , )."
    },
    {
        "link": "https://geeksforgeeks.org/python-os-makedirs-method",
        "document": "All functions in the os module raise OSError in the case of invalid or inaccessible file names and paths, or other arguments that have the correct type but are not accepted by the operating system. In this article, we will see how to create directories recursively using the os module and also about os.makedirs() method.\n\nos.makedirs() method in Python is used to create a directory recursively. That means while making leaf directory if any intermediate-level directory is missing, os.makedirs() method will create them all.\n\nFor example, consider the following path:\n\nSuppose we want to create directory ‘ihritik’ but Directory ‘GeeksForGeeks’ and ‘Authors’ are unavailable in the path. Then os.makedirs() method will create all unavailable/missing directory in the specified path. ‘GeeksForGeeks’ and ‘Authors’ will be created first then ‘ihritik’ directory will be created.\n\nBelow are some examples of os.makedirs() function by which we can see how to create directories recursively using the os module:\n\nIn this example, the method is utilized to create nested directories. The first section creates a directory named “ihritik” within the “Authors” directory path. The second section, with specified permissions, creates a directory “c” nested within “GeeksforGeeks/a/b”.\n\nIn this example, the method attempts to create a directory named “ihritik” within the “GeeksForGeeks” path. If the directory already exists, the method raises an . Upon successful creation, a confirmation message is printed.\n\nIn this example, the method is used with the parameter set to to suppress if the directory already exists. If the directory doesn’t exist, it will be created. However, other exceptions, such as an invalid path name, can still be raised and need to be handled separately."
    },
    {
        "link": "https://note.nkmk.me/en/python-os-mkdir-makedirs",
        "document": "In Python, you can create new directories (folders) with the and functions.\n\nAll sample code in this article assumes that the module has been imported. The module is included in the standard library and does not require additional installation.\n\nSpecify a path string for the new directory. See the following article for more information on manipulating path strings.\n• Get the filename, directory, extension from a path string in Python\n\nThe path string may include or exclude a trailing delimiter, like a slash for UNIX and Mac systems, or a backslash for Windows systems.\n\nIf you specify an existing directory, an error ( ) will be raised.\n\nAn error ( ) will be raised if you attempt to create a new directory within a non-existent directory.\n\nWhen using , make sure the parent directories of the desired directory already exist. To create new directories along with their parent directories, use as explained in the next section.\n\nBy default, if you specify an existing directory, an error ( ) will be raised.\n\nThe argument (Python 3.2 or later)\n\nThe argument was added to in Python 3.2.\n\nIf you set , you can specify an existing directory without encountering an error. Note that the default value is .\n\nIn older versions without the argument, you can use to handle exceptions or to check if the target directory already exists.\n• Try, except, else, finally in Python (Exception handling)\n\nCheck for the existence of a directory with :\n• Check if a file or a directory exists in Python"
    },
    {
        "link": "https://w3schools.com/python/ref_os_makedirs.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://freecodecamp.org/news/creating-a-directory-in-python-how-to-create-a-folder",
        "document": "In this article, you will learn how to create new directories (which is another name for folders) in Python.\n\nYou will also learn how to create a nested directory structure.\n\nTo work with directories in Python, you first need to include the module in your project, which allows you to interact with your operating system.\n\nThe module also lets you use the two methods we will cover in this article:\n\nLet’s get into it!\n\nHow To Create A Single Directory Using The Method in Python\n\nAs mentioned earlier, to work with directories in Python, you first need to include the module.\n\nTo do so, add the following line of code to the top of your file:\n\nThe code above will allow you to use the method to create a new single directory.\n\nThe method accepts one argument – the path for the directory.\n\nThe code above will create a directory in the current working directory.\n\nNote that the stands for the current working directory. You can omit this part and only write when specifying the path – the result will be the same!\n\nHow to Handle Exceptions When Using the Method in Python\n\nBut what happens when the directory you are trying to create already exists? A exception is raised:\n\nOne way to handle this exception is to check if the file already exists using an block:\n\nIn the example above, I first checked whether the directory already exists using the method.\n\nIf it does, I will get the following output instead of a :\n\nIf the file doesn't exist, then a new folder gets created in the current working directory, and I get the following output:\n\nAlternatively, you can use a block to handle exceptions:\n\nIf a folder already exists in the current working directory, you will get the following output instead of an error message:\n\nHow To Create A Directory With Subdirectories Using The Method in Python\n\nThe method does not let you create a subdirectory. Instead, it lets you create a single directory.\n\nTo create a nested directory structure (such as a directory inside another directory), use the method.\n\nThe accepts one argument – the entire folder path you want to create.\n\nIn the example above, I created a directory in the current working directory.\n\nInside projects, I created another directory, . And inside , I created yet another directory, .\n\nAnd there you have it! You now know how to create a single directory and a directory with subdirectories in Python.\n\nTo learn more about Python, check out freeCodeCamp's Python for beginners course.\n\nThanks for reading, and happy coding!"
    }
]