[
    {
        "link": "https://docs.python.org/3/library/abc.html",
        "document": "This module provides the infrastructure for defining abstract base classes (ABCs) in Python, as outlined in PEP 3119; see the PEP for why this was added to Python. (See also PEP 3141 and the module regarding a type hierarchy for numbers based on ABCs.)\n\nThe module has some concrete classes that derive from ABCs; these can, of course, be further derived. In addition, the submodule has some ABCs that can be used to test whether a class or instance provides a particular interface, for example, if it is hashable or if it is a mapping.\n\nThis module provides the metaclass for defining ABCs and a helper class to alternatively define ABCs through inheritance:\n\nA helper class that has as its metaclass. With this class, an abstract base class can be created by simply deriving from avoiding sometimes confusing metaclass usage, for example: Note that the type of is still , therefore inheriting from requires the usual precautions regarding metaclass usage, as multiple inheritance may lead to metaclass conflicts. One may also define an abstract base class by passing the metaclass keyword and using directly, for example:\n\nUse this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as “virtual subclasses” – these and their descendants will be considered subclasses of the registering ABC by the built-in function, but the registering ABC won’t show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via ). Classes created with a metaclass of have the following method: Register subclass as a “virtual subclass” of this ABC. For example: Changed in version 3.3: Returns the registered subclass, to allow usage as a class decorator. Changed in version 3.4: To detect calls to , you can use the function. You can also override this method in an abstract base class: Check whether subclass is considered a subclass of this ABC. This means that you can customize the behavior of further without the need to call on every class you want to consider a subclass of the ABC. (This class method is called from the method of the ABC.) This method should return , or . If it returns , the subclass is considered a subclass of this ABC. If it returns , the subclass is not considered a subclass of this ABC, even if it would normally be one. If it returns , the subclass check is continued with the usual mechanism. For a demonstration of these concepts, look at this example ABC definition: The ABC defines the standard iterable method, , as an abstract method. The implementation given here can still be called from subclasses. The method is also part of the abstract base class, but it does not have to be overridden in non-abstract derived classes. The class method defined here says that any class that has an method in its (or in that of one of its base classes, accessed via the list) is considered a too. Finally, the last line makes a virtual subclass of , even though it does not define an method (it uses the old-style iterable protocol, defined in terms of and ). Note that this will not make available as a method of , so it is provided separately.\n\nThe module also provides the following decorator:\n\nUsing this decorator requires that the class’s metaclass is or is derived from it. A class that has a metaclass derived from cannot be instantiated unless all of its abstract methods and properties are overridden. The abstract methods can be called using any of the normal ‘super’ call mechanisms. may be used to declare abstract methods for properties and descriptors. Dynamically adding abstract methods to a class, or attempting to modify the abstraction status of a method or class once it is created, are only supported using the function. The only affects subclasses derived using regular inheritance; “virtual subclasses” registered with the ABC’s method are not affected. When is applied in combination with other method descriptors, it should be applied as the innermost decorator, as shown in the following usage examples: In order to correctly interoperate with the abstract base class machinery, the descriptor must identify itself as abstract using . In general, this attribute should be if any of the methods used to compose the descriptor are abstract. For example, Python’s built-in does the equivalent of: Unlike Java abstract methods, these abstract methods may have an implementation. This implementation can be called via the mechanism from the class that overrides it. This could be useful as an end-point for a super-call in a framework that uses cooperative multiple-inheritance.\n\nThe module also supports the following legacy decorators:\n\nDeprecated since version 3.3: It is now possible to use , , and with , making this decorator redundant. A subclass of the built-in , indicating an abstract property. This special case is deprecated, as the decorator is now correctly identified as abstract when applied to an abstract method: The above example defines a read-only property; you can also define a read-write abstract property by appropriately marking one or more of the underlying methods as abstract: If only some components are abstract, only those components need to be updated to create a concrete property in a subclass:\n\nThe module also provides the following functions:"
    },
    {
        "link": "https://geeksforgeeks.org/abstract-base-class-abc-in-python",
        "document": "Have you ever thought about checking whether the objects you are using adheres to a particular specification? It is necessary to verify whether an object implements a given method or property, especially while creating a library where other developers make use of it. A developer can use hasattr or isinstance methods to check whether the input conforms to a particular identity. But sometimes it is inconvenient to use those methods to check a myriad of different properties and methods.\n\nAs a solution to this inconvenience, Python introduced a concept called abstract base class (abc). In this section, we will discuss the abstract base class and its importance.\n\nThe main goal of the abstract base class is to provide a standardized way to test whether an object adheres to a given specification. It can also prevent any attempt to instantiate a subclass that doesn’t override a particular method in the superclass. And finally, using an abstract class, a class can derive identity from another class without any object inheritance.\n\nPython has a module called abc (abstract base class) that offers the necessary tools for crafting an abstract base class. First and foremost, you should understand the ABCMeta metaclass provided by the abstract base class. The rule is every abstract class must use ABCMeta metaclass.\n\nABCMeta metaclass provides a method called register method that can be invoked by its instance. By using this register method, any abstract base class can become an ancestor of any arbitrary concrete class. Let’s understand this process by considering an example of an abstract base class that registers itself as an ancestor of dict.\n\nHere, dict identifies itself as a subclass of AbstractClass. Let’s do a check.\n\nTo understand the need to declare a virtual subclass, we need to consider the example of a list-like object where you don’t want to put a restriction of only considering list or tuple. Before that let’s see how to use isinstance to check against a list or tuple of class.\n\nThis isinstance check meets the purpose if you are accepting only a list or tuple. But here the case is different, there is no such restriction. So, this solution is not extensible for a developer who uses your library to send something else other than a list or tuple. Here comes the importance of abstract class. Let’s understand through the below code.\n\nAs you can see, when you do isinstance check, it returns true for both the list and tuple; for the other objects, it returns false. Let’s consider a scenario where a developer expects a class object itself. In the above case, the isinstance will return false. But it can be achieved by creating a custom class and registering it with the abstract base class.\n\nHere ‘MySequence’ is an abstract class within the library. A developer can import it and register a custom class. Let’s have a look at the below code.\n\nHere, CustomListLikeObjCls instance is passed to the library by registering it with MySequence. Therefore, the instance check returns True. Apart from the above method, you can also use the register method as a decorator to register a custom class. Let’s see how to use the register method as a decorator.\n\nRegistering a class using the above-implemented method meets the purpose. However, you have to do manual registration for every intended subclass. How about automatic subclassing based on a particular method?. An abstract class has a concept called __subclasshook__ to subclass the classes.\n\nIt is a special magic method defined by ABCMeta. The __subclasshook__ must be defined as a class method using @classmethod decorator. It takes one additional positional argument other than the class and can return either of the three values – True, False, or NotImplemented. Let’s look at the below implementation.\n\nFrom the above discussion, you understood how to hook subclasses automatically. Now we will look into how to avoid instantiating a subclass that doesn’t override a particular method in the superclass. This feature can be achieved using @abc.abstractmethod.\n\n@abc.abstractmethod prevents any attempt to instantiate a subclass that doesn’t override a particular method in the superclass. Let’s have a look at the below code:\n\nSince the InvalidSubclass doesn’t override the method abstractName, the @abc.abstractmethod prevents the subclass from instantiation and throws the below error.\n\nLet’s look into another example where the subclass overrides the abstract method.\n\nNext, let’s see how to declare properties as an abstract class.\n\nWe can use @property decorator and @abc.abstractmethod to declare properties as an abstract class. Let’s look into the below code.\n\nPython 3 standard library provides a few built-in abstract classes for both abstract and non-abstract methods. These include sequence, mutable sequence, iterable, and so on. It often serves as an alternative to subclassing a built-in Python class. For example, subclassing the MutableSequence can substitute the subclassing of list or str. The main purpose of using Abstract class is that it allows you to consider a common type of collection rather than coding for each type of collection. Here we will discuss Single-Method ABCs and Alternative-Collection ABCs.\n\nPython has five abstract base classes. They are as follows:\n\nThese abstract base classes contain one abstract method each. Let’s consider an example of the __len__ method.\n\nAny class that has the appropriate method is considered as the subclass of the abstract base class. Out of the above five abstract base classes, the Iterator is slightly different. It provides an implementation for __iter__ and adds an abstract method called __next__.\n\nAlternative-Collection ABCs are built-in abstract base classes that identify subclasses, which serve similar purposes. They can be divided into three categories. Let’s go through one by one.\n• Sequence and Mutable Sequence: Sequence and Mutable Sequence are abstract base classes that generally behaves like tuples or list. A sequence abstract base class requires __getitem__ and __len__ , whereas mutable sequence needs __setitem__ and __getitem__.\n• Mapping: Mapping comes with mutable mapping, which is mainly for dictionary-like objects\n• Set: The set comes with a mutable set that is intended for unordered collections.\n\nThe key purpose of the abstract class is to check whether an object conforms to a particular protocol. It is a valuable class for testing certain attributes of a class or testing class itself. However, there are many other things that the abstract class does not check. Some of them are signatures, return type, etc. Another advantage is it provides a flexible way for developers to test common types of collections."
    },
    {
        "link": "https://docs.python.org/3/library/collections.abc.html",
        "document": "This module provides abstract base classes that can be used to test whether a class provides a particular interface; for example, whether it is hashable or whether it is a mapping.\n\nAn or test for an interface works in one of three ways.\n• None A newly written class can inherit directly from one of the abstract base classes. The class must supply the required abstract methods. The remaining mixin methods come from inheritance and can be overridden if desired. Other methods may be added as needed: # Extra method not required by the ABC\n• None Existing classes and built-in classes can be registered as “virtual subclasses” of the ABCs. Those classes should define the full API including all of the abstract methods and all of the mixin methods. This lets users rely on or tests to determine whether the full interface is supported. The exception to this rule is for methods that are automatically inferred from the rest of the API: # Extra method not required by the ABC In this example, class does not need to define , , and because the in-operator, the iteration logic, and the function automatically fall back to using and .\n• None Some simple interfaces are directly recognizable by the presence of the required methods (unless those methods have been set to ): Complex interfaces do not support this last technique because an interface is more than just the presence of method names. Interfaces specify semantics and relationships between methods that cannot be inferred solely from the presence of specific method names. For example, knowing that a class supplies , , and is insufficient for distinguishing a from a .\n\nABCs allow us to ask classes or instances if they provide particular functionality, for example: Several of the ABCs are also useful as mixins that make it easier to develop classes supporting container APIs. For example, to write a class supporting the full API, it is only necessary to supply the three underlying abstract methods: , , and . The ABC supplies the remaining methods such as and : and not requiring the set elements to be hashable. ''' # The __and__() method is supported automatically Notes on using and as a mixin:\n• None Since some set operations create new sets, the default mixin methods need a way to create new instances from an iterable. The class constructor is assumed to have a signature in the form . That assumption is factored-out to an internal called which calls to produce a new set. If the mixin is being used in a class with a different constructor signature, you will need to override with a classmethod or regular method that can construct new instances from an iterable argument.\n• None To override the comparisons (presumably for speed, as the semantics are fixed), redefine and , then the other operations will automatically follow suit.\n• None The mixin provides a method to compute a hash value for the set; however, is not defined because not all sets are hashable or immutable. To add set hashability using mixins, inherit from both and , then define .\n• None OrderedSet recipe for an example built on .\n• None For more about ABCs, see the module and PEP 3119."
    },
    {
        "link": "https://geeksforgeeks.org/abstract-classes-in-python",
        "document": "In Python, an abstract class is a class that cannot be instantiated on its own and is designed to be a blueprint for other classes. Abstract classes allow us to define methods that must be implemented by subclasses, ensuring a consistent interface while still allowing the subclasses to provide specific implementations.\n\nIt defines methods that must be implemented by its subclasses, ensuring that the subclasses follow a consistent structure. ABCs allow you to define common interfaces that various subclasses can implement while enforcing a level of abstraction.\n\nPython provides the abc module to define ABCs and enforce the implementation of abstract methods in subclasses.\n• Abstract Base Class: Animal is an abstract class that inherits from ABC (Abstract Base Class). This class cannot be instantiated directly because it contains an abstract method sound(). The @abstractmethod decorator is used to mark sound() as an abstract method. This means any subclass must implement this method to be instantiated.\n• Concrete Subclass: Dog is a subclass of Animal that provides an implementation for the sound() method. This allows the Dog class to be instantiated and used.\n• Instantiation: We create an instance of Dog and call the sound() method, which returns “Bark”.\n\nThe main components of an abstract class are:\n\nAbstract methods are methods that are defined in an abstract class but do not have an implementation. They serve as a blueprint for the subclasses, ensuring that they provide their own implementation.\n• None make_sound() is an abstract method in the Animal class, so it doesn’t have any code inside it.\n\nConcrete methods are methods that have full implementations in an abstract class. These methods can be inherited by subclasses and used directly without needing to be redefined.\n• None The move() method is a concrete method in the Animal class. It is implemented and does not need to be overridden by the Dog class.\n\nAbstract properties work like abstract methods but are used for properties. These properties are declared with the decorator and marked as abstract using . Subclasses must implement these properties.\n• None species is an abstract property in the Animal class and it is marked as @abstractmethod.\n• None The Dog class implements the species property, making it a concrete subclass that can be instantiated.\n• None Abstract properties enforce that a subclass provides the property’s implementation.\n\nAbstract classes cannot be instantiated directly. This is because they contain one or more abstract methods or properties that lack implementations. Attempting to instantiate an abstract class results in a TypeError.\n• None The Animal class is abstract because it has the make_sound() method as an abstract method.\n• None If you try to instantiate Animal directly (e.g., animal = Animal()), Python raises a TypeError because you can’t instantiate a class with unimplemented abstract methods.\n• None Only subclasses that implement all abstract methods can be instantiated.\n\nWhat is the Purpose of Abstract Classes in Python?\n\nHow to Define and Use an Abstract Class in Python?\n\nWhat is the ‘ Module and How is It Used in Python?\n\nHow to Define Abstract Methods in Python?\n\nWhy Should Abstract Classes Be Used in Python?"
    },
    {
        "link": "https://blog.teclado.com/python-abc-abstract-base-classes",
        "document": "What are Abstract Classes? Why are they useful? When should you use them? Let me give you a few examples and explanations! By the end of this post, you'll have a firm understanding of ABCs in Python, and how to add them to your programs.\n\nI believe the best way to learn is with an example, so let's take a look at the following code:\n\nOur job is to feed all the animals using a Python script. One way to do that would be:\n\nThis would work. But imagine how much time would it take to do this for each animal in a large zoo, repeating the same process and code hundreds of times. That would also make the code harder to maintain.\n\nCurrently our program's structure looks something like this:\n\nWe want to optimize the process, so we could come up with a solution like this one:\n\nThe problem is that every class has a different method name, when feeding a lion it's , when feeding a panda it's and it's for a snake.\n\nThis code is a mess because methods that do the same thing should be named the same.\n\nIf we could only force our classes to implement the same method names...\n\nIt turns out that the Abstract class is what we need. Essentially it forces its subclasses to implement all of its abstract methods. It is a class that represents what its subclasses look like.\n\nA better structure could look like like this ( is an Abstract class):\n\nBy introducing an abstract class ( ), every class that inherits from must implement abstract methods from , which in our case is the method\n\nLet's take a look at the code:\n\nWhen defining an abstract class we need to inherit from the Abstract Base Class - .\n\nTo define an abstract method in the abstract class, we have to use a decorator: . The built-in module contains both of these.\n\nIf you inherit from the Animal class but don't implement the abstract methods, you'll get an error:\n\nIf we try to instantiate the class (e.g. ) it will throw a since we can't instantiate Panda without an abstract method .\n\nKeeping that in mind, we need to make our animals (this time correctly):\n\nAnd lastly, this is all the code we need in order to create and feed our animals:\n\nWhat happens when an abstract method has parameters? When the subclass implements the method, it must contain all the parameters as well. The subclass' implementation can also add extra parameters if required.\n\nRunning the above code will print out:\n\nWe could also use default arguments, you can read about those here.\n\nWe may also want to create abstract properties and force our subclass to implement those properties. This could be done by using decorator along with .\n\nSince animals often have different diets, we'll need to define a in our animal classes. Since all the animals are inheriting from , we can define to be an abstract property. Besides , we'll make property and it's will check if we are trying to feed the animal something that's not on it's .\n\nTake a look at the code of , and :\n\nWe can create two objects, set the food that we're going to feed them and then call the method:\n\nThat will print out:\n\nIf we try to feed an animal something that it doesn't eat:\n\nYou may have come across metaclasses when learning about abstract classes.\n\nA class defines how an instance of the class behaves (e.g. describes how will behave). On the other hand a metaclass defines how a class behaves ( describes how every class will behave). A class is an instance of a metaclass.\n\nThe module comes with a metaclass . back in the days we had to use it to define metaclasses with .\n\nNowadays, just inheriting from does the same thing—so you don't have to worry about metaclasses at all!\n\nIn this blog post we described the basics of Python's abstract classes. They are especially useful when working in a team with other developers and parts of the project are developed in parallel.\n\nHere are some key takeaways:\n• Abstract classes make sure that derived classes implement methods and properties defined in the abstract base class.\n• We use to define a method in the abstract base class and combination of and in order to define an abstract property.\n\nI hope you learnt something new today! If you're looking to upgrade your Python skills even further, check out our Complete Python Course."
    },
    {
        "link": "https://medium.com/@shashikantrbl123/interfaces-and-abstract-classes-in-python-understanding-the-differences-3e5889a0746a",
        "document": "Interfaces and abstract classes are two important concepts in object-oriented programming. They allow us to write clean, maintainable, and flexible code. In this blog post, we’ll explore the similarities and differences between interfaces and abstract classes in Python, and learn when to use each approach.\n\nWhat is an interface?\n\nAn interface defines a contract between a class and its users. It specifies a set of methods that a class must implement in order to be considered compatible with the interface. In Python, interfaces can be implemented using abstract base classes (ABCs).\n\nFor example, suppose we have a Shape interface that specifies a single method, area(). We can define the Shape interface in Python using the abc module as follows:\n\nNow, any class that implements the Shape interface must provide an implementation of the area() method.\n\nTo implement an interface in Python, we create a class that inherits from the interface’s abstract base class. We then provide implementations for all the required methods.\n\nFor example, suppose we want to implement the Shape interface for a Rectangle class. We can do so as follows:\n\nNotice that we didn’t explicitly inherit from the Shape interface. Instead, we provided an implementation of the area() method, which is all that’s required to be compatible with the Shape interface.\n\nWhat is an abstract class?\n\nAn abstract class is a class that cannot be instantiated directly. Instead, it’s intended to be subclassed by other classes that provide concrete implementations of its abstract methods. Abstract classes are useful for defining a common interface for a group of related classes.\n\nFor example, suppose we have a Vehicle abstract class that defines a common interface for all types of vehicles. We can define the Vehicle abstract class in Python using the module as follows:\n\nNow, any class that inherits from the Vehicle abstract class must provide concrete implementations of the , , , and methods.\n\nTo implement an abstract class in Python, we create a subclass that inherits from the abstract class and provides concrete implementations of its abstract methods.\n\nFor example, suppose we want to implement the Vehicle abstract class for a Car class. We can do so as follows:\n\nNotice that we provided concrete implementations of all the abstract methods defined in the Vehicle abstract class.\n\nInterfaces and abstract classes have some similarities, but there are also some key differences. Interfaces focus on defining a contract between a class and its users, while abstract classes focus on defining a common interface for a group of related classes.\n\nIn general, interfaces cannot define any implementation, while abstract classes can define both abstract methods and concrete methods. This means that interfaces are more restrictive than abstract classes.\n\nAnother difference between interfaces and abstract classes is that a class can implement multiple interfaces, but it can only inherit from a single abstract class. This makes interfaces more flexible than abstract classes in terms of class design.\n\nIn addition, interfaces can be used for duck typing, which means that a class is considered compatible with an interface as long as it provides the required methods, regardless of its inheritance hierarchy. Abstract classes, on the other hand, require explicit inheritance and implementation.\n\nWhen to use interfaces and abstract classes\n\nInterfaces are useful when you want to define a contract between a class and its users. They’re particularly useful for defining APIs and ensuring that classes are compatible with each other.\n\nAbstract classes, on the other hand, are useful when you want to define a common interface for a group of related classes. They’re particularly useful for implementing a template method pattern, where the abstract class defines a skeleton for an algorithm and the concrete subclasses provide specific implementations for each step.\n\nIn this blog post, we explored the concepts of interfaces and abstract classes in Python. We saw that interfaces define a contract between a class and its users, while abstract classes define a common interface for a group of related classes. We also saw that interfaces are more restrictive than abstract classes and can be used for duck typing, while abstract classes require explicit inheritance and implementation. Understanding the differences between these two concepts is important for writing clean, maintainable, and flexible code in Python."
    },
    {
        "link": "https://realpython.com/python-interface",
        "document": "Interfaces play an important role in software engineering. As an application grows, updates and changes to the code base become more difficult to manage. More often than not, you wind up having classes that look very similar but are unrelated, which can lead to some confusion. In this tutorial, you’ll see how you can use a Python interface to help determine what class you should use to tackle the current problem.\n\nIn this tutorial, you’ll be able to:\n• Understand how interfaces work and the caveats of Python interface creation\n• Comprehend how useful interfaces are in a dynamic language like Python\n• Use and to implement a formal Python interface\n\nInterfaces in Python are handled differently than in most other languages, and they can vary in their design complexity. By the end of this tutorial, you’ll have a better understanding of some aspects of Python’s data model, as well as how interfaces in Python compare to those in languages like Java, C++, and Go.\n\nAt a high level, an interface acts as a blueprint for designing classes. Like classes, interfaces define methods. Unlike classes, these methods are abstract. An abstract method is one that the interface simply defines. It doesn’t implement the methods. This is done by classes, which then implement the interface and give concrete meaning to the interface’s abstract methods. Python’s approach to interface design is somewhat different when compared to languages like Java, Go, and C++. These languages all have an keyword, while Python does not. Python further deviates from other languages in one other aspect. It doesn’t require the class that’s implementing the interface to define all of the interface’s abstract methods.\n\nIn certain circumstances, you may not need the strict rules of a formal Python interface. Python’s dynamic nature allows you to implement an informal interface. An informal Python interface is a class that defines methods that can be overridden, but there’s no strict enforcement. In the following example, you’ll take the perspective of a data engineer who needs to extract text from various different unstructured file types, like PDFs and emails. You’ll create an informal interface that defines the methods that will be in both the and concrete classes: \"\"\"Load in the file for extracting text.\"\"\" \"\"\"Extract text from the currently loaded file.\"\"\" defines the two methods and . These methods are defined but not implemented. The implementation will occur once you create concrete classes that inherit from . As you can see, looks identical to a standard Python class. You rely on duck typing to inform users that this is an interface and should be used accordingly. Note: Haven’t heard of duck typing? This term says that if you have an object that looks like a duck, walks like a duck, and quacks like a duck, then it must be a duck! To learn more, check out Duck Typing. With duck typing in mind, you define two classes that implement the . To use your interface, you must create a concrete class. A concrete class is a subclass of the interface that provides an implementation of the interface’s methods. You’ll create two concrete classes to implement your interface. The first is , which you’ll use to parse the text from PDF files: The concrete implementation of now allows you to extract text from PDF files. Note: The concrete implementation consists of a statement, which does nothing. The implementation of the methods is not the point of this tutorial: Instead, you should focus on the structure of the classes. The second concrete class is , which you’ll use to parse the text from emails: The concrete implementation of now allows you to extract text from email files. So far, you’ve defined two concrete implementations of the . However, note that fails to properly define , instead it defines a different . If you were to check whether implements , then you’d get the following result: # Check if both PdfParser and EmlParser implement InformalParserInterface This would return , which poses a bit of a problem since it violates the definition of an interface! Now check the method resolution order (MRO) of and . This tells you the superclasses of the class in question, as well as the order in which they’re searched for executing a method. You can view a class’s MRO by using the dunder method : Such informal interfaces are fine for small projects where only a few developers are working on the source code. However, as projects get larger and teams grow, this could lead to developers spending countless hours looking for hard-to-find logic errors in the codebase! Ideally, you would want to return when the implementing class doesn’t define all of the interface’s abstract methods. To do this, you’ll create a metaclass called . You’ll be overriding two dunder methods: In the code block below, you create a class called that builds from the metaclass: \"\"\"A Parser metaclass that will be used for parser class creation. \"\"\"This interface is used for concrete classes to inherit from. There is no need to define the ParserMeta methods as any class as they are implicitly made available via .__subclasscheck__(). Now that and have been created, you can create your concrete implementations. First, create a new class for parsing PDFs called : Here, overrides and , so should return . In this next code block, you have a new implementation of the email parser called : Here, you have a metaclass that’s used to create . By using a metaclass, you don’t need to explicitly define the subclasses. Instead, the subclass must define the required methods. If it doesn’t, then will return . Running on your concrete classes will produce the following: As expected, is not a subclass of since wasn’t defined in . Now, let’s have a look at the MRO: As you can see, is a superclass of , but it doesn’t appear in the MRO. This unusual behavior is caused by the fact that is a virtual base class of . In the previous example, returned , even though did not appear in the MRO. That’s because is a virtual base class of . The key difference between these and standard subclasses is that virtual base classes use the dunder method to implicitly check if a class is a virtual subclass of the superclass. Additionally, virtual base classes don’t appear in the subclass MRO. Take a look at this code block: Here, you have the setup for creating your virtual base classes: Now that the setup for creating virtual base classes is done you’ll define two concrete classes, and . The class inherits from , while implicitly inherits from : PersonSuper will appear in Employee.__mro__ Friend is a virtual subclass of Person since Although does not explicitly inherit from , it implements and , so becomes a virtual base class of . When you run it should return , meaning that is a subclass of . The following UML diagram shows what happens when you call on the class: Taking a look at , you’ll notice that there’s another dunder method called . This method is used to check if instances of are created from the interface. Your code will call when you use .\n\nInformal interfaces can be useful for projects with a small code base and a limited number of programmers. However, informal interfaces would be the wrong approach for larger applications. In order to create a formal Python interface, you’ll need a few more tools from Python’s module. To enforce the subclass instantiation of abstract methods, you’ll utilize Python’s builtin from the module. Going back to your interface, you created your own metaclass, , with the overridden dunder methods and . Rather than create your own metaclass, you’ll use as the metaclass. Then, you’ll overwrite in place of and , as it creates a more reliable implementation of these dunder methods. Here’s the implementation of using as your metaclass: If you run on and , then will return and , respectively. Once you’ve imported the module, you can directly register a virtual subclass by using the metamethod. In the next example, you register the interface as a virtual base class of the built-in class: You can check out the effect of using : By using the meta method, you’ve successfully registered as a virtual subclass of . Once you’ve registered , you can use it as class decorator to set the decorated class as a virtual subclass: The decorator register method helps you to create a hierarchy of custom virtual class inheritance. You must be careful when you’re combining with , as takes precedence over virtual subclass registration. To ensure that the registered virtual subclasses are taken into consideration, you must add to the dunder method. The would be updated to the following: Since you’ve used registration, you can see that is considered a virtual subclass of your interface. This is not what you wanted since doesn’t override . Please use caution with virtual subclass registration! An abstract method is a method that’s declared by the Python interface, but it may not have a useful implementation. The abstract method must be overridden by the concrete class that implements the interface in question. To create abstract methods in Python, you add the decorator to the interface’s methods. In the next example, you update the to include the abstract methods and : In the above example, you’ve finally created a formal interface that will raise errors when the abstract methods aren’t overridden. The instance, , won’t raise any errors, as is correctly overriding the abstract methods. However, will raise an error: As you can see, the traceback message tells you that you haven’t overridden all the abstract methods. This is the behavior you expect when building a formal Python interface.\n\nInterfaces appear in many programming languages, and their implementation varies greatly from language to language. In the next few sections, you’ll compare interfaces in Python to Java, C++, and Go. Unlike Python, Java contains an keyword. Keeping with the file parser example, you declare an interface in Java like so: // Static fields, and abstract methods go here ... Now you’ll create two concrete classes, and , to implement the . To do so, you must use the keyword in the class definition, like so: Continuing with your file parsing example, a fully-functional Java interface would look something like this: As you can see, a Python interface gives you much more flexibility during creation than a Java interface does. Like Python, C++ uses abstract base classes to create interfaces. When defining an interface in C++, you use the keyword to describe a method that should be overwritten in the concrete class: When you want to implement the interface, you’ll give the concrete class name, followed by a colon ( ), and then the name of the interface. The following example demonstrates C++ interface implementation: A Python interface and a C++ interface have some similarities in that they both make use of abstract base classes to simulate interfaces. Although Go’s syntax is reminiscent of Python, the Go programming language contains an keyword, like Java. Let’s create the in Go: A big difference between Python and Go is that Go doesn’t have classes. Rather, Go is similar to C in that it uses the keyword to create structures. A structure is similar to a class in that a structure contains data and methods. However, unlike a class, all of the data and methods are publicly accessed. The concrete structs in Go will be used to implement the . Here’s an example of how Go uses interfaces: Unlike a Python interface, a Go interface is created using structs and the explicit keyword .\n\nPython offers great flexibility when you’re creating interfaces. An informal Python interface is useful for small projects where you’re less likely to get confused as to what the return types of the methods are. As a project grows, the need for a formal Python interface becomes more important as it becomes more difficult to infer return types. This ensures that the concrete class, which implements the interface, overwrites the abstract methods.\n• Understand how interfaces work and the caveats of creating a Python interface\n• Understand the usefulness of interfaces in a dynamic language like Python\n• Compare Python interfaces to those in languages like Java, C++, and Go Now that you’ve become familiar with how to create a Python interface, add a Python interface to your next project to see its usefulness in action! Test your knowledge with our interactive “Implementing an Interface in Python” quiz. You’ll receive a score upon completion to help you track your learning progress: In this quiz, you'll test your understanding of Python interfaces and their role in software engineering. You'll learn how interfaces can help manage complexity in a growing application and how to implement them in Python."
    },
    {
        "link": "https://stackoverflow.com/questions/53213543/is-it-a-good-practice-to-put-common-methods-to-an-abstract-class-in-python",
        "document": "TL; DR; Yes, it is OK for an abstract class to have non-abstract methods.\n\nTypically what we call an abstract class is just a class that cannot be instantiated.\n\nOn the other hand what we call an interface is a class which has only method declarations but no implementations. In particular its an abstract class because it doesn't have a constructor.\n\nOf course in Python there are no real interfaces: every method has to have a body. But we can somewhat emulate interfaces via .\n\nAnyway interfaces form a subset of abstract classes. This obviously suggests that there are abstract classes that are not interfaces. This is exactly the case you are describing. Yes, abstract class may contain implemented, non-abstract methods. And it is not a bad practice. This is especially useful when a given method does not depend on concrete implementation.\n\nFor example consider an interface for a generic parser (I'm thinking about and ):\n\nIt's completely OK to give method which accepts a string instead of stream with a default implementation:\n\nalthough I would use prefix instead of . ;)"
    },
    {
        "link": "https://geeksforgeeks.org/abstract-classes-in-python",
        "document": "In Python, an abstract class is a class that cannot be instantiated on its own and is designed to be a blueprint for other classes. Abstract classes allow us to define methods that must be implemented by subclasses, ensuring a consistent interface while still allowing the subclasses to provide specific implementations.\n\nIt defines methods that must be implemented by its subclasses, ensuring that the subclasses follow a consistent structure. ABCs allow you to define common interfaces that various subclasses can implement while enforcing a level of abstraction.\n\nPython provides the abc module to define ABCs and enforce the implementation of abstract methods in subclasses.\n• Abstract Base Class: Animal is an abstract class that inherits from ABC (Abstract Base Class). This class cannot be instantiated directly because it contains an abstract method sound(). The @abstractmethod decorator is used to mark sound() as an abstract method. This means any subclass must implement this method to be instantiated.\n• Concrete Subclass: Dog is a subclass of Animal that provides an implementation for the sound() method. This allows the Dog class to be instantiated and used.\n• Instantiation: We create an instance of Dog and call the sound() method, which returns “Bark”.\n\nThe main components of an abstract class are:\n\nAbstract methods are methods that are defined in an abstract class but do not have an implementation. They serve as a blueprint for the subclasses, ensuring that they provide their own implementation.\n• None make_sound() is an abstract method in the Animal class, so it doesn’t have any code inside it.\n\nConcrete methods are methods that have full implementations in an abstract class. These methods can be inherited by subclasses and used directly without needing to be redefined.\n• None The move() method is a concrete method in the Animal class. It is implemented and does not need to be overridden by the Dog class.\n\nAbstract properties work like abstract methods but are used for properties. These properties are declared with the decorator and marked as abstract using . Subclasses must implement these properties.\n• None species is an abstract property in the Animal class and it is marked as @abstractmethod.\n• None The Dog class implements the species property, making it a concrete subclass that can be instantiated.\n• None Abstract properties enforce that a subclass provides the property’s implementation.\n\nAbstract classes cannot be instantiated directly. This is because they contain one or more abstract methods or properties that lack implementations. Attempting to instantiate an abstract class results in a TypeError.\n• None The Animal class is abstract because it has the make_sound() method as an abstract method.\n• None If you try to instantiate Animal directly (e.g., animal = Animal()), Python raises a TypeError because you can’t instantiate a class with unimplemented abstract methods.\n• None Only subclasses that implement all abstract methods can be instantiated.\n\nWhat is the Purpose of Abstract Classes in Python?\n\nHow to Define and Use an Abstract Class in Python?\n\nWhat is the ‘ Module and How is It Used in Python?\n\nHow to Define Abstract Methods in Python?\n\nWhy Should Abstract Classes Be Used in Python?"
    },
    {
        "link": "https://datacamp.com/tutorial/python-abstract-classes",
        "document": "From testing code and implementing version control to web scraping and developing packages, take the next step in your Python developer journey!"
    }
]