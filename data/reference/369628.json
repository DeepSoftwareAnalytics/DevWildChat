[
    {
        "link": "https://vuejs.org/guide/essentials/component-basics",
        "document": "Components allow us to split the UI into independent and reusable pieces, and think about each piece in isolation. It's common for an app to be organized into a tree of nested components:\n\nThis is very similar to how we nest native HTML elements, but Vue implements its own component model that allows us to encapsulate custom content and logic in each component. Vue also plays nicely with native Web Components. If you are curious about the relationship between Vue Components and native Web Components, read more here.\n\nWhen using a build step, we typically define each Vue component in a dedicated file using the extension - known as a Single-File Component (SFC for short):\n\nWhen not using a build step, a Vue component can be defined as a plain JavaScript object containing Vue-specific options:\n\nThe template is inlined as a JavaScript string here, which Vue will compile on the fly. You can also use an ID selector pointing to an element (usually native elements) - Vue will use its content as the template source.\n\nThe example above defines a single component and exports it as the default export of a file, but you can use named exports to export multiple components from the same file.\n\nTo use a child component, we need to import it in the parent component. Assuming we placed our counter component inside a file called , the component will be exposed as the file's default export:\n\nIt's also possible to globally register a component, making it available to all components in a given app without having to import it. The pros and cons of global vs. local registration is discussed in the dedicated Component Registration section.\n\nComponents can be reused as many times as you want:\n\nNotice that when clicking on the buttons, each one maintains its own, separate . That's because each time you use a component, a new instance of it is created.\n\nIn SFCs, it's recommended to use tag names for child components to differentiate from native HTML elements. Although native HTML tag names are case-insensitive, Vue SFC is a compiled format so we are able to use case-sensitive tag names in it. We are also able to use to close a tag.\n\nIf you are authoring your templates directly in a DOM (e.g. as the content of a native element), the template will be subject to the browser's native HTML parsing behavior. In such cases, you will need to use and explicit closing tags for components:\n\nSee in-DOM template parsing caveats for more details.\n\nIf we are building a blog, we will likely need a component representing a blog post. We want all the blog posts to share the same visual layout, but with different content. Such a component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.\n\nProps are custom attributes you can register on a component. To pass a title to our blog post component, we must declare it in the list of props this component accepts, using the option macro:\n\nA component can have as many props as you like and, by default, any value can be passed to any prop.\n\nOnce a prop is registered, you can pass data to it as a custom attribute, like this:\n\nIn a typical app, however, you'll likely have an array of posts in your parent component:\n\nThen want to render a component for each one, using :\n\nNotice how syntax ( ) is used to pass dynamic prop values. This is especially useful when you don't know the exact content you're going to render ahead of time.\n\nThat's all you need to know about props for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Props.\n\nAs we develop our component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page at its default size.\n\nIn the parent, we can support this feature by adding a data propertyref:\n\nWhich can be used in the template to control the font size of all blog posts:\n\nNow let's add a button to the component's template:\n\nThe button doesn't do anything yet - we want clicking the button to communicate to the parent that it should enlarge the text of all posts. To solve this problem, components provide a custom events system. The parent can choose to listen to any event on the child component instance with or , just as we would with a native DOM event:\n\nThen the child component can emit an event on itself by calling the built-in method, passing the name of the event:\n\nThanks to the listener, the parent will receive the event and update the value of .\n\nWe can optionally declare emitted events using the option macro:\n\nThis documents all the events that a component emits and optionally validates them. It also allows Vue to avoid implicitly applying them as native listeners to the child component's root element.\n\nThat's all you need to know about custom component events for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Custom Events.\n\nJust like with HTML elements, it's often useful to be able to pass content to a component, like this:\n\nWhich might render something like:\n\nThis can be achieved using Vue's custom element:\n\nAs you'll see above, we use the as a placeholder where we want the content to go – and that's it. We're done!\n\nThat's all you need to know about slots for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on Slots.\n\nSometimes, it's useful to dynamically switch between components, like in a tabbed interface:\n\nThe above is made possible by Vue's element with the special attribute:\n\nIn the example above, the value passed to can contain either:\n• the name string of a registered component, OR\n\nYou can also use the attribute to create regular HTML elements.\n\nWhen switching between multiple components with , a component will be unmounted when it is switched away from. We can force the inactive components to stay \"alive\" with the built-in component.\n\nIf you are writing your Vue templates directly in the DOM, Vue will have to retrieve the template string from the DOM. This leads to some caveats due to browsers' native HTML parsing behavior.\n\nHTML tags and attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you’re using in-DOM templates, PascalCase component names and camelCased prop names or event names all need to use their kebab-cased (hyphen-delimited) equivalents:\n\nWe have been using self-closing tags for components in previous code samples:\n\nThis is because Vue's template parser respects as an indication to end any tag, regardless of its type.\n\nIn in-DOM templates, however, we must always include explicit closing tags:\n\nThis is because the HTML spec only allows a few specific elements to omit closing tags, the most common being and . For all other elements, if you omit the closing tag, the native HTML parser will think you never terminated the opening tag. For example, the following snippet:\n\nwill be parsed as:\n\nSome HTML elements, such as , , and have restrictions on what elements can appear inside them, and some elements such as , , and can only appear inside certain other elements.\n\nThis will lead to issues when using components with elements that have such restrictions. For example:\n\nThe custom component will be hoisted out as invalid content, causing errors in the eventual rendered output. We can use the special attribute as a workaround:\n\nThat's all you need to know about in-DOM template parsing caveats for now - and actually, the end of Vue's Essentials. Congratulations! There's still more to learn, but first, we recommend taking a break to play with Vue yourself - build something fun, or check out some of the Examples if you haven't already.\n\nOnce you feel comfortable with the knowledge you've just digested, move on with the guide to learn more about components in depth."
    },
    {
        "link": "https://vuejs.org/guide/essentials/reactivity-fundamentals.html",
        "document": "With the Options API, we use the option to declare reactive state of a component. The option value should be a function that returns an object. Vue will call the function when creating a new component instance, and wrap the returned object in its reactivity system. Any top-level properties of this object are proxied on the component instance ( in methods and lifecycle hooks): // `mounted` is a lifecycle hook which we will explain later // `this` refers to the component instance. // data can be mutated as well These instance properties are only added when the instance is first created, so you need to ensure they are all present in the object returned by the function. Where necessary, use , or some other placeholder value for properties where the desired value isn't yet available. It is possible to add a new property directly to without including it in . However, properties added this way will not be able to trigger reactive updates. Vue uses a prefix when exposing its own built-in APIs via the component instance. It also reserves the prefix for internal properties. You should avoid using names for top-level properties that start with either of these characters. In Vue 3, data is made reactive by leveraging JavaScript Proxies. Users coming from Vue 2 should be aware of the following edge case: When you access after assigning it, the value is a reactive proxy of the original . Unlike in Vue 2, the original is left intact and will not be made reactive: make sure to always access reactive state as a property of .\n\nIn Composition API, the recommended way to declare reactive state is using the function: takes the argument and returns it wrapped within a ref object with a property: To access refs in a component's template, declare and return them from a component's function: // `setup` is a special hook dedicated for the Composition API. // expose the ref to the template Notice that we did not need to append when using the ref in the template. For convenience, refs are automatically unwrapped when used inside templates (with a few caveats). You can also mutate a ref directly in event handlers: For more complex logic, we can declare functions that mutate refs in the same scope and expose them as methods alongside the state: // .value is needed in JavaScript // don't forget to expose the function as well. Exposed methods can then be used as event handlers: Here's the example live on Codepen, without using any build tools. Manually exposing state and methods via can be verbose. Luckily, it can be avoided when using Single-File Components (SFCs). We can simplify the usage with : Top-level imports, variables and functions declared in are automatically usable in the template of the same component. Think of the template as a JavaScript function declared in the same scope - it naturally has access to everything declared alongside it. For the rest of the guide, we will be primarily using SFC + syntax for the Composition API code examples, as that is the most common usage for Vue developers. If you are not using SFC, you can still use Composition API with the option. You might be wondering why we need refs with the instead of plain variables. To explain that, we will need to briefly discuss how Vue's reactivity system works. When you use a ref in a template, and change the ref's value later, Vue automatically detects the change and updates the DOM accordingly. This is made possible with a dependency-tracking based reactivity system. When a component is rendered for the first time, Vue tracks every ref that was used during the render. Later on, when a ref is mutated, it will trigger a re-render for components that are tracking it. In standard JavaScript, there is no way to detect the access or mutation of plain variables. However, we can intercept the get and set operations of an object's properties using getter and setter methods. The property gives Vue the opportunity to detect when a ref has been accessed or mutated. Under the hood, Vue performs the tracking in its getter, and performs triggering in its setter. Conceptually, you can think of a ref as an object that looks like this: Another nice trait of refs is that unlike plain variables, you can pass refs into functions while retaining access to the latest value and the reactivity connection. This is particularly useful when refactoring complex logic into reusable code. The reactivity system is discussed in more details in the Reactivity in Depth section.\n\nTo add methods to a component instance we use the option. This should be an object containing the desired methods: // methods can be called in lifecycle hooks, or other methods! Vue automatically binds the value for so that it always refers to the component instance. This ensures that a method retains the correct value if it's used as an event listener or callback. You should avoid using arrow functions when defining , as that prevents Vue from binding the appropriate value: // BAD: no `this` access here! Just like all other properties of the component instance, the are accessible from within the component's template. Inside a template they are most commonly used as event listeners: In the example above, the method will be called when the is clicked.\n\nRefs can hold any value type, including deeply nested objects, arrays, or JavaScript built-in data structures like . A ref will make its value deeply reactive. This means you can expect changes to be detected even when you mutate nested objects or arrays: // these will work as expected. Non-primitive values are turned into reactive proxies via , which is discussed below. It is also possible to opt-out of deep reactivity with shallow refs. For shallow refs, only access is tracked for reactivity. Shallow refs can be used for optimizing performance by avoiding the observation cost of large objects, or in cases where the inner state is managed by an external library.\n\nWhen you mutate reactive state, the DOM is updated automatically. However, it should be noted that the DOM updates are not applied synchronously. Instead, Vue buffers them until the \"next tick\" in the update cycle to ensure that each component updates only once no matter how many state changes you have made.\n\nTo wait for the DOM update to complete after a state change, you can use the nextTick() global API:\n\nThere is another way to declare reactive state, with the API. Unlike a ref which wraps the inner value in a special object, makes an object itself reactive: Reactive objects are JavaScript Proxies and behave just like normal objects. The difference is that Vue is able to intercept the access and mutation of all properties of a reactive object for reactivity tracking and triggering. converts the object deeply: nested objects are also wrapped with when accessed. It is also called by internally when the ref value is an object. Similar to shallow refs, there is also the API for opting-out of deep reactivity. It is important to note that the returned value from is a Proxy of the original object, which is not equal to the original object: // proxy is NOT equal to the original. Only the proxy is reactive - mutating the original object will not trigger updates. Therefore, the best practice when working with Vue's reactivity system is to exclusively use the proxied versions of your state. To ensure consistent access to the proxy, calling on the same object always returns the same proxy, and calling on an existing proxy also returns that same proxy: // calling reactive() on the same object returns the same proxy This rule applies to nested objects as well. Due to deep reactivity, nested objects inside a reactive object are also proxies: The API has a few limitations:\n• None Limited value types: it only works for object types (objects, arrays, and collection types such as and ). It cannot hold primitive types such as , or .\n• None Cannot replace entire object: since Vue's reactivity tracking works over property access, we must always keep the same reference to the reactive object. This means we can't easily \"replace\" a reactive object because the reactivity connection to the first reference is lost: // the above reference ({ count: 0 }) is no longer being tracked\n• None Not destructure-friendly: when we destructure a reactive object's primitive type property into local variables, or when we pass that property into a function, we will lose the reactivity connection: // count is disconnected from state.count when destructured. // won't be able to track changes to state.count // we have to pass the entire object in to retain reactivity Due to these limitations, we recommend using as the primary API for declaring reactive state. A ref is automatically unwrapped when accessed or mutated as a property of a reactive object. In other words, it behaves like a normal property: If a new ref is assigned to a property linked to an existing ref, it will replace the old ref: // original ref is now disconnected from state.count Ref unwrapping only happens when nested inside a deep reactive object. It does not apply when it is accessed as a property of a shallow reactive object. Unlike reactive objects, there is no unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like : Ref unwrapping in templates only applies if the ref is a top-level property in the template render context. In the example below, and are top-level properties, but is not: Therefore, this expression works as expected: ...while this one does NOT: The rendered result will be because is not unwrapped when evaluating the expression and remains a ref object. To fix this, we can destructure into a top-level property: Now the render result will be . Another thing to note is that a ref does get unwrapped if it is the final evaluated value of a text interpolation (i.e. a tag), so the following will render : This is just a convenience feature of text interpolation and is equivalent to ."
    },
    {
        "link": "https://stackoverflow.com/questions/76028025/vue-3-set-component-data-model-with-unknown-structure-using-option-api",
        "document": "My child component should be created with data model that I get externally using fetch. Structure of this model is not predetermined (kind of black box). Important thing is that I am working with detailed representation of some entity, not a list (array). I have few options how to do this, but I dont like any. Maybe there is better solution.\n• Use property. But vue documentation dont like this:\n\nAdding new properties to this.$data is possible, but it is not recommended\n• Set property in advance. This aproach hides all content of model. So in this case I have to use instead of ..\n\n3. Parent component provide model to child using . But I guess it is better when child is responsible for getting model and as a result holds all logic inside."
    },
    {
        "link": "https://stackoverflow.com/questions/64105088/vue-3-composition-api-data-function",
        "document": "Under the new Composition API, all of the variables that you previously defined in are just returned from your function as normal variables with reactive values. For example, a Vue 2.0 component that had a data function like so:\n\nbecomes this function in Vue 3:\n\nThe helper wraps a non-object value for reactivity, and wraps an object. This is exposing the underlying principles of Vue more clearly than the old way, where the wrapping happened \"magically\" behind the scenes, but will behave the same otherwise. What I like about it personally is that your function can build up your object on the go while keeping related things together, allowing it to tell a cohesive story and not require jumping around to different sections."
    },
    {
        "link": "https://vuejs.org/api/options-state.html",
        "document": "A function that returns the initial reactive state for the component instance.\n• None The function is expected to return a plain JavaScript object, which will be made reactive by Vue. After the instance is created, the reactive data object can be accessed as . The component instance also proxies all the properties found on the data object, so will be equivalent to . All top-level data properties must be included in the returned data object. Adding new properties to is possible, but it is not recommended. If the desired value of a property is not yet available then an empty value such as or should be included as a placeholder to ensure that Vue knows that the property exists. Properties that start with or will not be proxied on the component instance because they may conflict with Vue's internal properties and API methods. You will have to access them as . It is not recommended to return objects with their own stateful behavior like browser API objects and prototype properties. The returned object should ideally be a plain object that only represents the state of the component.\n• None Note that if you use an arrow function with the property, won't be the component's instance, but you can still access the instance as the function's first argument:\n• None See also Reactivity in Depth\n• None In Vue, all component props need to be explicitly declared. Component props can be declared in two forms:\n• Simple form using an array of strings\n• Full form using an object where each property key is the name of the prop, and the value is the prop's type (a constructor function) or advanced options. With object-based syntax, each prop can further define the following options:\n• None : Can be one of the following native constructors: , , , , , , , , any custom constructor function or an array of those. In development mode, Vue will check if a prop's value matches the declared type, and will throw a warning if it doesn't. See Prop Validation for more details. Also note that a prop with type affects its value casting behavior in both development and production. See Boolean Casting for more details.\n• None : Specifies a default value for the prop when it is not passed by the parent or has value. Object or array defaults must be returned using a factory function. The factory function also receives the raw props object as the argument.\n• None : Defines if the prop is required. In a non-production environment, a console warning will be thrown if this value is truthy and the prop is not passed.\n• None : Custom validator function that takes the prop value and props object as arguments. In development mode, a console warning will be thrown if this function returns a falsy value (i.e. the validation fails).\n\nDeclare computed properties to be exposed on the component instance.\n• None The option accepts an object where the key is the name of the computed property, and the value is either a computed getter, or an object with and methods (for writable computed properties). All getters and setters have their context automatically bound to the component instance. Note that if you use an arrow function with a computed property, won't point to the component's instance, but you can still access the instance as the function's first argument:\n\nDeclare methods to be mixed into the component instance.\n• None Declared methods can be directly accessed on the component instance, or used in template expressions. All methods have their context automatically bound to the component instance, even when passed around. Avoid using arrow functions when declaring methods, as they will not have access to the component instance via .\n\nDeclare watch callbacks to be invoked on data change.\n• None The option expects an object where keys are the reactive component instance properties to watch (e.g. properties declared via or ) — and values are the corresponding callbacks. The callback receives the new value and the old value of the watched source. In addition to a root-level property, the key can also be a simple dot-delimited path, e.g. . Note that this usage does not support complex expressions - only dot-delimited paths are supported. If you need to watch complex data sources, use the imperative API instead. The value can also be a string of a method name (declared via ), or an object that contains additional options. When using the object syntax, the callback should be declared under the field. Additional options include:\n• : trigger the callback immediately on watcher creation. Old value will be on the first call.\n• : force deep traversal of the source if it is an object or an array, so that the callback fires on deep mutations. See Deep Watchers.\n• : adjust the callback's flush timing. See Callback Flush Timing and . Avoid using arrow functions when declaring watch callbacks as they will not have access to the component instance via .\n• None // the callback will be called whenever any of the watched object properties change regardless of their nested depth // the callback will be called immediately after the start of the observation // you can pass array of callbacks, they will be called one-by-one\n\nDeclare the custom events emitted by the component.\n• None Emitted events can be declared in two forms:\n• Simple form using an array of strings\n• Full form using an object where each property key is the name of the event, and the value is either or a validator function. The validation function will receive the additional arguments passed to the component's call. For example, if is called, the corresponding validator for will receive the argument . The validator function should return a boolean to indicate whether the event arguments are valid. Note that the option affects which event listeners are considered component event listeners, rather than native DOM event listeners. The listeners for declared events will be removed from the component's object, so they will not be passed through to the component's root element. See Fallthrough Attributes for more details.\n\nDeclare exposed public properties when the component instance is accessed by a parent via template refs.\n• None By default, a component instance exposes all instance properties to the parent when accessed via , , or template refs. This can be undesirable, since a component most likely has internal state or methods that should be kept private to avoid tight coupling. The option expects a list of property name strings. When is used, only the properties explicitly listed will be exposed on the component's public instance. only affects user-defined properties - it does not filter out built-in component instance properties.\n• None // only `publicMethod` will be available on the public instance"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
        "document": "A JavaScript date is fundamentally specified as the time in milliseconds that has elapsed since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC (equivalent to the UNIX epoch). This timestamp is timezone-agnostic and uniquely defines an instant in history. Note: While the time value at the heart of a Date object is UTC, the basic methods to fetch the date and time or its components all work in the local (i.e. host system) time zone and offset. The maximum timestamp representable by a object is slightly smaller than the maximum safe integer ( , which is 9,007,199,254,740,991). A object can represent a maximum of ±8,640,000,000,000,000 milliseconds, or ±100,000,000 (one hundred million) days, relative to the epoch. This is the range from April 20, 271821 BC to September 13, 275760 AD. Any attempt to represent a time outside this range results in the object holding a timestamp value of , which is an \"Invalid Date\". There are various methods that allow you to interact with the timestamp stored in the date:\n• You can interact with the timestamp value directly using the and methods.\n• The and (when passed ) methods — which are automatically called in number coercion — return the timestamp, causing objects to behave like their timestamps when used in number contexts.\n• All static methods ( , , and ) return timestamps instead of objects.\n• The constructor can be called with a timestamp as the only argument.\n\nA date is represented internally as a single number, the timestamp. When interacting with it, the timestamp needs to be interpreted as a structured date-and-time representation. There are always two ways to interpret a timestamp: as a local time or as a Coordinated Universal Time (UTC), the global standard time defined by the World Time Standard. The local timezone is not stored in the date object, but is determined by the host environment (user's device). Note: UTC should not be confused with the Greenwich Mean Time (GMT), because they are not always equal — this is explained in more detail in the linked Wikipedia page. For example, the timestamp 0 represents a unique instant in history, but it can be interpreted in two ways:\n• As a UTC time, it is midnight at the beginning of January 1, 1970, UTC,\n• As a local time in New York (UTC-5), it is 19:00:00 on December 31, 1969. The method returns the difference between UTC and the local time in minutes. Note that the timezone offset does not only depend on the current timezone, but also on the time represented by the object, because of daylight saving time and historical changes. In essence, the timezone offset is the offset from UTC time, at the time represented by the object and at the location of the host environment. There are two groups of methods: one group gets and sets various date components by interpreting the timestamp as a local time, while the other uses UTC. The constructor can be called with two or more arguments, in which case they are interpreted as the year, month, day, hour, minute, second, and millisecond, respectively, in local time. works similarly, but it interprets the components as UTC time and also accepts a single argument representing the year. Note: Some methods, including the constructor, , and the deprecated / methods, interpret a two-digit year as a year in the 1900s. For example, is interpreted as June 24, 1999, not June 24, 99. See Interpretation of two-digit years for more information. When a segment overflows or underflows its expected range, it usually \"carries over to\" or \"borrows from\" the higher segment. For example, if the month is set to 12 (months are zero-based, so December is 11), it become the January of the next year. If the day of month is set to 0, it becomes the last day of the previous month. This also applies to dates specified with the date time string format.\n\nThere are many ways to format a date as a string. The JavaScript specification only specifies one format to be universally supported: the date time string format, a simplification of the ISO 8601 calendar date extended format. The format is as follows:\n• is the year, with four digits ( to ), or as an expanded year of or followed by six digits. The sign is required for expanded years. is explicitly disallowed as a valid year.\n• is the month, with two digits ( to ). Defaults to .\n• is the day of the month, with two digits ( to ). Defaults to .\n• is a literal character, which indicates the beginning of the time part of the string. The is required when specifying the time part.\n• is the hour, with two digits ( to ). As a special case, is allowed, and is interpreted as midnight at the beginning of the next day. Defaults to .\n• is the minute, with two digits ( to ). Defaults to .\n• is the second, with two digits ( to ). Defaults to .\n• is the millisecond, with three digits ( to ). Defaults to .\n• is the timezone offset, which can either be the literal character (indicating UTC), or or followed by , the offset in hours and minutes from UTC. Various components can be omitted, so the following are all valid:\n• Date-time form: one of the above date-only forms, followed by , followed by , , or . Each combination can be followed by a time zone offset. For example, (date-only form), (date-time form), or (date-time form with milliseconds and time zone) are all valid date time strings. When the time zone offset is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time. The interpretation as a UTC time is due to a historical spec error that was not consistent with ISO 8601 but could not be changed due to web compatibility. See Broken Parser – A Web Reality Issue. and the constructor both accept strings in the date time string format as input. Furthermore, implementations are allowed to support other date formats when the input fails to match this format. The method returns a string representation of the date in the date time string format, with the time zone offset always set to (UTC). Note: You are encouraged to make sure your input conforms to the date time string format above for maximum compatibility, because support for other formats is not guaranteed. However, there are some formats that are supported in all major implementations — like RFC 2822 format — in which case their usage can be acceptable. Always conduct cross-browser tests to ensure your code works in all target browsers. A library can help if many different formats are to be accommodated. Non-standard strings can be parsed in any way as desired by the implementation, including the time zone — most implementations use the local time zone by default. Implementations are not required to return invalid date for out-of-bounds date components, although they usually do. A string may have in-bounds date components (with the bounds defined above), but does not represent a date in reality (for example, \"February 30\"). Implementations behave inconsistently in this case. The page offers more examples about these non-standard cases.\n\nReturns the day of the month ( – ) for the specified date according to local time. Returns the day of the week ( – ) for the specified date according to local time. Returns the year (4 digits for 4-digit years) of the specified date according to local time. Returns the hour ( – ) in the specified date according to local time. Returns the milliseconds ( – ) in the specified date according to local time. Returns the minutes ( – ) in the specified date according to local time. Returns the month ( – ) in the specified date according to local time. Returns the seconds ( – ) in the specified date according to local time. Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970 00:00:00 UTC. (Negative values are returned for prior times.) Returns the time-zone offset in minutes for the current locale. Returns the day (date) of the month ( – ) in the specified date according to universal time. Returns the day of the week ( – ) in the specified date according to universal time. Returns the year (4 digits for 4-digit years) in the specified date according to universal time. Returns the hours ( – ) in the specified date according to universal time. Returns the milliseconds ( – ) in the specified date according to universal time. Returns the minutes ( – ) in the specified date according to universal time. Returns the month ( – ) in the specified date according to universal time. Returns the seconds ( – ) in the specified date according to universal time. Returns the year (usually 2–3 digits) in the specified date according to local time. Use instead. Sets the day of the month for a specified date according to local time. Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to local time. Sets the hours for a specified date according to local time. Sets the milliseconds for a specified date according to local time. Sets the minutes for a specified date according to local time. Sets the month for a specified date according to local time. Sets the seconds for a specified date according to local time. Sets the object to the time represented by the number of milliseconds since January 1, 1970 00:00:00 UTC. Use negative numbers for times prior. Sets the day of the month for a specified date according to universal time. Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to universal time. Sets the hour for a specified date according to universal time. Sets the milliseconds for a specified date according to universal time. Sets the minutes for a specified date according to universal time. Sets the month for a specified date according to universal time. Sets the seconds for a specified date according to universal time. Sets the year (usually 2–3 digits) for a specified date according to local time. Use instead. Returns the \"date\" portion of the as a human-readable string like . Converts a date to a string following the ISO 8601 Extended Format. Returns a string representing the using . Intended to be implicitly called by . Returns a string with a locality sensitive representation of the date portion of this date based on system settings. Returns a string with a locality-sensitive representation of this date. Overrides the method. Returns a string with a locality-sensitive representation of the time portion of this date, based on system settings. Returns a string representing the specified object. Overrides the method. Returns a new object with the same value as this date's timestamp. Returns the \"time\" portion of the as a human-readable string. Converts a date to a string using the UTC timezone. Returns the primitive value of a object. Overrides the method. Converts this object to a primitive value.\n\nexhibits legacy undesirable, inconsistent behavior with two-digit year values; specifically, when a call is given a two-digit year value, that year value does not get treated as a literal year and used as-is but instead gets interpreted as a relative offset — in some cases as an offset from the year , but in other cases, as an offset from the year . let date = new Date(98, 1); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT) date = new Date(22, 1); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT) date = new Date(\"2/1/22\"); // Tue Feb 01 2022 00:00:00 GMT+0000 (GMT) // Legacy method; always interprets two-digit year values as relative to 1900 date.setYear(98); date.toString(); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT) date.setYear(22); date.toString(); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT) So, to create and get dates between the years and , instead use the preferred and methods:. // Preferred method; never interprets any value as being a relative offset, // but instead uses the year value as-is date.setFullYear(98); date.getFullYear(); // 98 (not 1998) date.setFullYear(22); date.getFullYear(); // 22 (not 1922, not 2022)\n\nThe following examples show how to determine the elapsed time between two JavaScript dates in milliseconds. Due to the differing lengths of days (due to daylight saving changeover), months, and years, expressing elapsed time in units greater than hours, minutes, and seconds requires addressing a number of issues, and should be thoroughly researched before being attempted. // Using Date objects const start = Date.now(); // The event to time goes here: doSomethingForALongTime(); const end = Date.now(); const elapsed = end - start; // elapsed time in milliseconds // Using built-in methods const start = new Date(); // The event to time goes here: doSomethingForALongTime(); const end = new Date(); const elapsed = end.getTime() - start.getTime(); // elapsed time in milliseconds // To test a function and get back its return function printElapsedTime(testFn) { const startTime = Date.now(); const result = testFn(); const endTime = Date.now(); console.log(`Elapsed time: ${String(endTime - startTime)} milliseconds`); return result; } const yourFunctionReturn = printElapsedTime(yourFunction); Note: In browsers that support the Performance API's high-resolution time feature, can provide more reliable and precise measurements of elapsed time than ."
    },
    {
        "link": "https://stackoverflow.com/questions/4156434/javascript-get-the-first-day-of-the-week-from-current-date",
        "document": "I need the fastest way to get the first day of the week. For example: today is the 11th of November, and a Thursday; and I want the first day of this week, which is the 8th of November, and a Monday. I need the fastest method for MongoDB map function, any ideas?\n\nUsing the method of Date objects, you can know the number of day of the week (being 0=Sunday, 1=Monday, etc). You can then subtract that number of days plus one, for example: function getMonday(d) { d = new Date(d); var day = d.getDay(), diff = d.getDate() - day + (day == 0 ? -6 : 1); // adjust when day is sunday return new Date(d.setDate(diff)); } console.log( getMonday(new Date()) ); // e.g. Mon Nov 08 2010\n\nCMS's answer is correct but assumes that Monday is the first day of the week.\n\n Chandler Zwolle's answer is correct but fiddles with the Date prototype.\n\n Other answers that add/subtract hours/minutes/seconds/milliseconds are wrong because not all days have 24 hours. The function below is correct and takes a date as first parameter and the desired first day of the week as second parameter (0 for Sunday, 1 for Monday, etc.). Note: the hour, minutes and seconds are set to 0 to have the beginning of the day. function firstDayOfWeek(dateObject, firstDayOfWeekIndex) { const dayOfWeek = dateObject.getDay(), firstDayOfWeek = new Date(dateObject), diff = dayOfWeek >= firstDayOfWeekIndex ? dayOfWeek - firstDayOfWeekIndex : 6 - dayOfWeek firstDayOfWeek.setDate(dateObject.getDate() - diff) firstDayOfWeek.setHours(0,0,0,0) return firstDayOfWeek } // August 18th was a Saturday let lastMonday = firstDayOfWeek(new Date('August 18, 2018 03:24:00'), 1) // outputs something like \"Mon Aug 13 2018 00:00:00 GMT+0200\" // (may vary according to your time zone) document.write(lastMonday)\n\n📆 First / Last Day of The Week To get the upcoming first day of the week, you can use something like so: Or to get the latest first day: * Depending on your time zone, the beginning of the week doesn't has to start on Sunday, it can start on Friday, Saturday, Monday or any other day your machine is set to. Those methods will account for that. * You can also format it using method like so:\n\nThis function uses the current millisecond time to subtract the current week, and then subtracts one more week if the current date is on a monday (javascript counts from sunday). function getMonday(fromDate) { // length of one day i milliseconds var dayLength = 24 * 60 * 60 * 1000; // Get the current date (without time) var currentDate = new Date(fromDate.getFullYear(), fromDate.getMonth(), fromDate.getDate()); // Get the current date's millisecond for this week var currentWeekDayMillisecond = ((currentDate.getDay()) * dayLength); // subtract the current date with the current date's millisecond for this week var monday = new Date(currentDate.getTime() - currentWeekDayMillisecond + dayLength); if (monday > currentDate) { // It is sunday, so we need to go back further monday = new Date(monday.getTime() - (dayLength * 7)); } return monday; } I have tested it when week spans over from one month to another (and also years), and it seems to work properly.\n\nIt is important to discern between local time and UTC. I wanted to find the start of the week in UTC, so I used the following function. function start_of_week_utc(date, start_day = 1) { // Returns the start of the week containing a 'date'. Monday 00:00 UTC is // considered to be the boundary between adjacent weeks, unless 'start_day' is // specified. A Date object is returned. date = new Date(date); const day_of_month = date.getUTCDate(); const day_of_week = date.getUTCDay(); const difference_in_days = ( day_of_week >= start_day ? day_of_week - start_day : day_of_week - start_day + 7 ); date.setUTCDate(day_of_month - difference_in_days); date.setUTCHours(0); date.setUTCMinutes(0); date.setUTCSeconds(0); date.setUTCMilliseconds(0); return date; } To find the start of the week in a given timezone, first add the timezone offset to the input date and then subtract it from the output date.\n\nAccepted answer won't work for anyone who runs the code in UTC-XX:XX timezone. Here is code which will work regardless of timezone for date only. This won't work if you provide time too. Only provide date or parse date and provide it as input. I have mentioned different test cases at start of the code. function getDateForTheMonday(dateString) { var orignalDate = new Date(dateString) var modifiedDate = new Date(dateString) var day = modifiedDate.getDay() diff = modifiedDate.getDate() - day + (day == 0 ? -6:1);// adjust when day is sunday modifiedDate.setDate(diff) var diffInDate = orignalDate.getDate() - modifiedDate.getDate() if(diffInDate == 6) { diff = diff + 7 modifiedDate.setDate(diff) } console.log(\"Given Date : \" + orignalDate.toUTCString()) console.log(\"Modified date for Monday : \" + modifiedDate) } getDateForTheMonday(\"2022-08-01\") // Jul month with 31 Days getDateForTheMonday(\"2022-07-01\") // June month with 30 days getDateForTheMonday(\"2022-03-01\") // Non leap year February getDateForTheMonday(\"2020-03-01\") // Leap year February getDateForTheMonday(\"2022-01-01\") // First day of the year getDateForTheMonday(\"2021-12-31\") // Last day of the year"
    },
    {
        "link": "https://w3schools.com/js/js_date_methods.asp",
        "document": "In JavaScript, date objects are created with .\n\nreturns a date object with the current date and time.\n\nThe get methods return information from existing date objects. In a date object, the time is static. The \"clock\" is not \"running\". The time in a date object is NOT the same as current time.\n\nThe method returns the year of a date as a four digit number:\n\nThe method returns the month of a date as a number (0-11).\n\nThe method returns the day of a date as a number (1-31):\n\nThe method returns the hours of a date as a number (0-23):\n\nThe method returns the minutes of a date as a number (0-59):\n\nThe method returns the seconds of a date as a number (0-59):\n\nThe method returns the milliseconds of a date as a number (0-999):\n\nThe method returns the weekday of a date as a number (0-6).\n\nIn JavaScript, the first day of the week (day 0) is Sunday. Some countries in the world consider the first day of the week to be Monday.\n\nThe method returns the number of milliseconds since January 1, 1970:\n\nreturns the number of milliseconds since January 1, 1970.\n\nis a static method of the Date object.\n\nYou cannot use it on a date object like .\n\nThe syntax is always .\n\nUTC time is the same as GMT (Greenwich Mean Time).\n\nThe difference between Local time and UTC time can be up to 24 hours.\n\nThe method returns the difference (in minutes) between local time an UTC time:\n\nFor a complete Date reference, go to our: The reference contains descriptions and examples of all Date properties and methods."
    },
    {
        "link": "https://stackoverflow.com/questions/5210376/how-to-get-first-and-last-day-of-the-current-week-in-javascript",
        "document": "I have today = new Date(); object. I need to get first and last day of the current week. I need both variants for Sunday and Monday as a start and end day of the week. I am little bit confuse now with a code. Can your help me?\n\nvar curr = new Date; // get current date var first = curr.getDate() - curr.getDay(); // First day is the day of the month - the day of the week var last = first + 6; // last day is the first day + 6 var firstday = new Date(curr.setDate(first)).toUTCString(); var lastday = new Date(curr.setDate(last)).toUTCString(); firstday \"Sun, 06 Mar 2011 12:25:40 GMT\" lastday \"Sat, 12 Mar 2011 12:25:40 GMT\" This works for firstday = sunday of this week and last day = saturday for this week. Extending it to run Monday to sunday is trivial. Making it work with first and last days in different months is left as an exercise for the user\n\nHere's a quick way to get first and last day, for any start day. knowing that: Recipe: figure out how many days you need to remove to get the your week's start day (multiply by 1 day's worth of milliseconds). All that is left after that is to add 6 days to get your end day. var startDay = 1; //0=sunday, 1=monday etc. var d = now.getDay(); //get the current day var weekStart = new Date(now.valueOf() - (d<=0 ? 7-startDay:d-startDay)*86400000); //rewind to start day var weekEnd = new Date(weekStart.valueOf() + 6*86400000); //add 6 days to get last day\n\nwill sets the day of the month. Using during start and end of the month,will result in wrong week var curr = new Date(\"08-Jul-2014\"); // get current date var first = curr.getDate() - curr.getDay(); // First day is the day of the month - the day of the week var last = first + 6; // last day is the first day + 6 var firstday = new Date(curr.setDate(first)); // 06-Jul-2014 var lastday = new Date(curr.setDate(last)); //12-Jul-2014 If u setting Date is 01-Jul-2014, it will show firstday as 29-Jun-2014 and lastday as 05-Jun-2014 instead of 05-Jul-2014 So overcome this issue i used var curr = new Date(); day = curr.getDay(); firstday = new Date(curr.getTime() - 60*60*24* day*1000); //will return firstday (ie sunday) of the week lastday = new Date(firstday.getTime() + 60 * 60 *24 * 6 * 1000); //adding (60*60*6*24*1000) means adding six days to the firstday which results in lastday (saturday) of the week\n\nI recommend to use Moment.js for such cases. I had scenarios where I had to check current date time, this week, this month and this quarters date time. Above an answer helped me so I thought to share rest of the functions as well. Simply to get current date time in specific format Week starts from Sunday and ends on Saturday if we simply use 'week' as parameter for endOf function but to get Sunday as the end of the week we need to use 'isoweek'. I chose this format as per my need. You can change the format according to your requirement.\n\nAn old question with lots of answers, so another one won't be an issue. Some general functions to get the start and end of all sorts of time units. For startOf and endOf week, the start day of the week defaults to Sunday (0) but any day can be passed (Monday - 1, Tuesday - 2, etc.). Only uses Gregorian calendar though. The functions don't mutate the source date, so to see if a date is in the same week as some other date (week starting on Monday): if (d >= startOf('week', d1, 1) && d <= endOf('week', d1, 1)) { // d is in same week as d1 } or in the current week starting on Sunday: if (d >= startOf('week') && d <= endOf('week')) { // d is in the current week } // Returns a new Date object set to start of given unit // For start of week, accepts any day as start function startOf(unit, date = new Date(), weekStartDay = 0) { // Copy original so don't modify it let d = new Date(date); let e = new Date(d); e.setHours(23,59,59,999); // Define methods let start = { second: d => d.setMilliseconds(0), minute: d => d.setSeconds(0,0), hour : d => d.setMinutes(0,0,0), day : d => d.setHours(0,0,0,0), week : d => { start.day(d); d.setDate(d.getDate() - d.getDay() + weekStartDay); if (d > e) d.setDate(d.getDate() - 7); }, month : d => { start.day(d); d.setDate(1); }, year : d => { start.day(d); d.setMonth(0, 1); }, decade: d => { start.year(d); let year = d.getFullYear(); d.setFullYear(year - year % 10); }, century: d => { start.year(d); let year = d.getFullYear(); d.setFullYear(year - year % 100); }, millenium: d => { start.year(d); let year = d.getFullYear(); d.setFullYear(year - year % 1000); } } start[unit](d); return d; } // Returns a new Date object set to end of given unit // For end of week, accepts any day as start day // Requires startOf function endOf(unit, date = new Date(), weekStartDay = 0) { // Copy original so don't modify it let d = new Date(date); let e = new Date(date); e.setHours(23,59,59,999); // Define methods let end = { second: d => d.setMilliseconds(999), minute: d => d.setSeconds(59,999), hour : d => d.setMinutes(59,59,999), day : d => d.setHours(23,59,59,999), week : w => { w = startOf('week', w, weekStartDay); w.setDate(w.getDate() + 6); end.day(w); d = w; }, month : d => { d.setMonth(d.getMonth() + 1, 0); end.day(d); }, year : d => { d.setMonth(11, 31); end.day(d); }, decade: d => { end.year(d); let y = d.getFullYear(); d.setFullYear(y - y % 10 + 9); }, century: d => { end.year(d); let y = d.getFullYear(); d.setFullYear(y - y % 100 + 99); }, millenium: d => { end.year(d); let y = d.getFullYear(); d.setFullYear(y - y % 1000 + 999); } } end[unit](d); return d; } // Examples let d = new Date(); ['second','minute','hour','day','week','month','year', 'decade','century','millenium'].forEach(unit => { console.log(('Start of ' + unit).padEnd(18) + ': ' + startOf(unit, d).toString()); console.log(('End of ' + unit).padEnd(18) + ': ' + endOf(unit, d).toString()); });"
    },
    {
        "link": "https://bugfender.com/blog/javascript-date-and-time",
        "document": "Master JavaScript’s Date object with this comprehensive guide. Learn to manipulate, format, and compute dates and times effectively, overcoming common challenges and leveraging powerful APIs for robust applications.\n• Discover methods for getting the current date in various formats.\n• Gain insights into popular JavaScript libraries for improved date and time handling.\n\nThere are now nearly 9 million apps worldwide, and practically all of them run on an internal clock.\n\nFinancial apps are built on timestamped data. Office apps run on calendars. Social apps are defined by their feeds, timelines and anniversaries.\n\nSo, as devs, we need to know how to compute date and time. JavaScript, the world’s most popular programming language, has plenty of helpful APIs, but they can throw up complications if you’ve never used them before.\n\nIn this article we’re going to look into JavaScript , a standard built-in object for computing date and time. We’ll look at the issue of formatting, dive deep into its related aspects, and study the list of Date APIs in detail, so you can become a master in dealing with JavaScript dates.\n\nWe’ll also look at the different use cases for JavaScript dates in programming, so you can see the challenges, as well as the benefits, in action.\n\nBefore we start talking about JavaScript, let’s have a quick history lesson.\n\nThe term refers to a specific point in time that happened in the past. In JavaScript, this is defined as midnight at the beginning of January 1, 1970, UTC (Coordinated Universal Time).\n\nThis snapshot serves as a reference-point for every single time-stamp in most development languages. In other words, we always refer back to this date as our own ‘Big Bang’ moment.\n\nThis referral process isn’t always user-friendly. However, JavaScript Date provides methods and properties to make it simpler.\n\nYou can use JavaScript Date to manipulate, format, and compare dates and times; convert between Date objects and epoch timestamps; and perform various other, more advanced operations.\n\nThe simplest way to create a Date object with today’s date in JavaScript is by using the keyword.\n\nIn JavaScript, you can create a Date object in several ways, according to your specific use cases.\n\nThe most common way to create a Date object is using the constructor or passing an argument to the constructor.\n\nThis returns the current date and time in the local timezone when you do not pass any argument to it.\n\nThis is the output (taken from my local computer at the moment of execution).\n\nYou can create a Date object by passing individual date and time components (year, month, day, hour, minute, second, and millisecond) as arguments to the constructor.\n\nSo the output will be:\n\nAs the arguments are optional, you must be mindful of how the Date constructor behaves when we omit one or more arguments.\n\nYou can create a object by passing a date and time string as an argument to the constructor. The string should be in a standardized date and time format.\n\nA date-time representation, like the one we’ve used in the example below, is not standardized and it may only work in some of the environments.\n\nYou can create a Date Object by passing a timestamp, representing the total number of seconds (or even milliseconds), since the epoch snapshot (January 1, 1970).\n\nWhen you work with dates, one of the standard requirements is to get the current date.\n\nWithout an argument, we have seen that the constructor returns the current date and time. But it returns a long date-time representation.\n\nThankfully, JavaScript provides multiple other ways to get the current date.\n\nWith the Date Object, we can use methods like , , and to get the current year, month, and date, respectively.\n\nWe can now combine these methods to form the current date representation.\n\nA few things to note here:\n• You are free to change the date format the way you want. The above example outputs the date in the format . In case you want , you can use:\n• The month as a single digit may not look great. In fact you probably want the date to look like than . To tackle this, you can use the string method . It adds padding (with another string) to a given string until it reaches a specified length. To put 0 before 9, we have to pad the month string value with a “0” until it reaches length 2 and results in the string .\n\nThe same applies to the date value.\n\nThe static method returns the current timestamp in milliseconds. This is the local time elapsed since the epoch.\n\nWe know that the constructor can create a Date object by passing the timestamp milliseconds as an argument. Hence, we can pass the to the Date constructor to get the current date and time.\n\nIf you are interested only in the date portion of the returned value, you can typecast the value to a string and use the method.\n\nThe method of the Date object returns the current date and time in the . That is .\n\nYou can extract the current date value using the same method we applied before.\n\nThe simplest and most effective method to get the current date into a JavaScript string is using the method from the Date object.\n\nYou can pass the locale as an argument to the method to get a locale-specific date. For example, to get the current date in the German locale, you can pass as the argument.\n\nTo calculate the elapsed time between two dates in JavaScript, you can subtract one Date Object from another to get the difference in milliseconds and then convert that into the desired units (e.g., seconds, minutes, hours, or days).\n\nPlease note: Calculating the elapsed time between two dates in JavaScript, considering daylight saving time (DST), requires a bit more complexity because DST can affect the length of a day. You need an additional code to find the time differences between the two dates.\n\nOne way of calculating it, including the DST, will be like this:\n\nThere are many ways we can do deal with date format in JavaScript.\n\nWe have seen some of them while discussing how to create a Date object. However, the ECMAScript Internationalization(Intl) API provides a more flexible way to handle date-time format in JavaScript.\n\nYou can create language-sensitive (in other words, locale-aware formats) date and time using the API. When you do not specify a locale, the uses the default locale.\n\nThe above code will output “17/10/2023” when you run with en-US locale (language) and time zone IST (UTC+0530). When you need a localized date, you must explicitly pass it to the method.\n\nHere is the output:\n\nPassing an invalid/unsupported locale will fall back to the default locale formatting.\n\nTo give the following output:\n\nThat’s not all. You can also pass options to the to get the desired formatted output.\n\nCheck out the code snippet below. We have passed the option to obtain the date in a format where a day is a numeric number, and the month name should be a long-formatted numeric year, and a long-formatted weekday. Also, we want this put out in the locale.\n\nPlease feel free to explore this API here.\n\nWhen your JavaScript app goes live and you need to support users worldwide, you might face problems with different time zones or date formats. A remote logging tool can be very helpful in fixing these issues.\n\nMany popular JavaScript-based libraries have built wrappers over the JavaScript Date Object’s built-in methods to solve critical use cases.\n\nIt is impossible to list them all, but here are the top five versions I’ve used in the last few years.\n• date-fns: is a modern JavaScript date utility library that provides a wide range of functions for formatting, parsing, manipulating, and comparing dates and times. It emphasizes simplicity and immutability.\n• Moment.js: was one of the most popular date libraries in the JavaScript ecosystem. It provides a comprehensive set of date manipulation and formatting functions. However, as of September 2020, it has been considered legacy, and its developers recommend using or for new projects.\n• Luxon: focuses on providing a clean API for parsing, formatting, and manipulating dates, while also considering internationalization and time zone support.\n• Day.js: is a minimalist JavaScript library for date manipulation and formatting. It aims to be lightweight and easy to use, providing a simple API for common date tasks.\n• timeago.js: is a lightweight(~2KBs) nano library used to format date and time with statement (e.g.: ‘2 hours ago’). It has support for React, Python, and plain JavaScript.\n\nYou must have realized by now that the JavaScript Date object is vast. There are a few shortcomings too.\n• We need more easy-to-use Date and Time APIs\n• The Date object doesn’t have support for non-Gregorian calendars.\n• Parsing a date from the string may not always give reliable results.\n• Computation for the DST is difficult.\n\nThe API, now in proposal, aims to solve all the problems we have pointed out above. You can read more about this proposal here.\n\nAs the Temporal API is in the experimental stage, it is not yet ready for production usage. If you want to try it out today, please install the polyfill.\n\nThen you can import it into your script file.\n\nAfter that, you can start using the API methods.\n\nThe JavaScript Date Object allows you to manipulate, format, and compare JavaScript dates and times. It is used for converting between Date JS objects and epoch timestamps and performing other advanced operations​. The most common way to create a Date object in JavaScript is by using the constructor, which returns the current date and time in the local timezone when no argument is passed​ To get the current date, you can use the constructor without passing any arguments. This returns the current date and time in a long date-time representation​​. To format a JavaScript date as “yyyy-mm-dd”, you can use the object and extract the year, month, and day components, then concatenate them into a string with the desired format. const date = new Date(); const year = date.getFullYear(); const month = String(date.getMonth() + 1).padStart(2, '0'); // getMonth() returns 0-11, so add 1 const day = String(date.getDate()).padStart(2, '0'); const formattedDate = `${year}-${month}-${day}`; console.log(formattedDate); // outputs date in yyyy-mm-dd format You can use other libraries like Moment.js or date fns, which offer convenient functions to format dates: To compare dates in JavaScript, you can use the method to convert the dates to timestamps and then compare these timestamps. For example: if (date1.getTime() < date2.getTime()) { // date1 is earlier } else if (date1.getTime() > date2.getTime()) { // date2 is earlier } else { // dates are the same } To add days to a JavaScript date, create a object and use the method along with the method. To get the day of the week from a JavaScript you can use the method of a object, which returns a number corresponding to the day of the week (0 for Sunday, 1 for Monday, etc.).\n• JavaScript Date object has lots to offer. There are plenty of methods to deal with date, time, and their manipulations.\n• We can create JavaScript Date objects in various ways.\n• The methods provided to obtain day, month, year, and date are handy. However, the method doesn’t return the month name directly.\n• The is a much more precise and effective way to get locale-aware dates.\n• There are many ways to format date and time in JavaScript. ECMAScript’s Intl Date APIs provide the most flexible way to handle formatting.\n• We have popular date-time libraries to get and manipulate dates.\n• The Temporal Date API is a promising one to explore.\n\nI hope the article was insightful and provided you with enough details to learn and explore the JavaScript Date object.\n\nIf you are interested in JavaScript development, you can also explore the following articles related to JavaScript development:\n• Unlocking the Magic of JavaScript Asynchronous Programming: Mastering Callbacks, Promises, and Async/Await"
    }
]