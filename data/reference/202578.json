[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nThe interface, part of the Canvas API, provides the 2D rendering context for the drawing surface of a element. It is used for drawing shapes, text, images, and other objects. The interface's properties and methods are described in the reference section of this page. The Canvas tutorial has more explanation, examples, and resources, as well. For , there is an equivalent interface that provides the rendering context. The offscreen rendering context inherits most of the same properties and methods as the and is described in more detail in the reference page.\n\nTo get a instance, you must first have an HTML element to work with: To get the canvas' 2D rendering context, call on the element, supplying as the argument: With the context in hand, you can draw anything you like. This code draws a house: The resulting drawing looks like this:\n\nThe following methods can be used to manipulate paths of objects. Starts a new path by emptying the list of sub-paths. Call this method when you want to create a new path. Causes the point of the pen to move back to the start of the current sub-path. It tries to draw a straight line from the current point to the start. If the shape has already been closed or has only one point, this function does nothing. Moves the starting point of a new sub-path to the (x, y) coordinates. Connects the last point in the current sub-path to the specified (x, y) coordinates with a straight line. Adds an arc to the current path with the given control points and radius, connected to the previous point by a straight line. Adds an elliptical arc to the current path. Creates a path for a rectangle at position (x, y) with a size that is determined by width and height. Creates a path for a rounded rectangle with a specified position, width, height, and corner radii.\n\nObjects in the rendering context have a current transformation matrix and methods to manipulate it. The transformation matrix is applied when creating the current default path, painting text, shapes and objects. The methods listed below remain for historical and compatibility reasons as objects are used in most parts of the API nowadays and will be used in the future instead. Retrieves the current transformation matrix being applied to the context. Adds a rotation to the transformation matrix. The angle argument represents a clockwise rotation angle and is expressed in radians. Adds a scaling transformation to the canvas units by x horizontally and by y vertically. Adds a translation transformation by moving the canvas and its origin x horizontally and y vertically on the grid. Multiplies the current transformation matrix with the matrix described by its arguments. Resets the current transform to the identity matrix, and then invokes the method with the same arguments. Resets the current transform by the identity matrix.\n\nThe rendering context contains a variety of drawing style states (attributes for line styles, fill styles, shadow styles, text styles). The following methods help you to work with that state: Saves the current drawing style state using a stack so you can revert any change you make to it using . Restores the drawing style state to the last element on the 'state stack' saved by . A read-only back-reference to the . Might be if it is not associated with a element. Returns an object containing the context attributes used by the browser. Context attributes can be requested when using to create the 2D context. Resets the rendering context, including the backing buffer, the drawing state stack, path, and styles. Returns if the rendering context was lost."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API",
        "document": "The Canvas API provides a means for drawing graphics via JavaScript and the HTML element. Among other things, it can be used for animation, game graphics, data visualization, photo manipulation, and real-time video processing. The Canvas API largely focuses on 2D graphics. The WebGL API, which also uses the element, draws hardware-accelerated 2D and 3D graphics.\n\nThe method gets a reference to the HTML element. Next, the method gets that element's context—the thing onto which the drawing will be rendered. The actual drawing is done using the interface. The property makes the rectangle green. The method places its top-left corner at (10, 10), and gives it a size of 150 units wide by 100 tall.\n\nThe Canvas API is extremely powerful, but not always simple to use. The libraries listed below can make the creation of canvas-based projects faster and easier.\n• EaselJS is an open-source canvas library that makes creating games, generative art, and other highly graphical experiences easy.\n• Fabric.js is an open-source canvas library with SVG parsing capabilities.\n• heatmap.js is an open-source library for creating canvas-based data heat maps.\n• Konva.js is a 2D canvas library for desktop and mobile applications.\n• p5.js has a full set of canvas drawing functionality for artists, designers, educators, and beginners.\n• Paper.js is an open-source vector graphics scripting framework that runs on top of the HTML Canvas.\n• Phaser is a fast, free and fun open source framework for Canvas and WebGL powered browser games.\n• Pts.js is a library for creative coding and visualization in canvas and SVG.\n• Rekapi is an animation key-framing API for Canvas.\n• Scrawl-canvas is an open-source JavaScript library for creating and manipulating 2D canvas elements.\n• The ZIM framework provides conveniences, components, and controls for coding creativity on the canvas — includes accessibility and hundreds of colorful tutorials.\n• Sprig is a beginner-friendly, open-source, tile-based game development library that uses Canvas. Note: See the WebGL API for 2D and 3D libraries that use WebGL."
    },
    {
        "link": "https://docs.tizen.org/application/web/guides/w3c/graphics/canvas",
        "document": "The HTML5 canvas allows you to use graphics on the screen, and draw and manage various shapes. The HTML Canvas 2D Context API (in mobile, wearable, and TV applications) defines a special canvas element that expresses images or shapes with JavaScript.\n\nThe main features of the Canvas Element API include the following:\n• To draw and manage shapes, you must insert a <canvas> element in the HTML page.\n• You can use images on the canvas by using the applicable method of the HTML Canvas 2D Context API.\n• With the HTML Canvas 2D Context API, you can draw various shapes, such as rectangles, circles, and lines to a canvas. You can also draw and mask objects on the canvas.\n• You can use a canvas to create text or lines other than images and shapes.\n\nFor all canvas objects (images, shapes, text, and lines), you can define colors (the and attributes), shadows (the and attributes), and gradation (the method). You can also use the transformation methods, such as , , , and , to implement, for example, transparency or shape gradient transformations.\n\nIn mobile applications only, in HTML5, the Scalable Vector Graphics (SVG) 2 API provides similar features as the canvas. Their difference is that SVG expresses graphics using vectors, while the canvas is based on pixels. To express complex graphics, use the canvas, and to express graphics with a liberal expansion or reduction, use SVG.\n\nTo create a canvas in your application, follow these steps:\n• The canvas assigns the region (canvas context) where images are drawn with JavaScript: If no and attributes are inserted, the default value is .\n• To check the information on the image connected to the canvas, use the method to restore the URL of the image used on the canvas. To create a blob object of the image file, use the method.\n• Use the interface (in mobile, wearable, and TV applications) to connect to the canvas and get the canvas context: The interface has various methods and attributes for expressing images and shapes.\n• To manage the work stack of the canvas, use the following methods:\n• : Pushes the current state onto the stack.\n• : Pops the top state on the stack, restoring the context to that state.\n\nThere is a need to separately check whether the canvas 2D context can be used by using the method:\n\nFor the complete source code related to this use case, see the following files:\n\nUse images on the canvas\n\nTo use images on the canvas, use the method of the HTML Canvas 2D Context API. The method receives information, such as the image URL and position, and where it is indicated, and then creates the image on the canvas. The created image is pixel-based.\n\nTo use images on a canvas, follow these steps:\n• Use the method to express an image on the canvas. When you define the URL of the image to be imported and its coordinates, the original image is imported as it is. You can hide certain parts of the image by assigning its size accordingly:\n• When the image is connected to the canvas, extract the color value through the method. Re-input the transformed values with the method:\n• Use the interface to transform the selected object, for example, its size, angle, or position. By connecting to the image used on the canvas, you can also rotate it: The following figure applies to mobile applications only.\n\nFor the complete source code related to this use case, see the following files:\n\nWith the HTML Canvas 2D Context API, you can draw various shapes, such as rectangles ( ), circles ( and ), and lines ( and ), to a canvas. You can define the position and size of the shapes, and also merge shapes with other shape objects.\n\nTo create and draw shapes on a canvas, follow these steps:\n• Use the method to create a rectangle. Use the canvas context to assign the rectangle attributes, such as position and size: The following figure applies to mobile applications only.\n• Use the method to create a circle. Use the canvas context to assign the circle attributes, such as position and radius. (The following figure applies to mobile applications only.)\n• Use the interface to transform the created shapes. With compositing, a certain part of the shape can be made transparent. The following figure applies to mobile applications only.\n\nFor the complete source code related to this use case, see the following file:\n\nTo draw masks on a canvas, follow these steps:\n• Create the HTML layout with a canvas and 2 button input elements for brush selection:\n• Define the CSS style for the background image:\n• Declare the JavaScript variables needed in the application. The and variables indicate the last position of a user event. The variable indicates whether a button or touch event has occurred, and the variable indicates the current brush size:\n• Draw an image on the canvas using the method. The user is able to replace the image with another using a brush. Create a new object, including the path of the image file. Define the line width to be based on the brush size selected by the user:\n• The and events only store the event coordinates, the and events define the position and direction of the drawing, and the and events indicate that the user event ends, as illustrated in the following figure.\n• Use the method to update the and variable values. The real coordinates can be calculated by reducing the offset position of the canvas element from the touch position coordinates. The string indicates that the event is a touch event:\n• When the user starts drawing, the or event calls the method, which updates the event position, sets the composite operations property to make the drawing a mask, begins to draw a new path, moves the drawing point to the selected coordinates, and sets the button or touch event state to :\n• While the user is drawing, the and events are handled with the method based on the button state retrieved from the variable. The method calls the method only when the mouse or finger is being moved. Use the method to make the drawn line visible:\n• When the touch event ends or the mouse button is released, use the method to stop drawing:\n\nFor the complete source code related to this use case, see the following file:\n\nCreat text and lines on the canvas\n\nTo create text and lines on a canvas, follow these steps:\n• To draw a line, use the method to assign the beginning point of the line, and the method to assign the end point of the line. The method draws the full line:\n• When adding text on the canvas, use various attributes and methods to define how the text looks and where it is located. The attribute defines the font style, and the attribute the vertical alignment of the text:\n• Use the attribute and the method to position the text in the assigned location:\n\nFor the complete source code related to this use case, see the following files:\n\nPerformance comparison of Canvas 2D and WebGL™ in mobile applications\n\nIn Web documents prior to HTML5, only simple image loading was supported. To create graphic animations, you had to use a separate plug-in. However, as the graphic-related APIs have become more standardized, you can now express graphics by using only JavaScript, without a separate plug-in.\n\nWhen developing Web applications that need to express complex graphics, such as games, the most important issue to consider is graphic performance. Currently, the HTML Canvas 2D Context API and WebGL™ are used to express graphic elements in many games. The following example illustrates how to create an effective graphic animation by comparing the performance of the renderers in the Canvas 2D Context API and WebGL™.\n\nTo compare the performance, 2 simple Web applications must be created, using the Canvas 2D Context API and WebGL™:\n• Create the applications with the following logic:\n• Render the loaded image in the random location of the canvas.\n• Use the method of the Timing control for script-based animations API (in mobile, wearable, and TV applications) to change the color of the loaded image, based on different times.\n• Create a logic that measures FPS (frames per second) in order to check the performance.\n• Execute the applications and measure the FPS.\n• Increase only the number of objects so that the same 1~N images, under the same conditions, are shown repeatedly based on 1~N.\n• Measure the FPS as the number of repeatedly shown objects increase.\n\nThe following figure shows the result of the test: As the number of objects increase, the performance of the Canvas 2D Context API rapidly decreases compared to WebGL™ (the result is subject to change according to the complexity of the application logic). As such, when expressing many graphic objects all differently, it is much more efficient to use WebGL™ than the Canvas 2D Context API.\n\nThere is one problem with using WebGL™; the ratio of mobile browsers supporting it is quite low compared to the Canvas 2D Context API, and even when it is supported, usually only partial features are included (support for 3D acceleration, reflection effect, and camera effect is particularly low). The following figure shows the support status of WebGL™ in computer (top) and mobile (bottom) browsers, as published in http://webglstats.com/ in June 2013.\n\nMany mobile browsers do not support WebGL™ or only partially support WebGL™. Even though Tizen supports WebGL™, it is recommended to use the Canvas 2D Context API for small numbers of 2D drawings, since the API is supported in most mobile browsers. However, for performance critical applications, use WebGL™ for faster 2D performance."
    },
    {
        "link": "https://w3.org/TR/2013/WD-2dcontext2-20130528",
        "document": "This specification defines the 2D Context for the HTML element. The 2D Context provides objects, methods, and properties to draw and manipulate graphics on a drawing surface.\n\nThis section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at http://www.w3.org/TR/.\n\nIf you wish to make comments regarding this document in a manner that is tracked by the W3C, please submit them via using our public bug database. If you cannot do this then you can also e-mail feedback to public-html-comments@w3.org (subscribe, archives), and arrangements will be made to transpose the comments to our public bug database. All feedback is welcome.\n\nWork on extending this specification typically proceeds through extension specifications which should be consulted to see what new features are being reviewed.\n\nThe bulk of the text of this specification is also available in the WHATWG HTML Living Standard, under a license that permits reuse of the specification text.\n\nThe working groups maintains a list of all bug reports that the editors have not yet tried to address and a list of issues for which the chairs have not yet declared a decision. You are very welcome to file a new bug for any problem you may encounter. These bugs and issues apply to multiple HTML-related specifications, not just this one.\n\nImplementors should be aware that this specification is not stable. Implementors who are not taking part in the discussions are likely to find the specification changing out from under them in incompatible ways. Vendors interested in implementing this specification before it eventually reaches the Candidate Recommendation stage should join the aforementioned mailing lists and take part in the discussions.\n\nPublication as a Working Draft does not imply endorsement by the W3C Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.\n\nThe latest stable version of the editor's draft of this specification is always available on the W3C HTML git repository.\n\nThe W3C HTML Working Group is the W3C working group responsible for this specification's progress along the W3C Recommendation track. This specification is the 28 May 2013 Working Draft.\n\nWork on this specification is also done at the WHATWG. The W3C HTML working group actively pursues convergence with the WHATWG, as required by the W3C HTML working group charter. There are various ways to follow this work at the WHATWG:\n\nThis specification is an extension to the HTML5 language. All normative content in the HTML5 specification, unless specifically overridden by this specification, is intended to be the basis for this specification.\n\nThis document was produced by a group operating under the 5 February 2004 W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.\n\nThis specification is an HTML specification. All the conformance requirements, conformance classes, definitions, dependencies, terminology, and typographical conventions described in the core HTML5 specification apply to this specification. [HTML5]\n\nInterfaces are defined in terms of Web IDL. [WEBIDL]\n\nThis specification defines the context type, whose API is implemented using the interface.\n\nThe 2D context represents a flat Cartesian surface whose origin (0,0) is at the top left corner, with the coordinate space having values increasing when going right, and values increasing when going down.\n\nEach context maintains a stack of drawing states. consist of:\n• The current values of the following attributes: , , , , , , , , , , , , , , , .\n\nThe current default path and the current bitmap are not part of the drawing state. The current default path is persistent, and can only be reset using the method. The current bitmap is a property of the canvas, not the context.\n\nAll the line styles (line width, caps, joins, and dash patterns) and text styles (fonts) described in the next two sections apply to objects and to objects. This section defines the constructor used to obtain a object. This object is then used by methods on objects to control how text and paths are rasterised and stroked.\n\nObjects that implement the interface have attributes and methods (defined in this section) that control how lines are treated by the object. The attribute gives the width of lines, in coordinate space units. On getting, it must return the current value. On setting, zero, negative, infinite, and NaN values must be ignored, leaving the value unchanged; other values must change the current value to the new value. When the object implementing the interface is created, the attribute must initially have the value . The attribute defines the type of endings that UAs will place on the end of lines. The three valid values are , , and . On getting, it must return the current value. On setting, if the new value is one of the literal strings , , and , then the current value must be changed to the new value; other values must ignored, leaving the value unchanged. When the object implementing the interface is created, the attribute must initially have the value . The attribute defines the type of corners that UAs will place where two lines meet. The three valid values are , , and . On getting, it must return the current value. On setting, if the new value is one of the literal strings , , and , then the current value must be changed to the new value; other values must be ignored, leaving the value unchanged. When the object implementing the interface is created, the attribute must initially have the value . When the attribute has the value , strokes use the miter limit ratio to decide how to render joins. The miter limit ratio can be explicitly set using the attribute. On getting, it must return the current value. On setting, zero, negative, infinite, and NaN values must be ignored, leaving the value unchanged; other values must change the current value to the new value. When the object implementing the interface is created, the attribute must initially have the value . Each object has a , which is either empty or consists of an even number of positive non-zero numbers. Initially, the dash list must be empty. When the method is invoked, it must run the following steps:\n• None If any value in is not finite (e.g. an Infinity or a NaN value), or if any value is negative (less than zero), then abort these steps (without throwing an exception; user agents could show a message on a developer console, though, as that would be helpful for debugging).\n• None If the number of elements in is odd, then let be the concatentation of two copies of .\n• None Let the object's dash list be . When the method is invoked, it must return a newly created sequence whose values are the values of the object's dash list, in the same order. It is sometimes useful to change the \"phase\" of the dash pattern, e.g. to achieve a \"marching ants\" effect. The phase can be set using the attribute. On getting, it must return the current value. On setting, infinite and NaN values must be ignored, leaving the value unchanged; other values must change the current value to the new value. When the object implementing the interface is created, the attribute must initially have the value . This element has three rectangles that are stroked with dashed lines. The attribute is used to create a \"marching ants\" effect. <!DOCTYPE html> <html> <head> <title>Dash line example</title> </head> <body> <canvas id=\"MyCanvas\" width=\"500\" height=\"400\">This browser or document mode doesn't support canvas</canvas> <script type=\"text/javascript\"> var antOffset = 0; // Starting value for ant offset var dashList = [12, 3, 3, 3]; // Create a dot/dash sequence function draw() { var canvas = document.getElementById(\"MyCanvas\"); if (canvas.getContext) { var ctx = canvas.getContext(\"2d\"); ctx.clearRect(0, 0, canvas.width, canvas.height); // Assign the dashList for the dash sequence ctx.setLineDash(dashList); // Get the current offset ctx.lineDashOffset = antOffset; ctx.lineJoin = \"round\"; ctx.lineWidth = \"3\"; ctx.strokeStyle = \"blue\"; ctx.strokeRect(5, 5, 300, 250); ctx.strokeStyle = \"red\"; ctx.strokeRect(150, 200, 300, 150); ctx.lineDashOffset = -antOffset; ctx.lineWidth = \"7\"; ctx.strokeStyle = \"green\"; ctx.strokeRect(250, 50, 150, 250); } } function doAnts() { antOffset++; if (antOffset > 20) // Reset offset after total of dashList values { antOffset = 0; } draw(); setTimeout(doAnts, 30); // Set a leisurely march of 30ms } doAnts(); // Start the demo </script> </body> </html> When a user agent is to , given an object that implements the interface, it must run the following algorithm. This algorithm returns a new path.\n• None Let be a copy of the path being traced.\n• None Remove from any subpaths containing no lines (i.e. empty subpaths with zero points, and subpaths with just one point).\n• None Replace each point in each subpath of other than the first point and the last point of each subpath by a join that joins the line leading to that point to the line leading out of that point, such that the subpaths all consist of two points (a starting point with a line leading out of it, and an ending point with a line leading into it), one or more lines (connecting the points and the joins), and zero or more joins (each connecting one line to another), connected together such that each subpath is a series of one or more lines with a join between each one and a point on each end.\n• None Add a straight closing line to each closed subpath in connecting the last point and the first point of that subpath; change the last point to a join (from the previously last line to the newly added closing line), and change the first point to a join (from the newly added closing line to the first line).\n• None If the dash list is empty, jump to the step labeled joins.\n• None Let be the aggregate length of all the lines of all the subpaths in , in coordinate space units.\n• None Let be the value of the , in coordinate space units.\n• While is greater than , decrement it by . While is less than , increment it by .\n• None Offset subpath: If is non-zero, add a new subpath at the start of consisting of two points connected by a line whose length is coordinate space units. (This path is temporary and will be removed in the joins step below. Its purpose is to offset the dash pattern.)\n• None Define to be a linear coordinate line defined along all lines in all the subpaths in , such that the start of the first line in the first subpath is defined as coordinate 0, and the end of the last line in the last subpath is defined as coordinate .\n• None Let be off (the other states being on and zero-on).\n• None Dash On: Let be the value of the dash list's th entry.\n• None If is greater than , then jump to the step labeled joins.\n• None If is non-zero, let be on.\n• None Dash Off: Let be the value of the dash list's th entry.\n• None Let be the offset on .\n• None If is greater than , then let be the offset on . Otherwise, let be the offset on .\n• Jump to the first appropriate step: If is zero and is off Do nothing, just continue to the next step. If is off Cut the line on which finds itself short at and place a point there, cutting the subpath that it was in in two; remove all line segments, joins, points, and subpaths that are between and ; and finally place a single point at with no lines connecting to it. The point has a directionality for the purposes of drawing line caps (see below). The directionality is the direction that the original line had at that point (i.e. when was defined above). Cut the line on which finds itself into two at and place a point there, cutting the subpath that it was in in two, and similarly cut the line on which finds itself short at and place a point there, cutting the subpath that it was in in two, and then remove all line segments, joins, points, and subpaths that are between and . If and are the same point, then this results in just the line being cut in two and two points being inserted there, with nothing being removed, unless a join also happens to be at that point, in which case the join must be removed.\n• None If is greater than , then jump to the step labeled joins.\n• None If is greater than zero, let be false.\n• None Increment by one. If it is equal to the number of entries in the dash list, then let be 0.\n• None Return to the step labeled dash on.\n• None Joins: Remove from any subpath that originally formed part of the subpath added in the offset subpath step above.\n• Create a new path that describes the result of inflating the paths in perpendicular to the direction of the path to the width, replacing each point with the end cap necessary to satisfy the attribute as described previously and elaborated below, and replacing each join with the join necessary to satisfy the type, as defined below. Caps: Each point has a flat edge perpendicular to the direction of the line coming out of it. This is them augmented according to the value of the . The value means that no additional line cap is added. The value means that a semi-circle with the diameter equal to the width must additionally be placed on to the line coming out of each point. The value means that a rectangle with the length of the width and the width of half the width, placed flat against the edge perpendicular to the direction of the line coming out of the point, must be added at each point. Points with no lines coming out of them must have two caps placed back-to-back as if it was really two points connected to each other by an infinitesimally short straight line in the direction of the point's directionality (as defined above). Joins: In addition to the point where a join occurs, two additional points are relevant to each join, one for each line: the two corners found half the line width away from the join point, one perpendicular to each line, each on the side furthest from the other line. A filled triangle connecting these two opposite corners with a straight line, with the third point of the triangle being the join point, must be added at all joins. The attribute controls whether anything else is rendered. The three aforementioned values have the following meanings: The value means that this is all that is rendered at joins. The value means that a filled arc connecting the two aforementioned corners of the join, abutting (and not overlapping) the aforementioned triangle, with the diameter equal to the line width and the origin at the point of the join, must be added at joins. The value means that a second filled triangle must (if it can given the miter length) be added at the join, with one line being the line between the two aforementioned corners, abutting the first triangle, and the other two being continuations of the outside edges of the two joining lines, as long as required to intersect without going over the miter length. The miter length is the distance from the point where the join occurs to the intersection of the line edges on the outside of the join. The miter limit ratio is the maximum allowed ratio of the miter length to half the line width. If the miter length would cause the miter limit ratio (as set by the attribute) to be exceeded, this second triangle must not be added. Subpaths in the newly created path must wind clockwise, regardless of the direction of paths in .\n\nThe attribute's allowed keywords correspond to alignment points in the font:\n\nThe keywords map to these alignment points as follows:\n\nThe is as follows. It takes as input a string , a object , and an optional length . It returns an array of glyph shapes, each positioned on a common coordinate space, and a whose value is one of left, right, and center. (Most callers of this algorithm ignore the .)\n• None If was provided but is less than or equal to zero, return an empty array.\n• None Replace all the space characters in with U+0020 SPACE characters.\n• None Let be the current font of , as given by that object's attribute.\n• Apply the appropriate step from the following list to determine the value of : If the object's font style source node is an element Let be of the object's font style source node. If the object's font style source node is a and that has a root element child Let be of the object's font style source node's root element child. If the object's font style source node is a and that has no root element child\n• None Form a hypothetical infinitely-wide CSS line box containing a single inline box containing the text , with all the properties at their initial values except the 'font' property of the inline box set to , the 'direction' property of the inline box set to , and the 'white-space' property set to 'pre'. [CSS]\n• None If was provided and the hypothetical width of the inline box in the hypothetical line box is greater than CSS pixels, then change to have a more condensed font (if one is available or if a reasonably readable one can be synthesized by applying a horizontal scale factor to the font) or a smaller font, and return to the previous step.\n• The is a point on the inline box, and the is one of the values left, right, and center. These variables are determined by the and values as follows: If is and is 'ltr' If is and is 'rtl' Let the 's horizontal position be the left edge of the inline box, and let be left. If is and is 'ltr' If is and is 'rtl' Let the 's horizontal position be the right edge of the inline box, and let be right. Let the 's horizontal position be half way between the left and right edges of the inline box, and let be center. Let the 's vertical position be the top of the em box of the first available font of the inline box. Let the 's vertical position be the hanging baseline of the first available font of the inline box. Let the 's vertical position be half way between the bottom and the top of the em box of the first available font of the inline box. Let the 's vertical position be the alphabetic baseline of the first available font of the inline box. Let the 's vertical position be the ideographic baseline of the first available font of the inline box. Let the 's vertical position be the bottom of the em box of the first available font of the inline box.\n• Let be an array constructed by iterating over each glyph in the inline box from left to right (if any), adding to the array, for each glyph, the shape of the glyph as it is in the inline box, positioned on a coordinate space using CSS pixels with its origin is at the .\n• None Return , and, for callers that need it, as the alignment value.\n\nEach object implementing the interface has a path. A has a list of zero or more subpaths. Each subpath consists of a list of one or more points, connected by straight or curved lines, and a flag indicating whether the subpath is closed or not. A closed subpath is one where the last point of the subpath is connected to the first point of the subpath by a straight line. Subpaths with fewer than two points are ignored when painting the path.\n\nWhen an object implementing the interface is created, its path must be initialized to zero subpaths.\n\nThe following methods allow authors to manipulate the paths of objects implementing the interface. For objects, the points and lines added to current default path by these methods must be transformed according to the current transformation matrix before they are added to the path. The method must create a new subpath with the specified point as its first (and only) point. When the user agent is to for a coordinate ( , ) on a path, the user agent must check to see if the path has any subpaths, and if it does not, then the user agent must create a new subpath with the point ( , ) as its first (and only) point, as if the method had been called. The method must do nothing if the object's path has no subpaths. Otherwise, it must mark the last subpath as closed, create a new subpath whose first point is the same as the previous subpath's first point, and finally add this new subpath to the path. If the last subpath had more than one point in its list of points, then this is equivalent to adding a straight line connecting the last point back to the first point, thus \"closing\" the shape, and then repeating the last (possibly implied) call. New points and the lines connecting them are added to subpaths using the methods described below. In all cases, the methods only modify the last subpath in the object's path. The method must ensure there is a subpath for ( , ) if the object's path has no subpaths. Otherwise, it must connect the last point in the subpath to the given point ( , ) using a straight line, and must then add the given point ( , ) to the subpath. The method must ensure there is a subpath for ( , ), and then must connect the last point in the subpath to the given point ( , ) using a quadratic Bézier curve with control point ( , ), and must then add the given point ( , ) to the subpath. [BEZIER] The method must ensure there is a subpath for ( , ), and then must connect the last point in the subpath to the given point ( , ) using a cubic Bézier curve with control points ( , ) and ( , ). Then, it must add the point ( , ) to the subpath. [BEZIER] The method must first ensure there is a subpath for ( , ). Then, the behavior depends on the arguments and the last point in the subpath, as described below. Negative values for must cause the implementation to throw an exception. Let the point ( , ) be the last point in the subpath. If the point ( , ) is equal to the point ( , ), or if the point ( , ) is equal to the point ( , ), or if the radius is zero, then the method must add the point ( , ) to the subpath, and connect that point to the previous point ( , ) by a straight line. Otherwise, if the points ( , ), ( , ), and ( , ) all lie on a single straight line, then the method must add the point ( , ) to the subpath, and connect that point to the previous point ( , ) by a straight line. Otherwise, let be the shortest arc given by circumference of the ellipse that has radius on the major axis and radius on the minor axis, and whose semi-major axis is rotated radians clockwise from the positive x-axis, and that has one point tangent to the half-infinite line that crosses the point ( , ) and ends at the point ( , ), and that has a different point tangent to the half-infinite line that ends at the point ( , ), and that has a different point tangent to the half-infinite line that ends at the point ( , ) and crosses the point ( , ). The points at which this ellipse touches these two lines are called the start and end tangent points respectively. The method must connect the point ( , ) to the start tangent point by a straight line, adding the start tangent point to the subpath, and then must connect the start tangent point to the end tangent point by , adding the end tangent point to the subpath. The method is equivalent to the method in the case where the two radii are equal. When the method is invoked, it must act as if the method had been invoked with the and arguments set to the value of the argument, the argument set to zero, and the other arguments set to the same values as their identically named arguments on the method. When the method is invoked, it must proceed as follows. First, if the object's path has any subpaths, then the method must add a straight line from the last point in the subpath to the start point of the arc. Then, it must add the start and end points of the arc to the subpath, and connect them with an arc. The arc and its start and end points are defined as follows: Consider an ellipse that has its origin at ( , ), that has a major-axis radius and a minor-axis radius , and that is rotated about its origin such that its semi-major axis is inclined radians clockwise from the x-axis. The points at and along this circle's circumference, measured in radians clockwise from the ellipse's semi-major axis, are the start and end points respectively. If the argument false and - is equal to or greater than 2π, or, if the argument is true and - is equal to or greater than 2π, then the arc is the whole circumference of this ellipse. Otherwise, the arc is the path along the circumference of this ellipse from the start point to the end point, going anti-clockwise if the argument is true, and clockwise otherwise. Since the points are on the ellipse, as opposed to being simply angles from zero, the arc can never cover an angle greater than 2π radians. Negative values for or must cause the implementation to throw an exception. The method must create a new subpath containing just the four points ( , ), ( + , ), ( + , + ), ( , + ), with those four points connected by straight lines, and must then mark the subpath as closed. It must then create a new subpath with the point ( , ) as the only point in the subpath.\n\nobjects can be used to declare paths that are then later used on objects. In addition to many of the APIs described in earlier sections, objects have methods to combine paths, and to add text to paths.\n\nEach object has a current transformation matrix, as well as methods (described in this section) to manipulate it. When a object is created, its transformation matrix must be initialized to the identity transform.\n\nThe transformation matrix is applied to coordinates when creating the current default path, and when painting text, shapes, and objects, on objects.\n\nMost of the API uses objects rather than this API. This API remains mostly for historical reasons.\n\nThe arguments , , , , , and are sometimes called , , , , , and or , , , , , and . Care should be taken in particular with the order of the second and third arguments ( and ) as their order varies from API to API and APIs sometimes use the notation / and sometimes / for those positions.\n\nThere are two types of gradients, linear gradients and radial gradients, both represented by objects implementing the opaque interface.\n\nOnce a gradient has been created (see below), stops are placed along it to define how the colors are distributed along the gradient. The color of the gradient at each stop is the color specified for that stop. Between each such stop, the colors and the alpha component must be linearly interpolated over the RGBA space without premultiplying the alpha value to find the color to use at that offset. Before the first stop, the color must be the color of the first stop. After the last stop, the color must be the color of the last stop. When there are no stops, the gradient is transparent black.\n\nPatterns are represented by objects implementing the opaque interface.\n\nThere are three methods that immediately draw rectangles to the bitmap. They each take four arguments; the first two give the and coordinates of the top left of the rectangle, and the second two give the width and height of the rectangle, respectively.\n\nA future version of the 2D context API may provide a way to render fragments of documents, rendered using CSS, straight to the canvas. This would be provided in preference to a dedicated way of doing multiline layout.\n\nThe context always has a . There is only one current default path, it is not part of the drawing state. The current default path is a path, as described above.\n\nTo draw images onto the canvas, the method can be used.\n\nThis method can be invoked with three different sets of arguments:\n\nEach of those three can take either an , an , or an for the argument.\n\nEach element whose primary context is a object must have a associated with its bitmap.\n\nThe hit region list is a list of hit regions.\n\nEach consists of the following information:\n• None A on the element's bitmap for which this region is responsible.\n• None A on the element's bitmap that surrounds the hit region's set of pixels as they stood when it was created.\n• None Optionally, a non-empty string representing an for distinguishing the region from others.\n• None Optionally, a reference to another region that acts as the for this one.\n• None A count of regions that have this one as their parent, known as the .\n• None A , in the form of either a CSS cursor value, or the string \" \" meaning that the cursor of the hit region's parent, if any, or of the element, if not, is to be used instead.\n• Optionally, either a control, or an unbacked region description. A is just a reference to an node, to which, in certain conditions, the user agent will route events, and from which the user agent will determine the state of the hit region for the purposes of accessibility tools. An consists of the following:\n• None An , which, if the unbacked region description also has a label, could be the empty string.\n\nThe interface is extended to support hit regions:\n\nThe constructor, when invoked, must return a newly created object with an existing data array. The object must be initialized so that its attribute is set to , the number of physical device pixels per row in the image data, their attribute is set to , the number of rows in the image data, and the attribute is initialized to an existing object. The object must use a Canvas Pixel for its storage, and must have a zero start offset and a length equal to the length of its storage, in bytes. The method is used to instantiate new blank objects. When the method is invoked with two arguments and , it must return an object representing a rectangle with a width in CSS pixels equal to the absolute magnitude of and a height in CSS pixels equal to the absolute magnitude of . When invoked with a single argument, it must return an object representing a rectangle with the same dimensions as the object passed as the argument. The object returned must be filled with transparent black. The method must, if the element's origin-clean flag is set to false, throw a exception; otherwise, it must return an object representing the underlying pixel data for the area of the canvas denoted by the rectangle whose corners are the four points ( , ), ( + , ), ( + , + ), ( , + ), in canvas coordinate space units. Pixels outside the canvas must be returned as transparent black. Pixels must be returned as non-premultiplied alpha values. If any of the arguments to or are infinite or NaN, the method must instead throw a exception. If either the or arguments are zero, the method must instead throw an exception. objects must be initialized so that their attribute is set to , the number of physical device pixels per row in the image data, their attribute is set to , the number of rows in the image data, and their attribute is initialized to a object. The object must use a Canvas Pixel for its storage, and must have a zero start offset and a length equal to the length of its storage, in bytes. The Canvas Pixel must contain the image data. At least one pixel's worth of image data must be returned. [TYPEDARRAY] A is an that whose data is represented in left-to-right order, row by row top to bottom, starting with the top left, with each pixel's red, green, blue, and alpha components being given in that order for each pixel. Each component of each device pixel represented in this array must be in the range 0..255, representing the 8 bit value for that component. The components must be assigned consecutive indices starting with 0 for the top left pixel's red component. [TYPEDARRAY] The method writes data from structures back to the canvas. If any of the arguments to the method are infinite or NaN, the method must throw a exception. When the last four arguments are omitted, they must be assumed to have the values 0, 0, the member of the structure, and the member of the structure, respectively. When invoked with arguments that do not, per the last few paragraphs, cause an exception to be thrown, the method must act as follows:\n• Let be the x-coordinate of the device pixel in the underlying pixel data of the canvas corresponding to the coordinate in the canvas coordinate space. Let be the y-coordinate of the device pixel in the underlying pixel data of the canvas corresponding to the coordinate in the canvas coordinate space.\n• If is negative, let be + , and let be equal to the absolute magnitude of . If is negative, let be + , and let be equal to the absolute magnitude of .\n• If is negative, let be + , and let be zero. If is negative, let be + , and let be zero.\n• If + is greater than the attribute of the argument, let be the value of that attribute, minus the value of . If + is greater than the attribute of the argument, let be the value of that attribute, minus the value of .\n• If, after those changes, either or is negative or zero, stop these steps without affecting the canvas.\n• None Otherwise, for all integer values of and where ≤ < + and ≤ < + , copy the four channels of the pixel with coordinate ( , ) in the data structure to the pixel with coordinate ( + , + ) in the underlying pixel data of the canvas. The handling of pixel rounding when the specified coordinates do not exactly map to the device coordinate space is not defined by this specification, except that the following must result in no visible changes to the rendering: ...for any value of , , , and and where is the smaller of and the sum of and , and is the smaller of and the sum of and ; and except that the following two calls: ...must return objects with the same dimensions, for any value of and . In other words, while user agents may round the arguments of these methods so that they map to device pixel boundaries, any rounding performed must be performed consistently for all of the , and operations. This implies that the data returned by is at the resolution of the canvas backing store. This is likely to not be one device pixel to each CSS pixel if the display used is a high resolution display. Due to the lossy nature of converting to and from premultiplied alpha color values, pixels that have just been set using might be returned to an equivalent as different values. The current path, transformation matrix, shadow attributes, global alpha, the clipping region, and global composition operator must not affect the and methods.\n\nAll drawing operations are affected by the four global shadow attributes.\n\nIf the current composition operation is , shadows effectively won't render (since the shape will overwrite the shadow).\n\nWhen a canvas is interactive, authors should include focusable elements in the element's fallback content corresponding to each focusable part of the canvas, as in the example above.\n\nTo indicate which focusable part of the canvas is currently focused, authors should use the method, passing it the element for which a ring is being drawn. This method only draws the focus ring if the element is focused, so that it can simply be called whenever drawing the element, without checking whether the element is focused or not first.\n\nAuthors should avoid implementing text editing controls using the element. Doing so has a large number of disadvantages:\n• Mouse placement of the caret has to be reimplemented.\n• Keyboard movement of the caret has to be reimplemented (possibly across lines, for multiline text input).\n• Scrolling of the text field has to be implemented (horizontally for long lines, vertically for multiline input).\n• Native features such as copy-and-paste have to be reimplemented.\n• Native features such as spell-checking have to be reimplemented.\n• Native features such as drag-and-drop have to be reimplemented.\n• Native features such as page-wide text search have to be reimplemented.\n• Native features specific to the user, for example custom text services, have to be reimplemented. This is close to impossible since each user might have different services installed, and there is an unbounded set of possible such services.\n• Bidirectional text editing has to be reimplemented.\n• For multiline text editing, line wrapping has to be implemented for all relevant languages.\n• Text selection has to be reimplemented.\n• Dragging of bidirectional text selections has to be reimplemented.\n• Platform-native keyboard shortcuts have to be reimplemented.\n• Platform-native input method editors (IMEs) have to be reimplemented.\n• Undo and redo functionality has to be reimplemented.\n• Accessibility features such as magnification following the caret or selection have to be reimplemented.\n\nThis is a huge amount of work, and authors are most strongly encouraged to avoid doing any of it by instead using the element, the element, or the attribute.\n\nAll references are normative unless marked \"Non-normative\"."
    },
    {
        "link": "https://w3schools.com/jsref/api_canvas.asp",
        "document": "You access a element with the HTML DOM method .\n\nTo draw in the canvas you need to create a 2D context object:\n\nThe common way to draw on the canvas is to:\n\nThere are only 3 methods to draw directly on the canvas:\n\nThe canvas object also supports the standard properties and events.\n\nThe element is an HTML5 standard (2014).\n\nis supported in all modern browsers:"
    },
    {
        "link": "https://stackoverflow.com/questions/8205828/html5-canvas-performance-and-optimization-tips-tricks-and-coding-best-practices",
        "document": "DO YOU KNOW SOME MORE BEST PRACTICES FOR CANVAS??\n\nPlease add to this thread what you know, have learned, or have read online any and all Canvas best practices, tips/tricks for performance\n\nWith Canvas being still very new to internet, and no signs of it ever getting old that I can see in the future, there are not too many documented \"best practices\" or other really important tips that are a 'must know' for developing with it in any one particular place. Things like this are scattered around and many times on lesser known sites.\n\nThere's so many things that people need to know about, and still so much to learn about too.\n\nI wanted to share some things to help people who are learning Canvas and maybe some who already know it quite well and am hoping to get some feedback from others about what they feel are some best practices or other tips and tricks for working with Canvas in HTML5.\n\nI want to start off with one I personally found to be quite a useful yet surprisingly uncommon thing for developers to do.\n\nJust as you would any other time, in any other language whatever the case may be. It has been a best practice for everything else, and I have come to find that in a complex canvas app, things can get a little confusing when dealing with several different contexts and saved/restore states. Not to mention the code is just more readable and overall cleaner looking too.\n\nIs the IF statement not easier and cleaner to read and know what is what immediately going on than the ELSE statement in this? Can you see what I'm saying here? I think this should be a method that developers should continue to practice just as they would when writing plain 'ol javascript or any other language even.\n\nUse requestAnimationFrame instead of setInterval / setTimeout\n\nsetInterval and setTimeout were never intended to be used as animation timers, they're just generic methods for calling functions after a time delay. If you set an interval for 20ms in the future, but your queue of functions takes longer than that to execute, your timer won't fire until after these functions have completed. That could be a while, which isn't ideal where animation is concerned. RequestAnimationFrame is a method which tells the browser that an animation is taking place, so it can optimize repaints accordingly. It also throttles the animation for inactive tabs, so it won't kill your mobile device's battery if you leave it open in the background.\n\nNicholas Zakas wrote a hugely detailed and informative article about requestAnimationFrame on his blog which is well worth reading. If you want some hard and fast implementation instructions, then Paul Irish has written a requestAnimationFrame shim – this is what I've used in every one of the Canvas apps I have made until recently.\n\nEven better than using requestAnimationFrame in place of setTimeout and setInterval, Joe Lambert has written a NEW and improved shim called requestInterval and requestTimeout, which he explains what issues exist when using requestAnimFrame. You can view the gist of the script.\n\nNow that all the browsers have caught up on the spec for this, there has been an update to the requestAnimFrame() polyfill, one which will probably remain the one to use to cover all vendors.\n\nUse more than one canvas\n\nA technique for animation-heavy games which @nicolahibbert wrote about in a post of hers on optimizing Canvas games mentions that it may be better to use multiple canvasses layered on top of one another rather than do everything in a single canvas. Nicola explains that \"drawing too many pixels to the same canvas at the same time will cause your frame rate to fall through the floor. Take Breakout for example. Trying to draw the bricks, the ball, the paddle, any power-ups or weapons, and then each star in the background – this simply won't work, it takes too long to execute each of these instructions in turn. By splitting the starfield and the rest of the game onto separate canvases, you are able to ensure a decent framerate.\"\n\nI have had to do this for a few apps I've made including Samsung's Olympic Genome Project facebook app. It's an extremely useful thing to know and to make use of whether it's needed or not. It decreases load time immensely, plus it can be a really useful technique to load images off screen since they can sometimes take a while.\n\nNotice that the src of the image is set after it is loaded. This is a key thing to remember to do too. Once the images are done loading and drawn into these temp canvases, you can then draw them to your main canvas by using the same ctx.drawImage(), but instead of putting the image as the first argument, you use 'tmpCtx.canvas' to reference the temp canvas.\n• Some more canvas and JS tests\n\nThe 2d context has a back reference to it's associated DOM element:\n\nI'd love to hear more from other people on this. I am working on making a list of things that we should standardize to add a new section to my company's Front-end Code Standards and Best Practices. I'd love to get as much feedback on this as I can."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Performance/JavaScript",
        "document": "It is very important to consider how you are using JavaScript on your websites and think about how to mitigate any performance issues that it might be causing. While images and video account for over 70% of the bytes downloaded for the average website, byte per byte, JavaScript has a greater potential for negative performance impact — it can significantly impact download times, rendering performance, and CPU and battery usage. This article introduces tips and techniques for optimizing JavaScript to enhance the performance of your website. To learn about the effects of JavaScript on web performance and how to mitigate or fix related issues.\n\nTo optimize or not to optimize The first question you should answer before starting to optimize your code is \"what do I need to optimize?\". Some of the tips and techniques discussed below are good practices that will benefit just about any web project, whereas some are only needed in certain situations. Trying to apply all these techniques everywhere is probably unnecessary, and may be a waste of your time. You should figure out what performance optimizations are actually needed in each project. To do this, you need to measure the performance of your site. As the previous link shows, there are several different ways to measure performance, some involving sophisticated performance APIs. The best way to get started however, is to learn how to use tools such as built-in browser network and performance tools, to see what parts of the page load are taking a long time and need optimizing.\n\nThe most performant, least blocking JavaScript you can use is JavaScript that you don't use at all. You should use as little JavaScript as possible. Some tips to bear in mind:\n• You don't always need a framework: You might be familiar with using a JavaScript framework. If you are experienced and confident with using this framework, and like all of the tooling it provides, then it might be your go-to tool for building most projects. However, frameworks are JavaScript-heavy. If you are creating a fairly static experience with few JavaScript requirements, you probably don't need that framework. You might be able to implement what you need using a few lines of standard JavaScript.\n• Consider a simpler solution: You might have a flashy, interesting solution to implement, but consider whether your users will appreciate it. Would they prefer something simpler?\n• Remove unused code: This may sound obvious, but it is surprising how many developers forget to clean up unused functionality that was added during the development process. You need to be careful and deliberate about what is added and removed. All script gets parsed, whether it is used or not; therefore, a quick win to speed up downloads would be to get rid of any functionality not being used. Consider also that often you will only use a small amount of the functionality available in a framework. Is it possible to create a custom build of the framework that only contains the part that you need?\n• Consider built-in browser features: It might be that you can use a feature the browser already has, rather than creating your own via JavaScript. For example:\n• Use the browser's own player.\n• Use CSS animations instead of a JavaScript animation library (see also Handling animations). You should also split your JavaScript into multiple files representing critical and non-critical parts. JavaScript modules allow you to do this more efficiently than just using separate external JavaScript files. Then you can optimize these smaller files. Minification reduces the number of characters in your file, thereby reducing the number of bytes or weight of your JavaScript. Gzipping compresses the file further and should be used even if you don't minify your code. Brotli is similar to Gzip, but generally outperforms Gzip compression. You can split and optimize your code manually, but often a module bundler like webpack will do a better job of this.\n\nBefore looking at the tips contained in this section, it is important to talk about where in the process of browser page rendering JavaScript is handled. When a web page is loaded:\n• The HTML is generally parsed first, in the order in which it appears on the page.\n• Whenever CSS is encountered, it is parsed to understand the styles that need to be applied to the page. During this time, linked assets such as images and web fonts start to be fetched.\n• Whenever JavaScript is encountered, the browser parses, evaluates, and runs it against the page.\n• Slightly later on, the browser works out how each HTML element should be styled, given the CSS applied to it.\n• The styled result is then painted to the screen. Note: This is a very simplified account of what happens, but it does give you an idea. The key step here is Step 3. By default, JavaScript parsing and execution are render-blocking. This means that the browser blocks the parsing of any HTML that appears after the JavaScript is encountered, until the script has been handled. As a result, styling and painting are blocked too. This means that you need to think carefully not only about what you are downloading, but also about when and how that code is being executed. The next few sections provide useful techniques for optimizing the parsing and execution of your JavaScript.\n\nLoading critical assets as soon as possible If a script is really important and you are concerned that it is affecting performance by not being loaded quickly enough, you can load it inside the of the document: This works OK, but is render-blocking. A better strategy is to use to create a preloader for critical JavaScript: The preload fetches the JavaScript as soon as possible, without blocking rendering. You can then use it wherever you want in your page: or inside your script, in the case of a JavaScript module: Note: Preloading does not guarantee that the script will be loaded by the time you include it, but it does mean that it will start being downloaded sooner. Render-blocking time will still be shortened, even if it is not completely removed.\n\nOn the other hand, you should aim to defer parsing and execution of non-critical JavaScript to later on, when it is needed. Loading it all up-front blocks rendering unnecessarily. First of all, you can add the attribute to your elements: This causes the script to be fetched in parallel with the DOM parsing, so it will be ready at the same time and won't block rendering. Note: There is another attribute, , which causes the script to be executed after the document has been parsed, but before firing the event. This has a similar effect to . You could also just not load the JavaScript at all until an event occurs when it is needed. This could be done via DOM scripting, for example: const scriptElem = document.createElement(\"script\"); scriptElem.src = \"index.js\"; scriptElem.addEventListener(\"load\", () => { // Run a function contained within index.js once it has definitely loaded init(); }); document.head.append(scriptElem); JavaScript modules can be dynamically loaded using the function: import(\"./modules/myModule.js\").then((module) => { // Do something with the module });\n\nWhen the browser runs your JavaScript, it will organize the script into tasks that are run sequentially, such as making fetch requests, driving user interactions and input through event handlers, running JavaScript-driven animation, and so on. Most of this happens on the main thread, with exceptions including JavaScript that runs in Web Workers. The main thread can run only one task at a time. When a single task takes longer than 50 ms to run, it is classified as a long task. If the user attempts to interact with the page or an important UI update is requested while a long task is running, their experience will be affected. An expected response or visual update will be delayed, resulting in the UI appearing sluggish or unresponsive. To mitigate this issue, you need to break down long tasks into smaller tasks. This gives the browser more chances to perform vital user interaction handling or UI rendering updates — the browser can potentially do them between each smaller task, rather than only before or after the long task. In your JavaScript, you might do this by breaking your code into separate functions. This also makes sense for several other reasons, such as easier maintenance, debugging, and writing tests. However, this kind of structure doesn't help with main thread blocking. Since all the five functions are being run inside one main function, the browser runs them all as a single long task. To handle this, we tend to run a \"yield\" function periodically to get the code to yield to the main thread. This means that our code is split into multiple tasks, between the execution of which the browser is given the opportunity to handle high-priority tasks such as updating the UI. A common pattern for this function uses to postpone execution into a separate task: This can be used inside a task runner pattern like so, to yield to the main thread after each task has been run: async function main() { // Create an array of functions to run const tasks = [a, b, c, d, e]; // Loop over the tasks while (tasks.length > 0) { // Shift the first task off the tasks array const task = tasks.shift(); // Run the task task(); // Yield to the main thread await yield(); } } To improve this further, we can use where available to allow this code to continue executing ahead of other less critical tasks in the queue: function yield() { // Use scheduler.yield() if available if (\"scheduler\" in window && \"yield\" in scheduler) { return scheduler.yield(); } // Fall back to setTimeout: return new Promise((resolve) => { setTimeout(resolve, 0); }); }\n\nAnimations can improve perceived performance, making interfaces feel snappier and making users feel like progress is being made when they are waiting for a page to load (loading spinners, for example). However, larger animations and a higher number of animations will naturally require more processing power to handle, which can degrade performance. The most obvious piece of animation advice is to use less animations — cut out any non-essential animations, or consider giving your users a preference they can set to turn off animations, for example if they are using a low-powered device or a mobile device with limited battery power. For essential DOM animations, you are advised to use CSS animations where possible, rather than JavaScript animations (the Web Animations API provides a way to directly hook into CSS animations using JavaScript). Using the browser to directly perform DOM animations rather than manipulating inline styles using JavaScript is much faster and more efficient. See also CSS performance optimization > Handling animations. For animations that can't be handled in JavaScript, for example, animating an HTML , you are advised to use rather than older options such as . The method is specially designed for handling animation frames efficiently and consistently, for a smooth user experience. The basic pattern looks like this: function loop() { // Clear the canvas before drawing the next frame of the animation ctx.fillStyle = \"rgb(0 0 0 / 25%)\"; ctx.fillRect(0, 0, width, height); // Draw objects on the canvas and update their positioning data // ready for the next frame for (const ball of balls) { ball.draw(); ball.update(); } // Call requestAnimationFrame to run the loop() function again // at the right time to keep the animation smooth requestAnimationFrame(loop); } // Call the loop() function once to set the animation running loop(); You can find a nice introduction to canvas animations at Drawing graphics > Animations, and a more in-depth example at Object building practice. You can also find a full set of canvas tutorials at Canvas tutorial.\n\nEvents can be expensive for the browser to track and handle, especially when you are running an event continuously. For example, you might be tracking the position of the mouse using the event to check whether it is still inside a certain area of the page: function handleMouseMove() { // Do stuff while mouse pointer is inside elem } elem.addEventListener(\"mousemove\", handleMouseMove); You might be running a game in your page. While the mouse is inside the canvas, you will want to constantly check for mouse movement and cursor position and update the game state — including the score, the time, the position of all the sprites, collision detection information, etc. Once the game is over, you will no longer need to do all that, and in fact, it will be a waste of processing power to keeping listening for that event. It is, therefore, a good idea to remove event listeners that are no longer needed. This can be done using : Another tip is to use event delegation wherever possible. When you have some code to run in response to a user interacting with any one of a large number of child elements, you can set an event listener on their parent. Events fired on any child element will bubble up to their parent, so you don't need to set the event listener on each child individually. Less event listeners to keep track of means better performance. See Event delegation for more details and a useful example.\n\nThere are several general best practices that will make your code run more efficiently.\n• Reduce DOM manipulation: Accessing and updating the DOM is computationally expensive, so you should minimize the amount that your JavaScript does, especially when performing constant DOM animation (see Handling JavaScript animations above).\n• Batch DOM changes: For essential DOM changes, you should batch them into groups that get done together, rather than just firing off each individual change as it occurs. This can reduce the amount of work the browser is doing in real terms, but also improve perceived performance. It can make the UI look smoother to get several updates out of the way in one go, rather than constantly making small updates. A useful tip here is — when you have a large chunk of HTML to add to the page, build the entire fragment first (typically inside a ) and then append it all to the DOM in one go, rather than appending each item separately.\n• Simplify your HTML: The simpler your DOM tree is, the faster it can be accessed and manipulated with JavaScript. Think carefully about what your UI needs, and remove unnecessary cruft.\n• Reduce the amount of looped code: Loops are expensive, so reduce the amount of loop usage in your code wherever possible. In cases where loops are unavoidable:\n• Avoid running the full loop when it is unnecessary, using or statements as appropriate. For example, if you are searching arrays for a specific name, you should break out of the loop once the name is found; there is no need to run further loop iterations: function processGroup(array) { const toFind = \"Bob\"; for (let i = 0; i < array.length - 1; i++) { if (array[i] === toFind) { processMatchingArray(array); break; } } }\n• Do work that is only needed once outside the loop. This may sound a bit obvious, but it is easy to overlook. Take the following snippet, which fetches a JSON object containing data to be processed in some way. In this case the operation is being done on every iteration of the loop, which is a waste of computing power. The fetching, which does not depend on , could be moved outside the loop, so it is only done once.\n• Run computation off the main thread: Earlier on we talked about how JavaScript generally runs tasks on the main thread, and how long operations can block the main thread, potentially leading to bad UI performance. We also showed how to break long tasks up into smaller tasks, mitigating this problem. Another way to handle such problems is to move tasks off the main thread altogether. There are a few ways to achieve this:\n• Use asynchronous code: Asynchronous JavaScript is basically JavaScript that does not block the main thread. Asynchronous APIs tend to handle operations such as fetching resources from the network, accessing a file on the local file system, or opening a stream to a user's web cam. Because those operations could take a long time, it would be bad to just block the main thread while we wait for them to complete. Instead, the browser executes those functions, keeps the main thread running subsequent code, and those functions will return results once they are available at some point in the future. Modern asynchronous APIs are -based, which is a JavaScript language feature designed for handling asynchronous operations. It is possible to write your own Promise-based functions if you have functionality that would benefit from being run asynchronously.\n• Run computation in web workers: Web Workers are a mechanism allowing you to open a separate thread to run a chunk of JavaScript in, so that it won't block the main thread. Workers do have some major restrictions, the biggest being that you can't do any DOM scripting inside a worker. You can do most other things, and workers can send and receive messages to and from the main thread. The main use case for workers is if you have a lot of computation to do, and you don't want it to block the main thread. Do that computation in a worker, wait for the result, and send it back to the main thread when it is ready.\n• Use WebGPU: WebGPU is a browser API that allows web developers to use the underlying system's GPU (Graphics Processing Unit) to carry out high-performance computations and draw complex images that can be rendered in the browser. It is fairly complex, but it can provide even better performance benefits than web workers."
    },
    {
        "link": "https://gist.github.com/jaredwilli/5469626",
        "document": "HTML5 canvas Performance and Optimization Tips, Tricks and Coding Best Practices With canvas being still very new to internet, and no signs of it ever getting old that I can see in the future, there are not too many documented best practices or other really important tips that are a must know for developing with it in any one particular place. Things like this are scattered around and many times on lesser known sites.\n\nThere's so many things that people need to know about, and still so much to learn about, so I wanted to share some things to help people who are learning canvas and maybe some who already know it quite well and am hoping to get some feedback from others about what they feel are some best practices or other tips and tricks for working with canvas in HTML5.\n\nI want to start off with one I personally found to be quite a useful yet surprisingly uncommon thing for developers to do. Indent your code Just as you would any other time, in any other language whatever the case may be. It has been a best practice for everything else, and I have come to find that in a complex canvas app, things can get a little confusing when dealing with several different contexts and saved/restore states. Not to mention the code is just more readable and overall cleaner looking too.\n\nThe if statement not easier and cleaner to read and know what is what immediately going on than the else statement in this, is it not? I think this should be a method that developers should continue to practice just as they would when writing plain 'ol javascript or any other language even.\n\nUse requestAnimationFrame instead of setInterval / setTimeout setInterval and setTimeout were never intended to be used as animation timers, they're just generic methods for calling functions after a time delay. If you set an interval for 20ms in the future, but your queue of functions takes longer than that to execute, your timer won't fire until after these functions have completed. That could be a while, which isn't ideal where animation is concerned. RequestAnimationFrame is a method which tells the browser that an animation is taking place, so it can optimize repaints accordingly. It also throttles the animation for inactive tabs, so it won't kill your mobile device's battery if you leave it open in the background.\n\nNicholas Zakas wrote a hugely detailed and informative article about requestAnimationFrame on his blog which is well worth reading. If you want some hard and fast implementation instructions, then Paul Irish has written a requestAnimationFrame shim which I've used in every one of the canvas apps I have made just about.\n\nUpdate: Even better than using requestAnimationFrame in place of setTimeout and setInterval, Joe Lambert has written a new and improved shim called requestInterval and requestTimeout, which he explains what issues exist when using requestAnimFrame. You can view the gist of the script here.\n\nUpdate #2: Now that all the browsers have caught up on the spec for this, there has been an update to the requestAnimFrame polyfill, one which will probably remain the one to use to cover all vendors.\n\nUse more than one canvas This is a technique for animation-heavy games which @nicolahibbert wrote about in a post of hers on optimizing canvas games. She explains how it may be better to use multiple canvases layered on top of one another rather than do everything in a single canvas.\n\n\"Drawing too many pixels to the same canvas at the same time will cause your frame rate to fall through the floor. Take Breakout for example. Trying to draw the bricks, the ball, the paddle, any power-ups or weapons, and then each star in the background – this simply won't work, it takes too long to execute each of these instructions in turn. By splitting the starfield and the rest of the game onto separate canvases, you are able to ensure a decent framerate.\" Nicola says.\n\nRender Elements Off-screen I have had to do this for a few canvas apps I've made including Samsung's Olympic Genome Project facebook app. It's an extremely useful thing to know and to make use of whether it's needed or not. It decreases load time immensely, plus it can be a really useful technique to load images off screen since they can sometimes take a while.\n\nNotice that the src of the image is set after it is loaded. This is a key thing to remember to do too. Once the images are done loading and drawn into these temp canvases, you can then draw them to your main canvas by using the same ctx.drawImage(), but instead of putting the image as the first argument, you use tmpCtx.canvas to reference the temporary canvas.\n\nOther Resources Canvas test cases Some more canvas and JS tests HTML5Rocks Performance Improving requestAnimFrame to Optimize Dragging Events\n\nCanvas Has a Back Reference The 2d Context has a back reference to it's associated DOM element that you can use for quick referencing of the context which is HTMLCanvasElemen.\n\nI would like to get more information on this and other shortcut references that may exist in canvas as well, but this is one that is pretty straightforward I think.\n\nRedraw Regions One of the best canvas optimization techniques for animations is to limit the amount of pixels that get cleared/painted on each frame. The easiest solution to implement is resetting the entire canvas element and drawing everything over again but that is an expensive operation for your browser to process.\n\nThe idea is to reuse as many pixels as possible between frames. What that means is the fewer pixels that need to be processed each frame, the faster your program will run. For example, when erasing pixels with the clearRect(x, y, w, h)method, it is very beneficial to clear and redraw only the pixels that have changed and not the full canvas.\n\nDrawing with Procedural Sprites Generating graphics procedurally is often the way to go, but sometimes that's not the most efficient one. If you're drawing simple shapes with solid fills, then drawing them procedurally is the best way do so. However, if you're drawing more detailed entities with strokes, gradient fills and other performance sensitive make-up you'd be better off using image sprites.\n\nIt is possible to get away with a mix of both. Draw graphical entities procedurally on the canvas once as your application starts up. After that you can reuse the same sprites by painting copies of them instead of generating the same drop-shadow, gradient and strokes repeatedly.\n\nState Stack & Transformation The canvas can be manipulated via transformations such as rotation and scaling, resulting in a change to the canvas coordinate system. This is where it's important to know about the state stack for which two methods are available:\n\ncontext.save() - pushes the current state to the stack context.restore() - reverts to the previous state\n\nThese enable you to apply transformation to a drawing and then restore back to the previous state to make sure the next shape is not affected by any earlier transformation. The states also include properties such as the fill and stroke colors.\n\nCompositing A very powerful tool at hand when working with canvas is compositing modes which, amongst other things, allow for masking and layering. There's a wide array of available composite modes and they are all set through the canvas context's globalCompositeOperation property. The composite modes are also part of the state stack properties, so you can apply a composite operation, stack the state and apply a different one, and restore back to the state before where you made the first one. So it can be especially useful for this reason.\n\nAnti-Aliasing To allow for sub-pixel drawings, all browser implementations of canvas employ anti-aliasing (although this does not seem to be a requirement in the HTML5 spec). Anti-aliasing can be important to keep in mind if you want to draw crisp lines and notice the result looks blurred. This occurs because the browser will interpolate the image as though it was actually between those pixels. It results in a much smoother animation (you can genuinely move at half a pixel per update) but it'll make your images appear fuzzy.\n\nTo work around this you will need to either round to whole integer values or offset by half a pixel depending on if you're drawing fills or strokes.\n\nUsing Whole Numbers for drawImage() x and y Positions If you call drawImage()on the canvas element, it's much faster if you round the x and y position to a whole number.\n\nHere's a test case on jsperf showing how much faster using whole numbers is compared to using decimals. So it is a good idea to round your x and y position to whole numbers before rendering.\n\nFaster than Math.round() Another jsperf test shows that Math.round()is not necessarily the fastest method for rounding numbers. Using a bitwise hack actually turns out to be faster than the built in method.\n\nClearing the canvas To clear the entire canvas of any existing pixels context.clearRect(x, y, w, h) is typically used – but there is another option available. Whenever the width and height of the canvas are set (even if they are set to the same value repeatedly) the canvas is reset. This is good to know when working with a dynamically sized canvas as you will notice drawings disappearing.\n\nComputation Distribution The Chrome Developer Tools profiler is very useful for finding out what your performance bottlenecks are. Depending on your application you may need to refactor some parts of your program to improve the performance and how browsers handle specific parts of your code.\n\nHere's some more tips and suggestions I put into a list worth sharing:\n\nDon't include jQuery unless you need to do more than just selecting the . I've managed to get by without it for almost everything I've made in canvas Create abstracted functions and decouple your code. Separating functionality from appearance or initial draw state as much as possible can be very helpful in the long run and is just good practice in general. Make common functions reusable as much as possible. Ideally, you should use a module pattern or some sort of abstracted API that breaks up code that you can reuse. I like to make a separate object that contains common functions and utilities. Use single and double letter variable names only when it makes sense (x, y, z). The coordinate system in canvas adds more single letters that are commonly declared as variables. Which can lead to creating multiple single/double variables (dX, dY, aX, aY, vX, vY) as part of an element. It’s better to be verbose and type out or at least abbreviate the variable names (dirX, accelX, velX) otherwise things could get pretty confusing for you later on. I’ve seen many people not doing this and it should be reiterated as a best practice. Make constructor functions for generating anything that you will need more than one of. These can be useful for anything, whether you want to make multiples of the same shape, or at a lower level make vectors which add actions or other things to the prototype.\n\nAn example of a constructor I made for creating circles:\n\nThen to create a ball you would do:\n\nA good base to work with is to create 3 functions init() - do all the initial work, and setup the base vars and event handlers etc. draw() - called once to begin the game and draws the first frame of the game, including the creation of elements that may be changing or need constructing. update() - called at the end of draw() and within itself via requestAnimFrame. Updates properties of changing elements, only do what you need to do here. Do the least amount of work within the loop updating and drawing only the changing pixels. Create the game elements and do any other UI work outside the animation loop. The animation loop is often a recursive function, which means it calls itself rapidly and repeatedly during the animation to draw each frame. If there are many elements being animated at once, you might want to first create the elements using a constructor function if you’re not already, and then within the constructor make a timer method that has requestAnimFrame/setTimeout sing it just how you would normally within any animation loop, but effects this element specifically only. Consider adding timer(), draw() and animate() methods on each of your constructors for things that need to animate and for varying amounts of time. Doing this gives you full separation of control for each element and one big animation loop will not be necessary at all since the loop is broken up into each element and you start/stop at will. Alternatively, create a Timer() constructor which you can use and give each animating element individually, thereby minimizing workload within animation loops.\n\nAfter having worked on a large Facebook app which a canvas data-visualization as the primary focus and incorporated each users Facebook profile information (a massive amount of data for some people) to match you (and friends of yours also using the app) to Olympic athletes (a 6 degrees of separation type of thing) there's quite a lot I have learned in my extensive efforts to do everything I could possibly try for increasing performance within the app.\n\nI literally spent months, and days at a time just working to refactor the code which I knew already so well, and believed it to be the most optimal way to do things. As it turned out in the end a valuable lesson I learned brings me to this last thing.\n\nUse DOM Elements Whenever Possible The fact is, browsers are still just not ready to handle more intensive running applications in canvas, especially if you're required to develop the app with support for Internet Explorer 8. There are sometimes cases where the DOM is faster than the current implementation of the canvas API at the time of writing this. At least I've found it to be while working on a massively complex single page animating html5 and canvas application for Samsung.\n\nWe were able to do quite well at improving the performance of things while still using canvas to do some complex work to crop images into circles, which would've probably been ok to stick with how we were doing it.\n\nDays before the launch, we decided to try a different technique, and rather than create temporary canvases off-screen which were placed on the visible canvas once cropped into circles etc., we just appended Image DOM elements on the canvas, using the x and y coordinates that we had been using for placing the temp canvases before.\n\nFor cropping the images into circles, well that was simple, we just used the CSS3 border-radius property to do it which was far less work than the complex series of state changes and while ingenious and creative yet over-use of the clip() method.\n\nOnce they are placed in the DOM, the animation of images the occurs, and the DOM nodes for each image are animated as separate entities of the canvas. Ones that we can have full control over the styling off easily through CSS.\n\nThis technique is similar to another method for doing this type of work that is quite good to know as well, which involves layering canvases on top of each other, rather than draw them to one context."
    },
    {
        "link": "https://stackoverflow.com/questions/29004245/optimizing-javascript-performance-with-many-event-listeners",
        "document": "You might look into javaScript event delegation. There are many answers on SO (an example here) and many good articles ( here or here ).\n\nBasically the idea you had is actually a good solution. So, instead of binding - let's say - one hundred rows with their own event handlers, you bind only their common parent which will fire an event when any of its child will receive a mouse input.\n\nRoughly speaking instead of this:\n\nYou will do this:\n\nThis is obviously a very simplified example, but it should be enough to build a good pattern upon.\n\nAs a side note, it's a very interesting thing (well, at least for me...) to inspect the event that is fired doing something like:\n\nAnd see how much information an event carries, and how much useful information you get out of the box with a simple click or mouse enter.\n\nOf course the same result can be achieved without any library.\n\nA simple implementation using Vanilla JS can be taken from David Walsh's article linked at the beginning of the answer, it goes roughly like this:\n\nIf you try this code though chances are that the actual is the , and not the we want. This means we have to be a bit more clever and walk the DOM upwards to see if the clicked element ( ) is contained in the one we really want ( ).\n\nA rough implementation to get you started would look like this:\n\nSee this fiddle or the snippet below:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Optimizing_canvas",
        "document": "The element is one of the most widely used tools for rendering 2D graphics on the web. However, when websites and apps push the Canvas API to its limits, performance begins to suffer. This article provides suggestions for optimizing your use of the canvas element to ensure that your graphics perform well.\n\nPre-render similar primitives or repeating objects on an offscreen canvas If you find yourself repeating some of the same drawing operations on each animation frame, consider offloading them to an offscreen canvas. You can then render the offscreen image to your primary canvas as often as needed, without unnecessarily repeating the steps needed to generate it in the first place.\n\nAvoid floating-point coordinates and use integers instead Sub-pixel rendering occurs when you render objects on a canvas without whole values. This forces the browser to do extra calculations to create the anti-aliasing effect. To avoid this, make sure to round all co-ordinates used in calls to using , for example.\n\nIn your application, you may find that some objects need to move or change frequently, while others remain relatively static. A possible optimization in this situation is to layer your items using multiple elements. For example, let's say you have a game with a UI on top, the gameplay action in the middle, and a static background on the bottom. In this case, you could split your game into three layers. The UI would change only upon user input, the gameplay layer would change with every new frame, and the background would remain generally unchanged.\n\nIf you have a static background image, you can draw it onto a plain element using the CSS property and position it under the canvas. This will negate the need to render the background to the canvas on every tick.\n\nCSS transforms are faster since they use the GPU. The best case is to not scale the canvas, or have a smaller canvas and scale up rather than a bigger canvas and scale down.\n\nYou may find that canvas items appear blurry on higher-resolution displays. While many solutions may exist, a simple first step is to scale the canvas size up and down simultaneously, using its attributes, styling, and its context's scale. // Get the DPR and size of the canvas const dpr = window.devicePixelRatio; const rect = canvas.getBoundingClientRect(); // Set the \"actual\" size of the canvas canvas.width = rect.width * dpr; canvas.height = rect.height * dpr; // Scale the context to ensure correct drawing operations ctx.scale(dpr, dpr); // Set the \"drawn\" size of the canvas canvas.style.width = `${rect.width}px`; canvas.style.height = `${rect.height}px`;"
    }
]