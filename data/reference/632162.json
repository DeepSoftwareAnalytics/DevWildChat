[
    {
        "link": "https://stackoverflow.com/questions/16683962/moving-every-element-down-one-in-an-array-java",
        "document": "The above should do what you want.\n\nHowever, I don't think this is the right way to go.\n\nI would use the same array as a circular array - that way - you don't need to move down everytime.\n\nIt remains at till the time all 20 elements are filled up. When the next element comes in,\n\nWhen you want to iterate through the array at any time, you begin at instead of beginning at ."
    },
    {
        "link": "https://stackoverflow.com/questions/13766209/efficient-swapping-of-elements-of-an-array-in-java",
        "document": "I am wondering if there is a more efficient way of swapping two elements in an Array, than doing something like this:\n\nWell, this is obviously not bad or even wrong, but I need to swap very often so I am interested if there are any Libs or something that provide a more efficient way to do this?"
    },
    {
        "link": "https://medium.com/@anil.goyal0057/mastering-basic-array-operations-in-java-a-guide-to-easy-level-problems-fc74e8fbad14",
        "document": "“Arrays are one of the fundamental data structures in Java, and understanding how to work with them is a key skill for any Java developer. They are used in a wide variety of applications, from storing data for processing to forming the basis for other data structures like heaps and hash tables. In this blog post, we will explore some easy-level problems related to arrays. These problems are designed to help you understand the basic operations that can be performed on arrays, such as accessing elements, iterating over the array, and modifying elements. We will also discuss some common algorithms and techniques used in array manipulation, such as sorting and searching. By the end of this post, you should have a solid understanding of how to work with arrays in Java and be able to solve basic array-related problems. So, whether you’re a beginner just starting out with Java, or an experienced developer looking to brush up on your array manipulation skills, this guide is for you. Let’s get started!”\n\nProblem: Finding the largest and second largest elements in an array.\n\nProblem: Finding the smallest and second smallest elements in an array.\n\nProblem: Check if an Array is sorted in Ascending Order\n\nProblem: Left rotate an Array by k places using temp array\n\nProblem: Right rotate an Array by k places using temp array\n\nProblem: Right rotate an Array by k places\n\nProblem: Moving All Zeros to end of an Array using Shifting indexes\n\nProblem: Moving All Zeros to end of an Array using two pointers\n\nProblem: Linear Search on an Array to find the index of the first occurrence of a given Number.\n\nProblem: Finding the missing number in an array that should contain numbers from 1 to n.\n\nProblem: Finding the missing number in an array that should contain numbers from 1 to n using XOR operation.\n\nProblem: Finding the number that appears once in an array where all other numbers appear twice.\n\nProblem: Counting the maximum number of consecutive ones in an array.\n\nProblem: Find the union of two sorted Arrays\n\nProblem: Find the intersection of two Sorted Arrays\n\nProblem : Finding the length of the longest subarray with a given sum k using two different approaches: a brute force approach and a two-pointer approach.\n\nProblem: Finding the length of the longest subarray with a given sum k in an array that may include negative numbers.\n\nFor medium level problem, pls see my article"
    },
    {
        "link": "https://reddit.com/r/javahelp/comments/qoituu/how_can_i_shift_the_elements_of_an_array_to_the",
        "document": "Im trying to add a string into an index of an existing array with inputted values and shift the old values to the right 1 place. for example an array I have created has 5 spaces in total and hold string values is [A, B, C] when I add Z to index 0 the output is [Z, A, A, A] instead of [Z, A, B, C]. I am confused on why it copies the A from index 0 to the other indices of the filled array. Here is the code for my function. curIndex is a integer instance variable that holds the current index of the array."
    },
    {
        "link": "https://bito.ai/resources/java-array-shift-java-explained",
        "document": "Java is one of the most widely used programming languages, and its use goes far beyond the development of web applications. In this article, we’ll take a closer look at one of Java’s features—array shifting—and how it can make your code faster and more efficient. We’ll cover what an array shift is, how to work with Java arrays, and common pitfalls to avoid.\n\nWhat is an Array Shift?\n\nAn array shift is a specialized programming technique that enables developers to move a value from one spot in an array to another without copying each value individually. In Java programming, this technique involves using two loops—the first loop runs through the array from the first position to the last, while the second loop moves from the last position to the position of the shifted value. The end result is that the value in question is shifted forward in the array.\n\nThis technique is useful for a variety of programming tasks, such as sorting an array, inserting a new value into an array, or deleting a value from an array. It is also a relatively efficient way to move values around in an array, as it requires fewer operations than copying each value individually. Additionally, array shifts can be used to create a new array with the same values as the original array, but in a different order.\n\nIn order to fully understand what an array shift is and how it works, it’s important to have a basic understanding of the language itself. Java is an object-oriented programming language, meaning it relies heavily on classes, objects, methods, and variables. It’s also platform-independent, meaning the same code will run on any computer regardless of operating system.\n\nThe structure of a Java program consists of execution statements and code blocks that are begun and ended using curly brackets. The code within can be as simple or as complex as needed for the task at hand. Variables are used to store information, and arrays can be used to store data that is related in some way.\n\nArray shifts are a type of operation that can be performed on an array. This operation shifts the elements of the array to the left or right, depending on the direction specified. This can be useful for sorting data or rearranging elements in an array. It’s important to note that when an array shift is performed, the last element of the array is lost and the first element is moved to the end.\n\nArrays are data structures used to store data in memory. Each array has a fixed number of elements, and each element has a specific data type. Arrays can be single-dimensional or multi-dimensional. In Java programming, arrays can be shifted with the help of a bit of code.\n\nTo shift an element in an array, you must first create an array object and specify the type of data it will contain. Then, you’ll need to loop through the elements in the array and replace each element with the one that follows it. The last element in the array will then be replaced by the shifted value.\n\nOnce you understand how to work with arrays in Java, you can begin to implement array shifts into your code. Here’s a sample of how you would do this:\n\nIn this example, we’ve used a for loop to execute the shift operation. In this case, we’ve shifted the first element in the array to the last, and added a new value of 0 to the end. Running this code would yield the following result:\n\nNow that we’ve seen how to shift elements in an array using Java, let’s take a look at some of the benefits of using this technique:\n• Faster Processing: Shifting elements in an array can speed up processing time by eliminating the need for extra copies. This can save memory and help your program run more efficiently.\n• Reusability: By shifting elements in an array instead of copying them, you can reuse parts of your code more easily.\n• Easy Maintenance: By using array shift techniques, you can make it easier to maintain your code over the long term.\n\nWhile array shifting can be a powerful tool for efficient programming, there are some pitfalls to avoid. It’s important to make sure you are following best practices and not introducing any unintended side effects into your code.\n• Data Loss: Shifting elements in an array can lead to data loss if you don’t take proper precautions. Be sure to check that each value is correctly transferred before performing a shift operation.\n• Overwriting: It’s also possible to overwrite existing values if you’re not careful when shifting elements in an array. Make sure that each element is moved to its correct position before proceeding.\n\nIf you’re having trouble understanding how to shift elements in an array using Java, here are a few troubleshooting tips:\n• Check the Syntax: Make sure you are using the correct syntax for shifting elements in Java.\n• Test Your Code: Test your code with different values and situations to make sure it’s running correctly.\n• Keep it Simple: If you’re just starting out with programming, keep your code as simple as possible until you gain more experience.\n\nNow that you have a better understanding of how array shifting works in Java, you can use it to make your code more efficient and maintainable. Keep in mind the potential pitfalls of shifting elements in an array, but don’t let them stop you from taking advantage of this powerful technique."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html",
        "document": "\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. All elements in the array must implement the interface. Furthermore, all elements in the array must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - if the array contains elements that are not mutually comparable (for example, strings and integers) - (optional) if the natural ordering of the array elements is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in this range must implement the mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified range of the specified array of objects into ascending order, according to the natural ordering of its elements. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in this range must implement the interface. Furthermore, all elements in this range must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable by the specified comparator (that is, must not throw a for any elements and in the array). Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must beby the specified comparator (that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator - (optional) if the comparator is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, must not throw a for any elements and in the range). Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in the range must beby the specified comparator (that is,must not throw afor any elementsandin the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. All elements in the array must implement the interface. Furthermore, all elements in the array must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the array to be sorted - if the array contains elements that are not mutually comparable (for example, strings and integers) - (optional) if the natural ordering of the array elements is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in this range must implement the mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified range of the specified array of objects into ascending order, according to the natural ordering of its elements. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in this range must implement the interface. Furthermore, all elements in this range must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable by the specified comparator (that is, must not throw a for any elements and in the array). Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must beby the specified comparator (that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the class of the objects to be sorted - the array to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator - (optional) if the comparator is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, must not throw a for any elements and in the range). Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in the range must beby the specified comparator (that is,must not throw afor any elementsandin the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator. - if or (optional) if the comparator is found to violate the contract\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the class of the objects in the array - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the class of the objects in the array - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holdsand the operation performs addition, then upon return the array holds. Parallel prefix computation is usually more efficient than sequential loops for large arrays. Because floating-point operations may not be strictly associative, the returned result may not be identical to the value that would be obtained if the operation was performed sequentially. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of longs for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of ints for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of shorts for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of chars for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of bytes for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of doubles for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of floats for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the natural ordering of its elements (as by the method) prior to making this call. If it is not sorted, the results are undefined. (If the array contains elements that are not mutually comparable (for example, strings and integers), itbe sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the search key is not comparable to the elements of the array.\n• cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the natural ordering of its elements (as by the method) prior to making this call. If it is not sorted, the results are undefined. (If the range contains elements that are not mutually comparable (for example, strings and integers), itbe sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the search key is not comparable to the elements of the array within the specified range.\n• Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the specified comparator (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the class of the objects in the array - the array to be searched - the value to be searched for - the comparator by which the array is ordered. A value indicates that the elements' natural ordering should be used. index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the array contains elements that are not mutually comparable using the specified comparator, or the search key is not comparable to the elements of the array using this comparator.\n• Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the specified comparator (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the class of the objects in the array - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for - the comparator by which the array is ordered. A value indicates that the elements' natural ordering should be used. index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the range contains elements that are not mutually comparable using the specified comparator, or the search key is not comparable to the elements in the range using this comparator.\n• if the two specified arrays of longs are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of longs areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of ints are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of ints areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of shorts are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of shorts areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of chars are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of chars areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of bytes are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of bytes areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of booleans are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of booleans areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of doubles are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of doubles areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are Two doubles and are considered equal if: (Unlike the operator, this method considers equals to itself, and 0.0d unequal to -0.0d.) - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of floats are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of floats areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are Two floats and are considered equal if: (Unlike the operator, this method considers equals to itself, and 0.0f unequal to -0.0f.) - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of Objects are equal to one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objects and are considered equal if . In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of Objects areto one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objectsandare consideredif. In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• Assigns the specified long value to each element of the specified array of longs. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified long value to each element of the specified range of the specified array of longs. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified int value to each element of the specified array of ints. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified int value to each element of the specified range of the specified array of ints. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified short value to each element of the specified array of shorts. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified short value to each element of the specified range of the specified array of shorts. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified char value to each element of the specified array of chars. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified char value to each element of the specified range of the specified array of chars. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified byte value to each element of the specified array of bytes. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified byte value to each element of the specified range of the specified array of bytes. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified boolean value to each element of the specified array of booleans. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified boolean value to each element of the specified range of the specified array of booleans. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified double value to each element of the specified array of doubles. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified double value to each element of the specified range of the specified array of doubles. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified float value to each element of the specified array of floats. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified float value to each element of the specified range of the specified array of floats. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified Object reference to each element of the specified array of Objects. - the array to be filled - the value to be stored in all elements of the array - if the specified value is not of a runtime type that can be stored in the specified array\n• Assigns the specified Object reference to each element of the specified range of the specified array of Objects. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array - if the specified value is not of a runtime type that can be stored in the specified array\n• Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of exactly the same class as the original array. - the class of the objects in the array - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with nulls to obtain the specified length\n• Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of the class . - the class of the objects in the original array - the class of the objects in the returned array - the array to be copied - the length of the copy to be returned - the class of the copy to be returned a copy of the original array, truncated or padded with nulls to obtain the specified length - if an element copied from is not of a runtime type that can be stored in an array of class\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with null characters (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with null characters to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with false elements to obtain the specified length\n• ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . Copies the specified range of the specified array into a new array. The initial index of the range () must lie between zero and, inclusive. The value atis placed into the initial element of the copy (unlessor). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (), which must be greater than or equal to, may be greater than, in which caseis placed in all elements of the copy whose index is greater than or equal to. The length of the returned array will be The resulting array is of exactly the same class as the original array. - the class of the objects in the array - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with nulls to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . The resulting array is of the class . - the class of the objects in the original array - the class of the objects in the returned array - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) - the class of the copy to be returned a new array containing the specified range from the original array, truncated or padded with nulls to obtain the required length - if an element copied from is not of a runtime type that can be stored in an array of class .\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with null characters to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with false elements to obtain the required length\n• Returns a fixed-size list backed by the specified array. (Changes to the returned list \"write through\" to the array.) This method acts as bridge between array-based and collection-based APIs, in combination with . The returned list is serializable and implements This method also provides a convenient way to create a fixed-size list initialized to contain several elements: - the class of the objects in the array - the array by which the list will be backed a list view of the specified array\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any two non-nullarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• Returns a hash code based on the contents of the specified array. If the array contains other arrays as elements, the hash code is based on their identities rather than their contents. It is therefore acceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. For any two arrays and such that , it is also the case that . The value returned by this method is equal to the value that would be returned by , unless is , in which case is returned. - the array whose content-based hash code to compute\n• Returns a hash code based on the \"deep contents\" of the specified array. If the array contains other arrays as elements, the hash code is based on their contents and so on, ad infinitum. It is therefore unacceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. The behavior of such an invocation is undefined. For any two arrays and such that , it is also the case that . The computation of the value returned by this method is similar to that of the value returned by on a list containing the same elements as in the same order, with one difference: If an element of is itself an array, its hash code is computed not by calling , but as by calling the appropriate overloading of if is an array of a primitive type, or as by calling recursively if is an array of a reference type. If is , this method returns 0. - the array whose deep-content-based hash code to compute\n• if the two specified arrays are deeply equal to one another. Unlike the Returnsif the two specified arrays areto one another. Unlike the method, this method is appropriate for use with nested arrays of arbitrary depth. Two array references are considered deeply equal if both are , or if they refer to arrays that contain the same number of elements and all corresponding pairs of elements in the two arrays are deeply equal. Two possibly elements and are deeply equal if any of the following conditions hold:\n• and are both arrays of object reference types, and\n• and are arrays of the same primitive type, and the appropriate overloading of would return true. Note that this definition permits elements at any depth. Note that this definition permitselements at any depth. If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined. - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• , which describes their identities rather than their contents. Returns a string representation of the contents of the specified array. If the array contains other arrays as elements, they are converted to strings by the method inherited from, which describes theirrather than their contents. The value returned by this method is equal to the value that would be returned by , unless is , in which case is returned. - the array whose string representation to return\n• Returns a string representation of the \"deep contents\" of the specified array. If the array contains other arrays as elements, the string representation contains their contents and so on. This method is designed for converting multidimensional arrays to strings. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by , unless they are themselves arrays. If an element is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of . If an element is an array of a reference type, it is converted to a string as by invoking this method recursively. To avoid infinite recursion, if the specified array contains itself as an element, or contains an indirect reference to itself through one or more levels of arrays, the self-reference is converted to the string . For example, an array containing only a reference to itself would be rendered as . This method returns if the specified array is . - the array whose string representation to return\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - type of elements of the array - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - type of elements of the array - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use the spliterator for the array elements\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - The type of the array elements - The array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the type of the array elements - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use an for the array\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover an for the array range - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size"
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api?java/util/Arrays.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://geeksforgeeks.org/array-class-in-java",
        "document": "The Arrays class in java.util package is a part of the Java Collection Framework. This class provides static methods to dynamically create and access Java arrays. It consists of only static methods and the methods of Object class. The methods of this class can be used by the class name itself.\n\nThe class hierarchy is as follows:\n\nGeek, now you must be wondering why do we need java Arrays class when we are able to declare, initialize and compute operations over arrays. The answer to this though lies within the methods of this class which we are going to discuss further as practically these functions help programmers expanding horizons with arrays for instance there are often times when loops are used to do some tasks on an array like:\n• None Fill an array with a particular value.\n• None And many more.\n\nSyntax: In order to use Arrays\n\nThe Arrays class of the java.util package contains several static methods that can be used to fill, sort, search, etc in arrays. Now let us discuss the methods of this class which are shown below in a tabular format as follows:\n\nReturns a fixed-size list backed by the specified Arrays Searches for the specified element in the array with the help of the Binary Search Algorithm Searches a range of the specified array for the specified object using the Binary Search Algorithm Copies the specified array, truncating or padding with the default value (if necessary) so the copy has the specified length. Copies the specified range of the specified array into a new Arrays. Returns true if the two specified arrays are deeply equal to one another. Returns a hash code based on the “deep contents” of the specified Arrays. Returns a string representation of the “deep contents” of the specified Arrays. Checks if both the arrays are equal or not. Assigns this fill value to each index of this arrays. Returns an integer hashCode of this array instance. Finds and returns the index of the first unmatched element between the two specified arrays. Performs parallelPrefix for the given range of the array with the specified functional operator. Performs parallelPrefix for complete array with the specified functional operator. Sets all the elements of this array in parallel, using the provided generator function. Sorts the specified array using parallel sort. Sets all the elements of the specified array using the generator function provided. Sorts the specified range of array in ascending order. Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. Sorts the specified array of objects according to the order induced by the specified comparator. Returns a Spliterator covering all of the specified Arrays. Returns a Spliterator of the type of the array covering the specified range of the specified arrays. Returns a sequential stream with the specified array as its source. It returns a string representation of the contents of this array. The string representation consists of a list of the array’s elements, enclosed in square brackets (“[]”). Adjacent elements are separated by the characters a comma followed by a space. Elements are converted to strings as by String.valueOf() function.\n\nThis methods search for the specified element in the array with the help of the binary search algorithm.\n\nThis method searches a range of the specified array for the specified object using the binary search algorithm."
    },
    {
        "link": "https://stackoverflow.com/questions/24390463/java-8-stream-and-operation-on-arrays",
        "document": "There are new methods added to to convert an array into a Java 8 stream which can then be used for summing etc.\n\nMultiplying two arrays is a little more difficult because I can't think of a way to get the value AND the index at the same time as a Stream operation. This means you probably have to stream over the indexes of the array.\n\nCommenter @Holger points out you can use the method instead of like this:"
    },
    {
        "link": "https://geeksforgeeks.org/arrays-in-java",
        "document": "Arrays are fundamental structures in Java that allow us to store multiple values of the same type in a single variable. They are useful for storing and managing collections of data. Arrays in Java are objects, which makes them work differently from arrays in C/C++ in terms of memory management.\n\nFor primitive arrays, elements are stored in a contiguous memory location. For non-primitive arrays, references are stored at contiguous locations, but the actual objects may be at different locations in memory.\n\nThere are some basic operations we can start with as mentioned below:\n\nTo declare an array in Java, use the following syntax:\n• type : The data type of the array elements (e.g.,\n• arrayName : The name of the array.\n\nNote: The array is not yet initialized.\n\nTo create an array, you need to allocate memory for it using the keyword:\n\nThis statement initializes the array to hold 5 integers. The default value for each element is .\n\n3. Access an Element of an Array\n\nWe can access array elements using their index, which starts from :\n\nThe first line sets the value of the first element to . The second line retrieves the value of the first element.\n\nTo change an element, assign a new value to a specific index:\n\nWe can get the length of an array using the property:\n\nNow, we have completed with basic operations so let us go through the in-depth concepts of Java Arrays, through the diagrams, examples, and explanations.\n\nFollowing are some important points about Java arrays.\n• None In Java, all arrays are dynamically allocated\n• None Arrays may be stored in contiguous memory\n• None Since arrays are objects in Java, we can find their length using the object property length . This is different from C/C++, where we find length using size of.\n• None A Java array variable can also be declared like other variables with [] after the data type.\n• None The variables in the array are ordered, and each has an index beginning with 0.\n• None Java array can also be used as a static field, a local variable, or a method parameter.\n\nAn array can contain primitives (int, char, etc.) and object (or non-primitive) references of a class, depending on the definition of the array. In the case of primitive data types, the actual values might be stored in contiguous memory locations (JVM does not guarantee this behavior). In the case of class objects, the actual objects are stored in a heap segment.\n\nFor understanding the array we need to understand how it actually works. To understand this follow the flow mentioned below:\n\nThe general form of array declaration is\n\nThe element type determines the data type of each element that comprises the array. Like an array of integers, we can also create an array of other primitive data types like char, float, double, etc., or user-defined data types (objects of a class).\n\nNote: It is just how we can create is an array variable, no actual array exists. It merely tells the compiler that this variable (int Array) will hold an array of the integer type.\n\nNow, Let us provide memory storage to this created array.\n\nWhen an array is declared, only a reference of an array is created. The general form of new as it applies to one-dimensional arrays appears as follows:\n\nHere, type specifies the type of data being allocated, size determines the number of elements in the array, and var-name is the name of the array variable that is linked to the array. To use new to allocate an array, you must specify the type and number of elements to allocate.\n\nNote: The elements in the array allocated by new will automatically be initialized to zero (for numeric types), false (for boolean), or null (for reference types). Do refer to default array values in Java.\n\nObtaining an array is a two-step process. First, you must declare a variable of the desired array type. Second, you must allocate the memory to hold the array, using new, and assign it to the array variable. Thus, in Java, all arrays are dynamically allocated.\n\nIn a situation where the size of the array and variables of the array are already known, array literals can be used.\n• None The length of this array determines the length of the created array.\n• None There is no need to write the new int[] part in the latest versions of Java.\n\nNow , we have created an Array with or without the values stored in it. Access becomes an important part to operate over the values mentioned within the array indexes using the points mentioned below:\n• None Each element in the array is accessed via its index.\n• None The index begins with 0 and ends at (total array size)-1.\n• None All the elements of array can be accessed using Java for Loop.\n\nLet us check the syntax of basic for loop to traverse an array:\n\nThese are the most common type of arrays, where elements are stored in a linear order.\n\nArrays with more than one dimension, such as two-dimensional arrays (matrices).\n\nYou can also access java arrays using for each loops.\n\nAn array of objects is created like an array of primitive-type data items in the following way.\n\nExample of Arrays of Objects\n\nExample 1: Here we are taking a student class and creating an array of Student with five Student objects stored in the array. The Student objects have to be instantiated using the constructor of the Student class, and their references should be assigned to the array elements.\n\n\n\nExample 2: An array of objects is also created like\n\nWhat happens if we try to access elements outside the array size?\n\nJVM throws ArrayIndexOutOfBoundsException to indicate that the array has been accessed with an illegal index. The index is either negative or greater than or equal to the size of an array.\n\nBelow code shows what happens if we try to access elements outside the array size:\n\nMultidimensional arrays are arrays of arrays with each element of the array holding the reference of other arrays. These are also known as Jagged Arrays. A multidimensional array is created by appending one set of square brackets ([]) per dimension.\n\nThere are 2 methods to declare Java Multidimensional Arrays as mentioned below:\n\nExample 1: Let us start with basic two dimensional Array declared and initialized.\n\nExample 2: Now, after declaring and initializing the array we will check how to Traverse the Multidimensional Array using for loop.\n\nLike variables, we can also pass arrays to methods. For example, the below program passes the array to method sum to calculate the sum of the array’s values.\n\nAs usual, a method can also return an array. For example, the below program returns an array from method m1.\n\nNow, as you know that arrays are objects of a class, and a direct superclass of arrays is a class Object.\n\nThe members of an array type are all of the following:\n• length contains the number of components of the array. Length may be positive or zero.\n• None All the members are inherited from class Object; the only method of Object that is not inherited is its\n• clone() overrides the clone method in class Object and throws no\n\nWhen you clone a single-dimensional array, such as , a shallow copy is performed. This means that the new array contains references to the original array’s elements rather than copies of the objects themselves. A deep copy occurs only with arrays containing primitive data types, where the actual values are copied.\n\nBelow is the implementation of the above method:\n\nA clone of a multi-dimensional array (like Object[][]) is a “shallow copy,” however, which is to say that it creates only a single new array with each element array a reference to an original element array, but subarrays are shared.\n\nBelow is the implementation of the above method:\n• Efficient Access : Accessing an element by its index is fast and has constant time complexity, O(1).\n• Memory Management : Arrays have fixed size, which makes memory management straightforward and predictable.\n• Data Organization : Arrays help organize data in a structured manner, making it easier to manage related elements.\n• Fixed Size : Once an array is created, its size cannot be changed, which can lead to memory waste if the size is overestimated or insufficient storage if underestimated.\n• Type Homogeneity : Arrays can only store elements of the same data type, which may require additional handling for mixed types of data.\n• Insertion and Deletion : Inserting or deleting elements, especially in the middle of an array, can be costly as it may require shifting elements.\n\nHow can we initialize an array in Java?\n\nCan we use an array of primitive types in Java?\n\nHow are multidimensional arrays represented in Java?\n\nCan we change the size of an array after it is created in Java?\n\nCan we specify the size of an array as\n\nWhat is the direct superclass of an array in Java?\n\nWhich interfaces are implemented by arrays in Java?"
    }
]