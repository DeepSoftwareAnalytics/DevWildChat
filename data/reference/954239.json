[
    {
        "link": "https://reaper.fm/sdk/reascript/reascripthelp.html",
        "document": "ReaScript/Python requires a recent version of Python installed on this machine. Python is available from multiple sources as a \n\n\n\n ReaScript/Python scripts can call API functions using .\n\n\n\n All parameters are passed by value, not reference. API functions that cannot return information in the parameter list will return a single value. API functions that can return any information in the parameter list will return a list of values; The first value in the list will be the function return value (unless the function is declared to return void).\n\n\n\n Examples:\n\n # function returning a single (scalar) value:\n\n sec = RPR_parse_timestr(\"1:12\")\n\n\n\n # function returning information in the first parameter (function returns void):\n\n (str) = RPR_GetProjectPath(\"\", 512)\n\n\n\n # lower volume of track 3 by half (RPR_GetTrackUIVolPan returns Bool):\n\n tr = RPR_GetTrack(0, 2)\n\n (ok, tr, vol, pan) = RPR_GetTrackUIVolPan(tr, 0, 0)\n\n # this also works, if you only care about one of the returned values:\n\n vol = RPR_GetTrackUIVolPan(tr, 0, 0)[2]\n\n RPR_SetMediaTrackInfo_Value(tr, \"D_VOL\", vol*0.5)\n\n \n\n You can create and save modules of useful functions that you can import into other ReaScripts. For example, if you create a file called reascript_utility.py that contains the function helpful_function(), you can import that file into any Python ReaScript with the line: and call the function by using: \n\n Note that ReaScripts must explicitly import the REAPER python module, even if the script is imported into another ReaScript: \n\n In addition to the \n\n\n\n ReaScript/Python requires a recent version of Python installed on this machine. Python is available from multiple sources as a free download . Python 2.7 is normally included with macOS, and the dynamic library is usually in /usr/lib. If you update to a newer version of Python, it will be installed to a different directory. After installing Python, REAPER may detect the Python dynamic library automatically. If not, you can enter the path in the ReaScript preferences page, at Options/Preferences/Plug-Ins/ReaScript.ReaScript/Python scripts can call API functions usingAll parameters are passed by value, not reference. API functions that cannot return information in the parameter list will return a single value. API functions that can return any information in the parameter list will return a list of values; The first value in the list will be the function return value (unless the function is declared to return void).Examples:You can create and save modules of useful functions that you can import into other ReaScripts. For example, if you create a file called reascript_utility.py that contains the function helpful_function(), you can import that file into any Python ReaScript with the line:and call the function by using:Note that ReaScripts must explicitly import the REAPER python module, even if the script is imported into another ReaScript:In addition to the standard API functions , Reascript/Python also has these built-in functions available:\n\nstring out = reaper.image_resolve_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.relative_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.resolve_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.resolve_fn2(string in, string out, optional string checkSubDir)\n• col_main_textshadow : Main window text shadow (ignored if too close to text color)\n• col_nodarkmodemiscwnd : Do not use window theming on macOS dark mode\n• track_lanesolo_tabcol : Track fixed lane button when only this lane plays\n\n\n\n\n\n \n\n \n\n EEL2: \n\n\n\nReturns the absolute value of the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc cosine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc sine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc tangent of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc tangent of the numerator divided by the denominator, allowing the denominator to be 0, and using their signs to produce a more meaningful result.\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the value rounded to the next highest integer (ceil(3.1)==4, ceil(-3.9)==-3).\n\n\n\n \n\n EEL2: \n\n\n\nMultiplies each of size complex pairs in dest by the complex pairs in src. Often used for convolution.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the cosine of the angle specified (specified in radians).\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n EEL2: \n\n\n\nExecutes code passed in. Code can use functions, but functions created in code can't be used elsewhere.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the number e ($e, approximately 2.718) raised to the parameter-th power. This function is significantly faster than pow() or the ^ operator.\n\n\n\n \n\n EEL2: \n\n\n\nUsed to call functions exported by extension plugins. The first parameter must be the exported function name, then its own parameters (as if the function was called directly).\n\n\n\n \n\n EEL2: \n\n\n\nCloses a file previously opened with fopen().\n\n\n\n \n\n EEL2: \n\n\n\nReturns nonzero if the file fp is at the end of file.\n\n\n\n \n\n EEL2: \n\n\n\nIf file fp is open for writing, flushes out any buffered data to disk.\n\n\n\n \n\n EEL2: \n\n\n\nPerforms a FFT on the data in the local memory buffer at the offset specified by the first parameter. The size of the FFT is specified by the second parameter, which must be 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, or 32768. The outputs are permuted, so if you plan to use them in-order, call fft_permute(buffer, size) before and fft_ipermute(buffer,size) after your in-order use. Your inputs or outputs will need to be scaled down by 1/size, if used.\n\nNote that fft()/ifft() require real / imaginary input pairs, so a 256 point FFT actually works with 512 items.\n\nNote that fft()/ifft() must NOT cross a 65,536 item boundary, so be sure to specify the offset accordingly.\n\n\n\n \n\n EEL2: \n\n\n\nPermute the input for ifft(), taking bands from in-order to the order ifft() requires. See \n\n\n\n \n\n EEL2: \n\n\n\nPermute the output of fft() to have bands in-order. See \n\n\n\n \n\n EEL2: \n\n\n\nPerforms an FFT, but takes size input samples and produces size/2 complex output pairs. Usually used along with fft_permute(size/2). Inputs/outputs will need to be scaled by 0.5/size.\n\n\n\n \n\n EEL2: \n\n\n\nReads a character from file fp, returns -1 if EOF.\n\n\n\n \n\n EEL2: \n\n\n\nReads a line from file fp into #str. Returns length of #str read.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the value rounded to the next lowest integer (floor(3.9)==3, floor(-3.1)==-4).\n\n\n\n \n\n EEL2: \n\n\n\nOpens a file \"fn\" with mode \"mode\". For read, use \"r\" or \"rb\", write \"w\" or \"wb\". Returns a positive integer on success.\n\n\n\n \n\n EEL2: \n\n\n\nFormats a string and writes it to file fp. For more information on format specifiers, see \n\n\n\n \n\n EEL2: \n\n\n\nReads from file fp into #str, up to length bytes. Returns actual length read, or negative if error.\n\n\n\n \n\n EEL2: \n\n\n\nHints the runtime that memory above the address specified may no longer be used. The runtime may, at its leisure, choose to lose the contents of memory above the address specified.\n\n\n\n \n\n EEL2: \n\n\n\nSeeks file fp, offset bytes from whence reference. Whence negative specifies start of file, positive whence specifies end of file, and zero whence specifies current file position.\n\n\n\n \n\n EEL2: \n\n\n\nRetunrs the current file position.\n\n\n\n \n\n EEL2: \n\n\n\nWrites up to len characters of #str to file fp. If len is less than 1, the full contents of #str will be written. Returns the number of bytes written to file.\n\n\n\n \n\n EEL2: \n\n\n\nQueries contextual information about the script, typically MIDI/OSC input values.\n\nReturns true if a new value has been updated.\n\nval will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).\n\nresolution=127 for 7-bit resolution, =16383 for 14-bit resolution.\n\nsectionID, and cmdID will be set to -1 if the script is not part of the action list.\n\nmode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.\n\ncontextstr may be empty or one of:\n• midi:XX[:YY] (one or two bytes hex)\n\n (flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)\n\n\n\n\n\n \n\n EEL2: \n\n\n\nThe following global variables are special and will be used by the graphics system:\n• gfx_a2 - current alpha component (0..1) used by drawing operations when writing solid colors (normally ignored but useful when creating transparent images).\n• gfx_mode - blend mode for drawing. Set mode to 0 for default options. Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx_a to negative and use gfx_mode as additive). Add 2.0 to disable source alpha for gfx_blit(). Add 4.0 to disable filtering for gfx_blit().\n• gfx_x - current graphics position X. Some drawing functions use as start position and update.\n• gfx_y - current graphics position Y. Some drawing functions use as start position and update.\n• gfx_clear - if greater than -1.0, framebuffer will be cleared to that color. the color for this one is packed RGB (0..255), i.e. red+green*256+blue*65536. The default is 0 (black).\n• gfx_dest - destination for drawing operations, -1 is main framebuffer, set to 0..1024-1 to have drawing operations go to an offscreen buffer (or loaded image).\n• gfx_texth - the (READ-ONLY) height of a line of text in the current font. Do not modify this variable.\n• gfx_ext_retina - to support hidpi/retina, callers should set to 1.0 on initialization, this value will be updated to value greater than 1.0 (such as 2.0) if retina/hidpi. On macOS gfx_w/gfx_h/etc will be doubled, but on other systems gfx_w/gfx_h will remain the same and gfx_ext_retina is a scaling hint for drawing.\n• mouse_x - current X coordinate of the mouse relative to the graphics window.\n• mouse_y - current Y coordinate of the mouse relative to the graphics window.\n• mouse_wheel - wheel position, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• mouse_hwheel - horizontal wheel positions, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• mouse_cap - a bitfield of mouse and keyboard modifier state. Note that a script must call gfx_getchar() at least once in order to get modifier state when the mouse is not captured by the window. Bitfield bits: \n\n\n\n \n\n EEL2: \n\n\n\nDraws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.\n\n\n\n \n\n EEL2: \n\n\n\nCopies from source (-1 = main framebuffer, or an image from gfx_loadimg() etc), using current opacity and copy mode (set with gfx_a, gfx_mode).\n\nIf destx/desty are not specified, gfx_x/gfx_y will be used as the destination position.\n\nscale (1.0 is unscaled) will be used only if destw/desth are not specified.\n\nrotation is an angle in radians\n\nsrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)\n\ndestx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale). \n\n\n\n \n\n EEL2: \n\n\n\nDeprecated, use gfx_blit instead.\n\n\n\n \n\n EEL2: \n\n\n\nBlurs the region of the screen between gfx_x,gfx_y and x,y, and updates gfx_x,gfx_y to x,y.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a circle, optionally filling/antialiasing. \n\n\n\n \n\n EEL2: \n\n\n\nConverts client coordinates x,y to screen coordinates.\n\n\n\n \n\n EEL2: \n\n\n\nBlits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.\n\n\n\n \n\n EEL2: \n\n\n\nCall with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh are specified, they will be filled with the undocked window position/size\n\n\n\n \n\n EEL2: \n\n\n\nDraws the character (can be a numeric ASCII code as well), to gfx_x, gfx_y, and moves gfx_x over by the size of the character.\n\n\n\n \n\n EEL2: \n\n\n\nDraws the number n with ndigits of precision to gfx_x, gfx_y, and updates gfx_x to the right side of the drawing. The text height is gfx_texth.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y so that subsequent draws will occur in a similar place.\n\n\n\nIf flags, right ,bottom passed in:\n• flags&256: ignore right/bottom, otherwise text is clipped to (gfx_x, gfx_y, right, bottom)\n\n\n\n \n\n EEL2: \n\n\n\nIf char is 0 or omitted, returns a character from the keyboard queue, or 0 if no character is available, or -1 if the graphics window is not open. If char is specified and nonzero, that character's status will be checked, and the function will return greater than 0 if it is pressed. Note that calling gfx_getchar() at least once causes mouse_cap to reflect keyboard modifiers even when the mouse is not captured.\n\n\n\nCommon values are standard ASCII, such as 'a', 'A', '=' and '1', but for many keys multi-byte values are used, including 'home', 'up', 'down', 'left', 'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'. \n\n\n\nModified and special keys can also be returned, including:\n• 65536 for query of special flags, returns: &1 (supported), &2=window has focus, &4=window is visible, &8=mouse click would hit window. 65537 queries special flags but does not do the mouse click hit testing (faster).\n• If unichar is specified, it will be set to the unicode value of the key if available (and the return value may be the unicode value or a raw key value as described above, depending). If unichar is not specified, unicode codepoints greater than 255 will be returned as 'u'<<24 + value\n\n \n\n\n\n \n\n EEL2: \n\n\n\nEnumerates any drag/dropped files. call gfx_dropfile(-1) to clear the list when finished. Returns 1 if idx is valid, 0 if idx is out of range.\n\n\n\n \n\n EEL2: \n\n\n\nReturns current font index. If a string is passed, it will receive the actual font face used by this font, if available.\n\n\n\n \n\n EEL2: \n\n\n\nRetreives the dimensions of image (representing a filename: index number) into w and h. Sets these values to 0 if an image failed loading (or if the filename index is invalid).\n\n\n\n \n\n EEL2: \n\n\n\nGets the value of the pixel at gfx_x,gfx_y into r,g,b. \n\n\n\n \n\n EEL2: \n\n\n\nFills a gradient rectangle with the color and alpha specified. drdx-dadx reflect the adjustment (per-pixel) applied for each pixel moved to the right, drdy-dady are the adjustment applied for each pixel moved toward the bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\n\n\n\n \n\n EEL2: \n\n\n\nInitializes the graphics window with title name. Suggested width and height can be specified. If window is already open, a non-empty name will re-title window, or an empty title will resize window. \n\n\n\nOnce the graphics window is open, gfx_update() should be called periodically. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a line from gfx_x,gfx_y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx_x and gfx_y to x,y.\n\n\n\n \n\n EEL2: \n\n\n\nLoad image from filename into slot 0..1024-1 specified by image. Returns the image index if success, otherwise -1 if failure. The image will be resized to the dimensions of the image file. \n\n\n\n \n\n EEL2: \n\n\n\nMeasures the drawing dimensions of a character with the current font (as set by gfx_setfont). \n\n\n\n \n\n EEL2: \n\n\n\nMeasures the drawing dimensions of a string with the current font (as set by gfx_setfont). \n\n\n\n \n\n EEL2: \n\n\n\nMultiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\n\n\n\n \n\n EEL2: \n\n\n\nFormats and draws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y accordingly (the latter only if the formatted string contains newline). For more information on format strings, see sprintf()\n\n\n\n \n\n EEL2: \n\n\n\nCloses the graphics window.\n\n\n\n \n\n EEL2: \n\n\n\nFills a rectangle at x,y, w,h pixels in dimension, filled by default. \n\n\n\n \n\n EEL2: \n\n\n\nFills a rectangle from gfx_x,gfx_y to x,y. Updates gfx_x,gfx_y to x,y. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a rectangle with rounded corners. \n\n\n\n \n\n EEL2: \n\n\n\nConverts screen coordinates x,y to client coordinates.\n\n\n\n \n\n EEL2: \n\n\n\nSets gfx_r/gfx_g/gfx_b/gfx_a/gfx_mode/gfx_a2, sets gfx_dest if final parameter specified\n\n\n\n \n\n EEL2: \n\n\n\nSpecify 0 resource_id and custom_cursor_name from https://www.reaper.fm/sdk/cursors/cursors.php (e.g. 'arrow') to set the cursor. Alternatively can specify resource_id for a Windows cursor or built-in REAPER cursor.\n\n\n\n \n\n EEL2: \n\n\n\nCan select a font and optionally configure it. idx=0 for default bitmapped font, no configuration is possible for this font. idx=1..16 for a configurable font, specify fontface such as \"Arial\", sz of 8-100, and optionally specify flags, which is a multibyte character, which can include 'i' for italics, 'u' for underline, or 'b' for bold. These flags may or may not be supported depending on the font and OS. After calling gfx_setfont(), gfx_texth may be updated to reflect the new average line height.\n\n\n\n \n\n EEL2: \n\n\n\nResize image referenced by index 0..1024-1, width and height must be 0-8192. The contents of the image will be undefined after the resize.\n\n\n\n \n\n EEL2: \n\n\n\nWrites a pixel of r,g,b to gfx_x,gfx_y.\n\n\n\n \n\n EEL2: \n\n\n\nShows a popup menu at gfx_x,gfx_y. str is a list of fields separated by | characters. Each field represents a menu item.\n\nFields can start with special characters:\n\n\n\n# : grayed out\n\n! : checked\n\n> : this menu item shows a submenu\n\n< : last item in the current submenu\n\n\n\nAn empty field will appear as a separator in the menu. gfx_showmenu returns 0 if the user selected nothing from the menu, 1 if the first field is selected, etc.\n\nExample:\n\n\n\ngfx_showmenu(\"first item, followed by separator||!second item, checked|>third item which spawns a submenu|#first item in submenu, grayed out|<second and last item in submenu|fourth item in top menu\")\n\n\n\n \n\n EEL2: \n\n\n\nBlits to destination at (destx,desty), size (destw,desth). div_w and div_h should be 2..64, and table should point to a table of 2*div_w*div_h values (this table must not cross a 65536 item boundary). Each pair in the table represents a S,T coordinate in the source image, and the table is treated as a left-right, top-bottom list of texture coordinates, which will then be rendered to the destination.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a filled triangle, or any convex polygon. \n\n\n\n\n\n EEL2: \n\n\n\nUpdates the graphics display, if opened\n\n\n\n \n\n EEL2: \n\n\n\nPerform an inverse FFT. For more information see fft().\n\n\n\n \n\n EEL2: \n\n\n\nPerforms an inverse FFT, but takes size/2 complex input pairs and produces size real output values. Usually used along with fft_ipermute(size/2).\n\n\n\n \n\n EEL2: \n\n\n\nReturns a fast inverse square root (1/sqrt(x)) approximation of the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the natural logarithm (base e) of the parameter. If the value is not greater than 0, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the base-10 logarithm of the parameter. If the value is not greater than 0, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nEvaluates count once, and then executes expression count, but not more than 1048576, times.\n\n\n\n \n\n EEL2: \n\n\n\nSearches for the first parameter in the second parameter, using a simplified regular expression syntax. \n\nYou can also use format specifiers to match certain types of data, and optionally put that into a variable:\n• %x, %d, %u, and %f are available for use similarly\n• %c can be used, but can't take any length modifiers\n• Use uppercase (%S, %D, etc) for lazy matching\n\n \n\nSee also sprintf() for other notes, including specifying direct variable references via {}.\n\n\n\n \n\n EEL2: \n\n\n\nCase-insensitive version of match().\n\n\n\n \n\n EEL2: \n\n\n\nReturns (by reference) the maximum value of the two parameters. Since max() returns by reference, expressions such as max(x,y) = 5 are possible.\n\n\n\n \n\n EEL2: \n\n\n\nReads values from memory starting at offset into variables specified. Slower than regular memory reads for less than a few variables, faster for more than a few. Undefined behavior if used with more than 32767 variables.\n\n\n\n \n\n EEL2: \n\n\n\nShuffles contents of buf right by 1, inserts value at buf[0], returns previous buf[len-1].\n\n\n\n \n\n EEL2: \n\n\n\nCalculates the sum of the products of values pointed to by src1 and src2. If src1 is -1, then calculates the sum of squares of src2, if -2, the sum of the absolute values of src2, if -3, calculates the sum of the values of src2. Other negative values are undefined.\n\n\n\n \n\n EEL2: \n\n\n\nWrites values to memory starting at offset from variables specified. Slower than regular memory writes for less than a few variables, faster for more than a few. Undefined behavior if used with more than 32767 variables.\n\n\n\n \n\n EEL2: \n\n\n\nCopies length items of memory from src to dest. Regions are permitted to overlap.\n\n\n\n \n\n EEL2: \n\n\n\nSets length items of memory at offset to value.\n\n\n\n \n\n EEL2: \n\n\n\nReturns (by reference) the minimum value of the two parameters. Since min() returns by reference, expressions such as min(x,y) = 5 are possible.\n\n\n\n \n\n EEL2: \n\n\n\nOutput formatted string to system-specific destination, see sprintf() for more information\n\n\n\n \n\n EEL2: \n\n\n\nReturns a pseudorandom real number between 0 and the parameter, inclusive. If the parameter is omitted or less than 1.0, 1.0 is used as a maximum instead.\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n EEL2: \n\n\n\nSets action options for the script.\n\nflag&1: script will auto-terminate if re-launched while already running\n\nflag&2: if (flag&1) is set, script will re-launch after auto-terminating. otherwise, re-launch is ignored.\n\nflag&4: set script toggle state on\n\nflag&8: set script toggle state off\n\n\n\n\n\n \n\n EEL2: \n\n\n\nReturns 1.0 if the parameter is greater than 0, -1.0 if the parameter is less than 0, or 0 if the parameter is 0.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the sine of the angle specified (specified in radians -- to convert from degrees to radians, multiply by $pi/180, or 0.017453).\n\n\n\n \n\n EEL2: \n\n\n\nYields the CPU for the millisecond count specified, calling Sleep() on Windows or usleep() on other platforms.\n\n\n\n \n\n EEL2: \n\n\n\nFormats a string and stores it in #dest. Format specifiers begin with %, and may include: \n\nMany standard C printf() modifiers can be used, including:\n• %.10s = string, but only print up to 10 characters\n\n \n\nValues for format specifiers can be specified as additional parameters to sprintf, or within {} in the format specifier (such as %{varname}d, in that case a global variable is always used).\n\n\n\n \n\n EEL2: \n\n\n\nReturns the square of the parameter (similar to value*value, but only evaluating value once).\n\n\n\n \n\n EEL2: \n\n\n\nReturns the square root of the parameter. If the parameter is negative, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nExchanges a value with the top of the stack, and returns a reference to the parameter (with the new value).\n\n\n\n \n\n EEL2: \n\n\n\nReturns a reference to the item on the top of the stack (if index is 0), or to the Nth item on the stack if index is greater than 0. \n\n\n\n \n\n EEL2: \n\n\n\nPops a value from the user stack into value, or into a temporary buffer if value is not specified, and returns a reference to where the stack was popped. Note that no checking is done to determine if the stack is empty, and as such stack_pop() will never fail.\n\n\n\n \n\n EEL2: \n\n\n\nPushes value onto the user stack, returns a reference to the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nDeletes len characters at offset pos from #str, and returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the data at byte-offset offset of str. If offset is negative, position is relative to end of string.type defaults to signed char, but can be specified to read raw binary data in other formats (note the single quotes, these are single/multi-byte characters): \n\n\n\n \n\n EEL2: \n\n\n\nInserts srcstr into #str at offset pos. Returns #str\n\n\n\n \n\n EEL2: \n\n\n\nSets value at offset offset, type optional. offset may be negative to refer to offset relative to end of string, or between 0 and length, inclusive, and if set to length it will lengthen string. See str_getchar() for more information on types.\n\n\n\n \n\n EEL2: \n\n\n\nSets length of #str (if increasing, will be space-padded), and returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nAppends srcstr to #str, and returns #str\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nCopies the contents of srcstr to #str, and returns #str\n\n\n\n \n\n EEL2: \n\n\n\nCopies srcstr to #str, but starts reading srcstr at offset offset\n\n\n\n \n\n EEL2: \n\n\n\nPHP-style (start at offs, offs<0 means from end, ml for maxlen, ml<0 = reduce length by this amt)\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings ignoring case, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nReturns the length of the string passed as a parameter\n\n\n\n \n\n EEL2: \n\n\n\nAppends srcstr to #str, stopping after maxlen characters of srcstr. Returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings giving up after maxlen characters, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nCopies srcstr to #str, stopping after maxlen characters. Returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings giving up after maxlen characters, ignoring case, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nReturns the tangent of the angle specified (specified in radians).\n\n\n\n \n\n EEL2: \n\n\n\nCloses a TCP connection created by tcp_listen() or tcp_connect().\n\n\n\n \n\n EEL2: \n\n\n\nCreate a new TCP connection to address:port. If block is specified and 0, connection will be made nonblocking. Returns TCP connection ID greater than 0 on success.\n\n\n\n \n\n EEL2: \n\n\n\nListens on port specified. Returns less than 0 if could not listen, 0 if no new connection available, or greater than 0 (as a TCP connection ID) if a new connection was made. If a connection made and #ip_out specified, it will be set to the remote IP. interface can be empty for all interfaces, otherwise an interface IP as a string.\n\n\n\n \n\n EEL2: \n\n\n\nEnds listening on port specified.\n\n\n\n \n\n EEL2: \n\n\n\nReceives data from a connection to #str. If maxlen is specified, no more than maxlen bytes will be received. If non-blocking, 0 will be returned if would block. Returns less than 0 if error.\n\n\n\n \n\n EEL2: \n\n\n\nSends a string to connection. Returns -1 on error, 0 if connection is non-blocking and would block, otherwise returns length sent. If len is specified and not less than 1, only the first len bytes of the string parameter will be sent.\n\n\n\n \n\n EEL2: \n\n\n\nSets whether a connection blocks.\n\n\n\n \n\n EEL2: \n\n\n\nSets the parameter (or a temporary buffer if omitted) to the number of seconds since January 1, 1970, and returns a reference to that value. The granularity of the value returned is 1 second.\n\n\n\n \n\n EEL2: \n\n\n\nSets the parameter (or a temporary buffer if omitted) to a system-local timestamp in seconds, and returns a reference to that value. The granularity of the value returned is system defined (but generally significantly smaller than one second).\n\n\n\n \n\n EEL2: \n\n\n\nExecutes expression until expression evaluates to zero, or until 1048576iterations occur. An alternate and more useful syntax is while (expression) ( statements ), which evaluates statements after every non-zero evaluation of expression.\n\n\n\n EEL2:Returns the absolute value of the parameter.EEL2:Returns the arc cosine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc sine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc tangent of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc tangent of the numerator divided by the denominator, allowing the denominator to be 0, and using their signs to produce a more meaningful result.EEL2:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.EEL2:Returns the value rounded to the next highest integer (ceil(3.1)==4, ceil(-3.9)==-3).EEL2:Multiplies each of size complex pairs in dest by the complex pairs in src. Often used for convolution.EEL2:Returns the cosine of the angle specified (specified in radians).EEL2:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.EEL2:Executes code passed in. Code can use functions, but functions created in code can't be used elsewhere.EEL2:Returns the number e ($e, approximately 2.718) raised to the parameter-th power. This function is significantly faster than pow() or the ^ operator.EEL2:Used to call functions exported by extension plugins. The first parameter must be the exported function name, then its own parameters (as if the function was called directly).EEL2:Closes a file previously opened with fopen().EEL2:Returns nonzero if the file fp is at the end of file.EEL2:If file fp is open for writing, flushes out any buffered data to disk.EEL2:Performs a FFT on the data in the local memory buffer at the offset specified by the first parameter. The size of the FFT is specified by the second parameter, which must be 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, or 32768. The outputs are permuted, so if you plan to use them in-order, call fft_permute(buffer, size) before and fft_ipermute(buffer,size) after your in-order use. Your inputs or outputs will need to be scaled down by 1/size, if used.Note that fft()/ifft() require real / imaginary input pairs, so a 256 point FFT actually works with 512 items.Note that fft()/ifft() must NOT cross a 65,536 item boundary, so be sure to specify the offset accordingly.EEL2:Permute the input for ifft(), taking bands from in-order to the order ifft() requires. See fft () for more information.EEL2:Permute the output of fft() to have bands in-order. See fft () for more information.EEL2:Performs an FFT, but takes size input samples and produces size/2 complex output pairs. Usually used along with fft_permute(size/2). Inputs/outputs will need to be scaled by 0.5/size.EEL2:Reads a character from file fp, returns -1 if EOF.EEL2:Reads a line from file fp into #str. Returns length of #str read.EEL2:Returns the value rounded to the next lowest integer (floor(3.9)==3, floor(-3.1)==-4).EEL2:Opens a file \"fn\" with mode \"mode\". For read, use \"r\" or \"rb\", write \"w\" or \"wb\". Returns a positive integer on success.EEL2:Formats a string and writes it to file fp. For more information on format specifiers, see sprintf (). Returns bytes written to file.EEL2:Reads from file fp into #str, up to length bytes. Returns actual length read, or negative if error.EEL2:Hints the runtime that memory above the address specified may no longer be used. The runtime may, at its leisure, choose to lose the contents of memory above the address specified.EEL2:Seeks file fp, offset bytes from whence reference. Whence negative specifies start of file, positive whence specifies end of file, and zero whence specifies current file position.EEL2:Retunrs the current file position.EEL2:Writes up to len characters of #str to file fp. If len is less than 1, the full contents of #str will be written. Returns the number of bytes written to file.EEL2:Queries contextual information about the script, typically MIDI/OSC input values.Returns true if a new value has been updated.val will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).resolution=127 for 7-bit resolution, =16383 for 14-bit resolution.sectionID, and cmdID will be set to -1 if the script is not part of the action list.mode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.contextstr may be empty or one of:(flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)EEL2:The following global variables are special and will be used by the graphics system:EEL2:Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.EEL2:Copies from source (-1 = main framebuffer, or an image from gfx_loadimg() etc), using current opacity and copy mode (set with gfx_a, gfx_mode).If destx/desty are not specified, gfx_x/gfx_y will be used as the destination position.scale (1.0 is unscaled) will be used only if destw/desth are not specified.rotation is an angle in radianssrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)destx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale).EEL2:Deprecated, use gfx_blit instead.EEL2:Blurs the region of the screen between gfx_x,gfx_y and x,y, and updates gfx_x,gfx_y to x,y.EEL2:Draws a circle, optionally filling/antialiasing.EEL2:Converts client coordinates x,y to screen coordinates.EEL2:Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.EEL2:Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh are specified, they will be filled with the undocked window position/sizeEEL2:Draws the character (can be a numeric ASCII code as well), to gfx_x, gfx_y, and moves gfx_x over by the size of the character.EEL2:Draws the number n with ndigits of precision to gfx_x, gfx_y, and updates gfx_x to the right side of the drawing. The text height is gfx_texth.EEL2:Draws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y so that subsequent draws will occur in a similar place.If flags, right ,bottom passed in:\n\n\n\n\n\n \n\n \n\n Lua: \n\n\n\n Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n Lua: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Lua: \n\n\n\n is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context()\n\nReturns contextual information about the script, typically MIDI/OSC input values.\n\nval will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).\n\nresolution=127 for 7-bit resolution, =16383 for 14-bit resolution.\n\nsectionID, and cmdID will be set to -1 if the script is not part of the action list.\n\nmode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.\n\ncontextstr may be empty or one of:\n• midi:XX[:YY] (one or two bytes hex)\n\n (flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)\n\n\n\n\n\n \n\n Lua: \n\n\n\n The following global variables are special and will be used by the graphics system:\n• gfx.a2 - current alpha component (0..1) used by drawing operations when writing solid colors (normally ignored but useful when creating transparent images).\n• gfx.mode - blend mode for drawing. Set mode to 0 for default options. Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx.a to negative and use gfx.mode as additive). Add 2.0 to disable source alpha for gfx.blit(). Add 4.0 to disable filtering for gfx.blit().\n• gfx.x - current graphics position X. Some drawing functions use as start position and update.\n• gfx.y - current graphics position Y. Some drawing functions use as start position and update.\n• gfx.clear - if greater than -1.0, framebuffer will be cleared to that color. the color for this one is packed RGB (0..255), i.e. red+green*256+blue*65536. The default is 0 (black).\n• gfx.dest - destination for drawing operations, -1 is main framebuffer, set to 0..1024-1 to have drawing operations go to an offscreen buffer (or loaded image).\n• gfx.texth - the (READ-ONLY) height of a line of text in the current font. Do not modify this variable.\n• gfx.ext_retina - to support hidpi/retina, callers should set to 1.0 on initialization, this value will be updated to value greater than 1.0 (such as 2.0) if retina/hidpi. On macOS gfx.w/gfx.h/etc will be doubled, but on other systems gfx.w/gfx.h will remain the same and gfx.ext_retina is a scaling hint for drawing.\n• gfx.mouse_x - current X coordinate of the mouse relative to the graphics window.\n• gfx.mouse_y - current Y coordinate of the mouse relative to the graphics window.\n• gfx.mouse_wheel - wheel position, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• gfx.mouse_hwheel - horizontal wheel positions, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• gfx.mouse_cap - a bitfield of mouse and keyboard modifier state. Note that a script must call gfx.getchar() at least once in order to get modifier state when the mouse is not captured by the window. Bitfield bits: \n\n\n\n \n\n Lua: \n\n\n\n Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.\n\n\n\n \n\n Lua: \n\n\n\n Copies from source (-1 = main framebuffer, or an image from gfx.loadimg() etc), using current opacity and copy mode (set with gfx.a, gfx.mode).\n\nIf destx/desty are not specified, gfx.x/gfx.y will be used as the destination position.\n\nscale (1.0 is unscaled) will be used only if destw/desth are not specified.\n\nrotation is an angle in radians\n\nsrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)\n\ndestx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale). \n\n\n\n \n\n Lua: \n\n\n\n Deprecated, use gfx.blit instead.\n\n\n\n \n\n Lua: \n\n\n\n Blurs the region of the screen between gfx.x,gfx.y and x,y, and updates gfx.x,gfx.y to x,y.\n\n\n\n \n\n Lua: \n\n\n\n Draws a circle, optionally filling/antialiasing. \n\n\n\n \n\n Lua: \n\n\n\n Converts the coordinates x,y to screen coordinates, returns those values.\n\n\n\n \n\n Lua: \n\n\n\n Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.\n\n\n\n \n\n Lua: \n\n\n\n Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh specified, additional values will be returned with the undocked window position/size\n\n\n\n \n\n Lua: \n\n\n\n Draws the character (can be a numeric ASCII code as well), to gfx.x, gfx.y, and moves gfx.x over by the size of the character.\n\n\n\n \n\n Lua: \n\n\n\n Draws the number n with ndigits of precision to gfx.x, gfx.y, and updates gfx.x to the right side of the drawing. The text height is gfx.texth.\n\n\n\n \n\n Lua: \n\n\n\n Draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y so that subsequent draws will occur in a similar place.\n\n\n\nIf flags, right ,bottom passed in:\n• flags&256: ignore right/bottom, otherwise text is clipped to (gfx.x, gfx.y, right, bottom)\n\n\n\n \n\n Lua: \n\n\n\n If char is 0 or omitted, returns a character from the keyboard queue, or 0 if no character is available, or -1 if the graphics window is not open. If char is specified and nonzero, that character's status will be checked, and the function will return greater than 0 if it is pressed. Note that calling gfx.getchar() at least once causes gfx.mouse_cap to reflect keyboard modifiers even when the mouse is not captured.\n\n\n\nCommon values are standard ASCII, such as 'a', 'A', '=' and '1', but for many keys multi-byte values are used, including 'home', 'up', 'down', 'left', 'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'. \n\n\n\nModified and special keys can also be returned, including:\n• 65536 for query of special flags, returns: &1 (supported), &2=window has focus, &4=window is visible, &8=mouse click would hit window. 65537 queries special flags but does not do the mouse click hit testing (faster).\n• If unichar is specified, it will be set to the unicode value of the key if available (and the return value may be the unicode value or a raw key value as described above, depending). If unichar is not specified, unicode codepoints greater than 255 will be returned as 'u'<<24 + value\n\n \n\n\n\n \n\n Lua: \n\n\n\n Returns success,string for dropped file index idx. call gfx.dropfile(-1) to clear the list when finished.\n\n\n\n \n\n Lua: \n\n\n\n Returns current font index, and the actual font face used by this font (if available).\n\n\n\n \n\n Lua: \n\n\n\n Retreives the dimensions of an image specified by handle, returns w, h pair.\n\n\n\n \n\n Lua: \n\n\n\n Returns r,g,b values [0..1] of the pixel at (gfx.x,gfx.y)\n\n\n\n \n\n Lua: \n\n\n\n Fills a gradient rectangle with the color and alpha specified. drdx-dadx reflect the adjustment (per-pixel) applied for each pixel moved to the right, drdy-dady are the adjustment applied for each pixel moved toward the bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\n\n\n\n \n\n Lua: \n\n\n\n Initializes the graphics window with title name. Suggested width and height can be specified. If window is already open, a non-empty name will re-title window, or an empty title will resize window. \n\n\n\nOnce the graphics window is open, gfx.update() should be called periodically. \n\n\n\n \n\n Lua: \n\n\n\n Draws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased. \n\n\n\n \n\n Lua: \n\n\n\n Draws a line from gfx.x,gfx.y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx.x and gfx.y to x,y.\n\n\n\n \n\n Lua: \n\n\n\n Load image from filename into slot 0..1024-1 specified by image. Returns the image index if success, otherwise -1 if failure. The image will be resized to the dimensions of the image file. \n\n\n\n \n\n Lua: \n\n\n\n Measures the drawing dimensions of a character with the current font (as set by gfx.setfont). Returns width and height of character.\n\n\n\n \n\n Lua: \n\n\n\n Measures the drawing dimensions of a string with the current font (as set by gfx.setfont). Returns width and height of string.\n\n\n\n \n\n Lua: \n\n\n\n Multiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\n\n\n\n \n\n Lua: \n\n\n\n Formats and draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y accordingly (the latter only if the formatted string contains newline). For more information on format strings, see sprintf()\n\n\n\n \n\n Lua: \n\n\n\n Closes the graphics window.\n\n\n\n \n\n Lua: \n\n\n\n Fills a rectangle at x,y, w,h pixels in dimension, filled by default. \n\n\n\n \n\n Lua: \n\n\n\n Fills a rectangle from gfx.x,gfx.y to x,y. Updates gfx.x,gfx.y to x,y. \n\n\n\n \n\n Lua: \n\n\n\n Draws a rectangle with rounded corners. \n\n\n\n \n\n Lua: \n\n\n\n Converts the screen coordinates x,y to client coordinates, returns those values.\n\n\n\n \n\n Lua: \n\n\n\n Sets gfx.r/gfx.g/gfx.b/gfx.a/gfx.mode/gfx.a2, sets gfx.dest if final parameter specified\n\n\n\n \n\n Lua: \n\n\n\n Sets the mouse cursor to resource_id and/or custom_cursor_name. \n\n\n\n \n\n Lua: \n\n\n\n Can select a font and optionally configure it. idx=0 for default bitmapped font, no configuration is possible for this font. idx=1..16 for a configurable font, specify fontface such as \"Arial\", sz of 8-100, and optionally specify flags, which is a multibyte character, which can include 'i' for italics, 'u' for underline, or 'b' for bold. These flags may or may not be supported depending on the font and OS. After calling gfx.setfont(), gfx.texth may be updated to reflect the new average line height.\n\n\n\n \n\n Lua: \n\n\n\n Resize image referenced by index 0..1024-1, width and height must be 0-8192. The contents of the image will be undefined after the resize.\n\n\n\n \n\n Lua: \n\n\n\n Writes a pixel of r,g,b to gfx.x,gfx.y.\n\n\n\n \n\n Lua: \n\n\n\n Shows a popup menu at gfx.x,gfx.y. str is a list of fields separated by | characters. Each field represents a menu item.\n\nFields can start with special characters:\n\n\n\n# : grayed out\n\n! : checked\n\n> : this menu item shows a submenu\n\n< : last item in the current submenu\n\n\n\nAn empty field will appear as a separator in the menu. gfx.showmenu returns 0 if the user selected nothing from the menu, 1 if the first field is selected, etc.\n\nExample:\n\n\n\ngfx.showmenu(\"first item, followed by separator||!second item, checked|>third item which spawns a submenu|#first item in submenu, grayed out|<second and last item in submenu|fourth item in top menu\")\n\n\n\n \n\n Lua: \n\n\n\n Blits to destination at (destx,desty), size (destw,desth). div_w and div_h should be 2..64, and table should point to a table of 2*div_w*div_h values (table can be a regular table or (for less overhead) a reaper.array). Each pair in the table represents a S,T coordinate in the source image, and the table is treated as a left-right, top-bottom list of texture coordinates, which will then be rendered to the destination.\n\n\n\n \n\n Lua: \n\n\n\n Draws a filled triangle, or any convex polygon. \n\n\n\n \n\n Lua: \n\n\n\n Updates the graphics display, if opened\n\n\n\n \n\n Lua: \n\n\n\n Causes gmem_read()/gmem_write() to read EEL2/JSFX/Video shared memory segment named by parameter. Set to empty string to detach. 6.20+: returns previous shared memory segment name.\n\n\n\n \n\n Lua: \n\n\n\n Read (number) value from shared memory attached-to by gmem_attach(). index can be [0..1<<25).\n\n\n\n \n\n Lua: \n\n\n\n Write (number) value to shared memory attached-to by gmem_attach(). index can be [0..1<<25).\n\n\n\n \n\n Lua: \n\n\n\n Creates a new reaper.array object of maximum and initial size size, if specified, or from the size/values of a table/array. Both size and table/array can be specified, the size parameter will override the table/array size.\n\n\n\n \n\n Lua: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Lua: \n\n\n\n reaper.set_action_options(flag)\n\nSets action options for the script.\n\nflag&1: script will auto-terminate if re-launched while already running\n\nflag&2: if (flag&1) is set, script will re-launch after auto-terminating. otherwise, re-launch is ignored.\n\nflag&4: set script toggle state on\n\nflag&8: set script toggle state off\n\n\n\n\n\n \n\n Lua: \n\n\n\n Sets the value of zero or more items in the array. If value not specified, 0.0 is used. offset is 1-based, if size omitted then the maximum amount available will be set.\n\n\n\n \n\n Lua: \n\n\n\n Convolves complex value pairs from reaper.array, starting at 1-based srcoffs, reading/writing to 1-based destoffs. size is in normal items (so it must be even)\n\n\n\n \n\n Lua: \n\n\n\n Copies values from reaper.array or table, starting at 1-based srcoffs, writing to 1-based destoffs.\n\n\n\n \n\n Lua: \n\n\n\n Performs a forward FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled following the FFT to be in normal order.\n\n\n\n \n\n Lua: \n\n\n\n Performs a forward real->complex FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled following the FFT to be in normal order.\n\n\n\n \n\n Lua: \n\n\n\n Returns the maximum (allocated) size of the array.\n\n\n\n \n\n Lua: \n\n\n\n Performs a backwards FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled before the IFFT to be in fft-order.\n\n\n\n \n\n Lua: \n\n\n\n Performs a backwards complex->real FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled before the IFFT to be in fft-order.\n\n\n\n \n\n Lua: \n\n\n\n Multiplies values from reaper.array, starting at 1-based srcoffs, reading/writing to 1-based destoffs.\n\n\n\n \n\n Lua: \n\n\n\n Resizes an array object to size. size must be [0..max_size].\n\n\n\n \n\n Lua: \n\n\n\n Returns a new table with values from items in the array. Offset is 1-based and if size is omitted all available values are used.\n\n\n\n Lua:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.Lua:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.Lua:is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context()Returns contextual information about the script, typically MIDI/OSC input values.val will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).resolution=127 for 7-bit resolution, =16383 for 14-bit resolution.sectionID, and cmdID will be set to -1 if the script is not part of the action list.mode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.contextstr may be empty or one of:(flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)Lua:The following global variables are special and will be used by the graphics system:Lua:Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.Lua:Copies from source (-1 = main framebuffer, or an image from gfx.loadimg() etc), using current opacity and copy mode (set with gfx.a, gfx.mode).If destx/desty are not specified, gfx.x/gfx.y will be used as the destination position.scale (1.0 is unscaled) will be used only if destw/desth are not specified.rotation is an angle in radianssrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)destx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale).Lua:Deprecated, use gfx.blit instead.Lua:Blurs the region of the screen between gfx.x,gfx.y and x,y, and updates gfx.x,gfx.y to x,y.Lua:Draws a circle, optionally filling/antialiasing.Lua:Converts the coordinates x,y to screen coordinates, returns those values.Lua:Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.Lua:Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh specified, additional values will be returned with the undocked window position/sizeLua:Draws the character (can be a numeric ASCII code as well), to gfx.x, gfx.y, and moves gfx.x over by the size of the character.Lua:Draws the number n with ndigits of precision to gfx.x, gfx.y, and updates gfx.x to the right side of the drawing. The text height is gfx.texth.Lua:Draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y so that subsequent draws will occur in a similar place.If flags, right ,bottom passed in:\n\n\n\n\n\n \n\n \n\n Python: \n\n\n\n Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n Python: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Python: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n Python:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.Python:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.Python:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly."
    },
    {
        "link": "https://extremraym.com/cloud/reascript-doc",
        "document": "Thank you for considering making a donation or buy one of Premium Scripts to support this free work! ❤️"
    },
    {
        "link": "https://mespotin.uber.space/Ultraschall/Reaper_Api_Documentation.html",
        "document": ""
    },
    {
        "link": "https://adamtcroft.com/how-to-read-the-reascript-api",
        "document": "Next week I’ll begin walking you through how to write real, functioning Reascripts. My plan with that is to dive in head-first – even if you have zero knowledge – and walk you through it step-by-step.\n\nBut before we do that, I have to introduce you to a concept that’s going to confuse the crap out of you if you’ve never programmed a line of code before.\n\nDon’t worry if you don’t understand anything in this post, just continue on with the examples that I write up in future posts. Once you start learning the basics and seeing patterns, you’ll be coming back to this page for reference.\n\nSo today I’m going to introduce you to…\n\nAPI is an acronym for Application Program Interface. In layman’s terms, an API is a set of pre-written code provided by a software’s developer to allow other people to extend their software’s native capabilities.\n\nAn audio-related example: think of an API as the presets that come with a keyboard or a guitar pedal. They come prepackaged, and sometimes you use a lot of them to build a brand new sound. While this isn’t an ideal analogy (some presets suck and you never use them, and they’re not always building blocks) – hopefully it’ll serve as a basis for understanding the concept.\n\nAs a more specific example, to find out if a track is muted you’ll use code that looks like reaper.GetMediaTrackInfo_Value(track_name, “B_MUTE”, 0). Or to get the number of tracks that are currently selected the code looks like reaper.CountSelectedTracks(0).\n\nWhere do you find the Reaper API?\n\nThe Reaper API is pretty easy to find. When all else fails you can quickly stick “Reaper API” in your Google machine.\n\nOtherwise, click here to go directly to it.\n\n Note: the above link is a depreciated version of the API. The proper way to access it is within Reaper itself. Go to the Help menu and click “Reascript Documentation”.\n\nAlso Raymond Radet (X-Raym) has created a great page that allows you to quickly search the API for a given function. While he warns it’s not always 100% up-to-date, I haven’t found an issue with it thus far.\n\nHow in the world do you read the Reascript API?\n\nSo once you’re at the API, first allow your eyeballs to be seared with pain at the white background with Times New Roman font. Consider this the only hazing ritual – welcome to the club (or run to X-Raym’s page)\n\nBefore I go further, for this series I’ll only be covering how to read the API for Lua. From there you should be able to see similar patterns in C++/Python, but I won’t be walking through them specifically.\n\nYour first job is to scroll down the page until you see the API Functions List. These are all of your pre-written codes (called functions from here on out) that will help you make cool new actions in Reaper! Most of these are fairly straightforward and are named by what they do. For example\n• AnyTrackSolo – this will return a true variable if there is any track solo’ed in your project, it will return a false variable if there are no tracks solo’ed.\n• CountProjectMarkers – this will return a variable with the total number of markers in your project\n\nYou can click on each of these functions to get more detail about exactly how to use them. Let’s look at that now…\n\nFirst we’ll look at CountSelectedMediaItems. For those of you unfamiliar, a Media Item in Reaper is a segment of audio (or images & video, but ignore that for this example) on the timeline. Pro Tools calls these “clips” if you’re more familiar with that.\n\nBelow is the API reference for CountSelectedMediaItems:\n\ncount the number of selected items in the project (proj=0 for active project)\n\nThe first thing you see is that the same function is written a little differently for each language. There is also a description of what the function does at the bottom, as well as a bit of info on how to get access the project you’re currently working on.\n\nGoing left to right, let’s explain everything in detail…\n• integer is describing what kind of information this function will give back to you after the code runs. In this case, it will return a number. More specifically, the number of selected items. So you’ll have to provide a variable for this go to into. Your code will end up looking like this for your current project:\n\n number_of_media_items = reaper.CountSelectedMediaItems(0)\n• reaper.CountSelectedMediaItems is the name of the function. In Lua, functions have the prefix “reaper.”, and then finish with the function name.\n• (ReaProject proj) is the parameter you need to provide the function. That’s a fancy way of saying the information you hand off to the function. In this case, it’s looking for a “ReaProject” (aka Reaper Project) which is represented by a number (shown as “proj” in the example). As they told you earlier in the API – “0” is the active project.\n\nSo our code number_of_media_items = reaper.CountSelectedMediaItems(0) means “hey Reaper, give me the number of Media Items in my active project that are selected and dump it in the variable number_of_media_items“. If we have a variable that equals zero the code can also look like number_of_media_items = reaper.CountSelectedMediaItems(variable)\n\nA little less difficult than you thought, right?!\n\nGoing left to right again…\n• number this time instead of getting back specifically an integer (aka a whole number with no decimals), we’re going to get back a number. In Lua, an integer is a sub-type of number variables. The other number subtype is called a float (essentially a number that can have decimal places). Since running this function will give you back a number, said number can be an integer decimal. Mostly what matters is this variable is going to be the information we want to get from the function.\n• reaper.GetMediaTrackInfo_Value is again the name of the function. You see the prefix “reaper.” again, and the function name is GetMediaTrackInfo_Value. Clearly, we’re trying to get information in number form (aka “Value”) from a Media Track\n• (MediaTrack tr, string paramname) just like before, these are the parameters we’re giving the function. In this case, for the function to work we need to give it two parameters. The first is a Media Track, aka a track from the timeline. The second is a string (in programming a string is essentially a word or set of words) “paramname”. If you go check out the specific reference to this function you’ll see a TON of options you can get information on such as mute, phase, solo, record arm, record input, volume, pan, etc. In our case, we want to know if the track is muted. So our paramname string is “B_MUTE”.\n\nSo our finished code for finding the mute status of a track would look like track_mute_status = reaper.GetMediaTrackInfo_Value(track, “B_MUTE”).\n\nKeep in mind, if you just write this code straight away and run it in Reaper, you’ll get an error. You need to use another function (reaper.GetTrack) to store a track variable and actually make this work.\n\nSo that’s pretty much all there is to reading the API! Certainly things can get a little more complicated, but this basic reference should start you off on the right foot. If you have any questions – I’m on twitter @adamtcroft – don’t be a stranger!"
    },
    {
        "link": "https://scribd.com/document/372358212/REAPER-API-functions-pdf",
        "document": "REAPER provides an API that allows users to extend its functionality through ReaScripts written in EEL, Lua, or Python. These scripts can call API functions to control aspects of REAPER like tracks, items, and playback. The API can be accessed in ReaScripts through function calls prefixed with the language (e.g. reaper.functionname() in Lua). Standard and graphical functions are available beyond the core API."
    },
    {
        "link": "https://randycoppinger.com/2024/12/28/beginners-guide-to-reaper-script",
        "document": ""
    },
    {
        "link": "https://reaper.fm/sdk/reascript/reascripthelp.html",
        "document": "ReaScript/Python requires a recent version of Python installed on this machine. Python is available from multiple sources as a \n\n\n\n ReaScript/Python scripts can call API functions using .\n\n\n\n All parameters are passed by value, not reference. API functions that cannot return information in the parameter list will return a single value. API functions that can return any information in the parameter list will return a list of values; The first value in the list will be the function return value (unless the function is declared to return void).\n\n\n\n Examples:\n\n # function returning a single (scalar) value:\n\n sec = RPR_parse_timestr(\"1:12\")\n\n\n\n # function returning information in the first parameter (function returns void):\n\n (str) = RPR_GetProjectPath(\"\", 512)\n\n\n\n # lower volume of track 3 by half (RPR_GetTrackUIVolPan returns Bool):\n\n tr = RPR_GetTrack(0, 2)\n\n (ok, tr, vol, pan) = RPR_GetTrackUIVolPan(tr, 0, 0)\n\n # this also works, if you only care about one of the returned values:\n\n vol = RPR_GetTrackUIVolPan(tr, 0, 0)[2]\n\n RPR_SetMediaTrackInfo_Value(tr, \"D_VOL\", vol*0.5)\n\n \n\n You can create and save modules of useful functions that you can import into other ReaScripts. For example, if you create a file called reascript_utility.py that contains the function helpful_function(), you can import that file into any Python ReaScript with the line: and call the function by using: \n\n Note that ReaScripts must explicitly import the REAPER python module, even if the script is imported into another ReaScript: \n\n In addition to the \n\n\n\n ReaScript/Python requires a recent version of Python installed on this machine. Python is available from multiple sources as a free download . Python 2.7 is normally included with macOS, and the dynamic library is usually in /usr/lib. If you update to a newer version of Python, it will be installed to a different directory. After installing Python, REAPER may detect the Python dynamic library automatically. If not, you can enter the path in the ReaScript preferences page, at Options/Preferences/Plug-Ins/ReaScript.ReaScript/Python scripts can call API functions usingAll parameters are passed by value, not reference. API functions that cannot return information in the parameter list will return a single value. API functions that can return any information in the parameter list will return a list of values; The first value in the list will be the function return value (unless the function is declared to return void).Examples:You can create and save modules of useful functions that you can import into other ReaScripts. For example, if you create a file called reascript_utility.py that contains the function helpful_function(), you can import that file into any Python ReaScript with the line:and call the function by using:Note that ReaScripts must explicitly import the REAPER python module, even if the script is imported into another ReaScript:In addition to the standard API functions , Reascript/Python also has these built-in functions available:\n\nstring out = reaper.image_resolve_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.relative_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.resolve_fn(string in, string out) \n\n\n\n\n\nstring out = reaper.resolve_fn2(string in, string out, optional string checkSubDir)\n• col_main_textshadow : Main window text shadow (ignored if too close to text color)\n• col_nodarkmodemiscwnd : Do not use window theming on macOS dark mode\n• track_lanesolo_tabcol : Track fixed lane button when only this lane plays\n\n\n\n\n\n \n\n \n\n EEL2: \n\n\n\nReturns the absolute value of the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc cosine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc sine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc tangent of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the arc tangent of the numerator divided by the denominator, allowing the denominator to be 0, and using their signs to produce a more meaningful result.\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the value rounded to the next highest integer (ceil(3.1)==4, ceil(-3.9)==-3).\n\n\n\n \n\n EEL2: \n\n\n\nMultiplies each of size complex pairs in dest by the complex pairs in src. Often used for convolution.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the cosine of the angle specified (specified in radians).\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n EEL2: \n\n\n\nExecutes code passed in. Code can use functions, but functions created in code can't be used elsewhere.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the number e ($e, approximately 2.718) raised to the parameter-th power. This function is significantly faster than pow() or the ^ operator.\n\n\n\n \n\n EEL2: \n\n\n\nUsed to call functions exported by extension plugins. The first parameter must be the exported function name, then its own parameters (as if the function was called directly).\n\n\n\n \n\n EEL2: \n\n\n\nCloses a file previously opened with fopen().\n\n\n\n \n\n EEL2: \n\n\n\nReturns nonzero if the file fp is at the end of file.\n\n\n\n \n\n EEL2: \n\n\n\nIf file fp is open for writing, flushes out any buffered data to disk.\n\n\n\n \n\n EEL2: \n\n\n\nPerforms a FFT on the data in the local memory buffer at the offset specified by the first parameter. The size of the FFT is specified by the second parameter, which must be 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, or 32768. The outputs are permuted, so if you plan to use them in-order, call fft_permute(buffer, size) before and fft_ipermute(buffer,size) after your in-order use. Your inputs or outputs will need to be scaled down by 1/size, if used.\n\nNote that fft()/ifft() require real / imaginary input pairs, so a 256 point FFT actually works with 512 items.\n\nNote that fft()/ifft() must NOT cross a 65,536 item boundary, so be sure to specify the offset accordingly.\n\n\n\n \n\n EEL2: \n\n\n\nPermute the input for ifft(), taking bands from in-order to the order ifft() requires. See \n\n\n\n \n\n EEL2: \n\n\n\nPermute the output of fft() to have bands in-order. See \n\n\n\n \n\n EEL2: \n\n\n\nPerforms an FFT, but takes size input samples and produces size/2 complex output pairs. Usually used along with fft_permute(size/2). Inputs/outputs will need to be scaled by 0.5/size.\n\n\n\n \n\n EEL2: \n\n\n\nReads a character from file fp, returns -1 if EOF.\n\n\n\n \n\n EEL2: \n\n\n\nReads a line from file fp into #str. Returns length of #str read.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the value rounded to the next lowest integer (floor(3.9)==3, floor(-3.1)==-4).\n\n\n\n \n\n EEL2: \n\n\n\nOpens a file \"fn\" with mode \"mode\". For read, use \"r\" or \"rb\", write \"w\" or \"wb\". Returns a positive integer on success.\n\n\n\n \n\n EEL2: \n\n\n\nFormats a string and writes it to file fp. For more information on format specifiers, see \n\n\n\n \n\n EEL2: \n\n\n\nReads from file fp into #str, up to length bytes. Returns actual length read, or negative if error.\n\n\n\n \n\n EEL2: \n\n\n\nHints the runtime that memory above the address specified may no longer be used. The runtime may, at its leisure, choose to lose the contents of memory above the address specified.\n\n\n\n \n\n EEL2: \n\n\n\nSeeks file fp, offset bytes from whence reference. Whence negative specifies start of file, positive whence specifies end of file, and zero whence specifies current file position.\n\n\n\n \n\n EEL2: \n\n\n\nRetunrs the current file position.\n\n\n\n \n\n EEL2: \n\n\n\nWrites up to len characters of #str to file fp. If len is less than 1, the full contents of #str will be written. Returns the number of bytes written to file.\n\n\n\n \n\n EEL2: \n\n\n\nQueries contextual information about the script, typically MIDI/OSC input values.\n\nReturns true if a new value has been updated.\n\nval will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).\n\nresolution=127 for 7-bit resolution, =16383 for 14-bit resolution.\n\nsectionID, and cmdID will be set to -1 if the script is not part of the action list.\n\nmode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.\n\ncontextstr may be empty or one of:\n• midi:XX[:YY] (one or two bytes hex)\n\n (flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)\n\n\n\n\n\n \n\n EEL2: \n\n\n\nThe following global variables are special and will be used by the graphics system:\n• gfx_a2 - current alpha component (0..1) used by drawing operations when writing solid colors (normally ignored but useful when creating transparent images).\n• gfx_mode - blend mode for drawing. Set mode to 0 for default options. Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx_a to negative and use gfx_mode as additive). Add 2.0 to disable source alpha for gfx_blit(). Add 4.0 to disable filtering for gfx_blit().\n• gfx_x - current graphics position X. Some drawing functions use as start position and update.\n• gfx_y - current graphics position Y. Some drawing functions use as start position and update.\n• gfx_clear - if greater than -1.0, framebuffer will be cleared to that color. the color for this one is packed RGB (0..255), i.e. red+green*256+blue*65536. The default is 0 (black).\n• gfx_dest - destination for drawing operations, -1 is main framebuffer, set to 0..1024-1 to have drawing operations go to an offscreen buffer (or loaded image).\n• gfx_texth - the (READ-ONLY) height of a line of text in the current font. Do not modify this variable.\n• gfx_ext_retina - to support hidpi/retina, callers should set to 1.0 on initialization, this value will be updated to value greater than 1.0 (such as 2.0) if retina/hidpi. On macOS gfx_w/gfx_h/etc will be doubled, but on other systems gfx_w/gfx_h will remain the same and gfx_ext_retina is a scaling hint for drawing.\n• mouse_x - current X coordinate of the mouse relative to the graphics window.\n• mouse_y - current Y coordinate of the mouse relative to the graphics window.\n• mouse_wheel - wheel position, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• mouse_hwheel - horizontal wheel positions, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• mouse_cap - a bitfield of mouse and keyboard modifier state. Note that a script must call gfx_getchar() at least once in order to get modifier state when the mouse is not captured by the window. Bitfield bits: \n\n\n\n \n\n EEL2: \n\n\n\nDraws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.\n\n\n\n \n\n EEL2: \n\n\n\nCopies from source (-1 = main framebuffer, or an image from gfx_loadimg() etc), using current opacity and copy mode (set with gfx_a, gfx_mode).\n\nIf destx/desty are not specified, gfx_x/gfx_y will be used as the destination position.\n\nscale (1.0 is unscaled) will be used only if destw/desth are not specified.\n\nrotation is an angle in radians\n\nsrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)\n\ndestx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale). \n\n\n\n \n\n EEL2: \n\n\n\nDeprecated, use gfx_blit instead.\n\n\n\n \n\n EEL2: \n\n\n\nBlurs the region of the screen between gfx_x,gfx_y and x,y, and updates gfx_x,gfx_y to x,y.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a circle, optionally filling/antialiasing. \n\n\n\n \n\n EEL2: \n\n\n\nConverts client coordinates x,y to screen coordinates.\n\n\n\n \n\n EEL2: \n\n\n\nBlits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.\n\n\n\n \n\n EEL2: \n\n\n\nCall with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh are specified, they will be filled with the undocked window position/size\n\n\n\n \n\n EEL2: \n\n\n\nDraws the character (can be a numeric ASCII code as well), to gfx_x, gfx_y, and moves gfx_x over by the size of the character.\n\n\n\n \n\n EEL2: \n\n\n\nDraws the number n with ndigits of precision to gfx_x, gfx_y, and updates gfx_x to the right side of the drawing. The text height is gfx_texth.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y so that subsequent draws will occur in a similar place.\n\n\n\nIf flags, right ,bottom passed in:\n• flags&256: ignore right/bottom, otherwise text is clipped to (gfx_x, gfx_y, right, bottom)\n\n\n\n \n\n EEL2: \n\n\n\nIf char is 0 or omitted, returns a character from the keyboard queue, or 0 if no character is available, or -1 if the graphics window is not open. If char is specified and nonzero, that character's status will be checked, and the function will return greater than 0 if it is pressed. Note that calling gfx_getchar() at least once causes mouse_cap to reflect keyboard modifiers even when the mouse is not captured.\n\n\n\nCommon values are standard ASCII, such as 'a', 'A', '=' and '1', but for many keys multi-byte values are used, including 'home', 'up', 'down', 'left', 'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'. \n\n\n\nModified and special keys can also be returned, including:\n• 65536 for query of special flags, returns: &1 (supported), &2=window has focus, &4=window is visible, &8=mouse click would hit window. 65537 queries special flags but does not do the mouse click hit testing (faster).\n• If unichar is specified, it will be set to the unicode value of the key if available (and the return value may be the unicode value or a raw key value as described above, depending). If unichar is not specified, unicode codepoints greater than 255 will be returned as 'u'<<24 + value\n\n \n\n\n\n \n\n EEL2: \n\n\n\nEnumerates any drag/dropped files. call gfx_dropfile(-1) to clear the list when finished. Returns 1 if idx is valid, 0 if idx is out of range.\n\n\n\n \n\n EEL2: \n\n\n\nReturns current font index. If a string is passed, it will receive the actual font face used by this font, if available.\n\n\n\n \n\n EEL2: \n\n\n\nRetreives the dimensions of image (representing a filename: index number) into w and h. Sets these values to 0 if an image failed loading (or if the filename index is invalid).\n\n\n\n \n\n EEL2: \n\n\n\nGets the value of the pixel at gfx_x,gfx_y into r,g,b. \n\n\n\n \n\n EEL2: \n\n\n\nFills a gradient rectangle with the color and alpha specified. drdx-dadx reflect the adjustment (per-pixel) applied for each pixel moved to the right, drdy-dady are the adjustment applied for each pixel moved toward the bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\n\n\n\n \n\n EEL2: \n\n\n\nInitializes the graphics window with title name. Suggested width and height can be specified. If window is already open, a non-empty name will re-title window, or an empty title will resize window. \n\n\n\nOnce the graphics window is open, gfx_update() should be called periodically. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a line from gfx_x,gfx_y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx_x and gfx_y to x,y.\n\n\n\n \n\n EEL2: \n\n\n\nLoad image from filename into slot 0..1024-1 specified by image. Returns the image index if success, otherwise -1 if failure. The image will be resized to the dimensions of the image file. \n\n\n\n \n\n EEL2: \n\n\n\nMeasures the drawing dimensions of a character with the current font (as set by gfx_setfont). \n\n\n\n \n\n EEL2: \n\n\n\nMeasures the drawing dimensions of a string with the current font (as set by gfx_setfont). \n\n\n\n \n\n EEL2: \n\n\n\nMultiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\n\n\n\n \n\n EEL2: \n\n\n\nFormats and draws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y accordingly (the latter only if the formatted string contains newline). For more information on format strings, see sprintf()\n\n\n\n \n\n EEL2: \n\n\n\nCloses the graphics window.\n\n\n\n \n\n EEL2: \n\n\n\nFills a rectangle at x,y, w,h pixels in dimension, filled by default. \n\n\n\n \n\n EEL2: \n\n\n\nFills a rectangle from gfx_x,gfx_y to x,y. Updates gfx_x,gfx_y to x,y. \n\n\n\n \n\n EEL2: \n\n\n\nDraws a rectangle with rounded corners. \n\n\n\n \n\n EEL2: \n\n\n\nConverts screen coordinates x,y to client coordinates.\n\n\n\n \n\n EEL2: \n\n\n\nSets gfx_r/gfx_g/gfx_b/gfx_a/gfx_mode/gfx_a2, sets gfx_dest if final parameter specified\n\n\n\n \n\n EEL2: \n\n\n\nSpecify 0 resource_id and custom_cursor_name from https://www.reaper.fm/sdk/cursors/cursors.php (e.g. 'arrow') to set the cursor. Alternatively can specify resource_id for a Windows cursor or built-in REAPER cursor.\n\n\n\n \n\n EEL2: \n\n\n\nCan select a font and optionally configure it. idx=0 for default bitmapped font, no configuration is possible for this font. idx=1..16 for a configurable font, specify fontface such as \"Arial\", sz of 8-100, and optionally specify flags, which is a multibyte character, which can include 'i' for italics, 'u' for underline, or 'b' for bold. These flags may or may not be supported depending on the font and OS. After calling gfx_setfont(), gfx_texth may be updated to reflect the new average line height.\n\n\n\n \n\n EEL2: \n\n\n\nResize image referenced by index 0..1024-1, width and height must be 0-8192. The contents of the image will be undefined after the resize.\n\n\n\n \n\n EEL2: \n\n\n\nWrites a pixel of r,g,b to gfx_x,gfx_y.\n\n\n\n \n\n EEL2: \n\n\n\nShows a popup menu at gfx_x,gfx_y. str is a list of fields separated by | characters. Each field represents a menu item.\n\nFields can start with special characters:\n\n\n\n# : grayed out\n\n! : checked\n\n> : this menu item shows a submenu\n\n< : last item in the current submenu\n\n\n\nAn empty field will appear as a separator in the menu. gfx_showmenu returns 0 if the user selected nothing from the menu, 1 if the first field is selected, etc.\n\nExample:\n\n\n\ngfx_showmenu(\"first item, followed by separator||!second item, checked|>third item which spawns a submenu|#first item in submenu, grayed out|<second and last item in submenu|fourth item in top menu\")\n\n\n\n \n\n EEL2: \n\n\n\nBlits to destination at (destx,desty), size (destw,desth). div_w and div_h should be 2..64, and table should point to a table of 2*div_w*div_h values (this table must not cross a 65536 item boundary). Each pair in the table represents a S,T coordinate in the source image, and the table is treated as a left-right, top-bottom list of texture coordinates, which will then be rendered to the destination.\n\n\n\n \n\n EEL2: \n\n\n\nDraws a filled triangle, or any convex polygon. \n\n\n\n\n\n EEL2: \n\n\n\nUpdates the graphics display, if opened\n\n\n\n \n\n EEL2: \n\n\n\nPerform an inverse FFT. For more information see fft().\n\n\n\n \n\n EEL2: \n\n\n\nPerforms an inverse FFT, but takes size/2 complex input pairs and produces size real output values. Usually used along with fft_ipermute(size/2).\n\n\n\n \n\n EEL2: \n\n\n\nReturns a fast inverse square root (1/sqrt(x)) approximation of the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the natural logarithm (base e) of the parameter. If the value is not greater than 0, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the base-10 logarithm of the parameter. If the value is not greater than 0, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nEvaluates count once, and then executes expression count, but not more than 1048576, times.\n\n\n\n \n\n EEL2: \n\n\n\nSearches for the first parameter in the second parameter, using a simplified regular expression syntax. \n\nYou can also use format specifiers to match certain types of data, and optionally put that into a variable:\n• %x, %d, %u, and %f are available for use similarly\n• %c can be used, but can't take any length modifiers\n• Use uppercase (%S, %D, etc) for lazy matching\n\n \n\nSee also sprintf() for other notes, including specifying direct variable references via {}.\n\n\n\n \n\n EEL2: \n\n\n\nCase-insensitive version of match().\n\n\n\n \n\n EEL2: \n\n\n\nReturns (by reference) the maximum value of the two parameters. Since max() returns by reference, expressions such as max(x,y) = 5 are possible.\n\n\n\n \n\n EEL2: \n\n\n\nReads values from memory starting at offset into variables specified. Slower than regular memory reads for less than a few variables, faster for more than a few. Undefined behavior if used with more than 32767 variables.\n\n\n\n \n\n EEL2: \n\n\n\nShuffles contents of buf right by 1, inserts value at buf[0], returns previous buf[len-1].\n\n\n\n \n\n EEL2: \n\n\n\nCalculates the sum of the products of values pointed to by src1 and src2. If src1 is -1, then calculates the sum of squares of src2, if -2, the sum of the absolute values of src2, if -3, calculates the sum of the values of src2. Other negative values are undefined.\n\n\n\n \n\n EEL2: \n\n\n\nWrites values to memory starting at offset from variables specified. Slower than regular memory writes for less than a few variables, faster for more than a few. Undefined behavior if used with more than 32767 variables.\n\n\n\n \n\n EEL2: \n\n\n\nCopies length items of memory from src to dest. Regions are permitted to overlap.\n\n\n\n \n\n EEL2: \n\n\n\nSets length items of memory at offset to value.\n\n\n\n \n\n EEL2: \n\n\n\nReturns (by reference) the minimum value of the two parameters. Since min() returns by reference, expressions such as min(x,y) = 5 are possible.\n\n\n\n \n\n EEL2: \n\n\n\nOutput formatted string to system-specific destination, see sprintf() for more information\n\n\n\n \n\n EEL2: \n\n\n\nReturns a pseudorandom real number between 0 and the parameter, inclusive. If the parameter is omitted or less than 1.0, 1.0 is used as a maximum instead.\n\n\n\n \n\n EEL2: \n\n\n\nAdds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n EEL2: \n\n\n\nSets action options for the script.\n\nflag&1: script will auto-terminate if re-launched while already running\n\nflag&2: if (flag&1) is set, script will re-launch after auto-terminating. otherwise, re-launch is ignored.\n\nflag&4: set script toggle state on\n\nflag&8: set script toggle state off\n\n\n\n\n\n \n\n EEL2: \n\n\n\nReturns 1.0 if the parameter is greater than 0, -1.0 if the parameter is less than 0, or 0 if the parameter is 0.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the sine of the angle specified (specified in radians -- to convert from degrees to radians, multiply by $pi/180, or 0.017453).\n\n\n\n \n\n EEL2: \n\n\n\nYields the CPU for the millisecond count specified, calling Sleep() on Windows or usleep() on other platforms.\n\n\n\n \n\n EEL2: \n\n\n\nFormats a string and stores it in #dest. Format specifiers begin with %, and may include: \n\nMany standard C printf() modifiers can be used, including:\n• %.10s = string, but only print up to 10 characters\n\n \n\nValues for format specifiers can be specified as additional parameters to sprintf, or within {} in the format specifier (such as %{varname}d, in that case a global variable is always used).\n\n\n\n \n\n EEL2: \n\n\n\nReturns the square of the parameter (similar to value*value, but only evaluating value once).\n\n\n\n \n\n EEL2: \n\n\n\nReturns the square root of the parameter. If the parameter is negative, the return value is undefined.\n\n\n\n \n\n EEL2: \n\n\n\nExchanges a value with the top of the stack, and returns a reference to the parameter (with the new value).\n\n\n\n \n\n EEL2: \n\n\n\nReturns a reference to the item on the top of the stack (if index is 0), or to the Nth item on the stack if index is greater than 0. \n\n\n\n \n\n EEL2: \n\n\n\nPops a value from the user stack into value, or into a temporary buffer if value is not specified, and returns a reference to where the stack was popped. Note that no checking is done to determine if the stack is empty, and as such stack_pop() will never fail.\n\n\n\n \n\n EEL2: \n\n\n\nPushes value onto the user stack, returns a reference to the parameter.\n\n\n\n \n\n EEL2: \n\n\n\nDeletes len characters at offset pos from #str, and returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nReturns the data at byte-offset offset of str. If offset is negative, position is relative to end of string.type defaults to signed char, but can be specified to read raw binary data in other formats (note the single quotes, these are single/multi-byte characters): \n\n\n\n \n\n EEL2: \n\n\n\nInserts srcstr into #str at offset pos. Returns #str\n\n\n\n \n\n EEL2: \n\n\n\nSets value at offset offset, type optional. offset may be negative to refer to offset relative to end of string, or between 0 and length, inclusive, and if set to length it will lengthen string. See str_getchar() for more information on types.\n\n\n\n \n\n EEL2: \n\n\n\nSets length of #str (if increasing, will be space-padded), and returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nAppends srcstr to #str, and returns #str\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nCopies the contents of srcstr to #str, and returns #str\n\n\n\n \n\n EEL2: \n\n\n\nCopies srcstr to #str, but starts reading srcstr at offset offset\n\n\n\n \n\n EEL2: \n\n\n\nPHP-style (start at offs, offs<0 means from end, ml for maxlen, ml<0 = reduce length by this amt)\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings ignoring case, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nReturns the length of the string passed as a parameter\n\n\n\n \n\n EEL2: \n\n\n\nAppends srcstr to #str, stopping after maxlen characters of srcstr. Returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings giving up after maxlen characters, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nCopies srcstr to #str, stopping after maxlen characters. Returns #str.\n\n\n\n \n\n EEL2: \n\n\n\nCompares strings giving up after maxlen characters, ignoring case, returning 0 if equal\n\n\n\n \n\n EEL2: \n\n\n\nReturns the tangent of the angle specified (specified in radians).\n\n\n\n \n\n EEL2: \n\n\n\nCloses a TCP connection created by tcp_listen() or tcp_connect().\n\n\n\n \n\n EEL2: \n\n\n\nCreate a new TCP connection to address:port. If block is specified and 0, connection will be made nonblocking. Returns TCP connection ID greater than 0 on success.\n\n\n\n \n\n EEL2: \n\n\n\nListens on port specified. Returns less than 0 if could not listen, 0 if no new connection available, or greater than 0 (as a TCP connection ID) if a new connection was made. If a connection made and #ip_out specified, it will be set to the remote IP. interface can be empty for all interfaces, otherwise an interface IP as a string.\n\n\n\n \n\n EEL2: \n\n\n\nEnds listening on port specified.\n\n\n\n \n\n EEL2: \n\n\n\nReceives data from a connection to #str. If maxlen is specified, no more than maxlen bytes will be received. If non-blocking, 0 will be returned if would block. Returns less than 0 if error.\n\n\n\n \n\n EEL2: \n\n\n\nSends a string to connection. Returns -1 on error, 0 if connection is non-blocking and would block, otherwise returns length sent. If len is specified and not less than 1, only the first len bytes of the string parameter will be sent.\n\n\n\n \n\n EEL2: \n\n\n\nSets whether a connection blocks.\n\n\n\n \n\n EEL2: \n\n\n\nSets the parameter (or a temporary buffer if omitted) to the number of seconds since January 1, 1970, and returns a reference to that value. The granularity of the value returned is 1 second.\n\n\n\n \n\n EEL2: \n\n\n\nSets the parameter (or a temporary buffer if omitted) to a system-local timestamp in seconds, and returns a reference to that value. The granularity of the value returned is system defined (but generally significantly smaller than one second).\n\n\n\n \n\n EEL2: \n\n\n\nExecutes expression until expression evaluates to zero, or until 1048576iterations occur. An alternate and more useful syntax is while (expression) ( statements ), which evaluates statements after every non-zero evaluation of expression.\n\n\n\n EEL2:Returns the absolute value of the parameter.EEL2:Returns the arc cosine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc sine of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc tangent of the value specified (return value is in radians). If the parameter is not between -1.0 and 1.0 inclusive, the return value is undefined.EEL2:Returns the arc tangent of the numerator divided by the denominator, allowing the denominator to be 0, and using their signs to produce a more meaningful result.EEL2:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.EEL2:Returns the value rounded to the next highest integer (ceil(3.1)==4, ceil(-3.9)==-3).EEL2:Multiplies each of size complex pairs in dest by the complex pairs in src. Often used for convolution.EEL2:Returns the cosine of the angle specified (specified in radians).EEL2:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.EEL2:Executes code passed in. Code can use functions, but functions created in code can't be used elsewhere.EEL2:Returns the number e ($e, approximately 2.718) raised to the parameter-th power. This function is significantly faster than pow() or the ^ operator.EEL2:Used to call functions exported by extension plugins. The first parameter must be the exported function name, then its own parameters (as if the function was called directly).EEL2:Closes a file previously opened with fopen().EEL2:Returns nonzero if the file fp is at the end of file.EEL2:If file fp is open for writing, flushes out any buffered data to disk.EEL2:Performs a FFT on the data in the local memory buffer at the offset specified by the first parameter. The size of the FFT is specified by the second parameter, which must be 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, or 32768. The outputs are permuted, so if you plan to use them in-order, call fft_permute(buffer, size) before and fft_ipermute(buffer,size) after your in-order use. Your inputs or outputs will need to be scaled down by 1/size, if used.Note that fft()/ifft() require real / imaginary input pairs, so a 256 point FFT actually works with 512 items.Note that fft()/ifft() must NOT cross a 65,536 item boundary, so be sure to specify the offset accordingly.EEL2:Permute the input for ifft(), taking bands from in-order to the order ifft() requires. See fft () for more information.EEL2:Permute the output of fft() to have bands in-order. See fft () for more information.EEL2:Performs an FFT, but takes size input samples and produces size/2 complex output pairs. Usually used along with fft_permute(size/2). Inputs/outputs will need to be scaled by 0.5/size.EEL2:Reads a character from file fp, returns -1 if EOF.EEL2:Reads a line from file fp into #str. Returns length of #str read.EEL2:Returns the value rounded to the next lowest integer (floor(3.9)==3, floor(-3.1)==-4).EEL2:Opens a file \"fn\" with mode \"mode\". For read, use \"r\" or \"rb\", write \"w\" or \"wb\". Returns a positive integer on success.EEL2:Formats a string and writes it to file fp. For more information on format specifiers, see sprintf (). Returns bytes written to file.EEL2:Reads from file fp into #str, up to length bytes. Returns actual length read, or negative if error.EEL2:Hints the runtime that memory above the address specified may no longer be used. The runtime may, at its leisure, choose to lose the contents of memory above the address specified.EEL2:Seeks file fp, offset bytes from whence reference. Whence negative specifies start of file, positive whence specifies end of file, and zero whence specifies current file position.EEL2:Retunrs the current file position.EEL2:Writes up to len characters of #str to file fp. If len is less than 1, the full contents of #str will be written. Returns the number of bytes written to file.EEL2:Queries contextual information about the script, typically MIDI/OSC input values.Returns true if a new value has been updated.val will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).resolution=127 for 7-bit resolution, =16383 for 14-bit resolution.sectionID, and cmdID will be set to -1 if the script is not part of the action list.mode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.contextstr may be empty or one of:(flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)EEL2:The following global variables are special and will be used by the graphics system:EEL2:Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.EEL2:Copies from source (-1 = main framebuffer, or an image from gfx_loadimg() etc), using current opacity and copy mode (set with gfx_a, gfx_mode).If destx/desty are not specified, gfx_x/gfx_y will be used as the destination position.scale (1.0 is unscaled) will be used only if destw/desth are not specified.rotation is an angle in radianssrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)destx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale).EEL2:Deprecated, use gfx_blit instead.EEL2:Blurs the region of the screen between gfx_x,gfx_y and x,y, and updates gfx_x,gfx_y to x,y.EEL2:Draws a circle, optionally filling/antialiasing.EEL2:Converts client coordinates x,y to screen coordinates.EEL2:Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.EEL2:Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh are specified, they will be filled with the undocked window position/sizeEEL2:Draws the character (can be a numeric ASCII code as well), to gfx_x, gfx_y, and moves gfx_x over by the size of the character.EEL2:Draws the number n with ndigits of precision to gfx_x, gfx_y, and updates gfx_x to the right side of the drawing. The text height is gfx_texth.EEL2:Draws a string at gfx_x, gfx_y, and updates gfx_x/gfx_y so that subsequent draws will occur in a similar place.If flags, right ,bottom passed in:\n\n\n\n\n\n \n\n \n\n Lua: \n\n\n\n Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n Lua: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Lua: \n\n\n\n is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context()\n\nReturns contextual information about the script, typically MIDI/OSC input values.\n\nval will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).\n\nresolution=127 for 7-bit resolution, =16383 for 14-bit resolution.\n\nsectionID, and cmdID will be set to -1 if the script is not part of the action list.\n\nmode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.\n\ncontextstr may be empty or one of:\n• midi:XX[:YY] (one or two bytes hex)\n\n (flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)\n\n\n\n\n\n \n\n Lua: \n\n\n\n The following global variables are special and will be used by the graphics system:\n• gfx.a2 - current alpha component (0..1) used by drawing operations when writing solid colors (normally ignored but useful when creating transparent images).\n• gfx.mode - blend mode for drawing. Set mode to 0 for default options. Add 1.0 for additive blend mode (if you wish to do subtractive, set gfx.a to negative and use gfx.mode as additive). Add 2.0 to disable source alpha for gfx.blit(). Add 4.0 to disable filtering for gfx.blit().\n• gfx.x - current graphics position X. Some drawing functions use as start position and update.\n• gfx.y - current graphics position Y. Some drawing functions use as start position and update.\n• gfx.clear - if greater than -1.0, framebuffer will be cleared to that color. the color for this one is packed RGB (0..255), i.e. red+green*256+blue*65536. The default is 0 (black).\n• gfx.dest - destination for drawing operations, -1 is main framebuffer, set to 0..1024-1 to have drawing operations go to an offscreen buffer (or loaded image).\n• gfx.texth - the (READ-ONLY) height of a line of text in the current font. Do not modify this variable.\n• gfx.ext_retina - to support hidpi/retina, callers should set to 1.0 on initialization, this value will be updated to value greater than 1.0 (such as 2.0) if retina/hidpi. On macOS gfx.w/gfx.h/etc will be doubled, but on other systems gfx.w/gfx.h will remain the same and gfx.ext_retina is a scaling hint for drawing.\n• gfx.mouse_x - current X coordinate of the mouse relative to the graphics window.\n• gfx.mouse_y - current Y coordinate of the mouse relative to the graphics window.\n• gfx.mouse_wheel - wheel position, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• gfx.mouse_hwheel - horizontal wheel positions, will change typically by 120 or a multiple thereof, the caller should clear the state to 0 after reading it.\n• gfx.mouse_cap - a bitfield of mouse and keyboard modifier state. Note that a script must call gfx.getchar() at least once in order to get modifier state when the mouse is not captured by the window. Bitfield bits: \n\n\n\n \n\n Lua: \n\n\n\n Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.\n\n\n\n \n\n Lua: \n\n\n\n Copies from source (-1 = main framebuffer, or an image from gfx.loadimg() etc), using current opacity and copy mode (set with gfx.a, gfx.mode).\n\nIf destx/desty are not specified, gfx.x/gfx.y will be used as the destination position.\n\nscale (1.0 is unscaled) will be used only if destw/desth are not specified.\n\nrotation is an angle in radians\n\nsrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)\n\ndestx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale). \n\n\n\n \n\n Lua: \n\n\n\n Deprecated, use gfx.blit instead.\n\n\n\n \n\n Lua: \n\n\n\n Blurs the region of the screen between gfx.x,gfx.y and x,y, and updates gfx.x,gfx.y to x,y.\n\n\n\n \n\n Lua: \n\n\n\n Draws a circle, optionally filling/antialiasing. \n\n\n\n \n\n Lua: \n\n\n\n Converts the coordinates x,y to screen coordinates, returns those values.\n\n\n\n \n\n Lua: \n\n\n\n Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.\n\n\n\n \n\n Lua: \n\n\n\n Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh specified, additional values will be returned with the undocked window position/size\n\n\n\n \n\n Lua: \n\n\n\n Draws the character (can be a numeric ASCII code as well), to gfx.x, gfx.y, and moves gfx.x over by the size of the character.\n\n\n\n \n\n Lua: \n\n\n\n Draws the number n with ndigits of precision to gfx.x, gfx.y, and updates gfx.x to the right side of the drawing. The text height is gfx.texth.\n\n\n\n \n\n Lua: \n\n\n\n Draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y so that subsequent draws will occur in a similar place.\n\n\n\nIf flags, right ,bottom passed in:\n• flags&256: ignore right/bottom, otherwise text is clipped to (gfx.x, gfx.y, right, bottom)\n\n\n\n \n\n Lua: \n\n\n\n If char is 0 or omitted, returns a character from the keyboard queue, or 0 if no character is available, or -1 if the graphics window is not open. If char is specified and nonzero, that character's status will be checked, and the function will return greater than 0 if it is pressed. Note that calling gfx.getchar() at least once causes gfx.mouse_cap to reflect keyboard modifiers even when the mouse is not captured.\n\n\n\nCommon values are standard ASCII, such as 'a', 'A', '=' and '1', but for many keys multi-byte values are used, including 'home', 'up', 'down', 'left', 'rght', 'f1'.. 'f12', 'pgup', 'pgdn', 'ins', and 'del'. \n\n\n\nModified and special keys can also be returned, including:\n• 65536 for query of special flags, returns: &1 (supported), &2=window has focus, &4=window is visible, &8=mouse click would hit window. 65537 queries special flags but does not do the mouse click hit testing (faster).\n• If unichar is specified, it will be set to the unicode value of the key if available (and the return value may be the unicode value or a raw key value as described above, depending). If unichar is not specified, unicode codepoints greater than 255 will be returned as 'u'<<24 + value\n\n \n\n\n\n \n\n Lua: \n\n\n\n Returns success,string for dropped file index idx. call gfx.dropfile(-1) to clear the list when finished.\n\n\n\n \n\n Lua: \n\n\n\n Returns current font index, and the actual font face used by this font (if available).\n\n\n\n \n\n Lua: \n\n\n\n Retreives the dimensions of an image specified by handle, returns w, h pair.\n\n\n\n \n\n Lua: \n\n\n\n Returns r,g,b values [0..1] of the pixel at (gfx.x,gfx.y)\n\n\n\n \n\n Lua: \n\n\n\n Fills a gradient rectangle with the color and alpha specified. drdx-dadx reflect the adjustment (per-pixel) applied for each pixel moved to the right, drdy-dady are the adjustment applied for each pixel moved toward the bottom. Normally drdx=adjustamount/w, drdy=adjustamount/h, etc.\n\n\n\n \n\n Lua: \n\n\n\n Initializes the graphics window with title name. Suggested width and height can be specified. If window is already open, a non-empty name will re-title window, or an empty title will resize window. \n\n\n\nOnce the graphics window is open, gfx.update() should be called periodically. \n\n\n\n \n\n Lua: \n\n\n\n Draws a line from x,y to x2,y2, and if aa is not specified or 0.5 or greater, it will be antialiased. \n\n\n\n \n\n Lua: \n\n\n\n Draws a line from gfx.x,gfx.y to x,y. If aa is 0.5 or greater, then antialiasing is used. Updates gfx.x and gfx.y to x,y.\n\n\n\n \n\n Lua: \n\n\n\n Load image from filename into slot 0..1024-1 specified by image. Returns the image index if success, otherwise -1 if failure. The image will be resized to the dimensions of the image file. \n\n\n\n \n\n Lua: \n\n\n\n Measures the drawing dimensions of a character with the current font (as set by gfx.setfont). Returns width and height of character.\n\n\n\n \n\n Lua: \n\n\n\n Measures the drawing dimensions of a string with the current font (as set by gfx.setfont). Returns width and height of string.\n\n\n\n \n\n Lua: \n\n\n\n Multiplies each pixel by mul_* and adds add_*, and updates in-place. Useful for changing brightness/contrast, or other effects.\n\n\n\n \n\n Lua: \n\n\n\n Formats and draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y accordingly (the latter only if the formatted string contains newline). For more information on format strings, see sprintf()\n\n\n\n \n\n Lua: \n\n\n\n Closes the graphics window.\n\n\n\n \n\n Lua: \n\n\n\n Fills a rectangle at x,y, w,h pixels in dimension, filled by default. \n\n\n\n \n\n Lua: \n\n\n\n Fills a rectangle from gfx.x,gfx.y to x,y. Updates gfx.x,gfx.y to x,y. \n\n\n\n \n\n Lua: \n\n\n\n Draws a rectangle with rounded corners. \n\n\n\n \n\n Lua: \n\n\n\n Converts the screen coordinates x,y to client coordinates, returns those values.\n\n\n\n \n\n Lua: \n\n\n\n Sets gfx.r/gfx.g/gfx.b/gfx.a/gfx.mode/gfx.a2, sets gfx.dest if final parameter specified\n\n\n\n \n\n Lua: \n\n\n\n Sets the mouse cursor to resource_id and/or custom_cursor_name. \n\n\n\n \n\n Lua: \n\n\n\n Can select a font and optionally configure it. idx=0 for default bitmapped font, no configuration is possible for this font. idx=1..16 for a configurable font, specify fontface such as \"Arial\", sz of 8-100, and optionally specify flags, which is a multibyte character, which can include 'i' for italics, 'u' for underline, or 'b' for bold. These flags may or may not be supported depending on the font and OS. After calling gfx.setfont(), gfx.texth may be updated to reflect the new average line height.\n\n\n\n \n\n Lua: \n\n\n\n Resize image referenced by index 0..1024-1, width and height must be 0-8192. The contents of the image will be undefined after the resize.\n\n\n\n \n\n Lua: \n\n\n\n Writes a pixel of r,g,b to gfx.x,gfx.y.\n\n\n\n \n\n Lua: \n\n\n\n Shows a popup menu at gfx.x,gfx.y. str is a list of fields separated by | characters. Each field represents a menu item.\n\nFields can start with special characters:\n\n\n\n# : grayed out\n\n! : checked\n\n> : this menu item shows a submenu\n\n< : last item in the current submenu\n\n\n\nAn empty field will appear as a separator in the menu. gfx.showmenu returns 0 if the user selected nothing from the menu, 1 if the first field is selected, etc.\n\nExample:\n\n\n\ngfx.showmenu(\"first item, followed by separator||!second item, checked|>third item which spawns a submenu|#first item in submenu, grayed out|<second and last item in submenu|fourth item in top menu\")\n\n\n\n \n\n Lua: \n\n\n\n Blits to destination at (destx,desty), size (destw,desth). div_w and div_h should be 2..64, and table should point to a table of 2*div_w*div_h values (table can be a regular table or (for less overhead) a reaper.array). Each pair in the table represents a S,T coordinate in the source image, and the table is treated as a left-right, top-bottom list of texture coordinates, which will then be rendered to the destination.\n\n\n\n \n\n Lua: \n\n\n\n Draws a filled triangle, or any convex polygon. \n\n\n\n \n\n Lua: \n\n\n\n Updates the graphics display, if opened\n\n\n\n \n\n Lua: \n\n\n\n Causes gmem_read()/gmem_write() to read EEL2/JSFX/Video shared memory segment named by parameter. Set to empty string to detach. 6.20+: returns previous shared memory segment name.\n\n\n\n \n\n Lua: \n\n\n\n Read (number) value from shared memory attached-to by gmem_attach(). index can be [0..1<<25).\n\n\n\n \n\n Lua: \n\n\n\n Write (number) value to shared memory attached-to by gmem_attach(). index can be [0..1<<25).\n\n\n\n \n\n Lua: \n\n\n\n Creates a new reaper.array object of maximum and initial size size, if specified, or from the size/values of a table/array. Both size and table/array can be specified, the size parameter will override the table/array size.\n\n\n\n \n\n Lua: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Lua: \n\n\n\n reaper.set_action_options(flag)\n\nSets action options for the script.\n\nflag&1: script will auto-terminate if re-launched while already running\n\nflag&2: if (flag&1) is set, script will re-launch after auto-terminating. otherwise, re-launch is ignored.\n\nflag&4: set script toggle state on\n\nflag&8: set script toggle state off\n\n\n\n\n\n \n\n Lua: \n\n\n\n Sets the value of zero or more items in the array. If value not specified, 0.0 is used. offset is 1-based, if size omitted then the maximum amount available will be set.\n\n\n\n \n\n Lua: \n\n\n\n Convolves complex value pairs from reaper.array, starting at 1-based srcoffs, reading/writing to 1-based destoffs. size is in normal items (so it must be even)\n\n\n\n \n\n Lua: \n\n\n\n Copies values from reaper.array or table, starting at 1-based srcoffs, writing to 1-based destoffs.\n\n\n\n \n\n Lua: \n\n\n\n Performs a forward FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled following the FFT to be in normal order.\n\n\n\n \n\n Lua: \n\n\n\n Performs a forward real->complex FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled following the FFT to be in normal order.\n\n\n\n \n\n Lua: \n\n\n\n Returns the maximum (allocated) size of the array.\n\n\n\n \n\n Lua: \n\n\n\n Performs a backwards FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled before the IFFT to be in fft-order.\n\n\n\n \n\n Lua: \n\n\n\n Performs a backwards complex->real FFT of size. size must be a power of two between 4 and 32768 inclusive. If permute is specified and true, the values will be shuffled before the IFFT to be in fft-order.\n\n\n\n \n\n Lua: \n\n\n\n Multiplies values from reaper.array, starting at 1-based srcoffs, reading/writing to 1-based destoffs.\n\n\n\n \n\n Lua: \n\n\n\n Resizes an array object to size. size must be [0..max_size].\n\n\n\n \n\n Lua: \n\n\n\n Returns a new table with values from items in the array. Offset is 1-based and if size is omitted all available values are used.\n\n\n\n Lua:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.Lua:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.Lua:is_new_value,filename,sectionID,cmdID,mode,resolution,val,contextstr = reaper.get_action_context()Returns contextual information about the script, typically MIDI/OSC input values.val will be set to a relative or absolute value depending on mode (=0: absolute mode, >0: relative modes).resolution=127 for 7-bit resolution, =16383 for 14-bit resolution.sectionID, and cmdID will be set to -1 if the script is not part of the action list.mode, resolution and val will be set to -1 if the script was not triggered via MIDI/OSC.contextstr may be empty or one of:(flags may include V=virtkey, S=shift, A=alt/option, C=control/command, W=win/control)Lua:The following global variables are special and will be used by the graphics system:Lua:Draws an arc of the circle centered at x,y, with ang1/ang2 being specified in radians.Lua:Copies from source (-1 = main framebuffer, or an image from gfx.loadimg() etc), using current opacity and copy mode (set with gfx.a, gfx.mode).If destx/desty are not specified, gfx.x/gfx.y will be used as the destination position.scale (1.0 is unscaled) will be used only if destw/desth are not specified.rotation is an angle in radianssrcx/srcy/srcw/srch specify the source rectangle (if omitted srcw/srch default to image size)destx/desty/destw/desth specify destination rectangle (if not specified destw/desth default to srcw/srch * scale).Lua:Deprecated, use gfx.blit instead.Lua:Blurs the region of the screen between gfx.x,gfx.y and x,y, and updates gfx.x,gfx.y to x,y.Lua:Draws a circle, optionally filling/antialiasing.Lua:Converts the coordinates x,y to screen coordinates, returns those values.Lua:Blits from srcimg(srcx,srcy,srcw,srch) to destination (destx,desty,destw,desth). Source texture coordinates are s/t, dsdx represents the change in s coordinate for each x pixel, dtdy represents the change in t coordinate for each y pixel, etc. dsdxdy represents the change in dsdx for each line. If usecliprect is specified and 0, then srcw/srch are ignored.Lua:Call with v=-1 to query docked state, otherwise v>=0 to set docked state. State is &1 if docked, second byte is docker index (or last docker index if undocked). If wx-wh specified, additional values will be returned with the undocked window position/sizeLua:Draws the character (can be a numeric ASCII code as well), to gfx.x, gfx.y, and moves gfx.x over by the size of the character.Lua:Draws the number n with ndigits of precision to gfx.x, gfx.y, and updates gfx.x to the right side of the drawing. The text height is gfx.texth.Lua:Draws a string at gfx.x, gfx.y, and updates gfx.x/gfx.y so that subsequent draws will occur in a similar place.If flags, right ,bottom passed in:\n\n\n\n\n\n \n\n \n\n Python: \n\n\n\n Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.\n\n\n\n \n\n Python: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n \n\n Python: \n\n\n\n Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().\n\nNote that no undo point will be automatically created when the script finishes, unless you create it explicitly.\n\n\n\n Python:Adds code to be executed when the script finishes or is ended by the user. Typically used to clean up after the user terminates defer() or runloop() code.Python:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to runloop().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly.Python:Adds code to be called back by REAPER. Used to create persistent ReaScripts that continue to run and respond to input, while the user does other tasks. Identical to defer().Note that no undo point will be automatically created when the script finishes, unless you create it explicitly."
    },
    {
        "link": "https://admiralbumblebee.com/music/2018/09/22/Reascript-Tutorial.html",
        "document": "Today we’re going to learn to write ReaScript, specifically Lua.\n\nIf you’ve never programmed in your life, I’m going to try to take you from that point to your very first script with a GUI.\n\nThis isn’t a super trivial example either! This is a useful script that lets you create sidechaining via automation items.\n\nTHIS IS A LOT OF READING!. You do not need to do it all at once. Try it in sections, take a break if you need to, and come back another time. Programming takes time to learn, and time to do. Don’t force it all on yourself at once.\n\nI’ve a video walking you through it as well. Let’s get on with it…\n• Beginner Tutorial Part 2 - Programming in Reaper\n• How to try code\n• Where to find information\n• How to interpret that page\n• Beginner Tutorial Part 3 - Writing the script\n• Put it all together\n\nBefore we start, I want to thank Justin of Cockos. Without his surprisingly timely support this entire post wouldn’t be possible.\n\nThank you to Evildragon for helping proofread, I really needed it this time. :) (there is some irony here…)\n\nLokasenna for his GUI Library, constant contributions to the REAPER community and pleasant chats.\n\nX-Raym and his fantastic website full of ReaScript resources and scripts for REAPER. He also helped me proofread and improve this article.\n\nJon @ The REAPER Blog for giving me an incredible community resource to utilize.\n\nCFillion for his amazing work on ReaPack and a variety of important REAPER projects.\n\nMPL for his demonstration of an advanced script that shows what REAPER is capable of and offers a more elegant solution to this use-case. Check out the Reaper Script Showcase to see many more of his amazing scripts. (Many of them replicate features from other DAWs that are paid add-ons, but he does it better!)\n\nThis entire post, including the code, was written using Dragon for Mac v6.\n\nI have developed a number of vocalizations that allow me to create common programming syntax, plus I have a number of snippets that I used in Visual Studio Code.\n\nI normally write my blog posts in emacs, however Dragon does not like typing words into Emacs. I have had a good deal of luck using VS code, however there are occasionally some issues\n\nIf you have ever wondered how well the speech to text software works, like Dragon, then let this be a demonstration. I have been using Dragon for nearly all of my text for the last week now and it has been incredibly accurate. I can edit the vocabulary and create custom commands that let me do nearly anything I want.\n\nI was even able to feed it a number of my blog posts to start out, and it built a vocabulary based on things that I commonly write. Thusly I could write things like REAPER, Cubase, VST or FLStudio without ever having to train the software.\n\nDue to the amount of pain that I have had in my arm and my hand this has been an incredible addition to my software arsenal. if you have ever been curious about speech to text software I can wholeheartedly recommend Dragon. It does require some set up, and you will need to spend some time adding the commands you need, but out-of-the-box it does an amazing job of voice recognition without any training or any set up.\n\nWithout Dragon, I do not think I would have been able to write this post at all, or it would have taken me literally weeks due to number of long pauses I would have to take while typing.\n\nThis entire lesson (mostly) is available on youtube as a ~39 minute produced video (not just rambling while someone fumbles around).\n\nReaScript is a generalized word that refers to miniature programs that can control REAPER. There are various computer programming languages that can be used to do this: Python, Lua and EEL.\n\nThere is also an API for C.\n\nIn this tutorial we will be using Lua to create a script that creates new automation items in the envelope lane that correspond to edits in media items. This will become more clear as I show the results of the script.\n\nDon’t fear, I will be leading you through everything as if you have no clue how to program or how to use REAPER.\n• - code is like this\n• “variable” - when I refer to a variable in the code, it will be in double quotes.\n\nI also put REAPER shortcuts . It should be clear when something is a shortcut, or if it’s code.\n\n“Sidechaining” is a a techinque people use for having the content of one track affect another. You’ll have a transient item like a kick drum, and a non-transient item like a bass that occupy the same sonic space. You want the bass to be turned down for a short period of time when the kick hits. This lets the kick be full sounding without clashing with the bass sound.\n\nREAPER has a concept called automation items. These are items that encapsulate automation so that you can:\n• Move the automation around and apply transformations to it (such as changing the shape) independently\n• “Pool” automation items. This allows you to have encapsulated automation anywhere in your project that is mirrored. If you change one of the items, all of the other items change the exact same.\n• These pooled items can be anywhere on an automation envelope. You can have pooled items on pan, volume, VST effect etc… all at the same time, and they all have the same data.\n\nThis script requires that you’ve split your audio part (using the menu item “View->Dynamic split”).\n\nWhen the item is split, you will have new items that have the start of the item right at the transient.\n\nOur script will get all of the items on the selected track then create new automation items on the selected envelope. The automation items will have matching start times to the items, and a configurable length.\n\nThis setup allows you to edit the automation items to have a custom shape to sidechain whatever you want. It also alllows you to individually shift parts, or shift all of the automation items at once.\n\nHere’s the things that you need:\n• Script: Set Lokasenna_GUI v2 library path.lua - this must be run before any of the GUI Library\n\nIn order to find the documentation for REAPER, open REAPER then goto the menu “Help->ReaScript Documentation”. Better yet, go here for better formatted documentation.\n\nYou can edit code in any editor you want like vim, emacs, Intellij, Sublime Text and…\n\nLokasenna has some fantastic extensions for VS Code that give you a bunch of snippets, highlighting and API documentation inline.\n\nJump to the GUI section to see how GUIs are done. There are a few other GUI Widget libraries, but Lokasennas is the most complete that I’m aware of. You can also find a number of examples insides your Reaper directory. (also available on github)\n\nThere is some digging you may need to do in order to understand how to use some functions, but general it’s only a cycle of two of feeding a function some garbage data to get an error message and be pointed in the right direction.\n\nIn order to be able to do this there are two things that you will need, you will need Reapack and you will need SWS.\n\nREAPER’s bare functionality is lacking sometimes. There’s a bunch of functions that can be added to REAPER that are necessary for certain scripts, or necessary for bare functionality.\n\nSWS Extensions provides a great deal of extra capability to REAPER and it acts as a library to give the programmer extra functions to use. These functions are automatically added to the ReaScript Docs.\n\nOnce it is installed you will see a new menu in REAPER named “Extensions”. If you do not see that window, then please utilize google and the REAPER forums to see what you may have done wrong.\n\nReaPack allows you to install Libraries and other people’s scripts.\n\nFollow the directions to install it.\n\nOnce it is installed you will see a menu inside “Extensions” named “ReaPack”. Click “Browse packages” to see the window above.\n\nInstalling with ReaPack is slightly tricky. You right click a package and select “Install”, but that does not install the package. You need to select the packages to install then hit “apply”.\n\nExplore the interface and see what else you can do with it.\n\nBefore we start actually writing some code let’s go over some basics of programming. I’m going to assume that you have never programmed in your life, and that you can just barely operate REAPER.\n\nThis tutorial is only written in the context of Lua for REAPER. Some of these concepts don’t apply necessarily to other languages.\n\nYou will need to read this tutorial at least twice if you are a total beginner. The concepts presented won’t make much sense until you see them in action, then you will need to go back and read about the concepts again and see them in action again.\n\nYou can try all of the examples here by going to repl.it, pasting the code and hitting the “run” button.\n\nAs the tutorial progresses, you will learn to use REAPER for this task.\n\nIf you do not understand the first time then please make sure to read the entire thing all the way through at least twice\n\nComputer software generally deals with two things: doing things to data, and dealing with events generated by outside sources like users.\n\nWhen your program encounters new data then it needs to store it somewhere, and you need a way to reference that data sometime in the future.\n\nYou will also sometimes need to create your own data that is included in the software (such as pre-defined settings for your script), and you will want to reference this data by some sort of name.\n\nThis is what variables allow you to do: store data, and then refer to it at some other point in time by a name.\n\nLet’s look at some code:\n\nIn that line we declare a variable named “a”, and it is assigned a value of one. Anywhere we use the letter “a” it will be just like using the number one. So let’s look at that more.\n\nI assume that you can guess what the value of “c” is.\n\nVariables in Lua can store any data that we want. It can be words, they can be numbers, and variables can even hold things like functions.\n\nSo when there is some data that you want to save and refer to later, then you assign it to a variable.\n\nData comes in a variety of types. This data can be numbers, strings (words), functions and other types of data that were not going to worry about right now.\n\nYou can assign any type of data to any variable in Lua, however sometimes you will need to use a specific type of data such as a number or a string.\n\nis a special type of data in Lua. It simply means, “nothing at all”. It is also read as a “false” value, which you well learn later.\n\nWe will only be working with numbers, strings and in this (explicitly at least. The only things you will need to know are how to convert between strings and numbers.)\n\nLua has a concept called tables, which is how you can store many things in a single variable.\n\nThe variable “numbers” is storing four strings.\n\nIf we want to access one of them then we use the variables name, and square brackets with the index of the value we wish to use. So “numbers[1]” will get the first thing in our table.\n\nI’m assuming that you can guess what “numbers[3]” will return, right? Be careful and look closely!\n\nWhen we want to process an entire table, item by item, then we use loops.\n\nIn Lua for REAPER your entire script will be put inside what is called a function named “main()”. This is not necessary, but it is a tidier way to work.\n\nFunctions are how you do things. A function will contain variable assignments, loops, conditionals and calls to other functions. Let’s look at what a function looks like:\n\nIn this function we assigned two variables, then assigned a third variable which was the addition of the first two variables.\n\nLua understands what belongs to the function due to the statement. Code is read more often than it is written, so we try to make this easier by indenting the things that belong to the function. As you can see, this makes it more obvious what things are “inside of the function”. Indentation is actually a complex topic(!!??), the only thing that is really important is that you are consistent with your style.\n\nIf we wanted to use this function, then we need to “call it”. When you call a function then the program jumps to that section of code and does everything inside that function block. Let’s see what that looks like:\n\nThe line with doesn’t do anything but declare the function as something that exists. If we want to use the function then we need to write .\n\nThat is not very useful though. We will want the function to interact with the outside world. It will need to take in its own data, and produce new data.\n\nTo give data to a function we use a feature called “arguments”.\n\nWe no longer need to assign A and B to variables. When we call the function with we are telling it that we want A to equal 1 and B to equal 2. Look at where we declare the function and where we call the function.\n\nWe are still missing a piece here though. If we send data to a function then it would stand to reason that we would also want to sometimes get data back from a function. There is a special word we use, . Let’s see that in action…\n\nWhen the function is called then we add “a” and “b”, assign it to “c and then we . That means that we can call the function, and immediately assign the result of the function to another variable.\n\nRemember, the line with only says ‘Here I am!’. The line is where the function is called, and there are 2 things happening:\n• Things are processed from the most inner-most (). So this means that is processed.\n• Now is called. It sees a value of 3, and it prints that.\n\nWhere did come from though? This is a function built-in to Lua that lets us print things to the screen. It’s not something that we use in ReaScripts, but while we are learning the the basic of Lua it’s perfect. You will learn REAPER’s equivalent of the print() statement later\n\nProgramming is not just about writing code, but about reading it as well.\n\nIn order to write a line that is not interpreted as code then place two hyphens in front of it.\n\nIf you want to have a comment that spans multiple lines then each line needs to have two hyphens in front of it or you can use this syntax:\n\nComments aren’t just for writing notes for yourself, or for somebody who might read your code. Comments can be used to temporarily disable parts of your code. If you have a portion of code that is no longer needed, or if you want to disable something so that you can test something, then use comments.\n\nImagine for a moment that you are making a script in REAPER that deals with moving items around. Often you will want to store the position of an item inside of a function. You may have many functions that move items around or store the position of an item.\n\nSo you may want to use a variable named “item_position”. That’s great, but if function “a()” uses “item_position” and function “b()” uses “item_position”, but the two functions need to store different values then what happens?\n\nIf you simply declare a variable in Lua, then it is visible to the entire program. If you want a variable to only be seen by the enclosing block (such as a function, conditional, loops, etc… almost anything with an ‘end’) then you need to put the word “local” in front of it.\n\nThis is a slightly tricky one. The function can see the variables “a” and “b” because they are what is called ‘global’. Any function can see them, and any function can change them.\n\nThe trick here is that even though “c” is declared inside a function, it is also able to be seen from outside the function!\n\nLet’s try to make “c” only visible to the function .\n\nThe first statement works, but the one at the end gives us a value. The word makes it so that “c” is only visible inside of the function .\n\nThis is a very important concept to understand! When in doubt, make your variable local.\n\nScope in Lua can be confusing for even experienced programmers, so don’t get discouraged if you find variables with the wrong value or you get some errors about a variable not existing. is your friend and it will guide you through the darkness.\n\nOften when programming you need to make choices, and the statement is what allows you to do that, so let’s just go ahead and try an statement:\n\ngenerates a number between one and five, then assign that value to “a”. This is another function built-in to Lua.\n\nNow we use the statement, and then compare “a” to 1. This is done using . takes the two values to the left and right of it, compares them, and returns true or false.\n\nBe careful! is for comparing things. is for assigning things. If you use in your if statement then you may be surprised with an error (thankfully Lua gives an error… other languages will let you assign things in an if statement, a frequent source of confusion)\n\nThe if statement executes the stuff inside of it if the condition is true. isn’t the only thing you can use though, there are other comparison operators…\n\nThis code will print “a” if it is less than 3. There’s a number of ways to compare things:\n• <= less than OR equal to\n• >= greater than or equal to\n\nSometimes your code will need to test two different things before it does something, so LUA has the operators and (also is available):\n\nThis code will only print “a” and print “b” if “a” is greater than 3 and “b” is less than 5. (note: repl.it always gives the same random values… so your code may never work correctly depending on the output! See if you can figure out how to make this code work by utilizing scope and print statements)\n\nOccasionally you will need to do one thing if a value is something, or do another thing if that the value is something else. This is where comes in.\n\nOther times you may need to test the value for something else. This is where you use , which can be combined with like this…:\n\nThis code should be pretty self-explanatory. Note that needs a new comparison, and does not. happens if no other comparisons are true, so it exists on its own.\n\nTry some , and statements yourself to get a feel for it.\n\nWhen programming you will frequently need to do things multiple times, or process a bunch of items one after the other in the same way. Loops are how you do this.\n\nThe statement declares a local variable, in this case named “index”. Then it executes the code inside the block.\n\nWhen it is done it goes back and increases the value of index by one, so now it’d be doing . This increases until “index” is 4, and the loop stops.\n\nWhat if we only wanted to print every other value?\n\nHere we have added a third number to our statement, “2”. This tells the for loop to increment index by two every time it loops.\n\nLua has another way of looping, but it will not be necessary for this tutorial. I will show you anyways, if this is confusing then you can ignore it for the context of this article.\n\nTables in Lua are what is called associative arrays. Each slot is two values, the key and the value.\n\nSo far we have been using keys that correspond to the “index”, or position in the table, and the value associated with that index.\n\nWhen using a for loop in Lua you can extract the key and the value using the format above. Lua will go through every single key and value pair then print the key and the value. (But it does not loop in order if we use . That is outside the context of this tutorial! It also does not matter for us.)\n\nPerhaps this example will make it more clear…\n\nYou can ignore those square brackets in the “numbers” declaration for now, that’s just a weird thing about Lua.\n\nHowever if you run this code you will see that the keys are a string and the values are a string. Anything can be a key and anything can be a value, and that is how you iterate over them.\n\nMost programmers want to write as little code as possible, and they want the code to be as correct as possible.\n\nOne way of achieving the first part, and hopefully the second part is to use somebody else’s code. people will put all their code together in a file and distribute it as what is called a “library”.\n\nWhat we will be using is called a “module” in Lua.\n\nThis lets us take somebody else’s code, imported into ours, and then use the functions from the other person’s code.\n\nWe will be using this concept to take somebody’s GUI functions so that we can draw a GUI easily without having to write all the annoying code.\n\nThis is done like this for the code that we will be writing:\n\nBut you don’t need to worry about that, because the GUI builder that we will be using automatically generates this code.\n\nYou can learn more about loading modules right here, but the concept that we use is loading files.\n\nIn Lua it is possible to load libraries from other people using the “module” concept, or we can take an entire file or a string that contains a Lua code and import that into our project.\n\nIn this tutorial we will copy and paste the code into our file.\n\nIf you are truly a beginner, I suspect you probably didn’t fully comprehend everything that I just covered, and that is totally fine.\n\nIt is now time to actually do some stuff in reaper.\n\nHow to try code\n\nThe first thing you need to do is press or just . This brings up the action list.\n\nClick the button next to ReaScript that says new, and then save the file wherever you want.\n\nThis is where you edit code. Let’s go ahead and try something simple:\n\nSave the file by pressing ctrl-s on Linux and Windows, or command-s on macOS.\n\nNow you are presented with a box saying hello to me.\n\nIf you want to get back to your code after closing that window, then go back to the actions list by pressing , searching for the name of your script, selecting your script, then clicking edit in the lower right-hand corner.\n\nIf you prefer to edit your code in another program you can do that. REAPER will pick up changes as the file is saved.\n\nLet’s look at that command we used again . How did I figure out that this command exists?\n\nIn REAPER go to the help menu and select “ReaScript Documentation”.\n\nThis will open a window in your web browser with a bunch of documentation. Alternatively you can use this nicely formatted documentation.\n\nWhen inside your browser press ctrl-f (win/lin) or cmd-f (mac) to bring up the search and enter “ShowConsoleMsg”.\n\nNow you will see the documentation for `reaper.ShowConsoleMsg() with information for C, EEL, Lua and Python.\n\nHow to interpret that page\n\nIn order to use these functions we need to understand what all this mess of text means. So let’s take the . Open the documentation and find this function by using the search feature in your browser.\n\nThe Lua line looks like this\n\nSo let’s break this down piece by piece:\n• “Lua:” - this tells us that this is the definition of the function for Lua\n• - as we discussed before in the functions section, functions can often return data to the thing that called to the function. The word integer tells us that the function returns an integer, or a number.\n• “ret 1=OK,2=CANCEL,3=ABORT,4=RETRY,5=IGNORE,6=YES,7=NO” - if you look below at the integer type argument in the function, then you can see that there are multiple types of windows we can create with different types of buttons. will return a numeric value that corresponds to which button the user pressed. Based on that information we can proceed in our code likely by using a conditional\n• - all functions for Lua are preceded by the word reaper, followed by the name of the function. I’ve seen this as a common mistake for beginners where they forget to put the word reaper in front of functions provided by reaper.\n• - once again as discussed in the functions section, function sometimes need to take data from outside. this function takes a string, another string and an integer. we do not need to provide all of these, as you can see above that we only provide a string initially.\n• - this is the message that is shown\n• - this will change the title of the window that is showing the message\n• - in the documentation we see “type 0=OK,1=OKCANCEL,2=ABORTRETRYIGNORE,3=YESNOCANCEL,4=YESNO,5=RETRYCANCEL”, so if for instance we provided the number 2, then we would get a window with aboart, retry and ignore buttons.\n\nThis may seem like a lot of information to process at first, but as you are looking for functions that do what you need it will become more obvious what the return values and arguments need to be.\n\nIf all else fails, then you just need to experiment… the documentation is not that great.\n\nAlright it’s time to write the script. Let’s just dig right in.\n\nThe first thing our script needs to do is get some information, it needs to know the track and the envelope that we wish to affect.\n\nSo what were going to start with is to get the select the track and the selected envelope.\n\nOpen up your REAPER documentation and search for “getselected”. You’ll see some options and look until you find these:\n\nWe are always going to pass a value of 0 for . That means that we wish to affect the current project and not something in the background.\n\nhas a value named “seltrackidx”. Since you can select multiple tracks in reaper, ReaScript needs to know which of the selected tracks you wish to grab, and we will always grab the first selected track, which has an index value of 0.\n\nSo in our code will look like this:\n\nNow the value “sel_track” contains data of the type . So when we want to use another function that is expecting we can pass “sel_track” to it.\n\nThe same goes for “sel_env”, which now has a stored inside of it.\n\nBefore we do anything with “sel_track” or “sel_env” we need to make sure that it exists. If we try to use a value that does not exist then we will get an error. So let’s make sure were careful about this\n\nGo ahead and test this code.\n\nSince we can identify two different things that we are doing separately, let’s put these things into functions so that we can reuse them easily.\n\nWe put all of the code for getting a track and getting an envelope into their own functions. If we need to get the track or get the function multiple times when we do not need to rewrite this code we just call the function.\n\nNote that the values of “sel_track” and “sel_env” are not local. That means that other functions in the program can see these variables. This will be important later.\n\nThis is generally not good programming practice, but for the simplicity of this tutorial and how simple the script is, we will be totally fine using these global variables.\n\nThe script that we are writing requires that the user has split the items at transients. This means the track will contain many media items that start at a transient.\n\nWe want to place an automation item on the selected envelope that corresponds to the start of every media on the selected track.\n\nIn order to do this we need to be able to get a table of all the media items, and then loop over all of those items.\n\nLet’s add a new function called “main()” that uses get_track() to get all of the media items on that track.\n\nSo here is what happens in the main function:\n• We want to select all of the items on the track, but what if the user has many tracks selected? We must make sure that no tracks are selected with .\n• Then we select our desired track with .\n• We call . This executes the action “Item: Select all items in track”. This will ensure that we have items selected if there are any.\n• Now we get the number of items that are selected with then assign that to a local variable named item_count\n• We create a for loop that goes from 0 to the size of item_count minus one. This is because in REAPER, values start at 0 (in Lua things start at 1, so we need to be explicit about what we want!).\n• Inside of the loop we create a variable named “sel_item”. This will contain a type value that comes from . Look up “GetSelectedMediaItem” in the ReaScript docs to see if you can figure out why we called it with a zero and with the i. Remember that i represents the current index in the loop, so it goes from zero up to the number of items we have minus one.\n• Now we use to get the current position of the item in the project and assign that to a local variable named “i_pos”\n• Lastly we make a console message that takes “i_pos” and combines it with “\n\n”. “\n\n” indicates that we want a new line. The “..” tells Lua that we want to combine two strings. You can think of it as an addition sign when you want to add the strings together.\n\nMake sure that you understand how works. Look at the documentation and experiment with it a little bit. You can see the values of variables on the right-hand side of the editor while the code is running, or you can use to see the values of things.\n\nNow we need to do something with that position, such as use that position to create new automation items on the envelope with the same position.\n\nWe have only added a few lines here.\n\nSo let’s look at this. This says that if we are making the first automation item, then we need to give it a pool ID of -1. This is necessary because as of this writing reaper does not let you create arbitrary pools.\n\nAutomation items that are in the same pool will all contain the same data and all change simultaneously when we change any single one of them.\n\nOnce we create this new automation item, then we need to get the pool ID from it so that all of the new automation items we create also have that pool_ID.\n\nIf were not processing the first automation item then we know we have a valid pool_ID and we can simply insert the automation item.\n\nI strongly suggest looking to the documentation and looking up:\n\nOnce you think you have a basic idea of how these work and let’s move onto the next section.\n\nIn our code so far we simply set an automation length of one. I would like to use the length of the smallest item, and later we will allow the user to input a length.\n\nSo let’s find the item when the shortest length\n\nThis function makes the scary assumption that we have selected items, which we may not have. I’m going to leave it up to you to fix that.\n\nAfter that assumption we go through all of the selected items as we have before. We store the current selected item in the loop in “sel_item”, then we use “sel_item” to get the length of the item.\n\nIf this is our first time through the loop then we assign “min_len” to the length of that item. ( …)\n\nFor each subsequent item that we evaluate, we assign “min_len” to either “i_len” or “min_len”. Math.min() takes two values and returns the lesser of the two.\n\nAs we loop through the items eventually “min_len” will be the value of the smallest item.\n\nThen we return that so that we can use that value in the place that we call the function.\n\nI strongly suggest taking a minute to use to show yourself what is happening in this function. Print out the current “i” value, the current “i_len”, the current “min_len” and perhaps the name of the media item that you are processing. You remember how to do that?\n\nUse things like “..” to put strings together and “\n\n” to create a new line.\n\nDo this any time you become confused! I actually had an issue while writing this code were I accidentally typed “min_length” instead of “min_len”. I ended up getting this cryptic error that I could not figure out until I started putting little messages to give me idea of what values were at what point.\n\nThis tends to be called “printf debugging” (due to how print is done in C). Some other languages have fancy debuggers, but with any language this is a powerful and quick way to figure out what is happening in your code. Don’t be afraid of it.\n\nPut it all together\n\nIt looks like we actually have all of our working code down. this will take the selected track, the selected envelope and make a new automation item at the start of every media item, and the length of the automation item equals the length of the smallest media item.\n\nThis time I have added some comments to the code to help make it be more clear for first-time readers.\n\nWe did add one small thing here,\n\nIf there is no “sel_track” or “sel_env” then we wanna abort our mission immediately. We from our function immediately, and no further code will be processed.\n\nIdeally we’d encapsulate this all in a class (using metatables) and pass values (and a few closures) around via functions while relying on no globals, but that would add complexity for zero benefit in this simple case. I also don’t want to make this tutorial too long :)\n\nAs your scripts become complex, you’ll google for solutions and find out about better practices, new functionality and see some fun arguments about how things should be done.\n\nOur code works if you run it and you have a track and an envelope selected. However, there is no way for the user to set the length of time that they want that automation items to be.\n\nSo let’s create a GUI that allows the user to select a track, select an envelope, set the length of the automation item and then do the process when they are ready.\n\nThe first thing you need to do is to go to ReaPack->Browse Packages. Install the following packages:\n\nNow go to the actions list using ( ). Select “Script: Set Lokasenna_GUI v2 library path.lua” and hit run.\n\nRight click in the middle of the window that pops up, this is where you can add new GUI elements to the screen.\n\nTo move a GUI widget or select a GUI widget for editing you need to hold shift and click it.\n\nBuild something like the GUI that you see above.\n\nYou will at least need these elements:\n• A textbox to get the length of the AI\n• A button to get the currently selected Track\n• A button to get the currently selected Envelope\n• A button to clear the currently selected Track\n• A button to clear the currently selected Envelope\n• A button to DO IT!\n\nWhen you’re done with your GUI go to the menu item “File->Export” and export the file to a location you are familiar with.\n\nIt really is that easy!\n\nJust play around with it and make a few rubbish attempts. It works quite nicely.\n\nThis is basically what is output from the GUI editor.\n\nSo what we need to do is insert our code into this file, and then connect the buttons to functions.\n\nSo where I have the comment that says “Insert code here”, place your current code in that location. We could keep our GUI code in a separate file and use a function called “loadfile” which lets you load a file into your current code. You can try doing this yourself, but for this tutorial we will just insert our current code into the generated GUI.\n\nThe next thing we need to do is add some code to the buttons so that they do something when you press it. Let’s look at what we need to do to the envelope button.\n\nI have done two things here:\n• Add a comma after . Every item, except the last item, needs a comma at the end. Since we’re adding a new item to the end, this is no longer the last item and it will need a comma\n• Add as the last item. This tells the button that when it is pressed, we want it to run the function. CAREFUL. You want and NOT . The latter will call the function immediately. We only want to pass the name of the function, so we leave out the parenthesis.\n\nSo go ahead and connect the buttons to your main function, to the get_track function, and you will need to create two “clear” functions. The information you need to create the “clear_envelope” and “clear_track” functions are in the next section.\n\nAt this point you can load the script, run it, and you’ll get a nice GUI… that doesn’t work at all.\n\nWhen the user presses the “Get track”, or “Get envelope” then we want the GUI to display the name of the track or envelope in the text box that we created.\n\nHere we’ve added an ‘else’ section to our code. If the sel_track exists then we want to change the GUI.\n\nThere is a trick here though. Look at this line:\n\nWhat is that ?\n\nThe function returns two values. The declaration is:\n\nWe only need the track name, but it returns . We need to deal with both values though! That’s what lets us do.\n\nsays “Forget the first return value, assign the second value to ”.\n\nThis is a powerful feature of Lua, and it can be slightly confusing sometimes. Just know that if a function has multiple return values, then you need to somehow assign all of them to a variable. If you want to ignore one, then use in that place.\n\nThe return values are processed in order. So if we had a function like that is declared as:\n\nIf we want to use any of those values, we need to process all of them. Something like this:\n• retval will not be assigned\n• beatpos will not be assigned\n• bpm will not be assigned\n\nWe can now use the variables , , , , , in our code. They were all simultaneously assigned by the return function.\n\nLua lets us return many values from a function, and we can assign these multiple return values at once. We can also ignore return values by using\n\nI want to do more than just list the envelope name in the text box. I want to do something like “track_name - envelope_name”. So first we need to get the name of the envelope.\n\nuses the trick. Look up “GetEnvelopeName” to see why we needed to do that.\n\nOnce we have the envelope name, we want the name of the track that the envelope is attached to. “GetSetMediaTrackInfo_String”s first argument is . That means we need a variable with a type of “MediaTrack”.\n\nSo I searched through the documentation until I found something that uses the envelope and returns a “MediaTrack”. does this!\n\nWe really only need the , so we use our trick to get that and ignore everything else.\n\nNow that we have the name of the track and the name of the envelope, we can set the text box to . Remember that just puts two strings together. We combine the track name with “ - “ and then the envelope name.\n\nI’m not going to tell you how to do this! The code I publish at the end will not have this either.\n\nYou need to set and to and clear the GUI textboxes.\n\nRemember to attach your and functions to the buttons too.\n\nPart of setting up the GUI was that we wanted the user to be able to set the length of the automation items that are created.\n\nWe already have the code for finding the minimum length. All we need to do is get the value from the GUI. If the GUI does not have a value then we use the minimum length code we used.\n\nOtherwise (else) we convert the “gui_len” to a number and return it to whereever the function was called.\n\nSince we have buttons that do and for us, we don’t need these in the “main()” block anymore.\n\nWhen we use this, we will want the user to be able to undo the action. So before we do anything, we put in. This tells REAPER that anything we do is going to be consolidated into a single undo stage.\n\nAfter we do all of our work we put the code . the first argument to will be what the undo shows up in REAPER’s undo history. (What’s the second argument? Find it, and figure it out, yourself!)\n\nThat code works, and there’s still some that you need to fill in yourself as I described earlier.\n\nI have also included (at least) 2 code paths that could lead to a crash. See if you can figure out where a user may do something that could crash the script. Read through the code and think to yourself “Does this variable always exist?” I tried to make this fairly easy to find for an intermediate developer. Beginners may need some time to find it.\n\nYou also need to think about what happens if a user already has some media items selected. That will mess everything up! Fix that.\n\nmpl has taken the idea of this script and removed the need to pre-split the ‘triggering’ items. His script reads the audio, figures out the location of the peaks and puts automation items on the selected envelope.\n\nIt has some parameters to tune the peak detection.\n\nMuch nicer than what we’ve created and a further example of what is possible with ReaScript.\n\nX-Raym has a fantastic series on learning more about ReaScript.\n\nAdam T Croft has some excellent content about learning ReaScript.\n\nMore LUA language resources (don’t bother reading the official docs, they are poorly written.)\n\nThat sure ramped up quickly didn’t it. That is kinda how programming works! You start with something small and then you slowly start building on it. Before you know it you have this giant piece of code that spans thousands of lines long and you don’t even realize that you did it.\n\nDon’t be discouraged buy how daunting a project may seem, just start with the smallest thing you can think of and slowly build up from there.\n\nIt is quite a bit like music, where you need to just put down one small part and then build on it by adding more parts, and more parts, and more parts. Eventually you go back and you start to remove some things, refine some things and potentially clean up your project to make everything look nice.\n\nIf you are a musician, then you can be a programmer. You basically already do the exact same thing anyway!\n\nThis post took 28 hours to screencast, debug, write and edit. If you appreciate the information presented then please consider joining patreon or paying me for my time spent bringing you quality content!"
    },
    {
        "link": "https://forums.cockos.com/showthread.php?t=201414",
        "document": ""
    },
    {
        "link": "https://github.com/ReaTeam/ReaScripts/blob/master/MIDI%20Editor/js_Mouse%20editing%20-%20Slice%20notes.lua",
        "document": ""
    }
]