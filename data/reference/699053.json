[
    {
        "link": "https://en.cppreference.com/w/cpp/language/dynamic_cast",
        "document": "Safely converts pointers and references to classes up, down, and sideways along the inheritance hierarchy.\n\nFor the convenience of description, “expression or the result is a reference to ” means that “it is a glvalue of type ”, which follows the convention of (since C++11).\n\nOnly the following conversions can be done with dynamic_cast, except when such conversions would cast away constness (or volatility).\n\nIf the type of is exactly or a less cv-qualified version of , the result is the value of with type . In other words, can be used to add constness. An implicit conversion and can perform this conversion as well.\n\nIf is “reference to (possibly cv-qualified) ” and the type of is “(possibly cv-qualified) ” such that is a base class of , the result is the unique subobject of the object referred to by . In other words, can be used to upcast references, from derived to base. An implicit conversion and can perform this conversion as well.\n\nOtherwise a runtime check is applied to see if the object pointed/referred to by can be converted to the type , pointed or referred to by :\n\nIf, in the most derived object pointed/referred to by , points/refers to a public base class subobject of a object, and if only one object of type is derived from the subobject pointed/referred to by , the result points/refers to that object. In other words, can be used to downcast pointers/references, from base to derived.\n\nOtherwise, if points/refers to a public base class subobject of the most derived object, and the type of the most derived object has an unambiguous and public base class of type , the result points/refers to the subobject of the most derived object. In other words, can be used to crosscast (or side-cast) pointers/references, between two types derived from the same base.\n\nWhen dynamic_cast is used in a constructor or a destructor (directly or indirectly), and expression refers to the object that's currently under construction/destruction, the object is considered to be the most derived object. If target-type is not a pointer or reference to the constructor's/destructor's own class or one of its bases, the behavior is undefined.\n\nSimilar to other cast expressions, the result is:\n\nA downcast can also be performed with static_cast, which avoids the cost of the runtime check, but it is only safe if the program can guarantee (through some other logic) that the object pointed to by expression is definitely .\n\nSome forms of dynamic_cast rely on run-time type identification (RTTI), that is, information about each polymorphic class in the compiled program. Compilers typically have options to disable the inclusion of this information.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://stackoverflow.com/questions/4644753/c-dynamic-cast-polymorphic-requirement-and-downcasting",
        "document": "In order for dynamic_cast to work the object needs to be polymorphic. The reason for this is that dynamic_cast needs somewhere to store the type information that is will use to perform the cast, and it does this by storing the information alongside the vtable for the class. In order for there to be a vtable you need to make at least one of your methods virtual.\n\nThe easiest way around this is to flag the base class destructor as virtual.\n\nUpcasting (ie derived to base) doesn't needs a cast as the compiler is able to check that the cast would work at compile time. However, the same isn't true when downcasting."
    },
    {
        "link": "https://boost.org/doc/libs/1_75_0/doc/html/conversion/polymorphic_casts.html",
        "document": "...one of the most highly regarded and expertly designed C++ library projects in the world. — Herb Sutter and Andrei Alexandrescu , C++ Coding Standards\n\nPointers to polymorphic objects (objects of classes which define at least one virtual function) are sometimes downcast or crosscast. Downcasting means casting from a base class to a derived class. Crosscasting means casting across an inheritance hierarchy diagram, such as from one base to the other in a diagram hierarchy.\n\nSuch casts can be done with old-style casts, but this approach is never to be recommended. Old-style casts are sorely lacking in type safety, suffer poor readability, and are difficult to locate with search tools.\n\nThe C++ built-in can be used for efficiently downcasting pointers to polymorphic objects, but provides no error detection for the case where the pointer being cast actually points to the wrong derived class. The template retains the efficiency of for non-debug compilations, but for debug compilations adds safety via an that a succeeds. A should be used for downcasts that you are certain should succeed. Error checking is only performed in translation units where is not defined, via where is the source pointer. This approach ensures that not only is a non-zero pointer returned, but also that it is correct in the presence of multiple inheritance. Attempts to crosscast using will fail to compile. Because uses , it violates the One Definition Rule (ODR) if is inconsistently defined across translation units. See ISO Std 3.2\n\nThe C++ built-in can be used for downcasts and crosscasts of pointers to polymorphic objects, but error notification in the form of a returned value of 0 is inconvenient to test, or worse yet, easy to forget to test. The throwing form of , which works on references, can be used on pointers through the ugly expression , which causes undefined behavior if is . The template performs a on a pointer, and throws an exception if the returns 0. For crosscasts, or when the success of a cast can only be known at runtime, or when efficiency is not important, is preferred. The C++ built-in must be used to cast references rather than pointers. It is also the only cast that can be used to check whether a given interface is supported; in that case a return of 0 isn't an error condition.\n\nWhile and work with built-in pointer types only, and are more generic versions with support for any pointer type for which the following expressions would be valid: This includes C++ built-in pointers, , , , etc."
    },
    {
        "link": "https://stackoverflow.com/questions/63520261/how-to-properly-use-c-core-guidelines-c-146-use-dynamic-cast-where-class-hi",
        "document": "The C++ Core Guidelines recommends using when \"class hierarchy navigation is unavoidable.\" This triggers clang-tidy to throw the following error: Do not use static_cast to downcast from a base to a derived class; use dynamic_cast instead [cppcoreguidelines-pro-type-static-cast-downcast] .\n\nThe guidelines go on to say:\n\nI have always just used an named nested in my base class, and performed a based on its kind. Reading C++ Core Guidelines, \"...Even so, in our experience such \"I know what I'm doing\" situations are still a known bug source.\" suggests that I should not be doing this. Often, I don't have any functions so RTTI is not present to use (e.g. I will get ). I can always add a function, but that sounds silly. The guideline also says to benchmark before considering using the discriminant approach that I use with .\n\nI am new to benchmarking, so I don't really know what I am doing. I took care to make sure that and discriminant versions have the same memory layout and tried my best to prevent optimizations. I went with optimization level since anything higher didn't seem representative. stands for discriminated or tagged. stands for Here are my results:\n\nSo, my questions are: How should I cast from a base to a derived type when (1) I know the derived type because I checked it before entering the function and (2) when I do not know the derived type yet. Additionally, (3) Should I even be worried about this guideline, or should I disable the warning? Performance matters here, but sometimes it does not. What should I be using?\n\nUsing seems to be the correct answer for downcasting. However, you still need to know what you are downcasting to and have a function. In many cases, you do not know without a discriminate such as or what the derived class is. (4) In the case where I already have to check what the of object I am looking at, should I still be using ? Is this not checking the same thing twice? (5) Is there a reasonable way to do this without a ?\n\nNot always will I need to cast to an . For example, I could have a function that prints out any . It only need to cast it to to get the and . To get the symbol of the operator (e.g. '-' or '+' ...) it can switch on the . I don't see how will help me here and I also have no virtual functions to use on.\n\nI have posted an answer making , this seems to be a good solution in general. However, I am now carrying around 8 bytes for a instead of a byte for a tag. Object instantiated from es derived from will far exceed any other object types. (6) Is this a good time to skip the or should I prefer the safety of ?"
    },
    {
        "link": "https://ibm.com/docs/SSLTBW_2.4.0/com.ibm.zos.v2r4.cbclx01/keyword_dynamic_cast.htm",
        "document": "With the right angle bracket feature, you may specify a as in the operator with the token in place of two consecutive tokens. For details, see Class templates (C++ only).\n\nThe expression converts the expression to type . Type must be a pointer or reference to a complete class type or a pointer to . expression:\n• If is a pointer type, must be a (prvalue) rvalue, and is a (prvalue) rvalue of type .\n• If is an lvalue reference type, must be an lvalue, and is an lvalue of the type that is referred by .\n• If is an rvalue reference type, is an xvalue of the type that is referred by . The following rules apply to theexpression: If is a pointer and the operator fails, the operator returns a null pointer of type . If is a reference and the operator fails, the operator throws the exception . You can find this class in the standard library header .\n\nis a void pointer, then returns the starting address of the object pointed to by . The following example demonstrates this: #include <iostream> using namespace std; struct A { virtual ~A() { }; }; struct B : A { }; int main() { B bobj; A* ap = &bobj; void * vp = dynamic_cast<void *>(ap); cout << \"Address of vp : \" << vp << endl; cout << \"Address of bobj: \" << &bobj << endl; } The output of this example is similar to the following result. Both and refer to the same address: Ifis a void pointer, thenreturns the starting address of the object pointed to by. The following example demonstrates this:The output of this example is similar to the following result. Bothandrefer to the same address:\n\nThe primary purpose for the operator is to perform type-safe downcasts. A downcast is the conversion of a pointer or reference to a class to a pointer or reference to a class , where class is a base class of . The problem with downcasts is that a pointer of type might point to an object that is not a base class subobject of type that belongs to an object of type or a class derived from B. The operator ensures that if you convert a pointer to class to a pointer to class , the object of type A pointed to by the former belongs to an object of type or a class derived from as a base class subobject.\n\noperator: #include <iostream> using namespace std; struct A { virtual void f() { cout << \"Class A\" << endl; } }; struct B : A { virtual void f() { cout << \"Class B\" << endl; } }; struct C : A { virtual void f() { cout << \"Class C\" << endl; } }; void f(A* arg) { B* bp = dynamic_cast<B*>(arg); C* cp = dynamic_cast<C*>(arg); if (bp) bp->f(); else if (cp) cp->f(); else arg->f(); }; int main() { A aobj; C cobj; A* ap = &cobj; A* ap2 = &aobj; f(ap); f(ap2); } See the output of the above example: The function determines whether the pointer points to an object of type , , or . The function does this by trying to convert to a pointer of type , then to a pointer of type , with the operator. If the operator succeeds, it returns a pointer that points to the object denoted by . If fails, it returns . The following example demonstrates the use of theoperator:See the output of the above example:The functiondetermines whether the pointerpoints to an object of type, or. The function does this by trying to convertto a pointer of type, then to a pointer of type, with theoperator. If theoperator succeeds, it returns a pointer that points to the object denoted by. Iffails, it returns\n\nYou may perform downcasts with the operator only on polymorphic classes. In the above example, all the classes are polymorphic because class has a virtual function. The operator uses the runtime type information generated from polymorphic classes."
    },
    {
        "link": "https://geeksforgeeks.org/stdmin-in-cpp",
        "document": "The std::min() is used to find the minimum element among the given elements. It is the built-in function of C++ STL defined inside <algorithm> header file.\n\nIn this article, we will learn how to use std::min() function in C++.\n\nThe std::min() can be used in three different ways to:\n\nWe can use std::min() function to find the smaller elements between the two elements. It uses < operator for comparison.\n• None Returns the smaller of the two values.\n• None If both are equal, returns the first value.\n\nFind the Minimum Among the Multiple Values\n\nThe std::min() function can also find the minimum value between more than two values. To achieve this, we have to pass the values in an initializer list, enclosed in and separated by commas. It uses < operator with to compare all the values pairwise.\n• None Returns the Smallest value among the given lists.\n• None If all are equal, return the first value.\n\nTime Complexity: O(n), where n is the number of elements. \n\nAuxiliary Space: O(1)\n\nThe std::min() function also supports the use of custom comparator function to change the way of comparison. It is by default set to find the minimum element but we can also change it to perform any other desired comparison. It is especially useful to compare values of user defined data type.\n\nwhere, comp is the comparator function, lambda expression or even functors. This comparator function should follow these rules:\n• None Return value should be of bool or any bool convertible type.\n• None Should take two arguments.\n• None Should not modify the arguments.\n\nIt returns true if a is smaller than b. False otherwise."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/algorithm/min",
        "document": "Returns the smaller of the given values.\n\nReturns the smaller of and .\n\nUses to compare the values.\n\nUse the comparison function to compare the values.\n\nReturns the smallest of the values in initializer list .\n\nUses to compare the values.\n\nUse the comparison function to compare the values.\n\ninitializer list with the values to compare comparison function object (i.e. an object that satisfies the requirements of ) which returns if is less than .\n\n The signature of the comparison function should be equivalent to the following: While the signature does not need to have const&, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) and regardless of value category (thus, Type1& is not allowed, nor is Type1 unless for a move is equivalent to a copy(since C++11)).\n\n The types Type1 and Type2 must be such that an object of type T can be implicitly converted to both of them.\n\nThe smaller of and . If the values are equivalent, returns .\n\nThe smallest value in . If several values are equivalent to the smallest, returns the leftmost such value.\n\nExactly one comparison using .\n\nExactly one application of the comparison function .\n\nExactly applications of the comparison function .\n\nCapturing the result of by reference produces a dangling reference if one of the parameters is a temporary and that parameter is returned:\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://stackoverflow.com/questions/3437404/min-and-max-in-c",
        "document": "@David Titarenco nailed it here, but let me at least clean it up a bit to make it look nice, and show both and together to make copying and pasting from here easier. :)\n\nUpdate 25 Apr. 2020: I've also added a Section 3 to show how this would be done with C++ templates too, as a valuable comparison for those learning both C and C++, or transitioning from one to the other. I've done my best to be thorough and factual and correct to make this answer a canonical reference I can come back to again and again, and I hope you find it as useful as I do.\n\n1. The old C macro way:\n\nThis technique is commonly used, well-respected by those who know how to use it properly, the \"de facto\" way of doing things, and fine to use if used properly, but buggy (think: double-evaluation side effect) if you ever pass expressions including variable assignment in to compare:\n\n2. The new and improved gcc and clang \"statement expression\" way:\n\nThis technique avoids the above \"double-evaluation\" side effects and bugs, and is therefore considered the superior, safer, and \"more modern\" GCC C way to do this. Expect it to work with both the gcc and clang compilers, since clang is, by design, gcc-compatible (see the clang note at the bottom of this answer).\n\nBUT: DO watch out for \"variable shadowing\" effects still, as statement expressions are apparently inlined and therefore do NOT have their own local variable scope!\n\nNote that in gcc statement expressions, the last expression in the code block is what is \"returned\" from the expression, as though it was returned from a function. GCC's documentation says it this way:\n\n3. [C++ only] The C++ template way:\n\nC++ Note: if using C++, templates are probably recommended for this type of construct instead, but I personally dislike templates and would probably use one of the above constructs in C++ anyway, as I frequently use and prefer C styles in embedded C++ as well.\n\nI've been doing a ton of C++ the past few months, and the pressure to prefer templates over macros, where able, in the C++ community is quite strong. As a result, I've been getting better at using templates, and want to put in the C++ template versions here for completeness and to make this a more canonical and thorough answer.\n\nHere's what basic function template versions of and might look like in C++:\n\nDo additional reading about C++ templates here: Wikipedia: Template (C++).\n\nHowever, both and are already part of the C++ standard library, in the header ( ). In the C++ standard library they are defined slightly differently than I have them above. The default prototypes for and , for instance, in C++14, looking at their prototypes in the cplusplus.com links just above, are:\n\nNote that the keyword is an alias to (so their usage is identical whether you say or ), since it was later acknowledged after the invention of C++ templates, that the template type might be a regular type ( , , etc.) instead of only a class type.\n\nHere you can see that both of the input types, as well as the return type, are , which means \"constant reference to type \". This means the input parameters and return value are passed by reference instead of passed by value. This is like passing by pointers, and is more efficient for large types, such as class objects. The part of the function modifies the function itself and indicates that the function must be capable of being evaluated at compile-time (at least if provided input parameters), but if it cannot be evaluated at compile-time, then it defaults back to a run-time evaluation, like any other normal function.\n\nThe compile-time aspect of a C++ function makes it kind-of C-macro-like, in that if compile-time evaluation is possible for a function, it will be done at compile-time, same as a or macro substitution could possibly be fully evaluated at compile-time in C or C++ too. For additional references for this C++ template info, see below.\n\n4. [C++ only] C++\n\nIf using C++, I'd like to add that the built-in function in the header file has a variety of forms. See the \"Possible implementation\" section on the documentation page at the cppreference.com community wiki (https://en.cppreference.com/w/cpp/algorithm/max) for 4 possible implementations for the 4 forms of .\n\n...but if you'd like to compare many numbers at once, you can use the 4th form, which accepts a , like this:\n• MIN and MAX in C\n• *****Wikipedia: Template (C++) <-- GREAT additional info about C++ templates!\n• (My own question & answer): Why is `constexpr` part of the C++14 template prototype for `std::max()`?\n• What's the difference between constexpr and const?\n• [my answer] Rounding integer division (instead of truncating) - I also use macros, gcc/clang statement expressions, and C++ templates here."
    },
    {
        "link": "https://quora.com/In-C-the-max-and-min-function-only-allow-two-numbers-so-how-do-you-find-the-max-of-four",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://educative.io/courses/cpp-standard-library-including-cpp-14-and-cpp-17/the-min-max-and-minmax-functions",
        "document": "The many variations of the , , and functions apply to values and initializer lists. These functions need the header . Nearly the same holds for the functions , and . You can apply them to arbitrary values. These three functions are defined in the header .\n\nThe functions std::min, std::max and std::minmax, defined in the header , act on values and initialiser lists and give you the requested value back as result. In the case of , you get an . The first element of the pair is the minimum, the second is the maximum of the values. By default, the less operator ( ) is used, but you can specify your comparison operator. This function needs two arguments and returns a boolean. Functions that either return true or false are called predicates."
    },
    {
        "link": "https://stackoverflow.com/questions/622659/what-are-the-good-and-bad-points-of-c-templates",
        "document": "I've been talking with friends and some completely agree that templates in C++ should be used, others disagree entirely.\n\nSome of the good things are:\n• They are more safe to use (type safety).\n• They are a good way of doing generalizations for APIs.\n\nWhat other good things can you tell me about C++ templates?\n\nWhat bad things can you tell me about C++ templates?\n\nEdit: One of the reasons I'm asking this is that I am studying for an exam and at the moment I am covering the topic of C++ templates. So I am trying to understand a bit more on them."
    },
    {
        "link": "https://medium.com/@threehappyer/c-performance-optimization-avoiding-common-pitfalls-and-best-practices-guide-81eee8e51467",
        "document": "C++ Performance Optimization: Avoiding Common Pitfalls and Best Practices Guide\n\n1. Preface\n\nIn modern C++ programming practices, performance optimization is a crucial area. As the C++ language continues to evolve, it provides developers with an increasing array of tools and features to better control program performance. However, these powerful features also bring additional complexity, making performance optimization a task that requires careful consideration. While pursuing code efficiency, developers must be vigilant against traps that may lead to performance degradation.\n\nThis article will delve into some common issues that C++ engineers may encounter while performing performance optimizations and provide corresponding solutions. We will start with the problem of abusing `std::shared_ptr` and discuss how to use smart pointers correctly to reduce performance overhead. Next, we will discuss the performance costs of type-erasure tools `std::function` and `std::any`, and how to use them only when necessary. The article will also cover improper use of `std::optional` and `std::string_view`, pitfalls of `std::async`, and misuse of `std::move`, among other issues.\n\nAdditionally, we will discuss the impact of hidden copies and destruction on performance, the performance overhead of virtual functions, unnecessary copying caused by structured bindings, and the importance of tail recursion optimization. New features introduced in C++20, such as concepts and constraints, coroutines, `std::span`, and modules, will also be examined to ensure they are used appropriately and do not become a burden on performance.\n\nThrough this article, we hope to help C++ developers better understand and address the challenges in performance optimization, thereby writing code that is both efficient and robust.\n\nProblem Description:\n\n`std::shared_ptr` provides a convenient reference counting mechanism, but its construction, copying, and destruction all involve atomic operations, which can be costly in terms of performance.\n\nSolution:\n\n- Prefer `std::unique_ptr` whenever possible, and use `std::shared_ptr` only when shared ownership is truly needed.\n\n- Use `std::make_shared` to construct `std::shared_ptr` instances to reduce the number of memory allocations.\n\nProblem Description:\n\n`std::function` and `std::any` provide flexible type-erasure capabilities, but they also come with performance costs.\n\nSolution:\n\n- Use `std::function` and `std::any` only when you need to store functions or objects of uncertain types.\n\n- Consider using templates and static polymorphism as an alternative to `std::function`.\n\nProblem Description:\n\n`std::optional` can lead to performance issues, especially when the contained type has significant construction, copying, or moving costs.\n\nSolution:\n\n- Use `std::optional` only when you need to represent an optional value.\n\n- Consider returning an empty container or a special value to represent a “no value” situation.\n\nProblem Description:\n\n`std::string_view` does not own the string it refers to; if the original string is released or modified, `std::string_view` may refer to invalid memory.\n\nSolution:\n\n- Ensure the lifetime of `std::string_view` does not exceed that of the string it references.\n\n- Be particularly mindful of ownership and lifetime issues when using `std::string_view`.\n\nProblem Description:\n\n`std::async` may lead to unexpected synchronous calls; if the returned `std::future` object is not saved, its destructor will wait for the asynchronous operation to complete, causing the code to execute synchronously.\n\nSolution:\n\n- Save the `std::future` object returned by `std::async` to ensure asynchronous execution.\n\nProblem Description:\n\nIn some cases, misusing `std::move` is not only unhelpful but may also lead to performance degradation. Particularly in scenarios where (Named Return Value Optimization) NRVO might be triggered, using `std::move` can result in additional copy or move operations.\n\nSolution:\n\n- Use `std::move` only when you need to transfer ownership.\n\n- Avoid using `std::move` when returning local objects.\n\nProblem Description:\n\nObject copying in C++ can lead to performance issues, especially in the following scenarios:\n\n- Constructors not using initializer lists or not using `std::move`.\n\n- Range-based for loops not using references.\n\n- Lambda expressions capturing by value without using `std::move` or capturing by reference.\n\n- Implicit type conversions leading to unnecessary copies.\n\nSolution:\n\n- Use initializer lists and `std::move` to avoid unnecessary copies.\n\n- Use references in range-based for loops.\n\n- Use reference capture or `std::move` in lambda expressions.\n\nProblem Description:\n\nDestruction of complex types can be very time-consuming. If an object’s destructor takes a long time to execute, it can inadvertently add to the function’s execution time.\n\nSolution:\n\n- Avoid creating and destroying complex objects on the hot path.\n\n- Use object pools to manage the lifecycle of complex objects.\n\nProblem Description:\n\nVirtual functions provide the ability for runtime polymorphism, but they come with additional performance overhead:\n\n- Extra addressing operations: the specific function address needs to be found through the virtual function table.\n\n- Disrupting the CPU pipeline: virtual function calls are indirect calls, which require branch prediction.\n\n- Hindering compiler inlining: in most cases, virtual functions cannot be inlined.\n\nSolution:\n\n- When polymorphism is not a necessity, consider using non-virtual member functions.\n\n- Use templates and static polymorphism (such as CRTP) to replace runtime polymorphism.\n\nProblem Description:\n\nC++17 introduced structured bindings, which allow you to conveniently unpack tuples or structures. However, if not careful, structured bindings can lead to unnecessary object copying.\n\nSolution:\n\n- Use references to avoid copying, for example, `auto& [x, y] = my_pair;`.\n\nProblem Description:\n\nTail recursion optimization can reduce the stack space usage of recursive functions, but hidden operations in C++ (such as destruction) may hinder this optimization.\n\nSolution:\n\n- Use trivially destructible objects, such as `std::string_view`, to help the compiler implement tail recursion optimization.\n\nProblem Description:\n\nC++20 introduced concepts and constraints, which provide a more powerful way to specify template parameter requirements. However, overly complex concepts and constraints can increase compilation time and make error messages difficult to understand.\n\nSolution:\n\n- Use concepts and constraints only when you need to clearly express interface requirements.\n\n- Avoid creating overly complex concepts; keep them simple and clear.\n\nProblem Description:\n\nC++20 introduced coroutines, which are a powerful tool for asynchronous programming. However, improper use of coroutines can lead to performance issues, such as excessive coroutine switching causing performance degradation.\n\nSolution:\n\n- Use coroutines in I/O-intensive or asynchronous operation scenarios.\n\n- Avoid frequent starting and suspending of coroutines in performance-critical code paths.\n\nProblem Description:\n\n`std::span` is a lightweight container view introduced in C++20, providing access to a contiguous region of an array or container. However, if the original data is released or modified, `std::span` may refer to invalid memory.\n\nSolution:\n\n- Ensure the lifetime of `std::span` does not exceed that of the data it references.\n\n- Be particularly mindful of ownership and lifetime issues when using `std::span`.\n\nProblem Description:\n\nC++20 introduced modules, intended to replace the traditional header and source file model, improving compilation efficiency. However, improper module partitioning can lead to increased compilation time, especially when there are complex dependencies between modules.\n\nSolution:\n\n- Reasonably partition modules to avoid over-segmentation.\n\n- Manage dependencies between modules well to reduce unnecessary imports.\n\n17. Developing any platform from Scratch with Codia AI Code\n\nTo integrate Codia AI into your Figma to any platform such as frontend, mobile, and Mac development process, follow these instructions:\n\nOpen the link: Codia AI Figma to code: HTML, CSS, React, Vue, iOS, Android, Flutter, ReactNative, Tailwind, Web, App\n\n- Install the Codia AI Plugin: Search for and install the Codia AI Figma to Flutter plugin from the Figma plugin store.\n\n- Prepare Your Figma Design: Arrange your Figma design with clearly named layers and components to ensure the best code generation results.\n\n- Convert with Codia AI: Select your design or component in Figma and use Codia AI to instantly"
    },
    {
        "link": "https://lefticus.gitbooks.io/cpp-best-practices/content/08-Considering_Performance.html",
        "document": "This applies to templates as well:\n\nThis is a proactive approach to reduce compilation time and rebuilding dependencies.\n\nNote: forward declaration does prevent more inlining and optimizations. It's recommended to use Link Time Optimization or Link Time Code Generation for release builds.\n\nTemplates are not free to instantiate. Instantiating many templates, or templates with more code than necessary increases compiled code size and build time.\n\nFor more examples see this article.\n\nRecursive template instantiations can result in a significant load on the compiler and more difficult to understand code.\n\nConsider using variadic expansions and folds when possible instead.\n\nThe tool Templight can be used to analyze the build time of your project. It takes some effort to get built, but once you do, it's a drop in replacement for clang++.\n\nAfter you build using Templight, you will need to analyze the results. The templight-tools project provides various methods. (Author's Note: I suggest using the callgrind converter and visualizing the results with kcachegrind).\n\nThe compiler has to do something with each include directive it sees. Even if it stops as soon as it sees the include guard, it still had to open the file and begin processing it.\n\ninclude-what-you-use is a tool that can help you identify which headers you need.\n\nReduce the load on the preprocessor\n\nThis is a general form of \"Firewall Frequently Changing Header Files\" and \"Don't Unnecessarily Include Headers.\" Tools like BOOST_PP can be very helpful, but they also put a huge burden on the preprocessor.\n\nThe usage of precompiled headers can considerably reduce the compile time in large projects. Selected headers are compiled to an intermediate form (PCH files) that can be faster processed by the compiler. It is recommended to define only frequently used header that changes rarely as precompiled header (e.g. system and library headers) to achieve the compile time reduction. But you have to keep in mind, that using precompiled headers has several disadvantages:\n• The usage of precompiled header is not portable.\n• The generated PCH files can be quite large.\n• It can break your header dependencies. Because of the precompiled headers, every file has the possibility to include every header that is marked as a precompiled header. In result it can happen, that the build fails if you disable the precompiled headers. This can be an issue if you ship something like a library. Because of this it is highly recommend to build once with precompiled header enabled and a second time without them.\n\nPrecompiled headers is supported by the most common compiler, like GCC, Clang and Visual Studio. Tools like cotire (a plugin for cmake) can help you to add precompiled headers to your build system.\n\nThese are not meant to supersede good design\n\nSee this YouTube video for more details.\n\nIf on Linux, consider using the gold linker for GCC.\n\nThere's no real way to know where your bottlenecks are without analyzing the code.\n\nThe cleaner, simpler, and easier to read the code is, the better chance the compiler has at implementing it well.\n\nInitializer lists are significantly more efficient; reducing object copies and resizing of containers.\n\nThis sort of code prevents the compiler from performing a move operation...\n\nMove operations are one of the most touted features of C++11. They allow the compiler to avoid extra copies by moving temporary objects instead of copying them in certain cases.\n\nCertain coding choices we make (such as declaring our own destructor or assignment operator or copy constructor) prevents the compiler from generating a move constructor.\n\nwould suffice. However, MSVC2013 doesn't seem to like this code yet.\n\nobjects are much more expensive to copy than you'd think they would be. This is because the reference count must be atomic and thread-safe. So this comment just re-enforces the note above: avoid temporaries and too many copies of objects. Just because we are using a pImpl it does not mean our copies are free.\n\nReduce Copies and Reassignments as Much as Possible\n\nFor more simple cases, the ternary operator can be used:\n\nMore complex cases can be facilitated with an immediately-invoked lambda.\n\nExceptions which are thrown and captured internally during normal processing slow down the application execution. They also destroy the user experience from within a debugger, as debuggers monitor and report on each exception event. It is best to just avoid internal exception processing when possible.\n\nWe already know that we should not be using raw memory access, so we are using and instead, right? Heap allocations are much more expensive than stack allocations, but sometimes we have to use them. To make matters worse, creating a actually requires 2 heap allocations.\n\nHowever, the function reduces this down to just one.\n\nIf possible use instead of . The does not need to keep track of its copies because it is not copyable. Because of this it is more efficient than the . Equivalent to and you should use (C++14 or greater) to create the :\n\nCurrent best practices suggest returning a from factory functions as well, then converting the to a if necessary.\n\nVariables should be declared as late as possible, and ideally only when it's possible to initialize the object. Reduced variable scope results in less memory being used, more efficient code in general, and helps the compiler optimize the code further.\n\nFor C++17 and onwards, consider using init-statement in the and statements:\n\nThis topic has an associated discussion thread.\n\nPrefer to , But Test First\n\nDepending on the situation and the compiler's ability to optimize, one may be faster over the other. Choosing will result in lower precision and may be slower due to conversions. On vectorizable operations may be faster if you are able to sacrifice precision.\n\nis the recommended default choice as it is the default type for floating point values in C++.\n\nSee this stackoverflow discussion for some more information.\n\n... when it is semantically correct. Pre-increment is faster than post-increment because it does not require a copy of the object to be made.\n\nEven if many modern compilers will optimize these two loops to the same assembly code, it is still good practice to prefer . There is absolutely no reason not to and you can never be certain that your code will not pass a compiler that does not optimize this. You should be also aware that the compiler will not be able optimize this only for integer types and not necessarily for all iterator or other user defined types.\n\nThe bottom line is that it is always easier and recommended to use the pre-increment operator if it is semantically identical to the post-increment operator.\n\nThis is very minor, but a has to be parsed by the compiler as a which has to do a range check for when writing it to the stream (or appending to a string). A '\n\n' is known to be a single character and avoids many CPU instructions.\n\nIf used inefficiently very many times it might have an impact on your performance, but more importantly thinking about these two usage cases gets you thinking more about what the compiler and runtime has to do to execute your code.\n\nis almost always way more overhead (both compile time and runtime) than you need. Instead simply use a lambda.\n\nProperly use the already highly optimized components of the vendor provided standard library.\n\nBe aware of how to use and related tags for efficient creation of objects such as , and ."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/1fv14b7/template_best_practices",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://geeksprogramming.com/templates-in-cpp",
        "document": "C++ stands out among programming languages due to its versatility and efficiency, making it a powerful language of choice. A distinctive feature that sets C++ apart from others is the utilization of templates. These templates hold immense significance, providing developers with a means to construct generic code capable of seamlessly functioning with different data types. In this blog post, we will delve into the realm of templates, exploring their importance, advantages, and how they empower programmers to embrace the concept of generic programming.\n\nAt its core, a template in C++ can be thought of as a blueprint or pattern used to create functions or classes that operate on diverse data types. Templates in C++ offer a flexible and efficient approach to crafting code that is both reusable and adaptable, as they can handle various data types without compromising performance.\n\nThe concept of templates in C++ goes hand in hand with generic programming. Generic programming allows developers to design algorithms and data structures that are independent of specific types. By employing templates, programmers can devise functions and classes that function uniformly for a wide array of data types, eliminating the need to duplicate code for each specific type. This not only saves time during development but also promotes code reuse and enhances code maintainability.\n\nFunction templates are a powerful feature in C++ that enable code reuse and flexibility. They allow you to write generic functions that can work with different types, making your code more versatile and efficient.\n\nThe concept of function templates revolves around creating a blueprint for a function that can be used with multiple types. This blueprint, known as a template, defines a generic function that can handle different data types. It is like creating a cookie cutter that can be used to produce cookies of various shapes and sizes.\n\nThe syntax of function templates involves declaring the function using the template keyword, followed by template parameters enclosed in angle brackets (<>). These template parameters represent the types or values that can be passed to the function. Inside the function body, you can use these template parameters as if they were regular types or values.\n\nLet’s consider a simple example to illustrate the usage of function templates. Suppose we want to write a function that returns the maximum of two values. Instead of writing separate functions for different types, we can use a function template. Here’s how it can be done\n\nIn this example, the is the template parameter representing the type of the values to be compared. The function can now be called with different types, such as , , or even custom types, and it will return the maximum value correctly. One of the main benefits of function templates is code reusability. With a single function template, you can perform the same operation on multiple types, eliminating the need for redundant code. This saves time and effort while ensuring consistent functionality across different data types.\n\nHere, we define a class template MyContainer with a generic type T. The setElement and getElement member functions can be used to set and retrieve the stored element, respectively. The type T can be dynamically determined when an object of MyContainer is created, allowing the container to hold elements of any type.\n\nTemplate specialization is the ability to provide a specific implementation for a particular set of template arguments. It allows us to customize the behavior of a template for specific types. One scenario where template specialization might be necessary is when we want to handle a specific type differently than the generic implementation.\n\nFor instance, let’s say we have a generic Print function template that prints an element to the console. However, we want to provide a specialized implementation for a std::string type, printing it with quotation marks.\n\nThe versatility of templates lies in their template arguments, which determine the behavior of the code generated from the template. Template arguments in C++ can be broadly classified into two categories: type arguments and non-type arguments. Type arguments are used to specify the data type that the template will operate on, while non-type arguments allow you to pass values of non-type entities, such as integers or pointers, to the template. When using type arguments, you can provide a specific type explicitly, such as or , or use a placeholder called a type parameter, denoted by the keyword or . This flexibility enables the creation of templates that work with various data types, promoting code reuse. Non-type arguments, on the other hand, are typically used to pass constant values to the template. These values can be integers, characters, or even pointers. Non-type arguments must be constant expressions known at compile-time, ensuring that the template code is generated correctly. While template arguments offer great flexibility, there are some rules and limitations to keep in mind. For instance, non-type arguments must have a constant value known at compile-time, making them unsuitable for runtime values. Additionally, the number and types of template arguments must match when using a template. To better illustrate the power of template arguments, consider a generic container class. You can create a template class that accepts a type argument, allowing you to use the container with various data types. Additionally, you can define a non-type argument for the container’s maximum size, providing a flexible and efficient solution.\n\nTemplate Metaprogramming (TMP) is a powerful technique in C++ that allows us to perform computations and generate code at compile-time. It leverages the flexibility of templates to enable the creation of highly customizable and efficient algorithms. At its core, template metaprogramming involves using templates and template specialization to perform computations and generate code during the compilation process. This approach allows us to shift some computations from runtime to compile-time, resulting in faster and more efficient programs. One of the key advantages of TMP is its ability to perform compile-time computations. For example, let’s say we want to calculate the factorial of a number at compile-time. We can achieve this using template recursion, where the compiler repeatedly instantiates templates until a base case is reached. Here’s an example:\n\nThe Standard Template Library (STL) is an essential part of the C++ programming language. It provides a collection of generic algorithms and containers that allow developers to write efficient and reusable code. At the heart of the STL are templates, which play a crucial role in enabling the generic nature of the library. Templates serve as the backbone of the STL, enabling the creation of generic algorithms and containers that can work seamlessly with different data types. They allow programmers to write code that is not tied to a specific data type but can be reused with various types effortlessly. This flexibility and reusability are at the core of what makes the STL a fundamental component of C++. Imagine you need to store a collection of integers in your program. Traditionally, you might have to write a custom data structure specifically designed for integers. With the STL, you can use a templated container such as , which can hold any data type. Here’s an example:\n\nIn this example, we include the necessary headers, and , to work with the STL containers and stream output. We create a vector called using the template, indicating that it will store integers. We then add three integers to the vector using the function. Finally, we iterate over the vector using a range-based for loop and print each element. The beauty of using templates is that you can easily adapt this code to work with other data types. Suppose you want to store strings instead of integers. Simply change the template argument from to , and the code will handle strings effortlessly. But templates don’t stop at containers. The STL provides a plethora of generic algorithms, such as sorting, searching, and manipulating elements, that can work with various container types. With just a few lines of code, you can sort a vector of integers or strings, find the maximum element, or perform other powerful operations. By leveraging the STL’s templated containers and algorithms, you can write concise, efficient, and flexible code that is applicable to a wide range of scenarios. As a programming beginner, exploring the STL and its templates will open doors to a wealth of possibilities in your C++ journey.\n\nTemplates in C++ are a powerful tool that allow for the creation of generic code, enabling programmers to write reusable algorithms and data structures. However, when used improperly, templates can lead to bloated code, unnecessary complexity, and difficult debugging experiences. To help you harness the full potential of templates while avoiding common pitfalls, here are some best practices and tips to keep in mind. First and foremost, organizing your code is crucial when working with templates. It’s recommended to separate template declarations from their definitions, placing them in header files to ensure their availability across multiple translation units. This practice promotes modularity and makes your code more maintainable. Another important consideration is minimizing template bloat. Templates can generate a large amount of code, potentially impacting compile times and executable size. To mitigate this, it’s advised to only include the necessary functionality in your template, avoiding unnecessary member functions or specialization. By keeping your templates concise and focused, you can reduce the impact of template bloat. When debugging template-related issues, it can be challenging to decipher error messages that involve complex template instantiations. A useful tip is to enable compiler flags or options that provide more detailed error messages, such as displaying the full instantiation stack. Additionally, employing static assertions and concept checks within templates can help catch errors early and provide clearer error messages. Lastly, be aware of common mistakes and pitfalls when working with templates. One such mistake is relying too heavily on template metaprogramming, which can lead to overly complex and unreadable code. Strive for simplicity and readability when using templates, ensuring that the benefits of generic programming outweigh the costs.\n\nIn conclusion, templates are a powerful feature in C++ that enables generic programming, allowing developers to write versatile and efficient code. Templates serve as a mechanism for creating functions and classes that seamlessly operate with different data types, thereby promoting code reusability and enhancing maintainability. Function templates allow you to write generic functions that can handle various types of data. By employing a single function template, you can perform identical operations on various types, eliminating the need for repetitive code. This not only saves time and effort but also ensures consistent functionality across different data types. On the other hand, class templates provide a blueprint for generic classes, enabling the construction of reusable and adaptable code. They prove particularly valuable when you seek to design containers or data structures capable of accommodating elements of any type. Template specialization allows you to provide specific implementations for certain types, giving you the flexibility to handle different types differently. This customization feature is valuable when you need to tailor your code to specific requirements while still benefiting from the generic nature of templates. The flexibility of template arguments, whether type arguments or non-type arguments, enables you to create highly customizable code. Type arguments allow you to create templates that work with different data types, while non-type arguments allow you to pass constant values to templates, providing flexibility and efficiency. Template metaprogramming (TMP) takes template usage to the next level by allowing you to perform computations and generate code at compile-time. This technique enables faster and more efficient programs by shifting computations from runtime to compile-time. In your own projects, consider using templates to write code that is flexible, reusable, and efficient. Templates will empower you to embrace the concept of generic programming, saving development time and promoting code maintainability. Don’t be afraid to experiment and explore the possibilities that templates offer, and remember to follow best practices to ensure code organization and avoid common pitfalls. By harnessing the power of templates in C++, you’ll be well on your way to becoming a more proficient and versatile programmer. So dive in, embrace the world of templates, and unlock the potential of generic programming in your C++ projects!"
    }
]