[
    {
        "link": "https://doc.rust-lang.org/std/net/struct.TcpStream.html",
        "document": "is an address of the remote host. Anything which implements trait can be supplied for the address; see this trait documentation for concrete examples. If yields multiple addresses, will be attempted with each of the addresses until a connection is successful. If none of the addresses result in a successful connection, the error returned from the last connection attempt (the last address) is returned. Open a TCP connection to . If the connection fails, open a TCP connection to :\n\nShuts down the read, write, or both halves of this connection. This function will cause all pending and future I/O on the specified portions to return immediately with an appropriate value (see the documentation of ). Calling this function multiple times may result in different behavior, depending on the operating system. On Linux, the second call will return , but on macOS, it will return . This may change in the future.\n\nSets the read timeout to the timeout specified. If the value specified is , then calls will block indefinitely. An is returned if the zero is passed to this method. Platforms may return a different error code whenever a read times out as a result of setting this option. For example Unix typically returns an error of the kind , but Windows may return . An is returned if the zero is passed to this method:\n\nSets the write timeout to the timeout specified. If the value specified is , then calls will block indefinitely. An is returned if the zero is passed to this method. Platforms may return a different error code whenever a write times out as a result of setting this option. For example Unix typically returns an error of the kind , but Windows may return . An is returned if the zero is passed to this method:\n\nSets the value of the option on this socket. If set, this option disables the Nagle algorithm. This means that segments are always sent as soon as possible, even if there is only a small amount of data. When not set, data is buffered until there is a sufficient amount to send out, thereby avoiding the frequent sending of small packets.\n\nMoves this TCP stream into or out of nonblocking mode. This will result in , , and system operations becoming nonblocking, i.e., immediately returning from their calls. If the IO operation is successful, is returned and no further action is required. If the IO operation could not be completed and needs to be retried, an error with kind is returned. On Unix platforms, calling this method corresponds to calling . On Windows calling this method corresponds to calling ."
    },
    {
        "link": "https://doc.rust-lang.org/std/net/index.html",
        "document": "This module provides networking functionality for the Transmission Control and User Datagram Protocols, as well as types for IP and socket addresses.\n• and provide functionality for communication over TCP\n• provides functionality for communication over UDP\n• represents IP addresses of either IPv4 or IPv6; and are respectively IPv4 and IPv6 addresses\n• represents socket addresses of either IPv4 or IPv6; and are respectively IPv4 and IPv6 socket addresses\n• is a trait that is used for generic address resolution when interacting with networking objects like , or\n• Other types are return or parameter types for various methods in this module\n\nRust disables inheritance of socket objects to child processes by default when possible. For example, through the use of the flag in UNIX systems or the flag on Windows."
    },
    {
        "link": "https://stackoverflow.com/questions/73518517/how-can-i-create-a-tcp-stream-using-rust",
        "document": "this is my first question and i hope you can help me.\n\nIm trying to start a TCP stream to send HTTP messages using the library. The problem is when i try to send SYN packets but i dont receive any answer and i dont know whats the problem. I thought i was creating broken packets but i copy a SYN packet from a \"telnet\" operation and i get the same result.\n\nI've tried so many ways and i still cant find a solution. Can anyone help me please?"
    },
    {
        "link": "https://docs.rs/tcp-stream",
        "document": "tcp-stream is a library aiming at providing TLS support to std::net::TcpStream"
    },
    {
        "link": "https://doc.rust-lang.org/book/ch20-02-multithreaded.html",
        "document": ""
    },
    {
        "link": "https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/boxing_errors.html",
        "document": "A way to write simple code while preserving the original errors is to them. The drawback is that the underlying error type is only known at runtime and not statically determined.\n\nThe stdlib helps in boxing our errors by having implement conversion from any type that implements the trait into the trait object , via ."
    },
    {
        "link": "https://stackoverflow.com/questions/58393250/returning-error-message-to-function-expecting-boxdyn-error",
        "document": "Let's focus on the absolute minimum reproduction of your issue:\n\nThe error returned by this code is:\n\nIt's saying that the function signature expected you to return an containing a , but you actually returned an containing a . Since the types don't line up, the compiler throws an error.\n\nThe easiest way to fix this is to use the trait, which implements a conversion between and :\n\nYou may still be wondering what exactly that magic call is doing behind the scenes.\n\nFirst, let's see what happens if we just the :\n\nAgain, this doesn't work because the types don't line up - it's expecting the to contain something that implements the trait, but if you look at the docs, you'll notice that is not one of the types that implements it. You need to wrap your string in a type that does implement :\n\nThis code compiles, and is basically exactly what does under the hood :)"
    },
    {
        "link": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html",
        "document": "Most errors aren’t serious enough to require the program to stop entirely. Sometimes when a function fails it’s for a reason that you can easily interpret and respond to. For example, if you try to open a file and that operation fails because the file doesn’t exist, you might want to create the file instead of terminating the process.\n\nRecall from “Handling Potential Failure with ” in Chapter 2 that the enum is defined as having two variants, and , as follows:\n\nThe and are generic type parameters: we’ll discuss generics in more detail in Chapter 10. What you need to know right now is that represents the type of the value that will be returned in a success case within the variant, and represents the type of the error that will be returned in a failure case within the variant. Because has these generic type parameters, we can use the type and the functions defined on it in many different situations where the success value and error value we want to return may differ.\n\nLet’s call a function that returns a value because the function could fail. In Listing 9-3 we try to open a file.\n\nThe return type of is a . The generic parameter has been filled in by the implementation of with the type of the success value, , which is a file handle. The type of used in the error value is . This return type means the call to might succeed and return a file handle that we can read from or write to. The function call also might fail: for example, the file might not exist, or we might not have permission to access the file. The function needs to have a way to tell us whether it succeeded or failed and at the same time give us either the file handle or error information. This information is exactly what the enum conveys.\n\nIn the case where succeeds, the value in the variable will be an instance of that contains a file handle. In the case where it fails, the value in will be an instance of that contains more information about the kind of error that occurred.\n\nWe need to add to the code in Listing 9-3 to take different actions depending on the value returns. Listing 9-4 shows one way to handle the using a basic tool, the expression that we discussed in Chapter 6.\n\nNote that, like the enum, the enum and its variants have been brought into scope by the prelude, so we don’t need to specify before the and variants in the arms.\n\nWhen the result is , this code will return the inner value out of the variant, and we then assign that file handle value to the variable . After the , we can use the file handle for reading or writing.\n\nThe other arm of the handles the case where we get an value from . In this example, we’ve chosen to call the macro. If there’s no file named hello.txt in our current directory and we run this code, we’ll see the following output from the macro:\n\nAs usual, this output tells us exactly what has gone wrong.\n\nThe code in Listing 9-4 will no matter why failed. However, we want to take different actions for different failure reasons. If failed because the file doesn’t exist, we want to create the file and return the handle to the new file. If failed for any other reason—for example, because we didn’t have permission to open the file—we still want the code to in the same way it did in Listing 9-4. For this, we add an inner expression, shown in Listing 9-5.\n\nThe type of the value that returns inside the variant is , which is a struct provided by the standard library. This struct has a method that we can call to get an value. The enum is provided by the standard library and has variants representing the different kinds of errors that might result from an operation. The variant we want to use is , which indicates the file we’re trying to open doesn’t exist yet. So we match on , but we also have an inner match on .\n\nThe condition we want to check in the inner match is whether the value returned by is the variant of the enum. If it is, we try to create the file with . However, because could also fail, we need a second arm in the inner expression. When the file can’t be created, a different error message is printed. The second arm of the outer stays the same, so the program panics on any error besides the missing file error.\n\nShortcuts for Panic on Error: and\n\nUsing works well enough, but it can be a bit verbose and doesn’t always communicate intent well. The type has many helper methods defined on it to do various, more specific tasks. The method is a shortcut method implemented just like the expression we wrote in Listing 9-4. If the value is the variant, will return the value inside the . If the is the variant, will call the macro for us. Here is an example of in action:\n\nIf we run this code without a hello.txt file, we’ll see an error message from the call that the method makes:\n\nSimilarly, the method lets us also choose the error message. Using instead of and providing good error messages can convey your intent and make tracking down the source of a panic easier. The syntax of looks like this:\n\nWe use in the same way as : to return the file handle or call the macro. The error message used by in its call to will be the parameter that we pass to , rather than the default message that uses. Here’s what it looks like:\n\nIn production-quality code, most Rustaceans choose rather than and give more context about why the operation is expected to always succeed. That way, if your assumptions are ever proven wrong, you have more information to use in debugging.\n\nWhen a function’s implementation calls something that might fail, instead of handling the error within the function itself you can return the error to the calling code so that it can decide what to do. This is known as propagating the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.\n\nFor example, Listing 9-6 shows a function that reads a username from a file. If the file doesn’t exist or can’t be read, this function will return those errors to the code that called the function.\n\nThis function can be written in a much shorter way, but we’re going to start by doing a lot of it manually in order to explore error handling; at the end, we’ll show the shorter way. Let’s look at the return type of the function first: . This means the function is returning a value of the type , where the generic parameter has been filled in with the concrete type and the generic type has been filled in with the concrete type .\n\nIf this function succeeds without any problems, the code that calls this function will receive an value that holds a —the that this function read from the file. If this function encounters any problems, the calling code will receive an value that holds an instance of that contains more information about what the problems were. We chose as the return type of this function because that happens to be the type of the error value returned from both of the operations we’re calling in this function’s body that might fail: the function and the method.\n\nThe body of the function starts by calling the function. Then we handle the value with a similar to the in Listing 9-4. If succeeds, the file handle in the pattern variable becomes the value in the mutable variable and the function continues. In the case, instead of calling , we use the keyword to return early out of the function entirely and pass the error value from , now in the pattern variable , back to the calling code as this function’s error value.\n\nSo, if we have a file handle in , the function then creates a new in variable and calls the method on the file handle in to read the contents of the file into . The method also returns a because it might fail, even though succeeded. So we need another to handle that : if succeeds, then our function has succeeded, and we return the username from the file that’s now in wrapped in an . If fails, we return the error value in the same way that we returned the error value in the that handled the return value of . However, we don’t need to explicitly say , because this is the last expression in the function.\n\nThe code that calls this code will then handle getting either an value that contains a username or an value that contains an . It’s up to the calling code to decide what to do with those values. If the calling code gets an value, it could call and crash the program, use a default username, or look up the username from somewhere other than a file, for example. We don’t have enough information on what the calling code is actually trying to do, so we propagate all the success or error information upward for it to handle appropriately.\n\nThis pattern of propagating errors is so common in Rust that Rust provides the question mark operator to make this easier.\n\nListing 9-7 shows an implementation of that has the same functionality as in Listing 9-6, but this implementation uses the operator.\n\nThe placed after a value is defined to work in almost the same way as the expressions we defined to handle the values in Listing 9-6. If the value of the is an , the value inside the will get returned from this expression, and the program will continue. If the value is an , the will be returned from the whole function as if we had used the keyword so the error value gets propagated to the calling code.\n\nThere is a difference between what the expression from Listing 9-6 does and what the operator does: error values that have the operator called on them go through the function, defined in the trait in the standard library, which is used to convert values from one type into another. When the operator calls the function, the error type received is converted into the error type defined in the return type of the current function. This is useful when a function returns one error type to represent all the ways a function might fail, even if parts might fail for many different reasons.\n\nFor example, we could change the function in Listing 9-7 to return a custom error type named that we define. If we also define to construct an instance of from an , then the operator calls in the body of will call and convert the error types without needing to add any more code to the function.\n\nIn the context of Listing 9-7, the at the end of the call will return the value inside an to the variable . If an error occurs, the operator will return early out of the whole function and give any value to the calling code. The same thing applies to the at the end of the call.\n\nThe operator eliminates a lot of boilerplate and makes this function’s implementation simpler. We could even shorten this code further by chaining method calls immediately after the , as shown in Listing 9-8.\n\nWe’ve moved the creation of the new in to the beginning of the function; that part hasn’t changed. Instead of creating a variable , we’ve chained the call to directly onto the result of . We still have a at the end of the call, and we still return an value containing when both and succeed rather than returning errors. The functionality is again the same as in Listing 9-6 and Listing 9-7; this is just a different, more ergonomic way to write it.\n\nListing 9-9 shows a way to make this even shorter using .\n\nReading a file into a string is a fairly common operation, so the standard library provides the convenient function that opens the file, creates a new , reads the contents of the file, puts the contents into that , and returns it. Of course, using doesn’t give us the opportunity to explain all the error handling, so we did it the longer way first.\n\nWhere The Operator Can Be Used\n\nThe operator can only be used in functions whose return type is compatible with the value the is used on. This is because the operator is defined to perform an early return of a value out of the function, in the same manner as the expression we defined in Listing 9-6. In Listing 9-6, the was using a value, and the early return arm returned an value. The return type of the function has to be a so that it’s compatible with this .\n\nIn Listing 9-10, let’s look at the error we’ll get if we use the operator in a function with a return type that is incompatible with the type of the value we use on.\n\nThis code opens a file, which might fail. The operator follows the value returned by , but this function has the return type of , not . When we compile this code, we get the following error message:\n\nThis error points out that we’re only allowed to use the operator in a function that returns , , or another type that implements .\n\nTo fix the error, you have two choices. One choice is to change the return type of your function to be compatible with the value you’re using the operator on as long as you have no restrictions preventing that. The other choice is to use a or one of the methods to handle the in whatever way is appropriate.\n\nThe error message also mentioned that can be used with values as well. As with using on , you can only use on in a function that returns an . The behavior of the operator when called on an is similar to its behavior when called on a : if the value is , the will be returned early from the function at that point. If the value is , the value inside the is the resultant value of the expression, and the function continues. Listing 9-11 has an example of a function that finds the last character of the first line in the given text.\n\nThis function returns because it’s possible that there is a character there, but it’s also possible that there isn’t. This code takes the string slice argument and calls the method on it, which returns an iterator over the lines in the string. Because this function wants to examine the first line, it calls on the iterator to get the first value from the iterator. If is the empty string, this call to will return , in which case we use to stop and return from . If is not the empty string, will return a value containing a string slice of the first line in .\n\nThe extracts the string slice, and we can call on that string slice to get an iterator of its characters. We’re interested in the last character in this first line, so we call to return the last item in the iterator. This is an because it’s possible that the first line is the empty string; for example, if starts with a blank line but has characters on other lines, as in . However, if there is a last character on the first line, it will be returned in the variant. The operator in the middle gives us a concise way to express this logic, allowing us to implement the function in one line. If we couldn’t use the operator on , we’d have to implement this logic using more method calls or a expression.\n\nNote that you can use the operator on a in a function that returns , and you can use the operator on an in a function that returns , but you can’t mix and match. The operator won’t automatically convert a to an or vice versa; in those cases, you can use methods like the method on or the method on to do the conversion explicitly.\n\nSo far, all the functions we’ve used return . The function is special because it’s the entry point and exit point of an executable program, and there are restrictions on what its return type can be for the program to behave as expected.\n\nLuckily, can also return a . Listing 9-12 has the code from Listing 9-10, but we’ve changed the return type of to be and added a return value to the end. This code will now compile.\n\nThe type is a trait object, which we’ll talk about in the “Using Trait Objects that Allow for Values of Different Types” section in Chapter 18. For now, you can read to mean “any kind of error.” Using on a value in a function with the error type is allowed because it allows any value to be returned early. Even though the body of this function will only ever return errors of type , by specifying , this signature will continue to be correct even if more code that returns other errors is added to the body of .\n\nWhen a function returns a , the executable will exit with a value of if returns and will exit with a nonzero value if returns an value. Executables written in C return integers when they exit: programs that exit successfully return the integer , and programs that error return some integer other than . Rust also returns integers from executables to be compatible with this convention.\n\nThe function may return any types that implement the trait , which contains a function that returns an . Consult the standard library documentation for more information on implementing the trait for your own types.\n\nNow that we’ve discussed the details of calling or returning , let’s return to the topic of how to decide which is appropriate to use in which cases."
    },
    {
        "link": "https://stevedonovan.github.io/rust-gentle-intro/6-error-handling.html",
        "document": "Error handling in Rust can be clumsy if you can't use the question-mark operator. To achieve happiness, we need to return a which can accept any error. All errors implement the trait , and so any error can convert into a .\n\nSay we needed to handle both i/o errors and errors from converting strings into numbers:\n\nSo that's two question-marks for the i/o errors (can't open file, or can't read as string) and one question-mark for the conversion error. Finally, we wrap the result in . Rust can work out from the return type that should convert to .\n\nIt's easy to create a shortcut for this type:\n\nHowever, our programs will have application-specific error conditions, and so we need to create our own error type. The basic requirements are straightforward:\n\nOtherwise, your error can do pretty much what it likes.\n\nTyping gets tedious and many Rust modules define their own - e.g. is short for .\n\nIn this next example we need to handle the specific error when a string can't be parsed as a floating-point number.\n\nNow the way that works is to look for a conversion from the error of the expression to the error that must be returned. And this conversion is expressed by the trait. works as it does because it implements for all types implementing .\n\nAt this point you can continue to use the convenient alias and catch everything as before; there will be a conversion from our error into . This is a good option for smaller applications. But I want to show other errors can be explicitly made to cooperate with our error type.\n\nThe first is fine (a type always converts to itself with ) and the second will convert the to .\n\nNot too complicated, although a little long-winded. The tedious bit is having to write conversions for all the other error types that need to play nice with - or you simply lean on . Newcomers get confused by the multitude of ways to do the same thing in Rust; there is always another way to peel the avocado (or skin the cat, if you're feeling bloodthirsty). The price of flexibility is having many options. Error-handling for a 200 line program can afford to be simpler than for a large application. And if you ever want to package your precious droppings as a Cargo crate, then error handling becomes crucial.\n\nCurrently, the question-mark operator only works for , not , and this is a feature, not a limitation. has a which converts itself into a . For example, say we had a and must fail if a key isn't defined:\n\nNow here the error returned is completely clear! (This form uses a closure, so the error value is only created if the lookup fails.)\n\nThe simple-error crate provides you with a basic error type based on a string, as we have defined it here, and a few convenient macros. Like any error, it works fine with :\n\nexpands to - return early with a conversion into the receiving type.\n\nYou need to use for mixing the type with other errors, since we can't implement for it, since both the trait and the type come from other crates.\n\nFor non-trivial applications have a look at the error_chain crate. A little macro magic can go a long way in Rust...\n\nCreate a binary crate with and change to this directory. Edit and add to the end.\n\nWhat error-chain does for you is create all the definitions we needed for manually implementing an error type; creating a struct, and implementing the necessary traits: , and . It also by default implements so strings can be converted into errors.\n\nOur first file looks like this. All the main program does is call , print out any errors, and end the program with a non-zero exit code. The macro generates all the definitions needed, within an module - in a larger program you would put this in its own file. We need to bring everything in back into global scope because our code will need to see the generated traits. By default, there will be an struct and a defined with that error.\n\nHere we also ask for to be implemented so that will convert into our error type using :\n\nThe 'foreign_links' has made our life easier, since the question mark operator now knows how to convert into our . (Under the hood, the macro is creating a conversion, exactly as spelt out earlier.)\n\nAll the action happens in ; let's make it print out the first 10 lines of a file given as the first program argument. There may or may not be such an argument, which isn't necessarily an error. Here we want to convert an into a . There are two methods for doing this conversion, and I've picked the simplest one. Our type implements for , so it's straightforward to make an error with a simple text message.\n\nThere is (again) a useful little macro for 'throwing' errors. An alternative to the method here could be:\n\nLike it does an early return.\n\nThe returned error contains an enum , which allows us to distinguish between various kinds of errors. There's always a variant (when you say ) and the has declared which wraps I/O errors:\n\nIt's straightforward to add new kinds of errors. Add an section to the macro:\n\nThis defines how works for this new kind of error. And now we can handle 'no argument' errors more specifically, feeding a value:\n\nThere's now an extra variant that you must match:\n\nGenerally, it's useful to make errors as specific as possible, particularly if this is a library function! This match-on-kind technique is pretty much the equivalent of traditional exception handling, where you match on exception types in a or block.\n\nIn summary, error-chain creates a type for you, and defines to be . contains an enum and by default there is one variant for errors created from strings. You define external errors with which does two things. First, it creates a new variant. Second, it defines on these external errors so they can be converted to our error. New error variants can be easily added. A lot of irritating boilerplate code is eliminated.\n\nBut the really cool thing that this crate provides is error chaining.\n\nAs a library user, it's irritating when a method simply just 'throws' a generic I/O error. OK, it could not open a file, fine, but what file? Basically, what use is this information to me?\n\ndoes error chaining which helps solve this problem of over-generic errors. When we try to open the file, we can lazily lean on the conversion to using , or chain the error.\n\nHere's a new version of the program, with no imported 'foreign' errors, just the defaults:\n\nSo the method takes the original error, and creates a new error which contains the original error - this can be continued indefinitely. The closure is expected to return any value which can be converted into an error.\n\nRust macros can clearly save you a lot of typing. even provides a shortcut that replaces the whole main program:"
    },
    {
        "link": "https://shuttle.dev/blog/2022/06/30/error-handling",
        "document": "To quote the Rust Book, 'errors are a fact of life in software'. This post goes over how to handle them.\n\nBefore talking about recoverable errors and the type, let's first touch on unrecoverable errors - a.k.a panics.\n\nPanics are exceptions a program can throw. It stops all execution in the current thread. When a panic is thrown it returns a short description of what went wrong as well as information about the position of the the panic.\n\nRunning the above causes:\n\nThey are similar to in JavaScript and other languages, in that they don't require an annotation on the function to run and they can pass through function boundaries. However in Rust, panics cannot be recovered from, there is no way to incept a panic in the current thread.\n\nThe function is fallible (can go wrong). If this is called with an empty message then the program stops running. There is no way for the callee to track that an error has occurred.\n\nFor recoverable errors, Rust has a type for error handling in the standard library called a . It is a generic type, which means the result and error variant can basically be whatever you want.\n\nAt the moment our function doesn't return anything. This means no information can be received by the callee. We can change the definition to instead return a and rather than panicking we can early return a .\n\nNow our function actually returns information about what went wrong we can handle it when we call it:\n\nIn the above example we inspect the value of the item and branch on it. However, if we didn't inspect and handle the returned Result then the Rust compiler gives us a helpful warning about it so that you don't forget to explicitly deal with errors in your program.\n\nThe type can be found in most libraries. One of my favorite examples is the return type of the FromStr::from_str trait method. With str::parse (which uses the trait) we can do the following:\n\nHere we can see when we type in a number we get a variant with the number else we get a ParseFloatError\n\nAll errors occur when you interact with the outside world or things outside the Rust runtime. One of the places where a lot of errors can occur is interacting with the file system. The function attempts to open a file. This can fail for a variety of reasons. The filename is invalid, the file doesn't exist or you simply don't have permission to read the file. Notice the errors are well-defined and known before-hand. You can even access the error variants with the function and in order to implement your program logic or return an instructive error message to the user.\n\nWhen you're working on a project you'll often find yourself repeating yourself when it comes to return types in function signatures:\n\nTo give a concrete example, all functions which operate on the file system have the same errors (file not exists, invalid permissions). io::Result is a alias over a result but means that every function does not have to specify the error type:\n\nIf you have an API which has a common error type, you may want to consider this pattern.\n\nOne of the best things about Results is the question mark operator, The question mark operator can short circuit Result error values. Let's look at a simple function which uploads text from a file. This can error in a bunch of different ways:\n\nHang on, we're writing Rust not Go!\n\nIf a is postfixed on to a Result (or anything that implements so also ) we can obtain a functionally equivalent outcome with a much more readable and concise syntax.\n\nAs long as the calling function also returns a with the same type, saves a ton of explicit code being written. Moreover, the question-mark implicitly runs Into::into (which is automatically implemented for From implementors) on the error value. So we don't have to worry about converting the error before we use the operator:\n\nWe will look at more patterns for combining error types later!\n\nThe Error trait is defined in the standard library. It basically represents the expectations of error values - values of type in . The Error trait is implemented for many errors and provides a unified API for information on errors. The Error trait is a bit needy and requires that the error implements both Debug and Display. While it can be cumbersome to implement we will see some helper libraries for doing so later on.\n\nIn the standard library VarError (for reading environment variables) and ParseIntError (for parsing a string slice as a integer) are different errors. When we interact them we need to differentiate between the types because they have different properties and different stack sizes. To build a combination of them we could build a sum type using an enum. Alternatively we can use dynamically dispatched traits which handle varying stack sized items and other type information.\n\nUsing the above mentioned try syntax ( ) we can convert the above errors to be dynamically dispatched. This makes it easy to handle different errors without building enums to combine errors.\n\nWhile this is an easy way to handle errors, it isn't easy to differentiate between the types and can make handling errors in libraries hard. More information on this later.\n\nThe Error trait vs Results and enums\n\nOne thing when using an enum is we can use to branch on the enum error variants. On the other hand, with the trait unless you go down the down casting path it is very hard to get specific information about the error:\n\nFor reusable libraries it is better to use enums to combine errors so that users of your library can handle the specifics themselves. But for CLIs and other applications using the trait can be a lot simpler.\n\nResult and Option contains many useful functions. Here are some functions I commonly use:\n\nResult::map maps or converts the value if it exists. This can be more concise than using the operator.\n\nResult::ok is useful for converting Results to Options\n\nOption::ok_or_else is useful for going the other way in converting from Options to Results\n\nUsing results in iterator chains can be a little confusing. Luckily implements collect. We can use this to short circuit an iterator if an error occurs. In the following, if all the s succeed then we get collected vec of numbers result. If one fails then it instead returns a Result with the failing Err.\n\nBecause Rust iterators are piecewise and lazy the iterator can short circuit without evaluating parse on any of the later items.\n\n, , are all wrappers for which but are specialized to their situation. Panics have a special type, called the 'never type', which represents the result of computations that never complete (also means it can be passed anywhere):\n\nSometimes there is Rust code which the compiler cannot properly infer is valid. For this type of situation, the panic can be used:\n\nis a method on and . They return the or variant or else panic...\n\nThe uses-cases for this are developer error and situations the compiler can't quite figure out. If you are just trying something and don't want to set up a full error handling system then they can be used to ignore compiler warnings.\n\nEven if the situation calls for you are better off using which has an accompanying message - you'll be thanking your past self when the error message helps you find the root cause of an issue 2 weeks down the line.\n\nIt is important to note that some of the APIs in the standard library can panic. You should look out for these annotations in the docs. One of them is Vec::remove. If you use this you should ensure that the argument is in its indexable range.\n\nHandling errors from multiple libraries and APIs can become challenging as you have to deal with a bunch of different types. They are different sizes and contain different information. To unify the types we have to build a sum type using an enum, in order to ensure they have the same size at compile time.\n\nSome crates for making creating these unifying enums easier:\n\nprovides a derive implementation which adds the Error trait for us. As previously mentioned, to implement Error we have to implement display and thiserrors' attributes provide templating for the displayed errors.\n\nprovides an ergonomic and idiomatic alternative to explicitly handling errors. It is similar to the previously mentioned error trait but has additional features such as adding context to thrown errors.\n\nThis is really, really, useful when you want to convey errors to an application's users in a context-aware fashion:\n\nSimilar to the trait, suffers from the fact you can't match on 's result error variant. This is why it is suggested in 's docs to use for applications and for libraries.\n\nFinally, is a fork of and adds more backtrace information. It's highly customisable and using color-eyre we get colors in our panic messages - a little color always brightens up the dev experience.\n\nThank you for reading this article! Error handling can be tough, but with this guide hopefully you'll have a better idea of how to ensure you can reliably track errors and make debugging your Rust apps that much easier."
    }
]