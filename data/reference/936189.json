[
    {
        "link": "https://docs.python.org/3/library/os.html",
        "document": "This module provides a portable way of using operating system dependent functionality. If you just want to read or write a file see , if you want to manipulate paths, see the module, and if you want to read all the lines in all the files on the command line see the module. For creating temporary files and directories see the module, and for high-level file and directory handling see the module.\n\nNotes on the availability of these functions:\n• None The design of all built-in operating system dependent modules of Python is such that as long as the same functionality is available, it uses the same interface; for example, the function returns stat information about path in the same format (which happens to have originated with the POSIX interface).\n• None Extensions peculiar to a particular operating system are also available through the module, but using them is of course a threat to portability.\n• None All functions accepting path or file names accept both bytes and string objects, and result in an object of the same type, if a path or file name is returned.\n• None On VxWorks, os.popen, os.fork, os.execv and os.spawn*p* are not supported.\n• None On WebAssembly platforms, Android and iOS, large parts of the module are not available or behave differently. APIs related to processes (e.g. , ) and resources (e.g. ) are not available. Others like and are emulated or stubs. WebAssembly platforms also lack support for signals (e.g. , )."
    },
    {
        "link": "https://docs.python.org/3/library/os.path.html",
        "document": "Source code: Lib/genericpath.py, Lib/posixpath.py (for POSIX) and Lib/ntpath.py (for Windows).\n\nThis module implements some useful functions on pathnames. To read or write files see , and for accessing the filesystem see the module. The path parameters can be passed as strings, or bytes, or any object implementing the protocol.\n\nUnlike a Unix shell, Python does not do any automatic path expansions. Functions such as and can be invoked explicitly when an application desires shell-like path expansion. (See also the module.)\n\nSince different operating systems have different path name conventions, there are several versions of this module in the standard library. The module is always the path module suitable for the operating system Python is running on, and therefore usable for local paths. However, you can also import and use the individual modules if you want to manipulate a path that is always in one of the different formats. They all have the same interface:\n\nOn Unix and Windows, return the argument with an initial component of or replaced by that user’s home directory. On Unix, an initial is replaced by the environment variable if it is set; otherwise the current user’s home directory is looked up in the password directory through the built-in module . An initial is looked up directly in the password directory. On Windows, will be used if set, otherwise a combination of and will be used. An initial is handled by checking that the last directory component of the current user’s home directory matches , and replacing it if so. If the expansion fails or if the path does not begin with a tilde, the path is returned unchanged. Changed in version 3.8: No longer uses on Windows.\n\nJoin one or more path segments intelligently. The return value is the concatenation of path and all members of *paths, with exactly one directory separator following each non-empty part, except the last. That is, the result will only end in a separator if the last part is either empty or ends in a separator. If a segment is an absolute path (which on Windows requires both a drive and a root), then all previous segments are ignored and joining continues from the absolute path segment. On Windows, the drive is not reset when a rooted path segment (e.g., ) is encountered. If a segment is on a different drive or is an absolute path, all previous segments are ignored and the drive is reset. Note that since there is a current directory for each drive, represents a path relative to the current directory on drive ( ), not . Changed in version 3.6: Accepts a path-like object for path and paths."
    },
    {
        "link": "https://geeksforgeeks.org/os-module-python-examples",
        "document": "The OS module in Python provides functions for interacting with the operating system. OS comes under Python’s standard utility modules. This module provides a portable way of using operating system-dependent functionality.\n\nThe *os* and *os.path* modules include many functions to interact with the file system.\n\nHere we will discuss some important functions of the Python os module :\n• None Listing out Files and Directories with Python\n\nConsider Current Working Directory(CWD) as a folder, where Python is operating. Whenever the files are called only by their name, Python assumes that it starts in the CWD which means that name-only reference will be successful only if the file is in the Python’s CWD.\n\nTo get the location of the current working directory os.getcwd() is used.\n\nExample: This code uses the ‘ module to get and print the current working directory (CWD) of the Python script. It retrieves the CWD using the ‘ and then prints it to the console.\n\nTo change the current working directory(CWD) os.chdir() method is used. This method changes the CWD to a specified path. It only takes a single argument as a new directory path.\n\nExample: The code checks and displays the current working directory (CWD) twice: before and after changing the directory up one level using . It provides a simple example of how to work with the current working directory in Python.\n\nThere are different methods available in the OS module for creating a directory. These are –\n\nBy using os.mkdir() method in Python is used to create a directory named path with the specified numeric mode. This method raises FileExistsError if the directory to be created already exists.\n\nExample: This code creates two directories: “GeeksforGeeks” within the “D:/Pycharm projects/” directory and “Geeks” within the “D:/Pycharm projects” directory.\n• None The first directory is created using the method without specifying the mode.\n• None The second directory is created using the same method, but a specific mode ( ) is provided, which grants read and write permissions.\n• None The code then prints messages to indicate that the directories have been created.\n\nos.makedirs() method in Python is used to create a directory recursively. That means while making leaf directory if any intermediate-level directory is missing, os.makedirs() method will create them all.\n\nExample: This code creates two directories, “Nikhil” and “c”, within different parent directories. It uses the function to ensure that parent directories are created if they don’t exist.\n\nIt also sets the permissions for the “c” directory. The code prints messages to confirm the creation of these directories\n\nListing out Files and Directories with Python\n\nThere is os.listdir() method in Python is used to get the list of all files and directories in the specified directory. If we don’t specify any directory, then the list of files and directories in the current working directory will be returned.\n\nExample: This code lists all the files and directories in the root directory (“/”). It uses the function to get the list of files and directories in the specified path and then prints the results.\n\nOS module provides different methods for removing directories and files in Python. These are –\n\nos.remove() method in Python is used to remove or delete a file path. This method can not remove or delete a directory. If the specified path is a directory then OSError will be raised by the method.\n\nExample: Suppose the file contained in the folder are:\n\n\n\nThis code removes a file named “file1.txt” from the specified location “D:/Pycharm projects/GeeksforGeeks/Authors/Nikhil/”. It uses the function to delete the file at the specified path.\n\nos.rmdir() method in Python is used to remove or delete an empty directory. OSError will be raised if the specified path is not an empty directory.\n\nExample: Suppose the directories are\n\nThis code attempts to remove a directory named “Geeks” located at “D:/Pycharm projects/”.\n\nIt uses the function to delete the directory. If the directory is empty, it will be removed. If it contains files or subdirectories, you may encounter an error.\n\nThis function gives the name of the operating system dependent module imported. The following names have currently been registered: ‘posix’, ‘nt’, ‘os2’, ‘ce’, ‘java’ and ‘riscos’.\n\nNote: It may give different output on different interpreters, such as ‘posix’ when you run the code here.\n\nAll functions in this module raise OSError in the case of invalid or inaccessible file names and paths, or other arguments that have the correct type, but are not accepted by the operating system. os.error is an alias for built-in OSError exception.\n\nThis code reads the contents of a file named ‘GFG.txt’. It uses a ‘try…except‘ block to handle potential errors, particularly the ‘IOError‘ that may occur if there’s a problem reading the file.\n\nIf an error occurs, it will print a message saying, “Problem reading: GFG.txt.”\n\nThis method opens a pipe to or from command. The return value can be read or written depending on whether the mode is ‘r’ or ‘w’. \n\nSyntax:\n\nParameters mode & bufsize are not necessary parameters, if not provided, default ‘r’ is taken for mode.\n\nThis code opens a file named ‘GFG.txt’ in write mode, writes “Hello” to it, and then reads and prints its contents. The use of is not recommended, and standard file operations are used for these tasks.\n\nNote: Output for popen() will not be shown, there would be direct changes into the file.\n\nClose file descriptor fd. A file opened using open(), can be closed by close()only. But file opened through os.popen(), can be closed with close() or os.close(). If we try closing a file opened with open(), using os.close(), Python would throw TypeError.\n\nNote: The same error may not be thrown, due to the non-existent file or permission privilege.\n\nA file old.txt can be renamed to new.txt, using the function os.rename(). The name of the file changes only if, the file exists and the user has sufficient privilege permission to change the file.\n\nA file name “GFG.txt” exists, thus when os.rename() is used the first time, the file gets renamed.\n\nUpon calling the function os.rename() second time, file “New.txt” exists and not “GFG.txt” thus Python throws FileNotFoundError.\n\nUsing the Os module we can remove a file in our system using the os.remove() method. To remove a file we need to pass the name of the file as a parameter.\n\nThe OS module provides us a layer of abstraction between us and the operating system.\n\nWhen we are working with os module always specify the absolute path depending upon the operating system the code can run on any os but we need to change the path exactly. If you try to remove a file that does not exist you will get FileNotFoundError.\n\nThis method will check whether a file exists or not by passing the name of the file as a parameter. OS module has a sub-module named PATH by using which we can perform many more functions.\n\nAs in the above code, the file does not exist it will give output False. If the file exists it will give us output True.\n\nIn os.path.getsize() function, python will give us the size of the file in bytes. To use this method we need to pass the name of the file as a parameter.\n\nWhat is the OS module in Python?\n\nWhat is an OS package?\n\nWhat is OS name in Python?\n\nWhat is the OS process in Python?"
    },
    {
        "link": "https://docs.python.org/3/library/filesys.html",
        "document": "The modules described in this chapter deal with disk files and directories. For example, there are modules for reading the properties of files, manipulating paths in a portable way, and creating temporary files. The full list of modules in this chapter is:\n\nOperating system interfaces, including functions to work with files at a lower level than Python file objects. Python’s built-in I/O library, including both abstract classes and some concrete classes such as file I/O. The standard way to open files for reading and writing with Python."
    },
    {
        "link": "https://python101.pythonlibrary.org/chapter16_os.html",
        "document": "The os module has many uses. We won’t be covering everything that it can do. Instead, we will get an overview of its uses and we’ll also take a look at one of its sub-modules, known as os.path. Specifically, we will be covering the following:\n\nThat looks like a lot to cover, but there is at least ten times as many other actions that the os module can do. This chapter is just going to give you a little taste of what’s available. To use any of the methods mentioned in this section, you will need to import the os module, like this:\n\nLet’s start learning how to use this module!\n\nThe os module has both callable functions and normal values. In the case of os.name, it is just a value. When you access os.name, you will get information about what platform you are running on. You will receive one of the following values: ‘posix’, ‘nt’, ‘os2’, ‘ce’, ‘java’, ‘riscos’. Let’s see what we get when we run it on Windows 7: This tells us that our Python instance is running on a Windows box. How do we know this? Because Microsoft started calling its operating system NT many years ago. For example, Windows 7 is also known as Windows NT 6.1.\n\nThe os.environ value is known as a mapping object that returns a dictionary of the user’s environmental variables. You may not know this, but every time you use your computer, some environment variables are set. These can give you valuable information, such as number of processors, type of CPU, the computer name, etc. Let’s see what we can find out about our machine: Your output won’t be the same as mine as everyone’s PC configuration is a little different, but you’ll see something similar. As you may have noticed, this returned a dictionary. That means you can access the environmental variables using your normal dictionary methods. Here’s an example: You could also use the os.getenv function to access this environmental variable: The benefit of using os.getenv() instead of the os.environ dictionary is that if you happen to try to access an environmental variable that doesn’t exist, the getenv function will just return None. If you did the same thing with os.environ, you would receive an error. Let’s give it a try so you can see what happens:\n\nThe os.chdir function allows us to change the directory that we’re currently running our Python session in. If you want to actually know what path you are currently in, then you would call os.getcwd(). Let’s try them both out: The code above shows us that we started out in the Python directory by default when we run this code in IDLE. Then we change folders using os.chdir(). Finally we call os.getcwd() a second time to make sure that we changed to the folder successfully.\n\nYou might have guessed this already, but the two methods covered in this section are used for creating directories. The first one is os.mkdir(), which allows us to create a single folder. Let’s try it out: The first line of code will create a folder named test in the current directory. You can use the methods in the previous section to figure out where you just ran your code if you’ve forgotten. The second example assigns a path to a variable and then we pass the path to os.mkdir(). This allows you to create a folder anywhere on your system that you have permission to. The os.makedirs() function will create all the intermediate folders in a path if they don’t already exist. Basically this means that you can created a path that has nested folders in it. I find myself doing this a lot when I create a log file that is in a dated folder structure, like Year/Month/Day. Let’s look at an example: What happened here? This code just created a bunch of folders! If you still had the pytest folder in your system, then it just added a 2014 folder with another folder inside of it which also contained a folder. Try it out for yourself using a valid path on your system.\n\nThe os.remove() and os.rmdir() functions are used for deleting files and directories respectively. Let’s look at an example of os.remove(): This code snippet will attempt to remove a file named test.txt from your current working directory. If it cannot find the file, you will likely receive some sort of error. You will also receive an error if the file is in use (i.e. locked) or you don’t have permission to delete the file. You might also want to check out os.unlink, which does the same thing. The term unlink is the traditional Unix name for this procedure. Now let’s look at an example of os.rmdir(): The code above will attempt to remove a directory named pytest from your current working directory. If it’s successful, you will see that the directory no longer exists. An error will be raised if the directory does not exist, you do not have permission to remove it or if the directory is not empty. You might also want to take a look at os.removedirs() which can remove nested empty directories recursively.\n\nThe os.walk() method gives us a way to iterate over a root level path. What this means is that we can pass a path to this function and get access to all its sub-directories and files. Let’s use one of the Python folders that we have handy to test this function with. We’ll use: C:\\Python27\\Tools If you want, you can also loop over dirs and files too. Here’s one way to do it: This piece of code will print a lot of stuff out, so I won’t be showing its output here, but feel free to give it a try. Now we’re ready to learn about working with paths!\n\nThe os.path sub-module of the os module has lots of great functionality built into it. We’ll be looking at the following functions: There are lots of other functions in this sub-module. You are welcome to go read about them in the Python documentation, section 10.1. The basename function will return just the filename of a path. Here is an example: I have found this useful whenever I need to use a filename for naming some related file, such as a log file. This happens a lot when I’m processing a data file. The dirname function will return just the directory portion of the path. It’s easier to understand if we take a look at some code: In this example, we just get the directory path back. This is also useful when you want to store other files next to the file you’re processing, like the aforementioned log file. The exists function will tell you if a path exists or not. All you have to do is pass it a path. Let’s take a look: In the first example, we pass the exists function a real path and it returns True, which means that the path exists. In the second example, we passed it a bad path and it told us that the path did not exist by returning False. The isdir and isfile methods are closely related to the exists method in that they also test for existence. However, isdir only checks if the path is a directory and isfile only checks if the path is a file. If you want to check if a path exists regardless of whether it is a file or a directory, then you’ll want to use the exists method. Anyway, let’s study some examples: Take a moment to study this set of examples. In the first one we pass a path to a file and check if the path is really a file. Then the second example checks the same path to see if it’s a directory. You can see for yourself how that turned out. Then in the last two examples, we switched things up a bit by passing a path to a directory to the same two functions. These examples demonstrate how these two functions work. The join method give you the ability to join one or more path components together using the appropriate separator. For example, on Windows, the separator is the backslash, but on Linux, the separator is the forward slash. Here’s how it works: In this example, we joined a directory path and a file path together to get a fully qualified path. Note however that the join method does not check if the result actually exists! The split method will split a path into a tuple that contains the directory and the file. Let’s take a look: This example shows what happens when we path in a path with a file. Let’s see what happens if the path doesn’t have a filename on the end: As you can see, it took the path and split it in such a way that the last sub-folder became the second element of the tuple with the rest of the path in the first element. For our final example, I thought you might like to see a commmon use case of the split: This shows how to do multiple assignment. When you split the path, it returns a two-element tuple. Since we have two variables on the left, the first element of the tuple is assigned to the first variable and the second element to the second variable."
    },
    {
        "link": "https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_csv.html",
        "document": "String, path object (implementing os.PathLike[str]), or file-like object implementing a write() function. If None, the result is returned as a string. If a non-binary file object is passed, it should be opened with , disabling universal newlines. If a binary file object is passed, might need to contain a .\n\nWrite out the column names. If a list of strings is given it is assumed to be aliases for the column names.\n\nColumn label for index column(s) if desired. If None is given, and and are True, then the index names are used. A sequence should be given if the object uses MultiIndex. If False do not print fields for index names. Use index_label=False for easier importing in R.\n\nFor on-the-fly compression of the output data. If ‘infer’ and ‘path_or_buf’ is path-like, then detect compression from the following extensions: ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, ‘.tar’, ‘.tar.gz’, ‘.tar.xz’ or ‘.tar.bz2’ (otherwise no compression). Set to for no compression. Can also be a dict with key set to one of { , , , , , } and other key-value pairs are forwarded to , , , , or , respectively. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: . May be a dict with key ‘method’ as compression mode and other entries as additional compression options if compression mode is ‘zip’. Passing compression options as keys in dict is supported for compression modes ‘gzip’, ‘bz2’, ‘zstd’, and ‘zip’.\n\nDefaults to csv.QUOTE_MINIMAL. If you have set a then floats are converted to strings and thus csv.QUOTE_NONNUMERIC will treat them as non-numeric.\n\nThe newline character or character sequence to use in the output file. Defaults to , which depends on the OS in which this method is called (’\n\n’ for linux, ‘\\r\n\n’ for Windows, i.e.). Changed in version 1.5.0: Previously was line_terminator, changed for consistency with read_csv and the standard library ‘csv’ module.\n\nExtra options that make sense for a particular storage connection, e.g. host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to as header options. For other URLs (e.g. starting with “s3://”, and “gcs://”) the key-value pairs are forwarded to . Please see and for more details, and for more examples on storage options refer here."
    },
    {
        "link": "https://pandas.pydata.org/pandas-docs/version/1.5/reference/api/pandas.DataFrame.to_csv.html",
        "document": "String, path object (implementing os.PathLike[str]), or file-like object implementing a write() function. If None, the result is returned as a string. If a non-binary file object is passed, it should be opened with , disabling universal newlines. If a binary file object is passed, might need to contain a . Changed in version 1.2.0: Support for binary file objects was introduced.\n\nWrite out the column names. If a list of strings is given it is assumed to be aliases for the column names.\n\nColumn label for index column(s) if desired. If None is given, and and are True, then the index names are used. A sequence should be given if the object uses MultiIndex. If False do not print fields for index names. Use index_label=False for easier importing in R.\n\nA string representing the encoding to use in the output file, defaults to ‘utf-8’. is not supported if is a non-binary file object.\n\nFor on-the-fly compression of the output data. If ‘infer’ and ‘path_or_buf’ is path-like, then detect compression from the following extensions: ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, ‘.tar’, ‘.tar.gz’, ‘.tar.xz’ or ‘.tar.bz2’ (otherwise no compression). Set to for no compression. Can also be a dict with key set to one of { , , , , } and other key-value pairs are forwarded to , , , or , respectively. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: . New in version 1.5.0: Added support for files. Changed in version 1.0.0: May now be a dict with key ‘method’ as compression mode and other entries as additional compression options if compression mode is ‘zip’. Changed in version 1.1.0: Passing compression options as keys in dict is supported for compression modes ‘gzip’, ‘bz2’, ‘zstd’, and ‘zip’. Changed in version 1.2.0: Compression is supported for binary file objects. Changed in version 1.2.0: Previous versions forwarded dict entries for ‘gzip’ to instead of which prevented setting .\n\nDefaults to csv.QUOTE_MINIMAL. If you have set a then floats are converted to strings and thus csv.QUOTE_NONNUMERIC will treat them as non-numeric.\n\nThe newline character or character sequence to use in the output file. Defaults to , which depends on the OS in which this method is called (’\n\n’ for linux, ‘\\r\n\n’ for Windows, i.e.). Changed in version 1.5.0: Previously was line_terminator, changed for consistency with read_csv and the standard library ‘csv’ module.\n\nExtra options that make sense for a particular storage connection, e.g. host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to as header options. For other URLs (e.g. starting with “s3://”, and “gcs://”) the key-value pairs are forwarded to . Please see and for more details, and for more examples on storage options refer here."
    },
    {
        "link": "https://pandas.pydata.org/docs/dev/reference/api/pandas.DataFrame.to_csv.html",
        "document": "String, path object (implementing os.PathLike[str]), or file-like object implementing a write() function. If None, the result is returned as a string. If a non-binary file object is passed, it should be opened with , disabling universal newlines. If a binary file object is passed, might need to contain a .\n\nWrite out the column names. If a list of strings is given it is assumed to be aliases for the column names.\n\nColumn label for index column(s) if desired. If None is given, and and are True, then the index names are used. A sequence should be given if the object uses MultiIndex. If False do not print fields for index names. Use index_label=False for easier importing in R.\n\nFor on-the-fly compression of the output data. If ‘infer’ and ‘path_or_buf’ is path-like, then detect compression from the following extensions: ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, ‘.tar’, ‘.tar.gz’, ‘.tar.xz’ or ‘.tar.bz2’ (otherwise no compression). Set to for no compression. Can also be a dict with key set to one of { , , , , , } and other key-value pairs are forwarded to , , , , or , respectively. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: . May be a dict with key ‘method’ as compression mode and other entries as additional compression options if compression mode is ‘zip’. Passing compression options as keys in dict is supported for compression modes ‘gzip’, ‘bz2’, ‘zstd’, and ‘zip’.\n\nDefaults to csv.QUOTE_MINIMAL. If you have set a then floats are converted to strings and thus csv.QUOTE_NONNUMERIC will treat them as non-numeric.\n\nThe newline character or character sequence to use in the output file. Defaults to , which depends on the OS in which this method is called (’\n\n’ for linux, ‘\\r\n\n’ for Windows, i.e.). Changed in version 1.5.0: Previously was line_terminator, changed for consistency with read_csv and the standard library ‘csv’ module.\n\nExtra options that make sense for a particular storage connection, e.g. host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to as header options. For other URLs (e.g. starting with “s3://”, and “gcs://”) the key-value pairs are forwarded to . Please see and for more details, and for more examples on storage options refer here."
    },
    {
        "link": "https://pandas.pydata.org/docs/dev/reference/api/pandas.Series.to_csv.html",
        "document": "String, path object (implementing os.PathLike[str]), or file-like object implementing a write() function. If None, the result is returned as a string. If a non-binary file object is passed, it should be opened with , disabling universal newlines. If a binary file object is passed, might need to contain a .\n\nWrite out the column names. If a list of strings is given it is assumed to be aliases for the column names.\n\nColumn label for index column(s) if desired. If None is given, and and are True, then the index names are used. A sequence should be given if the object uses MultiIndex. If False do not print fields for index names. Use index_label=False for easier importing in R.\n\nFor on-the-fly compression of the output data. If ‘infer’ and ‘path_or_buf’ is path-like, then detect compression from the following extensions: ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, ‘.tar’, ‘.tar.gz’, ‘.tar.xz’ or ‘.tar.bz2’ (otherwise no compression). Set to for no compression. Can also be a dict with key set to one of { , , , , , } and other key-value pairs are forwarded to , , , , or , respectively. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: . May be a dict with key ‘method’ as compression mode and other entries as additional compression options if compression mode is ‘zip’. Passing compression options as keys in dict is supported for compression modes ‘gzip’, ‘bz2’, ‘zstd’, and ‘zip’.\n\nDefaults to csv.QUOTE_MINIMAL. If you have set a then floats are converted to strings and thus csv.QUOTE_NONNUMERIC will treat them as non-numeric.\n\nThe newline character or character sequence to use in the output file. Defaults to , which depends on the OS in which this method is called (’\n\n’ for linux, ‘\\r\n\n’ for Windows, i.e.). Changed in version 1.5.0: Previously was line_terminator, changed for consistency with read_csv and the standard library ‘csv’ module.\n\nExtra options that make sense for a particular storage connection, e.g. host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to as header options. For other URLs (e.g. starting with “s3://”, and “gcs://”) the key-value pairs are forwarded to . Please see and for more details, and for more examples on storage options refer here."
    },
    {
        "link": "http://pandas.pydata.org/pandas-docs/version/1.5.0/reference/api/pandas.Series.to_csv.html",
        "document": "String, path object (implementing os.PathLike[str]), or file-like object implementing a write() function. If None, the result is returned as a string. If a non-binary file object is passed, it should be opened with , disabling universal newlines. If a binary file object is passed, might need to contain a . Changed in version 1.2.0: Support for binary file objects was introduced.\n\nWrite out the column names. If a list of strings is given it is assumed to be aliases for the column names.\n\nColumn label for index column(s) if desired. If None is given, and and are True, then the index names are used. A sequence should be given if the object uses MultiIndex. If False do not print fields for index names. Use index_label=False for easier importing in R.\n\nA string representing the encoding to use in the output file, defaults to ‘utf-8’. is not supported if is a non-binary file object.\n\nFor on-the-fly compression of the output data. If ‘infer’ and ‘path_or_buf’ is path-like, then detect compression from the following extensions: ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, ‘.tar’, ‘.tar.gz’, ‘.tar.xz’ or ‘.tar.bz2’ (otherwise no compression). Set to for no compression. Can also be a dict with key set to one of { , , , , } and other key-value pairs are forwarded to , , , or , respectively. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: . New in version 1.5.0: Added support for files. Changed in version 1.0.0: May now be a dict with key ‘method’ as compression mode and other entries as additional compression options if compression mode is ‘zip’. Changed in version 1.1.0: Passing compression options as keys in dict is supported for compression modes ‘gzip’, ‘bz2’, ‘zstd’, and ‘zip’. Changed in version 1.2.0: Compression is supported for binary file objects. Changed in version 1.2.0: Previous versions forwarded dict entries for ‘gzip’ to instead of which prevented setting .\n\nDefaults to csv.QUOTE_MINIMAL. If you have set a then floats are converted to strings and thus csv.QUOTE_NONNUMERIC will treat them as non-numeric.\n\nThe newline character or character sequence to use in the output file. Defaults to , which depends on the OS in which this method is called (’\n\n’ for linux, ‘\\r\n\n’ for Windows, i.e.). Changed in version 1.5.0: Previously was line_terminator, changed for consistency with read_csv and the standard library ‘csv’ module.\n\nExtra options that make sense for a particular storage connection, e.g. host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to as header options. For other URLs (e.g. starting with “s3://”, and “gcs://”) the key-value pairs are forwarded to . Please see and for more details, and for more examples on storage options refer here."
    }
]