[
    {
        "link": "https://typescriptlang.org/docs/handbook/2/modules.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/48165514/how-to-export-an-array-in-typescript",
        "document": "In an Angular4 app, I use a service to export some constants, enums and interfaces used all across the application. I'd like to export an array of strings whose keys are the keys in an anum. This is what I have right now:\n\nI'd like to export an array of strings based on the values of the enum above, like this:\n\nI've tried using as suggested in a forum, but when I try to import it from a component like this:\n\nThe compiler complains that the module 'app-options.service has no exported member ObjectStyles'.\n\nAnother proposed solution was to export ObjectStyles like this:\n\nIn this case, the compiler doesn't complain, but the app crashes at runtime with the following error:\n\nHow could I do what I want? Thanks!"
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html",
        "document": "Comparing JavaScript to an example DTS\n\nA module using CommonJS patterns uses to describe the exported values. For example, here is a module which exports a function and a numerical constant:\n\nThis can be described by the following :\n\nThe TypeScript playground can show you the equivalent for JavaScript code. You can try it yourself here.\n\nThe syntax intentionally looks like ES Modules syntax. ES Modules was ratified by TC39 in 2015 as part of ES2015 (ES6), while it has been available via transpilers for a long time, however if you have a JavaScript codebase using ES Modules:\n\nThis would have the following equivalent:\n\nIn CommonJS you can export any value as the default export, for example here is a regular expression module:\n\nWhich can be described by the following .d.ts:\n\nOne style of exporting in CommonJS is to export a function. Because a function is also an object, then extra fields can be added and are included in the export.\n\nWhich can be described with:\n\nSee Module: Functions for details of how that works, and the Modules reference page.\n\nThere are many ways to import a module in modern consuming code:\n\nCovering all of these cases requires the JavaScript code to actually support all of these patterns. To support many of these patterns, a CommonJS module would need to look something like:\n\nYou may want to provide a type for JavaScript code which does not exist\n\nThis can be described with:\n\nThis example is a good case for using generics to provide richer type information:\n\nNow the type of the array propagates into the type.\n\nThe types which are exported can then be re-used by consumers of the modules using either or in TypeScript code or JSDoc imports.\n\nTrying to describe the runtime relationship of JavaScript code can be tricky. When the ES Module-like syntax doesn’t provide enough tools to describe the exports then you can use .\n\nFor example, you may have complex enough types to describe that you choose to namespace them inside your :\n\nTo understand how namespaces work in files read the deep dive.\n\nYou can use to declare that your module will be available in the global scope in UMD contexts:\n\nTo give you an idea of how all these pieces can come together, here is a reference to start with when making a new module\n\nThe layout of your declaration files should mirror the layout of the library.\n\nA library can consist of multiple modules, such as\n\nThese could be imported as\n\nYour declaration files should thus be\n\nIf you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:"
    },
    {
        "link": "https://stackoverflow.com/questions/15651510/can-typescript-export-a-function",
        "document": "It's hard to tell what you're going for in that example. is about exporting from external modules, but the code sample you linked is an internal module.\n\nRule of thumb: If you write , you're writing an internal module; if you write at top-level in a file, you're writing an external module. It's somewhat rare that you'd actually write at top-level (since then you'd be double-nesting the name), and it's even rarer that you'd write in a file that had a top-level export (since would not be externally visible).\n\nThe following things make sense (each scenario delineated by a horizontal rule):"
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/modules/reference.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/62823261/how-to-generate-array-of-n-equidistant-points-along-a-line-segment-of-length-x",
        "document": "I ported this function from a python answer to a similar question on this site. However, although the points are equidistant from each other, they are not centered on the line.\n\nThe first point is at while the last is at (the end of the line segment is ).\n\nHow do I center this row of points?\n\nSpecifically, I want the first point to be the same distance from that the last point is from .\n\nI tried this, but it doesn't appear to work as I expected:\n\nThe first point is away from , but the last point is away from ."
    },
    {
        "link": "https://stackoverflow.com/questions/56098263/how-to-generate-a-line-with-exact-number-of-points",
        "document": "I have to generate a path from a dataset of n points. I am plotting a cubic spline through the points in this dataset. The generated path must contain an exact number of projected path-points.\n\nMy problem is not with the plotting of the curve but rather with the distribution of the path-points along the x-axis to yield a path that is made up of an exact number of path-points. This is why I have reduced the following example to a one dimensional array of points through which a straight line should be plotted. Each point in the dataset should represent the beginning of a curve segment (even though the curve is really a line because of the simplification).\n\nMy current naive approach is not exact ie it does not yield a path that contains the specified number of points (it's off by 4-5 points depending on the density of the dataset and the specified targetLength).\n\nI think I'll have to use linear interpolation to get an exact result but I don't know how. Can anyone help or point me in the right direction?\n\nIn the above example I expect path.length to equal targetLength (1024). I could take the generated path as a whole and interpolate the entire array but I think I'm looking for a smarter way to generate the path in the first place. Any help is greatly appreciated!"
    },
    {
        "link": "https://tutorialspoint.com/how-to-generate-array-of-n-equidistant-points-along-a-line-segment-of-length-x-with-javascript",
        "document": "How to generate array of n equidistant points along a line segment of length x with JavaScript?\n\nTo generate array of n equidistant points along a line segment of length x, use the below syntax −\n\nTo run the above program, you need to use the following command −\n\nHere, my file name is demo53.js\n\nThis will produce the following output −"
    },
    {
        "link": "https://geeksforgeeks.org/computer-graphics-circle-generation-algorithm",
        "document": "Computer graphics provide a powerful tool for creating and manipulating graphical objects such as lines, circles, and polygons. A circle is one of the fundamental shapes used in computer graphics and it is generated through a circle generation algorithm. A circle generation algorithm is an algorithm used to create a circle on a computer screen. It is used in various applications such as computer-aided design (CAD) software, animation software, games, and scientific visualization.\n\nThere are several algorithms used for generating circles on a computer screen. These algorithms can be divided into two main categories: analytical algorithms and iterative algorithms.\n\nAnalytical algorithms are algorithms that use mathematical equations to generate a circle. These algorithms have the advantage of being fast and accurate but they have the disadvantage of being more complex to understand and implement. The two main analytical algorithms used for circle generation are the midpoint circle algorithm and Bresenham’s circle algorithm.\n\nThe midpoint circle algorithm is the most commonly used analytical algorithm for circle generation. It is based on the midpoint theorem which states that if the points along the circumference of a circle are equidistant from the center of the circle, then the points will lie on the circle. The algorithm uses this theorem to generate a circle by calculating the points which are equidistant from the center of the circle and then connecting the points to form a circle.\n\nBresenham’s circle algorithm is an extension of the midpoint circle algorithm. It uses the same midpoint theorem but instead of calculating the points which are equidistant from the center of the circle, it uses an iterative approach to calculate the points. This algorithm is more efficient than the midpoint circle algorithm and is often used for generating circles in computer graphics.\n\nIterative algorithms are algorithms that use an iterative approach to generate a circle. These algorithms are simpler to understand and implement but they are slower and less accurate than the analytical algorithms.\n\nThe two main iterative algorithms used for circle generation are the polar coordinates algorithm and the incremental algorithm.\n\nThe polar coordinates algorithm is an iterative algorithm that uses the fact that a circle can be represented as a set of points in polar coordinates. The algorithm uses the polar coordinates of the points along the circumference of the circle to calculate the points and then connects the points to form a circle.\n\nThe incremental algorithm is an iterative algorithm that uses an iterative approach to generate a circle. It starts with the center of the circle and then calculates the points along the circumference of the circle by incrementally increasing the angle. The algorithm then connects the points to form a circle.\n\nCircle generation algorithms are used for creating circles on a computer screen. These algorithms can be divided into two main categories: analytical algorithms and iterative algorithms. Each algorithm has its own advantages and disadvantages and the choice of algorithm depends on the application."
    },
    {
        "link": "https://ghost-together.medium.com/how-to-code-your-first-algorithm-draw-a-line-ca121f9a1395",
        "document": "I think it’s a perfect specimen to learn from for many reasons:\n• It’s rewarding — you don’t just crunch numbers but also see visual results.\n• It’s relatively simple as your first example to study algorithms from.\n• It uses the Cartesian Coordinate System — the one used as the basis in many popular algorithms. It’s prerequisite to Machine Learning (which uses so called activation functions in AI, which are CCS-based math equations.)\n• You can implement it in JavaScript (see the live demo here.)\n\nDo you ever have a project you always lay off for later? You know - that one idea you wish you had coded but you can’t because you are currently in the middle of something more important?\n\nWell, drawing a line in HTML without canvas was something on my mind for over a year. And I finally decided to make this tutorial on the subject!\n\nBy the way you can follow me on Twitter for more freemium tutorials.\n\nCheck out this line drawing demo live in action on a sample page I created.\n\nThe above is the result of the algorithm explained in this tutorial. A line is drawn between two points on a typical raster display. In this case, I used a simple HTML grid made up of DIV elements. It’s kind of slow, and not suitable for high-performance graphics rendering in real-time, but it clearly demonstrates the purpose of this algorithm!\n\nHow would something like this work? I created this demo screenshot to show the basic idea in action. Given any two end points — we can render a line on a raster display.\n\nIn this case, it’s represented by a simple HTML grid made out of DIV elements!\n\nHow Does It Work?\n\nFirst, it’s best to visualize what it is you’re trying to accomplish.\n\nBresenham’s algorithm solves the problem of drawing lines in Quadrant 1:\n\nDrawing a line in any direction requires thinking in quadrants.\n\nWhile the algorithm for Quadrant 1 is simple — implementation for all quadrants (and octants) is tricky. But only logistically. The rest of the cases are simple mirror images of the two octants in Quadrant 1.\n\nThis means that instead of reinventing the wheel all you have to do is swap some variables around or flip their sign here and there.\n\nThe problem is — how do we code that in JavaScript?\n\nWhy Draw Lines in HTML Without Canvas?\n\nTo provide a clear explanation of how Bresenham’s drawing algorithm works.\n\nMany Bresenham’s line drawing tutorials I came across only explained mathematical derivations. But they didn’t go into much detail about code for each octant or physically implementing the demo. It just felt like implementing something you don’t really understand.\n\nIt’s simple — some things are just fun. I mean, wouldn’t it be great to draw lines in HTML without using canvas or WebGL? In this line drawing tutorial I will write a JavaScript class that handles instantiation of a single HTML line. You can spawn as many as you like.\n\nI come from a game development background. And in games you often deal with drawing lines. But beyond that, I always found the idea of drawing lines in HTML fascinating. Probably because I’ve never seen it done before.\n\nOf course, raw HTML rendering speed will be an issue. And yes, further optimizations will be required to achieve meaningful performance. But the focus of this line drawing tutorial is primarily set on the line drawing algorithm explanation itself. You can always re-implement it in any other raster environment or graphics library.\n\nWe take two deltas and calculate the slope of the line equation, based on two end points of the line.\n\nThe starting and ending points of the line are provided to the four parameters of the draw_line function ([x0, y0] and [x1, y1] respectively).\n\nYou can implement this in C, C++, Python, Java or any other language. In this tutorial, of course, we will use JavaScript.\n\nAfter we get a good grasp on the algorithm visually, it’s time to start converting the logic into code.\n\nHere is the pseudo code:\n\nConverting it to JavaScript, we get the following:\n\nNote that all this is only for Quadrant 1.\n\nFirst we calculate the difference between the line’s end points on both axes (dx and dy) which are usually referred to as the deltas — for each of the two dimensions, respectively.\n\nThen we calculate the delta of the line as a whole (here stored in variable D) — you can think of it as the mathematical equation for drawing a line. Or in other words the line slope equation.\n\nBefore iterating through each span of the line, let’s reset the y-axis counter (that we will walk using a for-loop, as the line is being drawn) by setting it to the initial position on the line. Here y0 refers to the Y coordinate of the first point on the line.\n\nFinally, draw the line one “pixel” at a time, in pseudo code shown as pixel(x, y) function. Once the pixel is rendered, we can adjust the current pixel position using the delta steps we calculated.\n\nEvery time the delta counter exceeds 0 we step down to the next pixel on the Y-axis and adjust the D variable again but in the opposite dimension, which ends up in progressively drawing the line across both dimensions until we reach the line’s end.\n\nBut that’s not everything. In addition, depending on axis-dominance, the for-loop must be modified to travel in that direction. To complete the algorithm, we must also adjust parameters based on what octant (out of eight) we are in. This is explained in detail in the following section.\n\nThe barebones Bresenham’s line algorithm above is designed to draw a line only in one quadrant (Quadrant 1) of the Cartesian coordinate system. But we need to cover all directions. After all, a random line can be plotted from any point on the raster screen to any other point.\n\nThis means that in addition to the pseudo code above, we need to take care of two other things:\n• Quadrant-Aware Algorithm. The algorithm must adjust iterator parameters, for each of the four quadrants. We can swap line endpoints to make sure that we always draw the line from left to right, and split the algorithm in two main parts (line is pointing either up or down from the starting point.) Or we can branch out in four different cases, for each quadrant respectively, and just swap x-axis and y-axis iterators to accommodate for line direction.\n• Axis-Dominance. But even in each of the four quadrants, the line will either be x-axis or y-axis dominant. This means there are actually not four but eight different cases. One for each of the eight octants. Luckily, the algorithm stays exactly the same, all we need to do is switch the iterators and branch out a few times.\n\nThat’s a lot of branching out. But the algorithm presented in the following example will take care of all possible cases.\n\nOkay — all of this sounds great in theory — and we already covered the pseudo code and JavaScript version — but only for one quadrant! Let’s take a look at the whole enchilada.\n\nThis is just one way of writing the Bresenham’s line drawing algorithm. You can juggle around parameters and improvise on branching out. But the basic idea is there.\n\nThe main if-statement branches out between two potential axis-dominance cases.\n\nThe code is octant-aware — within the two if-statement scopes you will also see that the code basically mirrors itself between the X and Y axis (tracked by variables px and py) but the algorithm logic is pretty much identical otherwise.\n\nRemember, we are not using canvas or any other graphics library when writing our own graphics algorithms.\n\nThis means the actual medium in which you choose to draw the data depends entirely on you. In this demo I used a basic DIV grid.\n\nThis function pixel(x, y) is how you choose to implement the drawing of the line based on what type of raster display you will use.\n\nIt basically puts a “pixel” at X and Y location on the “screen” / render output.\n\nOften, people ask me how to improve their coding skills. I usually suggest choosing a project slightly above the range of your current ability. If you make sure to finish it, this experience will help you advance your coding skills. For me, this was that type of project.\n\nStill available — Grab a copy of CSS Visual Dictionary here in PDF format."
    }
]