[
    {
        "link": "https://cpcwiki.eu/imgs/e/e3/8253.pdf",
        "document": ""
    },
    {
        "link": "https://tutorialspoint.com/microprocessor/microprocessor_intel_8253_programmable_interval_timer.htm",
        "document": "The Intel 8253 and 8254 are Programmable Interval Timers (PTIs) designed for microprocessors to perform timing and counting functions using three 16-bit registers. Each counter has 2 input pins, i.e. Clock & Gate, and 1 pin for OUT output. To operate a counter, a 16-bit count is loaded in its register. On command, it begins to decrement the count until it reaches 0, then it generates a pulse that can be used to interrupt the CPU.\n\nThe following table differentiates the features of 8253 and 8254 −\n\nThe most prominent features of 8253/54 are as follows −\n• None It has three independent 16-bit down counters.\n• None It can handle inputs from DC to 10 MHz.\n• None These three counters can be programmed for either binary or BCD count.\n• None It is compatible with almost all microprocessors.\n• None 8254 has a powerful command called READ BACK command, which allows the user to check the count value, the programmed mode, the current mode, and the current status of the counter.\n\nThe architecture of 8254 looks as follows −\n\nHere is the pin diagram of 8254 −\n\nIn the above figure, there are three counters, a data bus buffer, Read/Write control logic, and a control register. Each counter has two input signals - CLOCK & GATE, and one output signal - OUT.\n\nIt is a tri-state, bi-directional, 8-bit buffer, which is used to interface the 8253/54 to the system data bus. It has three basic functions −\n\nIt includes 5 signals, i.e. RD, WR, CS, and the address lines A & A . In the peripheral I/O mode, the RD and WR signals are connected to IOR and IOW, respectively. In the memorymapped I/O mode, these are connected to MEMR and MEMW.\n\nAddress lines A & A of the CPU are connected to lines A and A of the 8253/54, and CS is tied to a decoded address. The control word register and counters are selected according to the signals on lines A & A .\n\nThis register is accessed when lines A & A are at logic 1. It is used to write a command word, which specifies the counter to be used, its mode, and either a read or write operation. Following table shows the result for various control inputs.\n\nEach counter consists of a single, 16 bit-down counter, which can be operated in either binary or BCD. Its input and output is configured by the selection of modes stored in the control word register. The programmer can read the contents of any of the three counters without disturbing the actual count in process."
    },
    {
        "link": "https://gacbe.ac.in/pdf/ematerial/18BCS37S-U4.pdf",
        "document": ""
    },
    {
        "link": "https://advdownload.advantech.com/productfile/Downloadfile2/1+GC+2976/ch8.pdf",
        "document": ""
    },
    {
        "link": "https://scribd.com/document/306731594/Real-Time-Clock-Using-8253",
        "document": "The document describes using an 8253 Programmable Interval Timer chip to implement a real-time clock for a microcomputer system. It discusses interfacing the 8253 chip to an 8086 microprocessor system, programming the chip to select counters and set operating modes, and using one counter configured in binary mode to generate interrupts to update hours, minutes, and seconds displayed on 7-segment displays. Connecting Counter 0's output to the microprocessor's NMI input allows it to interrupt the CPU regularly to increment the displayed time."
    },
    {
        "link": "https://harshityadav95.medium.com/microprocessor-and-interfacing-ef9c2b116382",
        "document": "\n• CS(bar): Chip select \n\n To access this chip, is made low. A LOW on this pin enables & communication between the CPU and the 8259A. \n\nThis pin is connected to address bus through the decoder logic circuits. INTA functions are independent of .\n• WR(bar)\n\nA low on this pin. When is low enables the 8259 A to accept \n\ncommand words from CPU.\n• RD(bar):\n\nA low on this pin when (CS)is low enables these 8259 A to release \n\nstatus on to the data bus for the CPU.\n\nBidirectional data bus control status and interrupt in a this bus. This bus is connected to BDB of 8085. CAS0-CAS2:\n\nThe CAS lines form a private 8259A bus to control a multiple 8259A structure ie to identify a particular slave device. These pins are outputs of a master 8259A and inputs for a slave 8259A. /\n\n6. SPEN : Salve program/enable buffer: \n\nThis is a dual function pin. It is used as an input to determine whether the 8259A is to a master (SP /EN = 1) or as a slave ( SP/EN = 0). It is \n\nalso used as an output to disable the data bus transceivers when data are being transferred from the 8259A to the CPU. When in buffered mode, it can be used as an output and when not in the buffered mode it is used as an input.\n\n7.INT: This pin goes high whenever a valid interrupt request is asserted. It is used to interrupt the CPU, thus it is connected to the CPU’s interrupt pin 7(INTR). :\n\n8.(INTA)Interrupt: Acknowledge. This pin is used to enable 8259A interrupt vector data on the data bus by a sequence of interrupt request pulses issued by the CPU.\n\nAsynchronous interrupt inputs. An interrupt request is executed by raising an IR input (low to high), and holding it high until it is acknowledged. (Edge triggered mode).or just by a high level on an IR input (levels triggered mode).\n\n10. A0: A0 address line: This pin acts in conjunction with the RD,WR & CS pins. It is used by the 8259A to send various command words from the CPU and to read the status. If is connected to the CPU A0 address line. Two addresses must be reserved in the I/O address space for each 8259 in the system.\n• Data bus buffer: \n\nThis 3- state, bidirectional 8-bit buffer is used to interface the 8259A to the system data bus. Control words and status information are transferred through the data bus buffer.\n\n2.Read/Write & control logic: \n\nThe function of this block is to accept OUTPUT commands from the CPU. It contains the initialization command word (ICW) register and operation command word (OCW) register which store the various control formats for device operation. This function block also allows the status of 8159A to be transferred to the data bus.\n\n3. Interrupt request register (IRR): \n\nIRR stores all the interrupt inputs that are requesting service. Basically, it keeps track of which interrupt inputs are asking for service. If an interrupt input is unmasked, and has an interrupt signal on it, then the corresponding bit in the IRR will be set.\n\n4. Interrupt mask register (IMR): \n\nThe IMR is used to disable (Mask) or enable (Unmask) individual interrupt inputs. Each bit in this register corresponds to the interrupt input with the same number. The IMR operation on the IRR. Masking of higher priority input will not affect the interrupt request lines of lower priority. To unmask any interrupt the corresponding bit is set ‘0’.\n\n5.In service register (ISR): \n\nThe in service registers keeps tracks of which interrupt inputs are currently being serviced. For each input that is currently being serviced the corresponding bit will be set in the in service register. Each of these 3-reg can be read as status reg.\n\n6.Priority Resolver: \n\nThis logic block determines the priorities of the set in the IRR. The highest priority is selected and strobed into the corresponding bit of the ISR during (INTA)pulse.\n\n7.Cascade buffer/comparator: \n\nThis function blocks stores and compare the IDS of all 8259A’s in the reg. The associated 3-I/O pins (CAS0-CAS2) are outputs when \n\n8259A is used a master. Master and are inputs when 8259A is used as a slave. As a master, the 8259A sends the ID of the interrupting slave device onto the cas2-cas0. The slave thus selected will send its pre-programmed subroutine address on to the data bus during the next one or two successive(INTA) pulses\n\nUsing a DMA controller, the device requests the CPU to hold its data, address and control bus, so the device is free to transfer data directly to/from the memory. The DMA data transfer is initiated only after receiving HLDA signal from the CPU.\n\nFollowing is the sequence of operations performed by a DMA\n• Initially, when any device has to send data between the device and the memory, the device has to send DMA request (DRQ) to DMA controller.\n• The DMA controller sends Hold request (HRQ) to the CPU and waits for the CPU to assert the HLDA.\n• Then the microprocessor tri-states all the data bus, address bus, and control bus. The CPU leaves the control over bus and acknowledges the HOLD request through HLDA signal.\n• Now the CPU is in HOLD state and the DMA controller has to manage the operations over buses between the CPU, memory, and I/O devices.\n\nHere is a list of some of the prominent features of 8257 âˆ’\n• It has four channels which can be used over four I/O devices.\n• Each channel has 16-bit address and 14-bit counter.\n• Each channel can transfer data up to 64kb.\n• Each channel can be programmed independently.\n• Each channel can perform read transfer, write transfer and verify transfer operations.\n• It generates MARK signal to the peripheral device that 128 bytes have been transferred.\n• Its frequency ranges from 250Hz to 3MHz.\n• It operates in 2 modes, i.e., Master mode and Slave mode.\n\nThe following image shows the architecture of 8257 âˆ’\n\nThe following image shows the pin diagram of a 8257 DMA controller\n\nThe following image depicts the pin diagram of 8085 Microprocessor âˆ’\n\nThe pins of a 8085 microprocessor can be classified into seven groups âˆ’\n\nA15-A8, it carries the most significant 8-bits of memory/IO address.\n\nAD7-AD0, it carries the least significant 8-bit address and data bus.\n\nThese signals are used to identify the nature of operation. There are 3 control signal and 3 status signals.\n• RDÂ âˆ’ This signal indicates that the selected IO or memory device is to be read and is ready for accepting data available on the data bus.\n• WRÂ âˆ’ This signal indicates that the data on the data bus is to be written into a selected memory or IO location.\n• ALEÂ âˆ’ It is a positive going pulse generated when a new operation is started by the microprocessor. When the pulse goes high, it indicates address. When the pulse goes down it indicates data.\n\nThis signal is used to differentiate between IO and Memory operations, i.e. when it is high indicates IO operation and when it is low then it indicates memory operation.\n\nThese signals are used to identify the type of current operation.\n\nThere are 2 power supply signals âˆ’ VCC & VSS. VCC indicates +5v power supply and VSS indicates ground signal.\n\nThere are 3 clock signals, i.e. X1, X2, CLK OUT.\n• X1, X2Â âˆ’ A crystal (RC, LC N/W) is connected at these two pins and is used to set frequency of the internal clock generator. This frequency is internally divided by 2.\n• CLK OUTÂ âˆ’ This signal is used as the system clock for devices connected with the microprocessor.\n\nInterrupts are the signals generated by external devices to request the microprocessor to perform a task. There are 5 interrupt signals, i.e. TRAP, RST 7.5, RST 6.5, RST 5.5, and INTR. We will discuss interrupts in detail in interrupts section.\n• INTAÂ âˆ’ It is an interrupt acknowledgment signal.\n• RESET INÂ âˆ’ This signal is used to reset the microprocessor by setting the program counter to zero.\n• RESET OUTÂ âˆ’ This signal is used to reset all the connected devices when the microprocessor is reset.\n• READYÂ âˆ’ This signal indicates that the device is ready to send or receive data. If READY is low, then the CPU has to wait for READY to go high.\n• HOLDÂ âˆ’ This signal indicates that another master is requesting the use of the address and data buses.\n• HLDA (HOLD Acknowledge)Â âˆ’ It indicates that the CPU has received the HOLD request and it will relinquish the bus in the next clock cycle. HLDA is set to low after the HOLD signal is removed.\n\nThere are 2 serial signals, i.e. SID and SOD and these signals are used for serial communication.\n• SODÂ (Serial output data line) âˆ’ The output SOD is set/reset as specified by the SIM instruction.\n• SIDÂ (Serial input data line) âˆ’ The data on this line is loaded into accumulator whenever a RIM instruction is executed.\n\nNow let us discuss the addressing modes in 8085 Microprocessor.\n\nThese are the instructions used to transfer the data from one register to another register, from the memory to the register, and from the register to the memory without any alteration in the content. Addressing modes in 8085 is classified into 5 groups âˆ’\n\nIn this mode, the 8/16-bit data is specified in the instruction itself as one of its operand.Â For example:Â MVI K, 20F: means 20F is copied into register K.\n\nIn this mode, the data is copied from one register to another.Â For example:Â MOV K, B: means data in register B is copied to register K.\n\nIn this mode, the data is directly copied from the given address to the register.Â For example:Â LDB 5000K: means the data at address 5000K is copied to register B.\n\nIn this mode, the data is transferred from one register to another by using the address pointed by the register.Â For example:Â MOV K, B: means data is transferred from the memory address pointed by the register to the register K.\n\nThis mode doesnâ€™t require any operand; the data is specified by the opcode itself.Â For example:Â CMP.\n\nInterrupts are the signals generated by the external devices to request the microprocessor to perform a task. There are 5 interrupt signals, i.e. TRAP, RST 7.5, RST 6.5, RST 5.5, and INTR.\n\nInterrupt are classified into following groups based on their parameter âˆ’\n• Vector interruptÂ âˆ’ In this type of interrupt, the interrupt address is known to the processor.Â For example:Â RST7.5, RST6.5, RST5.5, TRAP.\n• Non-Vector interruptÂ âˆ’ In this type of interrupt, the interrupt address is not known to the processor so, the interrupt address needs to be sent externally by the device to perform interrupts.Â For example:Â INTR.\n• Maskable interruptÂ âˆ’ In this type of interrupt, we can disable the interrupt by writing some instructions into the program.Â For example:Â RST7.5, RST6.5, RST5.5.\n• Non-Maskable interruptÂ âˆ’ In this type of interrupt, we cannot disable the interrupt by writing some instructions into the program.Â For example:Â TRAP.\n• Software interruptÂ âˆ’ In this type of interrupt, the programmer has to add the instructions into the program to execute the interrupt. There are 8 software interrupts in 8085, i.e. RST0, RST1, RST2, RST3, RST4, RST5, RST6, and RST7.\n• Hardware interruptÂ âˆ’ There are 5 interrupt pins in 8085 used as hardware interrupts, i.e. TRAP, RST7.5, RST6.5, RST5.5, INTA.\n\nNoteÂ âˆ’ NTA is not an interrupt, it is used by the microprocessor for sending acknowledgement. TRAP has the highest priority, then RST7.5 and so on.\n\nA small program or a routine that when executed, services the corresponding interrupting source is called an ISR.\n\nIt is a non-maskable interrupt, having the highest priority among all interrupts. Bydefault, it is enabled until it gets acknowledged. In case of failure, it executes as ISR and sends the data to backup memory. This interrupt transfers the control to the location 0024H.\n\nIt is a maskable interrupt, having the second highest priority among all interrupts. When this interrupt is executed, the processor saves the content of the PC register into the stack and branches to 003CH address.\n\nIt is a maskable interrupt, having the third highest priority among all interrupts. When this interrupt is executed, the processor saves the content of the PC register into the stack and branches to 0034H address.\n\nIt is a maskable interrupt. When this interrupt is executed, the processor saves the content of the PC register into the stack and branches to 002CH address.\n\nIt is a maskable interrupt, having the lowest priority among all interrupts. It can be disabled by resetting the microprocessor.\n\nWhenÂ INTR signal goes high, the following events can occur âˆ’\n• The microprocessor checks the status of INTR signal during the execution of each instruction.\n• When the INTR signal is high, then the microprocessor completes its current instruction and sends active low interrupt acknowledge signal.\n• When instructions are received, then the microprocessor saves the address of the next instruction on stack and executes the received instruction\n\nLet us take a look at the programming of 8085 Microprocessor.\n\nInstruction sets are instruction codes to perform some task. It is classified into five categories.\n\nS.No.Instruction & Description1Control InstructionsFollowing is the table showing the list of Control instructions with their meanings.\n\n2Logical InstructionsFollowing is the table showing the list of Logical instructions with their meanings.\n\n3Branching InstructionsFollowing is the table showing the list of Branching instructions with their meanings.\n\n4Arithmetic InstructionsFollowing is the table showing the list of Arithmetic instructions with their meanings.\n\n5Data Transfer InstructionsFollowing is the table showing the list of Data-transfer instructions with their meanings.\n\nNow, let us take a look at some program demonstrations using the above instructions âˆ’\n\nWrite a program to add data at 3005H & 3006H memory location and store the result at 3007H memory location.\n\nThe program code can be written like this âˆ’\n\nWrite a program to exchange the data at 5000M& 6000M memory location.\n\nWrite a program to arrange first 10 numbers from memory address 3000H in an ascending order.\n\nThe following diagram depicts the architecture of a 8086 Microprocessor âˆ’\n\n8086 Microprocessor is divided into two functional units, i.e.,Â EUÂ (Execution Unit) andÂ BIUÂ (Bus Interface Unit).\n\nExecution unit gives instructions to BIU stating from where to fetch the data and then decode and execute those instructions. Its function is to control operations on data using the instruction decoder & ALU. EU has no direct connection with system buses as shown in the above figure, it performs operations over data through BIU.\n\nLet us now discuss the functional parts of 8086 microprocessors.\n\nIt handles all arithmetic and logical operations, like +, âˆ’, Ã — , /, OR, AND, NOT operations.\n\nIt is a 16-bit register that behaves like a flip-flop, i.e. it changes its status according to the result stored in the accumulator. It has 9 flags and they are divided into 2 groups âˆ’ Conditional Flags and Control Flags.\n\nIt represents the result of the last arithmetic or logical instruction executed. Following is the list of conditional flags âˆ’\n• Carry flagÂ âˆ’ This flag indicates an overflow condition for arithmetic operations.\n• Auxiliary flagÂ âˆ’ When an operation is performed at ALU, it results in a carry/barrow from lower nibble (i.e. D0 â€“ D3) to upper nibble (i.e. D4 â€“ D7), then this flag is set, i.e. carry given by D3 bit to D4 is AF flag. The processor uses this flag to perform binary to BCD conversion.\n• Parity flagÂ âˆ’ This flag is used to indicate the parity of the result, i.e. when the lower order 8-bits of the result contains even number of 1â€™s, then the Parity Flag is set. For odd number of 1â€™s, the Parity Flag is reset.\n• Zero flagÂ âˆ’ This flag is set to 1 when the result of arithmetic or logical operation is zero else it is set to 0.\n• Sign flagÂ âˆ’ This flag holds the sign of the result, i.e. when the result of the operation is negative, then the sign flag is set to 1 else set to 0.\n• Overflow flagÂ âˆ’ This flag represents the result when the system capacity is exceeded.\n\nControl flags controls the operations of the execution unit. Following is the list of control flags âˆ’\n• Trap flagÂ âˆ’ It is used for single step control and allows the user to execute one instruction at a time for debugging. If it is set, then the program can be run in a single step mode.\n• Interrupt flagÂ âˆ’ It is an interrupt enable/disable flag, i.e. used to allow/prohibit the interruption of a program. It is set to 1 for interrupt enabled condition and set to 0 for interrupt disabled condition.\n• Direction flagÂ âˆ’ It is used in string operation. As the name suggests when it is set then string bytes are accessed from the higher memory address to the lower memory address and vice-a-versa.\n\nThere are 8 general purpose registers, i.e., AH, AL, BH, BL, CH, CL, DH, and DL. These registers can be used individually to store 8-bit data and can be used in pairs to store 16bit data. The valid register pairs are AH and AL, BH and BL, CH and CL, and DH and DL. It is referred to the AX, BX, CX, and DX respectively.\n• AX registerÂ âˆ’ It is also known as accumulator register. It is used to store operands for arithmetic operations.\n• BX registerÂ âˆ’ It is used as a base register. It is used to store the starting base address of the memory area within the data segment.\n• CX registerÂ âˆ’ It is referred to as counter. It is used in loop instruction to store the loop counter.\n• DX registerÂ âˆ’ This register is used to hold I/O port address for I/O instruction.\n\nIt is a 16-bit register, which holds the address from the start of the segment to the memory location, where a word was most recently stored on the stack.\n\nBIU takes care of all data and addresses transfers on the buses for the EU like sending addresses, fetching instructions from the memory, reading data from the ports and the memory as well as writing data to the ports and the memory. EU has no direction connection with System Buses so this is possible with the BIU. EU and BIU are connected with the Internal Bus.\n\nIt has the following functional parts âˆ’\n• Instruction queueÂ âˆ’ BIU contains the instruction queue. BIU gets upto 6 bytes of next instructions and stores them in the instruction queue. When EU executes instructions and is ready for its next instruction, then it simply reads the instruction from this instruction queue resulting in increased execution speed.\n• Fetching the next instruction while the current instruction executes is calledÂ pipelining.\n• Segment registerÂ âˆ’ BIU has 4 segment buses, i.e. CS, DS, SS& ES. It holds the addresses of instructions and data in memory, which are used by the processor to access memory locations. It also contains 1 pointer register IP, which holds the address of the next instruction to executed by the EU.\n• CSÂ âˆ’ It stands for Code Segment. It is used for addressing a memory location in the code segment of the memory, where the executable program is stored.\n• DSÂ âˆ’ It stands for Data Segment. It consists of data used by the program andis accessed in the data segment by an offset address or the content of other register that holds the offset address.\n• SSÂ âˆ’ It stands for Stack Segment. It handles memory to store data and addresses during execution.\n• ESÂ âˆ’ It stands for Extra Segment. ES is additional data segment, which is used by the string to hold the extra destination data.\n• Instruction pointerÂ âˆ’ It is a 16-bit register used to hold the address of the next instruction to be executed.\n\nLet us now discuss these instruction sets in detail.\n\nThese instructions are used to transfer the data from the source operand to the destination operand. Following are the list of instructions under this group âˆ’\n• MOVÂ âˆ’ Used to copy the byte or word from the provided source to the provided destination.\n• PPUSHÂ âˆ’ Used to put a word at the top of the stack.\n• POPÂ âˆ’ Used to get a word from the top of the stack to the provided location.\n• PUSHAÂ âˆ’ Used to put all the registers into the stack.\n• POPAÂ âˆ’ Used to get words from the stack to all registers.\n• XCHGÂ âˆ’ Used to exchange the data from two locations.\n• XLATÂ âˆ’ Used to translate a byte in AL using a table in the memory.\n• INÂ âˆ’ Used to read a byte or word from the provided port to the accumulator.\n• OUTÂ âˆ’ Used to send out a byte or word from the accumulator to the provided port.\n• LEAÂ âˆ’ Used to load the address of operand into the provided register.\n• LDSÂ âˆ’ Used to load DS register and other provided register from the memory\n• LESÂ âˆ’ Used to load ES register and other provided register from the memory.\n• LAHFÂ âˆ’ Used to load AH with the low byte of the flag register.\n• SAHFÂ âˆ’ Used to store AH register to low byte of the flag register.\n• PUSHFÂ âˆ’ Used to copy the flag register at the top of the stack.\n• POPFÂ âˆ’ Used to copy a word at the top of the stack to the flag register.\n\nThese instructions are used to perform arithmetic operations like addition, subtraction, multiplication, division, etc.\n\nFollowing is the list of instructions under this group âˆ’\n• ADDÂ âˆ’ Used to add the provided byte to byte/word to word.\n• ADCÂ âˆ’ Used to add with carry.\n• INCÂ âˆ’ Used to increment the provided byte/word by 1.\n• AAAÂ âˆ’ Used to adjust ASCII after addition.\n• DAAÂ âˆ’ Used to adjust the decimal after the addition/subtraction operation.\n• SUBÂ âˆ’ Used to subtract the byte from byte/word from word.\n• SBBÂ âˆ’ Used to perform subtraction with borrow.\n• DECÂ âˆ’ Used to decrement the provided byte/word by 1.\n• NPGÂ âˆ’ Used to negate each bit of the provided byte/word and add 1/2â€™s complement.\n• AASÂ âˆ’ Used to adjust ASCII codes after subtraction.\n• DASÂ âˆ’ Used to adjust decimal after subtraction.\n• MULÂ âˆ’ Used to multiply unsigned byte by byte/word by word.\n• IMULÂ âˆ’ Used to multiply signed byte by byte/word by word.\n• AAMÂ âˆ’ Used to adjust ASCII codes after multiplication.\n• DIVÂ âˆ’ Used to divide the unsigned word by byte or unsigned double word by word.\n• IDIVÂ âˆ’ Used to divide the signed word by byte or signed double word by word.\n• AADÂ âˆ’ Used to adjust ASCII codes after division.\n• CBWÂ âˆ’ Used to fill the upper byte of the word with the copies of sign bit of the lower byte.\n• CWDÂ âˆ’ Used to fill the upper word of the double word with the sign bit of the lower word.\n\nThese instructions are used to perform operations where data bits are involved, i.e. operations like logical, shift, etc.\n\nFollowing is the list of instructions under this group âˆ’\n• NOTÂ âˆ’ Used to invert each bit of a byte or word.\n• ANDÂ âˆ’ Used for adding each bit in a byte/word with the corresponding bit in another byte/word.\n• ORÂ âˆ’ Used to multiply each bit in a byte/word with the corresponding bit in another byte/word.\n• XORÂ âˆ’ Used to perform Exclusive-OR operation over each bit in a byte/word with the corresponding bit in another byte/word.\n• TESTÂ âˆ’ Used to add operands to update flags, without affecting operands.\n• SHL/SALÂ âˆ’ Used to shift bits of a byte/word towards left and put zero(S) in LSBs.\n• SHRÂ âˆ’ Used to shift bits of a byte/word towards the right and put zero(S) in MSBs.\n• SARÂ âˆ’ Used to shift bits of a byte/word towards the right and copy the old MSB into the new MSB.\n• ROLÂ âˆ’ Used to rotate bits of byte/word towards the left, i.e. MSB to LSB and to Carry Flag [CF].\n• RORÂ âˆ’ Used to rotate bits of byte/word towards the right, i.e. LSB to MSB and to Carry Flag [CF].\n• RCRÂ âˆ’ Used to rotate bits of byte/word towards the right, i.e. LSB to CF and CF to MSB.\n• RCLÂ âˆ’ Used to rotate bits of byte/word towards the left, i.e. MSB to CF and CF to LSB.\n\nString is a group of bytes/words and their memory is always allocated in a sequential order.\n\nFollowing is the list of instructions under this group âˆ’\n• REPÂ âˆ’ Used to repeat the given instruction till CX â‰ 0.\n• REPE/REPZÂ âˆ’ Used to repeat the given instruction until CX = 0 or zero flag ZF = 1.\n• REPNE/REPNZÂ âˆ’ Used to repeat the given instruction until CX = 0 or zero flag ZF = 1.\n• MOVS/MOVSB/MOVSWÂ âˆ’ Used to move the byte/word from one string to another.\n• COMS/COMPSB/COMPSWÂ âˆ’ Used to compare two string bytes/words.\n• INS/INSB/INSWÂ âˆ’ Used as an input string/byte/word from the I/O port to the provided memory location.\n• OUTS/OUTSB/OUTSWÂ âˆ’ Used as an output string/byte/word from the provided memory location to the I/O port.\n• SCAS/SCASB/SCASWÂ âˆ’ Used to scan a string and compare its byte with a byte in AL or string word with a word in AX.\n• LODS/LODSB/LODSWÂ âˆ’ Used to store the string byte into AL or string word into AX.\n\nThese instructions are used to transfer/branch the instructions during an execution. It includes the following instructions âˆ’\n\nInstructions to transfer the instruction during an execution without any condition âˆ’\n• CALLÂ âˆ’ Used to call a procedure and save their return address to the stack.\n• RETÂ âˆ’ Used to return from the procedure to the main program.\n• JMPÂ âˆ’ Used to jump to the provided address to proceed to the next instruction.\n\nInstructions to transfer the instruction during an execution with some conditions âˆ’\n• JA/JNBEÂ âˆ’ Used to jump if above/not below/equal instruction satisfies.\n• JAE/JNBÂ âˆ’ Used to jump if above/not below instruction satisfies.\n• JBE/JNAÂ âˆ’ Used to jump if below/equal/ not above instruction satisfies.\n• JCÂ âˆ’ Used to jump if carry flag CF = 1\n• JE/JZÂ âˆ’ Used to jump if equal/zero flag ZF = 1\n• JG/JNLEÂ âˆ’ Used to jump if greater/not less than/equal instruction satisfies.\n• JGE/JNLÂ âˆ’ Used to jump if greater than/equal/not less than instruction satisfies.\n• JL/JNGEÂ âˆ’ Used to jump if less than/not greater than/equal instruction satisfies.\n• JLE/JNGÂ âˆ’ Used to jump if less than/equal/if not greater than instruction satisfies.\n• JNCÂ âˆ’ Used to jump if no carry flag (CF = 0)\n• JNE/JNZÂ âˆ’ Used to jump if not equal/zero flag ZF = 0\n• JNOÂ âˆ’ Used to jump if no overflow flag OF = 0\n• JNP/JPOÂ âˆ’ Used to jump if not parity/parity odd PF = 0\n• JNSÂ âˆ’ Used to jump if not sign SF = 0\n• JOÂ âˆ’ Used to jump if overflow flag OF = 1\n• JP/JPEÂ âˆ’ Used to jump if parity/parity even PF = 1\n• JSÂ âˆ’ Used to jump if sign flag SF = 1\n\nThese instructions are used to control the processor action by setting/resetting the flag values.\n\nFollowing are the instructions under this group âˆ’\n• STCÂ âˆ’ Used to set carry flag CF to 1\n• CLCÂ âˆ’ Used to clear/reset carry flag CF to 0\n• CMCÂ âˆ’ Used to put complement at the state of carry flag CF.\n• STDÂ âˆ’ Used to set the direction flag DF to 1\n• CLDÂ âˆ’ Used to clear/reset the direction flag DF to 0\n• STIÂ âˆ’ Used to set the interrupt enable flag to 1, i.e., enable INTR input.\n• CLIÂ âˆ’ Used to clear the interrupt enable flag to 0, i.e., disable INTR input.\n\nThese instructions are used to execute the given instructions for number of times. Following is the list of instructions under this group âˆ’\n• LOOPÂ âˆ’ Used to loop a group of instructions until the condition satisfies, i.e., CX = 0\n• LOOPE/LOOPZÂ âˆ’ Used to loop a group of instructions till it satisfies ZF = 1 & CX = 0\n• LOOPNE/LOOPNZÂ âˆ’ Used to loop a group of instructions till it satisfies ZF = 0 & CX = 0\n• JCXZÂ âˆ’ Used to jump to the provided address if CX = 0\n\nThese instructions are used to call the interrupt during program execution.\n• INTÂ âˆ’ Used to interrupt the program during execution and calling service specified.\n• INTOÂ âˆ’ Used to interrupt the program during execution if OF = 1\n• IRETÂ âˆ’ Used to return from interrupt service to the main program"
    },
    {
        "link": "https://engineeringbyte.com/assembly-language-program-to-interfacing-8253-timer-with-8086-in-mode-0",
        "document": "Write an assembly language program to interfacing 8253 Timer with 8086 in mode 0.\n\nWrite an assembly language program to interfacing 8253 Timer with 8086 in mode 0.\n\nTheory:The Intel 8253 is a Programmable Interval Timers (PITs), which perform timing and counting functions.\n\nThe 8253/54 solves one of most common problem in any microcomputer system, the generation of accurate time delays under software control. Instead of setting up timing loops in system software, the programmer configures the 8253 to match his requirements, initializes one of the counters of the 8253 with the desired quantity, then upon command the 8253 will count out the delay and interrupt the CPU when it has completed its tasks. 8253/54 can be operated in 6 different modes with the use of Control word Register\n• Step 1: “7FH” is the command used to unmask IRQ7. Do the connection as follows:\n• Step 2:“30H” is the control word for 8253. Binary counter 0 is selected. Timer mode is 0. Lower 8-bit count should be loaded first and then higher 8-bit count should be loaded.\n• Step 3:0005H is the 16-bit count that is loaded into the counter. First the LSB count should be loaded followed by the LSB count.\n• Step 4:“00H” is the control word for 8253 to latch the count. If the 4th and 5th bits of control words are 0 then the count can be latched. MSB and LSB count can be stored in a reg. pair so that it can be read\n• Step 5:A pulse can be given to the pulser clock as shown in figure and the output can be observed at the OUT0 pin.\n\nResult: LED1will glow after 5 pulser compression key as shown in figure below.\n• State the number of counters that are present in the programmable timer device 8253?\n• Name the mode that is used to interrupt the processor by setting a suitable terminal count is?\n• Name the counter which is selected when in control word register is SC1=0 and SC0=1?\n• What operation is performed by 8254 when in control word register, RL1=1, RL0=1?\n• Which mode of 8253 can provide pulse width modulation?\n\nProcedure for writing and compiling program through μ vision keil :\n\nProcedure to write the program in μ Vision Keil:\n• Give an appropriate name to the project.\n• After creation of project open a new file. Start writing your program.\n• If the program needs to be included then include the program in Target1 as : Right click on “Source Group1” to add the file as: (Add file to group “Source Group 1”)\n• Now, file will be included in the target.\n• Right click on Target1 → click option for Target1 → Output Tab →tick the check box “Create the Hex file”.\n• Now build the target & rebuild it.\n• Debug the errors (if any).\n• Select Device “89LV51RD2” as written on the microcontroller.\n• IMP: Check the COM port each time we connect the microcontroller through USB. e.g. „COM12‟ (Check from device manager).\n• Select the same COM port in the COM port drop down box in the flash magic as given in step 13.\n• Select the Hex file from the directory\n• IMP: make sure go to options→ Advance options → Hwdr Config..-->”Use DTR to control RST ” box is unchekcked.\n• Now, Make sure that jumper settings are as per 4-bit and 8-bit operation. (Refer Dyna51 User Manual).\n• At bottom of the Flash Magic window “Finished ” will be displayed."
    },
    {
        "link": "https://tutorialspoint.com/microprocessor/microprocessor_intel_8253_programmable_interval_timer.htm",
        "document": "The Intel 8253 and 8254 are Programmable Interval Timers (PTIs) designed for microprocessors to perform timing and counting functions using three 16-bit registers. Each counter has 2 input pins, i.e. Clock & Gate, and 1 pin for OUT output. To operate a counter, a 16-bit count is loaded in its register. On command, it begins to decrement the count until it reaches 0, then it generates a pulse that can be used to interrupt the CPU.\n\nThe following table differentiates the features of 8253 and 8254 −\n\nThe most prominent features of 8253/54 are as follows −\n• None It has three independent 16-bit down counters.\n• None It can handle inputs from DC to 10 MHz.\n• None These three counters can be programmed for either binary or BCD count.\n• None It is compatible with almost all microprocessors.\n• None 8254 has a powerful command called READ BACK command, which allows the user to check the count value, the programmed mode, the current mode, and the current status of the counter.\n\nThe architecture of 8254 looks as follows −\n\nHere is the pin diagram of 8254 −\n\nIn the above figure, there are three counters, a data bus buffer, Read/Write control logic, and a control register. Each counter has two input signals - CLOCK & GATE, and one output signal - OUT.\n\nIt is a tri-state, bi-directional, 8-bit buffer, which is used to interface the 8253/54 to the system data bus. It has three basic functions −\n\nIt includes 5 signals, i.e. RD, WR, CS, and the address lines A & A . In the peripheral I/O mode, the RD and WR signals are connected to IOR and IOW, respectively. In the memorymapped I/O mode, these are connected to MEMR and MEMW.\n\nAddress lines A & A of the CPU are connected to lines A and A of the 8253/54, and CS is tied to a decoded address. The control word register and counters are selected according to the signals on lines A & A .\n\nThis register is accessed when lines A & A are at logic 1. It is used to write a command word, which specifies the counter to be used, its mode, and either a read or write operation. Following table shows the result for various control inputs.\n\nEach counter consists of a single, 16 bit-down counter, which can be operated in either binary or BCD. Its input and output is configured by the selection of modes stored in the control word register. The programmer can read the contents of any of the three counters without disturbing the actual count in process."
    },
    {
        "link": "https://advdownload.advantech.com/productfile/Downloadfile2/1+GC+2976/ch8.pdf",
        "document": ""
    },
    {
        "link": "https://prgwonders.blogspot.com/2016/03/interfacing-of-8253programmable.html",
        "document": ""
    }
]