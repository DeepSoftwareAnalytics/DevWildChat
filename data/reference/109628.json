[
    {
        "link": "https://react.dev/reference/react/useEffect",
        "document": "In this example, a cleanup function is not needed because the class manages only the DOM node that was passed to it. After the React component is removed from the tree, both the DOM node and the class instance will be automatically garbage-collected by the browser JavaScript engine. You can use an Effect to fetch data for your component. Note that if you use a framework, using your framework’s data fetching mechanism will be a lot more efficient than writing Effects manually. If you want to fetch data from an Effect manually, your code might look like this: Note the variable which is initialized to , and is set to during cleanup. This ensures your code doesn’t suffer from “race conditions”: network responses may arrive in a different order than you sent them.\n\nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It’s easier to use a custom Hook—either your own or maintained by the community. What are good alternatives to data fetching in Effects? Writing calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:\n• Effects don’t run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.\n• Fetching directly in Effects makes it easy to create “network waterfalls”. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.\n• Fetching directly in Effects usually means you don’t preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.\n• It’s not very ergonomic. There’s quite a bit of boilerplate code involved when writing calls in a way that doesn’t suffer from bugs like race conditions. This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\n• If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.\n• Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes). You can continue fetching data directly in Effects if neither of these approaches suit you. Notice that you can’t “choose” the dependencies of your Effect. Every reactive value used by your Effect’s code must be declared as a dependency. Your Effect’s dependency list is determined by the surrounding code: If either or change, your Effect will reconnect to the chat using the new values. Reactive values include props and all variables and functions declared directly inside of your component. Since and are reactive values, you can’t remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix: To remove a dependency, you need to “prove” to the linter that it doesn’t need to be a dependency. For example, you can move out of your component to prove that it’s not reactive and won’t change on re-renders: Now that is not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency. If your Effect’s code doesn’t use any reactive values, its dependency list should be empty ( ): An Effect with empty dependencies doesn’t re-run when any of your component’s props or state change. If you have an existing codebase, you might have some Effects that suppress the linter like this: When dependencies don’t match the code, there is a high risk of introducing bugs. By suppressing the linter, you “lie” to React about the values your Effect depends on. Instead, prove they’re unnecessary.\n\nNow that you create the object inside the Effect, the Effect itself only depends on the string. With this fix, typing into the input doesn’t reconnect the chat. Unlike an object which gets re-created, a string like doesn’t change unless you set it to another value. Read more about removing dependencies. If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the function is different for every render: By itself, creating a function from scratch on every re-render is not a problem. You don’t need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render. Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:"
    },
    {
        "link": "https://leejjon.medium.com/react-typescript-i-stopped-using-the-useeffect-hook-to-fetch-data-f830c1186b71",
        "document": "Just like many, when I started to build React.js web apps I used the useEffect hook to fetch data because the (now old) documentation said so.\n\nA few months ago I stumbled on this article below about the useEffect hook and data fetching:\n\nThat article has valid points. I could immediately jump to its conclusion and switch to React Query, Vercel’s SWR or the Apollo HTTP client.\n\nHowever, it’s usually a good learning experience to not jump to solutions. Instead you should first encounter the problems, isolate them in a hello world project, understand them and look for the best solution. If you jump to a framework that promises lots of solutions for problems you’re not even sure about whether you’re going to have them, you might add a lot complexity.\n\nSo read on if you want to take a look at the problem(s) with me!\n\nHere is an example of a React App created with create-react-app. It is fetching football matches from api.football-data.org with the useEffect hook and display them in a React component:\n\nThis is how the app works when you run it locally:\n\nThis code has a few small problems that I could initially live with for hobby apps:\n• If you run this locally with strict mode on (default in create-react-app) it will fetch the data twice. You can work around it by removing the <React.StrictMode> tags in your index.tsx file.\n• It needs some more code to show a spinner while the data is fetching.\n• It only starts fetching the data when the component has loaded.\n\nRegarding that last thing, let’s take a look at the performance.\n\nIn the waterfall from the Chrome screenshot, we see that the React app takes under 400ms to download. The content of the DOM is only loaded after ~550ms. That means it takes less than 200ms to start up React and all our components. Then it takes another ~800 ms to load the matches from the football API.\n\nI decided replace the useEffect hook with the useQuery hook from React Query, as it seems React Query is being recommended a lot. I’ve prepared a separate branch of the same code, that uses this useQuery hook instead.\n\nIn the index.tsx I’m adding a few things:\n\nAnd in the App.tsx we replace the useEffect hook with a useQuery hook:\n\nWhen we run this thing, it works as expected. However the entire call takes even longer!\n\nI’m not sure if adding React Query to our application increased the bundle size and thus slows things down. Let me know in the comments if you think there is another reason.\n\nMy conclusion for now is:\n• React Query does not fetches data faster than if you would do it from a useEffect hook. It might even use the useEffect hook under the hood.\n• Use React Query if you need the extra features it offers for data fetching, such as caching.\n\nThe above app is simple. It has one page that always fetches the matches data. Most web apps have multiple pages and use a routing library like React Router. In the real world different pages would usually fetch different data. I prepared a branch with multiple pages and the routes defined with react router.\n\nWe need to move the matches logic to a new file called Matches.tsx in a pages folder:\n\nSimply duplicate this Matches.tsx file to a Matches2.tsx file with almost identical code. Also create a nice Home.tsx:\n\nAfter installing react router with we can define the routes in App.tsx:\n\nGoing to the home page no longer fetches the matches:\n\nNavigating to /matches or /matches2 does trigger the fetch. If we navigate between them, no re-fetch is happening (which is nice and efficient).\n\nThe article I mentioned above has a short mention about using React Router loaders instead of using the useEffect hook.\n\nEach route can define a “loader” function to provide data to the route element before it renders.\n\nDoes this mean we can increase performance by letting a loader do the fetching before our element renders?\n\nAt first glance it looks as if you can simply add loaders to the Routes in the JSX:\n\nIn the Matches component you should be able to use the useLoaderData hook to retrieve the data from the loader:\n\nUnfortunately, if you try to run this code you’ll get the error useLoaderData must be used within a data router, as explained in this StackOverflow post.\n\nTo solve this, we have to use the createBrowserRouter function to define our Routes. This can be quite an overhaul if you have a lot of routes, let’s apply it on this test project so you get an idea.\n\nStart with defining the router in index.tsx file:\n\nOur App.tsx file will still contain the navigation Link elements, and also an <Outlet/> element in which the loaded page content will be loaded:\n\nNow run the application again (find this version of the code here):\n\nBy fetching data inside the react router loaders we have successfully removed the useEffect clauses. And our code works, but the performance didn’t improve and we’ve lost a bit of control.\n• No more duplicate fetching in strict mode locally.\n• The routes are defined in code, which could be a little bit more flexible. If you prefer to define your routes in JSX and still use loaders, you can use the createRoutesFromElements function.\n• We’ve had to refactor our entire routing, and performance didn’t improve. It might still improve your performance if you have very heavy rendering (due to many nested components), but in this simple example, it’s premature optimization.\n• We’ve lost the simple caching our useEffect & useState solution offered. Which means that browsing from /matches to /matches2 will do a re-fetch of the matches data.\n• We have to do an unsafe cast from the useLoaderData hook:\n\nIf you look at the declaration in the react-router types, you’ll see that the hook doesn’t have a way to use the return type from the loader in the useLoaderData hook:\n\nI’d suggest to use React Query instead of passing raw fetch functions to React Router loaders.\n\nThe author of React Query has written a great guide to use React Query with React Router loaders, but I’ll show how to apply it on our example anyway. And of course, you can find the code on GitHub in a separate branch.\n\nIn the index.tsx, we need to define our query client, the query and the query loader:\n\nIn our Matches.tsx and Matches2.tsx add the useQuery hook to get the matches data:\n\nIf we try this code, we see that it works nicely and doesn’t refresh if you navigate between the Matches and Matches2 pages. But the performance still stays around the same.\n\nEven though this mix of React Router and React Query works in the end, I kind of dislike the way my code looks now. I feel that the original react router code was really easy to read for somebody who never used React Router before:\n\nIf a new programmer would work on my final code example he/she would need to understand:\n• What the RouterProvider and QueryClientProvider contexts do.\n• What the createBrowserRouter function does, and the concept of loaders.\n• What the <Outlet/> element does.\n\nI feel like that is more than just understanding the limits of the useEffect hook.\n\nSince the react router loaders force us to refactor lots of code and didn’t improve performance, let’s ditch the loaders:\n\nLet’s look at the performance when you do a hard refresh (control + shift + R) on the /matches route:\n\nI’d say good enough! You can find this version of the code here.\n\nWhat else can we do?\n\nI think most people suggest to go for server side rendering if you want to speed things up . Even though that could slow down your time to first byte.\n\nThere are a couple of things I’d recommend you to look into:\n• Watch this video from Ryan Florence (a co-author of React Router and Remix) about data fetching, react router and remix.\n• Read this article for more explanations on the subject of data fetching.\n• Read Dan Abramov’s reddit post here on fetching in useEffect and what you should use instead.\n\nI’m probably going to look into situational server side rendering (most likely Remix or Next.js) to make my performance better. But then I need to re-evaluate my infrastructure choices, and that falls outside the scope of this blog post.\n• Thank you for reading!\n• Leave a comment if you have questions.\n• Follow me on Medium/Twitter/LinkedIn if you want to read more original programming content."
    },
    {
        "link": "https://stackoverflow.com/questions/53332321/react-hook-warnings-for-async-function-in-useeffect-useeffect-function-must-ret",
        "document": "and I get this warning in my console. But the cleanup is optional for async calls I think. I am not sure why I get this warning. Linking sandbox for examples. https://codesandbox.io/s/24rj871r0p\n\nI was trying the useEffect example something like below:\n\nNote: If you want to support SSR/SSG for SEO, use framework specific api from React-router/Remix, Next.js or Gatsby. We now have nice loader and form action api: async function updateDataAndLoadNew() { // update data // load new data // return new data return { data: \"some data\" }; } export default function Index() { const [state, action, isPending] = useActionState( async (prev, formData) => { return updateUserAndLoadNewData(); }, { data: \"initial state, no data\" } // can be null ); if (state.error) { return `Error ${state.error.message}`; } return ( <form action={action}> <input type=\"text\" name=\"name\" /> <button type=\"submit\" disabled={isPending}> Do it </button> {state.data && <p>Data {state.data}</p>} </form> ); } Starting with React 18 you can also use Suspense, but it's not yet recommended if you are not using frameworks that correctly implement it: In React 18, you can start using Suspense for data fetching in opinionated frameworks like Relay, Next.js, Hydrogen, or Remix. Ad hoc data fetching with Suspense is technically possible, but still not recommended as a general strategy. If not part of the framework, you can try some libs that implement it like swr. Oversimplified example of how suspense works. You need to throw a promise for Suspense to catch it, show component first and render component when it's resolved. let fullfilled = false; let promise; const fetchData = () => { if (!fullfilled) { if (!promise) { promise = new Promise(async (resolve) => { const res = await fetch('api/data') const data = await res.json() fullfilled = true resolve(data) }); } throw promise } }; const Main = () => { fetchData(); return <div>Loaded</div>; }; const App = () => ( <Suspense fallback={\"Loading...\"}> <Main /> </Suspense> ); I suggest to look at Dan Abramov (one of the React core maintainers) answer here: I think you're making it more complicated than it needs to be. Longer term we'll discourage this pattern because it encourages race conditions. Such as — anything could happen between your call starts and ends, and you could have gotten new props. Instead, we'll recommend Suspense for data fetching which will look more like and no effects. But in the meantime you can move the async stuff to a separate function and call it. You can read more about experimental suspense here. If you want to use functions outside with eslint. function OutsideUsageExample({ userId }) { const [data, dataSet] = useState<any>(null) const fetchMyAPI = useCallback(async () => { let response = await fetch('api/data/' + userId) response = await response.json() dataSet(response) }, [userId]) // if userId changes, useEffect will run again useEffect(() => { fetchMyAPI() }, [fetchMyAPI]) return ( <div> <div>data: {JSON.stringify(data)}</div> <div> <button onClick={fetchMyAPI}>manual fetch</button> </div> </div> ) }\n\nWhen you use an async function like it returns a promise and doesn't expect the callback function to return Promise, rather it expects that nothing is returned or a function is returned. As a workaround for the warning you can use a self invoking async function. or to make it more cleaner you could define a function and then call it the second solution will make it easier to read and will help you write code to cancel previous requests if a new one is fired or save the latest request response in state\n\nUntil React provides a better way, you can create a helper, : Now you can pass an async function: If you choose this approach, note that it's bad form. I resort to this when I know it's safe, but it's always bad form and haphazard. Suspense for Data Fetching, which is still experimental, will solve some of the cases. In other cases, you can model the async results as events so that you can add or remove a listener based on the component life cycle. Or you can model the async results as an Observable so that you can subscribe and unsubscribe based on the component life cycle.\n\nFor fetching from an external using , you should call a function that fetches from the API inside of the hook. I strongly recommend that you do not define your query inside the Hook, because it will be re-render infinite times. And since you cannot make the async, you can make the function inside of it to be async. In the example shown above, the API call is in another separated async function so it makes sure that the call is async and that it only happens once. Also, the dependency array (the []) is empty, which means that it will behave just like the componentDidMount from React Class Components, it will only be executed once when the component is mounted. For the loading text, you can use React's conditional rendering to validate if your posts are null, if they are, render a loading text, else, show the posts. The else will be true when you finish fetching data from the API and the posts are not null. I see you already are using conditional rendering so I recommend you dive more into it, especially for validating if an object is null or not! I recommend you read the following articles in case you need more information about consuming an API using Hooks.\n\nYou can use this custom hook: import { useEffect, useRef } from \"react\"; import lodash from \"lodash\"; export const useEffectAsync = ( func: () => Promise<any>, dependencies: any[] ) => { let tasks = useRef<{ func: typeof func }[]>([]); const runWaitingTasks = () => { if (tasks.current.length) { tasks.current[0].func().then(() => { let tasksCopy = lodash.cloneDeep(tasks.current); tasksCopy.splice(0, 1); tasks.current = tasksCopy; runWaitingTasks(); }); } }; useEffect(() => { tasks.current.push({ func }); if (tasks.current.length === 1) { runWaitingTasks(); } }, dependencies); }; This hook is just created by combining the basic useEffect with a queue to manage dependencies changes asynchronously. import { useState } from \"react\"; import { useEffectAsync ,anApiCallAsync} from \"./Utils\"; function App() { useEffectAsync(async () => { let response = await anApiCallAsync(); console.log(response) }, []); return ( <div> <h1>useEffectAsync!</h1> </div> ); } export default App; import { useState } from \"react\"; import { useEffectAsync } from \"./Utils\"; function App() { const [counter, setCounter] = useState(0); const sleep = (sleep: number) => new Promise<void>((resolve, reject) => { setTimeout(() => { resolve(); }, sleep); }); useEffectAsync(async () => { await sleep(1500); console.log(\"useEffectAsync task with delay, counter: \" + counter); }, [counter]); return ( <div> <button onClick={() => setCounter(counter + 1)}>click to increase</button> <div>{counter}</div> </div> ); } export default App; In the above example when the counter is updated, the useEffectAsync hook ensures that the previous task finishes before executing the inner function with the new counter value. Actually, if a task is currently running and the dependencies change at the same time, this custom hook effectively creates a queue for incoming tasks and executes sequentially, one after the other, with new dependency values. This can be particularly useful for scenarios where you have time-consuming tasks and you need to ensure they complete one after the other with updated dependencies. If you run the above example via useEffect and use the async function inside of it, every time dependencies change, the useEffect runs the inner function instantly without waiting for previous tasks to finish, potentially causing concurrency issues. Below is the sample code with useEffect: import { useEffect, useState } from \"react\"; function App() { const [counter, setCounter] = useState(0); const sleep = (sleep: number) => new Promise<void>((resolve, reject) => { setTimeout(() => { resolve(); }, sleep); }); useEffect(() => { (async () => { await sleep(1500); console.log(\"useEffect task with delay, counter: \" + counter); })(); }, [counter]); return ( <div> <button onClick={() => setCounter(counter + 1)}>click to increase</button> <div>{counter}</div> </div> ); } export default App; I hope this custom hook is helpful for managing async tasks in your React components."
    },
    {
        "link": "https://reddit.com/r/reactjs/comments/mgm8o3/why_is_useeffect_used_for_data_fetching",
        "document": "is recommended to wrap any calls to async data fetching requests, but I'm not totally clear on why it's necessary since I don't see why a component mounting should affect an async fetch. It seems like it's primarily used for its dependency management to prevent it from being re-run unless a variable the fetch request depends on changes, or if there are no dependencies to only run it once.\n\nBut while that is a valid feature of it's not the primary purpose of and you can track whether a request needs to be re-run in plenty of other ways so I don't see why is needed for that one feature. It has the caveats of blocking on render and mounting which adds a delay to the request that doesn't appear to be necessary plus it prevents it from being run on the server side.\n\nIs there something I'm missing that makes it necessary or can I just run the fetch request with a separate pending request management system?"
    },
    {
        "link": "https://overreacted.io/a-complete-guide-to-useeffect",
        "document": "You wrote a few components with Hooks. Maybe even a small app. You’re mostly satisfied. You’re comfortable with the API and picked up a few tricks along the way. You even made some custom Hooks to extract repetitive logic (300 lines gone!) and showed it off to your colleagues. “Great job”, they said.\n\nBut sometimes when you , the pieces don’t quite fit together. You have a nagging feeling that you’re missing something. It seems similar to class lifecycles… but is it really? You find yourself asking questions like:\n• 🤔 How do I replicate with ?\n• 🤔 How do I correctly fetch data inside ? What is ?\n• 🤔 Do I need to specify functions as effect dependencies or not?\n• 🤔 Why do I sometimes get an infinite refetching loop?\n• 🤔 Why do I sometimes get an old state or prop value inside my effect?\n\nWhen I just started using Hooks, I was confused by all of those questions too. Even when writing the initial docs, I didn’t have a firm grasp on some of the subtleties. I’ve since had a few “aha” moments that I want to share with you. This deep dive will make the answers to these questions look obvious to you.\n\nTo see the answers, we need to take a step back. The goal of this article isn’t to give you a list of bullet point recipes. It’s to help you truly “grok” . There won’t be much to learn. In fact, we’ll spend most of our time unlearning.\n\nIt’s only after I stopped looking at the Hook through the prism of the familiar class lifecycle methods that everything came together for me.\n\nThis article assumes that you’re somewhat familiar with API.\n\nIt’s also really long. It’s like a mini-book. That’s just my preferred format. But I wrote a TLDR just below if you’re in a rush or don’t really care.\n\nIf you’re not comfortable with deep dives, you might want to wait until these explanations appear elsewhere. Just like when React came out in 2013, it will take some time for people to recognize a different mental model and teach it.\n\nHere’s a quick TLDR if you don’t want to read the whole thing. If some parts don’t make sense, you can scroll down until you find something related.\n\nFeel free to skip it if you plan to read the whole post. I’ll link to it at the end.\n\n🤔 Question: How do I replicate with ?\n\nWhile you can , it’s not an exact equivalent. Unlike , it will capture props and state. So even inside the callbacks, you’ll see the initial props and state. If you want to see “latest” something, you can write it to a ref. But there’s usually a simpler way to structure the code so that you don’t have to. Keep in mind that the mental model for effects is different from and other lifecycles, and trying to find their exact equivalents may confuse you more than help. To get productive, you need to “think in effects”, and their mental model is closer to implementing synchronization than to responding to lifecycle events.\n\n🤔 Question: How do I correctly fetch data inside ? What is ?\n\nThis article is a good primer on data fetching with . Make sure to read it to the end! It’s not as long as this one. means the effect doesn’t use any value that participates in React data flow, and is for that reason safe to apply once. It is also a common source of bugs when the value actually is used. You’ll need to learn a few strategies (primarily and ) that can remove the need for a dependency instead of incorrectly omitting it.\n\n🤔 Question: Do I need to specify functions as effect dependencies or not?\n\nThe recommendation is to hoist functions that don’t need props or state outside of your component, and pull the ones that are used only by an effect inside of that effect. If after that your effect still ends up using functions in the render scope (including function from props), wrap them into where they’re defined, and repeat the process. Why does it matter? Functions can “see” values from props and state — so they participate in the data flow. There’s a more detailed answer in our FAQ.\n\n🤔 Question: Why do I sometimes get an infinite refetching loop?\n\nThis can happen if you’re doing data fetching in an effect without the second dependencies argument. Without it, effects run after every render — and setting the state will trigger the effects again. An infinite loop may also happen if you specify a value that always changes in the dependency array. You can tell which one by removing them one by one. However, removing a dependency you use (or blindly specifying ) is usually the wrong fix. Instead, fix the problem at its source. For example, functions can cause this problem, and putting them inside effects, hoisting them out, or wrapping them with helps. To avoid recreating objects, can serve a similar purpose.\n\n🤔 Why do I sometimes get an old state or prop value inside my effect?\n\nEffects always “see” props and state from the render they were defined in. That helps prevent bugs but in some cases can be annoying. For those cases, you can explicitly maintain some value in a mutable ref (the linked article explains it at the end). If you think you’re seeing some props or state from an old render but don’t expect it, you probably missed some dependencies. Try using the lint rule to train yourself to see them. A few days, and it’ll be like a second nature to you. See also this answer in our FAQ.\n\nI hope this TLDR was helpful! Otherwise, let’s go.\n\nEach Render Has Its Own Props and State\n\nBefore we can talk about effects, we need to talk about rendering.\n\nHere’s a counter. Look at the highlighted line closely:\n\nWhat does it mean? Does somehow “watch” changes to our state and update automatically? That might be a useful first intuition when you learn React but it’s not an accurate mental model.\n\nIn this example, is just a number. It’s not a magic “data binding”, a “watcher”, a “proxy”, or anything else. It’s a good old number like this one:\n\nThe first time our component renders, the variable we get from is . When we call , React calls our component again. This time, will be . And so on:\n\nWhenever we update the state, React calls our component. Each render result “sees” its own state value which is a constant inside our function.\n\nSo this line doesn’t do any special data binding:\n\nIt only embeds a number value into the render output. That number is provided by React. When we , React calls our component again with a different value. Then React updates the DOM to match our latest render output.\n\nThe key takeaway is that the constant inside any particular render doesn’t change over time. It’s our component that’s called again — and each render “sees” its own value that’s isolated between renders.\n\nEach Render Has Its Own Event Handlers\n\nSo far so good. What about event handlers?\n\nLook at this example. It shows an alert with the after three seconds:\n\nLet’s say I do this sequence of steps:\n• Increment it to 5 before the timeout fires\n\nWhat do you expect the alert to show? Will it show 5 — which is the counter state at the time of the alert? Or will it show 3 — the state when I clicked?\n\nGo ahead and try it yourself!\n\nIf the behavior doesn’t quite make sense to you, imagine a more practical example: a chat app with the current recipient ID in the state, and a Send button. This article explores the reasons in depth but the correct answer is 3.\n\nThe alert will “capture” the state at the time I clicked the button.\n\nBut how does it work?\n\nWe’ve discussed that the value is constant for every particular call to our function. It’s worth emphasizing this — our function gets called many times (once per each render), but every one of those times the value inside of it is constant and set to a particular value (state for that render).\n\nThis is not specific to React — regular functions work in a similar way:\n\nIn this example, the outer variable is reassigned several times. (Just like somewhere in React, the current component state can change.) However, inside , there is a local constant that is associated with a from a particular call. That constant is local, so it’s isolated between the calls! As a result, when the timeouts fire, each alert “remembers” its own .\n\nThis explains how our event handler captures the at the time of the click. If we apply the same substitution principle, each render “sees” its own :\n\nSo effectively, each render returns its own “version” of . Each of those versions “remembers” its own :\n\nThis is why in this demo event handlers “belong” to a particular render, and when you click, it keeps using the state from that render.\n\nInside any particular render, props and state forever stay the same. But if props and state are isolated between renders, so are any values using them (including the event handlers). They also “belong” to a particular render. So even async functions inside an event handler will “see” the same value.\n\nSide note: I inlined concrete values right into functions above. This mental substitution is safe because can’t possibly change within a particular render. It’s declared as a and is a number. It would be safe to think the same way about other values like objects too, but only if we agree to avoid mutating state. Calling with a newly created object instead of mutating it is fine because state belonging to previous renders is intact.\n\nEach Render Has Its Own Effects\n\nThis was supposed to be a post about effects but we still haven’t talked about effects yet! We’ll rectify this now. Turns out, effects aren’t really any different.\n\nLet’s go back to an example from the docs:\n\nHere’s a question for you: how does the effect read the latest state?\n\nMaybe, there’s some kind of “data binding” or “watching” that makes update live inside the effect function? Maybe is a mutable variable that React sets inside our component so that our effect always sees the latest value?\n\nWe already know that is constant within a particular component render. Event handlers “see” the state from the render that they “belong” to because is a variable in their scope. The same is true for effects!\n\nIt’s not the variable that somehow changes inside an “unchanging” effect. It’s the effect function itself that’s different on every render.\n\nEach version “sees” the value from the render that it “belongs” to:\n\nReact remembers the effect function you provided, and runs it after flushing changes to the DOM and letting the browser paint the screen.\n\nSo even if we speak of a single conceptual effect here (updating the document title), it is represented by a different function on every render — and each effect function “sees” props and state from the particular render it “belongs” to.\n\nConceptually, you can imagine effects are a part of the render result.\n\nStrictly saying, they’re not (in order to allow Hook composition without clumsy syntax or runtime overhead). But in the mental model we’re building up, effect functions belong to a particular render in the same way that event handlers do.\n\nTo make sure we have a solid understanding, let’s recap our first render:\n• React: Give me the UI when the state is .\n• Your component:\n• Also remember to run this effect after you’re done: .\n• React: Sure. Updating the UI. Hey browser, I’m adding some stuff to the DOM.\n• Browser: Cool, I painted it to the screen.\n• React: OK, now I’m going to run the effect you gave me.\n\nNow let’s recap what happens after we click:\n• Your component: Hey React, set my state to .\n• React: Give me the UI for when the state is .\n• Your component:\n• Also remember to run this effect after you’re done: .\n• React: Sure. Updating the UI. Hey browser, I’ve changed the DOM.\n• Browser: Cool, I painted your changes to the screen.\n• React: OK, now I’ll run the effect that belongs to the render I just did.\n\nEach Render Has Its Own… Everything\n\nWe know now that effects run after every render, are conceptually a part of the component output, and “see” the props and state from that particular render.\n\nLet’s try a thought experiment. Consider this code:\n\nIf I click several times with a small delay, what is the log going to look like?\n\nYou might think this is a gotcha and the end result is unintuitive. It’s not! We’re going to see a sequence of logs — each one belonging to a particular render and thus with its own value. You can try it yourself:\n\nYou may think: “Of course that’s how it works! How else could it work?”\n\nWell, that’s not how works in classes. It’s easy to make the mistake of thinking that this class implementation is equivalent:\n\nHowever, always points at the latest count rather than the one belonging to a particular render. So you’ll see logged each time instead:\n\nI think it’s ironic that Hooks rely so much on JavaScript closures, and yet it’s the class implementation that suffers from the canonical wrong-value-in-a-timeout confusion that’s often associated with closures. This is because the actual source of the confusion in this example is the mutation (React mutates in classes to point to the latest state) and not closures themselves.\n\nClosures are great when the values you close over never change. That makes them easy to think about because you’re essentially referring to constants. And as we discussed, props and state never change within a particular render. By the way, we can fix the class version… by using a closure.\n\nAt this point it’s important that we call it out explicitly: every function inside the component render (including event handlers, effects, timeouts or API calls inside them) captures the props and state of the render call that defined it.\n\nSo these two examples are equivalent:\n\nIt doesn’t matter whether you read from props or state “early” inside of your component. They’re not going to change! Inside the scope of a single render, props and state stay the same. (Destructuring props makes this more obvious.)\n\nOf course, sometimes you want to read the latest rather than captured value inside some callback defined in an effect. The easiest way to do it is by using refs, as described in the last section of this article.\n\nBe aware that when you want to read the future props or state from a function in a past render, you’re swimming against the tide. It’s not wrong (and in some cases necessary) but it might look less “clean” to break out of the paradigm. This is an intentional consequence because it helps highlight which code is fragile and depends on timing. In classes, it’s less obvious when this happens.\n\nHere’s a version of our counter example that replicates the class behavior:\n\nIt might seem quirky to mutate something in React. However, this is exactly how React itself reassigns in classes. Unlike with captured props and state, you don’t have any guarantees that reading would give you the same value in any particular callback. By definition, you can mutate it any time. This is why it’s not a default, and you have to opt into that.\n\nSo What About Cleanup?\n\nAs the docs explain, some effects might have a cleanup phase. Essentially, its purpose is to “undo” an effect for cases like subscriptions.\n\nSay is on the first render, and on the second render. You might think that something like this happens:\n• React cleans up the effect for .\n\nWith this mental model, you might think the cleanup “sees” the old props because it runs before we re-render, and then the new effect “sees” the new props because it runs after the re-render. That’s the mental model lifted directly from the class lifecycles, and it’s not accurate here. Let’s see why.\n\nReact only runs the effects after letting the browser paint. This makes your app faster as most effects don’t need to block screen updates. Effect cleanup is also delayed. The previous effect is cleaned up after the re-render with new props:\n• The browser paints. We see the UI for on the screen.\n• React cleans up the effect for .\n\nYou might be wondering: but how can the cleanup of the previous effect still “see” the old props if it runs after the props change to ?\n\nNow the answer is clear! The effect cleanup doesn’t read the “latest” props, whatever that means. It reads props that belong to the render it’s defined in:\n\nKingdoms will rise and turn into ashes, the Sun will shed its outer layers to be a white dwarf, and the last civilization will end. But nothing will make the props “seen” by the first render effect’s cleanup anything other than .\n\nThat’s what allows React to deal with effects right after painting — and make your apps faster by default. The old props are still there if our code needs them.\n\nOne of my favorite things about React is that it unifies describing the initial render result and the updates. This reduces the entropy of your program.\n\nSay my component looks like this:\n\nIt doesn’t matter if I render and later , or if I just render . In the end, we will see “Hello, Yuzhi” in both cases.\n\nPeople say: “It’s all about the journey, not the destination”. With React, it’s the opposite. It’s all about the destination, not the journey. That’s the difference between and calls in jQuery code (our “journey”) and specifying what the CSS class should be in React code (our “destination”).\n\nReact synchronizes the DOM according to our current props and state. There is no distinction between a “mount” or an “update” when rendering.\n\nYou should think of effects in a similar way. lets you synchronize things outside of the React tree according to our props and state.\n\nThis is subtly different from the familiar mount/update/unmount mental model. It is important really to internalize this. If you’re trying to write an effect that behaves differently depending on whether the component renders for the first time or not, you’re swimming against the tide! We’re failing at synchronizing if our result depends on the “journey” rather than the “destination”.\n\nIt shouldn’t matter whether we rendered with props A, B, and C, or if we rendered with C immediately. While there may be some temporary differences (e.g. while we’re fetching data), eventually the end result should be the same.\n\nStill, of course running all effects on every render might not be efficient. (And in some cases, it would lead to infinite loops.)\n\nSo how can we fix this?\n\nWe’ve already learned that lesson with the DOM itself. Instead of touching it on every re-render, React only updates the parts of the DOM that actually change.\n\nIt goes over each of their props and determine that have changed and need a DOM update, but did not. So it can just do:\n\nCould we do something like this with effects too? It would be nice to avoid re-running them when applying the effect is unnecessary.\n\nFor example, maybe our component re-renders because of a state change:\n\nBut our effect doesn’t use the state. Our effect synchronizes the with the prop, but the prop is the same. Re-assigning on every counter change seems non-ideal.\n\nOK, so can React just… diff effects?\n\nNot really. React can’t guess what the function does without calling it. (The source doesn’t really contain specific values, it just closes over the prop.)\n\nThis is why if you want to avoid re-running effects unnecessarily, you can provide a dependency array (also known as “deps”) argument to :\n\nIt’s like if we told React: “Hey, I know you can’t see inside this function, but I promise it only uses and nothing else from the render scope.”\n\nIf each of these values is the same between the current and the previous time this effect ran, there’s nothing to synchronize so React can skip the effect:\n\nIf even one of the values in the dependency array is different between renders, we know running the effect can’t be skipped. Synchronize all the things!\n\nLying to React about dependencies has bad consequences. Intuitively, this makes sense, but I’ve seen pretty much everyone who tries with a mental model from classes try to cheat the rules. (And I did that too at first!)\n\n“But I only want to run it on mount!”, you’ll say. For now, remember: if you specify deps, all values from inside your component that are used by the effect must be there. Including props, state, functions — anything in your component.\n\nSometimes when you do that, it causes a problem. For example, maybe you see an infinite refetching loop, or a socket is recreated too often. The solution to that problem is not to remove a dependency. We’ll look at the solutions soon.\n\nBut before we jump to solutions, let’s understand the problem better.\n\nWhat Happens When Dependencies Lie\n\nIf deps contain every value used by the effect, React knows when to re-run it:\n\nBut if we specified for this effect, the new effect function wouldn’t run:\n\nIn this case the problem might seem obvious. But the intuition can fool you in other cases where a class solution “jumps out” from your memory.\n\nFor example, let’s say we’re writing a counter that increments every second. With a class, our intuition is: “Set up the interval once and destroy it once”. Here’s an example of how we can do it. When we mentally translate this code to , we instinctively add to the deps. “I want it to run once”, right?\n\nHowever, this example only increments once. Oops.\n\nIf your mental model is “dependencies let me specify when I want to re-trigger the effect”, this example might give you an existential crisis. You want to trigger it once because it’s an interval — so why is it causing issues?\n\nHowever, this makes sense if you know that dependencies are our hint to React about everything that the effect uses from the render scope. It uses but we lied that it doesn’t with . It’s only a matter of time before this bites us!\n\nIn the first render, is . Therefore, in the first render’s effect means . Since we never re-run the effect because of deps, it will keep calling every second:\n\nWe lied to React by saying our effect doesn’t depend on a value from inside our component, when in fact it does!\n\nOur effect uses — a value inside the component (but outside the effect):\n\nTherefore, specifying as a dependency will create a bug. React will compare the dependencies, and skip updating this effect:\n\nIssues like this are difficult to think about. Therefore, I encourage you to adopt it as a hard rule to always be honest about the effect dependencies, and specify them all. (We provide a lint rule if you want to enforce this on your team.)\n\nTwo Ways to Be Honest About Dependencies\n\nThere are two strategies to be honest about dependencies. You should generally start with the first one, and then apply the second one if needed.\n\nThe first strategy is to fix the dependency array to include all the values inside the component that are used inside the effect. Let’s include as a dep:\n\nThis makes the dependency array correct. It may not be ideal but that’s the first issue we needed to fix. Now a change to will re-run the effect, with each next interval referencing from its render in :\n\nThat would fix the problem but our interval would be cleared and set again whenever the changes. That may be undesirable:\n\nThe second strategy is to change our effect code so that it wouldn’t need a value that changes more often than we want. We don’t want to lie about the dependencies — we just want to change our effect to have fewer of them.\n\nLet’s look at a few common techniques for removing dependencies.\n\nWe want to get rid of the dependency in our effect.\n\nTo do this, we need to ask ourselves: what are we using for? It seems like we only use it for the call. In that case, we don’t actually need in the scope at all. When we want to update state based on the previous state, we can use the functional updater form of :\n\nI like to think of these cases as “false dependencies”. Yes, was a necessary dependency because we wrote inside the effect. However, we only truly needed to transform it into and “send it back” to React. But React already knows the current . All we needed to tell React is to increment the state — whatever it is right now.\n\nThat’s exactly what does. You can think of it as “sending an instruction” to React about how the state should change. This “updater form” also helps in other cases, like when you batch multiple updates.\n\nNote that we actually did the work to remove the dependency. We didn’t cheat. Our effect doesn’t read the value from the render scope anymore:\n\nYou can try it here.\n\nEven though this effect only runs once, the interval callback that belongs to the first render is perfectly capable of sending the update instruction every time the interval fires. It doesn’t need to know the current state anymore. React already knows it.\n\nRemember how we talked about synchronization being the mental model for effects? An interesting aspect of synchronization is that you often want to keep the “messages” between the systems untangled from their state. For example, editing a document in Google Docs doesn’t actually send the whole page to the server. That would be very inefficient. Instead, it sends a representation of what the user tried to do.\n\nWhile our use case is different, a similar philosophy applies to effects. It helps to send only the minimal necessary information from inside the effects into a component. The updater form like conveys strictly less information than because it isn’t “tainted” by the current count. It only expresses the action (“incrementing”). Thinking in React involves finding the minimal state. This is the same principle, but for updates.\n\nEncoding the intent (rather than the result) is similar to how Google Docs solves collaborative editing. While this is stretching the analogy, functional updates serve a similar role in React. They ensure updates from multiple sources (event handlers, effect subscriptions, etc) can be correctly applied in a batch and in a predictable way.\n\nHowever, even isn’t that great. It looks a bit weird and it’s very limited in what it can do. For example, if we had two state variables whose values depend on each other, or if we needed to calculate the next state based on a prop, it wouldn’t help us. Luckily, has a more powerful sister pattern. Its name is .\n\nLet’s modify the previous example to have two state variables: and . Our interval will increment the count by the value of the input:\n\nNote that we’re not cheating. Since I started using inside the effect, I added it to the dependencies. And that’s why the code runs correctly.\n\nThe current behavior in this example is that changing the restarts the interval — because it’s one of the dependencies. And in many cases, that is exactly what you want! There’s nothing wrong with tearing down an effect and setting it up anew, and we shouldn’t avoid that unless we have a good reason.\n\nHowever, let’s say we want the interval clock to not reset on changes to the . How do we remove the dependency from our effect?\n\nWhen setting a state variable depends on the current value of another state variable, you might want to try replacing them both with .\n\nWhen you find yourself writing , it’s a good time to consider using a reducer instead. A reducer lets you decouple expressing the “actions” that happened in your component from how the state updates in response to them.\n\nLet’s trade the dependency for a dependency in our effect:\n\nYou might ask me: “How is this any better?” The answer is that React guarantees the function to be constant throughout the component lifetime. So the example above doesn’t ever need to resubscribe the interval.\n\nInstead of reading the state inside an effect, it dispatches an action that encodes the information about what happened. This allows our effect to stay decoupled from the state. Our effect doesn’t care how we update the state, it just tells us about what happened. And the reducer centralizes the update logic:\n\n(Here’s a demo if you missed it earlier).\n\nWhy useReducer Is the Cheat Mode of Hooks\n\nWe’ve seen how to remove dependencies when an effect needs to set state based on previous state, or on another state variable. But what if we need props to calculate the next state? For example, maybe our API is . Surely, in this case we can’t avoid specifying as a dependency?\n\nIn fact, we can! We can put the reducer itself inside our component to read props:\n\nThis pattern disables a few optimizations so try not to use it everywhere, but you can totally access props from a reducer if you need to. (Here’s a demo.)\n\nEven in that case, identity is still guaranteed to be stable between re-renders. So you may omit it from the effect deps if you want. It’s not going to cause the effect to re-run.\n\nYou may be wondering: how can this possibly work? How can the reducer “know” props when called from inside an effect that belongs to another render? The answer is that when you , React just remembers the action — but it will call your reducer during the next render. At that point the fresh props will be in scope, and you won’t be inside an effect.\n\nThis is why I like to think of as the “cheat mode” of Hooks. It lets me decouple the update logic from describing what happened. This, in turn, helps me remove unnecessary dependencies from my effects and avoid re-running them more often than necessary.\n\nA common mistake is to think functions shouldn’t be dependencies. For example, this seems like it could work:\n\nAnd to be clear, this code does work. But the problem with simply omitting local functions is that it gets pretty hard to tell whether we’re handling all cases as the component grows!\n\nImagine our code was split like this and each function was five times larger:\n\nNow let’s say we later use some state or prop in one of these functions:\n\nIf we forget to update the deps of any effects that call these functions (possibly, through other functions!), our effects will fail to synchronize changes from our props and state. This doesn’t sound great.\n\nLuckily, there is an easy solution to this problem. If you only use some functions inside an effect, move them directly into that effect:\n\nSo what is the benefit? We no longer have to think about the “transitive dependencies”. Our dependencies array isn’t lying anymore: we truly aren’t using anything from the outer scope of the component in our effect.\n\nIf we later edit to use the state, we’re much more likely to notice that we’re editing it inside an effect — and therefore, we need to add to the effect dependencies:\n\nBy adding this dependency, we’re not just “appeasing React”. It makes sense to refetch the data when the query changes. The design of forces you to notice the change in our data flow and choose how our effects should synchronize it — instead of ignoring it until our product users hit a bug.\n\nThanks to the lint rule from the plugin, you can analyze the effects as you type in your editor and receive suggestions about which dependencies are missing. In other words, a machine can tell you which data flow changes aren’t handled correctly by a component.\n\nBut I Can’t Put This Function Inside an Effect\n\nSometimes you might not want to move a function inside an effect. For example, several effects in the same component may call the same function, and you don’t want to copy and paste its logic. Or maybe it’s a prop.\n\nShould you skip a function like this in the effect dependencies? I think not. Again, effects shouldn’t lie about their dependencies. There are usually better solutions. A common misconception is that “a function would never change”. But as we learned throughout this article, this couldn’t be further from truth. Indeed, a function defined inside a component changes on every render!\n\nThat by itself presents a problem. Say two effects call :\n\nIn that case you might not want to move inside either of the effects since you wouldn’t be able to share the logic.\n\nOn the other hand, if you’re “honest” about the effect dependencies, you may run into a problem. Since both our effects depend on (which is different on every render), our dependency arrays are useless:\n\nA tempting solution to this is to just skip the function in the deps list. However, I don’t think it’s a good solution. This makes it difficult to notice when we are adding a change to the data flow that needs to be handled by an effect. This leads to bugs like the “never updating interval” we saw earlier.\n\nInstead, there are two other solutions that are simpler.\n\nFirst of all, if a function doesn’t use anything from the component scope, you can hoist it outside the component and then freely use it inside your effects:\n\nThere’s no need to specify it in deps because it’s not in the render scope and can’t be affected by the data flow. It can’t accidentally depend on props or state.\n\nAlternatively, you can wrap it into the Hook:\n\nis essentially like adding another layer of dependency checks. It’s solving the problem on the other end — rather than avoid a function dependency, we make the function itself only change when necessary.\n\nLet’s see why this approach is useful. Previously, our example showed two search results (for and search queries). But let’s say we want to add an input so that you can search for an arbitrary . So instead of taking as an argument, will now read it from local state.\n\nIf I fix my deps to include , any effect with in deps will re-run whenever the changes:\n\nThanks to , if is the same, also stays the same, and our effect doesn’t re-run. But if changes, will also change, and we will re-fetch the data. It’s a lot like when you change some cell in an Excel spreadsheet, and the other cells using it recalculate automatically.\n\nThis is just a consequence of embracing the data flow and the synchronization mindset. The same solution works for function props passed from parents:\n\nSince only changes inside when its state changes, our won’t refetch the data until it’s actually necessary for the app.\n\nAre Functions Part of the Data Flow?\n\nInterestingly, this pattern is broken with classes in a way that really shows the difference between the effect and lifecycle paradigms. Consider this translation:\n\nYou might be thinking: “Come on Dan, we all know that is like and combined, you can’t keep beating that drum!” Yet this doesn’t work even with :\n\nOf course, is a class method! (Or, rather, a class property — but that doesn’t change anything.) It’s not going to be different because of a state change. So will stay equal to and we’ll never refetch. Let’s just remove this condition then?\n\nOh wait, this fetches on every re-render. (Adding an animation above in the tree is a fun way to discover it.) Maybe let’s bind it to a particular query?\n\nBut then is always , even if the didn’t change! So we’ll always refetch.\n\nThe only real solution to this conundrum with classes is to bite the bullet and pass the itself into the component. The doesn’t actually end up using the , but it can trigger a refetch when it changes:\n\nOver the years of working with classes with React, I’ve gotten so used to passing unnecessary props down and breaking encapsulation of parent components that I only realized a week ago why we had to do it.\n\nWith classes, function props by themselves aren’t truly a part of the data flow. Methods close over the mutable variable so we can’t rely on their identity to mean anything. Therefore, even when we only want a function, we have to pass a bunch of other data around in order to be able to “diff” it. We can’t know whether passed from the parent depends on some state or not, and whether that state has just changed.\n\nWith , functions can fully participate in the data flow. We can say that if the function inputs changed, the function itself has changed, but if not, it stayed the same. Thanks to the granularity provided by , changes to props like can propagate down automatically.\n\nSimilarly, lets us do the same for complex objects:\n\nI want to emphasize that putting everywhere is pretty clunky. It’s a nice escape hatch and it’s useful when a function is both passed down and called from inside an effect in some children. Or if you’re trying to prevent breaking memoization of a child component. But Hooks lend themselves better to avoiding passing callbacks down altogether.\n\nIn the above examples, I’d much prefer if was either inside my effect (which itself could be extracted to a custom Hook) or a top-level import. I want to keep the effects simple, and callbacks in them don’t help that. (“What if some callback changes while the request was in flight?”) You can simulate the class behavior but that doesn’t solve race conditions.\n\nA classic data fetching example with classes might look like this:\n\nAs you probably know, this code is buggy. It doesn’t handle updates. So the second classic example you could find online is something like this:\n\nThis is definitely better! But it’s still buggy. The reason it’s buggy is that the request may come out of order. So if I’m fetching , switch to , but the request comes first, the request that started earlier but finished later would incorrectly overwrite my state.\n\nThis is called a race condition, and it’s typical in code that mixes / (which assumes something waits for the result) with top-down data flow (props or state can change while we’re in the middle of an async function).\n\nEffects don’t magically solve this problem, although they’ll warn you if you try to pass an function to the effect directly. (We’ll need to improve that warning to better explain the problems you might run into.)\n\nIf the async approach you use supports cancellation, that’s great! You can cancel the async request right in your cleanup function.\n\nAlternatively, the easiest stopgap approach is to track it with a boolean:\n\nThis article goes into more detail about how you can handle errors and loading states, as well as extract that logic into a custom Hook. I recommend you to check it out if you’re interested to learn more about data fetching with Hooks.\n\nWith the class lifecycle mindset, side effects behave differently from the render output. Rendering the UI is driven by props and state, and is guaranteed to be consistent with them, but side effects are not. This is a common source of bugs.\n\nWith the mindset of , things are synchronized by default. Side effects become a part of the React data flow. For every call, once you get it right, your component handles edge cases much better.\n\nHowever, the upfront cost of getting it right is higher. This can be annoying. Writing synchronization code that handles edge cases well is inherently more difficult than firing one-off side effects that aren’t consistent with rendering.\n\nThis could be worrying if was meant to be the tool you use most of the time. However, it’s a low-level building block. It’s an early time for Hooks so everybody uses low-level ones all the time, especially in tutorials. But in practice, it’s likely the community will start moving to higher-level Hooks as good APIs gain momentum.\n\nI’m seeing different apps create their own Hooks like that encapsulates some of their app’s auth logic or which uses theme context. Once you have a toolbox of those, you don’t reach for that often. But the resilience it brings benefits every Hook built on top of it.\n\nSo far, is most commonly used for data fetching. But data fetching isn’t exactly a synchronization problem. This is especially obvious because our deps are often . What are we even synchronizing?\n\nIn the longer term, Suspense for Data Fetching will allow third-party libraries to have a first-class way to tell React to suspend rendering until something async (anything: code, data, images) is ready.\n\nAs Suspense gradually covers more data fetching use cases, I anticipate that will fade into background as a power user tool for cases when you actually want to synchronize props and state to some side effect. Unlike data fetching, it handles this case naturally because it was designed for it. But until then, custom Hooks like shown here are a good way to reuse data fetching logic.\n\nNow that you know pretty much everything I know about using effects, check out the TLDR in the beginning. Does it make sense? Did I miss something? (I haven’t run out of paper yet!)\n\nI’d love to hear from you on Twitter! Thanks for reading."
    },
    {
        "link": "https://legacy.reactjs.org/docs/conditional-rendering.html",
        "document": "These docs are old and won’t be updated. Go to react.dev for the new React docs. These new documentation pages teach modern React and include live examples:\n\nIn React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.\n\nConditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like or the conditional operator to create elements representing the current state, and let React update the UI to match them.\n\nConsider these two components:\n\nWe’ll create a component that displays either of these components depending on whether a user is logged in:\n\nTry it on CodePen\n\nThis example renders a different greeting depending on the value of prop.\n\nYou can use variables to store elements. This can help you conditionally render a part of the component while the rest of the output doesn’t change.\n\nConsider these two new components representing Logout and Login buttons:\n\nIn the example below, we will create a stateful component called .\n\nIt will render either or depending on its current state. It will also render a from the previous example:\n\nTry it on CodePen\n\nWhile declaring a variable and using an statement is a fine way to conditionally render a component, sometimes you might want to use a shorter syntax. There are a few ways to inline conditions in JSX, explained below.\n\nYou may embed expressions in JSX by wrapping them in curly braces. This includes the JavaScript logical operator. It can be handy for conditionally including an element:\n\nTry it on CodePen\n\nIt works because in JavaScript, always evaluates to , and always evaluates to .\n\nTherefore, if the condition is , the element right after will appear in the output. If it is , React will ignore and skip it.\n\nNote that returning a falsy expression will still cause the element after to be skipped but will return the falsy expression. In the example below, will be returned by the render method.\n\nAnother method for conditionally rendering elements inline is to use the JavaScript conditional operator .\n\nIn the example below, we use it to conditionally render a small block of text.\n\nIt can also be used for larger expressions although it is less obvious what’s going on:\n\nJust like in JavaScript, it is up to you to choose an appropriate style based on what you and your team consider more readable. Also remember that whenever conditions become too complex, it might be a good time to extract a component.\n\nIn rare cases you might want a component to hide itself even though it was rendered by another component. To do this return instead of its render output.\n\nIn the example below, the is rendered depending on the value of the prop called . If the value of the prop is , then the component does not render:\n\nTry it on CodePen\n\nReturning from a component’s method does not affect the firing of the component’s lifecycle methods. For instance will still be called."
    },
    {
        "link": "https://stackoverflow.com/questions/76792750/how-to-conditionally-render-components-in-react-based-on-state-changes",
        "document": "I'm working on a React application and I need to conditionally render components based on state changes. Specifically, I want to show different components or elements depending on the value of a state variable. For example, when the user clicks a button, I want to display a form, and when the form is submitted, I want to show a success message.\n\nHere's a simplified version of what I'm trying to achieve:\n\nI could not figure out how the function should be written to display the form only when the state variable is true and when it changes."
    },
    {
        "link": "https://reddit.com/r/reactjs/comments/qo1pr3/is_there_a_standard_or_best_practice_for",
        "document": "Say you want to render one of four different components depending on a variables state. You could use an if else, or a switch, or maybe an object literal in the return statement of the parent component. Is there a best way to do this?\n\nIf State=1 return component1 If State=2 return component2 If State=3 return component3 If State=4 return component4"
    },
    {
        "link": "https://thehumblecoder.medium.com/mastering-conditional-rendering-in-reactjs-453d87e686b4",
        "document": "Conditional rendering is a fundamental concept in ReactJS that empowers developers to dynamically display content based on specific conditions. It’s a crucial tool in your toolkit for creating interactive and personalized user interfaces. In this article, we’ll delve into the various techniques and best practices for effective conditional rendering in ReactJS.\n\nIn the realm of ReactJS, rendering content conditionally involves displaying different components or elements based on certain conditions. This ability allows you to tailor the user experience and create interfaces that respond dynamically to user input, authentication status, or data changes.\n\nOne of the most straightforward methods of conditional rendering is using standard statements within your JSX. Here's a quick example:\n\nThe ternary operator provides a concise way to conditionally render content in a single line:\n\nThe logical operator can also be harnessed for conditional rendering:\n\nYou can conditionally render content based on props received by your components:\n\nReact Hooks have revolutionized how we manage state and perform actions in functional components. Conditional rendering with hooks is equally intuitive:\n• Keep conditional rendering logic concise and readable for easy maintenance.\n• Choose the appropriate method based on the complexity of the condition.\n• Consider separating conditional cases into their own components for modularity.\n• Avoid excessive nesting of conditional rendering for better code structure.\n\nConditional rendering is a pivotal concept in ReactJS that empowers developers to craft dynamic, responsive, and user-centric interfaces. By using methods like statements, ternary operators, and hooks, you can seamlessly adapt your UI to various scenarios. Remember, the method you select should align with your project's requirements and the readability of your codebase. Now equipped with a solid understanding of conditional rendering, you're well-prepared to create captivating user experiences in your React applications."
    },
    {
        "link": "https://stackoverflow.com/questions/76651002/react-how-to-properly-handle-component-rendering-using-state-variables",
        "document": "I'm trying to render different fragments onto a page in a sequential way (A > B > C), and am wondering what the best practice is in terms of using state variables to control the rendering of these components\n\nCurrently, I have it set up as a single state variable: and am applying conditional rendering:\n\nHowever, I am concerned this might lead to re-rendering of each component when is updated (or would this not happen because isn't passed into the component itself?). Would having a separate state variable to trigger each screen be more efficient? For example:\n\nIn general, I'm confused about how to reduce state variables and am wondering if clustering them together is a bad practice as it may lead to unnecessary re-renders. For example:\n• Storing user data in - updating one key updates the entire state and will likely trigger re-renders in multiple components\n• Storing validation check and input values in an object to avoid having a state variable for each individual input\n\nPlease advise on whether it's appropriate to consolidate similar state variables in the above context"
    }
]