[
    {
        "link": "https://geeksforgeeks.org/c-sharp-queue-with-examples",
        "document": "A Queue in C# is a collection that follows the First-In-First-Out (FIFO) principle which means elements are processed in the same order they are added. It is a part of the System.Collections namespace for non-generic queues and System.Collections.Generic namespace for generic queues.\n• FIFO Behavior : The first element added is the first to be removed.\n• Dynamic Size: A queue can grow or shrink as needed.\n• Thread Safety : The Queue class is not thread-safe by default. Use ConcurrentQueue for thread-safe operations.\n• Common Operations\n• Enqueue : Add an element to the queue.\n• Dequeue : Remove and return the first element.\n• Peek : View the first element without removing it.\n• Contains : Check if an element exists in the queue.\n\nExample: This example demonstrates how to use a Queue in C# by enqueueing elements and then dequeuing them in FIFO (First-in-first-out ) order.\n• None When we add an item in the list, it is called\n• None When we remove an item, it is called\n• None Queue accepts null as a valid value for reference types.\n• None As elements are added to a Queue, the capacity is automatically increased as required by reallocating the internal array.\n• None In Queue, we are allowed to store duplicate elements.\n• None The capacity of a Queue is the number of elements the Queue can hold.\n\nQueue class has four constructors which are used to create the queue which are as follows:\n• Queue(): This constructor is used to create an instance of the Queue class which is empty and having the default initial capacity, and uses the default growth factor.\n• Queue(ICollection) : This constructor is used to create an instance of Queue class which contains elements copied from the specified collection, has the same initial capacity as the number of elements copied, and uses the default growth factor.\n• Queue(Int32): This constructor is used to create an instance of the Queue class which is empty and having specified initial capacity, and uses the default growth factor.\n• Queue(Int32, Single) : This constructor is used to create an instance of Queue class which is empty and having specified initial capacity, and uses the specified growth factor.\n\nLet’s see how to create an Queue using Queue() constructor:\n\nStep 1: Include System.Collections namespace in your program with the help of using keyword\n\n1. Adding Elements: We use Enqueue() method to insert elements in a Queue.\n\nExample: This example demonstrates how to create a queue in C# and add various elements to it using the Enqueue() method, then access and display the elements using a foreach loop.\n\n2. Remove Elements: The Queue class provides two different methods to remove elements and the methods are:\n• Clear() Method is used to remove the objects from the queue.\n• Dequeue() Method: removes the beginning element of the queue.\n\nExample: This example displays the contents of the Queue before and after removal.\n\n3. Get the Topmost Element of the Queue: The Queue class provides two different methods to find the topmost element of the Queue and the methods are listed below:\n• Peek() Method method returns the object at the beginning of the Queue without removing it.\n• Dequeue() Method method returns the object at the beginning of the Queue with modification means this method remove the topmost element of the queue.\n\nExample: This example demonstrates how to peek at the topmost element of a Queue.\n\n4. Check the Availability of Elements in the Queue: Queue class provide Contains() method to check if the element is present in the Queue or not.\n\nExample: This program demonstrates how to check if the specified element are present in a Queue using the contains() method."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.queue-1?view=net-9.0",
        "document": ""
    },
    {
        "link": "https://linkedin.com/pulse/best-practices-using-queues-stacks-c-melaku-michael-8dujc",
        "document": "A queue is a data structure that follows the first-in, first-out (FIFO) principle. It allows you to store and retrieve elements in the order they were added. In C#, you can use the Queue<T> class from the System.Collections.Generic namespace to work with queues.\n\nUse the Enqueue() method to add elements to the queue. For instance:\n\nTo remove elements from the queue, use the Dequeue() method. It removes and returns the first element in the queue.\n• A queue is useful when you need to process items in the order they were added.\n• The Queue<T> class is generic and type-safe.\n• You can store elements of any type in a queue.\n\nA stack is another fundamental data structure that follows the last-in, first-out (LIFO) principle. It’s like a stack of plates—you can only remove the top plate. In C#, you can use the Stack<T> class from the System.Collections.Generic namespace to work with stacks.\n\nUse the Push() method to add elements to the stack. For example:\n\nTo remove elements from the stack, use the Pop() method. It removes and returns the top element.\n• A stack is useful for managing items in a last-in, first-out order.\n• The Stack<T> class is generic and type-safe.\n• You can store elements of any type in a stack.\n\nQueues and stacks are essential tools in software development. Understanding their principles and best practices will help you write more efficient and organized code. Remember to choose the right data structure based on your specific requirements!"
    },
    {
        "link": "https://stackoverflow.com/questions/25691679/best-way-in-net-to-manage-queue-of-tasks-on-a-separate-single-thread",
        "document": "I know that asynchronous programming has seen a lot of changes over the years. I'm somewhat embarrassed that I let myself get this rusty at just 34 years old, but I'm counting on StackOverflow to bring me up to speed.\n\nWhat I am trying to do is manage a queue of \"work\" on a separate thread, but in such a way that only one item is processed at a time. I want to post work on this thread and it doesn't need to pass anything back to the caller. Of course I could simply spin up a new object and have it loop over a shared object, using sleeps, interrupts, wait handles, etc. But I know things have gotten better since then. We have , , / , not to mention NuGet packages that probably abstract a lot of that.\n\nI know that \"What's the best...\" questions are generally frowned upon so I'll rephrase it by saying \"What is the currently recommended...\" way to accomplish something like this using built-in .NET mechanisms preferably. But if a third party NuGet package simplifies things a bunch, it's just as well.\n\nI considered a instance with a fixed maximum concurrency of 1, but seems there is probably a much less clunky way to do that by now.\n\nSpecifically, what I am trying to do in this case is queue an IP geolocation task during a web request. The same IP might wind up getting queued for geolocation multiple times, but the task will know how to detect that and skip out early if it's already been resolved. But the request handler is just going to throw these calls into a queue and let the method handle duplicate work detection. The geolocation API I am using doesn't like to be bombarded with requests which is why I want to limit it to a single concurrent task at a time. However, it would be nice if the approach was allowed to easily scale to more concurrent tasks with a simple parameter change."
    },
    {
        "link": "https://geeksforgeeks.org/c-sharp-queue-class",
        "document": "In C#, the Queue<T> class is the part of the System.Collections.Generic namespace and represent a first-in-first-out (FIFO) collection of objects. When we add an item to the list, it is called enqueue, and when we remove an item, it is called dequeue.\n• Enqueue adds an element to the end of the Queue.\n• Dequeue removes the oldest element from the start of the Queue.\n• Peek returns the oldest element that is at the start of the Queue but does not remove it from the Queue.\n• capacity of a Queue is the number of elements the Queue can hold.\n• None As elements are added to a Queue, the capacity is automatically increased as required by reallocating the internal array.\n• null as a valid value for reference types and allows duplicate elements.\n\nExample: This example, demonstrates how to create a queue, add different elements to it using the enqueue() Method, and then display the elements using for-each loop.\n\nIn C#, the Queue<T> is a generic collection, meaning it can hold elements of a specific type. T is the type of elements the queue will hold\n\nThe Queue<T> class provides four constructor which are listed below in the table:\n\nExample: This example demonstrates the total number of elements present in the queue.\n\nThe Queue<T> class provides several properties to access its state.\n\nExample: This example demonstrates how to use the SyncRoot property of a Queue to ensure thread safety.\n\nRemoves all objects from the Queue. Determines whether an element is in the Queue. Copies the Queue elements to an existing one-dimensional Array, starting at the specified array index. Removes and returns the object at the beginning of the Queue. Adds an object to the end of the Queue. Determines whether the specified object is equal to the current object. Returns an enumerator that iterates through the Queue. Gets the Type of the current instance. Returns the object at the beginning of the Queue without removing it. Returns a new Queue that wraps the original queue, and is thread safe. Copies the Queue elements to a new array. Sets the capacity to the actual number of elements in the Queue.\n\nExample: This example demonstrates that the specific element is present in the Queue using the Contains() method.\n\nExample: This example demonstrates how to convert a Queue to an object array using ToArray() method."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.orderby?view=net-9.0",
        "document": "An IOrderedEnumerable<TElement> whose elements are sorted according to a key.\n\nThe following code example demonstrates how to use OrderBy<TSource,TKey>(IEnumerable<TSource>, Func<TSource,TKey>) to sort the elements of a sequence.\n\nThis method is implemented by using deferred execution. The immediate return value is an object that stores all the information that is required to perform the action. The query represented by this method is not executed until the object is enumerated either by calling its method directly or by using in C# or in Visual Basic.\n\nTo order a sequence by the values of the elements themselves, specify the identity function ( in C# or in Visual Basic) for .\n\nTwo methods are defined to extend the type IOrderedEnumerable<TElement>, which is the return type of this method. These two methods, namely and , enable you to specify additional sort criteria to sort a sequence. and also return an IOrderedEnumerable<TElement>, which means any number of consecutive calls to or can be made.\n\nThis method compares keys by using the default comparer Default.\n\nThis method performs a stable sort; that is, if the keys of two elements are equal, the order of the elements is preserved. In contrast, an unstable sort does not preserve the order of elements that have the same key.\n\nIn query expression syntax, an (C#) or (Visual Basic) clause translates to an invocation of OrderBy."
    },
    {
        "link": "https://pvs-studio.com/en/blog/posts/csharp/0991",
        "document": "Sorting in C#: OrderBy.OrderBy or OrderBy.ThenBy? What's more effective and why?\n\nSuppose we need to sort the collection by multiple keys. In C#, we can do this with the help of OrderBy().OrderBy() or OrderBy().ThenBy(). But what is the difference between these calls? To answer this question, we need to delve into the source code.\n\nThe article has three chapters:\n• Background. For those who like to warm up a bit before reading an article. Here you'll learn why I decided to do some research and find the difference between OrderBy().OrderBy() and OrderBy().ThenBy().\n• Performance comparison. Here we'll compare the performance and memory consumption of these sorting methods.\n• Behavior differences. Here we'll dive into the source code of .NET to find out why these sorting methods differ in efficiency.\n\nIt all started with the following article: \"Suspicious sortings in Unity, ASP.NET Core, and more\". The article describes cases where the order of OrderBy().OrderBy() calls can lead to errors. However, it turns out that sometimes developers intentionally use OrderBy().OrderBy(), not OrderBy().ThenBy().\n\nTake a look at an example. Let's say we have a Wrapper class and an array of instances of the following type:\n\nWe want to sort this array: first by the Primary value, then by Secondary.\n\nIf we perform sorting as follows — we make a mistake:\n\nWe get the wrong result. To sort the collection correctly, we need to use OrderBy().ThenBy():\n\nHowever, we can also use OrderBy().OrderBy() to get the correct result. We just need to swap the calls.\n\nThat's how we shouldn't do:\n\nAnd that's how we should do:\n\nIt turns out that to get the correct result, we can use both options:\n\nI think the second option is more readable.\n\nWhen you see OrderBy().OrderBy(), you wonder: isn't there an error? So, it is better to use OrderBy().ThenBy(): the code is easier to read, and the developer's intention is clear.\n\nHowever, these sorting methods differ not only in appearance: their performance and memory consumption vary too.\n\nLet's experiment with the following code:\n\nSo, let's sum up the main points:\n• Wrapper is a structure with two integer properties. We will use them as keys for sorting;\n• arr is an array of Wrapper instances that we need to sort. The way it was created is not important for tests. We will measure the performance of sorting and obtaining the final array;\n• there are two ways of sorting: the first one is OrderBy().OrderBy(), the second — OrderBy().ThenBy();\n• the ToArray() call is used to initiate sorting.\n\nTo run tests, I took two sets of generated test data (instances of the Wrapper type). In the first set, the spread of Primary and Secondary values is greater, in the second set it is less. I wrote Wrapper objects (from 10 to 1,000,000) in arr and sorted them.\n\nThe test project is running on .NET 6.\n\nI used BenchmarkDotNet to track the performance.\n\nBelow you can see how much it took to perform sorting and get an array. We're not interested in absolute values — the difference between sorting methods is more important.\n\nLet's move on and see the time difference if we perform several sortings at once. To do this, we use the for loop:\n\nHere's the time (in seconds) spend to sort 1,000,000 instances of the Wrapper type:\n\nWell, the difference in 20 seconds is worth considering.\n\nThere is a similar thing with memory — OrderBy().OrderBy() consumes more. It is especially noticeable on large amounts of data and several iterations.\n\nHere's the difference in the number of objects created per iteration:\n\nAs the table suggests, OrderBy().OrderBy() calls create two more arrays. When I was running the test that had 100 sortings, I got a 1GB difference of allocated memory.\n\nIt's important to note that the larger the sorted collection is, the larger the \"extra\" arrays are. As a result, the amount of consumed memory also increases.\n\nAnd now it's time to look \"under the hood\". Just to remind you — we are considering two ways of sorting:\n\nTo understand the difference, we need to analyze:\n• state of objects for whom methods are called;\n\nThe source code of .NET 6 is available on GitHub.\n\nWe need to discuss three top-level methods: OrderBy, ThenBy, and ToArray. Let's consider each of them.\n\nOrderBy is an extension method that returns an instance of the OrderedEnumerable<TElement, TKey> type:\n\nHere we're interested in the base constructor call — base(source). The base type is OrderedEnumerable<TElement>. The constructor looks as follows:\n\nLet's brush up on what we've already discussed: as a result of the OrderBy call, the OrderedEnumerable<TElement, TKey> instance is created. Its state is determined by the following fields:\n\nIn our case, the type of the source variable is OrderedEnumerable<TElement, TKey>. Let's take a look at the implementation of the CreateOrderedEnumerable method that will be called:\n\nWe see that the constructor of the OrderedEnumerable<TElement, TKey> type (that we've already discussed in the OrderBy section) is called. The arguments of the call differ, and, as a result, the state of the created object differs.\n\nLet's brush it up: ThenBy (like OrderBy), in our case returns an instance of the OrderedEnumerable<TElement, TKey> type.\n\nIn both cases, source are the instances of the OrderedEnumerable<TElement, TKey> type. This type implements the IIlistProvider<TSource> interface. Therefore, the execution will go via the arrayProvider.ToArray() call. In fact, the OrderedEnumerable<TElement>.ToArray method will be called:\n\nAnd here the main differences occur. Before we continue to dive deeper, we need to examine the state of the objects we will be working with.\n\nLet's get back to the source examples:\n\nWe need to compare four objects arranged in pairs:\n• #1.1 and #2.1 are objects created by the first OrderBy calls in both examples;\n• #1.2 and #2.2 are objects created by the second OrderBy call in the first example and by the ThenBy call in the second example.\n\nAs a result, we get 2 tables for comparing the states of objects.\n\nHere are the states of objects created by the first OrderBy calls:\n\nThis pair is identical. Only selectors differ.\n\nHere are the states of objects created by the second call of OrderBy (#1.2) and ThenBy (#2.2):\n\nHere the selectors also differ — and this is expected. Curious that _source and _parent fields differ. The state of the object in case of the ThenBy (#2.2) call seems more correct: the reference to the source collection is saved, and there's a \"parent\" — the result of the previous sorting.\n\nNow we need to find out how the state of objects affects the execution flow.\n\nLet's get back to the ToArray method:\n\nKeep in mind that objects received by different calls have different _source fields:\n\nLet's consider the determining of the Buffer<TElement> type:\n\nThis is where behavior starts to differ:\n• for OrderBy().OrderBy() calls the execution follows the then branch, since OrderedEnumerable implements the IIListProvider<TElement> interface;\n• for OrderBy().ThenBy() calls the execution follows the else branch, because arrays (in our case it is Wrapper[]) do not implement this interface.\n\nIn the first case, we are getting back to the ToArray method that was given above. Then, we get into the Buffer constructor again, but the execution will follow the else branch, because the _source of the object #1.1 is Wrapper[].\n\nEnumerableHelpers.ToArray just creates a copy of the array:\n\nThe execution follows the then branch. I omitted the rest of code, because in our case it is unimportant.\n\nThe difference is clearer in call stacks. Pay attention to the bold \"extra\" calls:\n\nBy the way, this also explains the difference in the number of created objects. Here's the table we discussed previously:\n\nThe most interesting arrays here are: Int32[] and Wrapper[]. They arise because the execution flow unnecessarily passes via the OrderedEnumerable<TElement>.ToArray method once again:\n\nJust to remind you — the sizes of array and map arrays depend on the size of the sorted collection: the larger it is, the larger the overhead will be — because of the unnecessary OrderedEnumerable<TElement>.ToArray call.\n\nThe same thing is with the performance. Let's take another look at the code of the OrderedEnumerable<TElement>.ToArray method:\n\nWe are interested in the map array. It describes the relationship between the positions of elements in arrays:\n• index is the position of an element in the resulting array;\n• the index value is the position in the source array.\n\nLet's say map[5] == 62. This means that the element takes the 62nd position in the source array, and the 5th position in the resulting array.\n\nTo get a so-called \"relationship map\", the SortedMap method is used:\n\nLet's take a look at the method overload:\n\nHere comes up another difference between the sorting methods that we are discussing:\n• OrderBy().OrderBy(): _parent of the object #1.2 is null. As a result, one instance of EnumerableSorter is created.\n• OrderBy().ThenBy(): _parent of the object #2.2 points to the object #2.1. This means that two EnumerableSorter instances related to each other will be created. This happens because the _parent.GetEnumerableSorter(sorter) method is called once again.\n\nThe constructor just initializes the object fields. There is another field that is not used in the constructor — _keys. It will be initialized later in the ComputeKeys method.\n\nLet's consider what the fields are responsible for. To do this, let's discuss one of the sorting ways:\n\nTo perform sorting via OrderBy, an instance of EnumerableSorter will be created. It has the following fields:\n• _keySelector: a delegate responsible for mapping the source object to the key. In our case it's Wrapper -> int. The delegate: p => p.Primary;\n• _comparer: a comparator used to compare keys. Comparer<T>.Default if not explicitly specified;\n• _descenging: a flag meaning that the collection is sorted in descending order;\n• _next: a reference to the EnumerableSorter object responsible for the following sorting criteria. In the example above, there is a reference to an object that was created for sorting by the criterion from ThenBy.\n\nAfter the EnumerableSorter instance was created and initialized, the Sort method is called for it:\n\nHere's the body of the Sort method:\n\nLet's take a look at the ComputeKeys method:\n\nIn this method, the _keys array of the EnumerableSorter instance is initialized. The _next?.ComputeKeys(elements, count) call allows initializing the entire chain of related EnumerableSorter objects.\n\nWhy do we need the _keys field? The array stores the results of calling the selector on each element of the source array. So, we get an array of keys that will be used to perform sorting.\n\nIn this example, two related EnumerableSorter instances will be created.\n\nThus, _keys stores sorting keys for each element of the source array.\n\nLet's get back to the ComputeMap method:\n\nAfter calling the ComputeKeys method, the map array is created and initialized. This is the array that describes the relationship between the positions in the source and resulting arrays. In this method, it still describes the i -> i relationship. This means that the positions in the source array coincide with the positions in the resulting array.\n\nLet's get back to the Sort method:\n\nWe are interested in the QuickSort method that makes the map array to look the way we need. Right after this operation we get the correct relationship between the positions of elements in the source array and in the resulting one.\n\nHere's the body of the QuickSort method:\n\nWe won't dive into the details of Span and its Sort method. Let's focus on the fact that it sorts the array considering the Comparison delegate:\n\nIt's a classic delegate for comparison. It takes two elements, compares them, and returns the value:\n• < 0 if x is less than y;\n• 0 if x is equal to y;\n• > 0 if x is greater than y.\n\nIn our case, the CompareAnyKeys method is used for comparison:\n\nSo, let's see what we have:\n\nTwo elements are compared via a comparator written in _comparer. Since we have not explicitly set any comparator, Comparer<T>.Default is used (in our case – Comparer<Int32>.Default).\n\nIf elements are not equal, the c == 0 condition is not executed, and the execution flow goes to return. The _descending field stores the information on how the elements are sorted — in descending or ascending order. If necessary, the field is used to correct the value returned by the method.\n\nBut what if the elements are equal?\n\nHere come the chains of EnumerableSorter instances related to each other. If the compared keys are equal, a check is performed to see if there are any other sorting criteria. If there is (_next != null), the comparison is performed via them.\n\nIt turns out that all sorting criteria are considered in one call of the Sort method.\n\nWhat happens if we use OrderBy().OrderBy()? To find out, let's get back to creating the EnumerableSorter instance:\n\nThe _parent value of the object obtained as a result of the second OrderBy call is null. This means that one EnumerableSorter instance is created. It is not related to something, the value of _next is null.\n\nIt turns out that we need to perform all the actions described above twice. We've already discussed how this affects the performance. To remind you, I'd duplicate one of the tables given above.\n\nHere's the time (in seconds) spend to sort 1,000,000 instances of the Wrapper type:\n\nThe OrderBy and ThenBy methods create OrderedEnumerable instances that are used to perform sorting. Instances of the EnumerableSorter type help perform sorting. They affect the algorithm, use specified selectors and a comparator.\n\nThe main difference between OrderBy().OrderBy() and OrderBy().ThenBy() calls is the relations between objects.\n\nOrderBy().OrderBy(). There are no relations between OrderedEnumerable or EnumerableSorter. As a result, \"extra\" objects are created — instead of one sorting, we get two. Memory consumption is growing, and the code runs slower.\n\nOrderBy().ThenBy(). Both OrderedEnumerable and EnumerableSorter instances are related. Because of this, one sorting operation is performed by several criteria at once. Extra objects are not created. Memory consumption is reduced, and the code runs faster.\n\nThe code that uses OrderBy().ThenBy() instead of OrderBy().OrderBy():\n• is better to read;\n\nFollow me on Twitter, if you are interested in such publications."
    },
    {
        "link": "https://stackoverflow.com/questions/3976602/how-to-sort-collection-by-using-linq-method",
        "document": "I'm not entirely sure what it is you're asking. As I understood what you said, you want to sort by based on the ordering of in which is a list of captions. You could do this then:\n\n[edit]\n\n Part of the confusion I had with your question was that I did not know how you wanted to determine the order of the items in based on the values of 's in the list . There is no natural ordering I can see. But now since I know that it is of type , I can make some educated guesses as to what you mean.\n\nIf I can assume that all items in have the same value for , then you just need to get the value from one of them and sort by that. You can get it by using .\n\nIf it is possible to have different values of and you wanted to get the most common value, you would have to find the value that occurs the most.\n\nI hope I captured your meaning in these possible solutions."
    },
    {
        "link": "https://geeksforgeeks.org/c-sharp-program-to-sort-a-list-of-integers-using-the-linq-orderby-method",
        "document": "C# Program to Sort a List of Integers Using the LINQ OrderBy() Method\n\nGiven a list of integers, now our task is to sort the given list of integers. So we use the OrderBy() method of LINQ. This method is used to sort the elements in the collection in ascending order. This method is overloaded in two different ways:\n• OrderBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>): It is used to sort the items of the given sequence in ascending order according to the key and performs a stable sort on the given sequence or list.\n• OrderBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IComparer<TKey>): It is used to sort the items of the given sequence in ascending order by using a given comparer and also performs a stable sort on the given sequence.\n\n1. Create and initialize a list of integer types. For example nums.\n\n3. Display the result using the foreach loop."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/linq/standard-query-operators/sorting-data",
        "document": "A sorting operation orders the elements of a sequence based on one or more attributes. The first sort criterion performs a primary sort on the elements. By specifying a second sort criterion, you can sort the elements within each primary sort group.\n\nThe following illustration shows the results of an alphabetical sort operation on a sequence of characters:\n\nThe standard query operator methods that sort data are listed in the following section.\n\nThe following examples in this article use the common data sources for this area.\n\n Each has a grade level, a primary department, and a series of scores. A also has a property that identifies the campus where the teacher holds classes. A has a name, and a reference to a who serves as the department head.\n\n You can find the example data set in the source repo.\n\nThe following example demonstrates how to use the clause in a LINQ query to sort the array of teachers by family name, in ascending order.\n\nThe equivalent query written using method syntax is shown in the following code:\n\nThe next example demonstrates how to use the clause in a LINQ query to sort the teachers by family name, in descending order.\n\nThe equivalent query written using method syntax is shown in the following code:\n\nThe following example demonstrates how to use the clause in a LINQ query to perform a primary and secondary sort. The teachers are sorted primarily by city and secondarily by their family name, both in ascending order.\n\nThe equivalent query written using method syntax is shown in the following code:\n\nThe next example demonstrates how to use the clause in a LINQ query to perform a primary sort, in ascending order, and a secondary sort, in descending order. The teachers are sorted primarily by city and secondarily by their family name.\n\nThe equivalent query written using method syntax is shown in the following code:\n• How to sort or filter text data by any word or field (LINQ) (C#)"
    }
]