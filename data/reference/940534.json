[
    {
        "link": "https://github.com/ArcadiaPower/arc-quickstart",
        "document": ""
    },
    {
        "link": "https://toml.io/en",
        "document": "Multi-line basic strings are surrounded by three quotation marks on each side and allow newlines. Include a line ending backslash to automatically trim whitespace preceeding any non-whitespace characters:\n\nbecomes \"The quick brown fox jumps over the lazy dog.\" (a single sentence with no line breaks).\n\nLiteral strings are surrounded by single quotes. No escaping is performed so what you see is what you get:\n\nSince there is no escaping, there is no way to write a single quote inside a literal string enclosed by single quotes. That's where multi-line literal strings come in:"
    },
    {
        "link": "https://packaging.python.org/en/latest/guides/writing-pyproject-toml",
        "document": "is a configuration file used by packaging tools, as well as other tools such as linters, type checkers, etc. There are three possible TOML tables in this file.\n• None The table is strongly recommended. It allows you to declare which build backend you use and which other dependencies are needed to build your project.\n• None The table is the format that most build backends use to specify your project’s basic metadata, such as the dependencies, your name, etc.\n• None The table has tool-specific subtables, e.g., , , . We only touch upon this table here because its contents are defined by each tool. Consult the particular tool’s documentation to know what it can contain.\n\nThe table should always be present, regardless of which build backend you use ( defines the build tool you use). On the other hand, the table is understood by most build backends, but some build backends use a different format. A notable exception is Poetry, which before version 2.0 (released January 5, 2025) did not use the table, it used the table instead. With version 2.0, it supports both. Also, the setuptools build backend supports both the table, and the older format in or . For new projects, use the table, and keep only if some programmatic configuration is needed (such as building C extensions), but the and formats are still valid. See Is setup.py deprecated?.\n\nThe table contains a key, which specifies the build backend to be used. It also contains a key, which is a list of dependencies needed to build the project – this is typically just the build backend package, but it may also contain additional dependencies. You can also constrain the versions, e.g., . Usually, you’ll just copy what your build backend’s documentation suggests (after choosing your build backend). Here are the values for some common build backends:\n\nThe rest of this guide is devoted to the table. Most of the time, you will directly write the value of a field. For example: , or . However, in some cases, it is useful to let your build backend compute the metadata for you. For example: many build backends can read the version from a attribute in your code, a Git tag, or similar. In such cases, you should mark the field as dynamic using, e.g., When a field is dynamic, it is the build backend’s responsibility to fill it. Consult your build backend’s documentation to learn how it does it.\n\nPut the name of your project on PyPI. This field is required and is the only field that cannot be marked as dynamic. The project name must consist of ASCII letters, digits, underscores “ ”, hyphens “ ” and periods “ ”. It must not start or end with an underscore, hyphen or period. Comparison of project names is case insensitive and treats arbitrarily long runs of underscores, hyphens, and/or periods as equal. For example, if you register a project named , users will be able to download it or declare a dependency on it using any of the following spellings: , , , . Put the version of your project. Some more complicated version specifiers like (for an alpha release) are possible; see the specification for full details. This field is required, although it is often marked as dynamic using This allows use cases such as filling the version from a attribute or a Git tag. Consult the Single-sourcing the Project Version discussion for more details.\n\nTo install a command as part of your package, declare it in the table. In this example, after installing your project, a command will be available. Executing this command will do the equivalent of . On Windows, scripts packaged this way need a terminal, so if you launch them from within a graphical application, they will make a terminal pop up. To prevent this from happening, use the table instead of . In that case, launching your script from the command line will give back control immediately, leaving the script to run in the background. The difference between and is only relevant on Windows.\n\nBoth of these fields contain lists of people identified by a name and/or an email address. This should be a one-line description of your project, to show as the “headline” of your project page on PyPI (example), and other places such as lists of search results (example). This is a longer description of your project, to display on your project page on PyPI. Typically, your project will have a or file and you just put its file name here. The README’s format is auto-detected from the extension: You can also specify the format explicitly, like this: PEP 639 (accepted in August 2024) has changed the way the field is declared. Make sure your preferred build backend supports PEP 639 before trying to apply the newer guidelines. As of February 2025, setuptools and flit don’t support PEP 639 yet. This is a valid SPDX license expression consisting of one or more license identifiers. The full license list is available at the SPDX license list page. The supported list version is 3.17 or any later compatible one. As a general rule, it is a good idea to use a standard, well-known license, both to avoid confusion and because some organizations avoid software whose license is unapproved. If your project is licensed with a license that doesn’t have an existing SPDX identifier, you can create a custom one in format . The custom identifiers must follow the SPDX specification, clause 10.1 of the version 2.2 or any later compatible one. This can take two forms. You can put your license in a file, typically or , and link that file here: or you can write the name of the license: If you are using a standard, well-known license, it is not necessary to use this field. Instead, you should use one of the classifiers starting with . (As a general rule, it is a good idea to use a standard, well-known license, both to avoid confusion and because some organizations avoid software whose license is unapproved.) PEP 639 (accepted in August 2024) has introduced the field. Make sure your preferred build backend supports PEP 639 before declaring the field. As of February 2025, setuptools and flit don’t support PEP 639 yet. This is a list of license files and files containing other legal information you want to distribute with your package. The glob patterns must follow the specification:\n• None Alphanumeric characters, underscores ( ), hyphens ( ) and dots ( ) will be matched verbatim.\n• None Path delimiters must be the forward slash character ( ).\n• None Patterns are relative to the directory containing , and thus may not start with a slash character.\n• None Parent directory indicators ( ) must not be used.\n• None Each glob must match at least one file. Literal paths are valid globs. Any characters or character sequences not covered by this specification are invalid. This will help PyPI’s search box to suggest your project when people search for these keywords. A list of PyPI classifiers that apply to your project. Check the full list of possibilities. # How mature is this project? Common values are # Indicate who your project is intended for # Specify the Python versions you support here. Although the list of classifiers is often used to declare what Python versions a project supports, this information is only used for searching and browsing projects on PyPI, not for installing projects. To actually restrict what Python versions a project can be installed on, use the requires-python argument. To prevent a package from being uploaded to PyPI, use the special classifier. PyPI will always reject packages with classifiers beginning with . A list of URLs associated with your project, displayed on the left sidebar of your PyPI project page. See Well-known labels for a listing of labels that PyPI and other packaging tools are specifically aware of, and PyPI’s project metadata docs for PyPI-specific URL processing. Note that if the label contains spaces, it needs to be quoted, e.g., but . Users are advised to use Well-known labels for their project URLs where appropriate, since consumers of metadata (like package indices) can specialize their presentation. For example in the following metadata, neither nor is a well-known label, so they will be rendered verbatim: Whereas in this metadata and both have well-known equivalents ( and ), and can be presented with those semantics in mind (the project’s home page and its external download location, respectively)."
    },
    {
        "link": "https://docs.h2o.ai/driverless-ai/1-10-lts/docs/userguide/config_toml.html",
        "document": "The file is a configuration file that uses the TOML v0.5.0 file format. Administrators can customize various aspects of a Driverless AI (DAI) environment by editing the file before starting DAI.\n\nStart DAI. Note that the command used to start DAI varies depending on your install type.\n\nEdit the desired variables in the config.toml file. Save your changes when you are done.\n\nExport the DAI config.toml file or add it to ~/.bashrc . For example:\n\nStart DAI with the DRIVERLESS_AI_CONFIG_FILE environment variable. Ensure that this environment variable points to the location of the edited config.toml file so that the software can locate the configuration file.\n\nEdit the desired variables in the config.toml file. Save your changes when you are done.\n\nCopy the config.toml file from inside the Docker image to your local filesystem.\n\nEnvironment variable - Configuration variables can also be provided as environment variables. They must have the prefix DRIVERLESS_AI_ followed by the variable name in all caps. For example, “authentication_method” can be provided as “DRIVERLESS_AI_AUTHENTICATION_METHOD”. Setting environment variables overrides values from the keystore file.\n\nKeystore file - Set the keystore_file parameter in the config.toml file or the environment variable “DRIVERLESS_AI_KEYSTORE_FILE” to point to a valid DAI keystore file generated using the h2oai.keystore tool. If an environment variable is set, the value in the config.toml for keystore_file is overridden.\n\nconfig.toml - Place this file in a folder or mount it in a Docker container and specify the path in the “DRIVERLESS_AI_CONFIG_FILE” environment variable.\n\nThe configuration engine reads and overrides variables in the following order:\n\nThe following is a copy of the standard file included with this version of DAI. The sections that follow describe some examples showing how to set different environment variables, data connectors, authentication methods, and notifications."
    },
    {
        "link": "https://anbowell.com/blog/the-developers-guide-to-toml",
        "document": "Everything you need to know to get started with TOML - examples, config files, serialization and more.\n\nTOML (Tom's Obvious Minimal Language) is a language designed to create simple, human readable configuration files. It's 2013 release makes it a relatively new language yet TOML has gained significant traction across software development. This is part due to it's syntax being reminiscent of '.ini' configuration files but with a single formal specification.\n\nTOML is built around the concept of Key/Value pairs. Tables can then be used group and structure the pairs into a hierarchy, much like JSON and YAML. The idea is that a TOML file can easily become a table/map/dictionary in whichever programming language you're using. TOML also has arrays which can be used to store lists of values or further nest arrays and tables. As with YAML, tables can be represented as their own structure or inline in a style similar to JSON.\n\nTo make your file as readable as possible you'll want to ensure you only use inline tables when necessary for small, easily represented data. Arrays are a little more complex. A basic array can contain data of various types,\n\nbut, if you wish to combine the lists and tables, the syntax is a little more complicated and we'll dive into that later.\n\nKey/Value pairs in TOML must map to one of the following types.\n\nTOML also has three different types of key too.\n• Quoted\n• Surrounded by \", can contain spaces, dots, etc. Bare keys are preferred\n\nComments are allowed and should be written after a '#'.\n\nThe example below shows off everything you can do within a '.toml' file.\n\nWhile the example above is a helpful little cheatsheet it lacks the context to give you and understanding of TOML. So, let's say I want to open a garden centre and need to keep track of all the different plants, where they are, and when they're about to flower. I need this file to be readable as I'll be handing it out to all the employees as well as ingesting it into the cash registers. I could write out this data in TOML as follows.\n\nUsing a converter we can take a look at what this would look like as a JSON.\n\nAs you can see, the comments have been removed and the dates have been turned into strings, as they're not supported in JSON, and the overall readability of the file has decreased. This is an excellent demonstration of why TOML is a favorite of mine for writing configuration files.\n\nLet's take a quick look at a TOML file in the real world now. The programming language Rust uses TOML in its manifest files. A manifest file is where all the metadata about your code is stored - for example, dependencies, authors, licenses, and a variety of compiler options. A basic 'Cargo.toml' file is seen below.\n\nDefining dependencies and compiler options within a TOML file makes it extraordinary clear to the next developer what dependencies were used and which options the code was compiled with.\n\nTo start using TOML in your projects, you'll need to know about the process of parsing/deserializing a TOML file as you'll need it in a usable format in your chosen programming language. Generally, dynamically and strongly typed languages complete this process in two different ways. In languages languages such as Python or JavaScript where the interpreter infers what type a variable is, a TOML file is parsed directly into a dictionary/object. This can be nested, contain combinations of any types, and be used however you wish. Let's check out an example of this using Python to calculate a simple polynomial equation.\n\nAs you can see, it's super simple to load in the file and use it as a standard dictionary type in Python. Let's take a look at doing this in a strongly typed, compiled language. Using Rust we'll recreate the same example. First, we'll use the Cargo.toml manifest file to declare our dependencies.\n\nNow let's say you're not sure what the exact format of the TOML data will be. It may change each and every time you use it and you want a way to read it in generically like in Python. You can do this using an enumeration. The toml package includes one called Value and it can contain all possible types within the TOML file.\n\nSo, we can remove our structs and read the data into this enumeration.\n\nIf you use a generic enumeration like this the downside is you'll have to check the type of each Value every time you want to use it. More often than not it's easier to use optional struct fields to try and coerce your data into a somewhat known structure and just check whether or not certain fields were present.\n\nAs seen in the Python and Rust examples, most programming languages will have packages which help you parse and stringify TOML data. I've listed some popular ones below.\n\nIn addition to earlier blogs on JSON and YAML I've also created some online tools which help you validate and convert TOML files!\n\nThanks for taking the time to read this article. You can also find this post on Medium. Next up I'll be comparing the differences between JSON, YAML, and TOML."
    },
    {
        "link": "https://doc.rust-lang.org/cargo/reference/config.html",
        "document": "This document explains how Cargo’s configuration system works, as well as available keys or configuration. For configuration of a package through its manifest, see the manifest format.\n\nCargo allows local configuration for a particular package as well as global configuration. It looks for configuration files in the current directory and all parent directories. If, for example, Cargo were invoked in , then the following configuration files would be probed for and unified in this order:\n\nWith this structure, you can specify configuration per-package, and even possibly check it into version control. You can also specify personal defaults with a configuration file in your home directory.\n\nIf a key is specified in multiple config files, the values will get merged together. Numbers, strings, and booleans will use the value in the deeper config directory taking precedence over ancestor directories, where the home directory is the lowest priority. Arrays will be joined together with higher precedence items being placed later in the merged array.\n\nAt present, when being invoked from a workspace, Cargo does not read config files from crates within the workspace. i.e. if a workspace has two crates in it, named and , and there are Cargo configs at and , Cargo does not read those configuration files if it is invoked from the workspace root ( ).\n\nConfiguration files are written in the TOML format (like the manifest), with simple key-value pairs inside of sections (tables). The following is a quick overview of all settings, with detailed descriptions found below.\n\nCargo can also be configured through environment variables in addition to the TOML configuration files. For each configuration key of the form the environment variable can also be used to define the value. Keys are converted to uppercase, dots and dashes are converted to underscores. For example the key can also be defined by the environment variable.\n\nEnvironment variables will take precedence over TOML configuration files. Currently only integer, boolean, string and some array values are supported to be defined by environment variables. Descriptions below indicate which keys support environment variables and otherwise they are not supported due to technical issues.\n\nIn addition to the system above, Cargo recognizes a few other specific environment variables.\n\nCargo also accepts arbitrary configuration overrides through the command-line option. The argument should be in TOML syntax of or provided as a path to an extra configuration file:\n\nThe option may be specified multiple times, in which case the values are merged in left-to-right order, using the same merging logic that is used when multiple configuration files apply. Configuration values specified this way take precedence over environment variables, which take precedence over configuration files.\n\nWhen the option is provided as an extra configuration file, The configuration file loaded this way follow the same precedence rules as other options specified directly with .\n\nSome examples of what it looks like using Bourne shell syntax:\n\nPaths in config files may be absolute, relative, or a bare name without any path separators. Paths for executables without a path separator will use the environment variable to search for the executable. Paths for non-executables will be relative to where the config value is defined.\n\nIn particular, rules are:\n• For environment variables, paths are relative to the current working directory.\n• For config values loaded directly from the option, paths are relative to the current working directory.\n• For config files, paths are relative to the parent directory of the directory where the config files were defined, no matter those files are from either the hierarchical probing or the option.\n\nSome Cargo commands invoke external programs, which can be configured as a path and some number of arguments.\n\nThe value may be an array of strings like or a space-separated string like . If the path to the executable contains a space, the list form must be used.\n\nIf Cargo is passing other arguments to the program such as a path to open or run, they will be passed after the last specified argument in the value of an option of this format. If the specified program does not have path separators, Cargo will search for its executable.\n\nConfiguration values with sensitive information are stored in the file. This file is automatically created and updated by and when using the credential provider.\n\nTokens are used by some Cargo commands such as for authenticating with remote registries. Care should be taken to protect the tokens and to keep them secret.\n\nIt follows the same format as Cargo config files.\n\nAs with most other config values, tokens may be specified with environment variables. The token for crates.io may be specified with the environment variable. Tokens for other registries may be specified with environment variables of the form where is the name of the registry in all capital letters.\n\nThis section documents all configuration keys. The description for keys with variable parts are annotated with angled brackets like where the part can be any target triple like .\n\nAn array of paths to local packages which are to be used as overrides for dependencies. For more information see the Overriding Dependencies guide.\n\nThe table defines CLI command aliases. For example, running is an alias for running . Each key in the table is the subcommand, and the value is the actual command to run. The value may be an array of strings, where the first element is the command and the following are arguments. It may also be a string, which will be split on spaces into subcommand and arguments. The following aliases are built-in to Cargo:\n\nAliases are not allowed to redefine existing built-in commands.\n\nSets the maximum number of compiler processes to run in parallel. If negative, it sets the maximum number of compiler processes to the number of logical CPUs plus provided value. Should not be 0. If a string is provided, it sets the value back to defaults.\n\nCan be overridden with the CLI option.\n\nSets the executable to use for .\n\nSets a wrapper to execute instead of . The first argument passed to the wrapper is the path to the actual executable to use (i.e., , if that is set, or otherwise).\n\nSets a wrapper to execute instead of , for workspace members only. When building a single-package project without workspaces, that package is considered to be the workspace. The first argument passed to the wrapper is the path to the actual executable to use (i.e., , if that is set, or otherwise). It affects the filename hash so that artifacts produced by the wrapper are cached separately.\n\nIf both and are set, then they will be nested: the final invocation is .\n\nSets the executable to use for .\n\nThe default target platform triples to compile to.\n\nThis allows passing either a string or an array of strings. Each string value is a target platform triple. The selected build targets will be built for each of the selected architectures.\n\nThe string value may also be a relative path to a target spec file.\n\nCan be overridden with the CLI option.\n\nThe path to where all compiler output is placed. The default if not specified is a directory named located at the root of the workspace.\n\nCan be overridden with the CLI option.\n\nExtra command-line flags to pass to . The value may be an array of strings or a space-separated string.\n\nThere are four mutually exclusive sources of extra flags. They are checked in order, with the first one being used:\n• All matching and config entries joined together.\n\nAdditional flags may also be passed with the command.\n\nIf the flag (or ) is used, then the flags will only be passed to the compiler for the target. Things being built for the host, such as build scripts or proc macros, will not receive the args. Without , the flags will be passed to all compiler invocations (including build scripts and proc macros) because dependencies are shared. If you have args that you do not want to pass to build scripts or proc macros and are building for the host, pass with the host triple.\n\nIt is not recommended to pass in flags that Cargo itself usually manages. For example, the flags driven by profiles are best handled by setting the appropriate profile setting.\n\nExtra command-line flags to pass to . The value may be an array of strings or a space-separated string.\n\nThere are four mutually exclusive sources of extra flags. They are checked in order, with the first one being used:\n\nAdditional flags may also be passed with the command.\n\nWhether or not to perform incremental compilation. The default if not set is to use the value from the profile. Otherwise this overrides the setting of all profiles.\n\nThe environment variable can be set to to force enable incremental compilation for all profiles, or to disable it. This env var overrides the config setting.\n\nStrips the given path prefix from dep info file paths. This config setting is intended to convert absolute paths to relative paths for tools that require relative paths.\n\nThe setting itself is a config-relative path. So, for example, a value of would strip all paths starting with the parent directory of the directory.\n\nThis option is deprecated and unused. Cargo always has pipelining enabled.\n\nThe table defines credential provider aliases. These aliases can be referenced as an element of the array, or as a credential provider for a specific registry under .\n\nIf specified as a string, the value will be split on spaces into path and arguments.\n\nFor example, to define an alias called :\n\nSee Registry Authentication for more information.\n\nThe table defines options for the command.\n• Type: string or array of strings (program path with args)\n• Default: environment variable, or, if that is missing, opening the link in a system specific way\n\nThis option sets the browser to be used by , overriding the environment variable when opening documentation with the option.\n\nThe table defines defaults for the command.\n\nThis option is deprecated and unused.\n\nThis option is deprecated and unused.\n\nSpecifies the source control system to use for initializing a new repository. Valid values are , (for Mercurial), , or to disable this behavior. Defaults to , or if already inside a VCS repository. Can be overridden with the CLI option.\n\nThe section allows you to set additional environment variables for build scripts, rustc invocations, and .\n\nBy default, the variables specified will not override values that already exist in the environment. This behavior can be changed by setting the flag.\n\nSetting the flag evaluates the value as a config-relative path that is relative to the parent directory of the directory that contains the file. The value of the environment variable will be the full absolute path.\n\nControls how often we display a notification to the terminal when a future incompat report is available. Possible values:\n\nThe table defines settings for HTTP behavior. This includes fetching crate dependencies and accessing remote git repositories.\n\nIf , enables debugging of HTTP requests. The debug information can be seen by setting the environment variable (or use for even more information).\n\nBe wary when posting logs from this output in a public location. The output may include headers with authentication tokens which you don’t want to leak! Be sure to review logs before posting them.\n• Environment: or or or\n\nSets an HTTP and HTTPS proxy to use. The format is in libcurl format as in . If not set, Cargo will also check the setting in your global git configuration. If none of those are set, the or environment variables set the proxy for HTTPS requests, and sets it for HTTP requests.\n\nSets the timeout for each HTTP request, in seconds.\n\nPath to a Certificate Authority (CA) bundle file, used to verify TLS certificates. If not specified, Cargo attempts to use the system certificates.\n\nThis determines whether or not TLS certificate revocation checks should be performed. This only works on Windows.\n\nThis sets the minimum TLS version to use. It takes a string, with one of the possible values of , , , , , or .\n\nThis may alternatively take a table with two keys, and , which each take a string value of the same kind that specifies the minimum and maximum range of TLS versions to use.\n\nThe default is a minimum version of and a max of the newest version supported on your platform, typically .\n\nThis setting controls timeout behavior for slow connections. If the average transfer speed in bytes per second is below the given value for seconds (default 30 seconds), then the connection is considered too slow and Cargo will abort and retry.\n\nWhen , Cargo will attempt to use the HTTP2 protocol with multiplexing. This allows multiple requests to use the same connection, usually improving performance when fetching multiple files. If , Cargo will use HTTP 1.1 without pipelining.\n\nSpecifies a custom user-agent header to use. The default if not specified is a string that includes Cargo’s version.\n\nThe table defines defaults for the command.\n\nSets the path to the root directory for installing executables for . Executables go into a directory underneath the root.\n\nTo track information of installed executables, some extra files, such as and , are also created under this root.\n\nThe default if not specified is Cargo’s home directory (default in your home directory).\n\nCan be overridden with the command-line option.\n\nIf this is , then Cargo will use the executable to fetch registry indexes and git dependencies. If , then it uses a built-in library.\n\nSetting this to can be helpful if you have special authentication requirements that Cargo does not support. See Git Authentication for more information about setting up git authentication.\n\nIf this is , then Cargo will avoid accessing the network, and attempt to proceed with locally cached data. If , Cargo will access the network as needed, and generate an error if it encounters a network error.\n\nCan be overridden with the command-line option.\n\nThe table contains settings for SSH connections.\n\nThe array contains a list of SSH host keys that should be accepted as valid when connecting to an SSH server (such as for SSH git dependencies). Each entry should be a string in a format similar to OpenSSH files. Each string should start with one or more hostnames separated by commas, a space, the key type name, a space, and the base64-encoded key. For example:\n\nCargo will attempt to load known hosts keys from common locations supported in OpenSSH, and will join those with any listed in a Cargo configuration file. If any matching entry has the correct key, the connection will be allowed.\n\nCargo comes with the host keys for github.com built-in. If those ever change, you can add the new keys to the config or known_hosts file.\n\nSee Git Authentication for more details.\n\nJust as you can override dependencies using in , you can override them in the cargo configuration file to apply those patches to any affected build. The format is identical to the one used in .\n\nSince files are not usually checked into source control, you should prefer patching using where possible to ensure that other developers can compile your crate in their own environments. Patching through cargo configuration files is generally only appropriate when the patch section is automatically generated by an external build tool.\n\nIf a given dependency is patched both in a cargo configuration file and a file, the patch in the configuration file is used. If multiple configuration files patch the same dependency, standard cargo configuration merging is used, which prefers the value defined closest to the current directory, with taking the lowest precedence.\n\nRelative dependencies in such a section are resolved relative to the configuration file they appear in.\n\nThe table can be used to globally change profile settings, and override settings specified in . It has the same syntax and options as profiles specified in . See the Profiles chapter for details about the options.\n\nThe build-override table overrides settings for build scripts, proc macros, and their dependencies. It has the same keys as a normal profile. See the overrides section for more details.\n\nThe package table overrides settings for specific packages. It has the same keys as a normal profile, minus the , , and settings. See the overrides section for more details.\n\nWhen resolving which version of a dependency to use, select how versions with incompatible s are treated. Values include:\n• : treat -incompatible versions like any other version\n• : only consider -incompatible versions if no other version matched\n\nCan be overridden with\n• Setting the dependency’s version requirement higher than any version with a compatible\n• Specifying the version to with\n\nSee the resolver chapter for more details.\n\nThe table is used for specifying additional registries. It consists of a sub-table for each named registry.\n\nSpecifies the URL of the index for the registry.\n\nSpecifies the authentication token for the given registry. This value should only appear in the credentials file. This is used for registry commands like that require authentication.\n\nCan be overridden with the command-line option.\n• Type: string or array of path and arguments\n\nSpecifies the credential provider for the given registry. If not set, the providers in will be used.\n\nIf specified as a string, path and arguments will be split on spaces. For paths or arguments that contain spaces, use an array.\n\nIf the value exists in the table, the alias will be used.\n\nSee Registry Authentication for more information.\n\nSpecifies the protocol used to access crates.io. Allowed values are or .\n\ncauses Cargo to clone the entire index of all packages ever published to crates.io from https://github.com/rust-lang/crates.io-index/. This can have performance implications due to the size of the index. is a newer protocol which uses HTTPS to download only what is necessary from https://index.crates.io/. This can result in a significant performance improvement for resolving new dependencies in most situations.\n\nMore information about registry protocols may be found in the Registries chapter.\n\nThe table controls the default registry used when one is not specified.\n\nThis value is no longer accepted and should not be used.\n\nThe name of the registry (from the table) to use by default for registry commands like .\n\nCan be overridden with the command-line option.\n• Type: string or array of path and arguments\n\nSpecifies the credential provider for crates.io. If not set, the providers in will be used.\n\nIf specified as a string, path and arguments will be split on spaces. For paths or arguments that contain spaces, use an array.\n\nIf the value exists in the table, the alias will be used.\n\nSee Registry Authentication for more information.\n\nSpecifies the authentication token for crates.io. This value should only appear in the credentials file. This is used for registry commands like that require authentication.\n\nCan be overridden with the command-line option.\n\nSpecifies the list of global credential providers. If credential provider is not set for a specific registry using , Cargo will use the credential providers in this list. Providers toward the end of the list have precedence.\n\nPath and arguments are split on spaces. If the path or arguments contains spaces, the credential provider should be defined in the table and referenced here by its alias.\n\nSee Registry Authentication for more information.\n\nThe table defines the registry sources available. See Source Replacement for more information. It consists of a sub-table for each named source. A source should only define one kind (directory, registry, local-registry, or git).\n\nIf set, replace this source with the given named source or named registry.\n\nSets the path to a directory to use as a directory source.\n\nSets the URL to use for a registry source.\n\nSets the path to a directory to use as a local registry source.\n\nSets the URL to use for a git repository source.\n\nSets the branch name to use for a git repository.\n\nIf none of , , or is set, defaults to the branch.\n\nSets the tag name to use for a git repository.\n\nIf none of , , or is set, defaults to the branch.\n\nSets the revision to use for a git repository.\n\nIf none of , , or is set, defaults to the branch.\n\nThe table is used for specifying settings for specific platform targets. It consists of a sub-table which is either a platform triple or a expression. The given values will be used if the target platform matches either the value or the expression.\n\nvalues come from those built-in to the compiler (run to view) and extra flags passed to (such as those defined in ). Do not try to match on , , Cargo features like , or values set by build scripts.\n\nIf using a target spec JSON file, the value is the filename stem. For example would match .\n\nThis option is deprecated and unused.\n\nSpecifies the linker which is passed to (via ) when the is being compiled for. By default, the linker is not overridden.\n\nThis is similar to the target linker, but using a expression. If both a and runner match, the will take precedence. It is an error if more than one runner matches the current target.\n• Type: string or array of strings (program path with args)\n\nIf a runner is provided, executables for the target will be executed by invoking the specified runner with the actual executable passed as an argument. This applies to , and commands. By default, compiled executables are executed directly.\n\nThis is similar to the target runner, but using a expression. If both a and runner match, the will take precedence. It is an error if more than one runner matches the current target.\n\nPasses a set of custom flags to the compiler for this . The value may be an array of strings or a space-separated string.\n\nSee for more details on the different ways to specific extra flags.\n\nThis is similar to the target rustflags, but using a expression. If several and entries match the current target, the flags are joined together.\n\nPasses a set of custom flags to the compiler for this . The value may be an array of strings or a space-separated string.\n\nSee for more details on the different ways to specific extra flags.\n\nThe links sub-table provides a way to override a build script. When specified, the build script for the given library will not be run, and the given values will be used instead.\n\nControls whether or not log messages are displayed by Cargo.\n\nSpecifying the flag will override and force quiet output. Specifying the flag will override and disable quiet output.\n\nControls whether or not extra detailed messages are displayed by Cargo.\n\nSpecifying the flag will override and disable verbose output. Specifying the flag will override and force verbose output.\n\nControls whether or not colored output is used in the terminal. Possible values:\n• (default): Automatically detect if color support is available on the terminal.\n\nCan be overridden with the command-line option.\n\nControls whether or not hyperlinks are used in the terminal.\n\nControl whether output can be rendered using non-ASCII unicode characters.\n\nControls whether or not progress bar is shown in the terminal. Possible values:"
    }
]