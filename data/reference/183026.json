[
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/index.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nAlso known as The Swing Tutorial\n\nThis trail tells you how to create graphical user interfaces (GUIs) for applications and applets, using the Swing components. If you would like to incorporate JavaFX into your Swing application, please see Integrating JavaFX into Swing Applications.\n\nGetting Started with Swing is a quick start lesson. First it gives you a bit of background about Swing. Then it tells you how to compile and run programs that use Swing components.\n\nLearning Swing with the NetBeans IDE is the fastest and easiest way to begin working with Swing. This lesson explores the NetBeans IDE's GUI builder, a powerful feature that lets you visually construct your Graphical User Interfaces.\n\nUsing Swing Components tells you how to use each of the Swing components  buttons, tables, text components, and all the rest. It also tells you how to use borders and icons.\n\nConcurrency in Swing discusses concurrency as it applies to Swing programming. Information on the event dispatch thread and the SwingWorker class are included.\n\nUsing Other Swing Features tells you how to use actions, timers, and the system tray; how to integrate with the desktop class, how to support assistive technologies, how to print tables and text, how to create a splash screen, and how to use modality in dialogs.\n\nLaying Out Components Within a Container tells you how to choose a layout manager, how to use each of the layout manager classes the Java platform provides, how to use absolute positioning instead of a layout manager, and how to create your own layout manager.\n\nModifying the Look and Feel tells you how to specify the look and feel of Swing components.\n\nDrag and Drop and Data Transfer tells you what you need to know to implement data transfer in your application.\n\nWriting Event Listeners tells you how to handle events in your programs.\n\nPerforming Custom Painting gives you information on painting your own Swing components. It discusses painting issues specific to Swing components, provides an overview of painting concepts, and has examples of custom components that paint themselves.\n\nAlthough this is the main trail for learning about GUIs, it isn't the only trail with UI-related information.\n• 2D Graphics, which describes the 2D graphics features available in the JDK.\n• Sound, which discusses the sound capabilities available in the JDK.\n• Java Applets, which describes API available only to applets.\n• Essential Java Classes, which covers many topics, including properties and the standard I/O streams.\n• The JavaFX Documentation, which describes how to build UIs with JavaFX.\n• The Bonus trail contains Full-Screen Exclusive Mode API, a lesson that describes how to use API introduced in v1.4 to render graphics directly to the screen."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html",
        "document": "Trail: Creating a GUI With Swing \n\nLesson: Laying Out Components Within a Container\n\nThe Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nSeveral AWT and Swing classes provide layout managers for general use:\n\nThis section shows example GUIs that use these layout managers, and tells you where to find the how-to page for each layout manager. You can find links for running the examples in the how-to pages and in the example index.\n\nNote: This lesson covers writing layout code by hand, which can be challenging. If you are not interested in learning all the details of layout management, you might prefer to use the layout manager combined with a builder tool to lay out your GUI. One such builder tool is the , then is recommended as the next most flexible and powerful layout manager. This lesson covers writing layout code by hand, which can be challenging. If you are not interested in learning all the details of layout management, you might prefer to use thelayout manager combined with a builder tool to lay out your GUI. One such builder tool is the NetBeans IDE . Otherwise, if you want to code by hand and do not want to use, thenis recommended as the next most flexible and powerful layout manager.\n\nIf you are interested in using JavaFX to create your GUI, see Working With Layouts in JavaFX.\n\nEvery content pane is initialized to use a . (As Using Top-Level Containers explains, the content pane is the main container in all frames, applets, and dialogs.) A places components in up to five areas: top, bottom, left, right, and center. All extra space is placed in the center area. Tool bars that are created using JToolBar must be created within a container, if you want to be able to drag and drop the bars away from their starting positions. For further details, see How to Use BorderLayout.\n\nThe class puts components in a single row or column. It respects the components' requested maximum sizes and also lets you align components. For further details, see How to Use BoxLayout.\n\nThe class lets you implement an area that contains different components at different times. A is often controlled by a combo box, with the state of the combo box determining which panel (group of components) the displays. An alternative to using is using a tabbed pane, which provides similar functionality but with a pre-defined GUI. For further details, see How to Use CardLayout.\n\nis the default layout manager for every . It simply lays out components in a single row, starting a new row if its container is not sufficiently wide. Both panels in CardLayoutDemo, shown previously, use . For further details, see How to Use FlowLayout.\n\nis a sophisticated, flexible layout manager. It aligns components by placing them within a grid of cells, allowing components to span more than one cell. The rows in the grid can have different heights, and grid columns can have different widths. For further details, see How to Use GridBagLayout.\n\nsimply makes a bunch of components equal in size and displays them in the requested number of rows and columns. For further details, see How to Use GridLayout.\n\nis a layout manager that was developed for use by GUI builder tools, but it can also be used manually. works with the horizontal and vertical layouts separately. The layout is defined for each dimension independently. Consequently, however, each component needs to be defined twice in the layout. The Find window shown above is an example of a . For further details, see How to Use GroupLayout.\n\nis a flexible layout manager designed for use by GUI builders. It lets you specify precise relationships between the edges of components under its control. For example, you might define that the left edge of one component is a certain distance (which can be dynamically calculated) from the right edge of a second component. lays out the children of its associated container according to a set of constraints, as shall be seen in How to Use SpringLayout."
    },
    {
        "link": "https://geeksforgeeks.org/introduction-to-java-swing",
        "document": "Swing is a Java Foundation Classes [JFC] library and an extension of the Abstract Window Toolkit [AWT]. Java Swing offers much-improved functionality over AWT, new components, expanded components features, and excellent event handling with drag-and-drop support.\n\nSwing has about four times the number of User Interface [UI] components as AWT and is part of the standard Java distribution. By today’s application GUI requirements, AWT is a limited implementation, not quite capable of providing the components required for developing complex GUIs required in modern commercial applications. The AWT component set has quite a few bugs and does take up a lot of system resources when compared to equivalent Swing resources. Netscape introduced its Internet Foundation Classes [IFC] library for use with Java. Its Classes became very popular with programmers creating GUI’s for commercial applications.\n• None Swing is a Set of API (API- Set of Classes and Interfaces)\n• None Swing is an Extension library to the AWT (Abstract Window Toolkit)\n• None Includes New and improved Components that have been enhancing the looks and Functionality of GUIs’\n• None Swing can be used to build (Develop) The Standalone swing GUI Apps as Servlets and Applets\n• None Swing is more portable and more flexible than AWT, the Swing is built on top of the AWT.\n• None Swing is Entirely written in Java.\n• None Java Swing Components are Platform-independent, and The Swing Components are lightweight.\n• None Swing Supports a Pluggable look and feel and Swing provides more powerful components.\n• None such as tables, lists, Scrollpanes, Colourchooser, tabbed pane, etc.\n\nThere are certain points from which Java Swing is different than Java AWT as mentioned below:\n\nTo know more about the topic, refer to Java Swing vs Java AWT.\n\nJFC stands for Java Foundation Classes. JFC is the set of GUI components that simplify desktop Applications. Many programmers think that JFC and Swing are one and the same thing, but that is not so. JFC contains Swing [A UI component package] and quite a number of other items:\n• None Accessibility features: Aimed at developing GUIs for users with disabilities.\n• None The Desktop Colors Features were first introduced in Java 1.1\n• None Java 2D: it has Improved colors, images, and text support.\n• None Advanced features such as JTable, JTabbedPane, JScollPane, etc.\n• None Java is a platform-independent language and runs on any client machine, the GUI look and feel, owned and delivered by a platform-specific O/S, simply does not affect an application’s GUI constructed using Swing components.\n• Lightweight Components: Starting with the JDK 1.1, its AWT-supported lightweight component development. For a component to qualify as lightweight, it must not depend on any non-Java [O/s based) system classes. Swing components have their own view supported by Java’s look and feel classes.\n• Pluggable Look and Feel: This feature enable the user to switch the look and feel of Swing components without restarting an application. The Swing library supports components’ look and feels that remain the same across all platforms wherever the program runs. The Swing library provides an API that gives real flexibility in determining the look and feel of the GUI of an application\n• Highly customizable – Swing controls can be customized in a very easy way as visual appearance is independent of internal representation.\n• Rich controls – Swing provides a rich set of advanced controls like Tree TabbedPane, slider, colorpicker, and table controls.\n• None In general, a visual component is a composite of three distinct aspects:\n• None The way that the component looks when rendered on the screen.\n• None The way such that the component reacts to the user.\n• None The state information associated with the component.\n• None Over the years, one component architecture has proven itself to be exceptionally effective: – Model-View-Controller MVC\n• model corresponds to the state information associated with the Component.\n• view determines how the component is displayed on the screen, including any aspects of the view that are affected by the current state of the model.\n• controller determines how the component reacts to the user.\n\nThe simplest Swing components have capabilities far beyond AWT components as follows:\n• None Swing buttons and labels can be displaying images instead of or in addition to text.\n• None The borders around most Swing components can be changed easily. For example, it is easy to put a 1-pixel border around the outside of a Swing label.\n• None Swing components do not have to be rectangular. Buttons, for example, can be round.\n• None Now The Latest Assertive technologies such as screen readers can easily get information from Swing components. Example: A screen reader tool can easily capture the text that is displayed on a Swing button or label.\n\nExample 1: Develop a program using label (swing) to display the message “GFG WEB Site Click”:\n\nExample 2: Write a program to create three buttons with caption OK, SUBMIT, CANCEL.\n\nExample 3: Program to Add Checkbox in the Frame\n\nA Component is the Abstract base class for about the non-menu user-interface controls of Java SWING. Components are representing an object with a graphical representation. A Container is a component that can container Java SWING Components A JComponent is a base class for all swing UI Components In order to use a swing component that inherits from JComponent, the component must be in a containment hierarchy whose root is a top-level Java Swing container. A JLabel is an object component for placing text in a container. A JColorChooser provides a pane of controls designed to allow the user to manipulate and select a color. A JCheckBox is a graphical (GUI) component that can be in either an on-(true) or off-(false) state. The JRadioButton class is a graphical (GUI) component that can be in either an on-(true) or off-(false) state. in the group A JList component represents the user with the scrolling list of text items. A JComboBox component is Presents the User with a show up Menu of choices. A JTextField object is a text component that will allow for the editing of a single line of text. A JPasswordField object it is a text component specialized for password entry. A JTextArea object is a text component that allows for the editing of multiple lines of text. A ImageIcon control is an implementation of the Icon interface that paints Icons from Images A JScrollbar control represents a scroll bar component in order to enable users to Select from range values. JOptionPane provides set of standard dialog boxes that prompt users for a value or Something. A JFileChooser it Controls represents a dialog window from which the user can select a file. As the task progresses towards completion, the progress bar displays the tasks percentage on its completion. A JSlider this class is letting the user graphically (GUI) select by using a value by sliding a knob within a bounded interval. A JSpinner this class is a single line input where the field that lets the user select by using a number or an object value from an ordered sequence."
    },
    {
        "link": "https://4056987.fs1.hubspotusercontent-na1.net/hubfs/4056987/Instructor%20Resources/Ezell/Ezell%20CC1.pdf",
        "document": ""
    },
    {
        "link": "https://geeksprogramming.com/java-swing-tutorial-for-beginners",
        "document": "In the realm of Java programming, creating graphical user interfaces (GUIs) stands as a pivotal skill. Picture this: you’re crafting an application, and its success hinges not just on functionality but also on user experience. Enter Swing, the powerhouse framework for GUI development in Java. But what exactly is Swing? In plain terms, Swing is a Java toolkit that empowers developers to build sleek, interactive GUIs with ease. Its roots trace back to the late 1990s, evolving alongside Java itself. Now, it stands as the go-to choice for crafting dynamic interfaces in Java applications. So, why opt for Swing over its predecessor, AWT (Abstract Window Toolkit)? Well, let’s delve into its advantages. Firstly, Swing offers a rich set of components, from buttons to scroll panes, enabling developers to design visually appealing interfaces effortlessly. Secondly, Swing provides greater flexibility and customization options, allowing for intricate designs tailored to specific project needs. And finally, Swing boasts platform independence, ensuring that your GUIs look and behave consistently across different operating systems. However, mastering Swing isn’t without its challenges. From understanding the nuances of layout managers to ensuring responsiveness and performance, there’s much to learn. But fear not! With the right guidance, you’ll soon find yourself crafting attractive Java GUIs like a pro. In this tutorial, we’ll embark on a journey through Swing, unraveling its mysteries and equipping you with the skills needed to build captivating GUIs. So, grab your Java IDE and let’s dive in!\n\nGetting started with Swing marks the first step towards unleashing the potential of Java GUI development. Before diving into crafting captivating interfaces, it’s essential to set up your development environment. Fortunately, this process is straightforward and requires minimal effort. Begin by ensuring you have the latest version of the Java Development Kit (JDK) installed on your system. You can download it from the official Oracle website or use a package manager if you’re on a Unix-based system like Linux. Once the JDK is installed, you’re ready to embark on your Swing journey. Next, fire up your favorite Integrated Development Environment (IDE). Whether it’s IntelliJ IDEA, Eclipse, or NetBeans, the choice is yours. Create a new Java project and give it a meaningful name that reflects its purpose. For example, if you’re building a simple calculator application, you might name your project “CalculatorApp.” With your project set up, it’s time to create your first Swing application. In Swing, everything revolves around the concept of components. These components, such as buttons, text fields, and panels, form the building blocks of your GUI. Let’s start with a basic example: creating a window with a button. In your IDE, create a new Java class named “MainWindow” or something similar. In this class, extend the JFrame class, which represents a window in Swing.\n\nCustomizing the appearance of buttons allows you to enhance the visual appeal of your GUI. Swing provides various methods to customize button appearance, including setting text, icons, colors, fonts, and borders. Handling button events is crucial for capturing user interactions. Swing employs event listeners to detect and respond to button clicks. You can register ActionListener interfaces to buttons and define actionPerformed() methods to specify the actions to be performed when the button is clicked."
    },
    {
        "link": "https://geeksforgeeks.org/java-awt-tutorial",
        "document": "Java AWT or Abstract Window Toolkit is an API used for developing GUI(Graphic User Interfaces) or Window-Based Applications in Java. Java AWT is part of the Java Foundation Classes (JFC) that provides a way to build platform-independent graphical applications.\n\nIn this AWT tutorial, you will learn the basics of the AWT, including how to create windows, buttons, labels, and text fields. We will also learn how to add event listeners to components so that they can respond to user input.\n\nBy the end of this tutorial, you will have a good understanding of the AWT and be able to create simple GUIs in Java.\n\nJava AWT (Abstract Window Toolkit) is an API used to create Graphical User Interface (GUI) or Windows-based Java programs and Java AWT components are platform-dependent, which means they are shown in accordance with the operating system’s view. AWT is heavyweight, which means that its components consume resources from the underlying operating system (OS). The java.awt package contains AWT API classes such as TextField, Label, TextArea, RadioButton, CheckBox, Choice, List, and so on.\n\nThe Java AWT utilizes the native platform subroutine to create API components such as TextField, CheckBox, and buttons. This results in a different visual format for these components on different platforms such as Windows, MAC OS, and Unix. The reason for this is that each platform has a distinct view of its native components. AWT directly calls this native subroutine to create the components, resulting in an AWT application resembling a Windows application on Windows OS, and a Mac application on the MAC OS. In simpler terms, the AWT application’s appearance adapts to the platform it is running on.\n\nUnderstanding how to use is vital for optimizing your application’s performance. To delve deeper into Java programming, the Java Backend course offers a comprehensive look at various Java concepts and their applications.\n\nAWT is platform independent even after the AWT components are platform dependent because of the points mentioned below:\n\nAWT provides an abstract layer for GUI. Java applications interact with AWT through Abstract API which are platform independent. Abstract API allows Java to isolate platform-specific details, making code portable across different systems.\n\nThe Libraries of AWT are written in Java which they are totally platform-independent. Because of this, it ensures that AWT functionality remains consistent across different environments.\n• Components: AWT provides various components such as buttons, labels, text fields, checkboxes, etc used for creating GUI elements for Java Applications.\n• Containers: AWT provides containers like panels, frames, and dialogues to organize and group components in the Application.\n• Layout Managers: Layout Managers are responsible for arranging data in the containers some of the layout managers are BorderLayout, FlowLayout, etc.\n• Event Handling: AWT allows the user to handle the events like mouse clicks, key presses, etc. using event listeners and adapters.\n• Graphics and Drawing: It is the feature of AWT that helps to draw shapes, insert images and write text in the components of a Java Application.\n\nThere are four types of containers in Java AWT:\n• Window: Window is a top-level container that represents a graphical window or dialog box. The Window class extends the Container class, which means it can contain other components, such as buttons, labels, and text fields.\n• Panel: Panel is a container class in Java. It is a lightweight container that can be used for grouping other components together within a window or a frame.\n• Frame : The Frame is the container that contains the title bar and border and can have menu bars.\n• Dialog: A dialog box is a temporary window an application creates to retrieve user input.\n\nLearn the basics of the Abstract Window Toolkit (AWT) in Java, for both beginners and experienced developers.\n\nThere are three types of Java AWT Label Class\n\nAWT Button is a control component with a label that generates an event when clicked on. Button Class is used for creating a labeled button that is platform-independent.\n\nThere are two types of Button class constructors as mentioned below:\n\nThere are TextField class constructors are mentioned below:\n\nThere are certain constructors in the AWT Checkbox class as mentioned below:\n\nCheckboxGroup Class is used to group together a set of Checkbox.\n\nThe object of the Choice class is used to show a popup menu of choices.\n\nThe object of the AWT List class represents a list of text items.\n\nThe List of class constructors is defined below:\n\nThere are three constructor classes in Java mentioned below:\n\nMenuItem class adds a simple labeled menu item on the menu. The MenuItem class allows you to create individual items that can be added to menus. And Menu is a component used to create a dropdown menu that can contain a list of MenuItem components.\n\nJava AWT PopupMenu is a component that is used for dynamically popping up a menu that appears when the user right-clicks or performs any other action on a component.\n\nJava AWT Panel is a container class used to hold and organize graphical components in a Java Application.\n\nJava AWT Toolkit class provides us with a platform-independent way to access various system resources and functionalities. Subclasses of Toolkit are used to bind various components.\n\nHere are some of the event handling components in Java:\n\nJava ActionListner is a interface which responds to the actions performed by the components like buttons, menu items ,etc.\n\nThere is only methods associated with ActionListner class that is actionPerformed().\n\nJava MouseListner is a interface that responds to the actions performed by mouse events generated by the user. Example: mouse clicks , mouse movements, etc.\n\nThere are 5 Methods associated with MouseListner:\n\nJava MouseMotionListner is a interface which is notified when mouse is moved or dragged.\n\nIt contains two Methods mentioned below:\n\nJava ItemListner is an interface which handles events related to item selection and deselection those that occur with checkboxes, radio buttons, etc. There is only one Method associated with ItemListner that is itemStateChanged(). This method provides information about the event, i.e. source of the event and the changed state.\n\nJava KeyListner is an interface in Java notified whenever you change the state of key or can be said for key related events.\n\nThere are three methods associated with KeyListner as mentioned below:\n\nJava WindowListener is a interface used for handling events related to window actions. Events like opening , closing, minimizing, etc are handled using WindowListener.\n\nThere are seven methods associated with WindowListener as mentioned below:\n\nAt the end we will need to Close AWT Window, So to perform this task we will use dispose() method. This method releases the resources associated with the window and also removes it from the screen.\n\nHere are some Java AWT examples:\n\nHello, World is was the first step in learning Java. So, let us program our first Program in Java AWT as Hello World using Labels and Frames.\n\nBelow is the implementation of the above method:\n\nBelow is the implementation of the Java AWT Program to create a Button:\n\n1. What is AWT in Java?\n\n2. What are the advantages of AWT?\n\n3. What are the types of containers in AWT?\n\n4. How to create and use components in AWT?"
    },
    {
        "link": "https://docs.oracle.com/javase/10/docs/api/java/awt/package-summary.html",
        "document": ""
    },
    {
        "link": "https://www3.ntu.edu.sg/home/ehchua/programming/java/J4a_GUI.html",
        "document": "So far, we have covered the basic programming constructs (such as variables, data types, decision, loop, array and method) and introduced the important concept of Object-Oriented Programming (OOP). As discussed, OOP permits higher level of abstraction than traditional Procedural-Oriented Languages (such as C). You can create high-level abstract data types called classes to mimic real-life things. These classes are self-contained and are reusable.\n\nIn this article, I shall show you how you can reuse the graphics classes provided in JDK for constructing your own Graphical User Interface (GUI) applications. Writing your own graphics classes (and re-inventing the wheels) is mission impossible! These graphics classes, developed by expert programmers, are highly complex and involve many advanced design patterns. However, re-using them are not so difficult, if you follow the API documentation, samples and templates provided.\n\nI shall assume that you have a good grasp of OOP, including composition, inheritance, polymorphism, abstract class and interface; otherwise, read the earlier articles. I will describe another important OO concept called nested class (or inner class) in this article.\n\nThere are current three sets of Java APIs for graphics programming: AWT (Abstract Windowing Toolkit), Swing and JavaFX.\n• AWT API was introduced in JDK 1.0. Most of the AWT UI components have become obsolete and should be replaced by newer Swing UI components.\n• Swing API, a much more comprehensive set of graphics libraries that enhances the AWT, was introduced as part of Java Foundation Classes (JFC) after the release of JDK 1.1. JFC consists of Swing, Java2D, Accessibility, Internationalization, and Pluggable Look-and-Feel Support APIs. JFC has been integrated into core Java since JDK 1.2.\n• The latest JavaFX, which was integrated into JDK 8, was meant to replace Swing. JavaFX was moved out from the JDK in JDK 11, but still available as a separate module.\n\nOther than AWT/Swing/JavaFX graphics APIs provided in JDK, other organizations/vendors have also provided graphics APIs that work with Java, such as Eclipse's Standard Widget Toolkit (SWT) (used in Eclipse), Google Web Toolkit (GWT) (used in Android), 3D Graphics API such as Java bindings for OpenGL (JOGL), Java3D, and etc. Furthermore, developers have moved to use technologies such as HTML5 as the basis of webapps.\n\nYou need to refer to the \"JDK API documentation\" for the AWT/Swing APIs (under module ) while reading this chapter. The best online reference for Graphics programming is the \"Swing Tutorial\" @ http://docs.oracle.com/javase/tutorial/uiswing/. For advanced 2D graphics programming, read \"Java 2D Tutorial\" @ http://docs.oracle.com/javase/tutorial/2d/index.html. For 3D graphics, read my 3D articles.\n\nI shall start with the AWT before moving into Swing to give you a complete picture of Java Graphics.\n\nAWT is huge! It consists of 12 packages of 370 classes (Swing is even bigger, with 18 packages of 737 classes as of JDK 8). Fortunately, only 2 packages - and - are commonly-used.\n• The package contains the core AWT graphics classes:\n• GUI Component classes, such as , , and .\n• GUI Container classes, such as and .\n• Layout managers, such as , and .\n• Custom graphics classes, such as , and .\n• The package supports event handling:\n• Event classes, such as , , and ,\n• Event Listener Interfaces, such as , , , and ,\n• Event Listener Adapter classes, such as , , and .\n\nAWT provides a platform-independent and device-independent interface to develop graphic programs that runs on all platforms, including Windows, macOS, and Unixes.\n\nThere are two groups of GUI elements:\n• Component (Widget, Control): Components are elementary GUI entities, such as , , and . They are also called widgets, controls in other graphics systems.\n• Container: Containers, such as and , are used to hold components in a specific layout (such as or ). A container can also hold sub-containers.\n\nIn the above figure, there are three containers: a and two s. A is the top-level container of an AWT program. A has a title bar (containing an icon, a title, and the minimize/maximize/close buttons), an optional menu bar and the content display area. A is a rectangular area used to group related GUI components in a certain layout. In the above figure, the top-level contains two s. There are five components: a (providing description), a (for users to enter text), and three s (for user to trigger certain programmed actions).\n\nIn a GUI program, a component must be kept (or added) in a container. You need to identify a container to hold the components. Every container has a method called . A (say ) can invoke to add into itself. For example,\n\nGUI components are also called controls (e.g., Microsoft ActiveX Control), widgets (e.g., Eclipse's Standard Widget Toolkit, Google Web Toolkit), which allow users to interact with (or control) the application.\n\nEach GUI program has a top-level container. The commonly-used top-level containers in AWT are , and :\n• A provides the \"main window\" for your GUI application. It has a title bar (containing an icon, a title, the minimize, maximize/restore-down and close buttons), an optional menu bar, and the content display area. To write a GUI program, we typically start with a subclass extending from to inherit the main window as follows:\n• An AWT is a \"pop-up window\" used for interacting with the users. A has a title-bar (containing an icon, a title and a close button) and a content display area, as illustrated.\n• An AWT (in package ) is the top-level container for an applet, which is a Java program running inside a browser. Applet is no longer supported in most of the browsers.\n\nSecondary containers are placed inside a top-level container or another secondary container. AWT provides these secondary containers:\n• : a rectangular box used to layout a set of related GUI components in pattern such as grid or flow.\n\nThe hierarchy of the AWT classes is as follows:\n\nAs illustrated, a has a to layout the components in a certain pattern, e.g., flow, grid.\n\nAWT provides many ready-made and reusable GUI components in package . The frequently-used are: , , , , (radio buttons), , and , as illustrated below.\n\nA provides a descriptive text string. Take note that prints to the system console, NOT to the graphics screen. You could use a to label another component (such as text field) to provide a text description.\n\nThe class has three constructors:\n• The first constructor constructs a object with the given text string in the given alignment. Note that three constants , , and are defined in the class for you to specify the alignment (rather than asking you to memorize arbitrary integer values).\n• The second constructor constructs a object with the given text string in default of left-aligned.\n• The third constructor constructs a object with an initially empty string. You could set the label text via the method later.\n\nThese three constants are defined for specifying the alignment of the 's text, as used in the above constructor.\n\nThe and methods can be used to read and modify the 's text. Similarly, the and methods can be used to retrieve and modify the alignment of the text.\n\nConstructing a Component and Adding the Component into a Container\n\nThree steps are necessary to create and place a GUI component:\n• Declare the component with an identifier (name);\n• Construct the component by invoking an appropriate constructor via the operator;\n• Identify the container (such as or ) designed to hold this component. The container can then add this component onto itself via method. Every container has a method. Take note that it is the container that actively and explicitly adds a component onto itself, NOT the other way.\n\nYou can create a without specifying an identifier, called anonymous instance. In the case, the Java compiler will assign an anonymous identifier for the allocated object. You will not be able to reference an anonymous instance in your program after it is created. This is usually alright for a instance as there is often no need to reference a after it is constructed.\n\nA is a GUI component that triggers a certain programmed action upon clicking.\n\nThe class has two constructors. The first constructor creates a object with the given label painted over the button. The second constructor creates a object with no label.\n\nThe and methods can be used to read the current label and modify the label of a button, respectively.\n\nNote: The latest Swing's replaces with to be consistent with all the components. We will describe Swing later.\n\nClicking a button fires a so-called and triggers a certain programmed action. I will explain event-handling later.\n\nA is single-line text box for users to enter texts. (There is a multiple-line text box called .) Hitting the \"ENTER\" key on a object fires an .\n\nHitting the \"ENTER\" key on a fires a , and triggers a certain programmed action.\n\nTake note that operates on . You can convert a to a primitive, such as or via method or . To convert a primitive to a , simply concatenate the primitive with an empty .\n\nLet's assemble a few components together into a simple GUI counter program, as illustrated. It has a top-level container , which contains three components - a \"Counter\", a non-editable to display the current count, and a \"Count\" . The shall display count of initially.\n\nEach time you click the button, the counter's value increases by 1.\n\nTo exit this program, you have to close the CMD-shell (or press \"control-c\" on the CMD console); or push the \"red\" close button in Eclipse's Application Console. This is because we have yet to write the handler for the 's close button. We shall do that in the later example.\n• The statements (Lines 1-2) are needed, as AWT container and component classes, such as , , , and are kept in the package; while AWT events and event-listener interfaces, such as and are kept in the package.\n• A GUI program needs a top-level container, and is often written as a subclass of (Line 5). In other words, this class is a , and inherits all the attributes and behaviors of a , such as the title bar and content pane.\n• Lines 11 to 47 define a constructor, which is used to setup the GUI components and event handlers.\n• In Line 13, the (inherited from the superclass ) is used to set the layout of the container. is used which arranges the components in left-to-right and flows into next row in a top-to-bottom manner.\n• A , (non-editable), and are constructed. We invoke the method (inherited from the superclass ) to add these components into container .\n• In Line 36-37, we invoke the and the (inherited from the superclass ) to set the initial size and the title of the . The method (Line 42) is then invoked to show the display.\n• Line 27 (or Line 29-30) is used to setup the callback event-handler, which will be discussed in length later. In brief, whenever the button is clicked, the will be called. In the (Lines 61-66), the counter value increases by 1 and displayed on the .\n• In the entry method (Lines 52-56), an instance of is constructed. The constructor is executed to initialize the GUI components and setup the event-handlers. The GUI program then waits for the user action.\n\nIt is interesting to inspect the GUI objects via the , to gain an insight to these classes. (Alternatively, use a graphic debugger in Eclipse/NetBeans or study the JDK source code.) For example, if we insert the following code before and after the :\n\nIn this example, the top-level container is again the typical . It contains 4 components: a \"Enter an Integer\", a for accepting user input, another \"The Accumulated Sum is\", and another non-editable for displaying the sum. The components are arranged in of 2 rows 2 columns.\n\nThe program shall accumulate the number entered into the input and display the sum in the output .\n• An AWT GUI program extends from (Line 6) - the top-level window container.\n• In the constructor (Line 14), we constructs 4 components - 2 anonymous s and 2 s. The adds the components, in .\n• ( ) is the source object, which fires an upon hitting the Enter key. adds an anonymous instance of as an handler (Line 23). The listener class needs to implement interface and provides implementation to method . Whenever an user hits Enter on the ( ), the will be called back.\n\nJava adopts the so-called \"Event-Driven\" (or \"Event-Delegation\") programming model for event-handling, similar to most of the visual programming languages like Visual Basic.\n\nIn event-driven programming, a piece of event-handling codes is executed (or called back by the graphics subsystem) when an event was fired in response to an user input (such as clicking a mouse button or hitting the ENTER key in a text field).\n\nIn the above examples, the method is known as a callback method. In other words, you never invoke in your codes explicitly. The is called back by the graphics subsystem under certain circumstances in response to certain user actions.\n\nJavaScript can attach a Callback method to an Event Directly\n\nIn some languages, you can directly attach a method (or function) to an event (such as mouse-click). For example, the following JavaScript code (called ) implement a counter similar to the , with a text label, text field and button:\n\nIn Java, we CANNOT attach a method to a source object directly, as method is not a first-class object in Java. For example, a Java method cannot accept methods as its arguments and it cannot return a method; you cannot assign a method to a variable, etc. (JavaScript and C language CAN!).\n\nThe AWT's event-handling classes are kept in package .\n\nThree kinds of objects are involved in the event-handling: a source, listener(s) and an event object.\n\nThe source object (such as and ) interacts with the user. Upon triggered, the source object creates an event object to capture the action (e.g., mouse-click x and y, texts entered, etc). This event object will be messaged to all the registered listener object(s), and an appropriate event-handler method of the listener(s) is called-back to provide the response. In other words, triggering a source fires an event to all its listener(s), and invoke an appropriate event handler of the listener(s).\n\nTo express interest for a certain source's event, the listener(s) must be registered with the source. In other words, the listener(s) \"subscribes\" to a source's event, and the source \"publishes\" the event to all its subscribers upon activation. This is known as subscribe-publish or observable-observer design pattern.\n\nThe sequence of steps is illustrated above:\n• The source object registers its listener(s) for a certain type of event. A source fires an event when triggered. For example, clicking a fires an , clicking a mouse button fires , typing a key fires , and etc. How the source and listener understand each other? The answer is via an agreed-upon interface. For example, if a source is capable of firing an event called (e.g., ). Firstly, we need to declare an interface called (e.g., ) containing the names of the handler methods (recall that an contains only methods without implementation). For example, the interface is declared as follows: Secondly, all listeners must implement the interface. That is, the listeners must provide their own implementations (i.e., programmed responses) to all the methods declared in the interface. In this way, the listener(s) can response to these events appropriately. For example, Thirdly, in the source, we need to maintain a list of listener object(s), and define two methods: and to add and remove a listener from this list. For the , the signature of the methods are: Take note that the takes a object as its sole parameter. In other words, it can only add objects of the type , and its sub-type. Since is an , you cannot create instance of , but need to create instance of a subclass implementing the . In summary, we identify the source, the event-listener interface, and the listener object. The listener must implement the event-listener interface. The source object then registers listener object via the method.\n• The source is triggered by a user.\n• The source create a object, which encapsulates the necessary information about the activation. For example, the position of the mouse pointer, the text entered, etc.\n• Finally, for each of the listeners in the listener list, the source invokes the appropriate handler on the listener(s), which provides the programmed response.\n\nIn summary, triggering a source fires an event to all its registered listeners, and invoke an appropriate handler of the listener.\n\nClicking a (or hitting the \"Enter\" key on a ) fires an to all its listener(s). An listener must implement the interface, which declares one method called as follow:\n\nHere are the event-handling steps:\n• We identify (of ) as the source object.\n• Clicking fires an to all its listener(s).\n• The listener(s) is required to implement interface, and override the method to provide the response. In Line 56-65, we write an inner class called , which override the to increment and display the count. An inner class is a class defined inside an outer class, and it can access the private entities of the outer class. We will elaborate on the inner class in the next section.\n• The source object registers listener via the . In this example, the source ( ) adds an instance of as a listener via: Note that takes an argument of the type . , which implements interface (i.e., a subclass of ), is upcasted and passed to the method.\n• Upon button-click, the creates an object, and calls back the method of all its registered listener(s) with the object created:\n\nThe sequence diagram is as follows:\n\nIn this example,\n• We identify the (of ) as the source object.\n• Hitting the \"Enter\" key on a fires an to all its listener(s).\n• In Line 46-59, we define an inner class called as the listener.The listener is required to implement the interface, and override the method to provide the programmed response upon activation.\n• The source object (of ) registers an anonymous instance of as its listener via the (Line 23).\n\nA is fired (to all its listeners) when a window (e.g., ) has been opened/closed, activated/deactivated, iconified/deiconified via the 3 buttons at the top-right corner or other means. The source of shall be a top-level window-container such as .\n\nA listener must implement interface, which declares 7 event-handling methods, as follows. Among them, the , which is called back upon clicking the window-close button, is the most commonly-used.\n\nThe following program added support for \"close-window button\" to \"Example 1: AWTCounter\".\n\nIn this example, we shall modify the earlier example to handle the . Recall that pushing the \"close-window\" button on the has no effect, as it did not handle the of . We included the handling codes in this example.\n• We identify the as the source object.\n• The fires the to all its registered listener(s).\n• In Line 53-69, we define an inner class called as the listener. It is required to implement the interface, which declares 7 abstract methods: , , , , , and .\n• We register an anonymous instance of as the listener to the source via method .\n• We override the handler to terminate the program using . We ignore the other 6 handlers, but required to provide an empty body for compilation.\n\nThe sequence diagram is as follow:\n\nA is fired when you press, release, or click (press followed by release) a mouse-button (left or right button) at the source object; or position the mouse-pointer at (enter) and away (exit) from the source object.\n\nA listener must implement the interface, which declares the following five methods:\n\nIn this example, we setup a GUI with 4 components (two anonymous s and two non-editable s) inside a top-level container , arranged in .\n• We identity as the source object.\n• The fires a to all its listener(s) when you click/press/release a mouse-button or enter/exit with the mouse-pointer.\n• In Line 42-56, we define an inner class called as the listener. It is required to implement the interface, which declares 5 abstract methods: , , , , and . We override the to display the (x, y) coordinates of the mouse click on the two displayed s. We ignore all the other handlers (for simplicity - but you need to provide an empty body for compilation).\n• We register an anonymous instance of as the listener to (source) via the method .\n\nTry: Include a to handle the close-window button.\n\nA is also fired when you move and drag the mouse pointer at the source object. But you need to use to handle the mouse-move and mouse-drag. The interface declares the following two abstract methods:\n\nIn this example, we shall illustrate both the and .\n• We identify the as the source, which fires the to its registered and .\n• In Line 53-80, we define an inner class called as both the and .\n• We register an instance of as the listener to via method and .\n• The needs to implement 2 abstract methods: and declared in the interface.\n• We override the to display the (x, y) position of the mouse pointer. We ignore the handler by providing an empty body for compilation.\n\nTry: Include a to handle the close-window button.\n\nA is fired when you pressed, released, and typed (pressed followed by released) a key on the source object. A listener must implement interface, which declares three abstract methods:\n\nIn this example:\n• We identify the (of ) as the source object.\n• The source fires a when you press/release/type a key to all its listener(s).\n• In Line 35-46, we define an inner class called as the listener.\n• We register an anonymous instance of as the listener to the source via method .\n• The listener needs to implement the interface, which declares 3 abstract methods: , , .\n• We override the to display key typed on the display . We ignore the and .\n\nIn our example, suppose we would like to write an external ordinary class (say ) as our listener. This class shall implement interface and override the method. An example is as follows:\n\nCan you see the problem? This external class cannot access the variables such as and in the class. We can fix this problem, but the solution is messy. An easy solution is to use an inner class instead of an ordinary external class (to be explained in the following sections).\n\nWhat are Inner classes?\n\nA nested class (or commonly called inner class) is a class defined inside another class - introduced in JDK 1.1. As an illustration, two nested classes and are defined inside the definition of an outer class called .\n• A nested class is a proper class. That is, it could contain constructors, member variables and member methods. You can create an instance of a nested class via the operator and constructor.\n• A nested class is a member of the outer class, just like any member variables and methods defined inside a class.\n• Most importantly, a nested class can access the members (variables/methods) of the enclosing outer class, as it is at the same level as these members. This is the property that makes inner class useful.\n• A nested class can have , , , or the default access, just like any member variables and methods defined inside a class. A inner class is only accessible by the enclosing outer class, and is not accessible by any other classes. [An top-level outer class cannot be declared , as no one can use a outer class.]\n• A nested class can also be declared , or , just like any ordinary class.\n• A nested class is NOT a subclass of the outer class. That is, the nested class does not inherit the variables and methods of the outer class. It is an ordinary self-contained class. [Nonetheless, you could declare it as a subclass of the outer class, via keyword \" \", in the nested class's definition.]\n\nThe usages of nested class are:\n• To control visibilities (of the member variables and methods) between inner/outer class. The nested class, being defined inside an outer class, can access members of the outer class.\n• To place a piece of class definition codes closer to where it is going to be used, to make the program clearer and easier to understand.\n\nExample 7: A Named Inner Class as Event Listener (Revisit Example 1 )\n\nA nested class is useful if you need a small class which relies on the enclosing outer class for its private variables and methods. It is ideal in an event-driven environment for implementing event handlers. This is because the event handling methods (in a listener) often require access to the private variables (e.g., a private ) of the outer class.\n\nIn this example (revisit Example 1 ), we define an inner class called , and create an instance of as the listener for the . The needs to implement the interface, and override the handler. needs to be defined as an inner class, as it needs to access private variables ( and ) of the outer class.\n• An inner class named is used as the .\n• An anonymous instance of the inner class is constructed. The source object adds this instance as a listener, as follows:\n• The inner class can access the variable and of the outer class.\n• The inner class is compiled into , in the format of .\n\n(Advanced) Using an Ordinary (Outer) Class as Listener\n\nTry moving the class outside, and define it as an ordinary class. You would need to pass a reference of the into the constructor of , and use this reference to access variables and , through getters or granting them to access.\n\nThis code is messy! Inner class provides a much cleaner solution!\n\nExample 8: An Anonymous Inner Class as Event Listener\n\nInstead of using a named inner class (called in the previous example), we shall use an inner class without a name, known as anonymous inner class as the in this example.\n• The anonymous inner class is given a name generated by the compiler, and compiled into , where is a running number of the inner classes of this outer class.\n• An anonymous instance of an anonymous inner class is constructed, and passed as the argument of the method as follows: The above codes is equivalent to and compiled as:\n• From JDK 8, you can write the event handler using \"Lambda Expression\" in a one-liner as follows:\n• The anonymous inner class is define inside a method, instead of a member of the outer class (class member). It is local to the method and cannot be marked with access modifier (such as , ) or , just like any local variable of a method.\n• An anonymous inner class must always extend a superclass or implement an interface. The keyword \" \" or \" \" is NOT required in its declaration. An anonymous inner class must implement all the abstract methods in the superclass or in the interface.\n• An anonymous inner class always uses the default (no-arg) constructor from its superclass to create an instance. If an anonymous inner class implements an interface, it uses the .\n• An anonymous inner class is compiled into a class named , where is a running number of inner classes within the outer class.\n• An instance of an anonymous inner class is constructed via this syntax: The created instance can be assigned to a variable or used as an argument of a method.\n\nExample 9: An Anonymous Inner Class for Each Source\n\nLet's modify our example to include 3 buttons for counting up, counting down, and reset the count, respectively. We shall attach an anonymous inner class as the listener to each of buttons.\n• Each of the s uses one anonymous instance of an anonymous inner class as its listener.\n\nExample 10: Using the Same Listener Instance for All the Buttons\n\nIf you use the same instance as the listener for all the 3 buttons, you need to determine which button has fired the event. It is because all the 3 buttons trigger the same event-handler method.\n\nIn the following example, we use the same instance of a \"named\" inner class as the listener for all the 3 buttons. The listener needs to determine which button has fired the event. This can be accomplished via the 's method, which returns the button's label.\n\nBesides the , which is only available for , you can use the method, which is available to all event objects, to retrieve a reference to the source object that has fired the event. returns a . You may need to downcast it to the proper type of the source object. For example,\n\nRefer to the , a listener is required to implement the interface, which declares 7 methods. Although we are only interested in , we need to provide an empty body to the other 6 methods in order to compile the program. This is tedious, e.g., we can rewrite the using an inner class implementing as follows:\n\nAn adapter class called is therefore provided, which implements the interface and provides default implementations to all the 7 methods. You can then derive a subclass from and override only methods of interest and leave the rest to their default implementation. For example,\n\nClearly, the adapter greatly simplifies the codes.\n\nSimilarly, adapter classes such as , , , are available for , , , and , respectively.\n\nThere is no for , because there is only one method (i.e. ) declared in the interface. This method has to be overridden and there is no need for an adapter.\n\nIf you read some old books, you may find many examples that use \" \" object as the event listener.\n\nThere is only ONE class in this code. But this code is much harder to understand and seldom used nowadays. Using inner class is a better solution.\n\nA container has a so-called layout manager to arrange its components. The layout managers provide a level of abstraction to map your user interface on all windowing systems, so that the layout can be platform-independent.\n\nAWT provides the following layout managers (in package ): , , , , , , and others. Swing added more layout manager in package , to be described later.\n\nA container has a method to set its layout manager:\n\nTo set up the layout of a (such as , , , or ), you have to:\n• Construct an instance of the chosen layout object, via and constructor, e.g., )\n• Invoke the method of the , with the layout object created as the argument;\n• Place the GUI components into the using the method in the correct order; or into the correct zones.\n\nYou can get the current layout via 's method.\n\n(and Swing's ) provides a constructor to set its initial layout manager. It is because a primary function of is to layout a group of component in a particular layout.\n\nIn the , components are arranged from left-to-right inside the container in the order that they are added (via method ). When one row is filled, a new row will be started. The actual appearance depends on the width of the display window.\n\nIn , components are arranged in a grid (matrix) of rows and columns inside the . Components are added in a left-to-right, top-to-bottom manner in the order they are added (via method ).\n\nIn , the container is divided into 5 zones: , , , , and . Components are added using method , where is either (or ), (or ), (or ), (or ), or .\n\nYou need not place components to all the 5 zones. The and components may be stretched horizontally; the and components may be stretched vertically; the component may stretch both horizontally and vertically to fill any space left over.\n\nUsing s as Sub-Container to Organize Components\n\nAn AWT is a rectangular pane, which can be used as sub-container to organized a group of related components in a specific layout (e.g., , ). s are secondary containers, which shall be added into a top-level container (such as ), or another .\n\nFor example, the following figure shows a in containing two - in and in . is added to the , and is added to the .\n\nReference: Read \"How to Use GridBagLayout\" @ https://docs.oracle.com/javase/tutorial/uiswing/layout/gridbag.html.\n\nRun the program, the output is in (a), where all components have their natural width and height, placed in center ( ) with extra x and y spaces at the 4 margins. The increases the internal y-padding for button-4 (spans 3 columns). Button 5 (spans second and third columns) has top margin specified by , and anchor at the bottom-right corner ( ).\n\nUncomment the (line 14). The output is in (b), where ALL components fill horizontally with equal column width.\n\nUncomment all (lines 20, 26, 32). The output is in (c). The extra x spaces are distributed according to the of (0.5, 1.0, 0.5).\n\nUncomment the (line 49). The output is in (d). The extra y spaces are given to row 3, as row 1 and 2 have of 0 and non-participating in the distribution of extra y-spaces.\n\nBoxLayout arrange components in a single row or column. It respects components' requests on the minimum sizes.\n\nSwing is part of the so-called \"Java Foundation Classes (JFC)\" (have you heard of MFC?), which was introduced in 1997 after the release of JDK 1.1. JFC was subsequently included as an integral part of JDK since JDK 1.2. JFC consists of:\n• Accessibility API: provides assistive technology for the disabled.\n\nThe goal of Java GUI programming is to allow the programmer to build GUI that looks good on ALL platforms. JDK 1.0's AWT was awkward and non-object-oriented (using many ). JDK 1.1's AWT introduced event-delegation (event-driven) model, much clearer and object-oriented. JDK 1.1 also introduced inner class and JavaBeans – a component programming model for visual programming environment (similar to Visual Basic).\n\nSwing appeared after JDK 1.1. It was introduced into JDK 1.1 as part of an add-on JFC (Java Foundation Classes). Swing is a rich set of easy-to-use, easy-to-understand JavaBean GUI components that can be dragged and dropped as \"GUI builders\" in visual programming environment. Swing is now an integral part of Java since JDK 1.2.\n\nSwing is huge (consists of 18 packages of 737 classes as in JDK 1.8) and has great depth. Compared with AWT, Swing provides a huge and comprehensive collection of reusable GUI components, as shown in the Figure below (extracted form Swing Tutorial).\n\nThe main features of Swing are (extracted from the Swing website):\n• Swing is written in pure Java (except a few classes) and therefore is 100% portable.\n• Swing components are lightweight. The AWT components are heavyweight (in terms of system resource utilization). Each AWT component has its own opaque native display, and always displays on top of the lightweight components. AWT components rely heavily on the underlying windowing subsystem of the native operating system. For example, an AWT button ties to an actual button in the underlying native windowing subsystem, and relies on the native windowing subsystem for their rendering and processing. Swing components ( s) are written in Java. They are generally not \"weight-down\" by complex GUI considerations imposed by the underlying windowing subsystem.\n• Swing components support pluggable look-and-feel. You can choose between Java look-and-feel and the look-and-feel of the underlying OS (e.g., Windows, UNIX or macOS). If the later is chosen, a Swing button runs on the Windows looks like a Windows' button and feels like a Window's button. Similarly, a Swing button runs on the UNIX looks like a UNIX's button and feels like a UNIX's button.\n• Swing supports mouse-less operation, i.e., it can operate entirely using keyboard.\n• Swing components are JavaBeans – a Component-based Model used in Visual Programming (like Visual Basic). You can drag-and-drop a Swing component into a \"design form\" using a \"GUI builder\" and double-click to attach an event handler.\n• Swing application uses AWT event-handling classes (in package ). Swing added some new classes in package , but they are not frequently used.\n• Swing application uses AWT's layout manager (such as and in package ). It added new layout managers, such as , , and (in package ).\n\nIf you understood the AWT programming (in particular, container/component and event-handling), switching over to Swing (or any other Graphics packages) is straight-forward.\n\nCompared with the AWT component classes (in package ), Swing component classes (in package ) begin with a prefix , e.g., , , , , , or .\n\nThe above figure shows the class hierarchy of the swing GUI classes. Similar to AWT, there are two groups of classes: containers and components. A container is used to hold components. A container can also hold containers because it is a (subclass of) component.\n\nAs a rule, do not mix heavyweight AWT components and lightweight Swing components in the same program, as the heavyweight components will always be painted on top of the lightweight components.\n\nJust like AWT application, a Swing application requires a top-level container. There are three top-level containers in Swing:\n• : used for the application's main window (with an icon, a title, minimize/maximize/close buttons, an optional menu-bar, and a content-pane), as illustrated.\n• : used for secondary pop-up window (with a title, a close button, and a content-pane).\n• : used for the applet's display-area (content-pane) inside a browser’s window.\n\nSimilarly to AWT, there are secondary containers (such as ) which can be used to group and layout relevant components.\n\nHowever, unlike AWT, the shall not be added onto the top-level container (e.g., , ) directly because they are lightweight components. The must be added onto the so-called content-pane of the top-level container. Content-pane is in fact a that can be used to group and layout components.\n• get the content-pane via from a top-level container, and add components onto it. For example,\n• set the content-pane to a (the main panel created in your application which holds all your GUI components) via 's .\n\nNotes: If a component is added directly into a , it is added into the content-pane of instead, i.e.,\n\nSwing uses the AWT event-handling classes (in package ). Swing introduces a few new event-handling classes (in package ) but they are not frequently used.\n\nIn summary, to write a Swing application, you have:\n• Use the Swing components with prefix in package , e.g., , , , , etc.\n• A top-level container (typically ) is needed. The should not be added directly onto the top-level container. They shall be added onto the content-pane of the top-level container. You can retrieve a reference to the content-pane by invoking method from the top-level container.\n• Run the constructor in the Event Dispatcher Thread (instead of Main thread) for thread safety, as shown in the following program template.\n\nI will explain this template in the following Swing example.\n\nLet's convert the earlier AWT application example into Swing. Compare the two source files and note the changes (which are highlighted). The display is shown below. Note the differences in look and feel between the AWT GUI components and Swing's.\n\nThe 's method returns the content-pane (which is a ) of the . You can then set its layout (the default layout is ), and add components into it. For example,\n\nYou can also use the 's method to directly set the content-pane to a (or a ). For example,\n\nInstead of writing a listener with a handler to process the \"close-window\" button, provides a method called to sets the default operation when the user initiates a \"close\" on this frame. Typically, we choose the option , which terminates the application via a .\n\nRunning the GUI Construction Codes on the Event-Dispatching Thread\n\nIn the previous examples, we invoke the constructor directly in the entry method to setup the GUI components. For example,\n\nThe constructor will be executed in the so-called \"Main-Program\" thread. This may cause multi-threading issues (such as unresponsive user-interface and deadlock).\n\nIt is recommended to execute the GUI setup codes in the so-called \"Event-Dispatching\" thread, instead of \"Main-Program\" thread, for thread-safe operations. Event-dispatching thread, which processes events, should be used when the codes updates the GUI.\n\nTo run the constructor on the event-dispatching thread, invoke method to asynchronously queue the constructor on the event-dispatching thread. The codes will be run after all pending events have been processed. For example,\n\nNote: is a cover for (which is used in the NetBeans' Visual GUI Builder).\n\nAt times, for example in game programming, the constructor or the may contains non-GUI codes. Hence, it is a common practice to create a dedicated method called (used in NetBeans visual GUI builder) or (used in Swing tutorial) to handle all the GUI codes (and another method called to handle initialization of the game's objects). This GUI init method shall be run in the event-dispatching thread.\n\nWarning Message \"The serialization class does not declare a static final serialVersionUID field of type long\"\n\nThis warning message is triggered because (via its superclass ) implements the interface. This interface enables the object to be written out to an output stream serially (via method ); and read back into the program (via method ). The serialization runtime uses a number (called ) to ensure that the object read into the program is compatible with the class definition, and not belonging to another version.\n\nYou have these options:\n• Simply ignore this warning message. If a class does not explicitly declare a , then the serialization runtime will calculate a default value for that class based on various aspects of the class.\n• Suppress this particular warning via annotation (in package ) (JDK 1.5):\n\nIf you have a complicated layout for your GUI application, you should use a GUI Builder, such as NetBeans or Eclipse to layout your GUI components in a drag-and-drop manner, similar to the popular visual languages such as Visual Basic.\n\nFor using NetBeans GUI Builder, read my \"Writing Java GUI (AWT/Swing) Application in NetBeans\"; or Swing Tutorial's \"Learning Swing with the NetBeans IDE\".\n\nFor using Eclipse GUI Builder, read \"Writing Swing Applications using Eclipse GUI Builder\"."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html",
        "document": "\n• Gets the name of the component.\n• Sets the name of the component to the specified string. - the string that is to be this component's name\n• Gets the parent of this component. the parent container of this component\n• Associate a with this component. The will receive drops only if it is enabled.\n• Gets the associated with this .\n• Gets the associated with this . If the has not been assigned a specific , the of the object's top-level container is returned. If the has been created, but not yet added to a , this method returns . the used by this or\n• Gets this component's locking object (the object that owns the thread synchronization monitor) for AWT component-tree and layout operations.\n• Gets the toolkit of this component. Note that the frame that contains a component controls which toolkit is used by that component. Therefore if the component is moved from one frame to another, the toolkit it uses may change. the toolkit of this component\n• Determines whether this component is valid. A component is valid when it is correctly sized and positioned within its parent container and all its children are also valid. In order to account for peers' size requirements, components are invalidated before they are first shown on the screen. By the time the parent container is fully realized, all its components will be valid. if the component is valid, otherwise\n• Determines whether this component is displayable. A component is displayable when it is connected to a native screen resource. A component is made displayable either when it is added to a displayable containment hierarchy or when its containment hierarchy is made displayable. A containment hierarchy is made displayable when its ancestor window is either packed or made visible. A component is made undisplayable either when it is removed from a displayable containment hierarchy or when its containment hierarchy is made undisplayable. A containment hierarchy is made undisplayable when its ancestor window is disposed. if the component is displayable, otherwise\n• Determines whether this component should be visible when its parent is visible. Components are initially visible, with the exception of top level components such as objects. if the component is visible, otherwise\n• 's coordinate space if the is directly under the mouse pointer, otherwise returns . If the is not showing on the screen, this method returns even if the mouse pointer is above the area where the would be displayed. If the is partially or fully obscured by other s or native windows, this method returns a non-null value only if the mouse pointer is located above the unobscured part of the . Returns the position of the mouse pointer in this's coordinate space if theis directly under the mouse pointer, otherwise returns. If theis not showing on the screen, this method returnseven if the mouse pointer is above the area where thewould be displayed. If theis partially or fully obscured by others or native windows, this method returns a non-null value only if the mouse pointer is located above the unobscured part of the For s it returns a non-null value if the mouse is above the itself or above any of its descendants. Use if you need to exclude children. Sometimes the exact mouse coordinates are not important, and the only thing that matters is whether a specific is under the mouse pointer. If the return value of this method is , mouse pointer is not directly above the . mouse coordinates relative to this , or null\n• Determines whether this component is showing on screen. This means that the component must be visible, and it must be in a container that is visible and showing. Note: sometimes there is no way to detect whether the is actually visible to the user. This can happen when:\n• the component has been added to a visible but the is not currently in the scroll pane's view port.\n• the is obscured by another or . if the component is showing, otherwise\n• Determines whether this component is enabled. An enabled component can respond to user input and generate events. Components are enabled initially by default. A component may be enabled or disabled by calling its method. if the component is enabled, otherwise\n• . An enabled component can respond to user input and generate events. Components are enabled initially by default. Enables or disables this component, depending on the value of the parameter. An enabled component can respond to user input and generate events. Components are enabled initially by default. Note: Disabling a lightweight component does not prevent it from receiving MouseEvents. Note: Disabling a heavyweight container prevents all components in this container from receiving any input events. But disabling a lightweight container affects only this container. - If , this component is enabled; otherwise this component is disabled\n• Returns true if this component is painted to an offscreen image (\"buffer\") that's copied to the screen later. Component subclasses that support double buffering should override this method to return true if double buffering is enabled.\n• Enables or disables input method support for this component. If input method support is enabled and the component also processes key events, incoming events are offered to the current input method and will only be processed by the component or dispatched to its listeners if the input method does not consume them. By default, input method support is enabled.\n• . Shows or hides this component depending on the value of parameter This method changes layout-related information, and therefore, invalidates the component hierarchy. - if , shows this component; otherwise, hides this component\n• Gets the foreground color of this component. this component's foreground color; if this component does not have a foreground color, the foreground color of its parent is returned\n• Sets the foreground color of this component. - the color to become this component's foreground color; if this parameter is then this component will inherit the foreground color of its parent\n• Returns whether the foreground color has been explicitly set for this Component. If this method returns , this Component is inheriting its foreground color from an ancestor. if the foreground color has been explicitly set for this Component; otherwise.\n• Gets the background color of this component. this component's background color; if this component does not have a background color, the background color of its parent is returned\n• Sets the background color of this component. The background color affects each component differently and the parts of the component that are affected by the background color may differ between operating systems. - the color to become this component's color; if this parameter is , then this component will inherit the background color of its parent\n• Returns whether the background color has been explicitly set for this Component. If this method returns , this Component is inheriting its background color from an ancestor. if the background color has been explicitly set for this Component; otherwise.\n• Gets the font of this component. this component's font; if a font has not been set for this component, the font of its parent is returned\n• Sets the font of this component. This method changes layout-related information, and therefore, invalidates the component hierarchy. - the font to become this component's font; if this parameter is then this component will inherit the font of its parent\n• Returns whether the font has been explicitly set for this Component. If this method returns , this Component is inheriting its font from an ancestor. if the font has been explicitly set for this Component; otherwise.\n• Gets the locale of this component. this component's locale; if this component does not have a locale, the locale of its parent is returned - if the does not have its own locale and has not yet been added to a containment hierarchy such that the locale can be determined from the containing parent\n• Sets the locale of this component. This is a bound property. This method changes layout-related information, and therefore, invalidates the component hierarchy. - the locale to become this component's locale\n• Gets the instance of used to display the component on the output device. the color model used by this component\n• Gets the location of this component in the form of a point specifying the component's top-left corner. The location will be relative to the parent's coordinate space. Due to the asynchronous nature of native event handling, this method can return outdated values (for instance, after several calls of in rapid succession). For this reason, the recommended method of obtaining a component's position is within , which is called after the operating system has finished moving the component. an instance of representing the top-left corner of the component's bounds in the coordinate space of the component's parent\n• Gets the location of this component in the form of a point specifying the component's top-left corner in the screen's coordinate space. an instance of representing the top-left corner of the component's bounds in the coordinate space of the screen - if the component is not showing on the screen\n• and parameters in the coordinate space of this component's parent. Moves this component to a new location. The top-left corner of the new location is specified by theandparameters in the coordinate space of this component's parent. This method changes layout-related information, and therefore, invalidates the component hierarchy. - the x-coordinate of the new location's top-left corner in the parent's coordinate space - the y-coordinate of the new location's top-left corner in the parent's coordinate space\n• . Point is given in the parent's coordinate space. Moves this component to a new location. The top-left corner of the new location is specified by point. Pointis given in the parent's coordinate space. This method changes layout-related information, and therefore, invalidates the component hierarchy. - the point defining the top-left corner of the new location, given in the coordinate space of this component's parent\n• Returns the size of this component in the form of a object. The field of the object contains this component's height, and the field of the object contains this component's width. a object that indicates the size of this component\n• and height . Resizes this component so that it has widthand height This method changes layout-related information, and therefore, invalidates the component hierarchy. - the new width of this component in pixels - the new height of this component in pixels\n• and height . Resizes this component so that it has widthand height This method changes layout-related information, and therefore, invalidates the component hierarchy. - the dimension specifying the new size of this component\n• Gets the bounds of this component in the form of a object. The bounds specify this component's width, height, and location relative to its parent.\n• and , and the new size is specified by and . Moves and resizes this component. The new location of the top-left corner is specified byand, and the new size is specified byand This method changes layout-related information, and therefore, invalidates the component hierarchy. - the new x-coordinate of this component - the new y-coordinate of this component - the new of this component - the new of this component\n• . This component's new position is specified by and , and its new size is specified by and Moves and resizes this component to conform to the new bounding rectangle. This component's new position is specified byand, and its new size is specified byand This method changes layout-related information, and therefore, invalidates the component hierarchy. - the new bounding rectangle for this component\n• Returns the current x coordinate of the components origin. This method is preferable to writing , or because it doesn't cause any heap allocations. the current x coordinate of the components origin\n• Returns the current y coordinate of the components origin. This method is preferable to writing , or because it doesn't cause any heap allocations. the current y coordinate of the components origin\n• Returns the current width of this component. This method is preferable to writing , or because it doesn't cause any heap allocations. the current width of this component\n• Returns the current height of this component. This method is preferable to writing , or because it doesn't cause any heap allocations. the current height of this component\n• Stores the bounds of this component into \"return value\" rv and return rv. If rv is a new is allocated. This version of is useful if the caller wants to avoid allocating a new object on the heap. - the return value, modified to the components bounds\n• Stores the width/height of this component into \"return value\" rv and return rv. If rv is a new object is allocated. This version of is useful if the caller wants to avoid allocating a new object on the heap. - the return value, modified to the components size\n• Stores the x,y origin of this component into \"return value\" rv and return rv. If rv is a new is allocated. This version of is useful if the caller wants to avoid allocating a new object on the heap. - the return value, modified to the components location\n• Returns true if this component is completely opaque, returns false by default. An opaque component paints every pixel within its rectangular region. A non-opaque component paints only some of its pixels, allowing the pixels underneath it to \"show through\". A component that does not fully paint its pixels therefore provides a degree of transparency. Subclasses that guarantee to always completely paint their contents should override this method and return true. true if this component is completely opaque\n• and , other than the ones defined in this package like or , are lightweight. All of the Swing components are lightweights. A lightweight component doesn't have a native toolkit peer. Subclasses ofand, other than the ones defined in this package likeor, are lightweight. All of the Swing components are lightweights. This method will always return if this component is not displayable because it is impossible to determine the weight of an undisplayable component. true if this component has a lightweight peer; false if it has a native peer or no peer\n• Sets the preferred size of this component to a constant value. Subsequent calls to will always return this value. Setting the preferred size to restores the default behavior. - The new preferred size, or null\n• Returns true if the preferred size has been set to a non- value otherwise returns false. true if has been invoked with a non-null value.\n• Gets the preferred size of this component.\n• Sets the minimum size of this component to a constant value. Subsequent calls to will always return this value. Setting the minimum size to restores the default behavior. - the new minimum size of this component\n• Returns whether or not has been invoked with a non-null value. true if has been invoked with a non-null value.\n• Gets the minimum size of this component.\n• Sets the maximum size of this component to a constant value. Subsequent calls to will always return this value. Setting the maximum size to restores the default behavior.\n• Returns true if the maximum size has been set to a non- value otherwise returns false. true if is non- , false otherwise\n• Gets the maximum size of this component.\n• Returns the alignment along the x axis. This specifies how the component would like to be aligned relative to other components. The value should be a number between 0 and 1 where 0 represents alignment along the origin, 1 is aligned the furthest away from the origin, 0.5 is centered, etc.\n• Returns the alignment along the y axis. This specifies how the component would like to be aligned relative to other components. The value should be a number between 0 and 1 where 0 represents alignment along the origin, 1 is aligned the furthest away from the origin, 0.5 is centered, etc.\n• s to align components along their baseline. A return value less than 0 indicates this component does not have a reasonable baseline and that s should not align this component on its baseline. Returns the baseline. The baseline is measured from the top of the component. This method is primarily meant fors to align components along their baseline. A return value less than 0 indicates this component does not have a reasonable baseline and thats should not align this component on its baseline. The default implementation returns -1. Subclasses that support baseline should override appropriately. If a value >= 0 is returned, then the component has a valid baseline for any size >= the minimum size and can be used to determine how the baseline changes with size. - the width to get the baseline for - the height to get the baseline for the baseline or < 0 indicating there is no reasonable baseline - if width or height is < 0\n• Returns an enum indicating how the baseline of the component changes as the size changes. This method is primarily meant for layout managers and GUI builders. The default implementation returns . Subclasses that have a baseline should override appropriately. Subclasses should never return ; if the baseline can not be calculated return . Callers should first ask for the baseline using and if a value >= 0 is returned use this method. It is acceptable for this method to return a value other than even if returns a value less than 0. an enum indicating how the baseline changes as the component size changes\n• Prompts the layout manager to lay out this component. This is usually called when the component (more specifically, container) is validated.\n• The meaning of the term validating is defined by the ancestors of this class. See for more details.\n• Invalidates this component and its ancestors. By default, all the ancestors of the component up to the top-most container of the hierarchy are marked invalid. If the system property is set to , invalidation stops on the nearest validate root of this component. Marking a container invalid indicates that the container needs to be laid out. This method is called automatically when any layout-related information changes (e.g. setting the bounds of the component, or adding the component to a container). This method might be called often, so it should work fast.\n• Revalidates the component hierarchy up to the nearest validate root. This method first invalidates the component hierarchy starting from this component up to the nearest validate root. Afterwards, the component hierarchy is validated starting from the nearest validate root. This is a convenience method supposed to help application developers avoid looking for validate roots manually. Basically, it's equivalent to first calling the method on this component, and then calling the method on the nearest validate root.\n• Creates a graphics context for this component. This method will return if this component is currently not displayable. a graphics context for this component, or if it has none\n• Gets the font metrics for the specified font. Warning: Since Font metrics are affected by the and this method does not provide one, it can return only metrics for the default render context which may not match that used when rendering on the Component if functionality is being used. Instead metrics can be obtained at rendering time by calling or text measurement APIs on the class. - the font for which font metrics is to be obtained\n• method for this component returns true for the current cursor location, and this Component is visible, displayable, and enabled. Setting the cursor of a causes that cursor to be displayed within all of the container's subcomponents, except for those that have a non- cursor. Sets the cursor image to the specified cursor. This cursor image is displayed when themethod for this component returns true for the current cursor location, and this Component is visible, displayable, and enabled. Setting the cursor of acauses that cursor to be displayed within all of the container's subcomponents, except for those that have a non-cursor. The method may have no visual effect if the Java platform implementation and/or the native system do not support changing the mouse cursor shape. - One of the constants defined by the class; if this parameter is then this component will inherit the cursor of its parent\n• Gets the cursor set in the component. If the component does not have a cursor set, the cursor of its parent is returned. If no cursor is set in the entire hierarchy, is returned.\n• Returns whether the cursor has been explicitly set for this Component. If this method returns , this Component is inheriting its cursor from an ancestor. if the cursor has been explicitly set for this Component; otherwise.\n• This method is called when the contents of the component should be painted; such as when the component is first being shown or is damaged and in need of repair. The clip rectangle in the parameter is set to the area which needs to be painted. Subclasses of that override this method need not call . For performance reasons, s with zero width or height aren't considered to need painting when they are first shown, and also aren't considered to need repair. Note: For more information on the paint mechanisms utilitized by AWT and Swing, including information on how to write the most efficient painting code, see Painting in AWT and Swing. - the graphics context to use for painting\n• If this component is not a lightweight component, the AWT calls the method in response to a call to . You can assume that the background is not cleared. The method of calls this component's method to redraw this component. This method is commonly overridden by subclasses which need to do additional work in response to a call to . Subclasses of Component that override this method should either call , or call directly from their method. The origin of the graphics context, its ( , ) coordinate point, is the top-left corner of this component. The clipping region of the graphics context is the bounding rectangle of this component. Note: For more information on the paint mechanisms utilitized by AWT and Swing, including information on how to write the most efficient painting code, see Painting in AWT and Swing. - the specified context to use for updating\n• Paints this component and all of its subcomponents. The origin of the graphics context, its ( , ) coordinate point, is the top-left corner of this component. The clipping region of the graphics context is the bounding rectangle of this component. - the graphics context to use for painting\n• If this component is a lightweight component, this method causes a call to this component's method as soon as possible. Otherwise, this method causes a call to this component's method as soon as possible. Note: For more information on the paint mechanisms utilitized by AWT and Swing, including information on how to write the most efficient painting code, see Painting in AWT and Swing.\n• within milliseconds. Repaints the component. If this component is a lightweight component, this results in a call towithinmilliseconds. Note: For more information on the paint mechanisms utilitized by AWT and Swing, including information on how to write the most efficient painting code, see Painting in AWT and Swing.\n• Repaints the specified rectangle of this component. If this component is a lightweight component, this method causes a call to this component's method as soon as possible. Otherwise, this method causes a call to this component's method as soon as possible. Note: For more information on the paint mechanisms utilitized by AWT and Swing, including information on how to write the most efficient painting code, see Painting in AWT and Swing.\n• milliseconds. Repaints the specified rectangle of this component withinmilliseconds. If this component is a lightweight component, this method causes a call to this component's method. Otherwise, this method causes a call to this component's method. Note: For more information on the paint mechanisms utilitized by AWT and Swing, including information on how to write the most efficient painting code, see Painting in AWT and Swing.\n• Prints this component. Applications should override this method for components that must do special processing before being printed or should be printed differently than they are painted. The default implementation of this method calls the method. The origin of the graphics context, its ( , ) coordinate point, is the top-left corner of this component. The clipping region of the graphics context is the bounding rectangle of this component. - the graphics context to use for printing\n• Prints this component and all of its subcomponents. The origin of the graphics context, its ( , ) coordinate point, is the top-left corner of this component. The clipping region of the graphics context is the bounding rectangle of this component. - the graphics context to use for printing\n• method of an is called when more information about an image which had been previously requested using an asynchronous routine such as the method of becomes available. See the definition of for more information on this method and its arguments. Repaints the component when the image has changed. Thismethod of anis called when more information about an image which had been previously requested using an asynchronous routine such as themethod ofbecomes available. See the definition offor more information on this method and its arguments. The method of incrementally draws an image on the component as more of the bits of the image are available. If the system property is missing or has the value , the image is incrementally drawn. If the system property has any other value, then the image is not drawn until it has been completely loaded. Also, if incremental drawing is in effect, the value of the system property is interpreted as an integer to give the maximum redraw rate, in milliseconds. If the system property is missing or cannot be interpreted as an integer, the redraw rate is once every 100ms. The interpretation of the , , , and arguments depends on the value of the argument. - see for more information if the infoflags indicate that the image is completely loaded; otherwise.\n• Creates an image from the specified image producer.\n• Creates an off-screen drawable image to be used for double buffering. an off-screen drawable image, which can be used for double buffering. The return value may be if the component is not displayable. This will always happen if returns .\n• Creates a volatile off-screen drawable image to be used for double buffering. an off-screen drawable image, which can be used for double buffering. The return value may be if the component is not displayable. This will always happen if returns .\n• Creates a volatile off-screen drawable image, with the given capabilities. The contents of this image may be lost at any time due to operating system issues, so the image must be managed via the interface. a VolatileImage object, which can be used to manage surface contents loss and capabilities. - if an image with the specified capabilities cannot be created\n• Prepares an image for rendering on this component. The image data is downloaded asynchronously in another thread and the appropriate screen representation of the image is generated. - the for which to prepare a screen representation - the object to be notified as the image is being prepared if the image has already been fully prepared; otherwise\n• Prepares an image for rendering on this component at the specified width and height. The image data is downloaded asynchronously in another thread, and an appropriately scaled screen representation of the image is generated. - the instance of for which to prepare a screen representation - the width of the desired screen representation - the height of the desired screen representation - the object to be notified as the image is being prepared if the image has already been fully prepared; otherwise\n• Returns the status of the construction of a screen representation of the specified image. This method does not cause the image to begin loading. An application must use the method to force the loading of an image. Information on the flags returned by this method can be found with the discussion of the interface. - the object whose status is being checked - the object to be notified as the image is being prepared the bitwise inclusive OR of flags indicating what information about the image is currently available\n• Returns the status of the construction of a screen representation of the specified image. This method does not cause the image to begin loading. An application must use the method to force the loading of an image. The method of calls its peer's method to calculate the flags. If this component does not yet have a peer, the component's toolkit's method is called instead. Information on the flags returned by this method can be found with the discussion of the interface. - the object whose status is being checked - the width of the scaled version whose status is to be checked - the height of the scaled version whose status is to be checked - the object to be notified as the image is being prepared the bitwise inclusive OR of flags indicating what information about the image is currently available\n• Sets whether or not paint messages received from the operating system should be ignored. This does not affect paint events generated in software by the AWT, unless they are an immediate response to an OS-level paint message. This is useful, for example, if running under full-screen mode and better performance is desired, or if page-flipping is used as the buffer strategy.\n• whether or not paint messages received from the operating system should be ignored.\n• Checks whether this component \"contains\" the specified point, where and are defined to be relative to the coordinate system of this component. - the x coordinate of the point - the y coordinate of the point\n• Checks whether this component \"contains\" the specified point, where the point's x and y coordinates are defined to be relative to the coordinate system of this component.\n• x, y) location, and if so, returns the containing component. This method only looks one level deep. If the point (x, y) is inside a subcomponent that itself has subcomponents, it does not go looking down the subcomponent tree. Determines if this component or one of its immediate subcomponents contains the () location, and if so, returns the containing component. This method only looks one level deep. If the point () is inside a subcomponent that itself has subcomponents, it does not go looking down the subcomponent tree. The method of simply returns the component itself if the (x, y) coordinate location is inside its bounding box, and otherwise. the component or subcomponent that contains the (x, y) location; if the location is outside this component\n• Returns the component or subcomponent that contains the specified point.\n• Dispatches an event to this component or one of its sub components. Calls before returning for 1.1-style events which have been enabled for the .\n• is , no exception is thrown and no action is performed. Adds the specified component listener to receive component events from this component. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• is , no exception is thrown and no action is performed. Removes the specified component listener so that it no longer receives component events from this component. This method performs no function, nor does it throw an exception, if the listener specified by the argument was not previously added to this component. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• Returns an array of all the component listeners registered on this component. all s of this component or an empty array if no component listeners are currently registered\n• is , no exception is thrown and no action is performed. Adds the specified focus listener to receive focus events from this component when this component gains input focus. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• is , no exception is thrown and no action is performed. Removes the specified focus listener so that it no longer receives focus events from this component. This method performs no function, nor does it throw an exception, if the listener specified by the argument was not previously added to this component. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• Returns an array of all the focus listeners registered on this component. all of this component's s or an empty array if no component listeners are currently registered\n• is , no exception is thrown and no action is performed. Adds the specified hierarchy listener to receive hierarchy changed events from this component when the hierarchy to which this container belongs changes. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• is , no exception is thrown and no action is performed. Removes the specified hierarchy listener so that it no longer receives hierarchy changed events from this component. This method performs no function, nor does it throw an exception, if the listener specified by the argument was not previously added to this component. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• Returns an array of all the hierarchy listeners registered on this component. all of this component's s or an empty array if no hierarchy listeners are currently registered\n• is , no exception is thrown and no action is performed. Adds the specified hierarchy bounds listener to receive hierarchy bounds events from this component when the hierarchy to which this container belongs changes. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• is , no exception is thrown and no action is performed. Removes the specified hierarchy bounds listener so that it no longer receives hierarchy bounds events from this component. This method performs no function, nor does it throw an exception, if the listener specified by the argument was not previously added to this component. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• Returns an array of all the hierarchy bounds listeners registered on this component. all of this component's s or an empty array if no hierarchy bounds listeners are currently registered\n• Adds the specified key listener to receive key events from this component. If l is null, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• is , no exception is thrown and no action is performed. Removes the specified key listener so that it no longer receives key events from this component. This method performs no function, nor does it throw an exception, if the listener specified by the argument was not previously added to this component. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• Returns an array of all the key listeners registered on this component. all of this component's s or an empty array if no key listeners are currently registered\n• is , no exception is thrown and no action is performed. Adds the specified mouse listener to receive mouse events from this component. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• is , no exception is thrown and no action is performed. Removes the specified mouse listener so that it no longer receives mouse events from this component. This method performs no function, nor does it throw an exception, if the listener specified by the argument was not previously added to this component. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• Returns an array of all the mouse listeners registered on this component. all of this component's s or an empty array if no mouse listeners are currently registered\n• is , no exception is thrown and no action is performed. Adds the specified mouse motion listener to receive mouse motion events from this component. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• is , no exception is thrown and no action is performed. Removes the specified mouse motion listener so that it no longer receives mouse motion events from this component. This method performs no function, nor does it throw an exception, if the listener specified by the argument was not previously added to this component. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• Returns an array of all the mouse motion listeners registered on this component. all of this component's s or an empty array if no mouse motion listeners are currently registered\n• Adds the specified mouse wheel listener to receive mouse wheel events from this component. Containers also receive mouse wheel events from sub-components. For information on how mouse wheel events are dispatched, see the class description for . If l is , no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• Removes the specified mouse wheel listener so that it no longer receives mouse wheel events from this component. This method performs no function, nor does it throw an exception, if the listener specified by the argument was not previously added to this component. If l is null, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• Returns an array of all the mouse wheel listeners registered on this component. all of this component's s or an empty array if no mouse wheel listeners are currently registered\n• to return an instance. If listener is , no exception is thrown and no action is performed. Adds the specified input method listener to receive input method events from this component. A component will only receive input method events from input methods if it also overridesto return aninstance. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• is , no exception is thrown and no action is performed. Removes the specified input method listener so that it no longer receives input method events from this component. This method performs no function, nor does it throw an exception, if the listener specified by the argument was not previously added to this component. If listeneris, no exception is thrown and no action is performed. Refer to AWT Threading Issues for details on AWT's threading model.\n• Returns an array of all the input method listeners registered on this component. all of this component's s or an empty array if no input method listeners are currently registered\n• s upon this . s are registered using the method. Returns an array of all the objects currently registered ass upon thiss are registered using themethod. You can specify the argument with a class literal, such as . For example, you can query a for its mouse listeners with the following code: If no such listeners exist, this method returns an empty array. If no such listeners exist, this method returns an empty array. - the type of listeners requested; this parameter should specify an interface that descends from an array of all objects registered as s on this component, or an empty array if no such listeners have been added - if doesn't specify a class or interface that implements\n• Gets the input method request handler which supports requests from input methods for this component. A component that supports on-the-spot text input must override this method to return an instance. At the same time, it also has to handle input method events. the input method request handler for this component, by default\n• Gets the input context used by this component for handling the communication with input methods when text is entered in this component. By default, the input context used for the parent component is returned. Components may override this to return a private input context. the input context used by this component; if no context can be determined\n• Enables the events defined by the specified event mask parameter to be delivered to this component. Event types are automatically enabled when a listener for that event type is added to the component. This method only needs to be invoked by subclasses of which desire to have the specified event types delivered to regardless of whether or not a listener is registered.\n• Disables the events defined by the specified event mask parameter from being delivered to this component.\n• if an event with the same ID as the event to be posted is found in the queue (both events must have this component as their source). This method either returns a coalesced event which replaces the existing event (and the new event is then discarded), or to indicate that no combining should be done (add the second event to the end of the queue). Either event parameter may be modified and returned, as the other one is discarded unless is returned. Potentially coalesce an event being posted with an existing event. This method is called byif an event with the same ID as the event to be posted is found in the queue (both events must have this component as their source). This method either returns a coalesced event which replaces the existing event (and the new event is then discarded), orto indicate that no combining should be done (add the second event to the end of the queue). Either event parameter may be modified and returned, as the other one is discarded unlessis returned. This implementation of coalesces two event types: mouse move (and drag) events, and paint (and update) events. For mouse move events the last event is always returned, causing intermediate moves to be discarded. For paint events, the new event is coalesced into a complex in the peer. The new is always returned. - the event already on the - the event being posted to the a coalesced event, or indicating that no coalescing was done\n• method for the given class of event. Processes events occurring on this component. By default this method calls the appropriatemethod for the given class of event. Note that if the event parameter is the behavior is unspecified and may result in an exception.\n• objects. Processes component events occurring on this component by dispatching them to any registeredobjects. This method is not called unless component events are enabled for this component. Component events are enabled when one of the following occurs: Note that if the event parameter is the behavior is unspecified and may result in an exception.\n• objects. Processes focus events occurring on this component by dispatching them to any registeredobjects. This method is not called unless focus events are enabled for this component. Focus events are enabled when one of the following occurs: If focus events are enabled for a , the current determines whether or not a focus event should be dispatched to registered objects. If the events are to be dispatched, the calls the 's method, which results in a call to the 's method. If focus events are enabled for a , calling the 's method with a as the argument will result in a call to the 's method regardless of the current . Note that if the event parameter is the behavior is unspecified and may result in an exception.\n• objects. Processes key events occurring on this component by dispatching them to any registeredobjects. This method is not called unless key events are enabled for this component. Key events are enabled when one of the following occurs: If key events are enabled for a , the current determines whether or not a key event should be dispatched to registered objects. The will not dispatch key events to a that is not the focus owner or is not showing. As of J2SE 1.4, s are redirected to the focus owner. Please see the Focus Specification for further information. Calling a 's method with a as the argument will result in a call to the 's method regardless of the current as long as the component is showing, focused, and enabled, and key events are enabled on it. If the event parameter is the behavior is unspecified and may result in an exception.\n• objects. Processes mouse events occurring on this component by dispatching them to any registeredobjects. This method is not called unless mouse events are enabled for this component. Mouse events are enabled when one of the following occurs: Note that if the event parameter is the behavior is unspecified and may result in an exception.\n• objects. Processes mouse motion events occurring on this component by dispatching them to any registeredobjects. This method is not called unless mouse motion events are enabled for this component. Mouse motion events are enabled when one of the following occurs: Note that if the event parameter is the behavior is unspecified and may result in an exception.\n• objects. Processes mouse wheel events occurring on this component by dispatching them to any registeredobjects. This method is not called unless mouse wheel events are enabled for this component. Mouse wheel events are enabled when one of the following occurs: For information on how mouse wheel events are dispatched, see the class description for . Note that if the event parameter is the behavior is unspecified and may result in an exception.\n• objects. Processes input method events occurring on this component by dispatching them to any registeredobjects. This method is not called unless input method events are enabled for this component. Input method events are enabled when one of the following occurs:\n• An object is registered via . Note that if the event parameter is the behavior is unspecified and may result in an exception.\n• objects. Processes hierarchy events occurring on this component by dispatching them to any registeredobjects. This method is not called unless hierarchy events are enabled for this component. Hierarchy events are enabled when one of the following occurs:\n• An object is registered via . Note that if the event parameter is the behavior is unspecified and may result in an exception.\n• objects. Processes hierarchy bounds events occurring on this component by dispatching them to any registeredobjects. This method is not called unless hierarchy bounds events are enabled for this component. Hierarchy bounds events are enabled when one of the following occurs:\n• An object is registered via . Note that if the event parameter is the behavior is unspecified and may result in an exception.\n• displayable by connecting it to a native screen resource. This method is called internally by the toolkit and should not be called directly by programs. Makes thisdisplayable by connecting it to a native screen resource. This method is called internally by the toolkit and should not be called directly by programs. This method changes layout-related information, and therefore, invalidates the component hierarchy.\n• undisplayable by destroying it native screen resource. This method is called by the toolkit internally and should not be called directly by programs. Code overriding this method should call as the first line of the overriding method.\n• Returns whether this can become the focus owner. if this is focusable; otherwise\n• Returns whether this Component can be focused. if this Component is focusable; otherwise.\n• Sets the focusable state of this Component to the specified value. This value overrides the Component's default focusability. - indicates whether this Component is focusable\n• Sets the focus traversal keys for a given traversal operation for this Component. The default values for a Component's focus traversal keys are implementation-dependent. Sun recommends that all implementations for a particular native platform use the same default values. The recommendations for Windows and Unix are listed below. These recommendations are used in the Sun AWT implementations. Go up one focus traversal cycle To disable a traversal key, use an empty Set; Collections.EMPTY_SET is recommended. To disable a traversal key, use an empty Set; Collections.EMPTY_SET is recommended. Using the AWTKeyStroke API, client code can specify on which of two specific KeyEvents, KEY_PRESSED or KEY_RELEASED, the focus traversal operation will occur. Regardless of which KeyEvent is specified, however, all KeyEvents related to the focus traversal key, including the associated KEY_TYPED event, will be consumed, and will not be dispatched to any Component. It is a runtime error to specify a KEY_TYPED event as mapping to a focus traversal operation, or to map the same event to multiple default focus traversal operations. If a value of null is specified for the Set, this Component inherits the Set from its parent. If all ancestors of this Component have null specified for the Set, then the current KeyboardFocusManager's default Set is used. This method may throw a if any in is not an . - one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS - the Set of AWTKeyStroke for the specified operation - if id is not one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or if keystrokes contains null, or if any keystroke represents a KEY_TYPED event, or if any keystroke already maps to another focus traversal operation for this Component\n• for a full description of each key.) Returns the Set of focus traversal keys for a given traversal operation for this Component. (Seefor a full description of each key.) If a Set of traversal keys has not been explicitly defined for this Component, then this Component's parent's Set is returned. If no Set has been explicitly defined for any of this Component's ancestors, then the current KeyboardFocusManager's default Set is returned. - one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS the Set of AWTKeyStrokes for the specified operation. The Set will be unmodifiable, and may be empty. null will never be returned. - if id is not one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS\n• Returns whether the Set of focus traversal keys for the given focus traversal operation has been explicitly defined for this Component. If this method returns , this Component is inheriting the Set from an ancestor, or from the current KeyboardFocusManager. - one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS if the the Set of focus traversal keys for the given focus traversal operation has been explicitly defined for this Component; otherwise. - if id is not one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS\n• Sets whether focus traversal keys are enabled for this Component. Components for which focus traversal keys are disabled receive key events for focus traversal keys. Components for which focus traversal keys are enabled do not see these events; instead, the events are automatically converted to traversal operations. - whether focus traversal keys are enabled for this Component\n• Returns whether focus traversal keys are enabled for this Component. Components for which focus traversal keys are disabled receive key events for focus traversal keys. Components for which focus traversal keys are enabled do not see these events; instead, the events are automatically converted to traversal operations. whether focus traversal keys are enabled for this Component\n• Requests that this Component get the input focus, and that this Component's top-level ancestor become the focused Window. This component must be displayable, focusable, visible and all of its ancestors (with the exception of the top-level Window) must be visible for the request to be granted. Every effort will be made to honor the request; however, in some cases it may be impossible to do so. Developers must never assume that this Component is the focus owner until this Component receives a FOCUS_GAINED event. If this request is denied because this Component's top-level Window cannot become the focused Window, the request will be remembered and will be granted when the Window is later focused by the user. This method cannot be used to set the focus owner to no Component at all. Use instead. Because the focus behavior of this method is platform-dependent, developers are strongly encouraged to use when possible. Note: Not all focus transfers result from invoking this method. As such, a component may receive focus without this or any of the other methods of being invoked.\n• get the input focus, and that this 's top-level ancestor become the focused . This component must be displayable, focusable, visible and all of its ancestors (with the exception of the top-level Window) must be visible for the request to be granted. Every effort will be made to honor the request; however, in some cases it may be impossible to do so. Developers must never assume that this component is the focus owner until this component receives a FOCUS_GAINED event. If this request is denied because this component's top-level window cannot become the focused window, the request will be remembered and will be granted when the window is later focused by the user. Requests that thisget the input focus, and that this's top-level ancestor become the focused. This component must be displayable, focusable, visible and all of its ancestors (with the exception of the top-level Window) must be visible for the request to be granted. Every effort will be made to honor the request; however, in some cases it may be impossible to do so. Developers must never assume that this component is the focus owner until this component receives a FOCUS_GAINED event. If this request is denied because this component's top-level window cannot become the focused window, the request will be remembered and will be granted when the window is later focused by the user. This method returns a boolean value. If is returned, the request is guaranteed to fail. If is returned, the request will succeed unless it is vetoed, or an extraordinary event, such as disposal of the component's peer, occurs before the request can be granted by the native windowing system. Again, while a return value of indicates that the request is likely to succeed, developers must never assume that this component is the focus owner until this component receives a FOCUS_GAINED event. This method cannot be used to set the focus owner to no component at all. Use instead. Because the focus behavior of this method is platform-dependent, developers are strongly encouraged to use when possible. Every effort will be made to ensure that s generated as a result of this request will have the specified temporary value. However, because specifying an arbitrary temporary state may not be implementable on all native windowing systems, correct behavior for this method can be guaranteed only for lightweight s. This method is not intended for general use, but exists instead as a hook for lightweight component libraries, such as Swing. Note: Not all focus transfers result from invoking this method. As such, a component may receive focus without this or any of the other methods of being invoked. - true if the focus change is temporary, such as when the window loses the focus; for more information on temporary focus changes see the Focus Specification if the focus change request is guaranteed to fail; if it is likely to succeed\n• Requests that this Component get the input focus, if this Component's top-level ancestor is already the focused Window. This component must be displayable, focusable, visible and all of its ancestors (with the exception of the top-level Window) must be visible for the request to be granted. Every effort will be made to honor the request; however, in some cases it may be impossible to do so. Developers must never assume that this Component is the focus owner until this Component receives a FOCUS_GAINED event. This method returns a boolean value. If is returned, the request is guaranteed to fail. If is returned, the request will succeed unless it is vetoed, or an extraordinary event, such as disposal of the Component's peer, occurs before the request can be granted by the native windowing system. Again, while a return value of indicates that the request is likely to succeed, developers must never assume that this Component is the focus owner until this Component receives a FOCUS_GAINED event. This method cannot be used to set the focus owner to no Component at all. Use instead. The focus behavior of this method can be implemented uniformly across platforms, and thus developers are strongly encouraged to use this method over when possible. Code which relies on may exhibit different focus behavior on different platforms. Note: Not all focus transfers result from invoking this method. As such, a component may receive focus without this or any of the other methods of being invoked. if the focus change request is guaranteed to fail; if it is likely to succeed\n• get the input focus, if this 's top-level ancestor is already the focused . This component must be displayable, focusable, visible and all of its ancestors (with the exception of the top-level Window) must be visible for the request to be granted. Every effort will be made to honor the request; however, in some cases it may be impossible to do so. Developers must never assume that this component is the focus owner until this component receives a FOCUS_GAINED event. Requests that thisget the input focus, if this's top-level ancestor is already the focused. This component must be displayable, focusable, visible and all of its ancestors (with the exception of the top-level Window) must be visible for the request to be granted. Every effort will be made to honor the request; however, in some cases it may be impossible to do so. Developers must never assume that this component is the focus owner until this component receives a FOCUS_GAINED event. This method returns a boolean value. If is returned, the request is guaranteed to fail. If is returned, the request will succeed unless it is vetoed, or an extraordinary event, such as disposal of the component's peer, occurs before the request can be granted by the native windowing system. Again, while a return value of indicates that the request is likely to succeed, developers must never assume that this component is the focus owner until this component receives a FOCUS_GAINED event. This method cannot be used to set the focus owner to no component at all. Use instead. The focus behavior of this method can be implemented uniformly across platforms, and thus developers are strongly encouraged to use this method over when possible. Code which relies on may exhibit different focus behavior on different platforms. Every effort will be made to ensure that s generated as a result of this request will have the specified temporary value. However, because specifying an arbitrary temporary state may not be implementable on all native windowing systems, correct behavior for this method can be guaranteed only for lightweight components. This method is not intended for general use, but exists instead as a hook for lightweight component libraries, such as Swing. Note: Not all focus transfers result from invoking this method. As such, a component may receive focus without this or any of the other methods of being invoked. - true if the focus change is temporary, such as when the window loses the focus; for more information on temporary focus changes see the Focus Specification if the focus change request is guaranteed to fail; if it is likely to succeed\n• Returns the Container which is the focus cycle root of this Component's focus traversal cycle. Each focus traversal cycle has only a single focus cycle root and each Component which is not a Container belongs to only a single focus traversal cycle. Containers which are focus cycle roots belong to two cycles: one rooted at the Container itself, and one rooted at the Container's nearest focus-cycle-root ancestor. For such Containers, this method will return the Container's nearest focus-cycle- root ancestor.\n• Returns whether the specified Container is the focus cycle root of this Component's focus traversal cycle. Each focus traversal cycle has only a single focus cycle root and each Component which is not a Container belongs to only a single focus traversal cycle. - the Container to be tested if the specified Container is a focus-cycle- root of this Component; otherwise\n• Transfers the focus to the next component, as though this Component were the focus owner.\n• Transfers the focus to the previous component, as though this Component were the focus owner.\n• Transfers the focus up one focus traversal cycle. Typically, the focus owner is set to this Component's focus cycle root, and the current focus cycle root is set to the new focus owner's focus cycle root. If, however, this Component's focus cycle root is a Window, then the focus owner is set to the focus cycle root's default Component to focus, and the current focus cycle root is unchanged.\n• Returns if this is the focus owner. This method is obsolete, and has been replaced by . if this is the focus owner; otherwise\n• Returns if this is the focus owner. if this is the focus owner; otherwise\n• Adds the specified popup menu to the component. - the popup menu to be added to the component.\n• Removes the specified popup menu from the component. - the popup menu to be removed\n• Returns a string representing the state of this component. This method is intended to be used only for debugging purposes, and the content and format of the returned string may vary between implementations. The returned string may be empty but may not be .\n• Returns a string representation of this component and its values.\n• Prints a listing of this component to the standard system output stream .\n• Prints a listing of this component to the specified output stream.\n• Prints out a list, starting at the specified indentation, to the specified print stream.\n• Prints a listing to the specified print writer. - the print writer to print to\n• Prints out a list, starting at the specified indentation, to the specified print writer. - the print writer to print to - the number of spaces to indent\n• \n• this Component's name (\"name\") Note that if this is inheriting a bound property, then no event will be fired in response to a change in the inherited property. Adds a PropertyChangeListener to the listener list. The listener is registered for all bound properties of this class, including the following:Note that if thisis inheriting a bound property, then no event will be fired in response to a change in the inherited property. If is , no exception is thrown and no action is performed. - the property change listener to be added\n• Removes a PropertyChangeListener from the listener list. This method should be used to remove PropertyChangeListeners that were registered for all bound properties of this class. If listener is null, no exception is thrown and no action is performed. - the PropertyChangeListener to be removed\n• Returns an array of all the property change listeners registered on this component. all of this component's s or an empty array if no property change listeners are currently registered\n• Note that if this is inheriting a bound property, then no event will be fired in response to a change in the inherited property. Adds a PropertyChangeListener to the listener list for a specific property. The specified property may be user-defined, or one of the following:Note that if thisis inheriting a bound property, then no event will be fired in response to a change in the inherited property. If or is , no exception is thrown and no action is taken. - one of the property names listed above - the property change listener to be added\n• from the listener list for a specific property. This method should be used to remove s that were registered for a specific bound property. Removes afrom the listener list for a specific property. This method should be used to removes that were registered for a specific bound property. If or is , no exception is thrown and no action is taken. - the PropertyChangeListener to be removed\n• Returns an array of all the listeners which have been associated with the named property. all of the s associated with the named property; if no such listeners have been added or if is , an empty array is returned\n• Support for reporting bound property changes for Object properties. This method can be called when a bound property has changed and it will send the appropriate PropertyChangeEvent to any registered PropertyChangeListeners. - the property whose value has changed - the property's new value\n• Support for reporting bound property changes for boolean properties. This method can be called when a bound property has changed and it will send the appropriate PropertyChangeEvent to any registered PropertyChangeListeners. - the property whose value has changed - the property's new value\n• Support for reporting bound property changes for integer properties. This method can be called when a bound property has changed and it will send the appropriate PropertyChangeEvent to any registered PropertyChangeListeners. - the property whose value has changed - the property's new value\n• - the programmatic name of the property that was changed - the old value of the property (as a byte) - the new value of the property (as a byte)\n• - the programmatic name of the property that was changed - the old value of the property (as a char) - the new value of the property (as a char)\n• - the programmatic name of the property that was changed - the old value of the property (as a short) - the old value of the property (as a short)\n• - the programmatic name of the property that was changed - the old value of the property (as a long) - the new value of the property (as a long)\n• - the programmatic name of the property that was changed - the old value of the property (as a float) - the new value of the property (as a float)\n• - the programmatic name of the property that was changed - the old value of the property (as a double) - the new value of the property (as a double)\n• and subclasses will use this property to determine how to lay out and draw components. Sets the language-sensitive orientation that is to be used to order the elements or text within this component. Language-sensitiveandsubclasses will use this property to determine how to lay out and draw components. At construction time, a component's orientation is set to , indicating that it has not been specified explicitly. The UNKNOWN orientation behaves the same as . To set the orientation of a single component, use this method. To set the orientation of an entire component hierarchy, use . This method changes layout-related information, and therefore, invalidates the component hierarchy.\n• Retrieves the language-sensitive orientation that is to be used to order the elements or text within this component. and subclasses that wish to respect orientation should call this method to get the component's orientation before performing layout or drawing.\n• property of this component and all components contained within it. Sets theproperty of this component and all components contained within it. This method changes layout-related information, and therefore, invalidates the component hierarchy. - the new component orientation of this component and the components contained within it.\n• Gets the associated with this . The method implemented by this base class returns null. Classes that extend should implement this method to return the associated with the subclass. the of this"
    },
    {
        "link": "https://web.mit.edu/java_v1.0.2/www/tutorial/ui/overview/components.html",
        "document": ""
    }
]