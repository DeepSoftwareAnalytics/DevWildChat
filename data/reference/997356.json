[
    {
        "link": "https://en.cppreference.com/w/cpp/io",
        "document": "C++ includes the following input/output libraries: an OOP-style stream-based I/O library, print-based family of functions(since C++23), and the standard set of C-style I/O functions.\n\nThe stream-based input/output library is organized around abstract input/output devices. These abstract devices allow the same code to handle input/output to files, memory streams, or custom adaptor devices that perform arbitrary operations (e.g. compression) on the fly.\n\nMost of the classes are templated, so they can be adapted to any basic character type. Separate typedefs are provided for the most common basic character types (char and wchar_t). The classes are organized into the following hierarchy:\n\nThe following typedefs for common character types are provided in namespace :\n\nThe stream-based I/O library uses I/O manipulators (e.g. std::boolalpha, std::hex, etc.) to control how streams behave.\n\nThe following auxiliary types are defined:\n\nThe following typedef names for std::fpos<std::mbstate_t> are provided:\n\nThe Unicode-aware print-family functions that perform formatted I/O on text that is already formatted. They bring all the performance benefits of std::format, are locale-independent by default, reduce global state, avoid allocating a temporary std::string object and calling operator<<, and in general make formatting more efficient compared to iostreams and stdio.\n\nThe following print-like functions are provided:\n\nC++ also includes the input/output functions defined by C, such as std::fopen, std::getc, etc."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/files",
        "document": "std; main () { ofstream myfile ( ); (myfile.is_open()) { myfile << ; myfile << \"This is another line.\n\n\" ; myfile.close(); } cout << ; 0; }\n\n[file example.txt] This is a line. This is another line."
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-c-classes",
        "document": "File handling is used to store data permanently in a computer. Using file handling we can store our data in secondary memory (Hard disk).\n\nHow to achieve the File Handling\n\nFor achieving file handling we need to follow the following steps:-\n\n STEP 1-Naming a file\n\n STEP 2-Opening a file\n\n STEP 3-Writing data into the file\n\n STEP 4-Reading data from the file\n\n STEP 5-Closing a file.\n\nWe give input to the executing program and the execution program gives back the output. The sequence of bytes given as input to the executing program and the sequence of bytes that comes as output from the executing program are called stream. In other words, streams are nothing but the flow of data in a sequence.\n\nThe input and output operation between the executing program and the devices like keyboard and monitor are known as “console I/O operation”. The input and output operation between the executing program and files are known as “disk I/O operation”.\n\nThe I/O system of C++ contains a set of classes which define the file handling methods. These include ifstream, ofstream and fstream classes. These classes are derived from fstream and from the corresponding iostream class. These classes, designed to manage the disk files, are declared in fstream and therefore we must include this file in any program that uses files. File handling is essential for data storage and retrieval in applications.\n• None This class is the base class for other classes in this class hierarchy.\n• None This class contains the necessary facilities that are used by all the other derived classes for input and output operations.\n• None This class is derived from the class ‘ios’.\n• None The extraction operator(>>) is overloaded in this class to handle input streams from files to the program execution.\n• None This class declares input functions such as get(), getline() and read().\n• None This class is derived from the class ‘ios’.\n• None The insertion operator(<<) is overloaded in this class to handle output streams to files from the program execution.\n• None This class declares output functions such as put() and write().\n• None This class contains a pointer which points to the buffer which is used to manage the input and output streams.\n• None This class provides operations common to the file streams. Serves as a base for fstream, ifstream and ofstream class.\n• None This class contains open() and close() function.\n• None It contains open() function with default input mode.\n• None Inherits the functions get(), getline(), read(), seekg() and tellg() functions from the istream.\n• None It contains open() function with default output mode.\n• None Inherits the functions put(), write(), seekp() and tellp() functions from the ostream.\n• None This class provides support for simultaneous input and output operations.\n• None Inherits all the functions from istream and ostream classes through iostream.\n• None Its purpose is to set the file buffers to read and write.\n• None We can also use file buffer member function to determine the length of the file. \n\n\n\nIn C++, files are mainly dealt by using three classes fstream, ifstream, ofstream available in fstream headerfile. \n\nofstream: Stream class to write on files \n\nifstream: Stream class to read from files \n\nfstream: Stream class to both read and write from/to files.\n\nNow the first step to open the particular file for read or write operation. We can open file by \n\n1. passing file name in constructor at the time of object creation \n\n2. using the open method\n\nBoth ios::app and ios::ate take us to the end of the file when it is opened. The difference between the two modes is that ios :: app allow us to add data to the end of the file only, while ios :: ate mode permits us add data or to modify the existing data anywhere in the file.\n\nProblem Statement : To read and write a File in C++. \n\nExamples:\n\nBelow is the implementation by using ifstream & ofstream classes.\n\nBelow is the implementation by using fstream class."
    },
    {
        "link": "https://stackoverflow.com/questions/4099596/performance-of-string-streams-versus-file-i-o-streams-in-c",
        "document": "If you're going to put the data into a stringstream anyway, it's probably a bit faster and easier to copy directly from the input stream to the string stream:\n\nThe will use a buffer, however, so while that's probably faster than reading into a string, then creating a stringstream, it may not be any faster than working directly from the input stream."
    },
    {
        "link": "https://geeksforgeeks.org/basic-input-output-c",
        "document": "In C++, input and output are performed in the form of a sequence of bytes or more commonly known as streams.\n• Input Stream: If the direction of flow of bytes is from the device (for example, Keyboard) to the main memory then this process is called input.\n• Output Stream: If the direction of flow of bytes is opposite, i.e. from main memory to device (display screen) then this process is called output.\n\nAll of these streams are defined inside the <iostream> header file which contains all the standard input and output tools of C++. The two instances cout and cin of iostream class are used very often for printing outputs and taking inputs respectively. These two are the most basic methods of taking input and printing output in C++.\n\nThe C++ cout is the instance of the ostream class used to produce output on the standard output device which is usually the display screen. The data needed to be displayed on the screen is inserted in the standard output stream (cout) using the insertion operator(<<).\n\nFor example, if we want to print text “GeeksforGeeks” on the display, we can use the cout as shown:\n\nExplanation: In the above program, cout is used to output the text “GeeksforGeeks” to the standard output stream. It works in conjunction with the insertion operator (<<) to send the specified data to the output stream.\n\nWe can also print the variable values using cout.\n\nUnderstanding input and output operations is essential for any C++ programmer. The C++ Course includes comprehensive lessons on basic I/O operations, ensuring you can manage user interaction in your programs.\n\nThe C++ cin statement is the instance of the class istream and is used to read input from the standard input device which is usually a keyboard. The extraction operator (>>) is used along with the object cin for extracting the data from the input stream and store it in some variable in the program.\n\nFor example, if we want to ask user for his/her age, then we can use cin as shown:\n\nExplanation: The above program asks the user to input the age. The object cin is connected to the input device (keyboard). The age entered by the user is extracted from cin using the extraction operator(>>) and the extracted data is then stored in the variable age present on the right side of the extraction operator.\n\nAlso, while taking text as input using cin, we need to remember that cin stops reading input as soon as it encounters a whitespace (space, tab, or newline). This means it only captures the first word or characters until the first whitespace. It is shown in the below example:\n\nThe C++ cerr is the standard error stream that is used to output the errors. This is also an instance of the iostream class. As cerr in C++ is un-buffered so it is used when one needs to display the error message immediately. It does not have any buffer to store the error message and display it later.\n\nThe main difference between cerr and cout comes when you would like to redirect output using “cout” that gets redirected to file if you use “cerr” the error doesn’t get stored in file.(This is what un-buffered means ..It cant store the message)\n\nThis is also an instance of ostream class and used to display errors but unlike cerr the error is first inserted into a buffer and is stored in the buffer until it is not fully filled. or the buffer is not explicitly flushed (using flush()). The error message will be displayed on the screen too."
    },
    {
        "link": "https://geeksforgeeks.org/floyd-warshall-algorithm-dp-16",
        "document": "The Floyd Warshall Algorithm is an all-pair shortest path algorithm that uses Dynamic Programming to find the shortest distances between every pair of vertices in a graph, unlike Dijkstra and Bellman-Ford which are single source shortest path algorithms. This algorithm works for both the directed and undirected weighted graphs and can handle graphs with both positive and negative weight edges. \n\n\n\nNote: It does not work for the graphs with negative cycles (where the sum of the edges in a cycle is negative).\n\nSuppose we have a graph graph[][] with V vertices from 0to V-1. Now we have to evaluate a dist[][] where dist[i][j] represents the shortest path between vertex i to j. Let us assume that vertices i to j have intermediate nodes. The idea behind Floyd Warshall algorithm is to treat each and every vertex k from 0 to V-1 as an intermediate node one by one. When we consider the vertex k, we must have considered vertices from 0 to k-1 already. So we use the shortest paths built by previous vertices to build shorter paths with vertex k included. The following figure shows the above optimal substructure property in Floyd Warshall algorithm:\n• None Initialize the solution matrix same as the input graph matrix as a first step.\n• None Then update the solution matrix by considering all vertices as an intermediate vertex.\n• None The idea is to pick all vertices one by one and updates all shortest paths which include the picked vertex as an intermediate vertex in the shortest path.\n• k as an intermediate vertex, we already have considered vertices {0, 1, 2, .. k-1}\n• (i, j) of the source and destination vertices respectively, there are two possible cases.\n• k is not an intermediate vertex in shortest path from i j . We keep the value of dist[i][j] as it is.\n• k is an intermediate vertex in shortest path from i j . We update the value of dist[i][j] dist[i][k] + dist[k][j], dist[i][j] > dist[i][k] + dist[k][j]\n\n// Add all vertices one by one to // Pick all vertices as source one by one // for the above picked source // If vertex k is on the shortest path from // i to j, then update the value of graph[i][j] // Add all vertices one by one to // Pick all vertices as source one by one // for the above picked source // If vertex k is on the shortest path from // i to j, then update the value of graph[i][j] # Add all vertices one by one to # Pick all vertices as source one by one # for the above picked source # If vertex k is on the shortest path from # i to j, then update the value of graph[i][j] // Add all vertices one by one to // Pick all vertices as source one by one // for the above picked source // If vertex k is on the shortest path from // i to j, then update the value of graph[i,j] // Add all vertices one by one to // Pick all vertices as source one by one // for the above picked source // If vertex k is on the shortest path from // i to j, then update the value of graph[i][j]\n\nTime Complexity: O(V3), where V is the number of vertices in the graph and we run three nested loops each of size V.\n\nAuxiliary Space: O(V2), to create a 2-D matrix in order to store the shortest distance for each pair of nodes.\n\nNote: The above program only prints the shortest distances. We can modify the solution to print the shortest paths also by storing the predecessor information in a separate 2D matrix.\n\nThe algorithm relies on the principle of optimal substructure, meaning:\n• None If the shortest path from i to j passes through some vertex k, then the path from i to k and the path from k to j must also be shortest paths.\n• None The iterative approach ensures that by the time vertex k is considered, all shortest paths using only vertices 0 to k-1 have already been computed.\n\nBy the end of the algorithm, all shortest paths are computed optimally because each possible intermediate vertex has been considered.\n\nWhy Floyd-Warshall Algorithm better for Dense Graphs and not for Sparse Graphs?\n\nDense Graph: A graph in which the number of edges are significantly much higher than the number of vertices.\n\nSparse Graph: A graph in which the number of edges are very much low. No matter how many edges are there in the graph the Floyd Warshall Algorithm runs for O(V3) times therefore it is best suited for Dense graphs. In the case of sparse graphs, Johnson’s Algorithm is more suitable.\n• None In computer networking, the algorithm can be used to find the shortest path between all pairs of nodes in a network. This is termed as network routing\n• None Flight Connectivity In the aviation industry to find the shortest path between the airports.\n• GIS Geographic Information Systems ) applications often involve analyzing spatial data, such as road networks, to find the shortest paths between locations.\n• None which is a generalization of floyd warshall, can be used to find regular expression for a regular language.\n• None How to Detect Negative Cycle in a graph using Floyd Warshall Algorithm?\n• None How is Floyd-warshall algorithm different from Dijkstra’s algorithm?\n• None How is Floyd-warshall algorithm different from Bellman-Ford algorithm?\n• None Shortest path with one curved edge in an undirected Graph\n• None 1st to Kth shortest path lengths in given Graph\n• None Number of ways to reach at destination in shortest time"
    },
    {
        "link": "https://geeksforgeeks.org/floyd-warshall-algorithm-cpp",
        "document": "The Floyd-Warshall algorithm is a dynamic programming technique used to find the shortest paths between all pairs of vertices in a weighted graph. This algorithm is particularly useful for graphs with dense connections and can handle both positive and negative edge weights, though it cannot handle negative cycles.\n\nIn this article, we will learn about the Floyd-Warshall algorithm and how to implement it in C++ language.\n\nFloyd-Warshall Algorithm for All-Pairs Shortest Paths in C++\n\nThe works by considering all pairs of vertices and updating the shortest paths iteratively. It uses a matrix to represent the distances between each pair of vertices, initially setting the distance to infinity for all pairs except for the diagonal (distance from a vertex to itself), which is set to zero.\n\nThe algorithm repeatedly updates the shortest distance between two vertices by checking if the distance can be minimized by passing through an intermediate vertex.\n• None Initialize the distance matrix with given edge weights.\n• None Set the distance from each vertex to itself as 0.\n• None For each pair of vertices (i, j), update the distance by considering each vertex k as an intermediate vertex.\n• None If the distance from i to j through k is less than the current distance from i to j, update the distance.\n\nBelow is the algorithm for finding the shortest paths between all pairs of vertices using the Floyd-Warshall algorithm:\n\nConsider the below example of a graph and see how Floyd-Warshall algorithm will generate the minimum spanning tree(MST) for it step-by-step:\n\nC++ Program for Implementation of Floyd-Warshall Algorithm\n\nBelow is a C++ implementation of the Floyd-Warshall algorithm:\n\nTime Complexity: O(V3), where V is the number of vertices in the graph and we run three nested loops each of size V.\n\nAuxiliary Space: O(V2), to create a 2-D matrix in order to store the shortest distance for each pair of nodes.\n• None Floyd-Warshall Algorithm is used in network routing protocols to find the shortest paths between all pairs of nodes.\n• None Can be used to find the transitive closure of a directed graph.\n• None Useful in comparing all possible paths in a weighted graph.\n• None Applied in geographical mapping and urban planning for finding shortest routes."
    },
    {
        "link": "https://programiz.com/dsa/floyd-warshall-algorithm",
        "document": "Floyd-Warshall Algorithm is an algorithm for finding the shortest path between all the pairs of vertices in a weighted graph. This algorithm works for both the directed and undirected weighted graphs. But, it does not work for the graphs with negative cycles (where the sum of the edges in a cycle is negative).\n\nFloyd-Warhshall algorithm is also called as Floyd's algorithm, Roy-Floyd algorithm, Roy-Warshall algorithm, or WFI algorithm.\n\nThis algorithm follows the dynamic programming approach to find the shortest paths.\n\nLet the given graph be:\n\nFollow the steps below to find the shortest path between all the pairs of vertices.\n• Create a matrix of dimension where n is the number of vertices. The row and the column are indexed as and respectively. and are the vertices of the graph.\n\n \n\n Each cell is filled with the distance from the vertex to the vertex. If there is no path from vertex to vertex, the cell is left as infinity. Fill each cell with the distance between ith and jth vertex\n• Now, create a matrix using matrix . The elements in the first column and the first row are left as they are. The remaining cells are filled in the following way.\n\n \n\n Let be the intermediate vertex in the shortest path from source to destination. In this step, is the first vertex. is filled with .\n\n \n\n That is, if the direct distance from the source to the destination is greater than the path through the vertex , then the cell is filled with .\n\n \n\n In this step, k is vertex 1. We calculate the distance from source vertex to destination vertex through this vertex k. Calculate the distance from the source vertex to destination vertex through this vertex k \n\n For example: For , the direct distance from vertex 2 to 4 is 4 and the sum of the distance from vertex 2 to 4 through vertex (ie. from vertex 2 to 1 and from vertex 1 to 4) is 7. Since , is filled with 4.\n• Similarly, is created using . The elements in the second column and the second row are left as they are.\n\n \n\n In this step, is the second vertex (i.e. vertex 2). The remaining steps are the same as in step 2. Calculate the distance from the source vertex to destination vertex through this vertex 2\n• Similarly, and is also created. Calculate the distance from the source vertex to destination vertex through this vertex 3 Calculate the distance from the source vertex to destination vertex through this vertex 4\n• gives the shortest path between each pair of vertices.\n\nThere are three loops. Each loop has constant complexities. So, the time complexity of the Floyd-Warshall algorithm is .\n\nThe space complexity of the Floyd-Warshall algorithm is .\n• To find the shortest path is a directed graph\n• To find the transitive closure of directed graphs\n• To find the Inversion of real matrices\n• For testing whether an undirected graph is bipartite"
    },
    {
        "link": "https://stackoverflow.com/questions/43478943/floyds-shortest-path-algorithm-c",
        "document": "So if there are long shortest paths from vertex i to j, then path[i][j] should equal a k value connected to i but instead its a k value connected to j and I cannot figure out why.\n\nUnfortunately no to both. There is nothing in your implementation that guarantees that should equal a value that comes immediately after , and your observation that is currently a value that comes immediately before is also incorrect. (Please try a few more samples to verify the second point.)\n\nThe only thing that is guaranteed by your implementation is that the vertex lies somewhere in the shortest path from vertex to vertex .\n\nThus you can retrieve the path recursively by doing:\n\nHaving clarified that, there does exist a method where you can store such that it is the vertex that comes immediately after ."
    },
    {
        "link": "https://stackoverflow.com/questions/34110552/floyd-warshall-algorithm",
        "document": "The only problem I see with the current code is ::\n\nSo, just in case or is infinity, then if you try adding something to it, then it is an integer overflow, and the value would be undefined (mostly negative!) which would lead to modifying the value of !\n\nTo prevent this, you just need to add an condition, something like this::\n\nThis will make it work, I believe!"
    }
]