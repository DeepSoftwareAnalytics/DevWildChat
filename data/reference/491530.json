[
    {
        "link": "https://stackoverflow.com/questions/49036167/crash-when-calling-c-function-from-c",
        "document": "I have a C++ library function which I am calling from a C function. The call passes in a C data-structure that is accessed by the C++ code. My program crashes in the C++ code when accessing the C data-structure. I've followed all the instructions in C++ faq related to mixing C-to-C++.\n\nThe crash happens on a centos7 machine. Running the same code in debug mode does not result in a crash. The same code running on Ubuntu (16.04) does not result in a crash. Here's the GDB analysis of the crash.\n\nAs soon as the execution enters the C++ code, the C data structure shows address out of bounds. Here's is the glue code for c-to-c++ functions.\n\nI would appreciate it if someone can shed some light on this. Are there any compiler options I need to use when mixing C and C++ code so that the C++ code can access the C data-structure properly? Here's the OS and compiler info:\n\nNot sure if it matters but I am running my app in a docker container on both OSes."
    },
    {
        "link": "https://stackoverflow.com/questions/25051679/c-program-crashes-when-linked-to-two-3rd-party-shared-libraries",
        "document": "I have two outsourced shared libraries for linux platform (no source, no document). The libraries work fine when they are linked to program separately (g++ xx.cpp lib1.so, or g++ xx.cpp lib2.so).\n\nHowever, when any c++ program is linked to these two shared libraries at the same time, the program inevitably crashes with \"double free\" error (g++ xx.cpp lib1.so lib2.so).\n\nEven if the c++ program is an empty hello world program and has nothing to do with these libraries, it still crashes.\n\nI got some clue that these lib1.so lib2.so libraries might share some common global variable and they destroy some variable twice. I have tried gdb and valgrind, but cannot extract useful information from backtrace.\n\nIs there any way that I could possibly isolate these two shared libraries and make them work in a sandbox manner?\n\nI just linked the aforementioned toy empty helloword program with the two libraries (platform: centos 7.0 64bits with gcc4.8.2):\n\nThanks for @RaduChivu 's help, I found a very similar scenario: segmentation fault at __tcf_0 when program exits , looks like indeed there is a global variable collision between the two libraries. Considering I do not have the source files for these two external shared libraries, except for using two separate processes, is there any other way that I can resolve this conflict?"
    },
    {
        "link": "https://community.nxp.com/t5/MCUXpresso-General/Static-Libraries-losing-capability-to-handle-exceptions/td-p/1297131",
        "document": "Hello! I'm currently having some issues with static libraries and exceptions.\n\n\n\nI'm currently running a static library (consisting of \"general\" code not specific to the current project I'm working on) in conjunction with a standard project. The static library has exception handling internal to it, but as of right now no exception handling occurs over the library-project line. Unfortunately, it appears that the static library is unable to process any exceptions - not even those it generates itself - causing any exception within the static library to crash the program.\n\n\n\nI've constructed a MWE in the following manner:\n\n\n\n\n\n1) Created a C++ Project and a C++ Static Library project, using the SDK wizard. I'm using the MIMXRT1060-EVK, but I don't think this is board specific.\n\n2) Enable exception handling in both the Project and Static Library (by changing -fno-exception to -fexception)\n\n\n\n3) Include the following code in the static library\n\n5) In the project, add the directory featuring library_example.hpp into the compiler include paths. Also add the directory featuring the library executable.\n\n6) Add the directory featuring the library executable to the library search path in the linker. Also add the library name to the libraries list in the linker settings. (See attachment)\n\n7) Include the following code in the project\n\nCompile. Put a breakpoint at is_caught++ and run. The expected behavior is that the thrown exception is caught, is_caught is incremented (just before it leaves scope) and then the program spins in place. However, instead, the program crashes on the throw and the catch section never sees the light of day.\n\n\n\nMy research so far have led me to some SE discussions saying that even exceptions across the boundary should be acceptable, never mind this situation where the exception handling is done in the same library. This had some promise that I was missing a -shared-libgcc, but to no avail. There's also this bit in the GCC documentation, but that seems to deal with handling an external exception, not this situation. The only problems I can think of is that I'm missing some obvious linking step that's crucial, but my research hasn't been able to find it and I'm about to drive myself insane. What's the obvious step I'm missing here?"
    },
    {
        "link": "https://github.com/fish-shell/fish-shell/issues/5289",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://arduino.stackexchange.com/questions/93609/program-crashes-when-calling-external-library-code-via-function-pointer",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/140061/when-to-use-dynamic-vs-static-libraries",
        "document": "When creating a class library in C++, you can choose between dynamic ( .dll , .so ) and static ( .lib , .a ) libraries. What is the difference between them and when is it appropriate to use which?\n\nStatic libraries increase the size of the code in your binary. They're always loaded and whatever version of the code you compiled with is the version of the code that will run. Dynamic libraries are stored and versioned separately. It's possible for a version of the dynamic library to be loaded that wasn't the original one that shipped with your code if the update is considered binary compatible with the original version. Additionally dynamic libraries aren't necessarily loaded -- they're usually loaded when first called -- and can be shared among components that use the same library (multiple data loads, one code load). Dynamic libraries were considered to be the better approach most of the time, but originally they had a major flaw (google DLL hell), which has all but been eliminated by more recent Windows OSes (Windows XP in particular).\n\nOthers have adequately explained what a static library is, but I'd like to point out some of the caveats of using static libraries, at least on Windows:\n• None Singletons: If something needs to be global/static and unique, be very careful about putting it in a static library. If multiple DLLs are linked against that static library they will each get their own copy of the singleton. However, if your application is a single EXE with no custom DLLs, this may not be a problem.\n• None Unreferenced code removal: When you link against a static library, only the parts of the static library that are referenced by your DLL/EXE will get linked into your DLL/EXE. For example, if contains and and your DLL/EXE only references functions or variables from , the entirety of will get discarded by the linker. If contains global/static objects, their constructors and destructors will not get executed. If those constructors/destructors have side effects, you may be disappointed by their absence. Likewise, if the static library contains special entrypoints you may need to take care that they are actually included. An example of this in embedded programming (okay, not Windows) would be an interrupt handler that is marked as being at a specific address. You also need to mark the interrupt handler as an entrypoint to make sure it doesn't get discarded. Another consequence of this is that a static library may contain object files that are completely unusable due to unresolved references, but it won't cause a linker error until you reference a function or variable from those object files. This may happen long after the library is written.\n• None Debug symbols: You may want a separate PDB for each static library, or you may want the debug symbols to be placed in the object files so that they get rolled into the PDB for the DLL/EXE. The Visual C++ documentation explains the necessary options.\n• None RTTI: You may end up with multiple objects for the same class if you link a single static library into multiple DLLs. If your program assumes that is \"singleton\" data and uses or , you may get undesirable and surprising results.\n\nA lib is a unit of code that is bundled within your application executable. A dll is a standalone unit of executable code. It is loaded in the process only when a call is made into that code. A dll can be used by multiple applications and loaded in multiple processes, while still having only one copy of the code on the hard drive. Dll pros: can be used to reuse/share code between several products; load in the process memory on demand and can be unloaded when not needed; can be upgraded independently of the rest of the program. Dll cons: performance impact of the dll loading and code rebasing; versioning problems (\"dll hell\") Lib pros: no performance impact as code is always loaded in the process and is not rebased; no versioning problems. Lib cons: executable/process \"bloat\" - all the code is in your executable and is loaded upon process start; no reuse/sharing - each product has its own copy of the code.\n\nYou should think carefully about changes over time, versioning, stability, compatibility, etc. If there are two apps that use the shared code, do you want to force those apps to change together, in case they need to be compatible with each other? Then use the dll. All the exe's will be using the same code. Or do you want to isolate them from each other, so that you can change one and be confident you haven't broken the other. Then use the static lib. DLL hell is when you probably SHOULD HAVE used a static lib, but you used a dll instead, and not all the exes are comaptible with it."
    },
    {
        "link": "https://notsocomplex.medium.com/optimizing-program-performance-a-comprehensive-guide-to-libraries-in-c-static-and-dynamic-linking-2eb4f1eb624f",
        "document": "In the realm of C programming, libraries are the unsung heroes that simplify development, enhance code reusability, and fine-tune program performance. This guide is designed to cater to the needs of programmers across all levels, whether you’re just beginning your coding journey or you’re a seasoned pro. Together, we’ll delve into the intricacies of static and dynamic linking in C and how to harness their full potential for robust and efficient software development.\n\nLibraries in C are treasure troves of pre-compiled functions and procedures that provide a library of commonly used functionalities. They are the pillars that support efficient development by enabling programmers to reuse tested and proven code. These libraries can be broadly categorized into two main types: Standard Libraries and User Libraries.\n\n- C Standard Library: This is the core library that comes bundled with the C programming language. It houses a treasure trove of functions and macros that are an integral part of the C language specification. Some notable standard libraries in C include:\n\n — stdio.h: Packed with functions for input and output, such as `printf` and `scanf`.\n\n —stdlib.h: A repository of functions for memory allocation and deallocation, including `malloc` and `free`.\n\n — string.h: Home to functions for string manipulation, like `strcpy` and `strlen`.\n\n — math.h: A hub for mathematical functions, including `sin`, `cos`, and `sqrt`.\n\n — time.h: The go-to place for functions related to date and time, such as `time` and `ctime`.\n\n- User libraries are the brainchildren of programmers who encapsulate and reuse their own code. These libraries are often tailored to specific projects or a set of related projects and go by various names, including “header files” and “source files.”\n\n — Header files (e.g., `.h` files) are repositories of function prototypes, macro definitions, and type definitions, allowing different parts of a program to utilize functions and data structures stored within the library.\n\n — Source files (e.g., `.c` files) are the beating heart of a library, housing the actual implementation of functions and data structures outlined in the header files.\n\nMastering the Art of Working with Libraries\n\nRegardless of whether you’re a newcomer to coding or a seasoned programmer, understanding how to navigate the world of libraries in C is essential. Here’s a condensed roadmap to get you started:\n\n1. Including Header Files: To utilize a library, it’s common practice to include the associated header file in your source code, usually by means of the `#include` preprocessor directive. For instance, to leverage functions from the standard input/output library, you’d include `<stdio.h>`.\n\n2. Linking Libraries: In C, functions from libraries must be linked to your program during the compilation process. The specific linking method depends on your compiler of choice. For instance, with the GCC compiler, you might employ the `-l` flag to specify a library, such as `-lm` for the math library.\n\n3. Compilation and Execution: After integrating the necessary header files and linking the libraries, you compile your code using a C compiler (e.g., `gcc`) and subsequently execute the generated program.\n\nLet’s illustrate this process with a basic example of using a library in C, focusing on the Standard Library:\n\nIn this example, we incorporate the `<stdio.h>` header file to access the `printf` function for output.\n\nLibraries serve as the backbone of C programming, and grasping the intricacies of working with them can enhance your coding efficiency and minimize redundancy. Let’s delve further into the world of libraries in C.\n\nThe Two Faces of Libraries: Static and Dynamic\n\nIn the vast universe of C programming, libraries come in two distinctive flavors: Static Libraries and Dynamic Libraries. Let’s start by dissecting Static Libraries.\n\nA Static Library is essentially a compendium of object files bundled together within a single file. These object files contain pre-compiled code for functions and procedures, essentially a treasure trove of building blocks for your programs. Creating a Static Library is akin to packaging a collection of functions and data that can be seamlessly integrated into your C program at compile time. This results in a self-contained and efficient executable.\n• Single File Repository: Static libraries are typically housed within a single file, often carrying a “.a” extension in Unix-based systems (e.g., “libmylibrary.a”) or “.lib” extension in Windows (e.g., “mylibrary.lib”).\n\n2. Pre-Compiled Code: They contain pre-compiled code in the form of object files, which can be generated from source code files (e.g., “.c” files) using a compiler.\n\n3. Compile-Time Linking: The magic of a Static Library lies in its ability to link with your program at compile time. In simple terms, the library’s code becomes an integral part of the final executable.\n\n1. Self-Contained Executables: When you compile your program with a Static Library, you’re crafting a self-contained executable. This means your program doesn’t rely on external library files, ensuring smooth execution on various systems without concerns about library compatibility.\n\n2. Performance Boost: Static libraries can contribute to faster execution times because the necessary code is already incorporated into the executable. This reduces the need for dynamic linking at runtime.\n\nTo forge your own Static Library, you’ll embark on the following steps:\n\nfiles. For instance, if you have source files like `file1.c` and `file2.c`, you can utilize these commands:\n\n2. Craft the Static Library using the `ar` (archive) command, as follows:\n\nThis command bundles the object files into a Static Library named `mylibrary.a`.\n\nTo make use of a Static Library in your C program, observe these steps:\n\n1. Integrate the library’s header files into your source code, generally through the `#include` directive.\n\n2. Link your program with the Static Library using the `-l` flag during compilation. For instance:\n\nIn the command above, `-L` specifies the directory where the library resides, and `-l` designates the library to link with. This will compile `myprogram.c` and link it with the `mylibrary` Static Library.\n\nStatic Libraries are a formidable tool for packaging and distributing code designed to be linked into programs at compile time. They provide control over program dependencies and enhance the portability of your C projects.\n\nThe Need for Indexing: Enhancing Speed\n\nIn the world of C programming, indexing a Static Library can be a game-changer, potentially enhancing the speed of linking. But why does this happen?\n\n1. Faster Symbol Lookup: An index in a Static Library houses a meticulously organized list of symbols (functions, variables, etc.) and their corresponding locations within the library. When you link your program with an indexed library, the linker can swiftly locate and access the symbols it requires. Without an index, the linker might need to scour the entire library to discover the symbols, a process that can be notably slower for large libraries.\n\n2. Reduced Disk I/O: When linking a program, the linker must read the object files within the library to resolve symbols. With an index in place, it can pinpoint and read only the object files it needs. Without an index, the linker might end up reading all the object files, resulting in additional disk I/O operations and slower linking.\n\n3. Optimized Memory Usage: Indexing can also assist in judiciously managing memory during the linking process. The linker can allocate memory for resolved symbols more efficiently, leading to reduced memory consumption and potentially quicker execution.\n\nThe effect of indexing on the speed of linking is contingent on various factors, including the size and complexity of the library and the system resources at your disposal. For smaller libraries or projects, the difference in linking speed may be negligible. However, for extensive and intricate projects with sizeable libraries, indexing can yield significant advantages.\n• Indexing During Creation: You can opt to create a Static Library with an index right from the start using the “ar rcs” command. This command seamlessly combines the library’s creation with the incorporation of an index (symbol table). For instance:\n\n2. Indexing After Creation: In scenarios where you have an existing Static Library that lacks an index or when you wish to update the index of an already existing library, the “ranlib” command comes to your aid. “ranlib” efficiently generates or refreshes the index without affecting the library itself. For instance:\n\nBoth approaches yield the same end result: a library endowed with an index for expedited symbol lookup during the linking process.\n\nIn the world of C programming, libraries are the secret ingredients that enable efficient code reuse and performance optimization. As you explore static and dynamic linking, you’ll discover the keys to crafting more efficient, self-contained, and responsive C programs. Whether you’re embarking on your coding journey or you’re a seasoned pro, the power of libraries in C can revolutionize your approach to software development. Unlock the potential, optimize your code, and embark on a programming journey that’s both efficient and exhilarating."
    },
    {
        "link": "https://stackoverflow.com/questions/2649334/difference-between-static-and-shared-libraries",
        "document": "Shared libraries are .so (or in Windows .dll, or in OS X .dylib) files. All the code relating to the library is in this file, and it is referenced by programs using it at run-time. A program using a shared library only makes reference to the code that it uses in the shared library.\n\nStatic libraries are .a (or in Windows .lib) files. All the code relating to the library is in this file, and it is directly linked into the program at compile time. A program using a static library takes copies of the code that it uses from the static library and makes it part of the program. [Windows also has .lib files which are used to reference .dll files, but they act the same way as the first one].\n\nThere are advantages and disadvantages in each method:\n• None Shared libraries reduce the amount of code that is duplicated in each program that makes use of the library, keeping the binaries small. It also allows you to replace the shared object with one that is functionally equivalent, but may have added performance benefits without needing to recompile the program that makes use of it. Shared libraries will, however have a small additional cost for the execution of the functions as well as a run-time loading cost as all the symbols in the library need to be connected to the things they use. Additionally, shared libraries can be loaded into an application at run-time, which is the general mechanism for implementing binary plug-in systems.\n• None Static libraries increase the overall size of the binary, but it means that you don't need to carry along a copy of the library that is being used. As the code is connected at compile time there are not any additional run-time loading costs. The code is simply there.\n\nPersonally, I prefer shared libraries, but use static libraries when needing to ensure that the binary does not have many external dependencies that may be difficult to meet, such as specific versions of the C++ standard library or specific versions of the Boost C++ library."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/385127/is-it-good-practice-to-statically-link-libstdc-and-or-libgcc-when-creating-dis",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://begriffs.com/posts/2021-07-04-shared-libraries.html",
        "document": "In this article we’ll learn how to build shared libraries and install them properly on several platforms. For guidance, we’ll examine the goals and history of dynamic linking on UNIX-based operating systems.\n\nContent for the article comes from researching how to create a shared library, wading through sloppy conventions that people recommend online, and testing on multiple Unix-like systems. Hopefully it can set the record straight and help improve the quality of open source libraries.\n• Variance of linker and loader by system\n\nThe design typically used nowadays for dynamic linking (in BSD, MacOS, and Linux) came from SunOS in 1988. The paper Shared Libraries in SunOS neatly explains the goals, design, and implementation.\n\nThe authors’ main motivations were saving disk and memory space, and upgrading libraries (or the OS) without needing to relink programs. The resource usage motivation is probably less important on today’s powerful personal computers than it was in 1988. However, the flexibility to upgrade libraries is as useful as ever, as well as the ability to easily inspect which library versions each application uses.\n\nDynamic linking is not without its critics, and isn’t appropriate in all situations. It runs a little slower because of position-independent code (PIC) and late loading. (The SunOS paper called it a “classic space/time trade-off.”) The complexity of the loader on some systems offers increased attack surface. Finally, upgraded libraries may affect some programs differently than others, for instance breaking those that rely on undocumented behavior.\n\nAt compile time the link editor resolves symbols in specified libraries, and makes a note in the resulting binary to load those libraries. At runtime, applications call code to map the shared library symbols in memory at the correct memory addresses.\n\nSunOS and subsequent UNIX-like systems added compile-time flags to the linker (ld) to generate – or link against – dynamically linked libraries. The designers also added a special system library (ld.so) with code to find and load other libraries for an application. The pre- initialization routine of a program loads ld.so and runs it from within the program to find and load the rest of the required libraries.\n\nAs mentioned, applications can take advantage of updated libraries without needing recompilation. Library updates can be classified in three categories:\n• New features, additions to the interface. (Minor release)\n• Backward-incompatible change to the interface or its operation. (Major release)\n\nAn application linked against a library at a given major release will continue to work properly when loading any newer minor or patch release. Applications may not work properly when loading a different major release, or an earlier minor release than that used at link time.\n\nMultiple applications can exist on a machine at once, and each may require different releases of a single library. The system should provide a way to store multiple library releases and load the right one for each app. Different systems have different ways to do it, as we’ll see later.\n\nEach library release can be marked with a version identifier (or “version”) which seeks to capture information about the library’s release history. There are multiple ways to map release history to a version identifier.\n\nThe two most common mapping systems are semantic versioning and libtool versioning. Semantic versioning counts the number of releases of various kinds that have happened, and writes them in lexicographic order. Libtool versioning counts distinct library interfaces.\n\nSemantic versioning is written as and libtool as . The intuition is that counts interface changes. Any time the interface changes, whether in a minor or major way, increases. Here’s how each system would record the same history of release events:\n\nHere’s how applications answer the question, “Can I load a given library?”\n\nWe’ll be using semantic versioning in this guide, because libtool versioning is only relevant to libtool, a tool to abstract library creation across platforms. I believe we can make portable libraries without libtool. I mention both systems only to show that there’s more than one way to build version identifiers.\n\nOne final note: version identifiers say that things have changed, but omit what changed. More complicated systems exist to track library compatibility. Solaris, for instance, developed a system called symbol versioning. Symbol versioning chases space savings at the expense of operational complexity, and we’ll consider it later.\n\nOne subtlety of versioning is that changes can happen in either a library’s programming interface (API) or binary interface (ABI). A C library’s programming interface is defined through its header files. A backward-incompatible API change means a program written for the previous version would not compile when including headers from the new version.\n\nBy contrast, a binary interface is a runtime concept. It concerns the calling conventions for functions, or the memory layout (and meaning) of data shared between program and library. The ABI ensures compatibility at load and run-time, while the API ensures compatibility at compile and link time.\n\nThe two interfaces usually change hand-in-hand, and people sometimes confuse them. It’s possible for one to change without the other, though.\n\nIn these library changes, application code doesn’t need to change, but does need to be recompiled with the new library headers in order to work at runtime.\n• A changed numerical value behind a #define constant. A program compiled before the change would pass the wrong value to the library.\n• Reordered elements in a struct. The program and library would read different offsets in memory thinking they’re referring to the same element, which is definitely an ABI break. Even adding an element after the others would affect the structure’s size, and hence layout within an array. An added field at the end may or may not affect a particular library’s ABI.\n• Widening function arguments. For instance changing a short int argument to a long int on an architecture/compiler where their size differs. Recompilation would be necessary to handle e.g. sign extension, or the offset of the next argument.\n• Other languages, including C++, have more opportunities for surprise ABI breakage.\n\nIn these library changes, application code would need to be modified to compile successfully against the new library, even though code compiled before the change could load and call the library without issue.\n• Changing an argument from to . A pointer to a const object cannot be implicitly converted to a pointer to a non-const object. The ABI doesn’t care though, and moves the same bytes. (If the library does in fact modify the dereferenced value, it may be an unpleasant surprise to the application of course.)\n• Changing the name of a struct element, while keeping its meaning and leaving it in the same position relative to the other elements.\n\nIt’s usually easy to tell when you’ve added functionality vs broken backward compatibility, but there are tools to check for sure. For instance, the ABI Compliance Checker can detect breakages in C and C++ libraries.\n\nIn light of the versioning discussion earlier, which changes should the version identifier describe? At the very least, the ABI. When the loader is searching for a library, the ABI determines whether a library would be compatible at runtime. However, I think a more conservative versioning scheme is wise, where you bump a version when either the API or ABI change. You’ll end up with potentially more library versions installed, but each shared API/ABI version will provide guarantees at both compilation and runtime.\n\nVariance of linker and loader by system\n\nAfter compiling object files, the compiler front-end (gcc, clang, cc, c99) will invoke the linker (ld, lld) to find unresolved symbols and match them across object files or in shared libraries. The linker searches only the shared libraries requested by the front-end, in the order specified on the command line. If an unresolved symbol is found in a listed library, the linker marks a dependency on that library in the generated executable.\n\nThe option adds a library to the list of candidates for symbol search. To add (or on Mac), specify . The linker looks for the library files in its search path. To add directories to the default search path(s), use , for instance .\n\nWhat happens if multiple versions of a library exist in the same directory? For instance two major versions, and ? OpenBSD knows about version numbers, and would pick the highest version automatically for . Linux and Mac would match neither, because they’re looking for an exact match of (or ). Similarly, what if both a static and dynamic library exist in the same directory, and ? All systems will choose the dynamic one.\n\nGreater control is necessary. GCC has a colon option to solve the problem, for instance . However clang doesn’t have it, so a truly portable build shouldn’t rely on it. Some systems solve the problem by creating a symlink from to the specific library desired. However when done in a system location like , it nominates a single inflexible link-time version for the whole system. I’ll suggest a different solution later that involves storing link-time files in a separate place from load-time libraries.\n\nAt launch time, programs with dynamic library dependencies load and run ld.so (or dyld on Mac) to find and load the rest of their dependencies. The load library inspects DT_NEEDED ELF tags (or LOAD_DYLIB names in Mach-O on Mac) to determine which library filename to find on the system. Interestingly, these values are not specified by the program developer, but by the library developer. They are extracted from the libraries themselves at link-time.\n\nDynamic libraries contain an internal “runtime name” called SONAME in ELF, or install_name in Mach-O. An application may link against a file named , but the library SONAME can say, “search for me under the filename libfoo.so.1.2 at load time.” The loader cares only about filenames, it never consults SONAMES. Conversely, the linker’s output cares only about SONAMES, not input library filenames.\n\nLoaders in different operating systems go about finding dependent libraries slightly differently. OpenBSD’s ld.so is very true to the SunOS model, and understands semantic versions. For instance, if asked to load libfoo.so.1.2, it will attempt to find libfoo.so.1.x with the largest x ≥ 2. FreeBSD also claims to have this behavior, but I didn’t observe it in my tests.\n\nIn 1995, Solaris 2.5 created a way to track semantic versioning at the symbol level, rather than for the entire library. With symbol versioning there would be a single e.g. libfoo.so file that simply grows over time. Every function inside is marked with a version number. The same function name can even exist under multiple versions with different implementations.\n\nThe advantage of symbol versioning is that it can save space. In the alternative, where versioning is per-library rather than per-symbol, a large percentage of object code is often copied unchanged from one library version to the next. The disadvantages of symbol versioning are:\n• It’s harder to see exactly which versions are installed on a system. Versions are hidden within libraries, rather than visible in filenames.\n• Library developers have to maintain a separate symbol mapfile for the linker.\n\nSymbol versioning quickly found its way into Linux, and became a staple of Glibc. Because of Linux’s symbol versioning preference, its ld.so doesn’t make any effort to rendezvous with the latest minor library version (à la SunOS or OpenBSD). Ld.so searches for an exact match between SONAME and filename.\n\nHowever, even on Linux, most libraries don’t use symbol versioning. Also, their SONAMEs typically record only a major version (like libfoo.so.2). Within that major version, you just have to hope the hidden minor version is new enough for all applications compiled or installed on the system. If an app relies on functions added in a later minor library version, it’ll crash when it attempts to call them. (Setting the environment variable will attempt to resolve all symbols at program start instead, to detect the failure up front.)\n\nMacOS uses an entirely different object format (Mach-O rather than ELF), and a differently named loader library (dyld rather than ld.so). Mac’s dynamically linked libraries are named , and their version numbers precede the extension.\n\nNative Mac applications are usually installed into their own dedicated directories, with libraries bundled inside. Thus the loader has special provisions for finding libraries, like the keywords , and in the . MacOS supports system libraries too, with dyld consulting the , by default .\n\nLike Linux, Mac does an exact name match – no minor version rendezvous. Unlike Linux, libraries can record their full semantic version internally, and a “compatibility” version. The compatibility version gets copied into an application at link time, and says the application requires at least that version at runtime.\n\nFor example, with full version 1.2.3 should have a compatibility version of 1.2.0 according to the rules of semantic versioning. An application linked against it would refuse to load libfoo with lesser minor version, like 1.1.5. At load time, the user would see a clear error:\n\nStandard practice is to create symlinks libfoo.so -> libfoo.so.x -> libfoo.so.x.y.z in a shared system directory. The first link (without the version number) is for linking at build time. Problem is, it’s pinned to one version. There’s no portable way to select which version to link against when there are multiple versions installed.\n\nAlso, standard practice gives even less care to versioning header files. Sometimes whichever version was most recently installed overwrites them in /usr/local/include. Sometimes the headers are maintained only at the major version level, in /usr/local/include/libfoo-n.\n\nTo solve these problems, I suggest bundling all development (linking) library files together into a different directory structure per version. Since I advocated earlier that the “total” library version should be bumped whenever the API or ABI changes, the same version safely applies to headers and binaries.\n\nFirst choose an installation PREFIX. If the system has an /opt directory, pick that, otherwise /usr/local. In this directory, add dynamic and/or static libraries, headers, man pages, and pkg-config files as desired:\n\nLinking against libfoo.x.y.z is easy. In a Makefile, set your flags like this:\n\nPkg-config can allow an application to express a range of acceptable library versions, rather than hardcoding a specific one. In a configure script, we’ll test for the library’s presence and version, and output the flags to :\n\nThen our Makefile becomes:\n\nTo choose a specific version of libfoo, we can add it to the pkg-config search path and run the configure script:\n\nTo create pkg-config files for a library, see Dan Nicholson’s guide. In order to offer both a static and dynamic library, the best way I could imagine was to release separate files, and that differ in their flag. One uses and another . (Pkg-config’s flag is a bit of a misnomer, and just passes items in in addition to in the build process.)\n\nThis section talks about installing dynamic libraries for system-wide loading. Libraries installed for this purpose are not meant to link with at compile time, but to load at runtime.\n\nELF objects don’t have much version metadata. SONAME is about it. That, combined with the lackluster behavior of loaders on some systems, means the traditional installation technique doesn’t work too well.\n\nLet’s review the traditional way to install ELF libraries, and then a safer method I designed.\n\nThis way allows a sysadmin to see exactly which versions are installed, and to have multiple major versions installed at once. It doesn’t allow multiple minor versions per major (although usually only the latest minor is needed), and more importantly doesn’t offer protection against loading too old a minor version.\n\nAt the cost of potentially a lot of minor version symlinks, this technique emulates the SunOS and OpenBSD behavior of minor version rendezvous. Also, because the SONAME has major.minor granularity, it will protect against loading too old a minor version.\n\nMach-O has more version metadata inside than ELF, so a traditional install works fine here.\n\nIt’s important to set the compatibility version correctly so that Mac’s dyld will prevent loading too old a minor version. To upgrade the library, overwrite libfoo.x.dylib with one of a later internal minor release.\n\nFor an example of how to build a library portably, and install it conveniently for the linker and loader, see begriffs/libderp. It’s my first shared library, where I tested the ideas for this article."
    }
]