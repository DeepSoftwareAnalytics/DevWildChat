[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions",
        "document": "Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it. See also the exhaustive reference chapter about JavaScript functions to get to know the details.\n\nA function definition (also called a function declaration, or function statement) consists of the keyword, followed by:\n• The name of the function.\n• A list of parameters to the function, enclosed in parentheses and separated by commas.\n• The JavaScript statements that define the function, enclosed in curly braces, . For example, the following code defines a function named : The function takes one parameter, called . The function consists of one statement that says to return the parameter of the function (that is, ) multiplied by itself. The statement specifies the value returned by the function, which is . Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function. When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example: When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example: Function declarations and expressions can be nested, which forms a scope chain. For example: See function scopes and closures for more information.\n\nWhile the function declaration above is syntactically a statement, functions can also be created by a function expression. Such a function can be anonymous; it does not have to have a name. For example, the function could have been defined as: However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces: Function expressions are convenient when passing a function as an argument to another function. The following example defines a function that should receive a function as first argument and an array as second argument. Then, it is called with a function defined by a function expression: function map(f, a) { const result = new Array(a.length); for (let i = 0; i < a.length; i++) { result[i] = f(a[i]); } return result; } const numbers = [0, 1, 2, 5, 10]; const cubedNumbers = map(function (x) { return x * x * x; }, numbers); console.log(cubedNumbers); // [0, 1, 8, 125, 1000] In JavaScript, a function can be defined based on a condition. For example, the following function definition defines only if equals : In addition to defining functions as described here, you can also use the constructor to create functions from a string at runtime, much like . A method is a function that is a property of an object. Read more about objects and methods in Working with objects.\n\nDefining a function does not execute it. Defining it names the function and specifies what to do when the function is called. Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function , you could call it as follows: The preceding statement calls the function with an argument of . The function executes its statements and returns the value . Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level). The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The function (defined in Working with objects) is an example of a function that takes an object as an argument. A function can call itself. For example, here is a function that computes factorials recursively: You could then compute the factorials of through as follows: There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime. It turns out that functions are themselves objects — and in turn, these objects have methods. (See the object.) The and methods can be used to achieve this goal.\n\nA function can refer to and call itself. It can be referred to either by the function expression or declaration's name, or via any in-scope variable that refers to the function object. For example, consider the following function definition: Within the function body, you can refer to the function itself either as or , and call itself using or . A function that calls itself is called a recursive function. In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case). For example, consider the following loop: let x = 0; // \"x < 10\" is the loop condition while (x < 10) { // do stuff x++; } It can be converted into a recursive function declaration, followed by a call to that function: function loop(x) { // \"x >= 10\" is the exit condition (equivalent to \"!(x < 10)\") if (x >= 10) { return; } // do stuff loop(x + 1); // the recursive call } loop(0); However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM) is easier via recursion: function walkTree(node) { if (node === null) { return; } // do something with node for (let i = 0; i < node.childNodes.length; i++) { walkTree(node.childNodes[i]); } } Compared to the function , each recursive call itself makes many recursive calls here. It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack. In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:\n\nWe also refer to the function body as a closure. A closure is any piece of source code (most commonly, a function) that refers to some variables, and the closure \"remembers\" these variables even when the scope in which these variables were declared has exited. Closures are usually illustrated with nested functions to show that they remember variables beyond the lifetime of its parent scope; but in fact, nested functions are unnecessary. Technically speaking, all functions in JavaScript form closures—some just don't capture anything, and closures don't even have to be functions. The key ingredients for a useful closure are the following:\n• A parent scope that defines some variables or functions. It should have a clear lifetime, which means it should finish execution at some point. Any scope that's not the global scope satisfies this requirement; this includes blocks, functions, modules, and more.\n• An inner scope defined within the parent scope, which refers to some variables or functions defined in the parent scope.\n• The inner scope manages to survive beyond the lifetime of the parent scope. For example, it is saved to a variable that's defined outside the parent scope, or it's returned from the parent scope (if the parent scope is a function).\n• Then, when you call the function outside of the parent scope, you can still access the variables or functions that were defined in the parent scope, even though the parent scope has finished execution. The following is a typical example of a closure: // The outer function defines a variable called \"name\" const pet = function (name) { const getName = function () { // The inner function has access to the \"name\" variable of the outer function return name; }; return getName; // Return the inner function, thereby exposing it to outer scopes }; const myPet = pet(\"Vivie\"); console.log(myPet()); // \"Vivie\" It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned. const createPet = function (name) { let sex; const pet = { // setName(newName) is equivalent to setName: function (newName) // in this context setName(newName) { name = newName; }, getName() { return name; }, getSex() { return sex; }, setSex(newSex) { if ( typeof newSex === \"string\" && (newSex.toLowerCase() === \"male\" || newSex.toLowerCase() === \"female\") ) { sex = newSex; } }, }; return pet; }; const pet = createPet(\"Vivie\"); console.log(pet.getName()); // Vivie pet.setName(\"Oliver\"); pet.setSex(\"male\"); console.log(pet.getSex()); // male console.log(pet.getName()); // Oliver In the code above, the variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold \"persistent\" and \"encapsulated\" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name. const getCode = (function () { const apiCode = \"0]Eal(eh&2\"; // A code we do not want outsiders to be able to modify… return function () { return apiCode; }; })(); console.log(getCode()); // \"0]Eal(eh&2\" In the code above, we use the IIFE pattern. Within this IIFE scope, two values exist: a variable and an unnamed function that gets returned and gets assigned to the variable . is in the scope of the returned unnamed function but not in the scope of any other part of the program, so there is no way for reading the value of apart from via the function.\n\nThe arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows: where is the ordinal number of the argument, starting at . So, the first argument passed to a function would be . The total number of arguments is indicated by . Using the object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use to determine the number of arguments actually passed to the function, and then access each argument using the object. For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows: function myConcat(separator) { let result = \"\"; // initialize list // iterate through arguments for (let i = 1; i < arguments.length; i++) { result += arguments[i] + separator; } return result; } You can pass any number of arguments to this function, and it concatenates each argument into a string \"list\": Note: The variable is \"array-like\", but not an array. It is array-like in that it has a numbered index and a property. However, it does not possess all of the array-manipulation methods. See the object in the JavaScript reference for more information."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Glossary/Recursion",
        "document": "The following Python code defines a function that takes a number, prints it, and then calls itself again with the number's value -1. It keeps going until the number is equal to 0, in which case it stops.\n\nThe output will look like this:"
    },
    {
        "link": "https://stackoverflow.com/questions/39555452/is-there-a-standard-way-to-document-recursive-functions",
        "document": "Just wondering if there is a standard notation or at least a common notation for specifying a recursive function?\n\nI don't know if it's important, but I like to give as much information in my function docblocks as possible, so I will usually just add something like 'This is a recursive function'.\n\nHere is an example so we're all thinking about documenting in the same place. And my example is using ES2015 Javascript"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions",
        "document": "Generally speaking, a function is a \"subprogram\" that can be called by code external (or internal, in the case of recursion) to the function. Like the program itself, a function is composed of a sequence of statements called the function body. Values can be passed to a function as parameters, and the function will return a value. In JavaScript, functions are first-class objects, because they can be passed to other functions, returned from functions, and assigned to variables and properties. They can also have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called. For more examples and explanations, see the JavaScript guide about functions.\n\nParameters and arguments have slightly different meanings, but in MDN web docs, we often use them interchangeably. For a quick reference: In this example, the variable is called the function's parameter: it's declared in the parenthesis-enclosed list of the function's definition. The function expects the parameter to be a number — although this is not enforceable in JavaScript without writing runtime validation code. In the call, the number is the function's argument: it's the value that is actually passed to the function in the function call. The argument value can be accessed inside the function body through the corresponding parameter name or the object. Arguments are always passed by value and never passed by reference. This means that if a function reassigns a parameter, the value won't change outside the function. More precisely, object arguments are passed by sharing, which means if the object's properties are mutated, the change will impact the outside of the function. For example: function updateBrand(obj) { // Mutating the object is visible outside the function obj.brand = \"Toyota\"; // Try to reassign the parameter, but this won't affect // the variable's value outside the function obj = null; } const car = { brand: \"Honda\", model: \"Accord\", year: 1998, }; console.log(car.brand); // Honda // Pass object reference to the function updateBrand(car); // updateBrand mutates car console.log(car.brand); // Toyota The keyword refers to the object that the function is accessed on — it does not refer to the currently executing function, so you must refer to the function value by name, even within the function body.\n\nBroadly speaking, JavaScript has four kinds of functions:\n• Regular function: can return anything; always runs to completion after invocation\n• Generator function: returns a object; can be paused and resumed with the operator\n• Async function: returns a ; can be paused and resumed with the operator\n• Async generator function: returns an object; both the and operators can be used For every kind of function, there are multiple ways to define it: In addition, there are special syntaxes for defining arrow functions and methods, which provide more precise semantics for their usage. Classes are conceptually not functions (because they throw an error when called without ), but they also inherit from and have . // Constructor const multiply = new Function(\"x\", \"y\", \"return x * y\"); // Declaration function multiply(x, y) { return x * y; } // No need for semicolon here // Expression; the function is anonymous but assigned to a variable const multiply = function (x, y) { return x * y; }; // Expression; the function has its own name const multiply = function funcName(x, y) { return x * y; }; // Arrow function const multiply = (x, y) => x * y; // Method const obj = { multiply(x, y) { return x * y; }, }; All syntaxes do approximately the same thing, but there are some subtle behavior differences.\n• The constructor, expression, and declaration syntaxes create full-fledged function objects, which can be constructed with . However, arrow functions and methods cannot be constructed. Async functions, generator functions, and async generator functions are not constructible regardless of syntax.\n• The declaration creates functions that are hoisted. Other syntaxes do not hoist the function and the function value is only visible after the definition.\n• The arrow function and constructor always create anonymous functions, which means they can't easily call themselves recursively. One way to call an arrow function recursively is by assigning it to a variable.\n• The arrow function syntax does not have access to or .\n• The constructor cannot access any local variables — it only has access to the global scope.\n• The constructor causes runtime compilation and is often slower than other syntaxes. For expressions, there is a distinction between the function name and the variable the function is assigned to. The function name cannot be changed, while the variable the function is assigned to can be reassigned. The function name can be different from the variable the function is assigned to — they have no relation to each other. The function name can be used only within the function's body. Attempting to use it outside the function's body results in an error (or gets another value, if the same name is declared elsewhere). For example: On the other hand, the variable the function is assigned to is limited only by its scope, which is guaranteed to include the scope in which the function is declared. A function declaration also creates a variable with the same name as the function name. Thus, unlike those defined by function expressions, functions defined by function declarations can be accessed by their name in the scope they were defined in, as well as in their own body. A function defined by will dynamically have its source assembled, which is observable when you serialize it. For example, gives: This is the actual source used to compile the function. However, although the constructor will create the function with name , this name is not added to the scope of the body. The body only ever has access to global variables. For example, the following would result in an error: A function defined by a function expression or by a function declaration inherits the current scope. That is, the function forms a closure. On the other hand, a function defined by a constructor does not inherit any scope other than the global scope (which all functions inherit). // p is a global variable globalThis.p = 5; function myFunc() { // p is a local variable const p = 9; function decl() { console.log(p); } const expr = function () { console.log(p); }; const cons = new Function(\"\\tconsole.log(p);\"); decl(); expr(); cons(); } myFunc(); // Logs: // 9 (for 'decl' by function declaration (current scope)) // 9 (for 'expr' by function expression (current scope)) // 5 (for 'cons' by Function constructor (global scope)) Functions defined by function expressions and function declarations are parsed only once, while a function defined by the constructor parses the string passed to it each and every time the constructor is called. Although a function expression creates a closure every time, the function body is not reparsed, so function expressions are still faster than . Therefore the constructor should generally be avoided whenever possible. A function declaration may be unintentionally turned into a function expression when it appears in an expression context. On the other hand, a function expression may also be turned into a function declaration. An expression statement cannot begin with the or keywords, which is a common mistake when implementing IIFEs (Immediately Invoked Function Expressions). Instead, start the expression statement with something else, so that the keyword unambiguously starts a function expression. Common options include grouping and using .\n\nIn non-strict code, function declarations inside blocks behave strangely. For example: if (shouldDefineZero) { function zero() { // DANGER: compatibility risk console.log(\"This is zero.\"); } } The semantics of this in strict mode are well-specified — only ever exists within that scope of the block. If is false, then should never be defined, since the block never executes. However, historically, this was left unspecified, so different browsers implemented it differently in non-strict mode. For more information, see the declaration reference. A safer way to define functions conditionally is to assign a function expression to a variable: // Using a var makes it available as a global variable, // with closer behavior to a top-level function declaration var zero; if (shouldDefineZero) { zero = function () { console.log(\"This is zero.\"); }; }"
    },
    {
        "link": "https://shecodes.io/athena/2373-understanding-recursion-with-javascript",
        "document": "const toggleInfo = (index, event) => { setVisibleLightIndexes((prev) => { if (prev.includes(index)) { return prev.filter((i) => i !== index); } else { return [...prev, index]; } }); const clickedElement = event.target.closest(\".chauvetLights\"); if (clickedElement) { clickedElement.classList.toggle(\"expanded\"); } toggleBackgroundColor(event); }; TypeError: Cannot read properties of undefined (reading 'target') at k (home-OO3WpeNb.js:1:102576) at onClick (home-OO3WpeNb.js:1:104620) at Object.Em (index-h-qGlws7.js:38:9852) at km (index-h-qGlws7.js:38:10006) at Cm (index-h-qGlws7.js:38:10063) at Wa (index-h-qGlws7.js:38:31422) at fd (index-h-qGlws7.js:38:31839) at index-h-qGlws7.js:38:36751 at Vs (index-h-qGlws7.js:41:36768) at Df (index-h-qGlws7.js:38:8988)\n\nAdd a value attribute to both radio buttons. For convenience, set the button's value attribute to the same value as its id attribute."
    },
    {
        "link": "https://javascript.info/recursion",
        "document": "Let’s return to functions and study them more in-depth.\n\nOur first topic will be recursion.\n\nIf you are not new to programming, then it is probably familiar and you could skip this chapter.\n\nRecursion is a programming pattern that is useful in situations when a task can be naturally split into several tasks of the same kind, but simpler. Or when a task can be simplified into an easy action plus a simpler variant of the same task. Or, as we’ll see soon, to deal with certain data structures.\n\nWhen a function solves a task, in the process it can call many other functions. A partial case of this is when a function calls itself. That’s called recursion.\n\nFor something simple to start with – let’s write a function that raises to a natural power of . In other words, multiplies by itself times.\n\nThere are two ways to implement it.\n• function pow(x, n) { let result = 1; // multiply result by x n times in the loop for (let i = 0; i < n; i++) { result *= x; } return result; } alert( pow(2, 3) ); // 8\n• Recursive thinking: simplify the task and call self:\n\nPlease note how the recursive variant is fundamentally different.\n\nWhen is called, the execution splits into two branches:\n• If , then everything is trivial. It is called the base of recursion, because it immediately produces the obvious result: equals .\n• Otherwise, we can represent as . In maths, one would write . This is called a recursive step: we transform the task into a simpler action (multiplication by ) and a simpler call of the same task ( with lower ). Next steps simplify it further and further until reaches .\n\nWe can also say that recursively calls itself till .\n\nFor example, to calculate the recursive variant does these steps:\n\nSo, the recursion reduces a function call to a simpler one, and then – to even more simpler, and so on, until the result becomes obvious.\n\nThe maximal number of nested calls (including the first one) is called recursion depth. In our case, it will be exactly .\n\nThe maximal recursion depth is limited by JavaScript engine. We can rely on it being 10000, some engines allow more, but 100000 is probably out of limit for the majority of them. There are automatic optimizations that help alleviate this (“tail calls optimizations”), but they are not yet supported everywhere and work only in simple cases.\n\nThat limits the application of recursion, but it still remains very wide. There are many tasks where recursive way of thinking gives simpler code, easier to maintain.\n\nNow let’s examine how recursive calls work. For that we’ll look under the hood of functions.\n\nThe information about the process of execution of a running function is stored in its execution context.\n\nThe execution context is an internal data structure that contains details about the execution of a function: where the control flow is now, the current variables, the value of (we don’t use it here) and few other internal details.\n\nOne function call has exactly one execution context associated with it.\n\nWhen a function makes a nested call, the following happens:\n• The execution context associated with it is remembered in a special data structure called execution context stack.\n• After it ends, the old execution context is retrieved from the stack, and the outer function is resumed from where it stopped.\n\nLet’s see what happens during the call.\n\nIn the beginning of the call the execution context will store variables: , the execution flow is at line of the function.\n\nWe can sketch it as:\n\nThat’s when the function starts to execute. The condition is falsy, so the flow continues into the second branch of :\n\nThe variables are same, but the line changes, so the context is now:\n\nTo calculate , we need to make a subcall of with new arguments .\n\nTo do a nested call, JavaScript remembers the current execution context in the execution context stack.\n\nHere we call the same function , but it absolutely doesn’t matter. The process is the same for all functions:\n• The current context is “remembered” on top of the stack.\n• The new context is created for the subcall.\n• When the subcall is finished – the previous context is popped from the stack, and its execution continues.\n\nHere’s the context stack when we entered the subcall :\n\nThe new current execution context is on top (and bold), and previous remembered contexts are below.\n\nWhen we finish the subcall – it is easy to resume the previous context, because it keeps both variables and the exact place of the code where it stopped.\n\nThe process repeats: a new subcall is made at line , now with arguments , .\n\nA new execution context is created, the previous one is pushed on top of the stack:\n\nThere are 2 old contexts now and 1 currently running for .\n\nDuring the execution of , unlike before, the condition is truthy, so the first branch of works:\n\nThere are no more nested calls, so the function finishes, returning .\n\nAs the function finishes, its execution context is not needed anymore, so it’s removed from the memory. The previous one is restored off the top of the stack:\n\nThe execution of is resumed. It has the result of the subcall , so it also can finish the evaluation of , returning .\n\nThen the previous context is restored:\n\nWhen it finishes, we have a result of .\n\nThe recursion depth in this case was: 3.\n\nAs we can see from the illustrations above, recursion depth equals the maximal number of context in the stack.\n\nNote the memory requirements. Contexts take memory. In our case, raising to the power of actually requires the memory for contexts, for all lower values of .\n\nThe iterative uses a single context changing and in the process. Its memory requirements are small, fixed and do not depend on .\n\nAny recursion can be rewritten as a loop. The loop variant usually can be made more effective.\n\n…But sometimes the rewrite is non-trivial, especially when a function uses different recursive subcalls depending on conditions and merges their results or when the branching is more intricate. And the optimization may be unneeded and totally not worth the efforts.\n\nRecursion can give a shorter code, easier to understand and support. Optimizations are not required in every place, mostly we need a good code, that’s why it’s used.\n\nAnother great application of the recursion is a recursive traversal.\n\nImagine, we have a company. The staff structure can be presented as an object:\n\nIn other words, a company has departments.\n• A department may have an array of staff. For instance, department has 2 employees: John and Alice.\n• Or a department may split into subdepartments, like has two branches: and . Each of them has their own staff.\n• It is also possible that when a subdepartment grows, it divides into subsubdepartments (or teams). For instance, the department in the future may be split into teams for and . And they, potentially, can split even more. That’s not on the picture, just something to have in mind.\n\nNow let’s say we want a function to get the sum of all salaries. How can we do that?\n\nAn iterative approach is not easy, because the structure is not simple. The first idea may be to make a loop over with nested subloop over 1st level departments. But then we need more nested subloops to iterate over the staff in 2nd level departments like … And then another subloop inside those for 3rd level departments that might appear in the future? If we put 3-4 nested subloops in the code to traverse a single object, it becomes rather ugly.\n\nAs we can see, when our function gets a department to sum, there are two possible cases:\n• Either it’s a “simple” department with an array of people – then we can sum the salaries in a simple loop.\n• Or it’s an object with subdepartments – then we can make recursive calls to get the sum for each of the subdeps and combine the results.\n\nThe 1st case is the base of recursion, the trivial case, when we get an array.\n\nThe 2nd case when we get an object is the recursive step. A complex task is split into subtasks for smaller departments. They may in turn split again, but sooner or later the split will finish at (1).\n\nThe algorithm is probably even easier to read from the code:\n\nThe code is short and easy to understand (hopefully?). That’s the power of recursion. It also works for any level of subdepartment nesting.\n\nWe can easily see the principle: for an object subcalls are made, while arrays are the “leaves” of the recursion tree, they give immediate result.\n\nNote that the code uses smart features that we’ve covered before:\n• Method explained in the chapter Array methods to get the sum of the array.\n• Loop to iterate over object values: returns an array of them.\n\nA recursive (recursively-defined) data structure is a structure that replicates itself in parts.\n\nWe’ve just seen it in the example of a company structure above.\n• Either an array of people.\n• Or an object with departments.\n\nFor web-developers there are much better-known examples: HTML and XML documents.\n\nIn the HTML document, an HTML-tag may contain a list of:\n• Other HTML-tags (that in turn may contain text pieces/comments or other tags etc).\n\nFor better understanding, we’ll cover one more recursive structure named “Linked list” that might be a better alternative for arrays in some cases.\n\nImagine, we want to store an ordered list of objects.\n\nThe natural choice would be an array:\n\n…But there’s a problem with arrays. The “delete element” and “insert element” operations are expensive. For instance, operation has to renumber all elements to make room for a new , and if the array is big, it takes time. Same with .\n\nThe only structural modifications that do not require mass-renumbering are those that operate with the end of array: . So an array can be quite slow for big queues, when we have to work with the beginning.\n\nAlternatively, if we really need fast insertion/deletion, we can choose another data structure called a linked list.\n\nThe linked list element is recursively defined as an object with:\n• property referencing the next linked list element or if that’s the end.\n\nHere we can even more clearly see that there are multiple objects, each one has the and pointing to the neighbour. The variable is the first object in the chain, so following pointers from it we can reach any element.\n\nThe list can be easily split into multiple parts and later joined back:\n\nAnd surely we can insert or remove items in any place.\n\nFor instance, to prepend a new value, we need to update the head of the list:\n\nTo remove a value from the middle, change of the previous one:\n\nWe made jump over to value . The value is now excluded from the chain. If it’s not stored anywhere else, it will be automatically removed from the memory.\n\nUnlike arrays, there’s no mass-renumbering, we can easily rearrange elements.\n\nNaturally, lists are not always better than arrays. Otherwise everyone would use only lists.\n\nThe main drawback is that we can’t easily access an element by its number. In an array that’s easy: is a direct reference. But in the list we need to start from the first item and go times to get the Nth element.\n\n…But we don’t always need such operations. For instance, when we need a queue or even a deque – the ordered structure that must allow very fast adding/removing elements from both ends, but access to its middle is not needed.\n• We can add property in addition to to reference the previous element, to move back easily.\n• We can also add a variable named referencing the last element of the list (and update it when adding/removing elements from the end).\n• …The data structure may vary according to our needs.\n• Recursion is a programming term that means calling a function from itself. Recursive functions can be used to solve tasks in elegant ways. When a function calls itself, that’s called a recursion step. The basis of recursion is function arguments that make the task so simple that the function does not make further calls.\n• A recursively-defined data structure is a data structure that can be defined using itself. For instance, the linked list can be defined as a data structure consisting of an object referencing a list (or null). Trees like HTML elements tree or the department tree from this chapter are also naturally recursive: they have branches and every branch can have other branches. Recursive functions can be used to walk them as we’ve seen in the example.\n\nAny recursive function can be rewritten into an iterative one. And that’s sometimes required to optimize stuff. But for many tasks a recursive solution is fast enough and easier to write and support."
    },
    {
        "link": "https://medium.com/@marc.herman.rodriguez/recursion-and-the-call-stack-93666f923226",
        "document": "Recursion can be a difficult concept to understand, especially as a beginner. It certainly boggled my mind the first time I learned about it. I could understand it as an abstract concept, but when it came to how recursive functions worked, I was at a loss. I had my ‘aha’ moment when I was learning about the call stack. Understanding the order in which JavaScript resolves functions is important to understanding recursion.\n\nSince I am still a beginner at learning JavaScript, I am hoping to explain recursion on a beginning level so you can understand how recursion works and maybe start to use it in your own code.\n\nRecursion is when a function calls itself. A function that calls itself can be called a recursive function.\n\nHere is the most basic (but fatally flawed) recursive function:\n\nThis function is declared and then invoked from within the code block. Written this way, this function would cause an infinite loop. An infinite loop will halt your program and could possibly crash your browser.\n\nFor this reason, a recursive function must be written with a stopping condition. This is sometimes referred to as a base condition. Recursive functions are very similar to for/while loops. Both execute code multiple times and a condition must be given to cease the loop. It is important to note that the condition must be attainable. The below example will still result in an infinite loop, despite a stopping condition being declared:\n\nRecursive functions often use if…else statements to avoid an infinite loop. One branch of the if…else statement will make the recursive call until a condition is met, and then the other branch will end recursion. The below example shows a function that will call itself until x is less than 0, then the function will end.\n\nWhat is the Call Stack?\n\nThe call stack is a data structure that the JavaScript interpreter uses to keep track of its place in a script that calls multiple functions. JavaScript has a single call stack, therefore only one function can be executed at a time. This is what makes JavaScript synchronous.\n\nThe call stack works on a Last-In First-Out principle. This means that the last function to be added to the call stack will be the first to execute and pop off the stack.\n\nWhen a function is called, it is added to the call stack. Any functions that are called from within that function are then added to the top of the call stack. Multiple functions can be added to the stack in this manner.\n\nWhen the current function finishes, it is popped off the stack and the interpreter returns to where it left off with the previous function. The interpreter will continue finishing functions and popping them off the stack until there are no more functions left on the call stack.\n\nThis may seem a bit complicated, but the call stack is best understood by looking at an example:\n\nIn this example, is called. This function is added to the stack. Then from within the function, is called. The function is added to the stack. does not call any additional functions, so the interpreter is able to complete this function and pop it off the stack. Now all that remains on the call stack is . The interpreter executes this function and removes it from the stack."
    },
    {
        "link": "https://dev.to/shehzadhussain/recursion-in-javascript-2kh3",
        "document": "Today, we'll talk about recursion in JavaScript, a powerful tool in your coding arsenal. You'll learn how to implement it through clear, practical examples.\n\nUnderstanding recursion is crucial for JavaScript developers. It simplifies complex problems, improves readability, and is often a preferred solution in interviews and real-world coding challenges.\n\nMany developers struggle with recursion due to its abstract concept and potential for errors like infinite loops. But, with the right approach, it can be learned effectively\n\n**Recursion is not just a technique but a new way of thinking.\n\nRecursion involves a function calling itself until it reaches a base condition. This approach is beneficial for tasks like traversing trees or solving algorithms that require backtracking, such as searching or sorting.\n• None Recursion simplifies complex problems by breaking them into smaller, manageable parts.\n• None It's essential to define a clear base case to prevent infinite loops.\n• None Recursion can lead to more readable and elegant code than iterative solutions.\n• None Understanding stack overflow and how JavaScript manages memory in recursive calls is crucial.\n• None Stack Overflow: In JavaScript, each recursive call adds a frame to the call stack. If your recursion is too deep (i.e., too many calls without reaching the base case), you can exhaust the stack memory, leading to a \"stack overflow\" error. This often happens if the base case is not correctly defined or the recursion is not converging towards it.\n• None Lack of Base Case: The base case is what stops the recursion. Without a proper base case, your function will keep calling itself indefinitely, leading to infinite recursion and, eventually, a stack overflow error.\n• None Large Memory Consumption: Each recursive call uses memory to maintain its execution context. Inefficient recursion, especially with many levels, can consume significant memory, leading to performance issues.\n\n**\n\n In ES6 (ECMAScript 2015), JavaScript introduced a feature called \"tail call optimization.\" This optimization allows certain recursive calls (tail calls) to be executed without adding a new stack frame. For a recursive call to be a tail call, it must be the last operation in the function. This optimization significantly reduces the risk of stack overflow and improves performance for deep recursive calls.\n• None Tail Call Optimization is a feature that makes recursive functions more efficient.\n• None Normally, whenever a function calls itself, it adds a new layer to the \"call stack\" (a pile of ongoing function calls). If this stack gets too big, it can cause problems like a \"stack overflow.\"\n• None In TCO, if a function's last action is calling itself (a \"tail call\"), JavaScript can optimize it. Instead of adding a new layer to the stack, it reuses the current one. This means you can have more recursive calls without the risk of stack overflow.\n• None However, for TCO to work, the recursive call must be the last thing the function does.\n\nHere's a more straightforward example of a recursive function using TCO:\n• None We're calculating the sum of numbers from 1 to n.\n• None The function keeps calling itself, but its last operation is the recursive call (return sumRange(n - 1, total + n)).\n• None Because this call is the last action, it's a tail call and can be optimized by JavaScript, allowing it to run more efficiently, especially for large values of n.\n\nIn summary, TCO in JavaScript allows you to write recursive functions that are more efficient and less likely to run into problems with large numbers of recursive calls.\n\nHere's an example to illustrate TCO with the factorial function:\n\nUnderstanding these pitfalls and techniques can significantly enhance your proficiency in writing efficient and safe recursive functions in JavaScript.\n\nConclusion\n\n Recursion in JavaScript is a valuable skill that, once mastered, opens up new possibilities in coding. It encourages cleaner, more intuitive solutions and is a favorite in algorithmic challenges. Practising and understanding the theory behind recursion are key to mastering it.\n\nIf you have any questions, feel free to reply to the email or leave a comment in the post.\n\nSee you in the next post."
    },
    {
        "link": "https://stackoverflow.com/questions/75633072/recursive-function-without-exceeding-call-stack",
        "document": "In theory, I would like to know a way to have a recursive function that runs forever without exceeding the call stack. I am trying to implement in javascript and I keep getting the error\n\nMy code looks like this\n\nNow i expect to just initiate this once in a terminal and let it run forever as long as no error.\n\nI've seen some discussion here JavaScript recursion: Maximum call stack size exceeded which suggests there must be some exit point for the loop. However i want to believe there will be particular application for such infinite loop in setting up things like a daemon process"
    },
    {
        "link": "https://sahinarslan.tech/posts/a-voyage-through-algorithms-using-javascript-recursion",
        "document": "Recursion is a powerful and elegant technique that forms the backbone of many algorithms. It allows a function to call itself repeatedly until a specific condition is met, enabling the solution of complex problems by breaking them down into simpler subproblems.\n\nEvery recursive function consists of two essential parts: the base condition and the recursive call.\n\nBase Condition: The base condition is the foundation of a recursive function. It defines the scenario where the function can provide a direct solution without the need for further recursive calls, acting as a termination point to prevent infinite loops. The base condition represents the simplest form of the problem that can be solved immediately.\n\nRecursive Call: The recursive call is where the function invokes itself with a modified version of the original problem. The function approaches the base condition by gradually reducing the problem into smaller, more manageable subproblems. The results of these recursive calls are then combined or processed to yield the final solution.\n\nThe cooperation between the base condition and the recursive call is what makes recursion a powerful tool. The base condition ensures that the recursion terminates, while the recursive call allows the function to tackle complex problems by breaking them down into simpler ones.\n\nRecursion can be classified into different types based on how the recursive calls are made. Let’s explore each type with examples, use cases, pros, and cons.\n\nIn direct recursion, a function calls itself directly within its own body.\n• Simple and intuitive to understand and implement\n• Can lead to stack overflow if the recursion depth is too large\n• May be less efficient compared to iterative solutions for certain problems\n\nIndirect recursion occurs when a function calls another function, which in turn calls the original function directly or indirectly.\n• Solving problems that can be divided into interrelated subproblems\n• Allows for modular and organized code structure due to each function having a specific role.\n• Can make the logic more readable and maintainable due to each function handling a distinct part of the problem.\n• Even the modularity and separation of concerns makes it readable at a glance, it can be still harder to understand since it involves multiple functions calling each other. This can make the flow of execution less straightforward compared to direct recursion, where you only deal with a single function calling itself.\n• It can result in deeper recursion depths since multiple functions are involved in the recursive process. This increases the risk of stack overflow if the recursion goes too deep, as each function call adds a new frame to the call stack.\n\nA recursive function is considered tail recursive if the recursive call is the last thing executed by the function. There is no need to keep a record of the previous state – in other words, there’s no additional computation after the recursive call returns.\n• Optimizing recursive algorithms by simplifying the recursive structure to reduce the amount of recursive calls\n• Example: A tail-recursive version of the naive implementation of Fibonacci sequence (more details on Optimizing Recursive functions section).\n• Tail call optimization (TCO) can also further enhance performance by optimizing these calls at the engine level. In terms of Javascript, TCO is only supported by the Safari engine.\n• Avoiding stack overflow in languages (or engines) that support tail call optimization\n• Can be optimized by the compiler or interpreter for better performance\n• Reduces the risk of stack overflow in supported languages / engines\n• Not all programming languages support tail call optimization in the engine level\n• May require additional parameters or helper functions to maintain the state\n\nA recursive function is considered non-tail recursive if the recursive call is not the last thing executed by the function. After returning from the recursive call, there is something left to evaluate (notice the console log after the reversePrint function below).\n• Allows for post-processing or evaluation after the recursive call\n• Suitable for problems that require backtracking or post-order traversal\n• Can lead to stack overflow if the recursion depth is too large\n• May be less efficient compared to tail recursive or iterative solutions\n\nIt is critical that the recursive calls eventually reach the base condition. Without a well-defined base condition, the function may continue calling itself indefinitely, leading to infinite recursion and a stack overflow error.\n\nConsider the following example of a recursive function without a base condition:\n\nIn this case, the function lacks a base condition. When invoked with the argument , it will print and then call itself with the same argument. This process will repeat indefinitely, causing an infinite loop. The function will keep printing until the call stack reaches its limit, resulting in a stack overflow error:\n\nHowever, stack overflow errors can also occur in functions with a base condition if the input data is too large. For example, calculating the factorial of a very large number using a simple recursive function without optimization can also lead to a stack overflow due to the excessive depth of recursive calls.\n\nWhich brings us to the next topic: to effectively work with recursive functions, it’s not only essential to understand the anatomy of recursion but also to comprehend how the call stack operates. The call stack is an “unseen” key element that must be considered when working with recursive problems.\n\nThe call stack is a fundamental data structure used by Javascript Engine (similarly in many other programming languages) to manage function execution, evaluations, and the program’s execution flow “under the hood”.\n\nWhen a script calls a function, Javascript creates a new execution context for that function and pushes it onto the call stack. This execution context includes information such as the function’s parameters, local variables, and the location to return to when the function completes. If the function makes further function calls or evaluations, additional execution contexts are pushed onto the stack.\n\nThe call stack operates on the principle of “last in, first out” (LIFO), meaning that the last execution context pushed onto the stack is the first one to be popped off when it completes. Javascript continuously executes the code in the execution context at the top of the stack. When a function completes, its execution context is popped off the stack, and the program resumes execution from the previous execution context.\n\nLet’s consider a simple example to illustrate how the call stack behaves with non-nested function calls:\n\nHere’s what happens with the call stack:\n• \n• is pushed onto the call stack.\n• is popped off the call stack.\n• \n• is pushed onto the call stack.\n• is popped off the call stack.\n• \n• is pushed onto the call stack.\n• is popped off the call stack.\n\nIn this scenario, each function call is independent and completes before the next function is called. The call stack never holds more than one function at a time, as each function “comes and goes” in a sequential manner.\n\nNow, let’s examine how the call stack handles nested function calls:\n\nHere’s what happens with the call stack when we’re dealing with nested calls:\n• \n• is pushed onto the call stack.\n• \n• is pushed onto the call stack on top of .\n• \n• is pushed onto the call stack on top of .\n• is popped off the call stack.\n• The return value from is used by :\n• continues execution, receives the string , and returns it.\n• is popped off the call stack.\n• The return value from is used by :\n• continues execution, receives the string , and returns it.\n• is popped off the call stack.\n\nIn this case, the call stack holds multiple functions simultaneously due to the nested calls to manage more complex execution flows.\n\nRecursion relies heavily on the call stack to manage the multiple instances of the recursive function. Each recursive call creates a new frame on the call stack with its own execution context (variables and parameters).\n\nConsider a simple example of a recursive function that counts down from a number:\n\nHere’s what happens in the call stack when we’re dealing with this recursive function:\n• is called and pushed onto the stack.\n• Since is not 0, it calls and pushes it onto the stack.\n• This process continues, pushing , , and onto the stack.\n• When is called, the base case is met, and it returns and pops off the stack.\n• The return value ( ) is passed up to , which then returns and pops off the stack.\n• This process continues until receives the return value from and completes, ultimately clearing the stack.\n\nAs you see, even a small operation can fill up the call stack pretty quickly. Therefore it’s critical to be cautious of the call stack’s size when working with recursion. If the recursion depth becomes too large or if there is no base case to terminate the recursion, the call stack can overflow. This happens when the maximum stack size is exceeded, and the program runs out of memory to store additional execution contexts.\n\nRecursive functions can be powerful and expressive, but they can also suffer from performance issues if not optimized properly. One common problem that arises with recursive functions is redundant calculations, where the same subproblems are solved multiple times. This can lead to exponential time complexity and inefficient use of resources.\n\nWhenever we discuss optimizing an algorithm, we are essentially focusing on improving its time and space complexity. This section assumes that you are at least somewhat familiar with Big O notation. If you need a quick refresher, I recommend starting with the article below and then returning here to continue:\n\nTo illustrate this, let’s take a look at the famous Fibonacci sequence problem and explore how we can optimize its recursive solution. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones. The sequence starts with 0 and 1, and goes on infinitely:\n\nA straightforward recursive implementation of the Fibonacci sequence can be written as follows:\n\nIn this implementation, the base condition is when is less than or equal to 1, in which case we simply return . For any value of greater than 1, we recursively call the function with and and add their results to obtain the Fibonacci number at position .\n\nWhile this implementation is concise and easy to understand, it suffers from a major performance issue. Let’s analyze the time complexity of this approach.\n\nThe time complexity of the naive recursive Fibonacci implementation can be represented by the recurrence relation:\n\nThis means that to calculate the Fibonacci number at position , we need to calculate the Fibonacci numbers at positions and , and then perform a constant-time operation (addition).\n\nThe recursive calls form a binary tree-like structure, where each node represents a function call. The height of this tree is , and the number of nodes in the tree grows exponentially with . In fact, the time complexity of this naive recursive approach is exponential, approximately O(2^n). In simpler words, each function is calling 2 functions, those 2 functions are calling 4 functions, and so on...\n\nTo understand why, let’s look at a small example. Consider the calculation of the 5th Fibonacci number:\n\nAs we can see, the number of function calls grows exponentially with each increasing value of . Each function call leads to two more function calls, resulting in a binary tree structure. The number of nodes in this tree is approximately 2^n, leading to an exponential time complexity.\n\nThe space complexity of the naive recursive Fibonacci implementation is O(n). This is because the maximum depth of the recursive call stack is proportional to the input value . Each recursive call adds a new frame to the call stack, consuming additional memory.\n\nIn the worst case, when is large, the recursive calls will reach a depth of before starting to return. This means that the call stack will contain frames, each storing the local variables and function call information.\n\nIt’s important to note that the space complexity is not exponential like the time complexity. While the time complexity grows exponentially with , the space complexity grows linearly with due to the linear growth of the call stack.\n• The time complexity of the naive recursive Fibonacci implementation is O(2^n), which is exponential.\n• The space complexity is O(n) due to the linear growth of the call stack with respect to the input value .\n\nNow let’s explore different optimization techniques to improve the performance of the recursive Fibonacci function:\n\nMemoization is a technique where we store the results of expensive function calls and return the cached result when the same inputs occur again. This optimization can significantly improve the performance of recursive functions by eliminating redundant calculations.\n\nHere’s an example of applying memoization to the Fibonacci function:\n\nIn this optimized version, we introduce an object to store the previously calculated Fibonacci numbers. Before making a recursive call, we check if the result for the current input is already available in the object. If it is, we return the memoized result directly. Otherwise, we proceed with the recursive calls and store the result in the object before returning it.\n\nWith memoization, each Fibonacci number is calculated only once. The recursive calls are made only for numbers that have not been previously calculated and memoized. This reduces the time complexity from exponential to linear, as there are only n unique subproblems to solve.\n\nThe space complexity of the memoized solution is O(n) because the object stores the results of each subproblem. In the worst case, the object will contain all the Fibonacci numbers from 0 to n.\n• When the recursive function has overlapping subproblems\n• Significantly improves the time complexity (from exponential to linear)\n• May not be suitable for all recursive problems\n\nTail call optimization is a technique used by some programming languages / engines to optimize recursive functions. It allows the compiler or interpreter to reuse the same callstack frame for recursive calls, thereby avoiding the overhead of creating new stack frames.\n\nTo take advantage of tail call optimization, we need to rewrite the recursive function in a way that the recursive call is the last operation performed. Here’s an example of the Fibonacci function optimized for tail calls:\n\nIn this version, we introduce two additional parameters and to keep track of the previous two Fibonacci numbers. The recursive call is made with , and the values of and are updated accordingly. The base conditions handle the cases when is 0 or 1.\n\nThe tail-recursive solution has a time complexity of O(n) because it makes n recursive calls, each taking constant time. This time complexity remains the same regardless of whether tail call optimization is supported or not.\n\nThe space complexity of the tail-recursive solution depends on whether the Javascript engine supports tail call optimization or not.\n• If tail call optimization is supported, the space complexity is reduced to O(1) because the recursive calls are optimized to reuse the same stack frame. This eliminates the need for additional memory to store the call stack.\n• If tail call optimization is not supported, the space complexity remains O(n) because each recursive call will consume an additional stack frame, similar to the naive recursive approach.\n\nIt’s worth noting that tail call optimization is not consistently available across all Javascript engines. As of today, TCO is only supported by Safari (in strict mode). This means that the actual space complexity of the tail-recursive solution may vary depending on the execution environment.\n• When the recursive function can be transformed into a tail-recursive form\n• When the programming language or specific implementation supports tail call optimization\n• Avoids stack overflow errors for deep recursions (if tail call optimization is supported)\n• Optimizes memory usage by reusing stack frames (if tail call optimization is supported)\n• May require additional parameters and manipulation of the recursive function\n\nTo keep the consistent behavior across different Javascript environments, it’s generally recommended to rely on other optimization techniques that have more predictable performance characteristics.\n\nTrampolining is a technique used to overcome the limitations of stack overflow in recursive functions. It involves separating the recursive function into a trampoline function that handles the recursive calls iteratively. This technique is particularly useful in Javascript, as it provides a way to manage deep recursion across different engines to prevent the call stack to exceed its limit.\n\nHere’s an example of applying trampolining to the Fibonacci function:\n\nIn this variant, the function is defined separately. It takes a recursive function as an argument and returns a new function that handles the recursive calls iteratively. The function remains the same as before, returning a function that encapsulates the next recursive step.\n\nThe function repeatedly calls the returned function until a non-function value is returned, which represents the final result. Finally, we create a function by passing to the function.\n\nThe trampolined solution has a time complexity of O(n) because it performs n iterations in the function. Each iteration invokes the returned function, which represents the next step of the recursion.\n\nThe space complexity of the trampolined solution is O(n) because the closure returned by captures the current state of the computation. In the worst case, there will be n closures created, each capturing the values of , , and .\n• When the recursive function has a deep recursion depth\n• When the programming language / engine does not support tail call optimization\n• Avoids stack overflow errors by breaking down the recursion into smaller steps\n• Allows for deep recursions without exceeding the call stack limit\n• May have slightly slower performance compared to direct recursion\n\nTake a look at the visual comparison below to see how trampolining effectively manages the call stack compared to the naive recursive approach:\n\nWhile recursive solutions can be elegant and expressive, sometimes an iterative approach can be more efficient in terms of time and space complexity. However, it’s important to note that iterative variants of recursive functions can often be more complex and harder to understand compared to their recursive counterparts. Let’s consider an iterative variant of the Fibonacci problem:\n\nIn this iterative solution, we start with the base cases for . Then, we initialize two variables and to keep track of the previous two Fibonacci numbers. We iterate from 2 to , updating the values of and in each iteration. Finally, we return the value of , which represents the Fibonacci number at position .\n\nThe iterative solution has a time complexity of O(n) because it iterates from 2 to n, performing constant-time operations in each iteration. The number of iterations is directly proportional to the input value n.\n\nThe space complexity of the iterative solution is O(1) because it only uses a constant amount of additional memory to store the variables , , and . The space required does not depend on the input value n.\n• When the recursive solution exceeds the maximum call stack size\n• When the problem requires a large number of iterations\n• Often more efficient in terms of time and space complexity\n• Avoids the overhead of function calls and stack management\n• Can be more complex and harder to understand compared to recursive solutions\n• May lack the elegance and expressiveness of recursive solutions\n\nJust by looking at the time and space complexity of each optimization technique, we can see how they improve upon the naive recursive approach:\n• Memoization reduces the time complexity from O(2^n) exponential to O(n) linear, but space complexity stays at O(n) linear to store the memoized results.\n• Tail call optimization maintains the O(n) linear time complexity, if the language / engine supports TPO it reduces the space complexity to O(1) constant by reusing stack frames, else space complexity stays at O(n) linear.\n• Trampolining also maintains the O(n) linear time complexity but has a space complexity of O(n) linear due to the creation of closures.\n• The iterative approach achieves optimization on both ends - O(n) linear time complexity and O(1) constant space complexity, making it the most efficient in terms of both time and space. But at this point, we no longer have a recursive function.\n\nWhile the iterative solution is the most efficient among them, it comes at the cost of reduced readability and increased complexity.\n\nRecursive solutions, on the other hand, often have a more natural and intuitive structure that aligns with the problem’s definition. They can be easier to understand and reason about, especially for problems that have a clear recursive nature.\n\nWhen deciding between a recursive or iterative approach, it’s also important to consider not only the efficiency aspects but also the readability and maintainability of the code. In some cases, a recursive solution may be preferable due to its simplicity and expressiveness, even if it has slightly higher time or space complexity compared to an iterative approach.\n\nThe choice between recursion and iteration depends on the specific problem, the constraints of the system, and the balance between efficiency and code clarity. It’s all about comparing the trade-offs and choose the approach that best fits the given scenario while prioritizing code readability and maintainability.\n\nI hope this article helped you to understand what a recursion is, how to work with it and how to optimize recursive functions depending on your use case. Thanks for reading!"
    }
]