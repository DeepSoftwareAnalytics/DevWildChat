[
    {
        "link": "https://arduino.cc/reference/tr/language/functions/analog-io/analogread",
        "document": "The Arduino Reference text is licensed under a Creative Commons Attribution-Share Alike 3.0 License.\n\nFind anything that can be improved? Suggest corrections and new documentation via GitHub.\n\nDoubts on how to use Github? Learn everything you need to know in this tutorial."
    },
    {
        "link": "https://forum.arduino.cc/t/understanding-analogread/955401",
        "document": "According to the definition presented below, the AnalogRead function will measure the output voltage of a pin as a 10 bit integer with 0 = 0V and 1023 = to the board voltage. That to me means that if I am using a 3.3V Arduino and measure 1V at the pin, then the AnalogRead should return 1023*1/3.3 = 310. I'm not getting that. When I do a Serial.print() of the variable I get a value equal to 1023-310 = 713 Everything works, but I have to program based on the AnalogRead subtracted from 1023. Just trying to make sense of this.\n\nWhich Arduino board do you use ? It should be 310 for a 3.3V board with a 10-bit ADC (Analog to Digital Converter) and nothing done with AREF or analogReference(). Can you show your sketch ? The current board is a Yourdrino RoboRed. which is just like an Uno but can be used with 21V input. The board I will be using is a Nano 33 BLE. Attached is the section of code where I read the pin and print it. Below that is the output of Serial Monitor. The issue occurs with both channels Radpin and CondPin. With the output presented the pins for RadPin and CondPin measure at 1.59V and 1.03V respectively. and are reporting 515 and 700,\n\nSo we can only give a section of an answer. When posting code we need to see all of it, and at least a photograph of the wiring. #include <PWM.h> // Note for low frequency < 31Hz,the high resolution pwmWriteHR() must be used with 16 bit PWM Value //For the RoboRed only pins 9 and 10 can be used with 16 bit resolution int RadPin = A0; int CondPin = A1; int AuxPin = A2; int RadVals[6] = {0, 0, 0, 0, 0, 0}; int CondVals[6] = {0, 0, 0, 0, 0, 0}; int AuxVals[6] = {0, 0, 0, 0, 0, 0}; // 10 bit temperature equivolents for radiator sensor int Rad20 = 444; //85C int Rad30 = 484; //90C int Rad40 = 524; //95C int Rad50 = 562; //100C int Rad60 = 599; //105C int Rad70 = 635; //110C int Rad80 = 668; //115C int Rad90 = 699; //120C // 10 bit temperature equivolents for condenser sensor int Cnd20 = 480; //40C int Cnd30 = 530; //45C int Cnd40 = 579; //50C int Cnd50 = 626; //55C int Cnd60 = 669; //60C int Cnd70 = 709; //65C int Cnd80 = 745; //70C int Cnd90 = 778; //75C int Aux20 = 0; int Aux30 = 0; int Aux40 = 0; int Aux50 = 0; int Aux60 = 0; int Aux70 = 0; int Aux80 = 0; int Aux90 = 0; int RadSpeed = 10; int CondSpeed = 10; int AuxSpeed = 10; int FanSpeed = 10; // Set fan to 10% PWM = off int FanPin = 9; // Set Fan pin int16_t PWMVal; int32_t frequency = 10; int t1; void setup() { // put your setup code here, to run once: pinMode(RadPin, INPUT); Serial.begin(9600); InitTimersSafe() //sets the frequency for the specified pin ; bool success = SetPinFrequencySafe(FanPin, frequency); //if the pin frequency was set successfully, pin 13 turn on. Pin 13 can be used to light an LED etc. if (success) { pinMode(13, OUTPUT); digitalWrite(13, HIGH); } } void loop() { // put your main code here, to run repeatedly: //this code prints sensor value to the console Serial.print(\"Rad pin input = \"); Serial.println(RadVals[0]); Serial.print(\"Cond pin input = \"); Serial.println(CondVals[0]); Serial.print(\"Aux pin input = \"); Serial.println(AuxVals[0]); Serial.println(\"Yo1\"); Serial.println(); // delay(1000); // t1=millis(); // do { // } while (millis()-t1 <1000); // initialize values RadVals[5] = 0; CondVals[5] = 0; AuxVals[5] = 0; //read sensor value and set upper limit cap //for (int i = 1; i <= 5; i++) { int i = 0; do { // Find 5 data points RadVals[i] = analogRead(RadPin); CondVals[i] = analogRead(CondPin); AuxVals[i] = analogRead(AuxPin); Serial.print(\"Rad pin input stored = \"); Serial.println(RadVals[i]); Serial.print(\"Cond pin input stored = \"); Serial.println(CondVals[i]); Serial.print(\"Aux pin input stored = \"); Serial.println(AuxVals[i]); Serial.println(i); Serial.println(\"Yo2\"); Serial.println(); // delay(1000); //Serial.print(\"Rad pin input before sum = \"); Serial.println(RadVals[5]); //Serial.println(\"Yo25\"); //Serial.println(); // sum all 5 data points RadVals[5] = RadVals[5] + RadVals[i]; CondVals[5] = CondVals[5] + CondVals[i]; AuxVals[5] = AuxVals[5] + AuxVals[i]; Serial.print(\"Rad pin input sum = \"); Serial.println(RadVals[5]); Serial.print(\"Cond pin input sum = \"); Serial.println(CondVals[5]); Serial.print(\"Aux pin input sum = \"); Serial.println(AuxVals[5]); Serial.println(i); Serial.println(\"Yo3\"); Serial.println(); // delay(1000); i = i + 1; } while (i < 5); // Find Average of 5 data points RadVals[5] = RadVals[5] / 5; CondVals[5] = CondVals[5] / 5; AuxVals[5] = AuxVals[5] / 5; Serial.print(\"Rad pin input Average = \"); Serial.println(RadVals[5]); Serial.print(\"Cond pin input Average = \"); Serial.println(CondVals[5]); Serial.print(\"Aux pin input Average = \"); Serial.println(AuxVals[5]); Serial.println(i); Serial.println(\"Yo4\"); Serial.println(); // delay(1000); if (RadVals[5] < Rad20) RadSpeed = 10; if (RadVals[5] < Rad30 and RadVals[5] >= Rad20) RadSpeed = 20; if (RadVals[5] < Rad40 and RadVals[5] >= Rad30) RadSpeed = 30; if (RadVals[5] < Rad50 and RadVals[5] >= Rad40) RadSpeed = 40; if (RadVals[5] < Rad60 and RadVals[5] >= Rad50) RadSpeed = 50; if (RadVals[5] < Rad70 and RadVals[5] >= Rad60) RadSpeed = 60; if (RadVals[5] < Rad80 and RadVals[5] >= Rad70) RadSpeed = 70; if (RadVals[5] < Rad90 and RadVals[5] >= Rad80) RadSpeed = 80; if (RadVals[5] >= Rad90) RadSpeed = 90; if (CondVals[5] < Cnd20) CondSpeed = 10; if (CondVals[5] < Cnd30 and CondVals[5] >= Cnd20) CondSpeed = 20; if (CondVals[5] < Cnd40 and CondVals[5] >= Cnd30) CondSpeed = 30; if (CondVals[5] < Cnd50 and CondVals[5] >= Cnd40) CondSpeed = 40; if (CondVals[5] < Cnd60 and CondVals[5] >= Cnd50) CondSpeed = 50; if (CondVals[5] < Cnd70 and CondVals[5] >= Cnd60) CondSpeed = 60; if (CondVals[5] < Cnd80 and CondVals[5] >= Cnd70) CondSpeed = 70; if (CondVals[5] < Cnd90 and CondVals[5] >= Cnd80) CondSpeed = 80; if (CondVals[5] >= Cnd90) CondSpeed = 90; if (AuxVals[5] < Aux20) AuxSpeed = 10; if (AuxVals[5] < Aux30 and AuxVals[5] >= Aux20) AuxSpeed = 20; if (AuxVals[5] < Aux40 and AuxVals[5] >= Aux30) AuxSpeed = 30; if (AuxVals[5] < Aux50 and AuxVals[5] >= Aux40) AuxSpeed = 40; if (AuxVals[5] < Aux60 and AuxVals[5] >= Aux50) AuxSpeed = 50; if (AuxVals[5] < Aux70 and AuxVals[5] >= Aux60) AuxSpeed = 60; if (AuxVals[5] < Aux80 and AuxVals[5] >= Aux70) AuxSpeed = 70; if (AuxVals[5] < Aux90 and AuxVals[5] >= Aux80) AuxSpeed = 80; if (AuxVals[5] >= Aux90) AuxSpeed = 90; FanSpeed = max(RadSpeed, CondSpeed); //map and assign pwm values to the fan output 0 to 65535 corresponds to 0 to 100% PWMVal = map(FanSpeed, 0, 100, 0, 65535); Serial.print(\"Rad pin input Average = \"); Serial.println(RadVals[5]); Serial.print(\"Cond pin input Average = \"); Serial.println(CondVals[5]); Serial.print(\"Aux pin input Average = \"); Serial.println(AuxVals[5]); Serial.print(\"Fan Speed = \"); Serial.println(FanSpeed); Serial.print(\"PMWval = \"); Serial.println(PWMVal); Serial.println(\"Yo4\"); Serial.println(); // delay(1000); //write the PWM value to the pwm output pin pwmWriteHR(FanPin, PWMVal); }\n\nYou need to read all 5 samples first before you go about averaging them. Why use a do ... while structure a simple for next loop will do? I am reading all five samples first. The code is summing each sample and after completion of the loop it divides by 5. I can probably loose the array but prefer to keep it in place to preserve each value for analysis. As far as the for next loop, I have already tried it and may go back to it. You can see it commented out above the while statement. I was having trouble with both For next and While Do until I commented out the all the Delay statements. For some reason delay was really messing every thing up. I am not surprised that you get rubbish answers. Just try printing out one analogue read at a time. Those prints are just there to see whats going on on the serial monitor. Do you think they could be messing things up? I can comment all of them out except for the last one at this point. If the average at the end changes significantly that should prove that the other print statements are effecting it.\n\nAt the moment I am running this measuring across a resistor that is connected to pin A0 and 3.3V output of the board. Are you trying to PWM the A0 pin and then get the Arduino to read it back? Do you know the PWM gives a signal of 5V followed by 0V, and the ratio of high to low averages out to be the number you set the PWM to be. Your meter could be averaging this for you. What are you doing with the PWM you generate?"
    },
    {
        "link": "https://geeksforgeeks.org/analogread-arduino-reference",
        "document": "In the world of Arduino programming, The analogRead() function plays a crucial role. This function used to fetch the analog data from the analog pins in the Arduino bords. Let us think of an example of developing a weather station. This needs to collect the data from sensors. To analyze the produced data primarily we have to collect that data from it. for this, we require the analogRead() Function to collect the data from external sources.\n\nThe Arduino board has a 10-bit multi-channel ADC (analog-to-digital converter) that reads analog pin values. It converts input voltages (0 to 5V or 3.3V) into integer values between 0 and 1023. For example, the Arduino UNO's resolution is 0.0049V per unit.\n• Analog Pin Reading : The `analogRead()` function reads the value from the specified analog pin.\n• Resolution Adjustment : Available on Zero, Due, and MKR boards using the `analogReadResolution()` function.\n\nNow, Let us see how different boards take inputs and produces output resolution..\n\n*A0~A5 are mapped on the board, A6~A11 are available on pins 4, 6, 8, 9, 10, and 12.**The default resolution of analogRead() is based on the board is 10 bits for compatibility. To convert to higher resolution use AnalogReadResolution().\n\nNow let us see the syntax of the analogRead() function.\n• Pin no is the Analog pin where the input is needed to read.\n• None The analog reading on the pin. Although it is limited to the resolution of the analog to digital converter (0-1023 for 10 bits or 0-4095 for 12 bits). Data type: int.\n\nLet us see some example to understand clearly,\n\nLet us example for how to use the analogRead() function to read the value from an analog input pin and print it to the serial monitor,\n\nNote: Use the following code only in the Arduino IDE, when the required hardware is connected....Don't Run the code here. It is only for reference..\n• None We first defined the analog input pin in which we'll be using (A0).\n• None In the setup() function, we initialized serial communication with a baud rate of 9600.\n• None In the loop() function, we used analogRead() to read the value from the analog input pin ( analogInPin ) and store it in the variable sensor Value\n• None We then print this value to the serial monitor using Serial.print() Serial.println()\n• None Finally, we added a short delay of 1000 milliseconds which is 1 second using the delay () function to give some time before reading the next analog input again.\n\nUpload this code into your Arduino board, open the serial monitor in the Arduino Ide, and you should see the analog values being printed in real-time as the Arduino reads them from the analog pin.\n• Reads Numbers from Sensors: This functions helps us to read the numbers from sensors.\n• Easy to Use: The process of using this function is very easy\n• Helps Control Things: With the numbers from analogRead(), we can control other things. like, we can make a light brighter based on the number you read.\n• Smooth Changes: analogRead() can give us smooth changes.\n• Not Super Fast: Compared to other functions this is not that much fast.\n• Limited Accuracy: The Accuracy that is provided by this function is less and limited.\n• Noise: In some ways it produce some noise while taking numbers from analogRead().\n• Light Sensors: We can use this analogRead() to read how much light is in a room.\n• Temperature Monitors: With analogRead(), we can read the temperature that came from a sensor.\n• Flex Sensors: analogRead() can read the bending of a flex sensor, which can be used in wearable technology.\n\nThe analogRead() function is an crucial function in Arduino programming. It is used to fetch the analog input from analog pins and converts it into digital signals . If that pins are connected to any secondary devices than this function is used to fetch the analog data from secondary devices that may be sensors, actuators and etc.\n\nWhat does the analogRead() function do?\n\nHow do I use analogRead() with sensors?\n\nWhat is the range of values returned by analogRead()?"
    },
    {
        "link": "https://reference.arduino.cc/reference/en/language/functions/analog-io/analogread",
        "document": "The Arduino Reference text is licensed under a Creative Commons Attribution-Share Alike 3.0 License.\n\nFind anything that can be improved? Suggest corrections and new documentation via GitHub.\n\nDoubts on how to use Github? Learn everything you need to know in this tutorial."
    },
    {
        "link": "https://docs.arduino.cc/built-in-examples/basics/AnalogReadSerial",
        "document": ""
    },
    {
        "link": "https://docs.arduino.cc/libraries/liquidcrystal",
        "document": ""
    },
    {
        "link": "https://arduino.cc/en/Tutorial/HelloWorld",
        "document": ""
    },
    {
        "link": "https://arduino.cc/en/Reference/LiquidCrystal",
        "document": ""
    },
    {
        "link": "https://docs.arduino.cc/learn/electronics/lcd-displays",
        "document": ""
    },
    {
        "link": "https://docs.arduino.cc/libraries/liquidcrystal-i2c",
        "document": ""
    }
]