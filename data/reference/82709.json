[
    {
        "link": "https://reddit.com/r/embedded/comments/1gs9tjk/what_are_some_good_resources_for_8051_programming",
        "document": "EDIT: Mods, if you don't tell me why you removed my post, I'll just put it back on... I can't find a thread that already answers my question concisely if that's why you took my post down. Thanks.\n\nHi, I'm making an analog synthesizer, and although the main microcontrollers will be something ARM Cortex based, I will need a few 8051's for stuff like processing and serializing keyboard input, and other small local functions.\n• I am looking for good resources to learn the 8051 architecture. Books or instruction manuals are good. I'm frustrated because I can't find anything of good quality or to-the-point -- most of what I find is either a series of articles or stuff aimed at people who don't know anything about microcontrollers at all and who haven't been exposed to assembly before.\n• Also, how the heck do I choose a specific 8051-based part if there are so many from various manufacturers? Does anyone have specific recommendations or guidance on which specific part to choose?"
    },
    {
        "link": "https://ww1.microchip.com/downloads/en/DeviceDoc/doc4316.pdf",
        "document": ""
    },
    {
        "link": "https://freecomputerbooks.com/Architecture-and-Programming-of-8051-Microcontrollers.html",
        "document": "Learn in a quick and easy way to program Intel 8051 microcontroller using many practical examples we have provided for you. Despite its relative old age, 8051 is still the most commonly used microcontroller at present. Beside Intel, many other renowned companies manufacture this model - Philips, Siemens, etc. The book contains details of its architecture and many practical examples, both simple and complex, useful program routines, instructions on handling the programmer for Atmel 51 series, and the guide on using the development systems for Atmel microcontrollers. In the appendices you will find detailed assembler instructions with examples, glossary and much more..\n\nDesigned as a main or supplementary text for courses on microprocessors or microcontrollers. Packaged with a customized disk containing an 8051 assembler and 8051 simulator. Focuses on programming the Intel 8051 microcontroller, one of the most common microprocessors used in controls or instrumentation applications using assembly code. Text has been updated to include easier-to-read computer programs and more hardware interfacing. Instruction Set in the Appendix has been expanded.\n• The C and Objective-C Programming\n• Microcontroller Projects in C for the 8051 (Dogan Ibrahim) Explore the 8051 and discover C programming through project work. Through graded projects, it introduces the reader to the fundamentals of microelectronics, the 8051 family, programming in C, and the use of a C compiler.\n• PaulOS: An 8051 Real-Time Operating System (Paul P. Debono) This book covers mainly the 8051 family of micro-controllers starting with the basic architecture and then moves on to assembly language and Real-Time Operating System (RTOS) where three main types of self-developed RTOSs are discussed.\n• Operational Amplifiers and Linear Integrated Circuits This book offers an extensive and detailed exploration of the modern op amp and associated specialized linear integrated circuits. The exploration begins with a fundamental building building block, the differential amplifier.\n• What's a Microcontroller? (Andy Lindsay) The book answers the question \"What's a Microcontroller?\" by showing students how they can design their own customized, intelligent inventions using the BASIC Stamp. This text is designed to accommodate a wide range of ages and skill levels.\n• Discovering the STM32 Microcontroller (Geoffrey Brown) This book is a hands-on manual for learning how to design systems using the STM32 F1 family of microcontrollers, focuses on developing code to utilize the various peripherals available in STM32 F1 micro-controllers and in particular the STM32VL Discovery board.\n• Mastering STM32 (Carmine Noviello) This book introduces the reader to this exciting MCU portfolio from ST Microelectronics and its official CubeHAL, showing its functionalities with a lot of examples and tutorials, assumes that you are totally new to this family of MCUs.\n• Introduction to Microcontrollers (Gunther Gridling, et al) This book has been developed for the introductory courses on microcontrollers It introduces undergraduate students to the field of microcontrollers - what they are, how they work, how they interface with their I/O components, etc.\n• Introduction to PLC Controllers (Nebojsa Matic) This basic guide will take you from the very basic concepts, to put PLC code together, all the way up to briefly explore the steps to a successful project! No previous PLC coding experience is needed to begin exploring this fascinating technological world!\n• PIC Microcontrollers - Programming in C (Milan Verle) This book provides a step-by-step guide to programming these microcontrollers (MCUs) with the C programming language. It is the perfect for entry into this world for engineers who have not worked with PICs, new professionals, students, and hobbyists.\n• PIC Microcontrollers - Programming in BASIC (Milan Verle) This book will help you learn more about programming PIC microcontrollers in BASIC with practical, common-sense instructions, real projects, clear illustrations and detailed schematics.\n• Programming dsPIC Microcontroller in PASCAL (Zoran Milivojevic) The book provides numerous practical examples with necessary connection schematics explaining the operation of temperature sensors, A/D and D/A converters, LCD and LED displays, relays, communication modules etc.\n• PIC Microcontrollers (Milan Verle) Numerous illustrations and practical examples along with detailed description of the PIC16F887 will make you enjoy your work with the PIC microcontrollers. It covers a series of exciting and fun projects.\n• Automating Manufacturing Systems with PLCs (Hugh Jack) An in depth examination of manufacturing control systems using structured design methods. Topics include ladder logic and other IEC 61131 standards, wiring, communication, analog IO, structured programming, and communications."
    },
    {
        "link": "https://instructables.com/Getting-started-with-a-8051-micro-controller",
        "document": "About: French engineer in robotics. I love Arduino projects / coding / guitar / various electronics. Oh, I like cooking also ! PS : English is not my main language, please inform me in case of grammar mistakes ! T… Hi all,\n\n\n\nI love micro-controllers projects. I use often both Arduino cards and \"naked\" AVR micro-controllers (ATTINY and ATMEGA devices) for my projects.\n\n\n\nFor my culture, I choose to study an other kind of micro-controllers, the ones based on the 8051 architecture : http://en.wikipedia.org/wiki/Intel_MCS-51 \n\nThe 8051 architecture was created by Intel in the last 70's. Ok, it's an old architecture, but very simple to understand, and easy to use. Modern micro-controllers based on this architecture are of course filled with up to date characteristics.\n\n\n\nThe advantages of these micro-controllers is that they are cheap, easy to use, and very well documented. Also, the code language and the pinout is an industry standard : It means that you can change the chip to an other one taken from an other supplier, they should work the same. The only cons is that you need to set up a new development process : new assembly language, new compiler, new programmer, new development boards... The hardest part was for me to find a simple tutorial that covers everything... As this kind of help doesn't exist, I choose to write down everything here... So, in this Instructable, we will see how to begin from scratch : how to set up the development environment, how to create sample programs and how to wire and flash the final chip.\n\n\n\nI'm not an expert with these chips, but I'm still learning...\n\n\n\nI assume that you have some knowledge in electronics and in micro-controllers programming... The process is still the same : writing the program, compile it to an HEX file, then upload it on the chip.\n\n\n\nIf you have questions / doubts, just ask. I'll try to do my best to answer...!\n\nOk, I choose to work with the AT89S52 from Atmel. I don't really remember why this one was in my stock... But this chip is very cheap : less than 2€ from a supplier. This chip has the following features: \n\nThe datasheet of the chip is here : http://www.atmel.com/Images/doc1919.pdf \n\nThis chip follows the industry-standard 80C51 instruction set and pin-out. It means that you can replace it by a compatible model from an other supplier, they should work the same way.\n\n\n\nFor this project, you will also need :\n• an arduino card (acts as a programmer and 5V power supply), \n\nIn my case, I've got a simple development board, with all the parts needed to run the AT89S52. Don't worry if you don't have it, you can do the same on a breadboard. The wiring is not as hard as it looks...!\n\nOk, the assembly language can looks strange (and I don't pretend to know everything) but here are the main instructions used for it. More information on the instruction set is available here :http://en.wikipedia.org/wiki/Intel_MCS-51#Instruc... Everything after a \";\" is a comment. A word that finishes with a \":\" is a line label. Used for jumps. Spaces are not allowed. .equ A, B : Placed at the beginning of a file, allow the programmer to define a symbol A equals to B. Ex : .equ InputButton , P3.5 means that InputButton is now attached to the P3.5 pin. MOV A,B : Put the value B into A (B can be a constant, a register, a memory address...) DJNZ register, line : Decrement and Jump if Not Zero. Decrements the register, then jump to the given line if the register contains 0. Useful to create simple loops. RET : move back to the master program. Used into a sub function called by CALL. JB bit, line : Jump if Bit set. if the specified bit is SET (so true),the program jumps to the given line. If not, moves to the next instruction. SETB bit : set the given bit to TRUE CLR bit : set the given bit to FALSE A register is simply a byte that is used to store data. The chip contains also special functions registers (SFR), used to drive the I/O ports and general configuration. The Accumulator (\"A\" in the code) is also a general-purpose register, like R0, R1 or R2. The general I/O ports of the chip are named here with numbers (unlike letters used with ATMEGA and ATTINY devices). P2 is a register byte, so the total eight individual ports. P2.0 is a bit that indicates the first individual port. The ports are form P2.0 to P2.7 You can also read the \"doc3710_C51ASM\" PDF file available in the DOC folder from the compiler zip file. Everything is explained in details : full instructions set, how to use the compiler...\n\nOk, connect the arduino card to the computer. Load the attached sketch in the editor, compile and upload it on the card. You should not get errors. \n\n (Note : the flashing process was taken from this other Instructable :https://www.instructables.com/id/ARDUINO-AS-A-8051-... Thanks ! I didn't take credits...) Follow the attached schematic to wire the AT89S52 (see the picture for more details). It's quite similar than others ATMEL micro-controllers (ATTINYs and ATMEGAs...), the main difference is the RESET pin, now pulled with a 10k resistor. Also, put the pin 31 (/EA - VPP) to 5V, it means that the chip will use it's internal memory to run the program. Connect the arduino board to the AT89S52 chip : We use the 5v pin of the arduino to feed power into the chip :\n\nOk, go back in the \"BIN\" folder. With the notepad, create a file called \"BLINK_LED.ASM\" and enter the following code : start: ; this is a line label name setb p2.0 ; setting pin p2.0 to high (so turn the led off) setb p2.1 ; setting pin p2.1 to high setb p2.2 ; setting pin p2.2 to high clr p2.5 ; setting pin 2.5 to LOW,so turn on the led lcall delay ;wait a little bit by calling the Delay function clr p2.0 ; setting p2.0 to low clr p2.1 ; so turn on the leds clr p2.2 lcall delay ;wait again jmp start ; go to the first line... in a loop delay : mov R2, #40 outer : mov R1, #200 inner : mov R0, #240 take : djnz R0, Take djnz R1, inner djnz R2, outer ret end ;end of this file, no more assembly language after As you can see, we will just blink a led to begin. How it works ? We turn off the led wired on the P2.0, P2.1 and P2.2 pins. Then we call a delay function, we turn on the leds, we wait again, and we do it again. The delay function just do a couple of loops to have dummy computing time. By putting loops together, we can wait a lot. Save the file, then drop it on the batch file. You should not have any errors or warnings. The result of the compilation is an HEX file (also attached in this step), ready to upload.\n\nOk, a little bit more complicated : we will put a LCD screen.\n\n We will use a standard 1602 LCD screen. Mine came with a nice blue back-light. Follow this wiring, the rest of the circuit is the same (you can keep the leds, if you want...) Lcd module pinout, from left to right, connector on the top : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n• pin 15 : Back-light power supply (if your module got one) Fortunately, my development board contains directly a port to connect the screen. I had to manually check the connections, as I don't have the schematics of this board. I learned almost everything on this web page : http://www.dnatechindia.com/Tutorial/8051-Tutoria... Watch out, the code on their page contains some errors. Again, compile this new file and upload it on the chip. Check the contrast pot to get a nice rendering of the letters. How the program works ? The screen is driven by sending commands. First, we initialize the screen, by setting its size, the behavior of the cursor, the font size... Then, we clear the screen, then we sent each character one by one. Sending a character or a commands works the same way : the data is loaded into the Accumulator register, then a function is called (lcd_datadisplay for the characters, lcd_command for system commands). The last part of the program contains the functions used to drive the screen, and a delay function.\n\nStep 11: What About C ? Ok, you can think that the assembly language is a bit hard to understand. If you are familiar with arduino boards, you have a knowledge in C programming. But can we use the C language to program our boards ? \n\n Maybe yes. I heard about an open-source program called SDCC (http://sdcc.sourceforge.net) (Small Device C compiler). The MCS 51 chips are supported. I'll try this out, and maybe write an Instructable on this subject. Again, all the hardware will be the same, even the flashing process will be the same, the only real difference is that we will use an other compiler to get the HEX file...\n\nOk, here we are for this Instructable. Again, I'm not an expert with this kind of chips, and I still have a small knowledge in this assembly language. But now, I am able to create something from scratch, as the entire development process is now OK. \n\n If you look on the web, you can find some development boards and other stuff. It's a great way to learn more things ! I'll try to use this chip for my projects... But the main problem will be that it's hard to find libraries and ready-made code for external modules. It's easier to use them with a modern chip, like arduino cards. Have you ideas for some great projects to make with this chip ?"
    },
    {
        "link": "https://microchip.com/en-us/products/microcontrollers-and-microprocessors/8-bit-mcus/8051-mcus",
        "document": ""
    },
    {
        "link": "https://courses.cs.washington.edu/courses/cse466/01au/Lab/C51.pdf",
        "document": ""
    },
    {
        "link": "https://8051projects.net/wiki/Keil_Embedded_C_Tutorial",
        "document": "The use of C language to program microcontrollers is becoming too common. And most of the time its not easy to buld an application in assembly which instead you can make easily in C. So Its important that you know C language for microcontroller which is commonly known as Embedded C. As we are going to use Keil C51 Compiler, hence we also call it Keil C.\n\nKeil C51 compiler adds few more keywords to the scope C Language:\n\nDescription: The variable will be stored in internal data memory of controller. example:\n\nDescription: The variable will be stored in bit addressable memory of controller. example:\n\nDescription: The variable will be stored in external RAM memory of controller. example:\n\nDescription: This keyword is used to store a constant variable in code memory. Lets say you have a big string which is not going to change anywhere in program. Wasting ram for such string will be foolish thing. So instead we will make use of the keyword \"code\" as shown in example below. example:\n\nDescription: This keyword will store the variable in paged data memory. This keyword is used occasionally. example:\n\nDescription: This keyword is used to store a variable on a defined location in ram. example:\n\nDescription: This keyword is used to define a special bit from SFR (special function register) memory. example:\n\nDescription: sfr is used to define an 8-bit special function register from sfr memory. example:\n\nDescription: This keyword is used to define a two sequential 8-bit registers in SFR memory. example:\n\nDescription: This keyword is used to define register bank for a function. User can specify register bank 0 to 3. example:\n\nDescription: This keyword will tells the compiler that function described is an interrupt service routine. C51 compiler supports interrupt functions for 32 interrupts (0-31). Use the interrupt vector address in the following table to determine the interrupt number.\n\nThere are three kind of memory models available for the user:\n\nDepending on our hardware configuration we can specify the momory models as shown below:\n\nPointers in keil C is are similar to that of standard C and can perform all the operations that are available in standard C. In addition, keil C extends the operatability of pointers to match with the 8051 Controller architecture. Keil C provides two different types of pointers:\n\nGeneric Pointers are declared same as standard C Pointers as shown below:\n\nGeneric pointers are always stored using three bytes. The first byte is the memory type, the second byte is the high-order byte of the offset, and the third byte is the low-order byte of the offset. Generic pointers maybe used to access any variable regardless of its location.\n\nMemory specific pointers are defined along with memory type to which the pointer refers to, for example:\n\nAs Memory-Specific pointers are defined with a memory type at compile time, so memory type byte as required for generic pointers is not needed. Memory-Specific pointers can be stored using 1 byte (for idata, data, bdata and pdata pointers) or 2 bytes (for code and xdata pointers).\n\nThe Code generated by keil C compiler for memory-specific pointer executes mroe quickly than the equivalent code generated for a generic pointer. This is because the memory area accessed by the pointer is known at the compile time rather at run-time. The compiler can use this information to optimize memory access. So If execution speed is your priority then it is recommended to use memory-specific pointers. Generic pointers and Memory-Specific pointers can be declared with memory area in which they are to be stored. For example:\n\nKeil C compiler provides number of extensions for standarad C function declerations. These extensions allows you to:\n• Specify a function as an interrupt procedure\n\nThese are options that you can specify along with function declaration. Memory_model: explicit memory model (Large, Compact, Small) for the function. Example:\n\nA function can be specified as an interrupt service routine using the keyword interrupt and interrupt number. The interrupt number indicates the interrupt for which the function is declared as service routine.\n\nAs 8051 vendors create new parts, more interrupts are added. Keil C51 compiler supports interrupt functions for 32 interrupts (0-31). Use the interrupt vector address in the following table to determine the interrupt number.\n\nThe interrupt function can be declared as follows:\n\nPlease make sure that interrupt service routines should not have any arguments or return type except void.\n\nIn ANSI C we have recursive function, to meet the same requirement in embedded C, we have reentrant function. These functions can be called recursively and can be called simultaneously by two or more processes. Now you might be thinking, why special definition for recursive functions?\n\nWell you must know how these functions work when they are called recursively. when a function is running there is some runtime data associated with it, like local variables associated with it etc. when the same function called recursively or two process calls same function, CPU has to maintain the state of function along with its local variables. Reentrant functions can be defined as follows:\n\nEach reentrant function has reentrant stack associated with it, which is defined by startup.A51 file. Reentrant stack area is simulated internal or external memory depending upon the memory model used:\n\nKeil or C51 provides support for real-time operating system (RTOS) RTX51 Full and RTX51 Tiny. Real-time function task are declared using _task_ and _priority_ keywords. The _task_ defines a function as real-time task. The _priority_ keyword specify the priority of task.\n\nFucntions are declared as follows:\n\nReal-time task functions must be declared with void return type and void argument list (say no arguments passed to task function).\n\nWriting First C program in Keil\n\nAs we already discussed, Keil C is not much different from a normal C program. If you know assembly, writing a C program is not a problem, only thing you have to keep in mind is forget your controller has general purpose registers, accumulators or whatever. But do not forget about Ports and other on chip peripherals and related registers to them.\n\nIn basic C, all programs have atleast one function which is entry point for your application that function is named as \\\"main\\\" function. Similarly in keil, we will have a main function, in which all your application specific work will be defined. Lets move further deep into the working of applications and programs.\n\nWhen you run your C programs in your PC or computer, you run them as a child program or process to your Operating System so when you exit your programs (exits main function of program) you come back to operating system. Whereas in case of embedded C, you do not have any operating system running in there. So you have to make sure that your program or main file should never exit. This can be done with the help of simple while(1) or for(;;) loop as they are going to run infinitely. Following layout provides a skeleton of Basic C program.\n\nWhen we are working on controller specific code, then we need to add header file for that controller. I am considering you have already gone through \"Keil Microvision\" tutorial. After project is created, add the C file to project. Now first thing you have to do is adding the header file. All you have to do is right click in editor window, it will show you correct header file for your project.\n\nFigure below shows the windows context for adding header file to your c file.\n\nIn harware specific code, we use hardware peripherals like ports, timers and uart etc. Do not forget to add header file for controller you are using, otherwise you will not be able to access registers related to peripherals. Lets write a simple code to Blink LED on Port1, Pin1.\n\nYou can now try out more programs. \"Practice makes a man perfect\".\n\nWriting C and Assembly together\n\nYou can easily interface your programs to routines written in 8051 Assembler. All you need to do is follow few programming rules, you can call assembly routines from C and vice-versa. Public variables declared in assembly modules are available to your C program.\n\nThere maybe several reasons to call an assembly routine like faster execution of program, accessing SFRs directly using assembly etc. In this part of tutorial we will discuss how to write assembly progarms that can be directly interfaced with C programs.\n\nFor any assembly routine to be called from C program, you must know how to pass parameters or arguements to fucntion and get return values from a function.\n\nC51 compiler generates objects for every program like program code, program data and constant data. These objects are stored in segments which are units of code or data memory. Segment naming is standard for C51 compiler, so every assembly program need to follow this convention.\n\nSegment names include module_name which is the name of the source file in which the object is declared. Each segment has a prefix that corresponds to memory type used for the segment. Prefix is enclosed in question marks (?). The following is the list of the standard segment name prefixes:\n\nData objects are the variables and constants you declare in your C programs. The C51 compiler generates a saperate segment for each memory type for which variable is declared. The following table lists the segment names generated for different variable data objects. Data objects segment prefix\n\nProgram onjects includes code generated for C programs functions by C51 compiler. Each function in a source module is assigned a separate code segment using the ?PR?function_name?module_name naming convention. For example, for a function name send_char in file name uart.c will have a segment name of ?PR?SEND_CHAR?UART.\n\nC51 compiler creates saperate segments for local variables that are declared within the body of a function. Segment naming conventions for different memory models are given in following tables:\n\nFunction names are modified slightly depending on type of function (functions without arguments, functions with arguments and reentrant functions). Following tables explains the segment names:\n\nC51 make use of registers and memory locations for passing parameters. By default C function pass up to three parameters in registers and further parameters are passed in fixed memory locations. You can disable parameter passing in register using NOREGPARMS keyword. Parameters are passed in fixed memory location if parameter passing in register is disabled or if there are too many parameters to fit in registers.\n\nC functions may pass parameter in registers and fixed memory locations. Following table gives an idea how registers are user for parameter passing.\n\nFollowing example explains a little more clearly the parameter passing technique:\n\nParameters passed to assembly routines in fixed memory lcoation use segments named\n\nAll parameters are assigned in this space even if they are passed using registers. Parameters are stored in the order in which they are declared in each respective segment.\n\nThe fixed memory locations used for parameters passing may be in internal data memory or external data memory depending upon the memory model used. The SMALL memory model is the most efficient and uses internal data memory for parameter segment. The COMPACT and LARGE models use external data memory for the parameter passing segments.\n\nFunction return values are always passed using CPU registers. The following table lists the possible return types and the registers used for each.\n\nFollowing example shows how these segment and function decleration is done in assembler.\n\nNow calling this above function from a C program is very simple. We make function call as normal function as shown below:"
    },
    {
        "link": "https://quora.com/Im-new-to-embedded-systems-programming-in-C-using-Code-Composer-Studio-Can-anyone-help-me-with-how-to-configure-my-code-composer-studio-environment-so-I-can-program-for-an-8051-microcontroller",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://keil.com/product/brochures/uv4.pdf",
        "document": ""
    },
    {
        "link": "https://elprocus.com/embedded-system-programming-using-keil-c-language",
        "document": "Embedded C is the most popular programming language in the software field for developing electronic gadgets. Each processor is associated with embedded software. Embedded C Programming plays a major role in performing specific functions by the processor. In our day-to-day life, we frequently use many electronic devices such as washing machines, mobile phones, digital camera and so on will work based on microcontrollers that are programmed by embedded C.\n\nThe C code written is more reliable, portable, and scalable; and in fact, much easier to understand. The first and foremost tool is the embedded software that decides the operation of an embedded system. Embedded C programming language is most frequently used for programming the microcontrollers.\n\nFor writing the program the embedded designers must have sufficient knowledge on the hardware of particular processors or controllers as the embedded C programming is a full hardware related programming technique.\n\nEarlier, many embedded applications were developed by using assembly level programming. However, they did not provide portability to overcome this problem with the advent of various high-level languages like C, COBOL, and Pascal. However, it was the C language that got extensive acceptance for embedded systems application development, and it continues to do so.\n\nThe embedded system is defined as the combination of embedded C programming software and hardware part majorly consist of microcontrollers and it is intended to perform the specific task. These types of embedded systems are being used in our daily life such as washing machines and video recorders, refrigerators and so on. The embedded system was first introduced by the 8051 microcontrollers.\n\nThe 8051 microcontroller is a basic microcontroller, it is first introduced by the ‘Intel Corporation’ since 1970. It is developed by the 8086 processor architecture. The 8051 is a family of the microcontroller, which has been developed by different manufacturers such as Philips, Atmel, dalls, and so on. The 8051 microcontrollers has been used in lots of embedded products from small children’s toys to large automotive systems.\n\nThe 8051 microcontroller is the 8-bit ‘CISC’ architecture. It consists of memories, serial communication, interrupts, input/output ports and timer/counters, built into a single integrated chip, which is programmed to control the peripheral devices which are interfaced with it. The program is stored in the RAM of the microcontroller but before writing the program, we must aware of the RAM organization of the microcontroller.\n\nEvery function is a collection of statements that perform a specific task and the collection of one or more functions is called a programming language. Every language consists of some basic elements and grammatical rules. The C language programming is designed to function with the character set, variables, data types, constants, keywords, expressions and so on are used to write a C program. All these considered under header file or library file and it is represented as\n\nThe extension of the C language is called an Embedded C programming language. As compared with above, the embedded programming in C language has some additional features such as data types and keywords and header file or library file is represented as\n\nThe “sbit” is used for declaring the single PIN of the microcontroller. For example, LED is connected to the P0.1 pin, it is not recommended to send the value to the port pin directly, first, we have to declare the pin with another variable then after we can use anywhere in the program.\n\nSyntax: sbit a=P0^1; //declares the respective pin with a variable//\n\n a=0x01; //send the value to the port pin//\n\nThe “bit” is used for checking the status of the variable.\n\nSyntax: bit c; //declares the bit variable//\n\n c=a; //a value is assigned to the c variable //\n\n if(c==1) //check the condition true or false//\n\nThe “SFR” keyword is used to access the SFR registers by another name. The SFR register defined as a special function register, it contains all peripherally related registers by indicating the address. The SFR register is declared by the SFR keyword. The SFR keyword must be in capital letters.\n\nSyntax: SFR port=0x00; //0x00 is a port0 address it is declared by port variable//\n\n Port=0x01; //then send the value to the port0//\n\n delay();\n\n port=0x00;\n\n delay();\n\nThe “volatile” keyword is the most important in embedded system development. The variable that declares with the volatile keyword value could not be changed unexpectedly. It can be used in memory-mapped peripheral registers, global variables modified by the ISRs. Without using the volatile keyword for transmitting and receiving the data, code error or an optimization error will take place.\n\nThe macro is a name it is used to declare the block of statements as a pre-processor directive. Whenever the name is used, it is replaced by the contents of the macro. The macros represent the #define. The whole port pins are defined by the macros.\n\nSyntax: #define dat Po; //the whole port is declared by a variable//\n\n dat=0x01; //data send to the port0//\n\nThe microcontroller programming will differ for each type of operating system. Even though there are many operating systems are existing such as Linux, Windows, RTOS and so on. However, RTOS has several advantages for embedded system development. This article discusses basic embedded C programming to develop embedded C programming using an 8051 microcontroller.\n\nThe LED is a semiconductor device which is used in many applications, mostly for indication purpose. It is finding a huge range of applications as indicators during the test to check the validity of results at different stages. They are very cheap and easily available in a variety of shapes, colors, and sizes. The LEDs are used to design message display boards and traffic control signal lights etc. Here the LEDs are interfaced with the PORT0 of the 8051 microcontrollers.\n\n#include<reg51.h> //header file//\n\n void main() //the program execution stat point//\n\n {\n\n unsigned int i; //data type//\n\n while(1) //for continuous loop//\n\n {\n\n P0=0x55; //send the hexa value to the port0//\n\n for(i=0;i<30000;i++) //normal delay//\n\n P0=0x3AA; //send the hexa value to the port0//\n\n for(i=0;i<30000;i++) //normal delay//\n\n }\n\n }\n\nThe 7-segment displays is the basic electronic displays, which are used in many systems to display the numeric information. It consists of eight LEDs which are connected in sequential manner so as to display digits from 0 to 9, when proper combinations of LEDs are switched on. They can display only one digit at a time.\n\n1. WAP to display the numbers form ‘0 to F’ on four 7segment displays ?\n\n2. WAP to display the numbers from ’00 to 10’ on 7segment displays ?\n\nThe delay is the one of the important factors in the application software development. However, the normal delay will not give the precious result to overcome this problem for implementing the timer delay. The timers and counters are hardware components of the microcontroller, which is used in many applications to provide the precious time delay with count pulses.The both tasks are implemented by the software technique.\n\nWAP to generate the 500us time delay using T1M2(timer1 and mode2) ?\n\nvoid main()\n\n {\n\n unsigned char i;\n\n TMOD=0x20; //set the timer mode//\n\n for(i=0i<2;i++) //double the time daly//\n\n {\n\n TL1=0x19; //set the time delay//\n\n TH1=0x00;\n\n TR1=1; //timer oN//\n\n While(TF1==0); //check the flag bit//\n\n TF1=0;\n\n }\n\n TR1=0; //timer off//\n\n }\n\nSerial communication is commonly used for transmitting and receiving the signal. The 8051 microcontroller have consist UART serial communication the signals transmitted and received by the Rx and Tx pins. The UART takes bytes of data and sends the individual bits in a sequential manner. The registers are a way to collect and store the data in the memory. UART is a half-duplex protocol. Half-duplex means transferring and receiving the data, but not at the same time.\n\n1. WAP to transmit the character ‘S’ to the serial window use 9600 as the baud rate?\n\n28800 is the maximum baud rate of the 8051 microcontroller\n\nThat baud rate ‘3’ is stored in the timers\n\n{\n\n SCON=0x50; //start the serial communication//\n\n TNOD=0x20; //selected the timer mode//\n\n TH1=3; // load the baud rate//\n\n TR1=1; //Timer ON//\n\n SBUF=’S’; //store the character in the register//\n\n while(TI==0); //check the interrupt register//\n\n TI=0;\n\n TR1=0; //OFF the timer//\n\n while(1); //continuous loop//\n\n }\n\n2. WAP to receive the data from the hyperterminal and send that data to the PORT 0 of the Microcontroller using 9600 baud?\n\n28800 is the maximum baud rate of the 8051 microcontroller\n\nThat baud rate ‘3’ is stored in the timers\n\nvoid main()\n\n {\n\n SCON=0x50; //start the serial communication//\n\n TMOD=0x20; //selected the timer mode//\n\n TH1=3; // load the baud rate//\n\n TR1=1; //Timer ON//\n\n PORT0=SBUF; //send the data from SBUF to port0//\n\n while(RI==0); //check the interrupt register//\n\n RI=0;\n\n TR1=0; //OFF the timer//\n\n while(1); //stop the program when character is received//\n\n }\n\nThe interrupt is a signal that forcing to stop the current program and execute the other program immediately. The 8051 microcontroller provide 6 interrupt, which are internal and external interrupt sources. When the interrupt occurs the microcontroller pause the current task and attend to the interrupt by executing the ISR then microcontroller returns back to the recent task.\n\nWAP to perform left shift operation when timer 0 interrupts occurs then perform the interrupt operation for the P0 in the main function?\n\nThe matrix keypad is an analog switching device, which is used in many embedded applications to allow the user to perform the necessary tasks. A matrix keypad consists of an arrangement of switches in matrix format in rows and columns. The rows and columns are connected to the microcontroller such that the row of switches are connected to one pin and switches in each column are connected to another pin, then perform the operations.\n\n1. WAP to toggle the LED by pressing the switch\n\n#include<reg51.h>\n\n sbit a=P3^0;\n\n sbit b=P3^1;\n\n sbit c=P3^2;\n\n sbit d=P3^3;\n\n void delay();\n\n void main()\n\n {\n\n while(1)\n\n {\n\n a=0;\n\n b=1;\n\n c=1;\n\n d=1;\n\n delay();\n\n a=1;\n\n b=0;\n\n c=1;\n\n d=1;\n\n void delay()\n\n {\n\n unsigned char i;\n\n TMOD=0x20; //set the timer mode//\n\n for(i=0i<2;i++) //double the time daly//\n\n {\n\n TL1=0x19; //set the time delay//\n\n TH1=0x00;\n\n TR1=1; //timer oN//\n\n While(TF1==0); //check the flag bit//\n\n TF1=0;\n\n }\n\n TR1=0; //timer off//\n\n }\n\n2. WAP to Switch ON the LED by pressing the key ‘1’ on the keypad?\n\n3. WAP to display the number 0,1,2,3,4,5 on the seven segment by pressing the respective key on the keypad?\n\nThe LCD display is an electronic device, which is frequently used in many applications for displaying the information in a text or image format. The LCD is a display that can easily show characters on its screen. The LCD display have consists 8-data lines and 3-control lines which are used to interface to the microcontroller.\n\nWAP to display the “EDGEFX KITS” on LED display ?\n\nHope this article gives a basic information about embedded system programming using 8051 microcontroller with a few example programs. For detailed embedded C programming tutorial please post your comments and queries in the comment section below."
    }
]