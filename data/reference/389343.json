[
    {
        "link": "https://flask-sqlalchemy.readthedocs.io/en/stable/quickstart",
        "document": "Flask-SQLAlchemy simplifies using SQLAlchemy by automatically handling creating, using, and cleaning up the SQLAlchemy objects you’d normally work with. While it adds a few useful features, it still works like SQLAlchemy.\n\nThis page will walk you through the basic use of Flask-SQLAlchemy. For full capabilities and customization, see the rest of these docs, including the API docs for the object.\n\nFlask-SQLAlchemy is a wrapper around SQLAlchemy. You should follow the SQLAlchemy Tutorial to learn about how to use it, and consult its documentation for detailed information about its features. These docs show how to set up Flask-SQLAlchemy itself, not how to use SQLAlchemy. Flask-SQLAlchemy sets up the engine and scoped session automatically, so you can skip those parts of the SQLAlchemy tutorial. This guide assumes you are using SQLAlchemy 2.x, which has a new API for defining models and better support for Python type hints and data classes. If you are using SQLAlchemy 1.x, see Legacy Quickstart.\n\nThe next step is to connect the extension to your Flask app. The only required Flask app config is the key. That is a connection string that tells SQLAlchemy what database to connect to. Create your Flask application object, load any config, and then initialize the extension class with the application by calling . This example connects to a SQLite database, which is stored in the app’s instance folder. # configure the SQLite database, relative to the app instance folder # initialize the app with the extension See Configuration for an explanation of connections strings and what other configuration keys are used.\n\nAfter all models and tables are defined, call to create the table schema in the database. This requires an application context. Since you’re not in a request at this point, create one manually. If you define models in other modules, you must import them before calling , otherwise SQLAlchemy will not know about them. does not update tables if they are already in the database. If you change a model’s columns, use a migration library like Alembic with Flask-Alembic or Flask-Migrate to generate migrations that update the database schema.\n\nWithin a Flask view or CLI command, you can use to execute queries and modify model data. SQLAlchemy automatically defines an method for each model that assigns any keyword arguments to corresponding database columns and other attributes. adds an object to the session, to be inserted. Modifying an object’s attributes updates the object. deletes an object. Remember to call after modifying, adding, or deleting any data. constructs a query to select data from the database. Building queries is the main feature of SQLAlchemy, so you’ll want to read its tutorial on select to learn all about it. You’ll usually use the method to get a list of results, or the method to get a single result. You may see uses of to build queries. This is an older interface for queries that is considered legacy in SQLAlchemy. Prefer using instead. See Modifying and Querying Data for more information about queries."
    },
    {
        "link": "https://flask-sqlalchemy.readthedocs.io/en/stable/config",
        "document": "Configuration is loaded from the Flask when is called. The configuration is not read again after that. Therefore, all configuration must happen before initializing the application. The database connection URI used for the default engine. It can be either a string or a SQLAlchemy instance. See below and Engine Configuration for examples. At least one of this and must be set. Changed in version 3.0: No longer defaults to an in-memory SQLite database if not set. A dict of arguments to pass to for the default engine. This takes precedence over the argument to , which can be used to set default options for all engines. Changed in version 3.0: Only applies to the default bind. A dict mapping bind keys to engine options. The value can be a string or a SQLAlchemy instance. Or it can be a dict of arguments, including the key, that will be passed to . The key can be used to configure the default bind, but and take precedence. At least one of this and must be set. The default value for and for every engine. This is useful to quickly debug the connections and queries issued from SQLAlchemy. Changed in version 3.0: Sets in addition to . If enabled, information about each query during a request will be recorded. Use to get a list of queries that were issued during the request. Changed in version 3.0: Not enabled automatically in debug or testing mode. If enabled, all , , and operations on models are recorded, then sent in and signals when is called. This adds a significant amount of overhead to every session. Prefer using SQLAlchemy’s ORM Events directly for the exact information you need.\n\nSee SQLAlchemy’s documentation on Engine Configuration for a complete description of syntax, dialects, and options. A basic database connection URL uses the following format. Username, password, host, and port are optional depending on the database type and configuration. Here are some example connection strings: SQLite does not use a user or host, so its URLs always start with _three_ slashes instead of two. The value is a file path. Absolute paths start with a _fourth_ slash (on Linux or Mac). Relative paths are relative to the Flask application’s .\n\nSome default options are set for SQLite and MySQL engines to make them more usable by default in web applications. SQLite relative file paths are relative to the Flask instance path instead of the current working directory. In-memory databases use a static pool and to work across requests. MySQL (and MariaDB) servers are configured to drop connections that have been idle for 8 hours, which can result in an error like . A default value of 2 hours (7200 seconds) is used to recreate connections before that timeout.\n\nBecause Flask-SQLAlchemy has support for multiple engines, there are rules for which config overrides other config. Most applications will only have a single database and only need to use and .\n• None If the argument is given to , it sets default options for all engines. sets the default value for both and for all engines.\n• None The options for each engine in override those defaults.\n• None overrides the key in , and overrides the key in that engine’s options."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-use-flask-sqlalchemy-to-interact-with-databases-in-a-flask-application",
        "document": "The author selected the Free and Open Source Fund to receive a donation as part of the Write for DOnations program.\n\nIn web applications, you usually need a database, which is an organized collection of data. You use a database to store and maintain persistent data that can be retrieved and manipulated efficiently. For example, in a social media application, you have a database where user data (personal information, posts, comments, followers) is stored in a way that can be efficiently manipulated. You can add data to a database, retrieve it, modify it, or delete it, depending on different requirements and conditions. In a web application, these requirements might be a user adding a new post, deleting a post, or deleting their account, which may or may not delete their posts. The actions you perform to manipulate data will depend on specific features in your application. For example, you might not want users to add posts with no titles.\n\nFlask is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. SQLAlchemy is an SQL toolkit that provides efficient and high-performing database access for relational databases. It provides ways to interact with several database engines such as SQLite, MySQL, and PostgreSQL. It gives you access to the database’s SQL functionalities. It also gives you an Object Relational Mapper (ORM), which allows you to make queries and handle data using simple Python objects and methods. Flask-SQLAlchemy is a Flask extension that makes using SQLAlchemy with Flask easier, providing you tools and methods to interact with your database in your Flask applications through SQLAlchemy.\n\nIn this tutorial, you’ll build a small student management system that demonstrates how to use the Flask-SQLAlchemy extension. You’ll use it with Flask to perform basic tasks, such as connecting to a database server, creating a table, adding data to your table, retrieving it, and updating and deleting items from your database. You’ll use SQLAlchemy with SQLite, although you can use it with other database engines too, such as PostgreSQL and MySQL. SQLite works well with Python because the Python standard library provides the module, which is used by SQLAlchemy behind the scenes to interact with SQLite databases without having to install anything. SQlite is installed on Linux systems by default, and is installed as part of the Python package on Windows.\n• A local Python 3 programming environment. Follow the tutorial for your distribution in How To Install and Set Up a Local Programming Environment for Python 3 series. In this tutorial we’ll call our project directory .\n• An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out How to Create Your First Web Application Using Flask and Python and How to Use Templates in a Flask Application.\n• An understanding of basic HTML concepts. You can review our How To Build a Website with HTML tutorial series for background knowledge.\n\nIn this step, you’ll install the necessary packages for your application.\n\nWith your virtual environment activated, use to install Flask and Flask-SQLAlchemy:\n\nOnce the installation is successfully finished, you’ll see a line similar to the following at the end of the output:\n\nWith the required Python packages installed, you’ll set up the database next.\n\nStep 2 — Setting up the Database and Model\n\nIn this step, you’ll set up your database connection, and create an SQLAlchemy database model, which is a Python class that represents the table that stores your data. You’ll initiate the database, create a table for students based on the model you’ll declare, and add a few students into your students table.\n\nOpen a file called in your directory. This file will have code for setting up the database and your Flask routes:\n\nThis file will connect to an SQLite database called , and have a class called that represents your database students table for storing student information, in addition to your Flask routes. Add the following statements at the top of :\n\nHere, you import the module, which gives you access to miscellaneous operating system interfaces. You’ll use it to construct a file path for your database file.\n\nFrom the package, you then import the necessary helpers you need for your application: the class to create a Flask application instance, the function to render templates, the object to handle requests, the function to construct URLs for routes, and the function for redirecting users. For more information on routes and templates, see How To Use Templates in a Flask Application.\n\nYou then import the class from the Flask-SQLAlchemy extension, which gives you access to all the functions and classes from SQLAlchemy, in addition to helpers, and functionality that integrates Flask with SQLAlchemy. You’ll use it to create a database object that connects to your Flask application, allowing you to create and manipulate tables using Python classes, objects, and functions without needing to use the SQL language.\n\nYou also import the helper from the module to access SQL functions. You’ll need it in your student management system to set a default creation date and time for when a student record is created.\n\nBelow the imports, you’ll set up a database file path, instantiate your Flask application, and configure and connect your application with SQLAlchemy. Add the following code:\n\nHere, you construct a path for your SQLite database file. You first define a base directory as the current directory. You use the function to get the absolute path of the current file’s directory. The special variable holds the pathname of the current file. You store the absolute path of the base directory in a variable called .\n\nYou then create a Flask application instance called , which you use to configure two Flask-SQLAlchemy configuration keys:\n• : The database URI to specify the database you want to establish a connection with. In this case, the URI follows the format . You use the function to intelligently join the base directory you constructed and stored in the variable, and the file name. This will connect to a database file in your directory. The file will be created once you initiate the database.\n• : A configuration to enable or disable tracking modifications of objects. You set it to to disable tracking and use less memory. For more, see the configuration page in the Flask-SQLAlchemy documentation.\n\nAfter configuring SQLAlchemy by setting a database URI and disabling tracking, you create a database object using the class, passing the application instance to connect your Flask application with SQLAlchemy. You store your database object in a variable called . You’ll use this object to interact with your database.\n\nWith the database connection established and the database object created, you’ll use the database object to create a database table for students, which is represented by a model — a Python class that inherits from a base class Flask-SQLAlchemy provides through the database instance you created earlier. To define a student table as a model, add the following class to your file:\n\nHere, you create a model, which inherits from the class. This represents the student table. You use the class to define columns for your table. The first argument represents the column type, and additional arguments represent column configuration.\n\nYou define the following columns for the model:\n• : The student ID. You define it as an integer with . defines this column as a primary key, which will assign it a unique value by the database for each entry (that is a student).\n• : The student’s first name. A string with a maximum length of characters. signifies that this column should not be empty.\n• : The student’s last name. A string with a maximum length of characters. signifies that this column should not be empty.\n• : The student’s email. A string with a maximum length of characters. signifies that each email should be unique for each student. signifies that this column should not be empty.\n• : The time the student record was created at in the database. You use to define it as a Python object. enables timezone support. sets the default value in the database when creating the table, so that default values are handled by the database rather than the model. You pass it the function which calls the SQL datetime function. In SQLite, it is rendered as when creating the student table.\n• : The student’s bio. indicates the column holds long texts.\n\nSee the SQLAlchemy documentation for column types other than the types you used in the preceding code block.\n\nThe special function allows you to give each object a string representation to recognize it for debugging purposes. In this case you use the student’s first name.\n\nThe file will now look as follows:\n\nNow that you’ve set the database connection and the student model, you’ll use the Flask shell to create your database and your student table based on the model.\n\nWith your virtual environment activated, set the file as your Flask application using the environment variable. Then open the Flask shell using the following command in your directory:\n\nA Python interactive shell will be opened. This special shell runs commands in the context of your Flask application, so that the Flask-SQLAlchemy functions you’ll call are connected to your application.\n\nImport the database object and the student model, and then run the function to create the tables that are associated with your models. In this case you only have one model, which means that the function call will only create one table in your database:\n\nLeave the shell running, open another terminal window and navigate to your directory. You will now see a new file called in .\n\nIf you receive an error, make sure your database URI and your model declaration are correct.\n\nAfter creating the database and student table, you’ll use the flask shell to add some students to your database through the model.\n\nUse the same flask shell you opened earlier, or open a new one with your virtual environment activated in your directory:\n\nTo add a student to your database, you’ll import the database object and the model, and create an instance of the model, passing it student data through keyword arguments as follows:\n\nThe object represents a student that will be added to the database, but this object has not been written to the database yet. Check out the object in the flask shell to see its representation string you constructed with the method:\n\nYou can get the value of columns using the class attributes you defined in the model:\n\nBecause this student has not been added to the database yet, its ID will be :\n\nTo add this student to the database, you’ll first need to add it to a database session, which manages a database transaction. Flask-SQLAlchemy provides the object through which you can manage your database changes. Add the object to the session using the method to prepare it to be written to the database:\n\nThis will issue an statement, but you won’t get an ID back because the database transaction is still not committed. To commit the transaction and apply the change to database, use the method:\n\nNow that student John is added to the database, you can get its ID:\n\nYou can also use the method to edit an item in the database. For example, you can modify the student’s email like so:\n\nUse the Flask shell to add a few more students to your database:\n\nNow, you can query all the records in the student table using the attribute with the method:\n\nAt this point, you have three students in your database. Next, you’ll create a Flask route for the index page and display all of the students in your database on it.\n\nIn this step, you’ll create a route and a template to display all the students in the database on the index page.\n\nLeave the Flask shell running and open a new terminal window.\n\nOpen your file to add a route for the index page to it:\n\nAdd the following route at the end of the file:\n\nHere, you create an view function using the decorator. In this function, you query the database and get all the students using the model with the attribute, which allows you to retrieve one or more items from the database using different methods. You use the method to get all student entries in the database. You store the query result in a variable called and pass it to a template called that you render using the helper function.\n\nBefore you create the template file on which you’ll display the existing students in the database, you’ll first create a base template, which will have all the basic HTML code other templates will also use to avoid code repetition. Then you’ll create the template file you rendered in your function. To learn more about templates, see How to Use Templates in a Flask Application.\n\nAdd the following code inside the file:\n\nThis base template has all the HTML boilerplate you’ll need to reuse in your other templates. The block will be replaced to set a title for each page, and the block will be replaced with the content of each page. The navigation bar has three links: one for the index page, which links to the view function using the helper function, one for a Create page, and one for an About page if you choose to add one to your application. You’ll edit this file later after you add a page for creating new students to make the Create link functional.\n\nNext, open a new template file. This is the template you referenced in the file:\n\nAdd the following code to it:\n\nHere, you extend the base template and replace the contents of the content block. You use an heading that also serves as a title. You use a Jinja loop in the line to go through each student in the variable that you passed from the view function to this template. You display the student ID, their first and last name, email, age, the date at which they were added to the database, and their bio.\n\nWhile in your directory with your virtual environment activated, tell Flask about the application ( in this case) using the environment variable. Then set the environment variable to to run the application in development mode and get access to the debugger. For more information about the Flask debugger, see How To Handle Errors in a Flask Application. Use the following commands to do this:\n\nWith the development server running, visit the following URL using your browser:\n\nYou’ll see the students you added to the database in a page similar to the following:\n\nYou’ve displayed the students you have in your database on the index page. Next, you’ll create a route for a student page, where you can display the details of each individual student.\n\nIn this step, you’ll use the Flask shell to query students by their ID, and create a route and a template to display the details of each student on a dedicated page.\n\nBy the end of this step, the URL will be a page that displays the first student (because it has the ID ). The URL will display the post with the associated number, if it exists.\n\nLeave the development server running and open a new terminal window.\n\nOpen the Flask shell for a demonstration of how to query students:\n\nTo query records and retrieve data from the database, Flask-SQLAlchemy provides a attribute on the model class. You can use its methods to get records with a specific filter.\n\nFor example, you can use the method with a parameter such as that matches a column in the table with an argument to retrieve a specific student:\n\nHere you retrieve all the students with as their first name. You use the method to get a list of all the results. To get the first result, which is the only result here, you can use the method:\n\nTo get a student by its ID, you can use :\n\nOr, you can use the shorter method, which allows you to retrieve a specific item using its primary key:\n\nBoth will give the same output:\n\nYou can now exit the shell:\n\nTo retrieve a student by their ID, you’ll create a new route that renders a page for each individual student. You’ll use the method Flask-SQLAlchemy provides, which is a variant of the method. The difference is that returns the value when no result matches the given ID, and returns a HTTP response. Open for modification:\n\nAdd the following route at the end of the file:\n\nHere, you use the route , with being a converter that converts the default string in the URL into an integer. And is the URL variable that will determine the student you’ll display on the page.\n\nThe ID is passed from the URL to the view function through the parameter. Inside the function, you query the students collection and retrieve a student by the ID using the method. This will save the student data in the variable if it exists, and respond with a HTTP error if no student with the given ID exists in the database.\n\nYou render a template called and pass it the student you retrieved.\n\nType the following code in this new file. This will be similar to the template, except that it will only display a single student:\n\nIn this file, you extend the base template, setting the student’s full name as a title for the page. You display the student ID, the student’s first and last name, email, age, the date of record creation, and their bio.\n\nUse your browser to navigate to the URL for the second student:\n\nYou’ll see a page similar to the following:\n\nNow, edit to make each student name link to their page:\n\nEdit the loop to look as follows:\n\nYou added an tag to the student’s full name which links to the student page using the function, passing the student ID that’s stored in to the view function.\n\nNavigate to your index page or refresh it:\n\nYou’ll now see that each student name links to the proper student page.\n\nAfter creating a page for individual students, you’ll next add a page for adding new students to the database.\n\nIn this step, you’ll add a new route to your application for adding new students to the database using web forms.\n\nYou’ll render a page with a web form where users enter the student’s data. Then you’ll handle the form submission, create an object for the new student using the model, add it to the session, then commit the transaction, similar to how you’ve added student entries in Step 2.\n\nLeave the development server running and open a new terminal window.\n\nAdd the following route at the end of the file:\n\nIn this route, you pass the tuple to the parameter to allow both GET and POST requests. GET requests are used to retrieve data from the server. POST requests are used to post data to a specific route. By default, only GET requests are allowed. When the user first requests the route using a GET request, a template file called will be rendered. You will later edit this route to handle POST requests for when users fill in and submit the web form for adding new students.\n\nAdd the following code to it:\n\nYou extend the base template, set a heading as a title, and use a tag with the attribute set to to indicate that the form will submit a POST request.\n\nYou have two text fields with the names and . You’ll use these names to access the form data the user submits in your view function later.\n\nYou have an email field with the name , a number field for the student’s age, and a text area for the student’s bio.\n\nLast, you have a Submit button at the end of the form.\n\nNow, with the development server running, use your browser to navigate to the route:\n\nYou will see an Add a New Student page with a web form and a Submit button like so:\n\nIf you fill in the form and submit it, sending a POST request to the server, nothing happens because you did not handle POST requests on the route.\n\nOpen to handle the POST request the user submits:\n\nEdit the route to look as follows:\n\nYou handle POST requests inside the condition. You extract the first name, last name, email, age, and bio the user submits from the object. You convert the age that gets passed as a string into an integer using the Python function. You construct a object using the model. You add the student object to the database session, then commit the transaction.\n\nLastly, you redirect the user to the index page where they can see the newly added student below the existing students.\n\nWith the development server running, use your browser to navigate to the route:\n\nFill in the form with some data and submit it.\n\nYou’ll be redirected to the index page where you’ll see your newly added student.\n\nNow that you have the functionality to add new students, you’ll need to add a link to the Create page in the navigation bar. Open :\n\nEdit the tag by modifying the value of the attribute for the link:\n\nRefresh your index page and you’ll notice the Create link in the navigation bar is now functional.\n\nYou now have a page with a web form for adding new students. For more on web forms, see How To Use Web Forms in a Flask Application. For a more advanced and more secure method of managing web forms, see How To Use and Validate Web Forms with Flask-WTF. Next, you’ll add a page for editing the data of existing students.\n\nIn this step, you’ll add a new page to your application for editing existing student data. You’ll add a new route to edit the data of students based on their ID.\n\nAdd the following route to the end of the file. This fetches the student entry you want to edit using its ID. It extracts the new student data submitted via a web form you’ll will create later. Then it edits the student data, and redirects the user to the index page:\n\nHere, you have the route that accepts both POST and GET methods, with as a URL variable that passes the ID to the view function.\n\nYou use the query method on the model to get the student associated with the given student ID. This will respond with a error in case no student with the given ID exists in the database.\n\nIf the given ID has a student associated with it, code execution continues to the condition. If the request was a GET request, meaning that the user did not submit a form, then this condition is false, and the code inside it will be skipped to the line . This renders an template, passing it the student object you got from the database, allowing you to fill the student web form with current student data. You will create this template later.\n\nWhen a user edits student data and submits the form, the code inside the is executed. You extract the submitted student data from the object into corresponding variables. You set each attribute of the object to the newly submitted data to change column values as you’ve done in Step 2. If no change was performed on a field on the web form, the value of that column will stay the same in the database.\n\nAfter you set the student data to the newly submitted data, you add the object to the database session, then you commit the changes. Lastly, you redirect the user to the index page.\n\nNext, you need to create a page where users can do the editing. Open a new template:\n\nThis new file will have a web form similar to the one that’s in the file with current student data as default values for the fields. Add the following code inside it:\n\nThe title has the student’s first name and last name. The attribute of each input field and the value of the bio text area are set to the corresponding value in the object you passed from the view function to the template.\n\nNow, navigate to the following URL to edit the first student’s details:\n\nYou will see a page similar to the following:\n\nEdit the student’s data and submit the form. You’ll be redirected to the index page, and the student’s information will be updated.\n\nNext, you’ll add an Edit button below each student on the index page to link to their edit page. Open the template file:\n\nEdit the loop in this file to look exactly like the following:\n\nHere you add an tag to link to the view function, passing in the value to link to the edit page of each student with an Edit link.\n\nYou now have a page for editing existing students. Next, you’ll add a Delete button to delete students from the database.\n\nIn this step, you’ll add a new route and Delete button for deleting existing students.\n\nFirst, you’ll add a new route that accepts POST requests. Your new view function will receive the ID of the student you want to delete, pass the ID to the query method on the model to get it if it exists, or respond with a page if no student with the given ID was found on the database.\n\nAdd the following route to the end of the file:\n\nHere, instead of using the usual decorator, you use the decorator introduced in Flask version 2.0.0, which added shortcuts for common HTTP methods. For example, is a shortcut for . This means that this view function only accepts POST requests, and navigating to the route on your browser will return a error, because web browsers default to GET requests. To delete a student, the user clicks on a button that sends a POST request to this route.\n\nThis view function receives the ID of the student to be deleted via the URL variable. You use the method to get a student and save it in a variable, or respond with a in case the student doesn’t exist. You use the method on the database session in the line , passing it the student object. This sets up the session to delete the student whenever the transaction is committed. Because you don’t need to perform any other modifications, you directly commit the transaction using . Lastly, you redirect the user to the index page.\n\nNext, edit the template to add a Delete Student button:\n\nEdit the loop by adding a new tag directly below the Edit link:\n\nHere, you have a web form that submits a POST request to the view function. You pass as an argument for the parameter to specify the student entry to be deleted. You use the method function available in web browsers to display a confirmation message before submitting the request.\n\nYou’ll see a Delete Student button below each student entry. Click on it, and confirm the deletion. You’ll be redirected to the index page, and the student will no longer be there.\n\nYou now have a way of deleting students from the database in your student management application.\n\nYou built a small Flask web application for managing students using Flask and Flask-SQLAlchemy with an SQLite database. You learned how to connect to your database, set up database models that represent your tables, add items to your database, query your table, and modify database data.\n\nUsing SQLAlchemy in your application allows you to use Python classes and objects to manage your SQL database. Instead of SQLite, you can use another database engine, and other than the configuration responsible for the connection, you don’t need to change anything in your core application code. That allows you to move from one SQL database engine to another with minimal code change. See the Flask-SQLAlchemy documentation for more information.\n\nIf you would like to read more about Flask, check out the other tutorials in the How To Build Web Applications with Flask series."
    },
    {
        "link": "https://stackoverflow.com/questions/64277544/how-to-get-a-handle-to-the-initialized-database-from-a-flask-application-with-sq",
        "document": "I would like to add data to a database with Flask-SQLAlchemy without the Flask app running.\n\nIs there a way to get back from the app after the app and the database have been initialized.\n\nMy code looks like\n\nAnd what I would like to do is something like\n\nBasically I would like to do what's described here:\n\nAnother disadvantage is that Flask-SQLAlchemy makes using the database outside of a Flask context difficult. This is because, with FLask-SQLAlchemy, the database connection, models, and app are all located within the app.py file. Having models within the app file, we have limited ability to interact with the database outside of the app. This makes loading data outside of your app difficult. Additionally, this makes it hard to retrieve data outside of the Flask context."
    },
    {
        "link": "https://flask.palletsprojects.com/en/stable/tutorial/database",
        "document": "The application will use a SQLite database to store users and posts. Python comes with built-in support for SQLite in the module.\n\nSQLite is convenient because it doesn’t require setting up a separate database server and is built-in to Python. However, if concurrent requests try to write to the database at the same time, they will slow down as each write happens sequentially. Small applications won’t notice this. Once you become big, you may want to switch to a different database.\n\nThe tutorial doesn’t go into detail about SQL. If you are not familiar with it, the SQLite docs describe the language.\n\nThe first thing to do when working with a SQLite database (and most other Python database libraries) is to create a connection to it. Any queries and operations are performed using the connection, which is closed after the work is finished. In web applications this connection is typically tied to the request. It is created at some point when handling a request, and closed before the response is sent. is a special object that is unique for each request. It is used to store data that might be accessed by multiple functions during the request. The connection is stored and reused instead of creating a new connection if is called a second time in the same request. is another special object that points to the Flask application handling the request. Since you used an application factory, there is no application object when writing the rest of your code. will be called when the application has been created and is handling a request, so can be used. establishes a connection to the file pointed at by the configuration key. This file doesn’t have to exist yet, and won’t until you initialize the database later. tells the connection to return rows that behave like dicts. This allows accessing the columns by name. checks if a connection was created by checking if was set. If the connection exists, it is closed. Further down you will tell your application about the function in the application factory so that it is called after each request.\n\nIn SQLite, data is stored in tables and columns. These need to be created before you can store and retrieve data. Flaskr will store users in the table, and posts in the table. Create a file with the SQL commands needed to create empty tables: Add the Python functions that will run these SQL commands to the file: \"\"\"Clear the existing data and create new tables.\"\"\" opens a file relative to the package, which is useful since you won’t necessarily know where that location is when deploying the application later. returns a database connection, which is used to execute the commands read from the file. defines a command line command called that calls the function and shows a success message to the user. You can read Command Line Interface to learn more about writing commands. The call to tells Python how to interpret timestamp values in the database. We convert the value to a .\n\nThe and functions need to be registered with the application instance; otherwise, they won’t be used by the application. However, since you’re using a factory function, that instance isn’t available when writing the functions. Instead, write a function that takes an application and does the registration. tells Flask to call that function when cleaning up after returning the response. adds a new command that can be called with the command. Import and call this function from the factory. Place the new code at the end of the factory function before returning the app.\n\nNow that has been registered with the app, it can be called using the command, similar to the command from the previous page. If you’re still running the server from the previous page, you can either stop the server, or run this command in a new terminal. If you use a new terminal, remember to change to your project directory and activate the env as described in Installation. There will now be a file in the folder in your project."
    },
    {
        "link": "https://flask-sqlalchemy.readthedocs.io/en/stable/config",
        "document": "Configuration is loaded from the Flask when is called. The configuration is not read again after that. Therefore, all configuration must happen before initializing the application. The database connection URI used for the default engine. It can be either a string or a SQLAlchemy instance. See below and Engine Configuration for examples. At least one of this and must be set. Changed in version 3.0: No longer defaults to an in-memory SQLite database if not set. A dict of arguments to pass to for the default engine. This takes precedence over the argument to , which can be used to set default options for all engines. Changed in version 3.0: Only applies to the default bind. A dict mapping bind keys to engine options. The value can be a string or a SQLAlchemy instance. Or it can be a dict of arguments, including the key, that will be passed to . The key can be used to configure the default bind, but and take precedence. At least one of this and must be set. The default value for and for every engine. This is useful to quickly debug the connections and queries issued from SQLAlchemy. Changed in version 3.0: Sets in addition to . If enabled, information about each query during a request will be recorded. Use to get a list of queries that were issued during the request. Changed in version 3.0: Not enabled automatically in debug or testing mode. If enabled, all , , and operations on models are recorded, then sent in and signals when is called. This adds a significant amount of overhead to every session. Prefer using SQLAlchemy’s ORM Events directly for the exact information you need.\n\nSee SQLAlchemy’s documentation on Engine Configuration for a complete description of syntax, dialects, and options. A basic database connection URL uses the following format. Username, password, host, and port are optional depending on the database type and configuration. Here are some example connection strings: SQLite does not use a user or host, so its URLs always start with _three_ slashes instead of two. The value is a file path. Absolute paths start with a _fourth_ slash (on Linux or Mac). Relative paths are relative to the Flask application’s .\n\nSome default options are set for SQLite and MySQL engines to make them more usable by default in web applications. SQLite relative file paths are relative to the Flask instance path instead of the current working directory. In-memory databases use a static pool and to work across requests. MySQL (and MariaDB) servers are configured to drop connections that have been idle for 8 hours, which can result in an error like . A default value of 2 hours (7200 seconds) is used to recreate connections before that timeout.\n\nBecause Flask-SQLAlchemy has support for multiple engines, there are rules for which config overrides other config. Most applications will only have a single database and only need to use and .\n• None If the argument is given to , it sets default options for all engines. sets the default value for both and for all engines.\n• None The options for each engine in override those defaults.\n• None overrides the key in , and overrides the key in that engine’s options."
    },
    {
        "link": "https://devcamp.com/trails/python-api-development-with-flask/campsites/hello-flask/guides/creating-sqlite-database-flask-sqlalchemy",
        "document": "In the last guide, we installed a number of dependencies that will allow our application to work with a database, as well as being able to give us the ability to output API data that comes in from that database.\n\nNOTE: As of November 2022, you will need to use Flask's application context provider to instantiate your SQL database as you see toward the end of the lesson (either SQLite like in this lesson or other SQL formats when you are building and deploying projects). The most direct way to do this is to use the \"with\" keyword in a Python REPL in conjunction with the context provider (be sure to indent last line and press enter more than once if needed to get code to execute):\n\nNow in this guide, what we're going to do, and just be prepared, this one is going to be a little longer and it's also going to be a little bit complicated if you've never done it before. What my recommendation would be to follow along and see what gets built out. Don't worry about understanding everything that we're going to talk about.\n\nSimply look at this as a high-level type of understanding, and try to have that for building out what we're going to do here. What we're going to do is we're going to programmatically create a database table, and we're going to use a pretty basic database.\n\nWe are not going to use or anything like . , or . We're going to use what is called . SQLite is a very light-weight database. It's what's called an , and that means that we're going to be able to not have to worry about setting up an entire development environment for a database like we would have to do with my SQL or Postgres.\n\nInstead, we're going to be able to simply create a file that will function exactly like how a database would. That's what we do in this guide and we're going to create what is called a . That means we are going to define the table that we want to work with, and then we are going to allow that code to generate the table for us.\n\nNow the first thing I'm going to do is, we don't need this or anything like that here anymore. We're going to be building now our own , so let's just remove that just so it doesn't get in the way.\n\nThe next thing we're going to do is we're going to integrate with the file system. So we need to be able to save our database to our project. In order to do that, if you remember back on , we imported the which stands for operating system. So now we can work with it.\n\nI'm going to start off by creating a variable here called . This is going to stand for the of our application because if we don't know what the base directory is then flask isn't going to know where to save our SQLite table to. I'm going to start off with this, and I'm going to call , our operating system library, and then say:\n\nstands for and then that is a function. So we're going to pass in an argument and that is going to be:\n\nThis is going to at a high-level, if that looks really weird and you've never seen this before, all we're doing is we're telling in our server or in our where the application is located so that it knows where to place our SQLite database. From here I can say:\n\nThen I'm going to use this dictionary syntax. Now, this is technically not a dictionary. It is a configuration variable, but you can think of it as performing a look up and then setting a value in our application. So I'm gonna say:\n\nMake sure that you spell it, and this is all in caps. Make sure this is spelled correctly, I had one time where I did this, and I had the weirdest bug come up. It was because one of the letters here was in lowercase, and that was very hard to see because it was the L in and that just made for a very frustrating while and figuring that out.\n\nSo this is all in upper case . Now, this is a specific name. This is something inside of our system, and it has to be set exactly like this or else the SQLite database is not going to know where to go or what the values are.\n\nNow that you have that, we're going to pass in a string here. So I'm going to say:\n\nWhat we're doing here is we're saying that we want to create a database. We need to pass in the base directory that we want it to go, and then we want it to be named . Now that we have that, we can create a database object. So I'm going to say:\n\nNow now we're going to work with . So I'm going to say:\n\nI know that may look a little weird if you've never seen it before. Just know that what we're doing is we're making it possible to create a , and now we've instantiated a database object and a marshmallow object. Now what we can do is we can create the schema for our table, so I'm going to say::\n\nI know we haven't really talked about the type of application we're going to build out, mainly because you can build anything that you want in this particular project. What we're working through are just the basic fundamentals of how flask works, and so we're not going to be able to use this in a production application. We'll do that in a future project. For right now what I think a good example would be to create a little learning management system.\n\nWe're going to have an that has guides, and the guide is going to have two columns. It's going to have a title and it's going to have content. So right here I'm going to say , this is going to inherit from (db.Model). You may notice this call right here is calling this object, the object that we created on .\n\nSo we're saying that , and this whole class, is going to inherit from that model. Now we're going to add three database columns, so this is where we're saying this is how we want our database to look like. I'm going to create an and reference that database object again. So I'm going to say:\n\nWhat this means is this is going to be a built-in column. We're never going to reference this except for database look-up, so we're never going to have to set this. It's going to be set automatically. This is a syntax that's SQL Alchemy uses where you use the database object that we created. You say that we want to add a new column to that object. It has a data type of integer and it's a .\n\nNow if you're not familiar with the way databases work, or you don't have a lot of experience with it, what a primary key does is it allows you to have some nice built-in functionality.\n\nThe two key items that are primary key does for you is a primary key will make sure it's always unique. So every guide is going to have a unique ID associated with it. The other thing is that this ID will automatically increment, so every time that our API creates a new record in the database it is going to increment.\n\nSo the first guide that gets created is automatically going to have an ID of The next one is going to have an ID of , and so on and so forth. That's our first one. Now let's create a title, and I'm going to say:\n\nThen inside of the , I want this to be an integer. I want this to be of the string data type, and for this let's say that we want titles to be 100 characters long. For this specific use case, it's not that important, but we'll just say we're limiting it at , and then we want this to be . Also, it looks like I have another little encoding issue here.\n\nYou shouldn't run into that if you are on vs code or sublime text. It is just something with how my system set up with VIM. So I have this title and now I'm going to have one more column here. It's going to be called . For this one, let's imagine we're Twitter, and we want this to be characters.\n\nIt's going to be a string with that many characters, and we do not want this to be unique either. That is our basic schema.\n\nNow in order to, whenever a guide is called, We need to be able to have a constructor. So we're going to use the (2 underscores before and after) and method. I' going to say:\n\nThen here we're just going to set the value. So here we say:\n\nNotice that we didn't have to do the same thing for the ID because that happens automatically. That's all we need to do for our guide. Now let's go and let's create the schema class itself, so I'm going to say:\n\nThen here we're just going to set the value. So here we say:\n\nThen let's pass in marshmallow. If you remember that marshmallow library, that's what allows us to create the schema with SQL Alchemy. So I can say: , and inside of here we're going to nest another class, and it's going to be called: . What we do here is we're going to use a tuple to expose the fields that we want access to. In this case, it will be:\n\nThat looks really weird. Do not worry. What we're working through right here is just some base set up things that are specific to SQL Alchemy. If it looks weird that's perfectly fine. I remember the first time that I started working with it. It was a very different type of syntax.\n\nPart of the reason why I wanted to create this kind of example of a project before we get into more production ones, is so that you are able to go through and practice with this a few times.\n\nThe more times you do it you're going to start setting these kinds of things up very quickly, but for right now, I do realize that it's probably confusing and that's perfectly fine. Don't feel bad if some of this looks very foreign to you, because it definitely did for me.\n\nNow that we have that, what we need to do now is instantiate the . I'm going to create two variables here. One is going to be when we're working with a single guide, and another is going to be when we're working with multiples. So I'm going to start off by saying:\n\nThat is everything that we need, I believe, in order to get this working. So let's save this, and I'm going to start up a . Make sure that you have running because this is going to be something specific to the project. Now I'm going to say: . So that , that is the variable that's the object we've created. That's a SQL Alchemy object.\n\nSo you're going to hit run, and it might give you a little warning. That's fine, as long as it doesn't give you an error then you are fine.\n\nNow, I'm going to say: . That's a function, so call it with a at the end. Hit , and as long as you don't get any error there, you should be fine. Now let's close it off. The REPL session that is, with . Now if you type , now you can see that we have a new file here called .\n\nWhat we've done, and if you look at this file, it's not really a thing that you can look at. You can see just as all these weird types of characters you're not really meant for looking at this file. You can see a few things you can see that we have an you have a and you have right there.\n\nThat's kind of cool, and it even has all of our values, such as a title having a 100 characters, and a content having 144. That means that all of our commands worked. Let's review it really quickly because I do realize this may be very foreign to you. Now that you've seen the end result, and you've seen what gets created, maybe the first part of what we did might be a little bit more clear.\n\nLet's just take that line-by-line. First thing that we did is, we created this . That's just us going to the operating system, and asking the computer where is the application located. This is the application's base directory. From there we called our app object, and remember that is our .\n\nWe said: I want you to configure the SQL Alchemy Database URI. So that is going to add whatever value we set it to. It's going to add that to our application, and then SQLAlchemy is going to look up that. Very similar to how dictionaries work.\n\nSo it's going to look for the specific key, and it's going to see if it's set, then it's going to go and look for that value. What we did is we said we want to create an SQLite location here, and we want to pass in the path of our base directory, and then we want to create an embedded database of .\n\nFrom there, we instantiated a new database object with SQL Alchemy, and remember what SQL Alchemy is, it gives us a programmatic way of interacting with the database. It created, right here, an object for us, and that object allowed us to perform tasks such as creating this guide table. Then creating the guide schema, and everything that we did from . That is what we're doing there.\n\nThen the , this marshmallow, allows us to have schema. This adds structure to the database. Next, we created a class where we passed in, so our guide inherits from , and then we created those three columns, their data types, and some of the values associated with them. We created a constructor here, where we set the title and the content.\n\nThen we created the schema. This is really just some boilerplate code that allows us to see what values we have access to. So we have access to the title and to the content, and then from there we just instantiated it. We created a single guide schema and then a multiple guides schema. That is the only difference between those two.\n\nGreat job if you went through that. Do not worry if it's not exactly clear on every step of it. I definitely recommend that you go through it a few times, and read some of the documentation until it really becomes clear. Good job if you did, because we have created our first database table, and now with this in place, we're finally ready to build out our API."
    },
    {
        "link": "https://stackoverflow.com/questions/78833005/how-to-properly-change-the-database-uri-in-flask-sqlalchemy-for-failover-handlin",
        "document": "I am using Flask-SQLAlchemy to connect to a MariaDB database. I've configured the database URI in my .env file. I want to implement a failover mechanism so that if the connection to MariaDB fails, it switches to an SQLite database for testing purposes.\n\nHere is the code I'm using to set up the database:\n\nNote: My variable db = SQLAlchemy() is located in a folder named models. Additionally, when my application context attempts to use db.create_all(), the exception occurs but within the exception handling, it still uses the same URI or in other cases, it says that a connection already exists and that I should use that one for Flask.\n\nWhat I tried: I configured SQLALCHEMY_DATABASE_URI to switch to SQLite if the MariaDB Server connection fails. I also called db.engine.dispose() to release the current engine and reinitialized SQLAlchemy and Migrate after changing the URI.\n\nWhat I expected to happen: I expected that if the connection to MariaDB Server fails, the application would switch to using SQLite as specified in SQLALCHEMY_DATABASE_URI, and db.create_all() would work with the new SQLite database.\n\nWhat actually resulted: The application still tries to connect to MariaDB uri and gives an error stating that a connection fail, or already exists or that it should use the existing connection, even though the URI was changed to SQLite in the exception handling."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-use-flask-sqlalchemy-to-interact-with-databases-in-a-flask-application",
        "document": "The author selected the Free and Open Source Fund to receive a donation as part of the Write for DOnations program.\n\nIn web applications, you usually need a database, which is an organized collection of data. You use a database to store and maintain persistent data that can be retrieved and manipulated efficiently. For example, in a social media application, you have a database where user data (personal information, posts, comments, followers) is stored in a way that can be efficiently manipulated. You can add data to a database, retrieve it, modify it, or delete it, depending on different requirements and conditions. In a web application, these requirements might be a user adding a new post, deleting a post, or deleting their account, which may or may not delete their posts. The actions you perform to manipulate data will depend on specific features in your application. For example, you might not want users to add posts with no titles.\n\nFlask is a lightweight Python web framework that provides useful tools and features for creating web applications in the Python Language. SQLAlchemy is an SQL toolkit that provides efficient and high-performing database access for relational databases. It provides ways to interact with several database engines such as SQLite, MySQL, and PostgreSQL. It gives you access to the database’s SQL functionalities. It also gives you an Object Relational Mapper (ORM), which allows you to make queries and handle data using simple Python objects and methods. Flask-SQLAlchemy is a Flask extension that makes using SQLAlchemy with Flask easier, providing you tools and methods to interact with your database in your Flask applications through SQLAlchemy.\n\nIn this tutorial, you’ll build a small student management system that demonstrates how to use the Flask-SQLAlchemy extension. You’ll use it with Flask to perform basic tasks, such as connecting to a database server, creating a table, adding data to your table, retrieving it, and updating and deleting items from your database. You’ll use SQLAlchemy with SQLite, although you can use it with other database engines too, such as PostgreSQL and MySQL. SQLite works well with Python because the Python standard library provides the module, which is used by SQLAlchemy behind the scenes to interact with SQLite databases without having to install anything. SQlite is installed on Linux systems by default, and is installed as part of the Python package on Windows.\n• A local Python 3 programming environment. Follow the tutorial for your distribution in How To Install and Set Up a Local Programming Environment for Python 3 series. In this tutorial we’ll call our project directory .\n• An understanding of basic Flask concepts, such as routes, view functions, and templates. If you are not familiar with Flask, check out How to Create Your First Web Application Using Flask and Python and How to Use Templates in a Flask Application.\n• An understanding of basic HTML concepts. You can review our How To Build a Website with HTML tutorial series for background knowledge.\n\nIn this step, you’ll install the necessary packages for your application.\n\nWith your virtual environment activated, use to install Flask and Flask-SQLAlchemy:\n\nOnce the installation is successfully finished, you’ll see a line similar to the following at the end of the output:\n\nWith the required Python packages installed, you’ll set up the database next.\n\nStep 2 — Setting up the Database and Model\n\nIn this step, you’ll set up your database connection, and create an SQLAlchemy database model, which is a Python class that represents the table that stores your data. You’ll initiate the database, create a table for students based on the model you’ll declare, and add a few students into your students table.\n\nOpen a file called in your directory. This file will have code for setting up the database and your Flask routes:\n\nThis file will connect to an SQLite database called , and have a class called that represents your database students table for storing student information, in addition to your Flask routes. Add the following statements at the top of :\n\nHere, you import the module, which gives you access to miscellaneous operating system interfaces. You’ll use it to construct a file path for your database file.\n\nFrom the package, you then import the necessary helpers you need for your application: the class to create a Flask application instance, the function to render templates, the object to handle requests, the function to construct URLs for routes, and the function for redirecting users. For more information on routes and templates, see How To Use Templates in a Flask Application.\n\nYou then import the class from the Flask-SQLAlchemy extension, which gives you access to all the functions and classes from SQLAlchemy, in addition to helpers, and functionality that integrates Flask with SQLAlchemy. You’ll use it to create a database object that connects to your Flask application, allowing you to create and manipulate tables using Python classes, objects, and functions without needing to use the SQL language.\n\nYou also import the helper from the module to access SQL functions. You’ll need it in your student management system to set a default creation date and time for when a student record is created.\n\nBelow the imports, you’ll set up a database file path, instantiate your Flask application, and configure and connect your application with SQLAlchemy. Add the following code:\n\nHere, you construct a path for your SQLite database file. You first define a base directory as the current directory. You use the function to get the absolute path of the current file’s directory. The special variable holds the pathname of the current file. You store the absolute path of the base directory in a variable called .\n\nYou then create a Flask application instance called , which you use to configure two Flask-SQLAlchemy configuration keys:\n• : The database URI to specify the database you want to establish a connection with. In this case, the URI follows the format . You use the function to intelligently join the base directory you constructed and stored in the variable, and the file name. This will connect to a database file in your directory. The file will be created once you initiate the database.\n• : A configuration to enable or disable tracking modifications of objects. You set it to to disable tracking and use less memory. For more, see the configuration page in the Flask-SQLAlchemy documentation.\n\nAfter configuring SQLAlchemy by setting a database URI and disabling tracking, you create a database object using the class, passing the application instance to connect your Flask application with SQLAlchemy. You store your database object in a variable called . You’ll use this object to interact with your database.\n\nWith the database connection established and the database object created, you’ll use the database object to create a database table for students, which is represented by a model — a Python class that inherits from a base class Flask-SQLAlchemy provides through the database instance you created earlier. To define a student table as a model, add the following class to your file:\n\nHere, you create a model, which inherits from the class. This represents the student table. You use the class to define columns for your table. The first argument represents the column type, and additional arguments represent column configuration.\n\nYou define the following columns for the model:\n• : The student ID. You define it as an integer with . defines this column as a primary key, which will assign it a unique value by the database for each entry (that is a student).\n• : The student’s first name. A string with a maximum length of characters. signifies that this column should not be empty.\n• : The student’s last name. A string with a maximum length of characters. signifies that this column should not be empty.\n• : The student’s email. A string with a maximum length of characters. signifies that each email should be unique for each student. signifies that this column should not be empty.\n• : The time the student record was created at in the database. You use to define it as a Python object. enables timezone support. sets the default value in the database when creating the table, so that default values are handled by the database rather than the model. You pass it the function which calls the SQL datetime function. In SQLite, it is rendered as when creating the student table.\n• : The student’s bio. indicates the column holds long texts.\n\nSee the SQLAlchemy documentation for column types other than the types you used in the preceding code block.\n\nThe special function allows you to give each object a string representation to recognize it for debugging purposes. In this case you use the student’s first name.\n\nThe file will now look as follows:\n\nNow that you’ve set the database connection and the student model, you’ll use the Flask shell to create your database and your student table based on the model.\n\nWith your virtual environment activated, set the file as your Flask application using the environment variable. Then open the Flask shell using the following command in your directory:\n\nA Python interactive shell will be opened. This special shell runs commands in the context of your Flask application, so that the Flask-SQLAlchemy functions you’ll call are connected to your application.\n\nImport the database object and the student model, and then run the function to create the tables that are associated with your models. In this case you only have one model, which means that the function call will only create one table in your database:\n\nLeave the shell running, open another terminal window and navigate to your directory. You will now see a new file called in .\n\nIf you receive an error, make sure your database URI and your model declaration are correct.\n\nAfter creating the database and student table, you’ll use the flask shell to add some students to your database through the model.\n\nUse the same flask shell you opened earlier, or open a new one with your virtual environment activated in your directory:\n\nTo add a student to your database, you’ll import the database object and the model, and create an instance of the model, passing it student data through keyword arguments as follows:\n\nThe object represents a student that will be added to the database, but this object has not been written to the database yet. Check out the object in the flask shell to see its representation string you constructed with the method:\n\nYou can get the value of columns using the class attributes you defined in the model:\n\nBecause this student has not been added to the database yet, its ID will be :\n\nTo add this student to the database, you’ll first need to add it to a database session, which manages a database transaction. Flask-SQLAlchemy provides the object through which you can manage your database changes. Add the object to the session using the method to prepare it to be written to the database:\n\nThis will issue an statement, but you won’t get an ID back because the database transaction is still not committed. To commit the transaction and apply the change to database, use the method:\n\nNow that student John is added to the database, you can get its ID:\n\nYou can also use the method to edit an item in the database. For example, you can modify the student’s email like so:\n\nUse the Flask shell to add a few more students to your database:\n\nNow, you can query all the records in the student table using the attribute with the method:\n\nAt this point, you have three students in your database. Next, you’ll create a Flask route for the index page and display all of the students in your database on it.\n\nIn this step, you’ll create a route and a template to display all the students in the database on the index page.\n\nLeave the Flask shell running and open a new terminal window.\n\nOpen your file to add a route for the index page to it:\n\nAdd the following route at the end of the file:\n\nHere, you create an view function using the decorator. In this function, you query the database and get all the students using the model with the attribute, which allows you to retrieve one or more items from the database using different methods. You use the method to get all student entries in the database. You store the query result in a variable called and pass it to a template called that you render using the helper function.\n\nBefore you create the template file on which you’ll display the existing students in the database, you’ll first create a base template, which will have all the basic HTML code other templates will also use to avoid code repetition. Then you’ll create the template file you rendered in your function. To learn more about templates, see How to Use Templates in a Flask Application.\n\nAdd the following code inside the file:\n\nThis base template has all the HTML boilerplate you’ll need to reuse in your other templates. The block will be replaced to set a title for each page, and the block will be replaced with the content of each page. The navigation bar has three links: one for the index page, which links to the view function using the helper function, one for a Create page, and one for an About page if you choose to add one to your application. You’ll edit this file later after you add a page for creating new students to make the Create link functional.\n\nNext, open a new template file. This is the template you referenced in the file:\n\nAdd the following code to it:\n\nHere, you extend the base template and replace the contents of the content block. You use an heading that also serves as a title. You use a Jinja loop in the line to go through each student in the variable that you passed from the view function to this template. You display the student ID, their first and last name, email, age, the date at which they were added to the database, and their bio.\n\nWhile in your directory with your virtual environment activated, tell Flask about the application ( in this case) using the environment variable. Then set the environment variable to to run the application in development mode and get access to the debugger. For more information about the Flask debugger, see How To Handle Errors in a Flask Application. Use the following commands to do this:\n\nWith the development server running, visit the following URL using your browser:\n\nYou’ll see the students you added to the database in a page similar to the following:\n\nYou’ve displayed the students you have in your database on the index page. Next, you’ll create a route for a student page, where you can display the details of each individual student.\n\nIn this step, you’ll use the Flask shell to query students by their ID, and create a route and a template to display the details of each student on a dedicated page.\n\nBy the end of this step, the URL will be a page that displays the first student (because it has the ID ). The URL will display the post with the associated number, if it exists.\n\nLeave the development server running and open a new terminal window.\n\nOpen the Flask shell for a demonstration of how to query students:\n\nTo query records and retrieve data from the database, Flask-SQLAlchemy provides a attribute on the model class. You can use its methods to get records with a specific filter.\n\nFor example, you can use the method with a parameter such as that matches a column in the table with an argument to retrieve a specific student:\n\nHere you retrieve all the students with as their first name. You use the method to get a list of all the results. To get the first result, which is the only result here, you can use the method:\n\nTo get a student by its ID, you can use :\n\nOr, you can use the shorter method, which allows you to retrieve a specific item using its primary key:\n\nBoth will give the same output:\n\nYou can now exit the shell:\n\nTo retrieve a student by their ID, you’ll create a new route that renders a page for each individual student. You’ll use the method Flask-SQLAlchemy provides, which is a variant of the method. The difference is that returns the value when no result matches the given ID, and returns a HTTP response. Open for modification:\n\nAdd the following route at the end of the file:\n\nHere, you use the route , with being a converter that converts the default string in the URL into an integer. And is the URL variable that will determine the student you’ll display on the page.\n\nThe ID is passed from the URL to the view function through the parameter. Inside the function, you query the students collection and retrieve a student by the ID using the method. This will save the student data in the variable if it exists, and respond with a HTTP error if no student with the given ID exists in the database.\n\nYou render a template called and pass it the student you retrieved.\n\nType the following code in this new file. This will be similar to the template, except that it will only display a single student:\n\nIn this file, you extend the base template, setting the student’s full name as a title for the page. You display the student ID, the student’s first and last name, email, age, the date of record creation, and their bio.\n\nUse your browser to navigate to the URL for the second student:\n\nYou’ll see a page similar to the following:\n\nNow, edit to make each student name link to their page:\n\nEdit the loop to look as follows:\n\nYou added an tag to the student’s full name which links to the student page using the function, passing the student ID that’s stored in to the view function.\n\nNavigate to your index page or refresh it:\n\nYou’ll now see that each student name links to the proper student page.\n\nAfter creating a page for individual students, you’ll next add a page for adding new students to the database.\n\nIn this step, you’ll add a new route to your application for adding new students to the database using web forms.\n\nYou’ll render a page with a web form where users enter the student’s data. Then you’ll handle the form submission, create an object for the new student using the model, add it to the session, then commit the transaction, similar to how you’ve added student entries in Step 2.\n\nLeave the development server running and open a new terminal window.\n\nAdd the following route at the end of the file:\n\nIn this route, you pass the tuple to the parameter to allow both GET and POST requests. GET requests are used to retrieve data from the server. POST requests are used to post data to a specific route. By default, only GET requests are allowed. When the user first requests the route using a GET request, a template file called will be rendered. You will later edit this route to handle POST requests for when users fill in and submit the web form for adding new students.\n\nAdd the following code to it:\n\nYou extend the base template, set a heading as a title, and use a tag with the attribute set to to indicate that the form will submit a POST request.\n\nYou have two text fields with the names and . You’ll use these names to access the form data the user submits in your view function later.\n\nYou have an email field with the name , a number field for the student’s age, and a text area for the student’s bio.\n\nLast, you have a Submit button at the end of the form.\n\nNow, with the development server running, use your browser to navigate to the route:\n\nYou will see an Add a New Student page with a web form and a Submit button like so:\n\nIf you fill in the form and submit it, sending a POST request to the server, nothing happens because you did not handle POST requests on the route.\n\nOpen to handle the POST request the user submits:\n\nEdit the route to look as follows:\n\nYou handle POST requests inside the condition. You extract the first name, last name, email, age, and bio the user submits from the object. You convert the age that gets passed as a string into an integer using the Python function. You construct a object using the model. You add the student object to the database session, then commit the transaction.\n\nLastly, you redirect the user to the index page where they can see the newly added student below the existing students.\n\nWith the development server running, use your browser to navigate to the route:\n\nFill in the form with some data and submit it.\n\nYou’ll be redirected to the index page where you’ll see your newly added student.\n\nNow that you have the functionality to add new students, you’ll need to add a link to the Create page in the navigation bar. Open :\n\nEdit the tag by modifying the value of the attribute for the link:\n\nRefresh your index page and you’ll notice the Create link in the navigation bar is now functional.\n\nYou now have a page with a web form for adding new students. For more on web forms, see How To Use Web Forms in a Flask Application. For a more advanced and more secure method of managing web forms, see How To Use and Validate Web Forms with Flask-WTF. Next, you’ll add a page for editing the data of existing students.\n\nIn this step, you’ll add a new page to your application for editing existing student data. You’ll add a new route to edit the data of students based on their ID.\n\nAdd the following route to the end of the file. This fetches the student entry you want to edit using its ID. It extracts the new student data submitted via a web form you’ll will create later. Then it edits the student data, and redirects the user to the index page:\n\nHere, you have the route that accepts both POST and GET methods, with as a URL variable that passes the ID to the view function.\n\nYou use the query method on the model to get the student associated with the given student ID. This will respond with a error in case no student with the given ID exists in the database.\n\nIf the given ID has a student associated with it, code execution continues to the condition. If the request was a GET request, meaning that the user did not submit a form, then this condition is false, and the code inside it will be skipped to the line . This renders an template, passing it the student object you got from the database, allowing you to fill the student web form with current student data. You will create this template later.\n\nWhen a user edits student data and submits the form, the code inside the is executed. You extract the submitted student data from the object into corresponding variables. You set each attribute of the object to the newly submitted data to change column values as you’ve done in Step 2. If no change was performed on a field on the web form, the value of that column will stay the same in the database.\n\nAfter you set the student data to the newly submitted data, you add the object to the database session, then you commit the changes. Lastly, you redirect the user to the index page.\n\nNext, you need to create a page where users can do the editing. Open a new template:\n\nThis new file will have a web form similar to the one that’s in the file with current student data as default values for the fields. Add the following code inside it:\n\nThe title has the student’s first name and last name. The attribute of each input field and the value of the bio text area are set to the corresponding value in the object you passed from the view function to the template.\n\nNow, navigate to the following URL to edit the first student’s details:\n\nYou will see a page similar to the following:\n\nEdit the student’s data and submit the form. You’ll be redirected to the index page, and the student’s information will be updated.\n\nNext, you’ll add an Edit button below each student on the index page to link to their edit page. Open the template file:\n\nEdit the loop in this file to look exactly like the following:\n\nHere you add an tag to link to the view function, passing in the value to link to the edit page of each student with an Edit link.\n\nYou now have a page for editing existing students. Next, you’ll add a Delete button to delete students from the database.\n\nIn this step, you’ll add a new route and Delete button for deleting existing students.\n\nFirst, you’ll add a new route that accepts POST requests. Your new view function will receive the ID of the student you want to delete, pass the ID to the query method on the model to get it if it exists, or respond with a page if no student with the given ID was found on the database.\n\nAdd the following route to the end of the file:\n\nHere, instead of using the usual decorator, you use the decorator introduced in Flask version 2.0.0, which added shortcuts for common HTTP methods. For example, is a shortcut for . This means that this view function only accepts POST requests, and navigating to the route on your browser will return a error, because web browsers default to GET requests. To delete a student, the user clicks on a button that sends a POST request to this route.\n\nThis view function receives the ID of the student to be deleted via the URL variable. You use the method to get a student and save it in a variable, or respond with a in case the student doesn’t exist. You use the method on the database session in the line , passing it the student object. This sets up the session to delete the student whenever the transaction is committed. Because you don’t need to perform any other modifications, you directly commit the transaction using . Lastly, you redirect the user to the index page.\n\nNext, edit the template to add a Delete Student button:\n\nEdit the loop by adding a new tag directly below the Edit link:\n\nHere, you have a web form that submits a POST request to the view function. You pass as an argument for the parameter to specify the student entry to be deleted. You use the method function available in web browsers to display a confirmation message before submitting the request.\n\nYou’ll see a Delete Student button below each student entry. Click on it, and confirm the deletion. You’ll be redirected to the index page, and the student will no longer be there.\n\nYou now have a way of deleting students from the database in your student management application.\n\nYou built a small Flask web application for managing students using Flask and Flask-SQLAlchemy with an SQLite database. You learned how to connect to your database, set up database models that represent your tables, add items to your database, query your table, and modify database data.\n\nUsing SQLAlchemy in your application allows you to use Python classes and objects to manage your SQL database. Instead of SQLite, you can use another database engine, and other than the configuration responsible for the connection, you don’t need to change anything in your core application code. That allows you to move from one SQL database engine to another with minimal code change. See the Flask-SQLAlchemy documentation for more information.\n\nIf you would like to read more about Flask, check out the other tutorials in the How To Build Web Applications with Flask series."
    },
    {
        "link": "https://geeksforgeeks.org/connect-flask-to-a-database-with-flask-sqlalchemy",
        "document": "Flask doesn’t have a built-in way to handle databases, so it relies on SQLAlchemy, a powerful library that makes working with databases easier. SQLAlchemy provides an Object Relational Mapper (ORM), allowing developers to interact with databases using Python code instead of raw SQL.\n• None Easily integrates with Flask using the Flask – SQLAlchemy extension.\n\nIn this article, we’ll build a Flask app where users submit a form, view the data on another page, and delete it if needed. The focus will be on the backend, not the front end.\n\nCreate the project folder and open the command line in the directory. Create a python virtual environment using the command below.\n\nAfter creating virtual environment, activate it by using the following command-\n\nNow, install Flask and Flask-SQLAlchemy in it using command:\n\nBelow is the snapshot of the file structure of the project after its completed.\n\nOnce the installation is complete, we can create our main Flask application file, app.py. To verify that everything is installed and running correctly, paste the basic app code below and start the application by running python app.py in the terminal (this code will be updated later).\n\nTo create a database we need to import SQLAlchemy in app.py, set up SQLite configuration, and create a database instance as shown below.\n\nWe set up Flask, connect it to a SQLite database (site.db), and use db.create_all() to create the database when the app runs. The app_context() ensures SQLAlchemy works properly.\n\nIn sqlalchemy we use classes to create our database structure. In our application, we will create a Profile table that will be responsible for holding the user’s id, first name, last name, and age.\n\nThe table below explains some of the keywords used in the model class.\n\nCreate an “index.html” file int the Templates folder. This will be our root page, it will display all the saved profiles in the database. Jinja templating will dynamically render the data in the HTML file. The delete function will be added later.\n\n\n\nWe loop through every object in profiles that we pass down to our template in our index function and print all its data in a tabular form. The index function in our app.py is updated as follows.\n\nIn the templates folder, create file “add_profile.html“, it will erender the form that taes user input for the profile details and the form will be linked to a “/add” route.\n\nThis route will receive the form data, create a user object and add it to the databse.\n\n\n\nTo check whether the code is working fine or not, we can run the following command to start the local server.\n\nNow, visit http://localhost:5000/add_data and you will be able to see the form.\n\nFunction to add data to the database\n\nCreate a “/add” route in app.py. In this route will use request objects to get form data inside the function then create an object of the Profile class and store it in our database using database sessions.\n\nOnce the function is executed it redirects us back to the index page of the application.\n\nTo delete data we have already used an anchor tag in our table and now we will just be associating a function with it.\n\nThe function queries data on the basis of id and then deletes it from our database.\n\nThe entire code for app.py, index.html, and add-profile.html is given below."
    }
]